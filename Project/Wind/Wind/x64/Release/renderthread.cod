; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.61030.0 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	?normalShaderProgram@@3PEAVShaderProgram@gfxu@@EA ; normalShaderProgram
PUBLIC	?bGrid@@3PAY1BB@BB@_NA				; bGrid
PUBLIC	?testure@@3PEAVTexture2D@gfxu@@EA		; testure
PUBLIC	?normalFShader@@3PEAVFragmentShader@gfxu@@EA	; normalFShader
PUBLIC	?noTexFShader@@3PEAVFragmentShader@gfxu@@EA	; noTexFShader
PUBLIC	?noTexShaderProgram@@3PEAVShaderProgram@gfxu@@EA ; noTexShaderProgram
PUBLIC	?grid@@3PEAVVertexStream@gfxu@@EA		; grid
PUBLIC	?normalVShader@@3PEAVVertexShader@gfxu@@EA	; normalVShader
PUBLIC	?noTexVShader@@3PEAVVertexShader@gfxu@@EA	; noTexVShader
PUBLIC	?square@@3PEAVVertexStream@gfxu@@EA		; square
PUBLIC	?skipRender@RenderThread@@2_NA			; RenderThread::skipRender
EXTRN	__imp_glFlush:PROC
EXTRN	__imp_glEnable:PROC
EXTRN	__imp_glViewport:PROC
EXTRN	__imp_glBlendFunc:PROC
EXTRN	__imp_glDisable:PROC
EXTRN	__imp_glClearColor:PROC
EXTRN	__imp_glClear:PROC
EXTRN	__imp_glDepthFunc:PROC
?normalShaderProgram@@3PEAVShaderProgram@gfxu@@EA DQ 01H DUP (?) ; normalShaderProgram
?bGrid@@3PAY1BB@BB@_NA DB 01331H DUP (?)		; bGrid
	ALIGN	8

?testure@@3PEAVTexture2D@gfxu@@EA DQ 01H DUP (?)	; testure
?normalFShader@@3PEAVFragmentShader@gfxu@@EA DQ 01H DUP (?) ; normalFShader
?noTexFShader@@3PEAVFragmentShader@gfxu@@EA DQ 01H DUP (?) ; noTexFShader
?noTexShaderProgram@@3PEAVShaderProgram@gfxu@@EA DQ 01H DUP (?) ; noTexShaderProgram
?grid@@3PEAVVertexStream@gfxu@@EA DQ 01H DUP (?)	; grid
?normalVShader@@3PEAVVertexShader@gfxu@@EA DQ 01H DUP (?) ; normalVShader
?noTexVShader@@3PEAVVertexShader@gfxu@@EA DQ 01H DUP (?) ; noTexVShader
?square@@3PEAVVertexStream@gfxu@@EA DQ 01H DUP (?)	; square
_BSS	ENDS
?skipRender@RenderThread@@2_NA DB 01H			; RenderThread::skipRender
_DATA	ENDS
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
	DB	00H						; `string'
	ORG $+2
renderDistance DD 08H
	ORG $+2
$SG4294950235 DB 'gridTransform', 00H
	ORG $+2
$SG4294950234 DB 'arrayInsideCheck', 00H
	ORG $+7
$SG4294950233 DB 'Graphics thread loop error', 00H
	ORG $+5
$SG4294950232 DB '\', 00H, 'p', 00H, 'r', 00H, 'o', 00H, 'g', 00H, 'r', 00H
	DB	'a', 00H, 'm', 00H, 's', 00H, '\', 00H, 'f', 00H, 'r', 00H, 'u'
	DB	00H, 's', 00H, 't', 00H, 'u', 00H, 'm', 00H, 'c', 00H, 'l', 00H
	DB	'i', 00H, 'p', 00H, '.', 00H, 'c', 00H, 'l', 00H, 00H, 00H
	ORG $+6
$SG4294950231 DB '\', 00H, 's', 00H, 'h', 00H, 'a', 00H, 'd', 00H, 'e', 00H
	DB	'r', 00H, 's', 00H, '\', 00H, 'n', 00H, 'o', 00H, 'r', 00H, 'm'
	DB	00H, 'a', 00H, 'l', 00H, '.', 00H, 'v', 00H, 'e', 00H, 'r', 00H
	DB	't', 00H, 00H, 00H
	ORG $+6
$SG4294950230 DB '\', 00H, 's', 00H, 'h', 00H, 'a', 00H, 'd', 00H, 'e', 00H
	DB	'r', 00H, 's', 00H, '\', 00H, 'n', 00H, 'o', 00H, 'r', 00H, 'm'
	DB	00H, 'a', 00H, 'l', 00H, '.', 00H, 'f', 00H, 'r', 00H, 'a', 00H
	DB	'g', 00H, 00H, 00H
	ORG $+6
$SG4294950229 DB '\', 00H, 's', 00H, 'h', 00H, 'a', 00H, 'd', 00H, 'e', 00H
	DB	'r', 00H, 's', 00H, '\', 00H, 'n', 00H, 'o', 00H, 'T', 00H, 'e'
	DB	00H, 'x', 00H, '.', 00H, 'v', 00H, 'e', 00H, 'r', 00H, 't', 00H
	DB	00H, 00H
$SG4294950228 DB '\', 00H, 's', 00H, 'h', 00H, 'a', 00H, 'd', 00H, 'e', 00H
	DB	'r', 00H, 's', 00H, '\', 00H, 'n', 00H, 'o', 00H, 'T', 00H, 'e'
	DB	00H, 'x', 00H, '.', 00H, 'f', 00H, 'r', 00H, 'a', 00H, 'g', 00H
	DB	00H, 00H
$SG4294950227 DB '\', 00H, 't', 00H, 'e', 00H, 'x', 00H, 't', 00H, 'u', 00H
	DB	'r', 00H, 'e', 00H, 's', 00H, '\', 00H, 't', 00H, 'e', 00H, 's'
	DB	00H, 't', 00H, '.', 00H, 'p', 00H, 'n', 00H, 'g', 00H, 00H, 00H
PUBLIC	??$_Move@AEAPEAVChunkBase@@@std@@YA$$QEAPEAVChunkBase@@AEAPEAV1@@Z ; std::_Move<ChunkBase * __ptr64 & __ptr64>
PUBLIC	??$swap@PEAVChunkBase@@@std@@YAXAEAPEAVChunkBase@@0@Z ; std::swap<ChunkBase * __ptr64>
PUBLIC	??$forward@V?$_Ptr_base@VChunkBase@@@std@@@std@@YA$$QEAV?$_Ptr_base@VChunkBase@@@0@AEAV10@@Z ; std::forward<std::_Ptr_base<ChunkBase> >
PUBLIC	?_Swap@?$_Ptr_base@VChunkBase@@@std@@QEAAXAEAV12@@Z ; std::_Ptr_base<ChunkBase>::_Swap
PUBLIC	?_Assign_rv@?$_Ptr_base@VChunkBase@@@std@@QEAAX$$QEAV12@@Z ; std::_Ptr_base<ChunkBase>::_Assign_rv
PUBLIC	??0?$_Ptr_base@VChunkBase@@@std@@QEAA@$$QEAV01@@Z ; std::_Ptr_base<ChunkBase>::_Ptr_base<ChunkBase>
PUBLIC	??0?$shared_ptr@VChunkBase@@@std@@QEAA@$$QEAV01@@Z ; std::shared_ptr<ChunkBase>::shared_ptr<ChunkBase>
PUBLIC	??$construct@V?$shared_ptr@VChunkBase@@@std@@V12@@?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAAXPEAV?$shared_ptr@VChunkBase@@@1@$$QEAV21@@Z ; std::allocator<std::shared_ptr<ChunkBase> >::construct<std::shared_ptr<ChunkBase>,std::shared_ptr<ChunkBase> >
PUBLIC	??$construct@V?$shared_ptr@VChunkBase@@@std@@V12@@?$allocator_traits@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$shared_ptr@VChunkBase@@@std@@@1@PEAV?$shared_ptr@VChunkBase@@@1@$$QEAV31@@Z ; std::allocator_traits<std::allocator<std::shared_ptr<ChunkBase> > >::construct<std::shared_ptr<ChunkBase>,std::shared_ptr<ChunkBase> >
PUBLIC	??$forward@V?$shared_ptr@VChunkBase@@@std@@@std@@YA$$QEAV?$shared_ptr@VChunkBase@@@0@AEAV10@@Z ; std::forward<std::shared_ptr<ChunkBase> >
PUBLIC	??$construct@V?$shared_ptr@VChunkBase@@@std@@V12@@?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QEAAXPEAV?$shared_ptr@VChunkBase@@@1@$$QEAV21@@Z ; std::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> > >::construct<std::shared_ptr<ChunkBase>,std::shared_ptr<ChunkBase> >
PUBLIC	??$_Uninit_move@PEAV?$shared_ptr@VChunkBase@@@std@@PEAV12@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@V12@@std@@YAPEAV?$shared_ptr@VChunkBase@@@0@PEAV10@00AEAU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<std::shared_ptr<ChunkBase> * __ptr64,std::shared_ptr<ChunkBase> * __ptr64,std::allocator<std::shared_ptr<ChunkBase> >,std::shared_ptr<ChunkBase> >
PUBLIC	??$_Val_type@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@YAPEAV?$shared_ptr@VChunkBase@@@0@PEAV10@@Z ; std::_Val_type<std::shared_ptr<ChunkBase> * __ptr64>
PUBLIC	??$construct@V?$shared_ptr@VChunkBase@@@std@@AEAV12@@?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAAXPEAV?$shared_ptr@VChunkBase@@@1@AEAV21@@Z ; std::allocator<std::shared_ptr<ChunkBase> >::construct<std::shared_ptr<ChunkBase>,std::shared_ptr<ChunkBase> & __ptr64>
PUBLIC	??$_Uninitialized_move@PEAV?$shared_ptr@VChunkBase@@@std@@PEAV12@U?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@YAPEAV?$shared_ptr@VChunkBase@@@0@PEAV10@00AEAU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@0@@Z ; std::_Uninitialized_move<std::shared_ptr<ChunkBase> * __ptr64,std::shared_ptr<ChunkBase> * __ptr64,std::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> > > >
PUBLIC	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@YAXPEAV?$shared_ptr@VChunkBase@@@0@0AEAU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> > > >
PUBLIC	??$_Ptr_cat@V?$shared_ptr@VChunkBase@@@std@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PEAV?$shared_ptr@VChunkBase@@@0@0@Z ; std::_Ptr_cat<std::shared_ptr<ChunkBase>,std::shared_ptr<ChunkBase> >
PUBLIC	??$?8_W_W@std@@YA_NAEBV?$allocator@_W@0@0@Z	; std::operator==<wchar_t,wchar_t>
PUBLIC	??$construct@V?$shared_ptr@VChunkBase@@@std@@AEAV12@@?$allocator_traits@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$shared_ptr@VChunkBase@@@std@@@1@PEAV?$shared_ptr@VChunkBase@@@1@AEAV31@@Z ; std::allocator_traits<std::allocator<std::shared_ptr<ChunkBase> > >::construct<std::shared_ptr<ChunkBase>,std::shared_ptr<ChunkBase> & __ptr64>
PUBLIC	??$forward@AEAV?$shared_ptr@VChunkBase@@@std@@@std@@YAAEAV?$shared_ptr@VChunkBase@@@0@AEAV10@@Z ; std::forward<std::shared_ptr<ChunkBase> & __ptr64>
PUBLIC	??$?8V?$allocator@_W@std@@V01@@std@@YA_NAEBU?$_Wrap_alloc@V?$allocator@_W@std@@@0@0@Z ; std::operator==<std::allocator<wchar_t>,std::allocator<wchar_t> >
PUBLIC	??$_Umove@PEAV?$shared_ptr@VChunkBase@@@std@@@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAPEAV?$shared_ptr@VChunkBase@@@1@PEAV21@00@Z ; std::vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::_Umove<std::shared_ptr<ChunkBase> * __ptr64>
PUBLIC	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@YAXPEAV?$shared_ptr@VChunkBase@@@0@0AEAU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> > > >
PUBLIC	??$addressof@$$CBU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@YAPEBU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@0@AEBU10@@Z ; std::addressof<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > const >
PUBLIC	??$construct@V?$shared_ptr@VChunkBase@@@std@@AEAV12@@?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QEAAXPEAV?$shared_ptr@VChunkBase@@@1@AEAV21@@Z ; std::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> > >::construct<std::shared_ptr<ChunkBase>,std::shared_ptr<ChunkBase> & __ptr64>
PUBLIC	??$addressof@$$CBV?$shared_ptr@VChunkBase@@@std@@@std@@YAPEBV?$shared_ptr@VChunkBase@@@0@AEBV10@@Z ; std::addressof<std::shared_ptr<ChunkBase> const >
PUBLIC	??$?9V?$allocator@_W@std@@V01@@std@@YA_NAEBU?$_Wrap_alloc@V?$allocator@_W@std@@@0@0@Z ; std::operator!=<std::allocator<wchar_t>,std::allocator<wchar_t> >
PUBLIC	??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@PEBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@1@@Z ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >,std::_Iterator_base0>
PUBLIC	?capacity@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEBA_KXZ ; std::vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::capacity
PUBLIC	?deallocate@?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAAXPEAV?$shared_ptr@VChunkBase@@@2@_K@Z ; std::allocator<std::shared_ptr<ChunkBase> >::deallocate
PUBLIC	?_Inside@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA_NPEB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Inside
PUBLIC	?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@AEBV12@_K1@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append
PUBLIC	??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@PEBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@1@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >
PUBLIC	??0?$_Vector_val@U?$_Simple_types@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QEAA@XZ ; std::_Vector_val<std::_Simple_types<std::shared_ptr<ChunkBase> > >::_Vector_val<std::_Simple_types<std::shared_ptr<ChunkBase> > >
PUBLIC	?_Xlen@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEBAXXZ ; std::vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::_Xlen
PUBLIC	?_Reallocate@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAX_K@Z ; std::vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::_Reallocate
PUBLIC	?_Grow_to@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEBA_K_K@Z ; std::vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::_Grow_to
PUBLIC	?_Destroy@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAXPEAV?$shared_ptr@VChunkBase@@@2@0@Z ; std::vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::_Destroy
PUBLIC	?max_size@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEBA_KXZ ; std::vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::max_size
PUBLIC	?_Unused_capacity@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEBA_KXZ ; std::vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::_Unused_capacity
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QEAAXPEAV?$shared_ptr@VChunkBase@@@2@_K@Z ; std::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> > >::deallocate
PUBLIC	?_Min@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@SAPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@PEAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::_Min
PUBLIC	?_Myval@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@SAAEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@2@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::_Myval
PUBLIC	?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@SAAEAPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@PEAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::_Right
PUBLIC	?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@SAAEAPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@PEAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::_Parent
PUBLIC	?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@SAAEAPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@PEAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::_Left
PUBLIC	?_Isnil@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@SAAEADPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::_Isnil
PUBLIC	?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@PEB_W_K@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append
PUBLIC	?pointer_to@?$pointer_traits@PEBU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@SAPEBU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@2@AEBU32@@Z ; std::pointer_traits<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > const * __ptr64>::pointer_to
PUBLIC	??0?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@PEBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@1@@Z ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >
PUBLIC	??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >,std::_Iterator_base0>::operator++
PUBLIC	??8?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::operator==
PUBLIC	??D?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QEBAAEBU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::operator*
PUBLIC	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@@std@@QEBA?AU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > > >::_Getal
PUBLIC	??0?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@@std@@QEAA@AEBV?$allocator@V?$shared_ptr@VChunkBase@@@std@@@1@@Z ; std::_Vector_alloc<0,std::_Vec_base_types<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > > >::_Vector_alloc<0,std::_Vec_base_types<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > > >
PUBLIC	?_Orphan_range@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEBAXPEAV?$shared_ptr@VChunkBase@@@2@0@Z ; std::vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::_Orphan_range
PUBLIC	?_Tidy@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAXXZ ; std::vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::_Tidy
PUBLIC	?_Reserve@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAX_K@Z ; std::vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::_Reserve
PUBLIC	?_Inside@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEBA_NPEBV?$shared_ptr@VChunkBase@@@2@@Z ; std::vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::_Inside
PUBLIC	?clear@?$List@PEAVTask@Tasks@@$0BAA@@@QEAAXXZ	; List<Tasks::Task * __ptr64,256>::clear
PUBLIC	?getSize@?$List@PEAVTask@Tasks@@$0BAA@@@QEAAHXZ	; List<Tasks::Task * __ptr64,256>::getSize
PUBLIC	??A?$List@PEAVTask@Tasks@@$0BAA@@@QEAAAEAPEAVTask@Tasks@@H@Z ; List<Tasks::Task * __ptr64,256>::operator[]
PUBLIC	?_Lmost@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEBAAEAPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@XZ ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Lmost
PUBLIC	?_Get@?$_Ptr_base@VVertexStream@gfxu@@@std@@QEBAPEAVVertexStream@gfxu@@XZ ; std::_Ptr_base<gfxu::VertexStream>::_Get
PUBLIC	?_Change_alloc@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QEAAXAEBU?$_Wrap_alloc@V?$allocator@_W@std@@@2@@Z ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Change_alloc
PUBLIC	?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@AEBV12@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
PUBLIC	?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@PEB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append
PUBLIC	??9?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::operator!=
PUBLIC	??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QEAAAEAV01@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::operator++
PUBLIC	??C?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QEBAPEBU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::operator->
PUBLIC	?push_back@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAAXAEBV?$shared_ptr@VChunkBase@@@2@@Z ; std::vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::push_back
PUBLIC	??A?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAAAEAV?$shared_ptr@VChunkBase@@@1@_K@Z ; std::vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::operator[]
PUBLIC	?size@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEBA_KXZ ; std::vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::size
PUBLIC	??1?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAA@XZ ; std::vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::~vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >
PUBLIC	??0?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAA@XZ ; std::vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >
PUBLIC	?clear@?$VirtualList@VTask@Tasks@@$0BAA@$0BAAC@@@QEAAXXZ ; VirtualList<Tasks::Task,256,4098>::clear
PUBLIC	?getSize@?$VirtualList@VTask@Tasks@@$0BAA@$0BAAC@@@QEAAHXZ ; VirtualList<Tasks::Task,256,4098>::getSize
PUBLIC	??A?$VirtualList@VTask@Tasks@@$0BAA@$0BAAC@@@QEAAPEAVTask@Tasks@@H@Z ; VirtualList<Tasks::Task,256,4098>::operator[]
PUBLIC	?end@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::end
PUBLIC	?begin@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::begin
PUBLIC	??B?$shared_ptr@VVertexStream@gfxu@@@std@@QEBAPEQ?$_Bool_struct@V?$shared_ptr@VVertexStream@gfxu@@@std@@@1@HXZ ; std::shared_ptr<gfxu::VertexStream>::operator int std::_Bool_struct<std::shared_ptr<gfxu::VertexStream> >::* __ptr64
PUBLIC	??C?$shared_ptr@VVertexStream@gfxu@@@std@@QEBAPEAVVertexStream@gfxu@@XZ ; std::shared_ptr<gfxu::VertexStream>::operator->
PUBLIC	?set@?$Uniform@M@gfxu@@QEAAXM@Z			; gfxu::Uniform<float>::set
PUBLIC	?set@?$Uniform@VVector@geom@@@gfxu@@QEAAXVVector@geom@@@Z ; gfxu::Uniform<geom::Vector>::set
PUBLIC	??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV01@PEB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::operator+=
PUBLIC	??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV01@AEBV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::operator=
PUBLIC	??1FragmentShader@gfxu@@QEAA@XZ			; gfxu::FragmentShader::~FragmentShader
PUBLIC	??1VertexShader@gfxu@@QEAA@XZ			; gfxu::VertexShader::~VertexShader
PUBLIC	??_GTexture2D@gfxu@@QEAAPEAXI@Z			; gfxu::Texture2D::`scalar deleting destructor'
PUBLIC	??_GShaderProgram@gfxu@@QEAAPEAXI@Z		; gfxu::ShaderProgram::`scalar deleting destructor'
PUBLIC	??_GFragmentShader@gfxu@@QEAAPEAXI@Z		; gfxu::FragmentShader::`scalar deleting destructor'
PUBLIC	??_GVertexShader@gfxu@@QEAAPEAXI@Z		; gfxu::VertexShader::`scalar deleting destructor'
PUBLIC	?postStop@RenderThread@@UEAAXXZ			; RenderThread::postStop
PUBLIC	?preStart@RenderThread@@UEAAXXZ			; RenderThread::preStart
PUBLIC	?tick@RenderThread@@EEAA_NXZ			; RenderThread::tick
PUBLIC	?_Orphan_all@_Container_base0@std@@QEAAXXZ	; std::_Container_base0::_Orphan_all
PUBLIC	?length@?$char_traits@_W@std@@SA_KPEB_W@Z	; std::char_traits<wchar_t>::length
PUBLIC	?program@@3VProgram@cl@@A			; program
PUBLIC	?gridBuffer@@3VBuffer@cl@@A			; gridBuffer
PUBLIC	?projectionMatrixBuffer@@3VBuffer@cl@@A		; projectionMatrixBuffer
PUBLIC	?commandQueue@@3VCommandQueue@cl@@A		; commandQueue
PUBLIC	?boolBuffer@@3VBuffer@cl@@A			; boolBuffer
	ALIGN	4

_Tuple_alloc DB	01H DUP (?)
	ALIGN	4

ignore	DB	01H DUP (?)
	ALIGN	4

?program@@3VProgram@cl@@A DB 030H DUP (?)		; program
allocator_arg DB 01H DUP (?)
	ALIGN	4

?gridBuffer@@3VBuffer@cl@@A DB 018H DUP (?)		; gridBuffer
?projectionMatrixBuffer@@3VBuffer@cl@@A DB 018H DUP (?)	; projectionMatrixBuffer
piecewise_construct DB 01H DUP (?)
	ALIGN	4

?commandQueue@@3VCommandQueue@cl@@A DB 010H DUP (?)	; commandQueue
?boolBuffer@@3VBuffer@cl@@A DB 018H DUP (?)		; boolBuffer
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_move@PEAV?$shared_ptr@VChunkBase@@@std@@PEAV12@U?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@YAPEAV?$shared_ptr@VChunkBase@@@0@PEAV10@00AEAU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@0@@Z DD imagerel $LN8
	DD	imagerel $LN8+14
	DD	imagerel $unwind$??$_Uninitialized_move@PEAV?$shared_ptr@VChunkBase@@@std@@PEAV12@U?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@YAPEAV?$shared_ptr@VChunkBase@@@0@PEAV10@00AEAU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@YAXPEAV?$shared_ptr@VChunkBase@@@0@0AEAU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z DD imagerel $LN31
	DD	imagerel $LN31+10
	DD	imagerel $unwind$??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@YAXPEAV?$shared_ptr@VChunkBase@@@0@0AEAU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@YAXPEAV?$shared_ptr@VChunkBase@@@0@0AEAU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z DD imagerel $LN31+10
	DD	imagerel $LN31+97
	DD	imagerel $chain$1$??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@YAXPEAV?$shared_ptr@VChunkBase@@@0@0AEAU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@YAXPEAV?$shared_ptr@VChunkBase@@@0@0AEAU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z DD imagerel $LN31+97
	DD	imagerel $LN31+99
	DD	imagerel $chain$2$??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@YAXPEAV?$shared_ptr@VChunkBase@@@0@0AEAU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Umove@PEAV?$shared_ptr@VChunkBase@@@std@@@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAPEAV?$shared_ptr@VChunkBase@@@1@PEAV21@00@Z DD imagerel $LN10
	DD	imagerel $LN10+26
	DD	imagerel $unwind$??$_Umove@PEAV?$shared_ptr@VChunkBase@@@std@@@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAPEAV?$shared_ptr@VChunkBase@@@1@PEAV21@00@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@YAXPEAV?$shared_ptr@VChunkBase@@@0@0AEAU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@0@@Z DD imagerel $LN35
	DD	imagerel $LN35+10
	DD	imagerel $unwind$??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@YAXPEAV?$shared_ptr@VChunkBase@@@0@0AEAU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@YAXPEAV?$shared_ptr@VChunkBase@@@0@0AEAU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@0@@Z DD imagerel $LN35+10
	DD	imagerel $LN35+97
	DD	imagerel $chain$1$??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@YAXPEAV?$shared_ptr@VChunkBase@@@0@0AEAU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@YAXPEAV?$shared_ptr@VChunkBase@@@0@0AEAU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@0@@Z DD imagerel $LN35+97
	DD	imagerel $LN35+99
	DD	imagerel $chain$2$??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@YAXPEAV?$shared_ptr@VChunkBase@@@0@0AEAU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@AEBV12@_K1@Z DD imagerel $LN119
	DD	imagerel $LN119+76
	DD	imagerel $unwind$?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@AEBV12@_K1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@AEBV12@_K1@Z DD imagerel $LN119+76
	DD	imagerel $LN119+277
	DD	imagerel $chain$0$?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@AEBV12@_K1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@AEBV12@_K1@Z DD imagerel $LN119+277
	DD	imagerel $LN119+303
	DD	imagerel $chain$1$?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@AEBV12@_K1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@AEBV12@_K1@Z DD imagerel $LN119+303
	DD	imagerel $LN119+316
	DD	imagerel $chain$2$?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@AEBV12@_K1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Xlen@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEBAXXZ DD imagerel $LN4
	DD	imagerel $LN4+17
	DD	imagerel $unwind$?_Xlen@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEBAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Reallocate@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAX_K@Z DD imagerel $LN85
	DD	imagerel $LN85+74
	DD	imagerel $unwind$?_Reallocate@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?_Reallocate@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAX_K@Z DD imagerel $LN85+74
	DD	imagerel $LN85+120
	DD	imagerel $chain$2$?_Reallocate@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?_Reallocate@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAX_K@Z DD imagerel $LN85+120
	DD	imagerel $LN85+180
	DD	imagerel $chain$3$?_Reallocate@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$?_Reallocate@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAX_K@Z DD imagerel $LN85+180
	DD	imagerel $LN85+238
	DD	imagerel $chain$4$?_Reallocate@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$?_Reallocate@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAX_K@Z DD imagerel $LN85+238
	DD	imagerel $LN85+244
	DD	imagerel $chain$5$?_Reallocate@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Destroy@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAXPEAV?$shared_ptr@VChunkBase@@@2@0@Z DD imagerel $LN37
	DD	imagerel $LN37+10
	DD	imagerel $unwind$?_Destroy@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAXPEAV?$shared_ptr@VChunkBase@@@2@0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?_Destroy@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAXPEAV?$shared_ptr@VChunkBase@@@2@0@Z DD imagerel $LN37+10
	DD	imagerel $LN37+97
	DD	imagerel $chain$1$?_Destroy@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAXPEAV?$shared_ptr@VChunkBase@@@2@0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?_Destroy@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAXPEAV?$shared_ptr@VChunkBase@@@2@0@Z DD imagerel $LN37+97
	DD	imagerel $LN37+99
	DD	imagerel $chain$2$?_Destroy@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAXPEAV?$shared_ptr@VChunkBase@@@2@0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@PEB_W_K@Z DD imagerel $LN129
	DD	imagerel $LN129+148
	DD	imagerel $unwind$?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@PEB_W_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@PEB_W_K@Z DD imagerel $LN129+148
	DD	imagerel $LN129+333
	DD	imagerel $chain$0$?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@PEB_W_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@PEB_W_K@Z DD imagerel $LN129+333
	DD	imagerel $LN129+346
	DD	imagerel $chain$1$?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@PEB_W_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@PEB_W_K@Z DD imagerel $LN129+346
	DD	imagerel $LN129+359
	DD	imagerel $chain$2$?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@PEB_W_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAXXZ DD imagerel $LN47
	DD	imagerel $LN47+21
	DD	imagerel $unwind$?_Tidy@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?_Tidy@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAXXZ DD imagerel $LN47+21
	DD	imagerel $LN47+35
	DD	imagerel $chain$0$?_Tidy@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?_Tidy@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAXXZ DD imagerel $LN47+35
	DD	imagerel $LN47+100
	DD	imagerel $chain$1$?_Tidy@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?_Tidy@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAXXZ DD imagerel $LN47+100
	DD	imagerel $LN47+126
	DD	imagerel $chain$2$?_Tidy@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?_Tidy@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAXXZ DD imagerel $LN47+126
	DD	imagerel $LN47+137
	DD	imagerel $chain$3$?_Tidy@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Reserve@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAX_K@Z DD imagerel $LN44
	DD	imagerel $LN44+139
	DD	imagerel $unwind$?_Reserve@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?push_back@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAAXAEBV?$shared_ptr@VChunkBase@@@2@@Z DD imagerel $LN80
	DD	imagerel $LN80+129
	DD	imagerel $unwind$?push_back@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAAXAEBV?$shared_ptr@VChunkBase@@@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV01@AEBV01@@Z DD imagerel $LN59
	DD	imagerel $LN59+35
	DD	imagerel $unwind$??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV01@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1FragmentShader@gfxu@@QEAA@XZ DD imagerel $LN42
	DD	imagerel $LN42+88
	DD	imagerel $unwind$??1FragmentShader@gfxu@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1VertexShader@gfxu@@QEAA@XZ DD imagerel $LN42
	DD	imagerel $LN42+88
	DD	imagerel $unwind$??1VertexShader@gfxu@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_GTexture2D@gfxu@@QEAAPEAXI@Z DD imagerel $LN9
	DD	imagerel $LN9+60
	DD	imagerel $unwind$??_GTexture2D@gfxu@@QEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_GShaderProgram@gfxu@@QEAAPEAXI@Z DD imagerel $LN7
	DD	imagerel $LN7+43
	DD	imagerel $unwind$??_GShaderProgram@gfxu@@QEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_GFragmentShader@gfxu@@QEAAPEAXI@Z DD imagerel $LN45
	DD	imagerel $LN45+99
	DD	imagerel $unwind$??_GFragmentShader@gfxu@@QEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_GVertexShader@gfxu@@QEAAPEAXI@Z DD imagerel $LN45
	DD	imagerel $LN45+99
	DD	imagerel $unwind$??_GVertexShader@gfxu@@QEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?postStop@RenderThread@@UEAAXXZ DD imagerel $LN44
	DD	imagerel $LN44+292
	DD	imagerel $unwind$?postStop@RenderThread@@UEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?preStart@RenderThread@@UEAAXXZ DD imagerel $LN901
	DD	imagerel $LN901+2556
	DD	imagerel $unwind$?preStart@RenderThread@@UEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?tick@RenderThread@@EEAA_NXZ DD imagerel $LN1695
	DD	imagerel $LN1695+8404
	DD	imagerel $unwind$?tick@RenderThread@@EEAA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__FgridBuffer@@YAXXZ DD imagerel ??__FgridBuffer@@YAXXZ
	DD	imagerel ??__FgridBuffer@@YAXXZ+58
	DD	imagerel $unwind$??__FgridBuffer@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__FboolBuffer@@YAXXZ DD imagerel ??__FboolBuffer@@YAXXZ
	DD	imagerel ??__FboolBuffer@@YAXXZ+58
	DD	imagerel $unwind$??__FboolBuffer@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__FprojectionMatrixBuffer@@YAXXZ DD imagerel ??__FprojectionMatrixBuffer@@YAXXZ
	DD	imagerel ??__FprojectionMatrixBuffer@@YAXXZ+58
	DD	imagerel $unwind$??__FprojectionMatrixBuffer@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__Eprogram@@YAXXZ DD imagerel ??__Eprogram@@YAXXZ
	DD	imagerel ??__Eprogram@@YAXXZ+76
	DD	imagerel $unwind$??__Eprogram@@YAXXZ
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??__Eprogram@@YAXXZ DD imagerel ??__Eprogram@@YAXXZ
	DD	0ffffffffH
	DD	imagerel ??__Eprogram@@YAXXZ+25
	DD	00H
	DD	imagerel ??__Eprogram@@YAXXZ+60
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??__Eprogram@@YAXXZ DD 0ffffffffH
	DD	imagerel ?dtor$0@?0???__Eprogram@@YAXXZ@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??__Eprogram@@YAXXZ DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$??__Eprogram@@YAXXZ
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$??__Eprogram@@YAXXZ
	DD	020H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__Eprogram@@YAXXZ DD 010d11H
	DD	06204H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??__Eprogram@@YAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__FprojectionMatrixBuffer@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__FboolBuffer@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__FgridBuffer@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?tick@RenderThread@@EEAA_NXZ DD imagerel ?tick@RenderThread@@EEAA_NXZ
	DD	0ffffffffH
	DD	imagerel ?tick@RenderThread@@EEAA_NXZ+4807
	DD	00H
	DD	imagerel ?tick@RenderThread@@EEAA_NXZ+4973
	DD	01H
	DD	imagerel ?tick@RenderThread@@EEAA_NXZ+5121
	DD	00H
	DD	imagerel ?tick@RenderThread@@EEAA_NXZ+5166
	DD	01H
	DD	imagerel ?tick@RenderThread@@EEAA_NXZ+5251
	DD	00H
	DD	imagerel ?tick@RenderThread@@EEAA_NXZ+5290
	DD	0ffffffffH
	DD	imagerel ?tick@RenderThread@@EEAA_NXZ+5496
	DD	02H
	DD	imagerel ?tick@RenderThread@@EEAA_NXZ+6150
	DD	0ffffffffH
	DD	imagerel ?tick@RenderThread@@EEAA_NXZ+6241
	DD	03H
	DD	imagerel ?tick@RenderThread@@EEAA_NXZ+6302
	DD	04H
	DD	imagerel ?tick@RenderThread@@EEAA_NXZ+6642
	DD	03H
	DD	imagerel ?tick@RenderThread@@EEAA_NXZ+6866
	DD	05H
	DD	imagerel ?tick@RenderThread@@EEAA_NXZ+7126
	DD	03H
	DD	imagerel ?tick@RenderThread@@EEAA_NXZ+7243
	DD	06H
	DD	imagerel ?tick@RenderThread@@EEAA_NXZ+7501
	DD	03H
	DD	imagerel ?tick@RenderThread@@EEAA_NXZ+8334
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?tick@RenderThread@@EEAA_NXZ DD 0ffffffffH
	DD	imagerel ?dtor$2@?0??tick@RenderThread@@EEAA_NXZ@4HA
	DD	00H
	DD	imagerel ?dtor$9@?0??tick@RenderThread@@EEAA_NXZ@4HA
	DD	0ffffffffH
	DD	imagerel ?dtor$4@?0??tick@RenderThread@@EEAA_NXZ@4HA
	DD	0ffffffffH
	DD	imagerel ?dtor$5@?0??tick@RenderThread@@EEAA_NXZ@4HA
	DD	03H
	DD	imagerel ?dtor$6@?0??tick@RenderThread@@EEAA_NXZ@4HA
	DD	03H
	DD	imagerel ?dtor$7@?0??tick@RenderThread@@EEAA_NXZ@4HA
	DD	03H
	DD	imagerel ?dtor$8@?0??tick@RenderThread@@EEAA_NXZ@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?tick@RenderThread@@EEAA_NXZ DD 019930522H
	DD	07H
	DD	imagerel $stateUnwindMap$?tick@RenderThread@@EEAA_NXZ
	DD	00H
	DD	00H
	DD	011H
	DD	imagerel $ip2state$?tick@RenderThread@@EEAA_NXZ
	DD	0188H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?tick@RenderThread@@EEAA_NXZ DD 0114a19H
	DD	0737839H
	DD	0746835H
	DD	0f37431H
	DD	0f2642dH
	DD	0f13429H
	DD	0ea011aH
	DD	0e00af00cH
	DD	0c006d008H
	DD	05004H
	DD	imagerel __GSHandlerCheck_EH
	DD	imagerel $cppxdata$?tick@RenderThread@@EEAA_NXZ
	DD	0722H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?preStart@RenderThread@@UEAAXXZ DD imagerel ?preStart@RenderThread@@UEAAXXZ
	DD	0ffffffffH
	DD	imagerel ?preStart@RenderThread@@UEAAXXZ+434
	DD	00H
	DD	imagerel ?preStart@RenderThread@@UEAAXXZ+1682
	DD	01H
	DD	imagerel ?preStart@RenderThread@@UEAAXXZ+1740
	DD	00H
	DD	imagerel ?preStart@RenderThread@@UEAAXXZ+1809
	DD	02H
	DD	imagerel ?preStart@RenderThread@@UEAAXXZ+1867
	DD	00H
	DD	imagerel ?preStart@RenderThread@@UEAAXXZ+1891
	DD	03H
	DD	imagerel ?preStart@RenderThread@@UEAAXXZ+1938
	DD	00H
	DD	imagerel ?preStart@RenderThread@@UEAAXXZ+2007
	DD	04H
	DD	imagerel ?preStart@RenderThread@@UEAAXXZ+2065
	DD	00H
	DD	imagerel ?preStart@RenderThread@@UEAAXXZ+2134
	DD	05H
	DD	imagerel ?preStart@RenderThread@@UEAAXXZ+2192
	DD	00H
	DD	imagerel ?preStart@RenderThread@@UEAAXXZ+2216
	DD	06H
	DD	imagerel ?preStart@RenderThread@@UEAAXXZ+2263
	DD	00H
	DD	imagerel ?preStart@RenderThread@@UEAAXXZ+2356
	DD	07H
	DD	imagerel ?preStart@RenderThread@@UEAAXXZ+2412
	DD	00H
	DD	imagerel ?preStart@RenderThread@@UEAAXXZ+2484
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?preStart@RenderThread@@UEAAXXZ DD 0ffffffffH
	DD	imagerel ?dtor$0@?0??preStart@RenderThread@@UEAAXXZ@4HA
	DD	00H
	DD	imagerel ?dtor$4@?0??preStart@RenderThread@@UEAAXXZ@4HA
	DD	00H
	DD	imagerel ?dtor$6@?0??preStart@RenderThread@@UEAAXXZ@4HA
	DD	00H
	DD	imagerel ?dtor$8@?0??preStart@RenderThread@@UEAAXXZ@4HA
	DD	00H
	DD	imagerel ?dtor$9@?0??preStart@RenderThread@@UEAAXXZ@4HA
	DD	00H
	DD	imagerel ?dtor$11@?0??preStart@RenderThread@@UEAAXXZ@4HA
	DD	00H
	DD	imagerel ?dtor$13@?0??preStart@RenderThread@@UEAAXXZ@4HA
	DD	00H
	DD	imagerel ?dtor$14@?0??preStart@RenderThread@@UEAAXXZ@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?preStart@RenderThread@@UEAAXXZ DD 019930522H
	DD	08H
	DD	imagerel $stateUnwindMap$?preStart@RenderThread@@UEAAXXZ
	DD	00H
	DD	00H
	DD	011H
	DD	imagerel $ip2state$?preStart@RenderThread@@UEAAXXZ
	DD	060H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?preStart@RenderThread@@UEAAXXZ DD 0114219H
	DD	098834H
	DD	0a782fH
	DD	0b682bH
	DD	01e7427H
	DD	01d6423H
	DD	01c341fH
	DD	0180113H
	DD	0e006f008H
	DD	05004H
	DD	imagerel __GSHandlerCheck_EH
	DD	imagerel $cppxdata$?preStart@RenderThread@@UEAAXXZ
	DD	08aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?postStop@RenderThread@@UEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??_GVertexShader@gfxu@@QEAAPEAXI@Z DD imagerel ??_GVertexShader@gfxu@@QEAAPEAXI@Z
	DD	0ffffffffH
	DD	imagerel ??_GVertexShader@gfxu@@QEAAPEAXI@Z+32
	DD	00H
	DD	imagerel ??_GVertexShader@gfxu@@QEAAPEAXI@Z+48
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??_GVertexShader@gfxu@@QEAAPEAXI@Z DD 0ffffffffH
	DD	imagerel ?dtor$1@?0???_GVertexShader@gfxu@@QEAAPEAXI@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??_GVertexShader@gfxu@@QEAAPEAXI@Z DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$??_GVertexShader@gfxu@@QEAAPEAXI@Z
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$??_GVertexShader@gfxu@@QEAAPEAXI@Z
	DD	020H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_GVertexShader@gfxu@@QEAAPEAXI@Z DD 021311H
	DD	03006520aH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??_GVertexShader@gfxu@@QEAAPEAXI@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??_GFragmentShader@gfxu@@QEAAPEAXI@Z DD imagerel ??_GFragmentShader@gfxu@@QEAAPEAXI@Z
	DD	0ffffffffH
	DD	imagerel ??_GFragmentShader@gfxu@@QEAAPEAXI@Z+32
	DD	00H
	DD	imagerel ??_GFragmentShader@gfxu@@QEAAPEAXI@Z+48
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??_GFragmentShader@gfxu@@QEAAPEAXI@Z DD 0ffffffffH
	DD	imagerel ?dtor$1@?0???_GFragmentShader@gfxu@@QEAAPEAXI@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??_GFragmentShader@gfxu@@QEAAPEAXI@Z DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$??_GFragmentShader@gfxu@@QEAAPEAXI@Z
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$??_GFragmentShader@gfxu@@QEAAPEAXI@Z
	DD	020H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_GFragmentShader@gfxu@@QEAAPEAXI@Z DD 021311H
	DD	03006520aH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??_GFragmentShader@gfxu@@QEAAPEAXI@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_GShaderProgram@gfxu@@QEAAPEAXI@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_GTexture2D@gfxu@@QEAAPEAXI@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1VertexShader@gfxu@@QEAA@XZ DD imagerel ??1VertexShader@gfxu@@QEAA@XZ
	DD	0ffffffffH
	DD	imagerel ??1VertexShader@gfxu@@QEAA@XZ+32
	DD	00H
	DD	imagerel ??1VertexShader@gfxu@@QEAA@XZ+48
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??1VertexShader@gfxu@@QEAA@XZ DD 0ffffffffH
	DD	imagerel ?dtor$1@?0???1VertexShader@gfxu@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??1VertexShader@gfxu@@QEAA@XZ DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$??1VertexShader@gfxu@@QEAA@XZ
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$??1VertexShader@gfxu@@QEAA@XZ
	DD	020H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1VertexShader@gfxu@@QEAA@XZ DD 021311H
	DD	03006520aH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??1VertexShader@gfxu@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1FragmentShader@gfxu@@QEAA@XZ DD imagerel ??1FragmentShader@gfxu@@QEAA@XZ
	DD	0ffffffffH
	DD	imagerel ??1FragmentShader@gfxu@@QEAA@XZ+32
	DD	00H
	DD	imagerel ??1FragmentShader@gfxu@@QEAA@XZ+48
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??1FragmentShader@gfxu@@QEAA@XZ DD 0ffffffffH
	DD	imagerel ?dtor$1@?0???1FragmentShader@gfxu@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??1FragmentShader@gfxu@@QEAA@XZ DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$??1FragmentShader@gfxu@@QEAA@XZ
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$??1FragmentShader@gfxu@@QEAA@XZ
	DD	020H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1FragmentShader@gfxu@@QEAA@XZ DD 021311H
	DD	03006520aH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??1FragmentShader@gfxu@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV01@AEBV01@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?push_back@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAAXAEBV?$shared_ptr@VChunkBase@@@2@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Reserve@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAX_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?_Tidy@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAXXZ DD 021H
	DD	imagerel $LN47
	DD	imagerel $LN47+21
	DD	imagerel $unwind$?_Tidy@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?_Tidy@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAXXZ DD 021H
	DD	imagerel $LN47+21
	DD	imagerel $LN47+35
	DD	imagerel $chain$0$?_Tidy@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?_Tidy@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAXXZ DD 020521H
	DD	063405H
	DD	imagerel $LN47+21
	DD	imagerel $LN47+35
	DD	imagerel $chain$0$?_Tidy@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?_Tidy@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAXXZ DD 020521H
	DD	075405H
	DD	imagerel $LN47
	DD	imagerel $LN47+21
	DD	imagerel $unwind$?_Tidy@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAXXZ DD 040a01H
	DD	08640aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@PEB_W_K@Z DD 020021H
	DD	067400H
	DD	imagerel $LN129
	DD	imagerel $LN129+148
	DD	imagerel $unwind$?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@PEB_W_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@PEB_W_K@Z DD 021H
	DD	imagerel $LN129
	DD	imagerel $LN129+148
	DD	imagerel $unwind$?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@PEB_W_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@PEB_W_K@Z DD 020521H
	DD	067405H
	DD	imagerel $LN129
	DD	imagerel $LN129+148
	DD	imagerel $unwind$?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@PEB_W_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@PEB_W_K@Z DD 061001H
	DD	086410H
	DD	073410H
	DD	0e00c3210H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?_Destroy@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAXPEAV?$shared_ptr@VChunkBase@@@2@0@Z DD 021H
	DD	imagerel $LN37
	DD	imagerel $LN37+10
	DD	imagerel $unwind$?_Destroy@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAXPEAV?$shared_ptr@VChunkBase@@@2@0@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?_Destroy@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAXPEAV?$shared_ptr@VChunkBase@@@2@0@Z DD 040a21H
	DD	07740aH
	DD	063405H
	DD	imagerel $LN37
	DD	imagerel $LN37+10
	DD	imagerel $unwind$?_Destroy@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAXPEAV?$shared_ptr@VChunkBase@@@2@0@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Destroy@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAXPEAV?$shared_ptr@VChunkBase@@@2@0@Z DD 020a01H
	DD	06006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$?_Reallocate@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAX_K@Z DD 021H
	DD	imagerel $LN85
	DD	imagerel $LN85+74
	DD	imagerel $unwind$?_Reallocate@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$?_Reallocate@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAX_K@Z DD 021H
	DD	imagerel $LN85+74
	DD	imagerel $LN85+120
	DD	imagerel $chain$2$?_Reallocate@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?_Reallocate@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAX_K@Z DD 020521H
	DD	0a3405H
	DD	imagerel $LN85+74
	DD	imagerel $LN85+120
	DD	imagerel $chain$2$?_Reallocate@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?_Reallocate@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAX_K@Z DD 061221H
	DD	0dc412H
	DD	0c740dH
	DD	0b5405H
	DD	imagerel $LN85
	DD	imagerel $LN85+74
	DD	imagerel $unwind$?_Reallocate@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Reallocate@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAX_K@Z DD 040a01H
	DD	0f006520aH
	DD	06002e004H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Xlen@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEBAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@AEBV12@_K1@Z DD 020021H
	DD	067400H
	DD	imagerel $LN119
	DD	imagerel $LN119+76
	DD	imagerel $unwind$?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@AEBV12@_K1@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@AEBV12@_K1@Z DD 021H
	DD	imagerel $LN119
	DD	imagerel $LN119+76
	DD	imagerel $unwind$?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@AEBV12@_K1@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@AEBV12@_K1@Z DD 020521H
	DD	067405H
	DD	imagerel $LN119
	DD	imagerel $LN119+76
	DD	imagerel $unwind$?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@AEBV12@_K1@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@AEBV12@_K1@Z DD 081501H
	DD	096415H
	DD	085415H
	DD	073415H
	DD	0e0113215H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@YAXPEAV?$shared_ptr@VChunkBase@@@0@0AEAU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@0@@Z DD 021H
	DD	imagerel $LN35
	DD	imagerel $LN35+10
	DD	imagerel $unwind$??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@YAXPEAV?$shared_ptr@VChunkBase@@@0@0AEAU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@YAXPEAV?$shared_ptr@VChunkBase@@@0@0AEAU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@0@@Z DD 040a21H
	DD	07740aH
	DD	063405H
	DD	imagerel $LN35
	DD	imagerel $LN35+10
	DD	imagerel $unwind$??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@YAXPEAV?$shared_ptr@VChunkBase@@@0@0AEAU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@YAXPEAV?$shared_ptr@VChunkBase@@@0@0AEAU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@0@@Z DD 020a01H
	DD	06006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Umove@PEAV?$shared_ptr@VChunkBase@@@std@@@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAPEAV?$shared_ptr@VChunkBase@@@1@PEAV21@00@Z DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@YAXPEAV?$shared_ptr@VChunkBase@@@0@0AEAU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z DD 021H
	DD	imagerel $LN31
	DD	imagerel $LN31+10
	DD	imagerel $unwind$??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@YAXPEAV?$shared_ptr@VChunkBase@@@0@0AEAU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@YAXPEAV?$shared_ptr@VChunkBase@@@0@0AEAU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z DD 040a21H
	DD	07740aH
	DD	063405H
	DD	imagerel $LN31
	DD	imagerel $LN31+10
	DD	imagerel $unwind$??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@YAXPEAV?$shared_ptr@VChunkBase@@@0@0AEAU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@YAXPEAV?$shared_ptr@VChunkBase@@@0@0AEAU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z DD 020a01H
	DD	06006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_move@PEAV?$shared_ptr@VChunkBase@@@std@@PEAV12@U?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@YAPEAV?$shared_ptr@VChunkBase@@@0@PEAV10@00AEAU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@0@@Z DD 010401H
	DD	06204H
commandQueue$initializer$ DQ FLAT:??__EcommandQueue@@YAXXZ
program$initializer$ DQ FLAT:??__Eprogram@@YAXXZ
projectionMatrixBuffer$initializer$ DQ FLAT:??__EprojectionMatrixBuffer@@YAXXZ
boolBuffer$initializer$ DQ FLAT:??__EboolBuffer@@YAXXZ
gridBuffer$initializer$ DQ FLAT:??__EgridBuffer@@YAXXZ
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
;	COMDAT ?length@?$char_traits@_W@std@@SA_KPEB_W@Z
_TEXT	SEGMENT
_First$ = 8
?length@?$char_traits@_W@std@@SA_KPEB_W@Z PROC		; std::char_traits<wchar_t>::length, COMDAT

; 305  : 		return (*_First == 0 ? 0
; 306  : 			: _CSTD wcslen(_First));

  00000	66 83 39 00	 cmp	 WORD PTR [rcx], 0
  00004	75 03		 jne	 SHORT $LN3@length
  00006	33 c0		 xor	 eax, eax

; 307  : 		}

  00008	c3		 ret	 0
$LN3@length:

; 305  : 		return (*_First == 0 ? 0
; 306  : 			: _CSTD wcslen(_First));

  00009	48 83 c8 ff	 or	 rax, -1
  0000d	0f 1f 00	 npad	 3
$LL5@length:
  00010	48 ff c0	 inc	 rax
  00013	66 83 3c 41 00	 cmp	 WORD PTR [rcx+rax*2], 0
  00018	75 f6		 jne	 SHORT $LL5@length

; 307  : 		}

  0001a	f3 c3		 fatret	 0
?length@?$char_traits@_W@std@@SA_KPEB_W@Z ENDP		; std::char_traits<wchar_t>::length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ?_Orphan_all@_Container_base0@std@@QEAAXXZ
_TEXT	SEGMENT
this$dead$ = 8
?_Orphan_all@_Container_base0@std@@QEAAXXZ PROC		; std::_Container_base0::_Orphan_all, COMDAT

; 40   : 		}

  00000	c2 00 00	 ret	 0
?_Orphan_all@_Container_base0@std@@QEAAXXZ ENDP		; std::_Container_base0::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp
;	COMDAT ??__EcommandQueue@@YAXXZ
text$yc	SEGMENT
??__EcommandQueue@@YAXXZ PROC				; `dynamic initializer for 'commandQueue'', COMDAT

; 11   : cl::CommandQueue commandQueue;

  00000	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??__FcommandQueue@@YAXXZ ; `dynamic atexit destructor for 'commandQueue''
  00007	e9 00 00 00 00	 jmp	 atexit
??__EcommandQueue@@YAXXZ ENDP				; `dynamic initializer for 'commandQueue''
text$yc	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp
;	COMDAT ??__FcommandQueue@@YAXXZ
text$yd	SEGMENT
??__FcommandQueue@@YAXXZ PROC				; `dynamic atexit destructor for 'commandQueue'', COMDAT

; 49   : 	if(okay) clReleaseCommandQueue(queue);

  00000	80 3d 08 00 00
	00 00		 cmp	 BYTE PTR ?commandQueue@@3VCommandQueue@cl@@A+8, 0
  00007	74 0e		 je	 SHORT $LN3@dynamic
  00009	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?commandQueue@@3VCommandQueue@cl@@A
  00010	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_clReleaseCommandQueue
$LN3@dynamic:
  00017	f3 c3		 fatret	 0
??__FcommandQueue@@YAXXZ ENDP				; `dynamic atexit destructor for 'commandQueue''
text$yd	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp
;	COMDAT ??__Eprogram@@YAXXZ
text$yc	SEGMENT
$T1 = 32
??__Eprogram@@YAXXZ PROC				; `dynamic initializer for 'program'', COMDAT

; 12   : cl::Program program;

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H
  00004	48 c7 44 24 20
	fe ff ff ff	 mov	 QWORD PTR $T1[rsp], -2
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree

; 778  : 		this->_Myhead = _Buyheadnode();

  0000d	e8 00 00 00 00	 call	 ?_Buyheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAU_cl_kernel@@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAU_cl_kernel@@@std@@@2@@std@@@std@@QEAAPEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAU_cl_kernel@@@std@@PEAX@2@XZ ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,_cl_kernel * __ptr64>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,_cl_kernel * __ptr64> > > >::_Buyheadnode
  00012	48 89 05 08 00
	00 00		 mov	 QWORD PTR ?program@@3VProgram@cl@@A+8, rax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 63   : 	return (_Check_C_return(_Mtx_init(_Mtx, _Type)));

  00019	ba 02 00 00 00	 mov	 edx, 2
  0001e	48 8d 0d 18 00
	00 00		 lea	 rcx, OFFSET FLAT:?program@@3VProgram@cl@@A+24
  00025	e8 00 00 00 00	 call	 _Mtx_init

; 32   : 	if (_Res != _Thrd_success)

  0002a	85 c0		 test	 eax, eax
  0002c	74 07		 je	 SHORT $LN31@dynamic

; 33   : 		_Throw_C_error(_Res);

  0002e	8b c8		 mov	 ecx, eax
  00030	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
$LN31@dynamic:
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp

; 68   : {

  00035	c6 05 28 00 00
	00 00		 mov	 BYTE PTR ?program@@3VProgram@cl@@A+40, 0
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp

; 12   : cl::Program program;

  0003c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??__Fprogram@@YAXXZ ; `dynamic atexit destructor for 'program''
  00043	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00047	e9 00 00 00 00	 jmp	 atexit
??__Eprogram@@YAXXZ ENDP				; `dynamic initializer for 'program''
text$yc	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
?dtor$0@?0???__Eprogram@@YAXXZ@4HA PROC			; ``dynamic initializer for 'program'''::`1'::dtor$0
  00000	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?program@@3VProgram@cl@@A ; program
  00007	48 83 c1 08	 add	 rcx, 8
  0000b	e9 00 00 00 00	 jmp	 ??1?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAU_cl_kernel@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAU_cl_kernel@@@std@@@2@@std@@QEAA@XZ
?dtor$0@?0???__Eprogram@@YAXXZ@4HA ENDP			; ``dynamic initializer for 'program'''::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??__Fprogram@@YAXXZ
text$yd	SEGMENT
??__Fprogram@@YAXXZ PROC				; `dynamic atexit destructor for 'program'', COMDAT
  00000	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?program@@3VProgram@cl@@A ; program
  00007	e9 00 00 00 00	 jmp	 ??1Program@cl@@QEAA@XZ	; cl::Program::~Program
??__Fprogram@@YAXXZ ENDP				; `dynamic atexit destructor for 'program''
text$yd	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp
;	COMDAT ??__EprojectionMatrixBuffer@@YAXXZ
text$yc	SEGMENT
??__EprojectionMatrixBuffer@@YAXXZ PROC			; `dynamic initializer for 'projectionMatrixBuffer'', COMDAT

; 13   : cl::Buffer projectionMatrixBuffer;

  00000	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??__FprojectionMatrixBuffer@@YAXXZ ; `dynamic atexit destructor for 'projectionMatrixBuffer''
  00007	e9 00 00 00 00	 jmp	 atexit
??__EprojectionMatrixBuffer@@YAXXZ ENDP			; `dynamic initializer for 'projectionMatrixBuffer''
text$yc	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp
;	COMDAT ??__FprojectionMatrixBuffer@@YAXXZ
text$yd	SEGMENT
??__FprojectionMatrixBuffer@@YAXXZ PROC			; `dynamic atexit destructor for 'projectionMatrixBuffer'', COMDAT
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 247  : 	if(okay)

  00004	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR ?projectionMatrixBuffer@@3VBuffer@cl@@A, 0
  0000b	74 28		 je	 SHORT $LN3@dynamic

; 248  : 	{
; 249  : 		cl_int error = clReleaseMemObject(mem);

  0000d	48 8b 0d 08 00
	00 00		 mov	 rcx, QWORD PTR ?projectionMatrixBuffer@@3VBuffer@cl@@A+8
  00014	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_clReleaseMemObject

; 250  : 		if(error != CL_SUCCESS)

  0001a	85 c0		 test	 eax, eax
  0001c	74 17		 je	 SHORT $LN3@dynamic

; 251  : 		{
; 252  : 			GLWindow::instance->postError("Failed to delete buffer", "OpenCL buffer deletion error");

  0001e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG4294956356
  00025	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG4294956355
  0002c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00030	e9 00 00 00 00	 jmp	 ?postError@GLWindow@@QEAAXPEBD0@Z ; GLWindow::postError
$LN3@dynamic:
  00035	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00039	c3		 ret	 0
??__FprojectionMatrixBuffer@@YAXXZ ENDP			; `dynamic atexit destructor for 'projectionMatrixBuffer''
text$yd	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp
;	COMDAT ??__EboolBuffer@@YAXXZ
text$yc	SEGMENT
??__EboolBuffer@@YAXXZ PROC				; `dynamic initializer for 'boolBuffer'', COMDAT

; 14   : cl::Buffer boolBuffer;

  00000	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??__FboolBuffer@@YAXXZ ; `dynamic atexit destructor for 'boolBuffer''
  00007	e9 00 00 00 00	 jmp	 atexit
??__EboolBuffer@@YAXXZ ENDP				; `dynamic initializer for 'boolBuffer''
text$yc	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp
;	COMDAT ??__FboolBuffer@@YAXXZ
text$yd	SEGMENT
??__FboolBuffer@@YAXXZ PROC				; `dynamic atexit destructor for 'boolBuffer'', COMDAT
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 247  : 	if(okay)

  00004	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR ?boolBuffer@@3VBuffer@cl@@A, 0
  0000b	74 28		 je	 SHORT $LN3@dynamic

; 248  : 	{
; 249  : 		cl_int error = clReleaseMemObject(mem);

  0000d	48 8b 0d 08 00
	00 00		 mov	 rcx, QWORD PTR ?boolBuffer@@3VBuffer@cl@@A+8
  00014	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_clReleaseMemObject

; 250  : 		if(error != CL_SUCCESS)

  0001a	85 c0		 test	 eax, eax
  0001c	74 17		 je	 SHORT $LN3@dynamic

; 251  : 		{
; 252  : 			GLWindow::instance->postError("Failed to delete buffer", "OpenCL buffer deletion error");

  0001e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG4294956356
  00025	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG4294956355
  0002c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00030	e9 00 00 00 00	 jmp	 ?postError@GLWindow@@QEAAXPEBD0@Z ; GLWindow::postError
$LN3@dynamic:
  00035	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00039	c3		 ret	 0
??__FboolBuffer@@YAXXZ ENDP				; `dynamic atexit destructor for 'boolBuffer''
text$yd	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp
;	COMDAT ??__EgridBuffer@@YAXXZ
text$yc	SEGMENT
??__EgridBuffer@@YAXXZ PROC				; `dynamic initializer for 'gridBuffer'', COMDAT

; 15   : cl::Buffer gridBuffer;

  00000	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??__FgridBuffer@@YAXXZ ; `dynamic atexit destructor for 'gridBuffer''
  00007	e9 00 00 00 00	 jmp	 atexit
??__EgridBuffer@@YAXXZ ENDP				; `dynamic initializer for 'gridBuffer''
text$yc	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp
;	COMDAT ??__FgridBuffer@@YAXXZ
text$yd	SEGMENT
??__FgridBuffer@@YAXXZ PROC				; `dynamic atexit destructor for 'gridBuffer'', COMDAT
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 247  : 	if(okay)

  00004	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR ?gridBuffer@@3VBuffer@cl@@A, 0
  0000b	74 28		 je	 SHORT $LN3@dynamic

; 248  : 	{
; 249  : 		cl_int error = clReleaseMemObject(mem);

  0000d	48 8b 0d 08 00
	00 00		 mov	 rcx, QWORD PTR ?gridBuffer@@3VBuffer@cl@@A+8
  00014	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_clReleaseMemObject

; 250  : 		if(error != CL_SUCCESS)

  0001a	85 c0		 test	 eax, eax
  0001c	74 17		 je	 SHORT $LN3@dynamic

; 251  : 		{
; 252  : 			GLWindow::instance->postError("Failed to delete buffer", "OpenCL buffer deletion error");

  0001e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG4294956356
  00025	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG4294956355
  0002c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00030	e9 00 00 00 00	 jmp	 ?postError@GLWindow@@QEAAXPEBD0@Z ; GLWindow::postError
$LN3@dynamic:
  00035	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00039	c3		 ret	 0
??__FgridBuffer@@YAXXZ ENDP				; `dynamic atexit destructor for 'gridBuffer''
text$yd	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\list.h
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\list.h
; File c:\users\glenn\documents\github\wind\project\wind\wind\memutil.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\geometry.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.h
; File c:\users\glenn\documents\github\wind\project\wind\wind\geometry.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.h
; File c:\users\glenn\documents\github\wind\project\wind\wind\geometry.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.h
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\geometry.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\window.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\window.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\window.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\window.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\window.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\window.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\window.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\window.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\window.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\window.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\window.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\geometry.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\geometry.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\geometry.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.h
; File c:\users\glenn\documents\github\wind\project\wind\wind\geometry.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\geometry.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\geometry.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.h
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\geometry.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.h
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\window.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp
;	COMDAT ?tick@RenderThread@@EEAA_NXZ
_TEXT	SEGMENT
xCam$ = 80
zCam$ = 84
yCam$ = 88
chunksToRender$ = 96
$T1 = 120
$T2 = 136
$T3 = 152
$T4 = 168
$T5 = 184
event$6 = 200
$T7 = 208
event$8 = 224
event$9 = 232
$T10 = 240
chunk$11 = 256
$T12 = 272
state$1$ = 280
$T13 = 288
$T14 = 296
$T15 = 312
$T16 = 344
chunk$17 = 376
$T18 = 392
$T19 = 400
chunk$20 = 408
$T21 = 424
c$22 = 432
c$23 = 448
$T24 = 464
$T25 = 528
$T26 = 592
$T27 = 656
$T28 = 720
$T29 = 784
$T30 = 848
$T31 = 912
$T32 = 976
$T33 = 1040
$T34 = 1064
$T35 = 1088
$T36 = 1152
$T37 = 1216
$T38 = 1280
$T39 = 1344
projectionMatrix$ = 1408
$T40 = 1472
$T41 = 1536
$T42 = 1600
$T43 = 1664
local_ws_1$ = 1728
global_ws_1$ = 1752
global_ws_2$ = 1776
local_ws_2$ = 1800
__$ArrayPad$ = 1824
this$ = 1920
?tick@RenderThread@@EEAA_NXZ PROC			; RenderThread::tick, COMDAT

; 31   : {

$LN1695:
  00000	48 8b c4	 mov	 rax, rsp
  00003	55		 push	 rbp
  00004	41 54		 push	 r12
  00006	41 55		 push	 r13
  00008	41 56		 push	 r14
  0000a	41 57		 push	 r15
  0000c	48 8d a8 88 f9
	ff ff		 lea	 rbp, QWORD PTR [rax-1656]
  00013	48 81 ec 50 07
	00 00		 sub	 rsp, 1872		; 00000750H
  0001a	48 c7 85 88 00
	00 00 fe ff ff
	ff		 mov	 QWORD PTR $T18[rbp-256], -2
  00025	48 89 58 10	 mov	 QWORD PTR [rax+16], rbx
  00029	48 89 70 18	 mov	 QWORD PTR [rax+24], rsi
  0002d	48 89 78 20	 mov	 QWORD PTR [rax+32], rdi
  00031	0f 29 70 c8	 movaps	 XMMWORD PTR [rax-56], xmm6
  00035	0f 29 78 b8	 movaps	 XMMWORD PTR [rax-72], xmm7
  00039	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00040	48 33 c4	 xor	 rax, rsp
  00043	48 89 85 20 06
	00 00		 mov	 QWORD PTR __$ArrayPad$[rbp-256], rax
  0004a	48 8b f1	 mov	 rsi, rcx

; 32   : 	for(int i = 0; i < RenderThread::taskList.getSize(); i++)

  0004d	45 33 ff	 xor	 r15d, r15d
  00050	41 8b ff	 mov	 edi, r15d
  00053	45 8d 77 01	 lea	 r14d, QWORD PTR [r15+1]
  00057	44 39 b9 20 08
	00 00		 cmp	 DWORD PTR [rcx+2080], r15d
  0005e	7e 2d		 jle	 SHORT $LN38@tick
  00060	48 8d 59 20	 lea	 rbx, QWORD PTR [rcx+32]
$LL40@tick:
; File c:\users\glenn\documents\github\wind\project\wind\wind\list.h

; 53   : 		return List::operator[](index);

  00064	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp

; 34   : 		if(!RenderThread::taskList[i]->invoke())

  00067	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  0006a	ff 10		 call	 QWORD PTR [rax]
  0006c	0f b6 0d 00 00
	00 00		 movzx	 ecx, BYTE PTR ?stop@GlobalThread@@3_NA ; GlobalThread::stop
  00073	84 c0		 test	 al, al
  00075	41 0f 44 ce	 cmove	 ecx, r14d
  00079	88 0d 00 00 00
	00		 mov	 BYTE PTR ?stop@GlobalThread@@3_NA, cl ; GlobalThread::stop

; 32   : 	for(int i = 0; i < RenderThread::taskList.getSize(); i++)

  0007f	ff c7		 inc	 edi
  00081	48 8d 5b 08	 lea	 rbx, QWORD PTR [rbx+8]
  00085	3b be 20 08 00
	00		 cmp	 edi, DWORD PTR [rsi+2080]
  0008b	7c d7		 jl	 SHORT $LL40@tick
$LN38@tick:
; File c:\users\glenn\documents\github\wind\project\wind\wind\list.h

; 37   : 		count = 0;

  0008d	44 89 be 20 08
	00 00		 mov	 DWORD PTR [rsi+2080], r15d
; File c:\users\glenn\documents\github\wind\project\wind\wind\memutil.cpp

; 18   : 	pos = 0;

  00094	44 89 be 34 08
	00 00		 mov	 DWORD PTR [rsi+2100], r15d
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp

; 42   : 	if(RenderThread::skipRender)

  0009b	44 38 3d 00 00
	00 00		 cmp	 BYTE PTR ?skipRender@RenderThread@@2_NA, r15b ; RenderThread::skipRender
  000a2	74 09		 je	 SHORT $LN36@tick

; 43   : 	{
; 44   : 		return true;

  000a4	41 0f b6 c6	 movzx	 eax, r14b
  000a8	e9 ed 1f 00 00	 jmp	 $LN41@tick
$LN36@tick:

; 45   : 	}
; 46   : 
; 47   : 	GameStates::swapPendingRendering();

  000ad	e8 00 00 00 00	 call	 ?swapPendingRendering@GameStates@@YAXXZ ; GameStates::swapPendingRendering

; 48   : 
; 49   : 	GameStates::GameState* state = GameStates::renderingState;

  000b2	4c 8b 25 00 00
	00 00		 mov	 r12, QWORD PTR ?renderingState@GameStates@@3PEAVGameState@1@EA ; GameStates::renderingState
  000b9	4c 89 65 18	 mov	 QWORD PTR state$1$[rbp-256], r12

; 50   : 
; 51   : 	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

  000bd	b9 00 41 00 00	 mov	 ecx, 16640		; 00004100H
  000c2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_glClear

; 52   : 
; 53   : 	if(GLWindow::instance->rescaled)

  000c8	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?instance@GLWindow@@2PEAV1@EA ; GLWindow::instance
  000cf	44 38 78 50	 cmp	 BYTE PTR [rax+80], r15b
  000d3	74 1d		 je	 SHORT $LN35@tick

; 54   : 	{
; 55   : 		glViewport(0, 0, GLWindow::instance->width, GLWindow::instance->height);

  000d5	44 8b 48 58	 mov	 r9d, DWORD PTR [rax+88]
  000d9	44 8b 40 54	 mov	 r8d, DWORD PTR [rax+84]
  000dd	33 d2		 xor	 edx, edx
  000df	33 c9		 xor	 ecx, ecx
  000e1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_glViewport

; 56   : 		GLWindow::instance->rescaled = false;

  000e7	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?instance@GLWindow@@2PEAV1@EA ; GLWindow::instance
  000ee	44 88 78 50	 mov	 BYTE PTR [rax+80], r15b
$LN35@tick:

; 57   : 	}
; 58   : 		
; 59   : 	normalShaderProgram->bind();

  000f2	48 8b 1d 00 00
	00 00		 mov	 rbx, QWORD PTR ?normalShaderProgram@@3PEAVShaderProgram@gfxu@@EA ; normalShaderProgram
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp

; 474  : 	glUseProgram(object);

  000f9	8b 4b 18	 mov	 ecx, DWORD PTR [rbx+24]
  000fc	ff 15 00 00 00
	00		 call	 QWORD PTR __glewUseProgram

; 713  : 	int error = glGetError();

  00102	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_glGetError

; 714  : 	if(error != GL_NO_ERROR)

  00108	85 c0		 test	 eax, eax
  0010a	74 17		 je	 SHORT $LN69@tick

; 715  : 	{
; 716  : 		const char* errorString = (const char*)gluErrorString(error);

  0010c	8b c8		 mov	 ecx, eax
  0010e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_gluErrorString

; 717  : 		GLWindow::instance->postError(errorString, caption);

  00114	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG4294928712
  0011b	48 8b d0	 mov	 rdx, rax
  0011e	e8 00 00 00 00	 call	 ?postError@GLWindow@@QEAAXPEBD0@Z ; GLWindow::postError
$LN69@tick:

; 475  : 	gfxu::getError();
; 476  : 	current = this;

  00123	48 89 1d 00 00
	00 00		 mov	 QWORD PTR ?current@ShaderProgram@gfxu@@2PEAV12@EA, rbx ; gfxu::ShaderProgram::current

; 601  : }
; 602  : 
; 603  : void Uniforms::setForceUpload()
; 604  : {
; 605  : 	MMS.changed = PMS.changed = true;

  0012a	44 88 35 68 00
	00 00		 mov	 BYTE PTR ?PMS@Uniforms@gfxu@@2VMatrixStack@2@A+104, r14b
  00131	44 88 35 68 00
	00 00		 mov	 BYTE PTR ?MMS@Uniforms@gfxu@@2VMatrixStack@2@A+104, r14b
; File c:\users\glenn\documents\github\wind\project\wind\wind\geometry.cpp

; 10   : {

  00138	f3 41 0f 10 04
	24		 movss	 xmm0, DWORD PTR [r12]
  0013e	f3 0f 11 45 88	 movss	 DWORD PTR $T2[rbp-256], xmm0
  00143	f3 41 0f 10 4c
	24 04		 movss	 xmm1, DWORD PTR [r12+4]
  0014a	f3 0f 11 4d 8c	 movss	 DWORD PTR $T2[rbp-252], xmm1
  0014f	f3 41 0f 10 44
	24 08		 movss	 xmm0, DWORD PTR [r12+8]
  00156	f3 0f 11 45 90	 movss	 DWORD PTR $T2[rbp-248], xmm0
  0015b	f3 41 0f 10 4c
	24 0c		 movss	 xmm1, DWORD PTR [r12+12]
  00162	f3 0f 11 4d 94	 movss	 DWORD PTR $T2[rbp-244], xmm1
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.h

; 245  : 			val = value;

  00167	48 8b 45 88	 mov	 rax, QWORD PTR $T2[rbp-256]
  0016b	48 89 05 00 00
	00 00		 mov	 QWORD PTR ?camPos@Uniforms@gfxu@@2V?$Uniform@VVector@geom@@@2@A, rax
  00172	48 8b 45 90	 mov	 rax, QWORD PTR $T2[rbp-248]
  00176	48 89 05 08 00
	00 00		 mov	 QWORD PTR ?camPos@Uniforms@gfxu@@2V?$Uniform@VVector@geom@@@2@A+8, rax

; 246  : 			changed = true;

  0017d	44 88 35 10 00
	00 00		 mov	 BYTE PTR ?camPos@Uniforms@gfxu@@2V?$Uniform@VVector@geom@@@2@A+16, r14b
; File c:\users\glenn\documents\github\wind\project\wind\wind\geometry.cpp

; 16   : {

  00184	f3 0f 10 3d 00
	00 00 00	 movss	 xmm7, DWORD PTR __real@3f800000
  0018c	c7 45 f0 00 00
	80 3f		 mov	 DWORD PTR $T10[rbp-256], 1065353216 ; 3f800000H
  00193	c7 45 f4 00 00
	80 3f		 mov	 DWORD PTR $T10[rbp-252], 1065353216 ; 3f800000H
  0019a	c7 45 f8 00 00
	80 3f		 mov	 DWORD PTR $T10[rbp-248], 1065353216 ; 3f800000H
  001a1	c7 45 fc 00 00
	80 3f		 mov	 DWORD PTR $T10[rbp-244], 1065353216 ; 3f800000H
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.h

; 245  : 			val = value;

  001a8	48 8b 45 f0	 mov	 rax, QWORD PTR $T10[rbp-256]
  001ac	48 89 05 00 00
	00 00		 mov	 QWORD PTR ?color@Uniforms@gfxu@@2V?$Uniform@VVector@geom@@@2@A, rax
  001b3	48 8b 45 f8	 mov	 rax, QWORD PTR $T10[rbp-248]
  001b7	48 89 05 08 00
	00 00		 mov	 QWORD PTR ?color@Uniforms@gfxu@@2V?$Uniform@VVector@geom@@@2@A+8, rax

; 246  : 			changed = true;

  001be	44 88 35 10 00
	00 00		 mov	 BYTE PTR ?color@Uniforms@gfxu@@2V?$Uniform@VVector@geom@@@2@A+16, r14b
; File c:\users\glenn\documents\github\wind\project\wind\wind\geometry.cpp

; 16   : {

  001c5	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f000000
  001cd	f3 0f 11 45 a8	 movss	 DWORD PTR $T4[rbp-256], xmm0
  001d2	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@3f600000
  001da	f3 0f 11 4d ac	 movss	 DWORD PTR $T4[rbp-252], xmm1
  001df	c7 45 b0 00 00
	80 3f		 mov	 DWORD PTR $T4[rbp-248], 1065353216 ; 3f800000H
  001e6	c7 45 b4 00 00
	80 3f		 mov	 DWORD PTR $T4[rbp-244], 1065353216 ; 3f800000H
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.h

; 245  : 			val = value;

  001ed	48 8b 45 a8	 mov	 rax, QWORD PTR $T4[rbp-256]
  001f1	48 89 05 00 00
	00 00		 mov	 QWORD PTR ?fogColor@Uniforms@gfxu@@2V?$Uniform@VVector@geom@@@2@A, rax
  001f8	48 8b 45 b0	 mov	 rax, QWORD PTR $T4[rbp-248]
  001fc	48 89 05 08 00
	00 00		 mov	 QWORD PTR ?fogColor@Uniforms@gfxu@@2V?$Uniform@VVector@geom@@@2@A+8, rax

; 246  : 			changed = true;

  00203	44 88 35 10 00
	00 00		 mov	 BYTE PTR ?fogColor@Uniforms@gfxu@@2V?$Uniform@VVector@geom@@@2@A+16, r14b

; 245  : 			val = value;

  0020a	f3 0f 10 35 00
	00 00 00	 movss	 xmm6, DWORD PTR __real@43000000
  00212	c7 05 00 00 00
	00 00 00 00 43	 mov	 DWORD PTR ?fogDist@Uniforms@gfxu@@2V?$Uniform@M@2@A, 1124073472 ; 43000000H

; 246  : 			changed = true;

  0021c	44 88 35 04 00
	00 00		 mov	 BYTE PTR ?fogDist@Uniforms@gfxu@@2V?$Uniform@M@2@A+4, r14b
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp

; 599  : 	MMS.clear();

  00223	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?MMS@Uniforms@gfxu@@2VMatrixStack@2@A ; gfxu::Uniforms::MMS
  0022a	e8 00 00 00 00	 call	 ?clear@MatrixStack@gfxu@@QEAAXXZ ; gfxu::MatrixStack::clear

; 600  : 	PMS.clear();

  0022f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?PMS@Uniforms@gfxu@@2VMatrixStack@2@A ; gfxu::Uniforms::PMS
  00236	e8 00 00 00 00	 call	 ?clear@MatrixStack@gfxu@@QEAAXXZ ; gfxu::MatrixStack::clear
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp

; 65   : 	gfxu::Uniforms::PMS.mult(geom::Matrix::perspective(state->FOV, (float)GLWindow::instance->width / (float)GLWindow::instance->height, 0.1f, 16.0f * renderDistance));

  0023b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?instance@GLWindow@@2PEAV1@EA ; GLWindow::instance
  00242	66 0f 6e 50 54	 movd	 xmm2, DWORD PTR [rax+84]
  00247	0f 5b d2	 cvtdq2ps xmm2, xmm2
  0024a	66 0f 6e 40 58	 movd	 xmm0, DWORD PTR [rax+88]
  0024f	0f 5b c0	 cvtdq2ps xmm0, xmm0
  00252	f3 0f 5e d0	 divss	 xmm2, xmm0
  00256	66 41 0f 6e 4c
	24 20		 movd	 xmm1, DWORD PTR [r12+32]
  0025d	0f 5b c9	 cvtdq2ps xmm1, xmm1
  00260	f3 0f 11 74 24
	20		 movss	 DWORD PTR [rsp+32], xmm6
  00266	f3 0f 10 1d 00
	00 00 00	 movss	 xmm3, DWORD PTR __real@3dcccccd
  0026e	48 8d 8d c0 04
	00 00		 lea	 rcx, QWORD PTR $T40[rbp-256]
  00275	e8 00 00 00 00	 call	 ?perspective@Matrix@geom@@SA?AV12@MMMM@Z ; geom::Matrix::perspective
  0027a	0f 10 00	 movups	 xmm0, XMMWORD PTR [rax]
  0027d	0f 29 85 10 02
	00 00		 movaps	 XMMWORD PTR $T29[rbp-256], xmm0
  00284	0f 10 48 10	 movups	 xmm1, XMMWORD PTR [rax+16]
  00288	0f 29 8d 20 02
	00 00		 movaps	 XMMWORD PTR $T29[rbp-240], xmm1
  0028f	0f 10 40 20	 movups	 xmm0, XMMWORD PTR [rax+32]
  00293	0f 29 85 30 02
	00 00		 movaps	 XMMWORD PTR $T29[rbp-224], xmm0
  0029a	0f 10 48 30	 movups	 xmm1, XMMWORD PTR [rax+48]
  0029e	0f 29 8d 40 02
	00 00		 movaps	 XMMWORD PTR $T29[rbp-208], xmm1
  002a5	48 8d 95 10 02
	00 00		 lea	 rdx, QWORD PTR $T29[rbp-256]
  002ac	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?PMS@Uniforms@gfxu@@2VMatrixStack@2@A ; gfxu::Uniforms::PMS
  002b3	e8 00 00 00 00	 call	 ?mult@MatrixStack@gfxu@@QEAAXVMatrix@geom@@@Z ; gfxu::MatrixStack::mult
  002b8	0f 57 f6	 xorps	 xmm6, xmm6

; 66   : 	gfxu::Uniforms::PMS.mult(geom::Matrix::rotate(state->cam.rot.x, 1.0f, 0.0f, 0.0f));

  002bb	f3 0f 11 74 24
	20		 movss	 DWORD PTR [rsp+32], xmm6
  002c1	0f 28 de	 movaps	 xmm3, xmm6
  002c4	0f 28 d7	 movaps	 xmm2, xmm7
  002c7	f3 41 0f 10 4c
	24 10		 movss	 xmm1, DWORD PTR [r12+16]
  002ce	48 8d 8d 00 05
	00 00		 lea	 rcx, QWORD PTR $T41[rbp-256]
  002d5	e8 00 00 00 00	 call	 ?rotate@Matrix@geom@@SA?AV12@MMMM@Z ; geom::Matrix::rotate
  002da	0f 10 00	 movups	 xmm0, XMMWORD PTR [rax]
  002dd	0f 29 85 10 01
	00 00		 movaps	 XMMWORD PTR $T25[rbp-256], xmm0
  002e4	0f 10 48 10	 movups	 xmm1, XMMWORD PTR [rax+16]
  002e8	0f 29 8d 20 01
	00 00		 movaps	 XMMWORD PTR $T25[rbp-240], xmm1
  002ef	0f 10 40 20	 movups	 xmm0, XMMWORD PTR [rax+32]
  002f3	0f 29 85 30 01
	00 00		 movaps	 XMMWORD PTR $T25[rbp-224], xmm0
  002fa	0f 10 48 30	 movups	 xmm1, XMMWORD PTR [rax+48]
  002fe	0f 29 8d 40 01
	00 00		 movaps	 XMMWORD PTR $T25[rbp-208], xmm1
  00305	48 8d 95 10 01
	00 00		 lea	 rdx, QWORD PTR $T25[rbp-256]
  0030c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?PMS@Uniforms@gfxu@@2VMatrixStack@2@A ; gfxu::Uniforms::PMS
  00313	e8 00 00 00 00	 call	 ?mult@MatrixStack@gfxu@@QEAAXVMatrix@geom@@@Z ; gfxu::MatrixStack::mult

; 67   : 	gfxu::Uniforms::PMS.mult(geom::Matrix::rotate(state->cam.rot.y, 0.0f, 1.0f, 0.0f));

  00318	f3 0f 11 74 24
	20		 movss	 DWORD PTR [rsp+32], xmm6
  0031e	0f 28 df	 movaps	 xmm3, xmm7
  00321	0f 28 d6	 movaps	 xmm2, xmm6
  00324	f3 41 0f 10 4c
	24 14		 movss	 xmm1, DWORD PTR [r12+20]
  0032b	48 8d 8d 80 05
	00 00		 lea	 rcx, QWORD PTR $T43[rbp-256]
  00332	e8 00 00 00 00	 call	 ?rotate@Matrix@geom@@SA?AV12@MMMM@Z ; geom::Matrix::rotate
  00337	0f 10 00	 movups	 xmm0, XMMWORD PTR [rax]
  0033a	0f 29 85 50 01
	00 00		 movaps	 XMMWORD PTR $T26[rbp-256], xmm0
  00341	0f 10 48 10	 movups	 xmm1, XMMWORD PTR [rax+16]
  00345	0f 29 8d 60 01
	00 00		 movaps	 XMMWORD PTR $T26[rbp-240], xmm1
  0034c	0f 10 40 20	 movups	 xmm0, XMMWORD PTR [rax+32]
  00350	0f 29 85 70 01
	00 00		 movaps	 XMMWORD PTR $T26[rbp-224], xmm0
  00357	0f 10 48 30	 movups	 xmm1, XMMWORD PTR [rax+48]
  0035b	0f 29 8d 80 01
	00 00		 movaps	 XMMWORD PTR $T26[rbp-208], xmm1
  00362	48 8d 95 50 01
	00 00		 lea	 rdx, QWORD PTR $T26[rbp-256]
  00369	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?PMS@Uniforms@gfxu@@2VMatrixStack@2@A ; gfxu::Uniforms::PMS
  00370	e8 00 00 00 00	 call	 ?mult@MatrixStack@gfxu@@QEAAXVMatrix@geom@@@Z ; gfxu::MatrixStack::mult

; 68   : 	gfxu::Uniforms::PMS.mult(geom::Matrix::rotate(state->cam.rot.z, 0.0f, 0.0f, 1.0f));

  00375	f3 0f 11 7c 24
	20		 movss	 DWORD PTR [rsp+32], xmm7
  0037b	0f 28 de	 movaps	 xmm3, xmm6
  0037e	0f 28 d6	 movaps	 xmm2, xmm6
  00381	f3 41 0f 10 4c
	24 18		 movss	 xmm1, DWORD PTR [r12+24]
  00388	48 8d 8d 40 05
	00 00		 lea	 rcx, QWORD PTR $T42[rbp-256]
  0038f	e8 00 00 00 00	 call	 ?rotate@Matrix@geom@@SA?AV12@MMMM@Z ; geom::Matrix::rotate
  00394	0f 10 00	 movups	 xmm0, XMMWORD PTR [rax]
  00397	0f 29 85 d0 01
	00 00		 movaps	 XMMWORD PTR $T28[rbp-256], xmm0
  0039e	0f 10 48 10	 movups	 xmm1, XMMWORD PTR [rax+16]
  003a2	0f 29 8d e0 01
	00 00		 movaps	 XMMWORD PTR $T28[rbp-240], xmm1
  003a9	0f 10 40 20	 movups	 xmm0, XMMWORD PTR [rax+32]
  003ad	0f 29 85 f0 01
	00 00		 movaps	 XMMWORD PTR $T28[rbp-224], xmm0
  003b4	0f 10 48 30	 movups	 xmm1, XMMWORD PTR [rax+48]
  003b8	0f 29 8d 00 02
	00 00		 movaps	 XMMWORD PTR $T28[rbp-208], xmm1
  003bf	48 8d 95 d0 01
	00 00		 lea	 rdx, QWORD PTR $T28[rbp-256]
  003c6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?PMS@Uniforms@gfxu@@2VMatrixStack@2@A ; gfxu::Uniforms::PMS
  003cd	e8 00 00 00 00	 call	 ?mult@MatrixStack@gfxu@@QEAAXVMatrix@geom@@@Z ; gfxu::MatrixStack::mult

; 69   : 	gfxu::Uniforms::PMS.mult(geom::Matrix::translate(-state->cam.pos.x, -state->cam.pos.y, -state->cam.pos.z));

  003d2	f3 41 0f 10 5c
	24 08		 movss	 xmm3, DWORD PTR [r12+8]
  003d9	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  003e1	0f 57 d8	 xorps	 xmm3, xmm0
  003e4	f3 41 0f 10 54
	24 04		 movss	 xmm2, DWORD PTR [r12+4]
  003eb	0f 57 d0	 xorps	 xmm2, xmm0
  003ee	f3 41 0f 10 0c
	24		 movss	 xmm1, DWORD PTR [r12]
  003f4	0f 57 c8	 xorps	 xmm1, xmm0
; File c:\users\glenn\documents\github\wind\project\wind\wind\geometry.cpp

; 143  : 		data[i] = 0.0f;

  003f7	4c 89 bd 80 03
	00 00		 mov	 QWORD PTR $T36[rbp-256], r15
  003fe	4c 89 bd 88 03
	00 00		 mov	 QWORD PTR $T36[rbp-248], r15
  00405	4c 89 bd 90 03
	00 00		 mov	 QWORD PTR $T36[rbp-240], r15
  0040c	4c 89 bd 98 03
	00 00		 mov	 QWORD PTR $T36[rbp-232], r15
  00413	4c 89 bd a0 03
	00 00		 mov	 QWORD PTR $T36[rbp-224], r15
  0041a	4c 89 bd a8 03
	00 00		 mov	 QWORD PTR $T36[rbp-216], r15
  00421	4c 89 bd b0 03
	00 00		 mov	 QWORD PTR $T36[rbp-208], r15
  00428	4c 89 bd b8 03
	00 00		 mov	 QWORD PTR $T36[rbp-200], r15

; 144  : 	}
; 145  : }
; 146  : 
; 147  : Matrix::Matrix(float* data)
; 148  : {
; 149  : 	for(int i = 0; i < 16; i++)
; 150  : 	{
; 151  : 		this->data[i] = data[i];
; 152  : 	}
; 153  : }
; 154  : 
; 155  : const float& Matrix::operator[](int index) const
; 156  : {
; 157  : 	return data[index];
; 158  : }
; 159  : 
; 160  : float& Matrix::operator[](int index)
; 161  : {
; 162  : 	return data[index];
; 163  : }
; 164  : 
; 165  : 
; 166  : Matrix Matrix::operator*(const Matrix& mat) const
; 167  : {
; 168  : 	Matrix result;
; 169  : 
; 170  : 	for(int i = 0; i < 4; i++)
; 171  : 	{
; 172  : 		for(int j = 0; j < 4; j++)
; 173  : 		{
; 174  : 			float value = 0.0f;
; 175  : 			for(int k = 0; k < 4; k++)
; 176  : 			{
; 177  : 				value += data[index(k, j)] * mat.data[index(i, k)];
; 178  : 			}
; 179  : 			result[index(i, j)] = value;
; 180  : 		}
; 181  : 	}
; 182  : 
; 183  : 	return result;
; 184  : }
; 185  : 
; 186  : Matrix Matrix::operator*(const float& scalar) const
; 187  : {
; 188  : 	Matrix result;
; 189  : 
; 190  : 	for(int i = 0; i < 16; i++)
; 191  : 	{
; 192  : 		result[i] = data[i] * scalar;
; 193  : 	}
; 194  : 
; 195  : 	return result;
; 196  : }
; 197  : 
; 198  : Vector Matrix::operator*(const Vector& vert) const
; 199  : {
; 200  : 	Vector result;
; 201  : 
; 202  : 	result.x = vert.x * data[0] + vert.y * data[1] + vert.z * data[2] + vert.w * data[3];
; 203  : 	result.y = vert.x * data[4] + vert.y * data[5] + vert.z * data[6] + vert.w * data[7];
; 204  : 	result.z = vert.x * data[8] + vert.y * data[9] + vert.z * data[10] + vert.w * data[11];
; 205  : 	result.w = vert.x * data[12] + vert.y * data[13] + vert.z * data[14] + vert.w * data[15];
; 206  : 
; 207  : 	return result;
; 208  : }
; 209  : 
; 210  : Matrix& Matrix::operator=(const Matrix& mat)
; 211  : {
; 212  : 	for(int i = 0; i < 16; i++)
; 213  : 	{
; 214  : 		data[i] = mat.data[i];
; 215  : 	}
; 216  : 
; 217  : 	return *this;
; 218  : }
; 219  : 
; 220  : Matrix Matrix::identity()
; 221  : {
; 222  : 	Matrix result;
; 223  : 	result[0] = 1.0f;

  0042f	c7 85 80 03 00
	00 00 00 80 3f	 mov	 DWORD PTR $T36[rbp-256], 1065353216 ; 3f800000H

; 224  : 	result[5] = 1.0f;

  00439	c7 85 94 03 00
	00 00 00 80 3f	 mov	 DWORD PTR $T36[rbp-236], 1065353216 ; 3f800000H

; 225  : 	result[10] = 1.0f;

  00443	c7 85 a8 03 00
	00 00 00 80 3f	 mov	 DWORD PTR $T36[rbp-216], 1065353216 ; 3f800000H

; 226  : 	result[15] = 1.0f;

  0044d	c7 85 bc 03 00
	00 00 00 80 3f	 mov	 DWORD PTR $T36[rbp-196], 1065353216 ; 3f800000H

; 238  : 
; 239  : 	return result;
; 240  : }
; 241  : 
; 242  : Matrix Matrix::translate(float x, float y, float z)
; 243  : {
; 244  : 	Matrix result = identity();
; 245  : 	result[3] = x;

  00457	f3 0f 11 8d 8c
	03 00 00	 movss	 DWORD PTR $T36[rbp-244], xmm1

; 246  : 	result[7] = y;

  0045f	f3 0f 11 95 9c
	03 00 00	 movss	 DWORD PTR $T36[rbp-228], xmm2

; 247  : 	result[11] = z;

  00467	f3 0f 11 9d ac
	03 00 00	 movss	 DWORD PTR $T36[rbp-212], xmm3
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp

; 69   : 	gfxu::Uniforms::PMS.mult(geom::Matrix::translate(-state->cam.pos.x, -state->cam.pos.y, -state->cam.pos.z));

  0046f	0f 28 85 80 03
	00 00		 movaps	 xmm0, XMMWORD PTR $T36[rbp-256]
  00476	0f 29 85 50 02
	00 00		 movaps	 XMMWORD PTR $T30[rbp-256], xmm0
  0047d	0f 28 8d 90 03
	00 00		 movaps	 xmm1, XMMWORD PTR $T36[rbp-240]
  00484	0f 29 8d 60 02
	00 00		 movaps	 XMMWORD PTR $T30[rbp-240], xmm1
  0048b	0f 28 85 a0 03
	00 00		 movaps	 xmm0, XMMWORD PTR $T36[rbp-224]
  00492	0f 29 85 70 02
	00 00		 movaps	 XMMWORD PTR $T30[rbp-224], xmm0
  00499	0f 28 8d b0 03
	00 00		 movaps	 xmm1, XMMWORD PTR $T36[rbp-208]
  004a0	0f 29 8d 80 02
	00 00		 movaps	 XMMWORD PTR $T30[rbp-208], xmm1
  004a7	48 8d 95 50 02
	00 00		 lea	 rdx, QWORD PTR $T30[rbp-256]
  004ae	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?PMS@Uniforms@gfxu@@2VMatrixStack@2@A ; gfxu::Uniforms::PMS
  004b5	e8 00 00 00 00	 call	 ?mult@MatrixStack@gfxu@@QEAAXVMatrix@geom@@@Z ; gfxu::MatrixStack::mult
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp

; 696  : 	if(!uploaded)

  004ba	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?testure@@3PEAVTexture2D@gfxu@@EA ; testure
  004c1	44 38 78 11	 cmp	 BYTE PTR [rax+17], r15b
  004c5	75 0a		 jne	 SHORT $LN119@tick

; 697  : 	{
; 698  : 		if(!upload())

  004c7	48 8b c8	 mov	 rcx, rax
  004ca	e8 00 00 00 00	 call	 ?upload@Texture2D@gfxu@@QEAA_NXZ ; gfxu::Texture2D::upload

; 699  : 		{
; 700  : 			return;
; 701  : 		}
; 702  : 	}
; 703  : 	else

  004cf	eb 0d		 jmp	 SHORT $LN117@tick
$LN119@tick:

; 704  : 	{
; 705  : 		glBindTexture(GL_TEXTURE_2D, object);

  004d1	8b 10		 mov	 edx, DWORD PTR [rax]
  004d3	b9 e1 0d 00 00	 mov	 ecx, 3553		; 00000de1H
  004d8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_glBindTexture
$LN117@tick:
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp

; 76   : 	int xCam = floorf(state->cam.pos.x / 16.0f);

  004de	f3 41 0f 10 04
	24		 movss	 xmm0, DWORD PTR [r12]
  004e4	f3 0f 10 35 00
	00 00 00	 movss	 xmm6, DWORD PTR __real@3d800000
  004ec	f3 0f 59 c6	 mulss	 xmm0, xmm6
  004f0	e8 00 00 00 00	 call	 floorf
  004f5	f3 0f 2c c0	 cvttss2si eax, xmm0
  004f9	89 44 24 50	 mov	 DWORD PTR xCam$[rsp], eax

; 77   : 	int yCam = floorf(state->cam.pos.y / 16.0f);

  004fd	f3 41 0f 10 44
	24 04		 movss	 xmm0, DWORD PTR [r12+4]
  00504	f3 0f 59 c6	 mulss	 xmm0, xmm6
  00508	e8 00 00 00 00	 call	 floorf
  0050d	f3 0f 2c c0	 cvttss2si eax, xmm0
  00511	89 44 24 58	 mov	 DWORD PTR yCam$[rsp], eax

; 78   : 	int zCam = floorf(state->cam.pos.z / 16.0f);

  00515	f3 41 0f 10 44
	24 08		 movss	 xmm0, DWORD PTR [r12+8]
  0051c	f3 0f 59 c6	 mulss	 xmm0, xmm6
  00520	e8 00 00 00 00	 call	 floorf
  00525	f3 0f 2c c0	 cvttss2si eax, xmm0
  00529	89 44 24 54	 mov	 DWORD PTR zCam$[rsp], eax
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp

; 544  : 	return topmost;

  0052d	0f 10 05 28 00
	00 00		 movups	 xmm0, XMMWORD PTR ?PMS@Uniforms@gfxu@@2VMatrixStack@2@A+40
  00534	0f 29 85 80 04
	00 00		 movaps	 XMMWORD PTR projectionMatrix$[rbp-256], xmm0
  0053b	0f 10 0d 38 00
	00 00		 movups	 xmm1, XMMWORD PTR ?PMS@Uniforms@gfxu@@2VMatrixStack@2@A+56
  00542	0f 29 8d 90 04
	00 00		 movaps	 XMMWORD PTR projectionMatrix$[rbp-240], xmm1
  00549	0f 10 05 48 00
	00 00		 movups	 xmm0, XMMWORD PTR ?PMS@Uniforms@gfxu@@2VMatrixStack@2@A+72
  00550	0f 29 85 a0 04
	00 00		 movaps	 XMMWORD PTR projectionMatrix$[rbp-224], xmm0
  00557	0f 10 0d 58 00
	00 00		 movups	 xmm1, XMMWORD PTR ?PMS@Uniforms@gfxu@@2VMatrixStack@2@A+88
  0055e	0f 29 8d b0 04
	00 00		 movaps	 XMMWORD PTR projectionMatrix$[rbp-208], xmm1
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp

; 304  : 	return write(queue, 0, size, data);

  00565	48 8d 85 80 04
	00 00		 lea	 rax, QWORD PTR projectionMatrix$[rbp-256]
  0056c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00571	4c 8b 0d 10 00
	00 00		 mov	 r9, QWORD PTR ?projectionMatrixBuffer@@3VBuffer@cl@@A+16
  00578	e8 00 00 00 00	 call	 ?write@Buffer@cl@@QEAA_NAEAVCommandQueue@2@_K1PEBX@Z ; cl::Buffer::write
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp

; 84   : 	const size_t global_ws_1[] = {renderDistance * 2 + 2, renderDistance * 2 + 2, renderDistance * 2 + 2};

  0057d	48 c7 85 d8 05
	00 00 12 00 00
	00		 mov	 QWORD PTR global_ws_1$[rbp-256], 18
  00588	48 c7 85 e0 05
	00 00 12 00 00
	00		 mov	 QWORD PTR global_ws_1$[rbp-248], 18
  00593	48 c7 85 e8 05
	00 00 12 00 00
	00		 mov	 QWORD PTR global_ws_1$[rbp-240], 18

; 85   : 	const size_t local_ws_1[] = {1, 1, 1};

  0059e	4c 89 b5 c0 05
	00 00		 mov	 QWORD PTR local_ws_1$[rbp-256], r14
  005a5	4c 89 b5 c8 05
	00 00		 mov	 QWORD PTR local_ws_1$[rbp-248], r14
  005ac	4c 89 b5 d0 05
	00 00		 mov	 QWORD PTR local_ws_1$[rbp-240], r14
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 2265 : 		this->_Myres = this->_BUF_SIZE - 1;

  005b3	48 c7 45 70 0f
	00 00 00	 mov	 QWORD PTR $T16[rbp-232], 15

; 1145 : 		}
; 1146 : 
; 1147 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1148 : 		{	// assign _Count * _Ch
; 1149 : 		if (_Count == npos)
; 1150 : 			_Xlen();	// result too long
; 1151 : 
; 1152 : 		if (_Grow(_Count))
; 1153 : 			{	// make room and assign new stuff
; 1154 : 			_Chassign(0, _Count, _Ch);
; 1155 : 			_Eos(_Count);
; 1156 : 			}
; 1157 : 		return (*this);
; 1158 : 		}
; 1159 : 
; 1160 : 	template<class _Iter>
; 1161 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1162 : 			_Myt&>::type
; 1163 : 		assign(_Iter _First, _Iter _Last)
; 1164 : 		{	// assign [First, _Last), input iterators
; 1165 : 		return (replace(begin(), end(), _First, _Last));
; 1166 : 		}
; 1167 : 
; 1168 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1169 : 		{	// assign [First, _Last), const pointers
; 1170 : 		return (replace(begin(), end(), _First, _Last));
; 1171 : 		}
; 1172 : 
; 1173 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1174 : 		{	// assign [First, _Last), const_iterators
; 1175 : 		return (replace(begin(), end(), _First, _Last));
; 1176 : 		}
; 1177 : 
; 1178 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1179 : 		{	// insert _Right at _Off
; 1180 : 		return (insert(_Off, _Right, 0, npos));
; 1181 : 		}
; 1182 : 
; 1183 : 	_Myt& insert(size_type _Off,
; 1184 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1185 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1186 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1187 : 			_Xran();	// _Off or _Roff off end
; 1188 : 		size_type _Num = _Right.size() - _Roff;
; 1189 : 		if (_Num < _Count)
; 1190 : 			_Count = _Num;	// trim _Count to size
; 1191 : 		if (npos - this->_Mysize <= _Count)
; 1192 : 			_Xlen();	// result too long
; 1193 : 
; 1194 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1195 : 			{	// make room and insert new stuff
; 1196 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1197 : 				this->_Myptr() + _Off,
; 1198 : 				this->_Mysize - _Off);	// empty out hole
; 1199 : 			if (this == &_Right)
; 1200 : 				_Traits::move(this->_Myptr() + _Off,
; 1201 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1202 : 						_Count);	// substring
; 1203 : 			else
; 1204 : 				_Traits::copy(this->_Myptr() + _Off,
; 1205 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1206 : 			_Eos(_Num);
; 1207 : 			}
; 1208 : 		return (*this);
; 1209 : 		}
; 1210 : 
; 1211 : 	_Myt& insert(size_type _Off,
; 1212 : 		const _Elem *_Ptr, size_type _Count)
; 1213 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1214 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1215 : 		if (_Count != 0)
; 1216 : 			_DEBUG_POINTER(_Ptr);
; 1217 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1218 : 
; 1219 : 		if (_Inside(_Ptr))
; 1220 : 			return (insert(_Off, *this,
; 1221 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1222 : 		if (this->_Mysize < _Off)
; 1223 : 			_Xran();	// _Off off end
; 1224 : 		if (npos - this->_Mysize <= _Count)
; 1225 : 			_Xlen();	// result too long
; 1226 : 		size_type _Num;
; 1227 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1228 : 			{	// make room and insert new stuff
; 1229 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1230 : 				this->_Myptr() + _Off,
; 1231 : 				this->_Mysize - _Off);	// empty out hole
; 1232 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1233 : 			_Eos(_Num);
; 1234 : 			}
; 1235 : 		return (*this);
; 1236 : 		}
; 1237 : 
; 1238 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1239 : 		{	// insert [_Ptr, <null>) at _Off
; 1240 : 		_DEBUG_POINTER(_Ptr);
; 1241 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1242 : 		}
; 1243 : 
; 1244 : 	_Myt& insert(size_type _Off,
; 1245 : 		size_type _Count, _Elem _Ch)
; 1246 : 		{	// insert _Count * _Ch at _Off
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	iterator insert(const_iterator _Where)
; 1264 : 		{	// insert <null> at _Where
; 1265 : 		return (insert(_Where, _Elem()));
; 1266 : 		}
; 1267 : 
; 1268 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1269 : 		{	// insert _Ch at _Where
; 1270 : 		size_type _Off = _Pdif(_Where, begin());
; 1271 : 		insert(_Off, 1, _Ch);
; 1272 : 		return (begin() + _Off);
; 1273 : 		}
; 1274 : 
; 1275 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1276 : 		{	// insert _Count * _Elem at _Where
; 1277 : 		size_type _Off = _Pdif(_Where, begin());
; 1278 : 		insert(_Off, _Count, _Ch);
; 1279 : 		return (begin() + _Off);
; 1280 : 		}
; 1281 : 
; 1282 : 	template<class _Iter>
; 1283 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1284 : 			iterator>::type
; 1285 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1286 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1287 : 		size_type _Off = _Pdif(_Where, begin());
; 1288 : 		replace(_Where, _Where, _First, _Last);
; 1289 : 		return (begin() + _Off);
; 1290 : 		}
; 1291 : 
; 1292 : 	iterator insert(const_iterator _Where,
; 1293 : 		const_pointer _First, const_pointer _Last)
; 1294 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		replace(_Where, _Where, _First, _Last);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where,
; 1301 : 		const_iterator _First, const_iterator _Last)
; 1302 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1303 : 		size_type _Off = _Pdif(_Where, begin());
; 1304 : 		replace(_Where, _Where, _First, _Last);
; 1305 : 		return (begin() + _Off);
; 1306 : 		}
; 1307 : 
; 1308 : 	_Myt& erase(size_type _Off = 0)
; 1309 : 		{	// erase elements [_Off, ...)
; 1310 : 		if (this->_Mysize < _Off)
; 1311 : 			_Xran();	// _Off off end
; 1312 : 		_Eos(_Off);
; 1313 : 		return (*this);
; 1314 : 		}
; 1315 : 
; 1316 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1317 : 		{	// erase elements [_Off, _Off + _Count)
; 1318 : 		if (this->_Mysize < _Off)
; 1319 : 			_Xran();	// _Off off end
; 1320 : 		if (this->_Mysize - _Off <= _Count)
; 1321 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1322 : 		else if (0 < _Count)
; 1323 : 			{	// move elements down
; 1324 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1325 : 			size_type _Newsize = this->_Mysize - _Count;
; 1326 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1327 : 			_Eos(_Newsize);
; 1328 : 			}
; 1329 : 		return (*this);
; 1330 : 		}
; 1331 : 
; 1332 : 	iterator erase(const_iterator _Where)
; 1333 : 		{	// erase element at _Where
; 1334 : 		size_type _Count = _Pdif(_Where, begin());
; 1335 : 		erase(_Count, 1);
; 1336 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1337 : 		}
; 1338 : 
; 1339 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1340 : 		{	// erase substring [_First, _Last)
; 1341 : 		_DEBUG_RANGE(_First, _Last);
; 1342 : 		size_type _Count = _Pdif(_First, begin());
; 1343 : 		erase(_Count, _Pdif(_Last, _First));
; 1344 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1345 : 		}
; 1346 : 
; 1347 : 	void clear() _NOEXCEPT
; 1348 : 		{	// erase all
; 1349 : 		_Eos(0);
; 1350 : 		}
; 1351 : 
; 1352 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1353 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1354 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1355 : 		}
; 1356 : 
; 1357 : 	_Myt& replace(size_type _Off,
; 1358 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1359 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1360 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1361 : 			_Xran();	// _Off or _Roff off end
; 1362 : 		if (this->_Mysize - _Off < _N0)
; 1363 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1364 : 		size_type _Num = _Right.size() - _Roff;
; 1365 : 		if (_Num < _Count)
; 1366 : 			_Count = _Num;	// trim _Count to size
; 1367 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1368 : 			_Xlen();	// result too long
; 1369 : 
; 1370 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1371 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1372 : 		if (this->_Mysize < _Newsize)
; 1373 : 			_Grow(_Newsize);
; 1374 : 
; 1375 : 		if (this != &_Right)
; 1376 : 			{	// no overlap, just move down and copy in new stuff
; 1377 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1378 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1379 : 			_Traits::copy(this->_Myptr() + _Off,
; 1380 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1381 : 			}
; 1382 : 		else if (_Count <= _N0)
; 1383 : 			{	// hole doesn't get larger, just copy in substring
; 1384 : 			_Traits::move(this->_Myptr() + _Off,
; 1385 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1386 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1387 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1388 : 			}
; 1389 : 		else if (_Roff <= _Off)
; 1390 : 			{	// hole gets larger, substring begins before hole
; 1391 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1392 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1393 : 			_Traits::move(this->_Myptr() + _Off,
; 1394 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1395 : 			}
; 1396 : 		else if (_Off + _N0 <= _Roff)
; 1397 : 			{	// hole gets larger, substring begins after hole
; 1398 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1399 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1400 : 			_Traits::move(this->_Myptr() + _Off,
; 1401 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1402 : 				_Count);	// fill hole
; 1403 : 			}
; 1404 : 		else
; 1405 : 			{	// hole gets larger, substring begins in hole
; 1406 : 			_Traits::move(this->_Myptr() + _Off,
; 1407 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1408 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1409 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1410 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1411 : 				this->_Myptr() + _Roff + _Count,
; 1412 : 				_Count - _N0);	// fill rest of new hole
; 1413 : 			}
; 1414 : 
; 1415 : 		_Eos(_Newsize);
; 1416 : 		return (*this);
; 1417 : 		}
; 1418 : 
; 1419 : 	_Myt& replace(size_type _Off,
; 1420 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1421 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1422 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1423 : 		if (_Count != 0)
; 1424 : 			_DEBUG_POINTER(_Ptr);
; 1425 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1426 : 
; 1427 : 		if (_Inside(_Ptr))
; 1428 : 			return (replace(_Off, _N0, *this,
; 1429 : 				_Ptr - this->_Myptr(),
; 1430 : 				_Count));	// substring, replace carefully
; 1431 : 		if (this->_Mysize < _Off)
; 1432 : 			_Xran();	// _Off off end
; 1433 : 		if (this->_Mysize - _Off < _N0)
; 1434 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1435 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1436 : 			_Xlen();	// result too long
; 1437 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1438 : 
; 1439 : 		if (_Count < _N0)
; 1440 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1441 : 				this->_Myptr() + _Off + _N0,
; 1442 : 				_Nm);	// smaller hole, move tail up
; 1443 : 		size_type _Num;
; 1444 : 		if ((0 < _Count || 0 < _N0)
; 1445 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1446 : 			{	// make room and rearrange
; 1447 : 			if (_N0 < _Count)
; 1448 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1449 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1450 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1451 : 			_Eos(_Num);
; 1452 : 			}
; 1453 : 		return (*this);
; 1454 : 		}
; 1455 : 
; 1456 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1457 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1458 : 		_DEBUG_POINTER(_Ptr);
; 1459 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1460 : 		}
; 1461 : 
; 1462 : 	_Myt& replace(size_type _Off,
; 1463 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1464 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1465 : 		if (this->_Mysize < _Off)
; 1466 : 			_Xran();	// _Off off end
; 1467 : 		if (this->_Mysize - _Off < _N0)
; 1468 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1469 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1470 : 			_Xlen();	// result too long
; 1471 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1472 : 
; 1473 : 		if (_Count < _N0)
; 1474 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1475 : 				this->_Myptr() + _Off + _N0,
; 1476 : 				_Nm);	// smaller hole, move tail up
; 1477 : 		size_type _Num;
; 1478 : 		if ((0 < _Count || 0 < _N0)
; 1479 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1480 : 			{	// make room and rearrange
; 1481 : 			if (_N0 < _Count)
; 1482 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1483 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1484 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1485 : 			_Eos(_Num);
; 1486 : 			}
; 1487 : 		return (*this);
; 1488 : 		}
; 1489 : 
; 1490 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1491 : 		const _Myt& _Right)
; 1492 : 		{	// replace [_First, _Last) with _Right
; 1493 : 		return (replace(
; 1494 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1495 : 		}
; 1496 : 
; 1497 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1498 : 		const _Elem *_Ptr, size_type _Count)
; 1499 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1500 : 		return (replace(
; 1501 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1502 : 		}
; 1503 : 
; 1504 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1505 : 		const _Elem *_Ptr)
; 1506 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1507 : 		return (replace(
; 1508 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1509 : 		}
; 1510 : 
; 1511 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1512 : 		size_type _Count, _Elem _Ch)
; 1513 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1514 : 		return (replace(
; 1515 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1516 : 		}
; 1517 : 
; 1518 : 	template<class _Iter>
; 1519 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1520 : 			_Myt&>::type
; 1521 : 		replace(const_iterator _First, const_iterator _Last,
; 1522 : 			_Iter _First2, _Iter _Last2)
; 1523 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1524 : 		_Myt _Right(_First2, _Last2);
; 1525 : 		replace(_First, _Last, _Right);
; 1526 : 		return (*this);
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const_pointer _First2, const_pointer _Last2)
; 1531 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1532 : 		if (_First2 == _Last2)
; 1533 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1534 : 		else
; 1535 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1536 : 				&*_First2, _Last2 - _First2);
; 1537 : 		return (*this);
; 1538 : 		}
; 1539 : 
; 1540 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1541 : 		pointer _First2, pointer _Last2)
; 1542 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1543 : 		if (_First2 == _Last2)
; 1544 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1545 : 		else
; 1546 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1547 : 				&*_First2, _Last2 - _First2);
; 1548 : 		return (*this);
; 1549 : 		}
; 1550 : 
; 1551 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1552 : 		const_iterator _First2, const_iterator _Last2)
; 1553 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1554 : 		if (_First2 == _Last2)
; 1555 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1556 : 		else
; 1557 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1558 : 				&*_First2, _Last2 - _First2);
; 1559 : 		return (*this);
; 1560 : 		}
; 1561 : 
; 1562 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1563 : 		iterator _First2, iterator _Last2)
; 1564 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1565 : 		if (_First2 == _Last2)
; 1566 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1567 : 		else
; 1568 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1569 : 				&*_First2, _Last2 - _First2);
; 1570 : 		return (*this);
; 1571 : 		}
; 1572 : 
; 1573 : 	iterator begin() _NOEXCEPT
; 1574 : 		{	// return iterator for beginning of mutable sequence
; 1575 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1576 : 		}
; 1577 : 
; 1578 : 	const_iterator begin() const _NOEXCEPT
; 1579 : 		{	// return iterator for beginning of nonmutable sequence
; 1580 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1581 : 		}
; 1582 : 
; 1583 : 	iterator end() _NOEXCEPT
; 1584 : 		{	// return iterator for end of mutable sequence
; 1585 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1586 : 		}
; 1587 : 
; 1588 : 	const_iterator end() const _NOEXCEPT
; 1589 : 		{	// return iterator for end of nonmutable sequence
; 1590 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1591 : 		}
; 1592 : 
; 1593 : 	reverse_iterator rbegin() _NOEXCEPT
; 1594 : 		{	// return iterator for beginning of reversed mutable sequence
; 1595 : 		return (reverse_iterator(end()));
; 1596 : 		}
; 1597 : 
; 1598 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1600 : 		return (const_reverse_iterator(end()));
; 1601 : 		}
; 1602 : 
; 1603 : 	reverse_iterator rend() _NOEXCEPT
; 1604 : 		{	// return iterator for end of reversed mutable sequence
; 1605 : 		return (reverse_iterator(begin()));
; 1606 : 		}
; 1607 : 
; 1608 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1609 : 		{	// return iterator for end of reversed nonmutable sequence
; 1610 : 		return (const_reverse_iterator(begin()));
; 1611 : 		}
; 1612 : 
; 1613 :  #if _HAS_CPP0X
; 1614 : 	const_iterator cbegin() const _NOEXCEPT
; 1615 : 		{	// return iterator for beginning of nonmutable sequence
; 1616 : 		return (((const _Myt *)this)->begin());
; 1617 : 		}
; 1618 : 
; 1619 : 	const_iterator cend() const _NOEXCEPT
; 1620 : 		{	// return iterator for end of nonmutable sequence
; 1621 : 		return (((const _Myt *)this)->end());
; 1622 : 		}
; 1623 : 
; 1624 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1625 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1626 : 		return (((const _Myt *)this)->rbegin());
; 1627 : 		}
; 1628 : 
; 1629 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1630 : 		{	// return iterator for end of reversed nonmutable sequence
; 1631 : 		return (((const _Myt *)this)->rend());
; 1632 : 		}
; 1633 : 
; 1634 : 	void shrink_to_fit()
; 1635 : 		{	// reduce capacity
; 1636 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1637 : 			{	// worth shrinking, do it
; 1638 : 			_Myt _Tmp(*this);
; 1639 : 			swap(_Tmp);
; 1640 : 			}
; 1641 : 		}
; 1642 :  #endif /* _HAS_CPP0X */
; 1643 : 
; 1644 : 	reference at(size_type _Off)
; 1645 : 		{	// subscript mutable sequence with checking
; 1646 : 		if (this->_Mysize <= _Off)
; 1647 : 			_Xran();	// _Off off end
; 1648 : 		return (this->_Myptr()[_Off]);
; 1649 : 		}
; 1650 : 
; 1651 : 	const_reference at(size_type _Off) const
; 1652 : 		{	// subscript nonmutable sequence with checking
; 1653 : 		if (this->_Mysize <= _Off)
; 1654 : 			_Xran();	// _Off off end
; 1655 : 		return (this->_Myptr()[_Off]);
; 1656 : 		}
; 1657 : 
; 1658 : 	reference operator[](size_type _Off)
; 1659 : 		{	// subscript mutable sequence
; 1660 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1661 : 		if (this->_Mysize < _Off)	// sic
; 1662 : 			_DEBUG_ERROR("string subscript out of range");
; 1663 : 
; 1664 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1665 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1666 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1667 : 
; 1668 : 		return (this->_Myptr()[_Off]);
; 1669 : 		}
; 1670 : 
; 1671 : 	const_reference operator[](size_type _Off) const
; 1672 : 		{	// subscript nonmutable sequence
; 1673 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1674 : 		if (this->_Mysize < _Off)	// sic
; 1675 : 			_DEBUG_ERROR("string subscript out of range");
; 1676 : 
; 1677 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1678 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1679 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1680 : 
; 1681 : 		return (this->_Myptr()[_Off]);
; 1682 : 		}
; 1683 : 
; 1684 : 	void push_back(_Elem _Ch)
; 1685 : 		{	// insert element at end
; 1686 : 		insert(end(), _Ch);
; 1687 : 		}
; 1688 : 
; 1689 :  #if _HAS_CPP0X
; 1690 : 	void pop_back()
; 1691 : 		{	// erase element at end
; 1692 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1693 : 		}
; 1694 : 
; 1695 : 	reference front()
; 1696 : 		{	// return first element of mutable sequence
; 1697 : 		return (*begin());
; 1698 : 		}
; 1699 : 
; 1700 : 	const_reference front() const
; 1701 : 		{	// return first element of nonmutable sequence
; 1702 : 		return (*begin());
; 1703 : 		}
; 1704 : 
; 1705 : 	reference back()
; 1706 : 		{	// return last element of mutable sequence
; 1707 : 		return (*(end() - 1));
; 1708 : 		}
; 1709 : 
; 1710 : 	const_reference back() const
; 1711 : 		{	// return last element of nonmutable sequence
; 1712 : 		return (*(end() - 1));
; 1713 : 		}
; 1714 :  #endif /* _HAS_CPP0X */
; 1715 : 
; 1716 : 	const _Elem *c_str() const _NOEXCEPT
; 1717 : 		{	// return pointer to null-terminated nonmutable array
; 1718 : 		return (this->_Myptr());
; 1719 : 		}
; 1720 : 
; 1721 : 	const _Elem *data() const _NOEXCEPT
; 1722 : 		{	// return pointer to nonmutable array
; 1723 : 		return (c_str());
; 1724 : 		}
; 1725 : 
; 1726 : 	size_type length() const _NOEXCEPT
; 1727 : 		{	// return length of sequence
; 1728 : 		return (this->_Mysize);
; 1729 : 		}
; 1730 : 
; 1731 : 	size_type size() const _NOEXCEPT
; 1732 : 		{	// return length of sequence
; 1733 : 		return (this->_Mysize);
; 1734 : 		}
; 1735 : 
; 1736 : 	size_type max_size() const _NOEXCEPT
; 1737 : 		{	// return maximum possible length of sequence
; 1738 : 		size_type _Num = this->_Getal().max_size();
; 1739 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1740 : 		}
; 1741 : 
; 1742 : 	void resize(size_type _Newsize)
; 1743 : 		{	// determine new length, padding with null elements as needed
; 1744 : 		resize(_Newsize, _Elem());
; 1745 : 		}
; 1746 : 
; 1747 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1748 : 		{	// determine new length, padding with _Ch elements as needed
; 1749 : 		if (_Newsize <= this->_Mysize)
; 1750 : 			_Eos(_Newsize);
; 1751 : 		else
; 1752 : 			append(_Newsize - this->_Mysize, _Ch);
; 1753 : 		}
; 1754 : 
; 1755 : 	size_type capacity() const _NOEXCEPT
; 1756 : 		{	// return current length of allocated storage
; 1757 : 		return (this->_Myres);
; 1758 : 		}
; 1759 : 
; 1760 : 	void reserve(size_type _Newcap = 0)
; 1761 : 		{	// determine new minimum length of allocated storage
; 1762 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1763 : 			{	// change reservation
; 1764 : 			size_type _Size = this->_Mysize;
; 1765 : 			if (_Grow(_Newcap, true))
; 1766 : 				_Eos(_Size);
; 1767 : 			}
; 1768 : 		}
; 1769 : 
; 1770 : 	bool empty() const _NOEXCEPT
; 1771 : 		{	// test if sequence is empty
; 1772 : 		return (this->_Mysize == 0);
; 1773 : 		}
; 1774 : 
; 1775 : 	_SCL_INSECURE_DEPRECATE
; 1776 : 
; 1777 : 	size_type copy(_Elem *_Ptr,
; 1778 : 		size_type _Count, size_type _Off = 0) const
; 1779 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1780 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1781 : 		if (_Count != 0)
; 1782 : 			_DEBUG_POINTER(_Ptr);
; 1783 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1784 : 
; 1785 : 		if (this->_Mysize < _Off)
; 1786 : 			_Xran();	// _Off off end
; 1787 : 		if (this->_Mysize - _Off < _Count)
; 1788 : 			_Count = this->_Mysize - _Off;
; 1789 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1790 : 		return (_Count);
; 1791 : 		}
; 1792 : 
; 1793 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1794 : 		size_type _Count, size_type _Off = 0) const
; 1795 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1796 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1797 : 		if (_Count != 0)
; 1798 : 			_DEBUG_POINTER(_Dest);
; 1799 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1800 : 
; 1801 : 		if (this->_Mysize < _Off)
; 1802 : 			_Xran();	// _Off off end
; 1803 : 		if (this->_Mysize - _Off < _Count)
; 1804 : 			_Count = this->_Mysize - _Off;
; 1805 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1806 : 		return (_Count);
; 1807 : 		}
; 1808 : 
; 1809 : 	void _Swap_bx(_Myt& _Right)
; 1810 : 		{	// exchange _Bx with _Right._Bx
; 1811 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1812 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1813 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1814 : 			else
; 1815 : 				{	// swap large with small
; 1816 : 				pointer _Ptr = this->_Bx._Ptr;
; 1817 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1818 : 				_Traits::copy(this->_Bx._Buf,
; 1819 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1820 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1821 : 				}
; 1822 : 		else
; 1823 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1824 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1825 : 			else
; 1826 : 				{	// swap small with large
; 1827 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1828 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1829 : 				_Traits::copy(_Right._Bx._Buf,
; 1830 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1831 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1832 : 				}
; 1833 : 		}
; 1834 : 
; 1835 : 	void swap(_Myt& _Right)
; 1836 : 		{	// exchange contents with _Right
; 1837 : 		if (this == &_Right)
; 1838 : 			;	// same object, do nothing
; 1839 : 		else if (this->_Getal() == _Right._Getal())
; 1840 : 			{	// same allocator, swap control information
; 1841 : 			this->_Swap_all(_Right);
; 1842 : 			_Swap_bx(_Right);
; 1843 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1844 : 			_STD swap(this->_Myres, _Right._Myres);
; 1845 : 			}
; 1846 : 
; 1847 :  #if _HAS_CPP0X
; 1848 : 		else if (_Alty::propagate_on_container_swap::value)
; 1849 : 			{	// swap allocators and control information
; 1850 : 			this->_Swap_alloc(_Right);
; 1851 : 			_Swap_bx(_Right);
; 1852 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1853 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1854 : 			_STD swap(this->_Myres, _Right._Myres);
; 1855 : 			}
; 1856 :  #endif /* _HAS_CPP0X */
; 1857 : 
; 1858 : 		else
; 1859 : 			{	// different allocator, do multiple assigns
; 1860 : 			_Myt _Tmp = *this;
; 1861 : 
; 1862 : 			*this = _Right;
; 1863 : 			_Right = _Tmp;
; 1864 : 			}
; 1865 : 		}
; 1866 : 
; 1867 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1868 : 		{	// look for _Right beginning at or after _Off
; 1869 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1870 : 		}
; 1871 : 
; 1872 : 	size_type find(const _Elem *_Ptr,
; 1873 : 		size_type _Off, size_type _Count) const
; 1874 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1875 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1876 : 		if (_Count != 0)
; 1877 : 			_DEBUG_POINTER(_Ptr);
; 1878 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1879 : 
; 1880 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1881 : 			return (_Off);	// null string always matches (if inside string)
; 1882 : 
; 1883 : 		size_type _Nm;
; 1884 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1885 : 			{	// room for match, look for it
; 1886 : 			const _Elem *_Uptr, *_Vptr;
; 1887 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1888 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1889 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1890 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1891 : 					return (_Uptr - this->_Myptr());	// found a match
; 1892 : 			}
; 1893 : 
; 1894 : 		return (npos);	// no match
; 1895 : 		}
; 1896 : 
; 1897 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1898 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1899 : 		_DEBUG_POINTER(_Ptr);
; 1900 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1901 : 		}
; 1902 : 
; 1903 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1904 : 		{	// look for _Ch at or after _Off
; 1905 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1906 : 		}
; 1907 : 
; 1908 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1909 : 		{	// look for _Right beginning before _Off
; 1910 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1911 : 		}
; 1912 : 
; 1913 : 	size_type rfind(const _Elem *_Ptr,
; 1914 : 		size_type _Off, size_type _Count) const
; 1915 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1916 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1917 : 		if (_Count != 0)
; 1918 : 			_DEBUG_POINTER(_Ptr);
; 1919 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1920 : 
; 1921 : 		if (_Count == 0)
; 1922 : 			return (_Off < this->_Mysize ? _Off
; 1923 : 				: this->_Mysize);	// null always matches
; 1924 : 		if (_Count <= this->_Mysize)
; 1925 : 			{	// room for match, look for it
; 1926 : 			const _Elem *_Uptr = this->_Myptr() +
; 1927 : 				(_Off < this->_Mysize - _Count ? _Off
; 1928 : 					: this->_Mysize - _Count);
; 1929 : 			for (; ; --_Uptr)
; 1930 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1931 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1932 : 					return (_Uptr - this->_Myptr());	// found a match
; 1933 : 				else if (_Uptr == this->_Myptr())
; 1934 : 					break;	// at beginning, no more chance for match
; 1935 : 			}
; 1936 : 
; 1937 : 		return (npos);	// no match
; 1938 : 		}
; 1939 : 
; 1940 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1941 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1942 : 		_DEBUG_POINTER(_Ptr);
; 1943 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1944 : 		}
; 1945 : 
; 1946 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1947 : 		{	// look for _Ch before _Off
; 1948 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1949 : 		}
; 1950 : 
; 1951 : 	size_type find_first_of(const _Myt& _Right,
; 1952 : 		size_type _Off = 0) const _NOEXCEPT
; 1953 : 		{	// look for one of _Right at or after _Off
; 1954 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1955 : 		}
; 1956 : 
; 1957 : 	size_type find_first_of(const _Elem *_Ptr,
; 1958 : 		size_type _Off, size_type _Count) const
; 1959 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1960 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1961 : 		if (_Count != 0)
; 1962 : 			_DEBUG_POINTER(_Ptr);
; 1963 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1964 : 
; 1965 : 		if (0 < _Count && _Off < this->_Mysize)
; 1966 : 			{	// room for match, look for it
; 1967 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1968 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1969 : 				_Uptr < _Vptr; ++_Uptr)
; 1970 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1971 : 					return (_Uptr - this->_Myptr());	// found a match
; 1972 : 			}
; 1973 : 
; 1974 : 		return (npos);	// no match
; 1975 : 		}
; 1976 : 
; 1977 : 	size_type find_first_of(const _Elem *_Ptr,
; 1978 : 		size_type _Off = 0) const
; 1979 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1980 : 		_DEBUG_POINTER(_Ptr);
; 1981 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 1982 : 		}
; 1983 : 
; 1984 : 	size_type find_first_of(_Elem _Ch,
; 1985 : 		size_type _Off = 0) const
; 1986 : 		{	// look for _Ch at or after _Off
; 1987 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1988 : 		}
; 1989 : 
; 1990 : 	size_type find_last_of(const _Myt& _Right,
; 1991 : 		size_type _Off = npos) const _NOEXCEPT
; 1992 : 		{	// look for one of _Right before _Off
; 1993 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_last_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off, size_type _Count) const
; 1998 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 1999 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2000 : 		if (_Count != 0)
; 2001 : 			_DEBUG_POINTER(_Ptr);
; 2002 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2003 : 
; 2004 : 		if (0 < _Count && 0 < this->_Mysize)
; 2005 : 			{	// worth searching, do it
; 2006 : 			const _Elem *_Uptr = this->_Myptr()
; 2007 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2008 : 			for (; ; --_Uptr)
; 2009 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2010 : 					return (_Uptr - this->_Myptr());	// found a match
; 2011 : 				else if (_Uptr == this->_Myptr())
; 2012 : 					break;	// at beginning, no more chance for match
; 2013 : 			}
; 2014 : 
; 2015 : 		return (npos);	// no match
; 2016 : 		}
; 2017 : 
; 2018 : 	size_type find_last_of(const _Elem *_Ptr,
; 2019 : 		size_type _Off = npos) const
; 2020 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2021 : 		_DEBUG_POINTER(_Ptr);
; 2022 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2023 : 		}
; 2024 : 
; 2025 : 	size_type find_last_of(_Elem _Ch,
; 2026 : 		size_type _Off = npos) const
; 2027 : 		{	// look for _Ch before _Off
; 2028 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2029 : 		}
; 2030 : 
; 2031 : 	size_type find_first_not_of(const _Myt& _Right,
; 2032 : 		size_type _Off = 0) const _NOEXCEPT
; 2033 : 		{	// look for none of _Right at or after _Off
; 2034 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2035 : 			_Right.size()));
; 2036 : 		}
; 2037 : 
; 2038 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2039 : 		size_type _Off, size_type _Count) const
; 2040 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2041 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2042 : 		if (_Count != 0)
; 2043 : 			_DEBUG_POINTER(_Ptr);
; 2044 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2045 : 
; 2046 : 		if (_Off < this->_Mysize)
; 2047 : 			{	// room for match, look for it
; 2048 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2049 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2050 : 				_Uptr < _Vptr; ++_Uptr)
; 2051 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2052 : 					return (_Uptr - this->_Myptr());
; 2053 : 			}
; 2054 : 		return (npos);
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off = 0) const
; 2059 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2060 : 		_DEBUG_POINTER(_Ptr);
; 2061 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2062 : 		}
; 2063 : 
; 2064 : 	size_type find_first_not_of(_Elem _Ch,
; 2065 : 		size_type _Off = 0) const
; 2066 : 		{	// look for non _Ch at or after _Off
; 2067 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2068 : 		}
; 2069 : 
; 2070 : 	size_type find_last_not_of(const _Myt& _Right,
; 2071 : 		size_type _Off = npos) const _NOEXCEPT
; 2072 : 		{	// look for none of _Right before _Off
; 2073 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off, size_type _Count) const
; 2078 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2079 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2080 : 		if (_Count != 0)
; 2081 : 			_DEBUG_POINTER(_Ptr);
; 2082 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2083 : 
; 2084 : 		if (0 < this->_Mysize)
; 2085 : 			{	// worth searching, do it
; 2086 : 			const _Elem *_Uptr = this->_Myptr()
; 2087 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2088 : 			for (; ; --_Uptr)
; 2089 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2090 : 					return (_Uptr - this->_Myptr());
; 2091 : 				else if (_Uptr == this->_Myptr())
; 2092 : 					break;
; 2093 : 			}
; 2094 : 		return (npos);
; 2095 : 		}
; 2096 : 
; 2097 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2098 : 		size_type _Off = npos) const
; 2099 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2100 : 		_DEBUG_POINTER(_Ptr);
; 2101 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2102 : 		}
; 2103 : 
; 2104 : 	size_type find_last_not_of(_Elem _Ch,
; 2105 : 		size_type _Off = npos) const
; 2106 : 		{	// look for non _Ch before _Off
; 2107 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2108 : 		}
; 2109 : 
; 2110 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2111 : 		{	// return [_Off, _Off + _Count) as new string
; 2112 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2113 : 		}
; 2114 : 
; 2115 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2116 : 		{	// compare [0, _Mysize) with _Right
; 2117 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2118 : 		}
; 2119 : 
; 2120 : 	int compare(size_type _Off, size_type _N0,
; 2121 : 		const _Myt& _Right) const
; 2122 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2123 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2124 : 		}
; 2125 : 
; 2126 : 	int compare(size_type _Off,
; 2127 : 		size_type _N0, const _Myt& _Right,
; 2128 : 		size_type _Roff, size_type _Count) const
; 2129 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2130 : 		if (_Right.size() < _Roff)
; 2131 : 			_Xran();	// _Off off end
; 2132 : 		if (_Right._Mysize - _Roff < _Count)
; 2133 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2134 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2135 : 		}
; 2136 : 
; 2137 : 	int compare(const _Elem *_Ptr) const
; 2138 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2139 : 		_DEBUG_POINTER(_Ptr);
; 2140 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2141 : 		}
; 2142 : 
; 2143 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2144 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2145 : 		_DEBUG_POINTER(_Ptr);
; 2146 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2147 : 		}
; 2148 : 
; 2149 : 	int compare(size_type _Off,
; 2150 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2151 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2152 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2153 : 		if (_Count != 0)
; 2154 : 			_DEBUG_POINTER(_Ptr);
; 2155 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2156 : 
; 2157 : 		if (this->_Mysize < _Off)
; 2158 : 			_Xran();	// _Off off end
; 2159 : 		if (this->_Mysize - _Off < _N0)
; 2160 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2161 : 
; 2162 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2163 : 			_N0 < _Count ? _N0 : _Count);
; 2164 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2165 : 			: _N0 == _Count ? 0 : +1);
; 2166 : 		}
; 2167 : 
; 2168 : 	allocator_type get_allocator() const _NOEXCEPT
; 2169 : 		{	// return allocator object for values
; 2170 : 		return (this->_Getal());
; 2171 : 		}
; 2172 : 
; 2173 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2174 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2175 : 		if (_Count == 1)
; 2176 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2177 : 		else
; 2178 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2179 : 		}
; 2180 : 
; 2181 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2182 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2183 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2184 : 		if (max_size() < _Newres)
; 2185 : 			_Newres = _Newsize;	// undo roundup if too big
; 2186 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2187 : 			;
; 2188 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2189 : 			_Newres = this->_Myres
; 2190 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2191 : 		else
; 2192 : 			_Newres = max_size();	// settle for max_size()
; 2193 : 
; 2194 : 		_Elem *_Ptr;
; 2195 : 		_TRY_BEGIN
; 2196 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2197 : 		_CATCH_ALL
; 2198 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2199 : 			_TRY_BEGIN
; 2200 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2201 : 			_CATCH_ALL
; 2202 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2203 : 			_RERAISE;
; 2204 : 			_CATCH_END
; 2205 : 		_CATCH_END
; 2206 : 
; 2207 : 		if (0 < _Oldlen)
; 2208 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2209 : 				_Oldlen);	// copy existing elements
; 2210 : 		_Tidy(true);
; 2211 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2212 : 		this->_Myres = _Newres;
; 2213 : 		_Eos(_Oldlen);
; 2214 : 		}
; 2215 : 
; 2216 : 	void _Eos(size_type _Newsize)
; 2217 : 		{	// set new length and null terminator
; 2218 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  005bb	4c 89 7d 68	 mov	 QWORD PTR $T16[rbp-240], r15
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  005bf	44 88 7d 58	 mov	 BYTE PTR $T16[rbp-256], r15b
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 1144 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

  005c3	41 b8 0d 00 00
	00		 mov	 r8d, 13
  005c9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG4294950235
  005d0	48 8d 4d 58	 lea	 rcx, QWORD PTR $T16[rbp-256]
  005d4	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp

; 87   : 	if(!program.prepare("gridTransform")) GlobalThread::stop = true;

  005d9	48 8d 55 58	 lea	 rdx, QWORD PTR $T16[rbp-256]
  005dd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?program@@3VProgram@cl@@A ; program
  005e4	e8 00 00 00 00	 call	 ?prepare@Program@cl@@QEAA_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; cl::Program::prepare
  005e9	0f b6 0d 00 00
	00 00		 movzx	 ecx, BYTE PTR ?stop@GlobalThread@@3_NA ; GlobalThread::stop
  005f0	84 c0		 test	 al, al
  005f2	41 0f 44 ce	 cmove	 ecx, r14d
  005f6	88 0d 00 00 00
	00		 mov	 BYTE PTR ?stop@GlobalThread@@3_NA, cl ; GlobalThread::stop
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp

; 182  : 	if(!preparedKernel)

  005fc	41 be 2c 00 00
	00		 mov	 r14d, 44		; 0000002cH
  00602	49 83 cd ff	 or	 r13, -1
  00606	48 8b 0d 20 00
	00 00		 mov	 rcx, QWORD PTR ?program@@3VProgram@cl@@A+32
  0060d	48 85 c9	 test	 rcx, rcx
  00610	0f 85 9c 00 00
	00		 jne	 $LN171@tick

; 183  : 	{
; 184  : 		GLWindow::instance->postError("Tried to set argument for unprepared kernel", "OpenCL kernel argument error");

  00616	48 8b 35 00 00
	00 00		 mov	 rsi, QWORD PTR ?instance@GLWindow@@2PEAV1@EA ; GLWindow::instance
; File c:\users\glenn\documents\github\wind\project\wind\wind\window.cpp

; 218  : 	wchar_t* wText = new wchar_t[lText + 1];

  0061d	b8 02 00 00 00	 mov	 eax, 2
  00622	49 f7 e6	 mul	 r14
  00625	49 0f 40 c5	 cmovo	 rax, r13
  00629	48 8b c8	 mov	 rcx, rax
  0062c	e8 00 00 00 00	 call	 ??_U@YAPEAX_K@Z		; operator new[]
  00631	48 8b f8	 mov	 rdi, rax

; 219  : 	mbstowcs_s(NULL, wText, lText + 1, text, lText);

  00634	48 c7 44 24 20
	2b 00 00 00	 mov	 QWORD PTR [rsp+32], 43	; 0000002bH
  0063d	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG4294956367
  00644	45 8b c6	 mov	 r8d, r14d
  00647	48 8b d0	 mov	 rdx, rax
  0064a	33 c9		 xor	 ecx, ecx
  0064c	e8 00 00 00 00	 call	 mbstowcs_s

; 220  : 
; 221  : 	size_t lCap = strlen(text);
; 222  : 	wchar_t* wCap = new wchar_t[lCap + 1];

  00651	b8 02 00 00 00	 mov	 eax, 2
  00656	49 f7 e6	 mul	 r14
  00659	49 0f 40 c5	 cmovo	 rax, r13
  0065d	48 8b c8	 mov	 rcx, rax
  00660	e8 00 00 00 00	 call	 ??_U@YAPEAX_K@Z		; operator new[]
  00665	48 8b d8	 mov	 rbx, rax

; 223  : 	mbstowcs_s(NULL, wCap, lCap + 1, caption, lCap);

  00668	48 c7 44 24 20
	2b 00 00 00	 mov	 QWORD PTR [rsp+32], 43	; 0000002bH
  00671	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG4294956368
  00678	45 8b c6	 mov	 r8d, r14d
  0067b	48 8b d0	 mov	 rdx, rax
  0067e	33 c9		 xor	 ecx, ecx
  00680	e8 00 00 00 00	 call	 mbstowcs_s

; 193  : }
; 194  : 
; 195  : void GLWindow::makeCurrent()
; 196  : {
; 197  : 	wglMakeCurrent(hDC, hRC);
; 198  : }
; 199  : 
; 200  : bool GLWindow::isOK()
; 201  : {
; 202  : 	return OK;
; 203  : }
; 204  : 
; 205  : HWND GLWindow::getHWnd()
; 206  : {
; 207  : 	return hWnd;
; 208  : }
; 209  : 
; 210  : void GLWindow::messageBox(LPCWSTR lpText, LPCWSTR lpCaption, UINT uType)
; 211  : {
; 212  : 	MessageBox(hWnd, lpText, lpText, uType);

  00685	45 8d 4e e4	 lea	 r9d, QWORD PTR [r14-28]
  00689	4c 8b c7	 mov	 r8, rdi
  0068c	48 8b d7	 mov	 rdx, rdi
  0068f	48 8b 4e 10	 mov	 rcx, QWORD PTR [rsi+16]
  00693	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_MessageBoxW

; 224  : 
; 225  : 	messageBox(wText, wCap, MB_OK | MB_ICONERROR);
; 226  : 
; 227  : 	GlobalThread::stop = true;

  00699	c6 05 00 00 00
	00 01		 mov	 BYTE PTR ?stop@GlobalThread@@3_NA, 1 ; GlobalThread::stop

; 228  : 
; 229  : 	delete wText;

  006a0	48 8b cf	 mov	 rcx, rdi
  006a3	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete

; 230  : 	delete wCap;

  006a8	48 8b cb	 mov	 rcx, rbx
  006ab	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp

; 185  : 		return false;

  006b0	eb 2a		 jmp	 SHORT $LN1661@tick
$LN171@tick:

; 186  : 	}
; 187  : 	cl_int error = clSetKernelArg(preparedKernel, index, size, value);

  006b2	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:renderDistance
  006b9	33 d2		 xor	 edx, edx
  006bb	44 8d 42 04	 lea	 r8d, QWORD PTR [rdx+4]
  006bf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_clSetKernelArg

; 188  : 	if(error != CL_SUCCESS)

  006c5	85 c0		 test	 eax, eax
  006c7	74 1a		 je	 SHORT $LN33@tick

; 189  : 	{
; 190  : 		GLWindow::instance->postError("Failed to set kernel argument", "OpenCL kernel argument error");

  006c9	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG4294956366
  006d0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG4294956365
  006d7	e8 00 00 00 00	 call	 ?postError@GLWindow@@QEAAXPEBD0@Z ; GLWindow::postError
$LN1661@tick:
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp

; 88   : 	if(!program.setArgument(0, sizeof(const unsigned int), &renderDistance)) GlobalThread::stop = true;

  006dc	c6 05 00 00 00
	00 01		 mov	 BYTE PTR ?stop@GlobalThread@@3_NA, 1 ; GlobalThread::stop
$LN33@tick:
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp

; 182  : 	if(!preparedKernel)

  006e3	48 8b 0d 20 00
	00 00		 mov	 rcx, QWORD PTR ?program@@3VProgram@cl@@A+32
  006ea	48 85 c9	 test	 rcx, rcx
  006ed	0f 85 9e 00 00
	00		 jne	 $LN181@tick

; 183  : 	{
; 184  : 		GLWindow::instance->postError("Tried to set argument for unprepared kernel", "OpenCL kernel argument error");

  006f3	48 8b 35 00 00
	00 00		 mov	 rsi, QWORD PTR ?instance@GLWindow@@2PEAV1@EA ; GLWindow::instance
; File c:\users\glenn\documents\github\wind\project\wind\wind\window.cpp

; 218  : 	wchar_t* wText = new wchar_t[lText + 1];

  006fa	b8 02 00 00 00	 mov	 eax, 2
  006ff	49 f7 e6	 mul	 r14
  00702	49 0f 40 c5	 cmovo	 rax, r13
  00706	48 8b c8	 mov	 rcx, rax
  00709	e8 00 00 00 00	 call	 ??_U@YAPEAX_K@Z		; operator new[]
  0070e	48 8b f8	 mov	 rdi, rax

; 219  : 	mbstowcs_s(NULL, wText, lText + 1, text, lText);

  00711	48 c7 44 24 20
	2b 00 00 00	 mov	 QWORD PTR [rsp+32], 43	; 0000002bH
  0071a	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG4294956367
  00721	4d 8b c6	 mov	 r8, r14
  00724	48 8b d0	 mov	 rdx, rax
  00727	33 c9		 xor	 ecx, ecx
  00729	e8 00 00 00 00	 call	 mbstowcs_s

; 220  : 
; 221  : 	size_t lCap = strlen(text);
; 222  : 	wchar_t* wCap = new wchar_t[lCap + 1];

  0072e	b8 02 00 00 00	 mov	 eax, 2
  00733	49 f7 e6	 mul	 r14
  00736	49 0f 40 c5	 cmovo	 rax, r13
  0073a	48 8b c8	 mov	 rcx, rax
  0073d	e8 00 00 00 00	 call	 ??_U@YAPEAX_K@Z		; operator new[]
  00742	48 8b d8	 mov	 rbx, rax

; 223  : 	mbstowcs_s(NULL, wCap, lCap + 1, caption, lCap);

  00745	48 c7 44 24 20
	2b 00 00 00	 mov	 QWORD PTR [rsp+32], 43	; 0000002bH
  0074e	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG4294956368
  00755	4d 8b c6	 mov	 r8, r14
  00758	48 8b d0	 mov	 rdx, rax
  0075b	33 c9		 xor	 ecx, ecx
  0075d	e8 00 00 00 00	 call	 mbstowcs_s

; 193  : }
; 194  : 
; 195  : void GLWindow::makeCurrent()
; 196  : {
; 197  : 	wglMakeCurrent(hDC, hRC);
; 198  : }
; 199  : 
; 200  : bool GLWindow::isOK()
; 201  : {
; 202  : 	return OK;
; 203  : }
; 204  : 
; 205  : HWND GLWindow::getHWnd()
; 206  : {
; 207  : 	return hWnd;
; 208  : }
; 209  : 
; 210  : void GLWindow::messageBox(LPCWSTR lpText, LPCWSTR lpCaption, UINT uType)
; 211  : {
; 212  : 	MessageBox(hWnd, lpText, lpText, uType);

  00762	41 b9 10 00 00
	00		 mov	 r9d, 16
  00768	4c 8b c7	 mov	 r8, rdi
  0076b	48 8b d7	 mov	 rdx, rdi
  0076e	48 8b 4e 10	 mov	 rcx, QWORD PTR [rsi+16]
  00772	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_MessageBoxW

; 224  : 
; 225  : 	messageBox(wText, wCap, MB_OK | MB_ICONERROR);
; 226  : 
; 227  : 	GlobalThread::stop = true;

  00778	c6 05 00 00 00
	00 01		 mov	 BYTE PTR ?stop@GlobalThread@@3_NA, 1 ; GlobalThread::stop

; 228  : 
; 229  : 	delete wText;

  0077f	48 8b cf	 mov	 rcx, rdi
  00782	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete

; 230  : 	delete wCap;

  00787	48 8b cb	 mov	 rcx, rbx
  0078a	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp

; 185  : 		return false;

  0078f	eb 2d		 jmp	 SHORT $LN1662@tick
$LN181@tick:

; 186  : 	}
; 187  : 	cl_int error = clSetKernelArg(preparedKernel, index, size, value);

  00791	4c 8d 0d 08 00
	00 00		 lea	 r9, OFFSET FLAT:?projectionMatrixBuffer@@3VBuffer@cl@@A+8
  00798	ba 01 00 00 00	 mov	 edx, 1
  0079d	44 8d 42 07	 lea	 r8d, QWORD PTR [rdx+7]
  007a1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_clSetKernelArg

; 188  : 	if(error != CL_SUCCESS)

  007a7	85 c0		 test	 eax, eax
  007a9	74 1a		 je	 SHORT $LN32@tick

; 189  : 	{
; 190  : 		GLWindow::instance->postError("Failed to set kernel argument", "OpenCL kernel argument error");

  007ab	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG4294956366
  007b2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG4294956365
  007b9	e8 00 00 00 00	 call	 ?postError@GLWindow@@QEAAXPEBD0@Z ; GLWindow::postError
$LN1662@tick:
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp

; 89   : 	if(!program.setArgument(1, sizeof(cl_mem), &projectionMatrixBuffer)) GlobalThread::stop = true;

  007be	c6 05 00 00 00
	00 01		 mov	 BYTE PTR ?stop@GlobalThread@@3_NA, 1 ; GlobalThread::stop
$LN32@tick:
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp

; 182  : 	if(!preparedKernel)

  007c5	48 8b 0d 20 00
	00 00		 mov	 rcx, QWORD PTR ?program@@3VProgram@cl@@A+32
  007cc	48 85 c9	 test	 rcx, rcx
  007cf	0f 85 9e 00 00
	00		 jne	 $LN189@tick

; 183  : 	{
; 184  : 		GLWindow::instance->postError("Tried to set argument for unprepared kernel", "OpenCL kernel argument error");

  007d5	48 8b 35 00 00
	00 00		 mov	 rsi, QWORD PTR ?instance@GLWindow@@2PEAV1@EA ; GLWindow::instance
; File c:\users\glenn\documents\github\wind\project\wind\wind\window.cpp

; 218  : 	wchar_t* wText = new wchar_t[lText + 1];

  007dc	b8 02 00 00 00	 mov	 eax, 2
  007e1	49 f7 e6	 mul	 r14
  007e4	49 0f 40 c5	 cmovo	 rax, r13
  007e8	48 8b c8	 mov	 rcx, rax
  007eb	e8 00 00 00 00	 call	 ??_U@YAPEAX_K@Z		; operator new[]
  007f0	48 8b f8	 mov	 rdi, rax

; 219  : 	mbstowcs_s(NULL, wText, lText + 1, text, lText);

  007f3	48 c7 44 24 20
	2b 00 00 00	 mov	 QWORD PTR [rsp+32], 43	; 0000002bH
  007fc	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG4294956367
  00803	4d 8b c6	 mov	 r8, r14
  00806	48 8b d0	 mov	 rdx, rax
  00809	33 c9		 xor	 ecx, ecx
  0080b	e8 00 00 00 00	 call	 mbstowcs_s

; 220  : 
; 221  : 	size_t lCap = strlen(text);
; 222  : 	wchar_t* wCap = new wchar_t[lCap + 1];

  00810	b8 02 00 00 00	 mov	 eax, 2
  00815	49 f7 e6	 mul	 r14
  00818	49 0f 40 c5	 cmovo	 rax, r13
  0081c	48 8b c8	 mov	 rcx, rax
  0081f	e8 00 00 00 00	 call	 ??_U@YAPEAX_K@Z		; operator new[]
  00824	48 8b d8	 mov	 rbx, rax

; 223  : 	mbstowcs_s(NULL, wCap, lCap + 1, caption, lCap);

  00827	48 c7 44 24 20
	2b 00 00 00	 mov	 QWORD PTR [rsp+32], 43	; 0000002bH
  00830	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG4294956368
  00837	4d 8b c6	 mov	 r8, r14
  0083a	48 8b d0	 mov	 rdx, rax
  0083d	33 c9		 xor	 ecx, ecx
  0083f	e8 00 00 00 00	 call	 mbstowcs_s

; 193  : }
; 194  : 
; 195  : void GLWindow::makeCurrent()
; 196  : {
; 197  : 	wglMakeCurrent(hDC, hRC);
; 198  : }
; 199  : 
; 200  : bool GLWindow::isOK()
; 201  : {
; 202  : 	return OK;
; 203  : }
; 204  : 
; 205  : HWND GLWindow::getHWnd()
; 206  : {
; 207  : 	return hWnd;
; 208  : }
; 209  : 
; 210  : void GLWindow::messageBox(LPCWSTR lpText, LPCWSTR lpCaption, UINT uType)
; 211  : {
; 212  : 	MessageBox(hWnd, lpText, lpText, uType);

  00844	41 b9 10 00 00
	00		 mov	 r9d, 16
  0084a	4c 8b c7	 mov	 r8, rdi
  0084d	48 8b d7	 mov	 rdx, rdi
  00850	48 8b 4e 10	 mov	 rcx, QWORD PTR [rsi+16]
  00854	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_MessageBoxW

; 224  : 
; 225  : 	messageBox(wText, wCap, MB_OK | MB_ICONERROR);
; 226  : 
; 227  : 	GlobalThread::stop = true;

  0085a	c6 05 00 00 00
	00 01		 mov	 BYTE PTR ?stop@GlobalThread@@3_NA, 1 ; GlobalThread::stop

; 228  : 
; 229  : 	delete wText;

  00861	48 8b cf	 mov	 rcx, rdi
  00864	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete

; 230  : 	delete wCap;

  00869	48 8b cb	 mov	 rcx, rbx
  0086c	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp

; 185  : 		return false;

  00871	eb 2b		 jmp	 SHORT $LN1663@tick
$LN189@tick:

; 186  : 	}
; 187  : 	cl_int error = clSetKernelArg(preparedKernel, index, size, value);

  00873	4c 8d 4c 24 50	 lea	 r9, QWORD PTR xCam$[rsp]
  00878	ba 02 00 00 00	 mov	 edx, 2
  0087d	44 8d 42 02	 lea	 r8d, QWORD PTR [rdx+2]
  00881	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_clSetKernelArg

; 188  : 	if(error != CL_SUCCESS)

  00887	85 c0		 test	 eax, eax
  00889	74 1a		 je	 SHORT $LN31@tick

; 189  : 	{
; 190  : 		GLWindow::instance->postError("Failed to set kernel argument", "OpenCL kernel argument error");

  0088b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG4294956366
  00892	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG4294956365
  00899	e8 00 00 00 00	 call	 ?postError@GLWindow@@QEAAXPEBD0@Z ; GLWindow::postError
$LN1663@tick:
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp

; 90   : 	if(!program.setArgument(2, sizeof(const int), &xCam)) GlobalThread::stop = true;

  0089e	c6 05 00 00 00
	00 01		 mov	 BYTE PTR ?stop@GlobalThread@@3_NA, 1 ; GlobalThread::stop
$LN31@tick:
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp

; 182  : 	if(!preparedKernel)

  008a5	48 8b 0d 20 00
	00 00		 mov	 rcx, QWORD PTR ?program@@3VProgram@cl@@A+32
  008ac	48 85 c9	 test	 rcx, rcx
  008af	0f 85 9e 00 00
	00		 jne	 $LN197@tick

; 183  : 	{
; 184  : 		GLWindow::instance->postError("Tried to set argument for unprepared kernel", "OpenCL kernel argument error");

  008b5	48 8b 35 00 00
	00 00		 mov	 rsi, QWORD PTR ?instance@GLWindow@@2PEAV1@EA ; GLWindow::instance
; File c:\users\glenn\documents\github\wind\project\wind\wind\window.cpp

; 218  : 	wchar_t* wText = new wchar_t[lText + 1];

  008bc	b8 02 00 00 00	 mov	 eax, 2
  008c1	49 f7 e6	 mul	 r14
  008c4	49 0f 40 c5	 cmovo	 rax, r13
  008c8	48 8b c8	 mov	 rcx, rax
  008cb	e8 00 00 00 00	 call	 ??_U@YAPEAX_K@Z		; operator new[]
  008d0	48 8b f8	 mov	 rdi, rax

; 219  : 	mbstowcs_s(NULL, wText, lText + 1, text, lText);

  008d3	48 c7 44 24 20
	2b 00 00 00	 mov	 QWORD PTR [rsp+32], 43	; 0000002bH
  008dc	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG4294956367
  008e3	4d 8b c6	 mov	 r8, r14
  008e6	48 8b d0	 mov	 rdx, rax
  008e9	33 c9		 xor	 ecx, ecx
  008eb	e8 00 00 00 00	 call	 mbstowcs_s

; 220  : 
; 221  : 	size_t lCap = strlen(text);
; 222  : 	wchar_t* wCap = new wchar_t[lCap + 1];

  008f0	b8 02 00 00 00	 mov	 eax, 2
  008f5	49 f7 e6	 mul	 r14
  008f8	49 0f 40 c5	 cmovo	 rax, r13
  008fc	48 8b c8	 mov	 rcx, rax
  008ff	e8 00 00 00 00	 call	 ??_U@YAPEAX_K@Z		; operator new[]
  00904	48 8b d8	 mov	 rbx, rax

; 223  : 	mbstowcs_s(NULL, wCap, lCap + 1, caption, lCap);

  00907	48 c7 44 24 20
	2b 00 00 00	 mov	 QWORD PTR [rsp+32], 43	; 0000002bH
  00910	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG4294956368
  00917	4d 8b c6	 mov	 r8, r14
  0091a	48 8b d0	 mov	 rdx, rax
  0091d	33 c9		 xor	 ecx, ecx
  0091f	e8 00 00 00 00	 call	 mbstowcs_s

; 193  : }
; 194  : 
; 195  : void GLWindow::makeCurrent()
; 196  : {
; 197  : 	wglMakeCurrent(hDC, hRC);
; 198  : }
; 199  : 
; 200  : bool GLWindow::isOK()
; 201  : {
; 202  : 	return OK;
; 203  : }
; 204  : 
; 205  : HWND GLWindow::getHWnd()
; 206  : {
; 207  : 	return hWnd;
; 208  : }
; 209  : 
; 210  : void GLWindow::messageBox(LPCWSTR lpText, LPCWSTR lpCaption, UINT uType)
; 211  : {
; 212  : 	MessageBox(hWnd, lpText, lpText, uType);

  00924	41 b9 10 00 00
	00		 mov	 r9d, 16
  0092a	4c 8b c7	 mov	 r8, rdi
  0092d	48 8b d7	 mov	 rdx, rdi
  00930	48 8b 4e 10	 mov	 rcx, QWORD PTR [rsi+16]
  00934	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_MessageBoxW

; 224  : 
; 225  : 	messageBox(wText, wCap, MB_OK | MB_ICONERROR);
; 226  : 
; 227  : 	GlobalThread::stop = true;

  0093a	c6 05 00 00 00
	00 01		 mov	 BYTE PTR ?stop@GlobalThread@@3_NA, 1 ; GlobalThread::stop

; 228  : 
; 229  : 	delete wText;

  00941	48 8b cf	 mov	 rcx, rdi
  00944	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete

; 230  : 	delete wCap;

  00949	48 8b cb	 mov	 rcx, rbx
  0094c	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp

; 185  : 		return false;

  00951	eb 2b		 jmp	 SHORT $LN1664@tick
$LN197@tick:

; 186  : 	}
; 187  : 	cl_int error = clSetKernelArg(preparedKernel, index, size, value);

  00953	4c 8d 4c 24 58	 lea	 r9, QWORD PTR yCam$[rsp]
  00958	ba 03 00 00 00	 mov	 edx, 3
  0095d	44 8d 42 01	 lea	 r8d, QWORD PTR [rdx+1]
  00961	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_clSetKernelArg

; 188  : 	if(error != CL_SUCCESS)

  00967	85 c0		 test	 eax, eax
  00969	74 1a		 je	 SHORT $LN30@tick

; 189  : 	{
; 190  : 		GLWindow::instance->postError("Failed to set kernel argument", "OpenCL kernel argument error");

  0096b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG4294956366
  00972	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG4294956365
  00979	e8 00 00 00 00	 call	 ?postError@GLWindow@@QEAAXPEBD0@Z ; GLWindow::postError
$LN1664@tick:
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp

; 91   : 	if(!program.setArgument(3, sizeof(const int), &yCam)) GlobalThread::stop = true;

  0097e	c6 05 00 00 00
	00 01		 mov	 BYTE PTR ?stop@GlobalThread@@3_NA, 1 ; GlobalThread::stop
$LN30@tick:
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp

; 182  : 	if(!preparedKernel)

  00985	48 8b 0d 20 00
	00 00		 mov	 rcx, QWORD PTR ?program@@3VProgram@cl@@A+32
  0098c	48 85 c9	 test	 rcx, rcx
  0098f	0f 85 9e 00 00
	00		 jne	 $LN205@tick

; 183  : 	{
; 184  : 		GLWindow::instance->postError("Tried to set argument for unprepared kernel", "OpenCL kernel argument error");

  00995	48 8b 35 00 00
	00 00		 mov	 rsi, QWORD PTR ?instance@GLWindow@@2PEAV1@EA ; GLWindow::instance
; File c:\users\glenn\documents\github\wind\project\wind\wind\window.cpp

; 218  : 	wchar_t* wText = new wchar_t[lText + 1];

  0099c	b8 02 00 00 00	 mov	 eax, 2
  009a1	49 f7 e6	 mul	 r14
  009a4	49 0f 40 c5	 cmovo	 rax, r13
  009a8	48 8b c8	 mov	 rcx, rax
  009ab	e8 00 00 00 00	 call	 ??_U@YAPEAX_K@Z		; operator new[]
  009b0	48 8b f8	 mov	 rdi, rax

; 219  : 	mbstowcs_s(NULL, wText, lText + 1, text, lText);

  009b3	48 c7 44 24 20
	2b 00 00 00	 mov	 QWORD PTR [rsp+32], 43	; 0000002bH
  009bc	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG4294956367
  009c3	4d 8b c6	 mov	 r8, r14
  009c6	48 8b d0	 mov	 rdx, rax
  009c9	33 c9		 xor	 ecx, ecx
  009cb	e8 00 00 00 00	 call	 mbstowcs_s

; 220  : 
; 221  : 	size_t lCap = strlen(text);
; 222  : 	wchar_t* wCap = new wchar_t[lCap + 1];

  009d0	b8 02 00 00 00	 mov	 eax, 2
  009d5	49 f7 e6	 mul	 r14
  009d8	49 0f 40 c5	 cmovo	 rax, r13
  009dc	48 8b c8	 mov	 rcx, rax
  009df	e8 00 00 00 00	 call	 ??_U@YAPEAX_K@Z		; operator new[]
  009e4	48 8b d8	 mov	 rbx, rax

; 223  : 	mbstowcs_s(NULL, wCap, lCap + 1, caption, lCap);

  009e7	48 c7 44 24 20
	2b 00 00 00	 mov	 QWORD PTR [rsp+32], 43	; 0000002bH
  009f0	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG4294956368
  009f7	4d 8b c6	 mov	 r8, r14
  009fa	48 8b d0	 mov	 rdx, rax
  009fd	33 c9		 xor	 ecx, ecx
  009ff	e8 00 00 00 00	 call	 mbstowcs_s

; 193  : }
; 194  : 
; 195  : void GLWindow::makeCurrent()
; 196  : {
; 197  : 	wglMakeCurrent(hDC, hRC);
; 198  : }
; 199  : 
; 200  : bool GLWindow::isOK()
; 201  : {
; 202  : 	return OK;
; 203  : }
; 204  : 
; 205  : HWND GLWindow::getHWnd()
; 206  : {
; 207  : 	return hWnd;
; 208  : }
; 209  : 
; 210  : void GLWindow::messageBox(LPCWSTR lpText, LPCWSTR lpCaption, UINT uType)
; 211  : {
; 212  : 	MessageBox(hWnd, lpText, lpText, uType);

  00a04	41 b9 10 00 00
	00		 mov	 r9d, 16
  00a0a	4c 8b c7	 mov	 r8, rdi
  00a0d	48 8b d7	 mov	 rdx, rdi
  00a10	48 8b 4e 10	 mov	 rcx, QWORD PTR [rsi+16]
  00a14	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_MessageBoxW

; 224  : 
; 225  : 	messageBox(wText, wCap, MB_OK | MB_ICONERROR);
; 226  : 
; 227  : 	GlobalThread::stop = true;

  00a1a	c6 05 00 00 00
	00 01		 mov	 BYTE PTR ?stop@GlobalThread@@3_NA, 1 ; GlobalThread::stop

; 228  : 
; 229  : 	delete wText;

  00a21	48 8b cf	 mov	 rcx, rdi
  00a24	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete

; 230  : 	delete wCap;

  00a29	48 8b cb	 mov	 rcx, rbx
  00a2c	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp

; 185  : 		return false;

  00a31	eb 2a		 jmp	 SHORT $LN1665@tick
$LN205@tick:

; 186  : 	}
; 187  : 	cl_int error = clSetKernelArg(preparedKernel, index, size, value);

  00a33	4c 8d 4c 24 54	 lea	 r9, QWORD PTR zCam$[rsp]
  00a38	ba 04 00 00 00	 mov	 edx, 4
  00a3d	44 8b c2	 mov	 r8d, edx
  00a40	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_clSetKernelArg

; 188  : 	if(error != CL_SUCCESS)

  00a46	85 c0		 test	 eax, eax
  00a48	74 1a		 je	 SHORT $LN29@tick

; 189  : 	{
; 190  : 		GLWindow::instance->postError("Failed to set kernel argument", "OpenCL kernel argument error");

  00a4a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG4294956366
  00a51	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG4294956365
  00a58	e8 00 00 00 00	 call	 ?postError@GLWindow@@QEAAXPEBD0@Z ; GLWindow::postError
$LN1665@tick:
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp

; 92   : 	if(!program.setArgument(4, sizeof(const int), &zCam)) GlobalThread::stop = true;

  00a5d	c6 05 00 00 00
	00 01		 mov	 BYTE PTR ?stop@GlobalThread@@3_NA, 1 ; GlobalThread::stop
$LN29@tick:
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp

; 182  : 	if(!preparedKernel)

  00a64	48 8b 0d 20 00
	00 00		 mov	 rcx, QWORD PTR ?program@@3VProgram@cl@@A+32
  00a6b	48 85 c9	 test	 rcx, rcx
  00a6e	0f 85 9e 00 00
	00		 jne	 $LN215@tick

; 183  : 	{
; 184  : 		GLWindow::instance->postError("Tried to set argument for unprepared kernel", "OpenCL kernel argument error");

  00a74	48 8b 35 00 00
	00 00		 mov	 rsi, QWORD PTR ?instance@GLWindow@@2PEAV1@EA ; GLWindow::instance
; File c:\users\glenn\documents\github\wind\project\wind\wind\window.cpp

; 218  : 	wchar_t* wText = new wchar_t[lText + 1];

  00a7b	b8 02 00 00 00	 mov	 eax, 2
  00a80	49 f7 e6	 mul	 r14
  00a83	49 0f 40 c5	 cmovo	 rax, r13
  00a87	48 8b c8	 mov	 rcx, rax
  00a8a	e8 00 00 00 00	 call	 ??_U@YAPEAX_K@Z		; operator new[]
  00a8f	48 8b f8	 mov	 rdi, rax

; 219  : 	mbstowcs_s(NULL, wText, lText + 1, text, lText);

  00a92	48 c7 44 24 20
	2b 00 00 00	 mov	 QWORD PTR [rsp+32], 43	; 0000002bH
  00a9b	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG4294956367
  00aa2	4d 8b c6	 mov	 r8, r14
  00aa5	48 8b d0	 mov	 rdx, rax
  00aa8	33 c9		 xor	 ecx, ecx
  00aaa	e8 00 00 00 00	 call	 mbstowcs_s

; 220  : 
; 221  : 	size_t lCap = strlen(text);
; 222  : 	wchar_t* wCap = new wchar_t[lCap + 1];

  00aaf	b8 02 00 00 00	 mov	 eax, 2
  00ab4	49 f7 e6	 mul	 r14
  00ab7	49 0f 40 c5	 cmovo	 rax, r13
  00abb	48 8b c8	 mov	 rcx, rax
  00abe	e8 00 00 00 00	 call	 ??_U@YAPEAX_K@Z		; operator new[]
  00ac3	48 8b d8	 mov	 rbx, rax

; 223  : 	mbstowcs_s(NULL, wCap, lCap + 1, caption, lCap);

  00ac6	48 c7 44 24 20
	2b 00 00 00	 mov	 QWORD PTR [rsp+32], 43	; 0000002bH
  00acf	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG4294956368
  00ad6	4d 8b c6	 mov	 r8, r14
  00ad9	48 8b d0	 mov	 rdx, rax
  00adc	33 c9		 xor	 ecx, ecx
  00ade	e8 00 00 00 00	 call	 mbstowcs_s

; 193  : }
; 194  : 
; 195  : void GLWindow::makeCurrent()
; 196  : {
; 197  : 	wglMakeCurrent(hDC, hRC);
; 198  : }
; 199  : 
; 200  : bool GLWindow::isOK()
; 201  : {
; 202  : 	return OK;
; 203  : }
; 204  : 
; 205  : HWND GLWindow::getHWnd()
; 206  : {
; 207  : 	return hWnd;
; 208  : }
; 209  : 
; 210  : void GLWindow::messageBox(LPCWSTR lpText, LPCWSTR lpCaption, UINT uType)
; 211  : {
; 212  : 	MessageBox(hWnd, lpText, lpText, uType);

  00ae3	41 b9 10 00 00
	00		 mov	 r9d, 16
  00ae9	4c 8b c7	 mov	 r8, rdi
  00aec	48 8b d7	 mov	 rdx, rdi
  00aef	48 8b 4e 10	 mov	 rcx, QWORD PTR [rsi+16]
  00af3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_MessageBoxW

; 224  : 
; 225  : 	messageBox(wText, wCap, MB_OK | MB_ICONERROR);
; 226  : 
; 227  : 	GlobalThread::stop = true;

  00af9	c6 05 00 00 00
	00 01		 mov	 BYTE PTR ?stop@GlobalThread@@3_NA, 1 ; GlobalThread::stop

; 228  : 
; 229  : 	delete wText;

  00b00	48 8b cf	 mov	 rcx, rdi
  00b03	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete

; 230  : 	delete wCap;

  00b08	48 8b cb	 mov	 rcx, rbx
  00b0b	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp

; 185  : 		return false;

  00b10	eb 2d		 jmp	 SHORT $LN1666@tick
$LN215@tick:

; 186  : 	}
; 187  : 	cl_int error = clSetKernelArg(preparedKernel, index, size, value);

  00b12	4c 8d 0d 08 00
	00 00		 lea	 r9, OFFSET FLAT:?boolBuffer@@3VBuffer@cl@@A+8
  00b19	ba 05 00 00 00	 mov	 edx, 5
  00b1e	44 8d 42 03	 lea	 r8d, QWORD PTR [rdx+3]
  00b22	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_clSetKernelArg

; 188  : 	if(error != CL_SUCCESS)

  00b28	85 c0		 test	 eax, eax
  00b2a	74 1a		 je	 SHORT $LN28@tick

; 189  : 	{
; 190  : 		GLWindow::instance->postError("Failed to set kernel argument", "OpenCL kernel argument error");

  00b2c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG4294956366
  00b33	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG4294956365
  00b3a	e8 00 00 00 00	 call	 ?postError@GLWindow@@QEAAXPEBD0@Z ; GLWindow::postError
$LN1666@tick:
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp

; 93   : 	if(!program.setArgument(5, sizeof(cl_mem), &boolBuffer)) GlobalThread::stop = true;

  00b3f	c6 05 00 00 00
	00 01		 mov	 BYTE PTR ?stop@GlobalThread@@3_NA, 1 ; GlobalThread::stop
$LN28@tick:
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp

; 203  : 	if(!preparedKernel)

  00b46	bb 23 00 00 00	 mov	 ebx, 35			; 00000023H
  00b4b	48 8b 15 20 00
	00 00		 mov	 rdx, QWORD PTR ?program@@3VProgram@cl@@A+32
  00b52	48 85 d2	 test	 rdx, rdx
  00b55	0f 85 a9 00 00
	00		 jne	 $LN225@tick

; 204  : 	{
; 205  : 		GLWindow::instance->postError("Tried to execute unprepared kernel", "OpenCL program execution error");

  00b5b	48 8b 35 00 00
	00 00		 mov	 rsi, QWORD PTR ?instance@GLWindow@@2PEAV1@EA ; GLWindow::instance
; File c:\users\glenn\documents\github\wind\project\wind\wind\window.cpp

; 218  : 	wchar_t* wText = new wchar_t[lText + 1];

  00b62	b8 02 00 00 00	 mov	 eax, 2
  00b67	48 f7 e3	 mul	 rbx
  00b6a	49 0f 40 c5	 cmovo	 rax, r13
  00b6e	48 8b c8	 mov	 rcx, rax
  00b71	e8 00 00 00 00	 call	 ??_U@YAPEAX_K@Z		; operator new[]
  00b76	48 8b f8	 mov	 rdi, rax

; 219  : 	mbstowcs_s(NULL, wText, lText + 1, text, lText);

  00b79	48 c7 44 24 20
	22 00 00 00	 mov	 QWORD PTR [rsp+32], 34	; 00000022H
  00b82	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG4294956363
  00b89	44 8b c3	 mov	 r8d, ebx
  00b8c	48 8b d0	 mov	 rdx, rax
  00b8f	33 c9		 xor	 ecx, ecx
  00b91	e8 00 00 00 00	 call	 mbstowcs_s

; 220  : 
; 221  : 	size_t lCap = strlen(text);
; 222  : 	wchar_t* wCap = new wchar_t[lCap + 1];

  00b96	b8 02 00 00 00	 mov	 eax, 2
  00b9b	48 f7 e3	 mul	 rbx
  00b9e	49 0f 40 c5	 cmovo	 rax, r13
  00ba2	48 8b c8	 mov	 rcx, rax
  00ba5	e8 00 00 00 00	 call	 ??_U@YAPEAX_K@Z		; operator new[]
  00baa	48 8b d8	 mov	 rbx, rax

; 223  : 	mbstowcs_s(NULL, wCap, lCap + 1, caption, lCap);

  00bad	48 c7 44 24 20
	22 00 00 00	 mov	 QWORD PTR [rsp+32], 34	; 00000022H
  00bb6	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG4294956364
  00bbd	41 b8 23 00 00
	00		 mov	 r8d, 35			; 00000023H
  00bc3	48 8b d0	 mov	 rdx, rax
  00bc6	33 c9		 xor	 ecx, ecx
  00bc8	e8 00 00 00 00	 call	 mbstowcs_s

; 193  : }
; 194  : 
; 195  : void GLWindow::makeCurrent()
; 196  : {
; 197  : 	wglMakeCurrent(hDC, hRC);
; 198  : }
; 199  : 
; 200  : bool GLWindow::isOK()
; 201  : {
; 202  : 	return OK;
; 203  : }
; 204  : 
; 205  : HWND GLWindow::getHWnd()
; 206  : {
; 207  : 	return hWnd;
; 208  : }
; 209  : 
; 210  : void GLWindow::messageBox(LPCWSTR lpText, LPCWSTR lpCaption, UINT uType)
; 211  : {
; 212  : 	MessageBox(hWnd, lpText, lpText, uType);

  00bcd	41 b9 10 00 00
	00		 mov	 r9d, 16
  00bd3	4c 8b c7	 mov	 r8, rdi
  00bd6	48 8b d7	 mov	 rdx, rdi
  00bd9	48 8b 4e 10	 mov	 rcx, QWORD PTR [rsi+16]
  00bdd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_MessageBoxW

; 224  : 
; 225  : 	messageBox(wText, wCap, MB_OK | MB_ICONERROR);
; 226  : 
; 227  : 	GlobalThread::stop = true;

  00be3	c6 05 00 00 00
	00 01		 mov	 BYTE PTR ?stop@GlobalThread@@3_NA, 1 ; GlobalThread::stop

; 228  : 
; 229  : 	delete wText;

  00bea	48 8b cf	 mov	 rcx, rdi
  00bed	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete

; 230  : 	delete wCap;

  00bf2	48 8b cb	 mov	 rcx, rbx
  00bf5	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp

; 206  : 		return false;

  00bfa	bb 01 00 00 00	 mov	 ebx, 1
  00bff	e9 a3 00 00 00	 jmp	 $LN1667@tick
$LN225@tick:

; 207  : 	}
; 208  : 
; 209  : 	cl_int error;
; 210  : 	cl_event event;
; 211  : 
; 212  : 	error = clEnqueueNDRangeKernel(queue.queue, preparedKernel, dimensions, NULL, globalWorkSize, localWorkSize, 0, NULL, &event);

  00c04	48 8d 45 c8	 lea	 rax, QWORD PTR event$6[rbp-256]
  00c08	48 89 44 24 40	 mov	 QWORD PTR [rsp+64], rax
  00c0d	4c 89 7c 24 38	 mov	 QWORD PTR [rsp+56], r15
  00c12	44 89 7c 24 30	 mov	 DWORD PTR [rsp+48], r15d
  00c17	48 8d 85 c0 05
	00 00		 lea	 rax, QWORD PTR local_ws_1$[rbp-256]
  00c1e	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00c23	48 8d 85 d8 05
	00 00		 lea	 rax, QWORD PTR global_ws_1$[rbp-256]
  00c2a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00c2f	45 33 c9	 xor	 r9d, r9d
  00c32	45 8d 41 03	 lea	 r8d, QWORD PTR [r9+3]
  00c36	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?commandQueue@@3VCommandQueue@cl@@A
  00c3d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_clEnqueueNDRangeKernel

; 213  : 	if(error != CL_SUCCESS)

  00c43	85 c0		 test	 eax, eax
  00c45	74 1a		 je	 SHORT $LN224@tick

; 214  : 	{
; 215  : 		GLWindow::instance->postError("Failed to exectue kernel", "OpenCL program execution error");

  00c47	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG4294956362
  00c4e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG4294956361
  00c55	e8 00 00 00 00	 call	 ?postError@GLWindow@@QEAAXPEBD0@Z ; GLWindow::postError

; 216  : 		return false;

  00c5a	bb 01 00 00 00	 mov	 ebx, 1
  00c5f	eb 46		 jmp	 SHORT $LN1667@tick
$LN224@tick:

; 217  : 	}
; 218  : 
; 219  : 	error = clWaitForEvents(1, &event);

  00c61	48 8d 55 c8	 lea	 rdx, QWORD PTR event$6[rbp-256]
  00c65	bb 01 00 00 00	 mov	 ebx, 1
  00c6a	8b cb		 mov	 ecx, ebx
  00c6c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_clWaitForEvents

; 220  : 	if(error != CL_SUCCESS)

  00c72	85 c0		 test	 eax, eax
  00c74	74 10		 je	 SHORT $LN223@tick

; 221  : 	{
; 222  : 		GLWindow::instance->postError("Failed to wait for kernel finish event", "OpenCL program execution error");

  00c76	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG4294956360
  00c7d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG4294956359

; 223  : 		return false;

  00c84	eb 1c		 jmp	 SHORT $LN1691@tick
$LN223@tick:

; 224  : 	}
; 225  : 
; 226  : 	error = clReleaseEvent(event);

  00c86	48 8b 4d c8	 mov	 rcx, QWORD PTR event$6[rbp-256]
  00c8a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_clReleaseEvent

; 227  : 	if(error != CL_SUCCESS)

  00c90	85 c0		 test	 eax, eax
  00c92	74 1c		 je	 SHORT $LN222@tick

; 228  : 	{
; 229  : 		GLWindow::instance->postError("Failed to release kernel finish event", "OpenCL program execution error");

  00c94	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG4294956358
  00c9b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG4294956357
$LN1691@tick:
  00ca2	e8 00 00 00 00	 call	 ?postError@GLWindow@@QEAAXPEBD0@Z ; GLWindow::postError
$LN1667@tick:
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp

; 94   : 	if(!program.invoke(commandQueue, 3, global_ws_1, local_ws_1)) GlobalThread::stop = true;

  00ca7	c6 05 00 00 00
	00 01		 mov	 BYTE PTR ?stop@GlobalThread@@3_NA, 1 ; GlobalThread::stop
  00cae	eb 1e		 jmp	 SHORT $LN27@tick
$LN222@tick:
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp

; 233  : 	preparedKernel = 0;

  00cb0	4c 89 3d 20 00
	00 00		 mov	 QWORD PTR ?program@@3VProgram@cl@@A+32, r15
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 83   : 	return (_Check_C_return(_Mtx_unlock(_Mtx)));

  00cb7	48 8d 0d 18 00
	00 00		 lea	 rcx, OFFSET FLAT:?program@@3VProgram@cl@@A+24
  00cbe	e8 00 00 00 00	 call	 _Mtx_unlock

; 32   : 	if (_Res != _Thrd_success)

  00cc3	85 c0		 test	 eax, eax
  00cc5	74 07		 je	 SHORT $LN27@tick

; 33   : 		_Throw_C_error(_Res);

  00cc7	8b c8		 mov	 ecx, eax
  00cc9	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
$LN27@tick:
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp

; 96   : 	const size_t global_ws_2[] = {renderDistance * 2 + 1, renderDistance * 2 + 1, renderDistance * 2 + 1};

  00cce	48 c7 85 f0 05
	00 00 11 00 00
	00		 mov	 QWORD PTR global_ws_2$[rbp-256], 17
  00cd9	48 c7 85 f8 05
	00 00 11 00 00
	00		 mov	 QWORD PTR global_ws_2$[rbp-248], 17
  00ce4	48 c7 85 00 06
	00 00 11 00 00
	00		 mov	 QWORD PTR global_ws_2$[rbp-240], 17

; 97   : 	const size_t local_ws_2[] = {1, 1, 1};

  00cef	48 89 9d 08 06
	00 00		 mov	 QWORD PTR local_ws_2$[rbp-256], rbx
  00cf6	48 89 9d 10 06
	00 00		 mov	 QWORD PTR local_ws_2$[rbp-248], rbx
  00cfd	48 89 9d 18 06
	00 00		 mov	 QWORD PTR local_ws_2$[rbp-240], rbx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 2265 : 		this->_Myres = this->_BUF_SIZE - 1;

  00d04	48 c7 45 50 0f
	00 00 00	 mov	 QWORD PTR $T15[rbp-232], 15

; 1145 : 		}
; 1146 : 
; 1147 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1148 : 		{	// assign _Count * _Ch
; 1149 : 		if (_Count == npos)
; 1150 : 			_Xlen();	// result too long
; 1151 : 
; 1152 : 		if (_Grow(_Count))
; 1153 : 			{	// make room and assign new stuff
; 1154 : 			_Chassign(0, _Count, _Ch);
; 1155 : 			_Eos(_Count);
; 1156 : 			}
; 1157 : 		return (*this);
; 1158 : 		}
; 1159 : 
; 1160 : 	template<class _Iter>
; 1161 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1162 : 			_Myt&>::type
; 1163 : 		assign(_Iter _First, _Iter _Last)
; 1164 : 		{	// assign [First, _Last), input iterators
; 1165 : 		return (replace(begin(), end(), _First, _Last));
; 1166 : 		}
; 1167 : 
; 1168 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1169 : 		{	// assign [First, _Last), const pointers
; 1170 : 		return (replace(begin(), end(), _First, _Last));
; 1171 : 		}
; 1172 : 
; 1173 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1174 : 		{	// assign [First, _Last), const_iterators
; 1175 : 		return (replace(begin(), end(), _First, _Last));
; 1176 : 		}
; 1177 : 
; 1178 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1179 : 		{	// insert _Right at _Off
; 1180 : 		return (insert(_Off, _Right, 0, npos));
; 1181 : 		}
; 1182 : 
; 1183 : 	_Myt& insert(size_type _Off,
; 1184 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1185 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1186 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1187 : 			_Xran();	// _Off or _Roff off end
; 1188 : 		size_type _Num = _Right.size() - _Roff;
; 1189 : 		if (_Num < _Count)
; 1190 : 			_Count = _Num;	// trim _Count to size
; 1191 : 		if (npos - this->_Mysize <= _Count)
; 1192 : 			_Xlen();	// result too long
; 1193 : 
; 1194 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1195 : 			{	// make room and insert new stuff
; 1196 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1197 : 				this->_Myptr() + _Off,
; 1198 : 				this->_Mysize - _Off);	// empty out hole
; 1199 : 			if (this == &_Right)
; 1200 : 				_Traits::move(this->_Myptr() + _Off,
; 1201 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1202 : 						_Count);	// substring
; 1203 : 			else
; 1204 : 				_Traits::copy(this->_Myptr() + _Off,
; 1205 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1206 : 			_Eos(_Num);
; 1207 : 			}
; 1208 : 		return (*this);
; 1209 : 		}
; 1210 : 
; 1211 : 	_Myt& insert(size_type _Off,
; 1212 : 		const _Elem *_Ptr, size_type _Count)
; 1213 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1214 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1215 : 		if (_Count != 0)
; 1216 : 			_DEBUG_POINTER(_Ptr);
; 1217 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1218 : 
; 1219 : 		if (_Inside(_Ptr))
; 1220 : 			return (insert(_Off, *this,
; 1221 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1222 : 		if (this->_Mysize < _Off)
; 1223 : 			_Xran();	// _Off off end
; 1224 : 		if (npos - this->_Mysize <= _Count)
; 1225 : 			_Xlen();	// result too long
; 1226 : 		size_type _Num;
; 1227 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1228 : 			{	// make room and insert new stuff
; 1229 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1230 : 				this->_Myptr() + _Off,
; 1231 : 				this->_Mysize - _Off);	// empty out hole
; 1232 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1233 : 			_Eos(_Num);
; 1234 : 			}
; 1235 : 		return (*this);
; 1236 : 		}
; 1237 : 
; 1238 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1239 : 		{	// insert [_Ptr, <null>) at _Off
; 1240 : 		_DEBUG_POINTER(_Ptr);
; 1241 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1242 : 		}
; 1243 : 
; 1244 : 	_Myt& insert(size_type _Off,
; 1245 : 		size_type _Count, _Elem _Ch)
; 1246 : 		{	// insert _Count * _Ch at _Off
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	iterator insert(const_iterator _Where)
; 1264 : 		{	// insert <null> at _Where
; 1265 : 		return (insert(_Where, _Elem()));
; 1266 : 		}
; 1267 : 
; 1268 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1269 : 		{	// insert _Ch at _Where
; 1270 : 		size_type _Off = _Pdif(_Where, begin());
; 1271 : 		insert(_Off, 1, _Ch);
; 1272 : 		return (begin() + _Off);
; 1273 : 		}
; 1274 : 
; 1275 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1276 : 		{	// insert _Count * _Elem at _Where
; 1277 : 		size_type _Off = _Pdif(_Where, begin());
; 1278 : 		insert(_Off, _Count, _Ch);
; 1279 : 		return (begin() + _Off);
; 1280 : 		}
; 1281 : 
; 1282 : 	template<class _Iter>
; 1283 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1284 : 			iterator>::type
; 1285 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1286 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1287 : 		size_type _Off = _Pdif(_Where, begin());
; 1288 : 		replace(_Where, _Where, _First, _Last);
; 1289 : 		return (begin() + _Off);
; 1290 : 		}
; 1291 : 
; 1292 : 	iterator insert(const_iterator _Where,
; 1293 : 		const_pointer _First, const_pointer _Last)
; 1294 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		replace(_Where, _Where, _First, _Last);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where,
; 1301 : 		const_iterator _First, const_iterator _Last)
; 1302 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1303 : 		size_type _Off = _Pdif(_Where, begin());
; 1304 : 		replace(_Where, _Where, _First, _Last);
; 1305 : 		return (begin() + _Off);
; 1306 : 		}
; 1307 : 
; 1308 : 	_Myt& erase(size_type _Off = 0)
; 1309 : 		{	// erase elements [_Off, ...)
; 1310 : 		if (this->_Mysize < _Off)
; 1311 : 			_Xran();	// _Off off end
; 1312 : 		_Eos(_Off);
; 1313 : 		return (*this);
; 1314 : 		}
; 1315 : 
; 1316 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1317 : 		{	// erase elements [_Off, _Off + _Count)
; 1318 : 		if (this->_Mysize < _Off)
; 1319 : 			_Xran();	// _Off off end
; 1320 : 		if (this->_Mysize - _Off <= _Count)
; 1321 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1322 : 		else if (0 < _Count)
; 1323 : 			{	// move elements down
; 1324 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1325 : 			size_type _Newsize = this->_Mysize - _Count;
; 1326 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1327 : 			_Eos(_Newsize);
; 1328 : 			}
; 1329 : 		return (*this);
; 1330 : 		}
; 1331 : 
; 1332 : 	iterator erase(const_iterator _Where)
; 1333 : 		{	// erase element at _Where
; 1334 : 		size_type _Count = _Pdif(_Where, begin());
; 1335 : 		erase(_Count, 1);
; 1336 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1337 : 		}
; 1338 : 
; 1339 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1340 : 		{	// erase substring [_First, _Last)
; 1341 : 		_DEBUG_RANGE(_First, _Last);
; 1342 : 		size_type _Count = _Pdif(_First, begin());
; 1343 : 		erase(_Count, _Pdif(_Last, _First));
; 1344 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1345 : 		}
; 1346 : 
; 1347 : 	void clear() _NOEXCEPT
; 1348 : 		{	// erase all
; 1349 : 		_Eos(0);
; 1350 : 		}
; 1351 : 
; 1352 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1353 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1354 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1355 : 		}
; 1356 : 
; 1357 : 	_Myt& replace(size_type _Off,
; 1358 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1359 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1360 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1361 : 			_Xran();	// _Off or _Roff off end
; 1362 : 		if (this->_Mysize - _Off < _N0)
; 1363 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1364 : 		size_type _Num = _Right.size() - _Roff;
; 1365 : 		if (_Num < _Count)
; 1366 : 			_Count = _Num;	// trim _Count to size
; 1367 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1368 : 			_Xlen();	// result too long
; 1369 : 
; 1370 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1371 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1372 : 		if (this->_Mysize < _Newsize)
; 1373 : 			_Grow(_Newsize);
; 1374 : 
; 1375 : 		if (this != &_Right)
; 1376 : 			{	// no overlap, just move down and copy in new stuff
; 1377 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1378 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1379 : 			_Traits::copy(this->_Myptr() + _Off,
; 1380 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1381 : 			}
; 1382 : 		else if (_Count <= _N0)
; 1383 : 			{	// hole doesn't get larger, just copy in substring
; 1384 : 			_Traits::move(this->_Myptr() + _Off,
; 1385 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1386 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1387 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1388 : 			}
; 1389 : 		else if (_Roff <= _Off)
; 1390 : 			{	// hole gets larger, substring begins before hole
; 1391 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1392 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1393 : 			_Traits::move(this->_Myptr() + _Off,
; 1394 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1395 : 			}
; 1396 : 		else if (_Off + _N0 <= _Roff)
; 1397 : 			{	// hole gets larger, substring begins after hole
; 1398 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1399 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1400 : 			_Traits::move(this->_Myptr() + _Off,
; 1401 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1402 : 				_Count);	// fill hole
; 1403 : 			}
; 1404 : 		else
; 1405 : 			{	// hole gets larger, substring begins in hole
; 1406 : 			_Traits::move(this->_Myptr() + _Off,
; 1407 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1408 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1409 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1410 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1411 : 				this->_Myptr() + _Roff + _Count,
; 1412 : 				_Count - _N0);	// fill rest of new hole
; 1413 : 			}
; 1414 : 
; 1415 : 		_Eos(_Newsize);
; 1416 : 		return (*this);
; 1417 : 		}
; 1418 : 
; 1419 : 	_Myt& replace(size_type _Off,
; 1420 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1421 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1422 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1423 : 		if (_Count != 0)
; 1424 : 			_DEBUG_POINTER(_Ptr);
; 1425 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1426 : 
; 1427 : 		if (_Inside(_Ptr))
; 1428 : 			return (replace(_Off, _N0, *this,
; 1429 : 				_Ptr - this->_Myptr(),
; 1430 : 				_Count));	// substring, replace carefully
; 1431 : 		if (this->_Mysize < _Off)
; 1432 : 			_Xran();	// _Off off end
; 1433 : 		if (this->_Mysize - _Off < _N0)
; 1434 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1435 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1436 : 			_Xlen();	// result too long
; 1437 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1438 : 
; 1439 : 		if (_Count < _N0)
; 1440 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1441 : 				this->_Myptr() + _Off + _N0,
; 1442 : 				_Nm);	// smaller hole, move tail up
; 1443 : 		size_type _Num;
; 1444 : 		if ((0 < _Count || 0 < _N0)
; 1445 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1446 : 			{	// make room and rearrange
; 1447 : 			if (_N0 < _Count)
; 1448 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1449 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1450 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1451 : 			_Eos(_Num);
; 1452 : 			}
; 1453 : 		return (*this);
; 1454 : 		}
; 1455 : 
; 1456 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1457 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1458 : 		_DEBUG_POINTER(_Ptr);
; 1459 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1460 : 		}
; 1461 : 
; 1462 : 	_Myt& replace(size_type _Off,
; 1463 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1464 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1465 : 		if (this->_Mysize < _Off)
; 1466 : 			_Xran();	// _Off off end
; 1467 : 		if (this->_Mysize - _Off < _N0)
; 1468 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1469 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1470 : 			_Xlen();	// result too long
; 1471 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1472 : 
; 1473 : 		if (_Count < _N0)
; 1474 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1475 : 				this->_Myptr() + _Off + _N0,
; 1476 : 				_Nm);	// smaller hole, move tail up
; 1477 : 		size_type _Num;
; 1478 : 		if ((0 < _Count || 0 < _N0)
; 1479 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1480 : 			{	// make room and rearrange
; 1481 : 			if (_N0 < _Count)
; 1482 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1483 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1484 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1485 : 			_Eos(_Num);
; 1486 : 			}
; 1487 : 		return (*this);
; 1488 : 		}
; 1489 : 
; 1490 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1491 : 		const _Myt& _Right)
; 1492 : 		{	// replace [_First, _Last) with _Right
; 1493 : 		return (replace(
; 1494 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1495 : 		}
; 1496 : 
; 1497 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1498 : 		const _Elem *_Ptr, size_type _Count)
; 1499 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1500 : 		return (replace(
; 1501 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1502 : 		}
; 1503 : 
; 1504 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1505 : 		const _Elem *_Ptr)
; 1506 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1507 : 		return (replace(
; 1508 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1509 : 		}
; 1510 : 
; 1511 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1512 : 		size_type _Count, _Elem _Ch)
; 1513 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1514 : 		return (replace(
; 1515 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1516 : 		}
; 1517 : 
; 1518 : 	template<class _Iter>
; 1519 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1520 : 			_Myt&>::type
; 1521 : 		replace(const_iterator _First, const_iterator _Last,
; 1522 : 			_Iter _First2, _Iter _Last2)
; 1523 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1524 : 		_Myt _Right(_First2, _Last2);
; 1525 : 		replace(_First, _Last, _Right);
; 1526 : 		return (*this);
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const_pointer _First2, const_pointer _Last2)
; 1531 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1532 : 		if (_First2 == _Last2)
; 1533 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1534 : 		else
; 1535 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1536 : 				&*_First2, _Last2 - _First2);
; 1537 : 		return (*this);
; 1538 : 		}
; 1539 : 
; 1540 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1541 : 		pointer _First2, pointer _Last2)
; 1542 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1543 : 		if (_First2 == _Last2)
; 1544 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1545 : 		else
; 1546 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1547 : 				&*_First2, _Last2 - _First2);
; 1548 : 		return (*this);
; 1549 : 		}
; 1550 : 
; 1551 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1552 : 		const_iterator _First2, const_iterator _Last2)
; 1553 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1554 : 		if (_First2 == _Last2)
; 1555 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1556 : 		else
; 1557 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1558 : 				&*_First2, _Last2 - _First2);
; 1559 : 		return (*this);
; 1560 : 		}
; 1561 : 
; 1562 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1563 : 		iterator _First2, iterator _Last2)
; 1564 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1565 : 		if (_First2 == _Last2)
; 1566 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1567 : 		else
; 1568 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1569 : 				&*_First2, _Last2 - _First2);
; 1570 : 		return (*this);
; 1571 : 		}
; 1572 : 
; 1573 : 	iterator begin() _NOEXCEPT
; 1574 : 		{	// return iterator for beginning of mutable sequence
; 1575 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1576 : 		}
; 1577 : 
; 1578 : 	const_iterator begin() const _NOEXCEPT
; 1579 : 		{	// return iterator for beginning of nonmutable sequence
; 1580 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1581 : 		}
; 1582 : 
; 1583 : 	iterator end() _NOEXCEPT
; 1584 : 		{	// return iterator for end of mutable sequence
; 1585 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1586 : 		}
; 1587 : 
; 1588 : 	const_iterator end() const _NOEXCEPT
; 1589 : 		{	// return iterator for end of nonmutable sequence
; 1590 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1591 : 		}
; 1592 : 
; 1593 : 	reverse_iterator rbegin() _NOEXCEPT
; 1594 : 		{	// return iterator for beginning of reversed mutable sequence
; 1595 : 		return (reverse_iterator(end()));
; 1596 : 		}
; 1597 : 
; 1598 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1600 : 		return (const_reverse_iterator(end()));
; 1601 : 		}
; 1602 : 
; 1603 : 	reverse_iterator rend() _NOEXCEPT
; 1604 : 		{	// return iterator for end of reversed mutable sequence
; 1605 : 		return (reverse_iterator(begin()));
; 1606 : 		}
; 1607 : 
; 1608 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1609 : 		{	// return iterator for end of reversed nonmutable sequence
; 1610 : 		return (const_reverse_iterator(begin()));
; 1611 : 		}
; 1612 : 
; 1613 :  #if _HAS_CPP0X
; 1614 : 	const_iterator cbegin() const _NOEXCEPT
; 1615 : 		{	// return iterator for beginning of nonmutable sequence
; 1616 : 		return (((const _Myt *)this)->begin());
; 1617 : 		}
; 1618 : 
; 1619 : 	const_iterator cend() const _NOEXCEPT
; 1620 : 		{	// return iterator for end of nonmutable sequence
; 1621 : 		return (((const _Myt *)this)->end());
; 1622 : 		}
; 1623 : 
; 1624 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1625 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1626 : 		return (((const _Myt *)this)->rbegin());
; 1627 : 		}
; 1628 : 
; 1629 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1630 : 		{	// return iterator for end of reversed nonmutable sequence
; 1631 : 		return (((const _Myt *)this)->rend());
; 1632 : 		}
; 1633 : 
; 1634 : 	void shrink_to_fit()
; 1635 : 		{	// reduce capacity
; 1636 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1637 : 			{	// worth shrinking, do it
; 1638 : 			_Myt _Tmp(*this);
; 1639 : 			swap(_Tmp);
; 1640 : 			}
; 1641 : 		}
; 1642 :  #endif /* _HAS_CPP0X */
; 1643 : 
; 1644 : 	reference at(size_type _Off)
; 1645 : 		{	// subscript mutable sequence with checking
; 1646 : 		if (this->_Mysize <= _Off)
; 1647 : 			_Xran();	// _Off off end
; 1648 : 		return (this->_Myptr()[_Off]);
; 1649 : 		}
; 1650 : 
; 1651 : 	const_reference at(size_type _Off) const
; 1652 : 		{	// subscript nonmutable sequence with checking
; 1653 : 		if (this->_Mysize <= _Off)
; 1654 : 			_Xran();	// _Off off end
; 1655 : 		return (this->_Myptr()[_Off]);
; 1656 : 		}
; 1657 : 
; 1658 : 	reference operator[](size_type _Off)
; 1659 : 		{	// subscript mutable sequence
; 1660 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1661 : 		if (this->_Mysize < _Off)	// sic
; 1662 : 			_DEBUG_ERROR("string subscript out of range");
; 1663 : 
; 1664 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1665 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1666 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1667 : 
; 1668 : 		return (this->_Myptr()[_Off]);
; 1669 : 		}
; 1670 : 
; 1671 : 	const_reference operator[](size_type _Off) const
; 1672 : 		{	// subscript nonmutable sequence
; 1673 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1674 : 		if (this->_Mysize < _Off)	// sic
; 1675 : 			_DEBUG_ERROR("string subscript out of range");
; 1676 : 
; 1677 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1678 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1679 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1680 : 
; 1681 : 		return (this->_Myptr()[_Off]);
; 1682 : 		}
; 1683 : 
; 1684 : 	void push_back(_Elem _Ch)
; 1685 : 		{	// insert element at end
; 1686 : 		insert(end(), _Ch);
; 1687 : 		}
; 1688 : 
; 1689 :  #if _HAS_CPP0X
; 1690 : 	void pop_back()
; 1691 : 		{	// erase element at end
; 1692 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1693 : 		}
; 1694 : 
; 1695 : 	reference front()
; 1696 : 		{	// return first element of mutable sequence
; 1697 : 		return (*begin());
; 1698 : 		}
; 1699 : 
; 1700 : 	const_reference front() const
; 1701 : 		{	// return first element of nonmutable sequence
; 1702 : 		return (*begin());
; 1703 : 		}
; 1704 : 
; 1705 : 	reference back()
; 1706 : 		{	// return last element of mutable sequence
; 1707 : 		return (*(end() - 1));
; 1708 : 		}
; 1709 : 
; 1710 : 	const_reference back() const
; 1711 : 		{	// return last element of nonmutable sequence
; 1712 : 		return (*(end() - 1));
; 1713 : 		}
; 1714 :  #endif /* _HAS_CPP0X */
; 1715 : 
; 1716 : 	const _Elem *c_str() const _NOEXCEPT
; 1717 : 		{	// return pointer to null-terminated nonmutable array
; 1718 : 		return (this->_Myptr());
; 1719 : 		}
; 1720 : 
; 1721 : 	const _Elem *data() const _NOEXCEPT
; 1722 : 		{	// return pointer to nonmutable array
; 1723 : 		return (c_str());
; 1724 : 		}
; 1725 : 
; 1726 : 	size_type length() const _NOEXCEPT
; 1727 : 		{	// return length of sequence
; 1728 : 		return (this->_Mysize);
; 1729 : 		}
; 1730 : 
; 1731 : 	size_type size() const _NOEXCEPT
; 1732 : 		{	// return length of sequence
; 1733 : 		return (this->_Mysize);
; 1734 : 		}
; 1735 : 
; 1736 : 	size_type max_size() const _NOEXCEPT
; 1737 : 		{	// return maximum possible length of sequence
; 1738 : 		size_type _Num = this->_Getal().max_size();
; 1739 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1740 : 		}
; 1741 : 
; 1742 : 	void resize(size_type _Newsize)
; 1743 : 		{	// determine new length, padding with null elements as needed
; 1744 : 		resize(_Newsize, _Elem());
; 1745 : 		}
; 1746 : 
; 1747 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1748 : 		{	// determine new length, padding with _Ch elements as needed
; 1749 : 		if (_Newsize <= this->_Mysize)
; 1750 : 			_Eos(_Newsize);
; 1751 : 		else
; 1752 : 			append(_Newsize - this->_Mysize, _Ch);
; 1753 : 		}
; 1754 : 
; 1755 : 	size_type capacity() const _NOEXCEPT
; 1756 : 		{	// return current length of allocated storage
; 1757 : 		return (this->_Myres);
; 1758 : 		}
; 1759 : 
; 1760 : 	void reserve(size_type _Newcap = 0)
; 1761 : 		{	// determine new minimum length of allocated storage
; 1762 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1763 : 			{	// change reservation
; 1764 : 			size_type _Size = this->_Mysize;
; 1765 : 			if (_Grow(_Newcap, true))
; 1766 : 				_Eos(_Size);
; 1767 : 			}
; 1768 : 		}
; 1769 : 
; 1770 : 	bool empty() const _NOEXCEPT
; 1771 : 		{	// test if sequence is empty
; 1772 : 		return (this->_Mysize == 0);
; 1773 : 		}
; 1774 : 
; 1775 : 	_SCL_INSECURE_DEPRECATE
; 1776 : 
; 1777 : 	size_type copy(_Elem *_Ptr,
; 1778 : 		size_type _Count, size_type _Off = 0) const
; 1779 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1780 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1781 : 		if (_Count != 0)
; 1782 : 			_DEBUG_POINTER(_Ptr);
; 1783 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1784 : 
; 1785 : 		if (this->_Mysize < _Off)
; 1786 : 			_Xran();	// _Off off end
; 1787 : 		if (this->_Mysize - _Off < _Count)
; 1788 : 			_Count = this->_Mysize - _Off;
; 1789 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1790 : 		return (_Count);
; 1791 : 		}
; 1792 : 
; 1793 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1794 : 		size_type _Count, size_type _Off = 0) const
; 1795 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1796 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1797 : 		if (_Count != 0)
; 1798 : 			_DEBUG_POINTER(_Dest);
; 1799 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1800 : 
; 1801 : 		if (this->_Mysize < _Off)
; 1802 : 			_Xran();	// _Off off end
; 1803 : 		if (this->_Mysize - _Off < _Count)
; 1804 : 			_Count = this->_Mysize - _Off;
; 1805 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1806 : 		return (_Count);
; 1807 : 		}
; 1808 : 
; 1809 : 	void _Swap_bx(_Myt& _Right)
; 1810 : 		{	// exchange _Bx with _Right._Bx
; 1811 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1812 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1813 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1814 : 			else
; 1815 : 				{	// swap large with small
; 1816 : 				pointer _Ptr = this->_Bx._Ptr;
; 1817 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1818 : 				_Traits::copy(this->_Bx._Buf,
; 1819 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1820 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1821 : 				}
; 1822 : 		else
; 1823 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1824 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1825 : 			else
; 1826 : 				{	// swap small with large
; 1827 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1828 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1829 : 				_Traits::copy(_Right._Bx._Buf,
; 1830 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1831 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1832 : 				}
; 1833 : 		}
; 1834 : 
; 1835 : 	void swap(_Myt& _Right)
; 1836 : 		{	// exchange contents with _Right
; 1837 : 		if (this == &_Right)
; 1838 : 			;	// same object, do nothing
; 1839 : 		else if (this->_Getal() == _Right._Getal())
; 1840 : 			{	// same allocator, swap control information
; 1841 : 			this->_Swap_all(_Right);
; 1842 : 			_Swap_bx(_Right);
; 1843 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1844 : 			_STD swap(this->_Myres, _Right._Myres);
; 1845 : 			}
; 1846 : 
; 1847 :  #if _HAS_CPP0X
; 1848 : 		else if (_Alty::propagate_on_container_swap::value)
; 1849 : 			{	// swap allocators and control information
; 1850 : 			this->_Swap_alloc(_Right);
; 1851 : 			_Swap_bx(_Right);
; 1852 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1853 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1854 : 			_STD swap(this->_Myres, _Right._Myres);
; 1855 : 			}
; 1856 :  #endif /* _HAS_CPP0X */
; 1857 : 
; 1858 : 		else
; 1859 : 			{	// different allocator, do multiple assigns
; 1860 : 			_Myt _Tmp = *this;
; 1861 : 
; 1862 : 			*this = _Right;
; 1863 : 			_Right = _Tmp;
; 1864 : 			}
; 1865 : 		}
; 1866 : 
; 1867 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1868 : 		{	// look for _Right beginning at or after _Off
; 1869 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1870 : 		}
; 1871 : 
; 1872 : 	size_type find(const _Elem *_Ptr,
; 1873 : 		size_type _Off, size_type _Count) const
; 1874 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1875 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1876 : 		if (_Count != 0)
; 1877 : 			_DEBUG_POINTER(_Ptr);
; 1878 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1879 : 
; 1880 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1881 : 			return (_Off);	// null string always matches (if inside string)
; 1882 : 
; 1883 : 		size_type _Nm;
; 1884 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1885 : 			{	// room for match, look for it
; 1886 : 			const _Elem *_Uptr, *_Vptr;
; 1887 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1888 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1889 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1890 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1891 : 					return (_Uptr - this->_Myptr());	// found a match
; 1892 : 			}
; 1893 : 
; 1894 : 		return (npos);	// no match
; 1895 : 		}
; 1896 : 
; 1897 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1898 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1899 : 		_DEBUG_POINTER(_Ptr);
; 1900 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1901 : 		}
; 1902 : 
; 1903 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1904 : 		{	// look for _Ch at or after _Off
; 1905 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1906 : 		}
; 1907 : 
; 1908 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1909 : 		{	// look for _Right beginning before _Off
; 1910 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1911 : 		}
; 1912 : 
; 1913 : 	size_type rfind(const _Elem *_Ptr,
; 1914 : 		size_type _Off, size_type _Count) const
; 1915 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1916 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1917 : 		if (_Count != 0)
; 1918 : 			_DEBUG_POINTER(_Ptr);
; 1919 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1920 : 
; 1921 : 		if (_Count == 0)
; 1922 : 			return (_Off < this->_Mysize ? _Off
; 1923 : 				: this->_Mysize);	// null always matches
; 1924 : 		if (_Count <= this->_Mysize)
; 1925 : 			{	// room for match, look for it
; 1926 : 			const _Elem *_Uptr = this->_Myptr() +
; 1927 : 				(_Off < this->_Mysize - _Count ? _Off
; 1928 : 					: this->_Mysize - _Count);
; 1929 : 			for (; ; --_Uptr)
; 1930 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1931 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1932 : 					return (_Uptr - this->_Myptr());	// found a match
; 1933 : 				else if (_Uptr == this->_Myptr())
; 1934 : 					break;	// at beginning, no more chance for match
; 1935 : 			}
; 1936 : 
; 1937 : 		return (npos);	// no match
; 1938 : 		}
; 1939 : 
; 1940 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1941 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1942 : 		_DEBUG_POINTER(_Ptr);
; 1943 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1944 : 		}
; 1945 : 
; 1946 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1947 : 		{	// look for _Ch before _Off
; 1948 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1949 : 		}
; 1950 : 
; 1951 : 	size_type find_first_of(const _Myt& _Right,
; 1952 : 		size_type _Off = 0) const _NOEXCEPT
; 1953 : 		{	// look for one of _Right at or after _Off
; 1954 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1955 : 		}
; 1956 : 
; 1957 : 	size_type find_first_of(const _Elem *_Ptr,
; 1958 : 		size_type _Off, size_type _Count) const
; 1959 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1960 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1961 : 		if (_Count != 0)
; 1962 : 			_DEBUG_POINTER(_Ptr);
; 1963 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1964 : 
; 1965 : 		if (0 < _Count && _Off < this->_Mysize)
; 1966 : 			{	// room for match, look for it
; 1967 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1968 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1969 : 				_Uptr < _Vptr; ++_Uptr)
; 1970 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1971 : 					return (_Uptr - this->_Myptr());	// found a match
; 1972 : 			}
; 1973 : 
; 1974 : 		return (npos);	// no match
; 1975 : 		}
; 1976 : 
; 1977 : 	size_type find_first_of(const _Elem *_Ptr,
; 1978 : 		size_type _Off = 0) const
; 1979 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1980 : 		_DEBUG_POINTER(_Ptr);
; 1981 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 1982 : 		}
; 1983 : 
; 1984 : 	size_type find_first_of(_Elem _Ch,
; 1985 : 		size_type _Off = 0) const
; 1986 : 		{	// look for _Ch at or after _Off
; 1987 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1988 : 		}
; 1989 : 
; 1990 : 	size_type find_last_of(const _Myt& _Right,
; 1991 : 		size_type _Off = npos) const _NOEXCEPT
; 1992 : 		{	// look for one of _Right before _Off
; 1993 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_last_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off, size_type _Count) const
; 1998 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 1999 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2000 : 		if (_Count != 0)
; 2001 : 			_DEBUG_POINTER(_Ptr);
; 2002 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2003 : 
; 2004 : 		if (0 < _Count && 0 < this->_Mysize)
; 2005 : 			{	// worth searching, do it
; 2006 : 			const _Elem *_Uptr = this->_Myptr()
; 2007 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2008 : 			for (; ; --_Uptr)
; 2009 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2010 : 					return (_Uptr - this->_Myptr());	// found a match
; 2011 : 				else if (_Uptr == this->_Myptr())
; 2012 : 					break;	// at beginning, no more chance for match
; 2013 : 			}
; 2014 : 
; 2015 : 		return (npos);	// no match
; 2016 : 		}
; 2017 : 
; 2018 : 	size_type find_last_of(const _Elem *_Ptr,
; 2019 : 		size_type _Off = npos) const
; 2020 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2021 : 		_DEBUG_POINTER(_Ptr);
; 2022 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2023 : 		}
; 2024 : 
; 2025 : 	size_type find_last_of(_Elem _Ch,
; 2026 : 		size_type _Off = npos) const
; 2027 : 		{	// look for _Ch before _Off
; 2028 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2029 : 		}
; 2030 : 
; 2031 : 	size_type find_first_not_of(const _Myt& _Right,
; 2032 : 		size_type _Off = 0) const _NOEXCEPT
; 2033 : 		{	// look for none of _Right at or after _Off
; 2034 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2035 : 			_Right.size()));
; 2036 : 		}
; 2037 : 
; 2038 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2039 : 		size_type _Off, size_type _Count) const
; 2040 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2041 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2042 : 		if (_Count != 0)
; 2043 : 			_DEBUG_POINTER(_Ptr);
; 2044 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2045 : 
; 2046 : 		if (_Off < this->_Mysize)
; 2047 : 			{	// room for match, look for it
; 2048 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2049 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2050 : 				_Uptr < _Vptr; ++_Uptr)
; 2051 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2052 : 					return (_Uptr - this->_Myptr());
; 2053 : 			}
; 2054 : 		return (npos);
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off = 0) const
; 2059 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2060 : 		_DEBUG_POINTER(_Ptr);
; 2061 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2062 : 		}
; 2063 : 
; 2064 : 	size_type find_first_not_of(_Elem _Ch,
; 2065 : 		size_type _Off = 0) const
; 2066 : 		{	// look for non _Ch at or after _Off
; 2067 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2068 : 		}
; 2069 : 
; 2070 : 	size_type find_last_not_of(const _Myt& _Right,
; 2071 : 		size_type _Off = npos) const _NOEXCEPT
; 2072 : 		{	// look for none of _Right before _Off
; 2073 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off, size_type _Count) const
; 2078 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2079 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2080 : 		if (_Count != 0)
; 2081 : 			_DEBUG_POINTER(_Ptr);
; 2082 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2083 : 
; 2084 : 		if (0 < this->_Mysize)
; 2085 : 			{	// worth searching, do it
; 2086 : 			const _Elem *_Uptr = this->_Myptr()
; 2087 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2088 : 			for (; ; --_Uptr)
; 2089 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2090 : 					return (_Uptr - this->_Myptr());
; 2091 : 				else if (_Uptr == this->_Myptr())
; 2092 : 					break;
; 2093 : 			}
; 2094 : 		return (npos);
; 2095 : 		}
; 2096 : 
; 2097 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2098 : 		size_type _Off = npos) const
; 2099 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2100 : 		_DEBUG_POINTER(_Ptr);
; 2101 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2102 : 		}
; 2103 : 
; 2104 : 	size_type find_last_not_of(_Elem _Ch,
; 2105 : 		size_type _Off = npos) const
; 2106 : 		{	// look for non _Ch before _Off
; 2107 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2108 : 		}
; 2109 : 
; 2110 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2111 : 		{	// return [_Off, _Off + _Count) as new string
; 2112 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2113 : 		}
; 2114 : 
; 2115 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2116 : 		{	// compare [0, _Mysize) with _Right
; 2117 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2118 : 		}
; 2119 : 
; 2120 : 	int compare(size_type _Off, size_type _N0,
; 2121 : 		const _Myt& _Right) const
; 2122 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2123 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2124 : 		}
; 2125 : 
; 2126 : 	int compare(size_type _Off,
; 2127 : 		size_type _N0, const _Myt& _Right,
; 2128 : 		size_type _Roff, size_type _Count) const
; 2129 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2130 : 		if (_Right.size() < _Roff)
; 2131 : 			_Xran();	// _Off off end
; 2132 : 		if (_Right._Mysize - _Roff < _Count)
; 2133 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2134 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2135 : 		}
; 2136 : 
; 2137 : 	int compare(const _Elem *_Ptr) const
; 2138 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2139 : 		_DEBUG_POINTER(_Ptr);
; 2140 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2141 : 		}
; 2142 : 
; 2143 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2144 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2145 : 		_DEBUG_POINTER(_Ptr);
; 2146 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2147 : 		}
; 2148 : 
; 2149 : 	int compare(size_type _Off,
; 2150 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2151 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2152 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2153 : 		if (_Count != 0)
; 2154 : 			_DEBUG_POINTER(_Ptr);
; 2155 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2156 : 
; 2157 : 		if (this->_Mysize < _Off)
; 2158 : 			_Xran();	// _Off off end
; 2159 : 		if (this->_Mysize - _Off < _N0)
; 2160 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2161 : 
; 2162 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2163 : 			_N0 < _Count ? _N0 : _Count);
; 2164 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2165 : 			: _N0 == _Count ? 0 : +1);
; 2166 : 		}
; 2167 : 
; 2168 : 	allocator_type get_allocator() const _NOEXCEPT
; 2169 : 		{	// return allocator object for values
; 2170 : 		return (this->_Getal());
; 2171 : 		}
; 2172 : 
; 2173 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2174 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2175 : 		if (_Count == 1)
; 2176 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2177 : 		else
; 2178 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2179 : 		}
; 2180 : 
; 2181 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2182 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2183 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2184 : 		if (max_size() < _Newres)
; 2185 : 			_Newres = _Newsize;	// undo roundup if too big
; 2186 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2187 : 			;
; 2188 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2189 : 			_Newres = this->_Myres
; 2190 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2191 : 		else
; 2192 : 			_Newres = max_size();	// settle for max_size()
; 2193 : 
; 2194 : 		_Elem *_Ptr;
; 2195 : 		_TRY_BEGIN
; 2196 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2197 : 		_CATCH_ALL
; 2198 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2199 : 			_TRY_BEGIN
; 2200 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2201 : 			_CATCH_ALL
; 2202 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2203 : 			_RERAISE;
; 2204 : 			_CATCH_END
; 2205 : 		_CATCH_END
; 2206 : 
; 2207 : 		if (0 < _Oldlen)
; 2208 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2209 : 				_Oldlen);	// copy existing elements
; 2210 : 		_Tidy(true);
; 2211 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2212 : 		this->_Myres = _Newres;
; 2213 : 		_Eos(_Oldlen);
; 2214 : 		}
; 2215 : 
; 2216 : 	void _Eos(size_type _Newsize)
; 2217 : 		{	// set new length and null terminator
; 2218 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  00d0c	4c 89 7d 48	 mov	 QWORD PTR $T15[rbp-240], r15
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  00d10	44 88 7d 38	 mov	 BYTE PTR $T15[rbp-256], r15b
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 1144 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

  00d14	41 b8 10 00 00
	00		 mov	 r8d, 16
  00d1a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG4294950234
  00d21	48 8d 4d 38	 lea	 rcx, QWORD PTR $T15[rbp-256]
  00d25	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp

; 99   : 	if(!program.prepare("arrayInsideCheck")) GlobalThread::stop = true;

  00d2a	48 8d 55 38	 lea	 rdx, QWORD PTR $T15[rbp-256]
  00d2e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?program@@3VProgram@cl@@A ; program
  00d35	e8 00 00 00 00	 call	 ?prepare@Program@cl@@QEAA_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; cl::Program::prepare
  00d3a	0f b6 0d 00 00
	00 00		 movzx	 ecx, BYTE PTR ?stop@GlobalThread@@3_NA ; GlobalThread::stop
  00d41	84 c0		 test	 al, al
  00d43	0f 44 cb	 cmove	 ecx, ebx
  00d46	88 0d 00 00 00
	00		 mov	 BYTE PTR ?stop@GlobalThread@@3_NA, cl ; GlobalThread::stop
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp

; 182  : 	if(!preparedKernel)

  00d4c	48 8b 0d 20 00
	00 00		 mov	 rcx, QWORD PTR ?program@@3VProgram@cl@@A+32
  00d53	48 85 c9	 test	 rcx, rcx
  00d56	0f 85 a3 00 00
	00		 jne	 $LN284@tick

; 183  : 	{
; 184  : 		GLWindow::instance->postError("Tried to set argument for unprepared kernel", "OpenCL kernel argument error");

  00d5c	48 8b 35 00 00
	00 00		 mov	 rsi, QWORD PTR ?instance@GLWindow@@2PEAV1@EA ; GLWindow::instance
; File c:\users\glenn\documents\github\wind\project\wind\wind\window.cpp

; 218  : 	wchar_t* wText = new wchar_t[lText + 1];

  00d63	b8 02 00 00 00	 mov	 eax, 2
  00d68	49 f7 e6	 mul	 r14
  00d6b	49 0f 40 c5	 cmovo	 rax, r13
  00d6f	48 8b c8	 mov	 rcx, rax
  00d72	e8 00 00 00 00	 call	 ??_U@YAPEAX_K@Z		; operator new[]
  00d77	48 8b f8	 mov	 rdi, rax

; 219  : 	mbstowcs_s(NULL, wText, lText + 1, text, lText);

  00d7a	48 c7 44 24 20
	2b 00 00 00	 mov	 QWORD PTR [rsp+32], 43	; 0000002bH
  00d83	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG4294956367
  00d8a	4d 8b c6	 mov	 r8, r14
  00d8d	48 8b d0	 mov	 rdx, rax
  00d90	33 c9		 xor	 ecx, ecx
  00d92	e8 00 00 00 00	 call	 mbstowcs_s

; 220  : 
; 221  : 	size_t lCap = strlen(text);
; 222  : 	wchar_t* wCap = new wchar_t[lCap + 1];

  00d97	b8 02 00 00 00	 mov	 eax, 2
  00d9c	49 f7 e6	 mul	 r14
  00d9f	49 0f 40 c5	 cmovo	 rax, r13
  00da3	48 8b c8	 mov	 rcx, rax
  00da6	e8 00 00 00 00	 call	 ??_U@YAPEAX_K@Z		; operator new[]
  00dab	48 8b d8	 mov	 rbx, rax

; 223  : 	mbstowcs_s(NULL, wCap, lCap + 1, caption, lCap);

  00dae	48 c7 44 24 20
	2b 00 00 00	 mov	 QWORD PTR [rsp+32], 43	; 0000002bH
  00db7	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG4294956368
  00dbe	4d 8b c6	 mov	 r8, r14
  00dc1	48 8b d0	 mov	 rdx, rax
  00dc4	33 c9		 xor	 ecx, ecx
  00dc6	e8 00 00 00 00	 call	 mbstowcs_s

; 193  : }
; 194  : 
; 195  : void GLWindow::makeCurrent()
; 196  : {
; 197  : 	wglMakeCurrent(hDC, hRC);
; 198  : }
; 199  : 
; 200  : bool GLWindow::isOK()
; 201  : {
; 202  : 	return OK;
; 203  : }
; 204  : 
; 205  : HWND GLWindow::getHWnd()
; 206  : {
; 207  : 	return hWnd;
; 208  : }
; 209  : 
; 210  : void GLWindow::messageBox(LPCWSTR lpText, LPCWSTR lpCaption, UINT uType)
; 211  : {
; 212  : 	MessageBox(hWnd, lpText, lpText, uType);

  00dcb	41 b9 10 00 00
	00		 mov	 r9d, 16
  00dd1	4c 8b c7	 mov	 r8, rdi
  00dd4	48 8b d7	 mov	 rdx, rdi
  00dd7	48 8b 4e 10	 mov	 rcx, QWORD PTR [rsi+16]
  00ddb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_MessageBoxW

; 224  : 
; 225  : 	messageBox(wText, wCap, MB_OK | MB_ICONERROR);
; 226  : 
; 227  : 	GlobalThread::stop = true;

  00de1	c6 05 00 00 00
	00 01		 mov	 BYTE PTR ?stop@GlobalThread@@3_NA, 1 ; GlobalThread::stop

; 228  : 
; 229  : 	delete wText;

  00de8	48 8b cf	 mov	 rcx, rdi
  00deb	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete

; 230  : 	delete wCap;

  00df0	48 8b cb	 mov	 rcx, rbx
  00df3	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp

; 185  : 		return false;

  00df8	bb 01 00 00 00	 mov	 ebx, 1
  00dfd	eb 2a		 jmp	 SHORT $LN1668@tick
$LN284@tick:

; 186  : 	}
; 187  : 	cl_int error = clSetKernelArg(preparedKernel, index, size, value);

  00dff	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:renderDistance
  00e06	33 d2		 xor	 edx, edx
  00e08	44 8d 42 04	 lea	 r8d, QWORD PTR [rdx+4]
  00e0c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_clSetKernelArg

; 188  : 	if(error != CL_SUCCESS)

  00e12	85 c0		 test	 eax, eax
  00e14	74 1a		 je	 SHORT $LN25@tick

; 189  : 	{
; 190  : 		GLWindow::instance->postError("Failed to set kernel argument", "OpenCL kernel argument error");

  00e16	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG4294956366
  00e1d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG4294956365
  00e24	e8 00 00 00 00	 call	 ?postError@GLWindow@@QEAAXPEBD0@Z ; GLWindow::postError
$LN1668@tick:
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp

; 100  : 	if(!program.setArgument(0, sizeof(const unsigned int), &renderDistance)) GlobalThread::stop = true;

  00e29	c6 05 00 00 00
	00 01		 mov	 BYTE PTR ?stop@GlobalThread@@3_NA, 1 ; GlobalThread::stop
$LN25@tick:
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp

; 182  : 	if(!preparedKernel)

  00e30	48 8b 0d 20 00
	00 00		 mov	 rcx, QWORD PTR ?program@@3VProgram@cl@@A+32
  00e37	48 85 c9	 test	 rcx, rcx
  00e3a	0f 85 9e 00 00
	00		 jne	 $LN294@tick

; 183  : 	{
; 184  : 		GLWindow::instance->postError("Tried to set argument for unprepared kernel", "OpenCL kernel argument error");

  00e40	48 8b 35 00 00
	00 00		 mov	 rsi, QWORD PTR ?instance@GLWindow@@2PEAV1@EA ; GLWindow::instance
; File c:\users\glenn\documents\github\wind\project\wind\wind\window.cpp

; 218  : 	wchar_t* wText = new wchar_t[lText + 1];

  00e47	b8 02 00 00 00	 mov	 eax, 2
  00e4c	49 f7 e6	 mul	 r14
  00e4f	49 0f 40 c5	 cmovo	 rax, r13
  00e53	48 8b c8	 mov	 rcx, rax
  00e56	e8 00 00 00 00	 call	 ??_U@YAPEAX_K@Z		; operator new[]
  00e5b	48 8b f8	 mov	 rdi, rax

; 219  : 	mbstowcs_s(NULL, wText, lText + 1, text, lText);

  00e5e	48 c7 44 24 20
	2b 00 00 00	 mov	 QWORD PTR [rsp+32], 43	; 0000002bH
  00e67	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG4294956367
  00e6e	4d 8b c6	 mov	 r8, r14
  00e71	48 8b d0	 mov	 rdx, rax
  00e74	33 c9		 xor	 ecx, ecx
  00e76	e8 00 00 00 00	 call	 mbstowcs_s

; 220  : 
; 221  : 	size_t lCap = strlen(text);
; 222  : 	wchar_t* wCap = new wchar_t[lCap + 1];

  00e7b	b8 02 00 00 00	 mov	 eax, 2
  00e80	49 f7 e6	 mul	 r14
  00e83	49 0f 40 c5	 cmovo	 rax, r13
  00e87	48 8b c8	 mov	 rcx, rax
  00e8a	e8 00 00 00 00	 call	 ??_U@YAPEAX_K@Z		; operator new[]
  00e8f	48 8b d8	 mov	 rbx, rax

; 223  : 	mbstowcs_s(NULL, wCap, lCap + 1, caption, lCap);

  00e92	48 c7 44 24 20
	2b 00 00 00	 mov	 QWORD PTR [rsp+32], 43	; 0000002bH
  00e9b	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG4294956368
  00ea2	4d 8b c6	 mov	 r8, r14
  00ea5	48 8b d0	 mov	 rdx, rax
  00ea8	33 c9		 xor	 ecx, ecx
  00eaa	e8 00 00 00 00	 call	 mbstowcs_s

; 193  : }
; 194  : 
; 195  : void GLWindow::makeCurrent()
; 196  : {
; 197  : 	wglMakeCurrent(hDC, hRC);
; 198  : }
; 199  : 
; 200  : bool GLWindow::isOK()
; 201  : {
; 202  : 	return OK;
; 203  : }
; 204  : 
; 205  : HWND GLWindow::getHWnd()
; 206  : {
; 207  : 	return hWnd;
; 208  : }
; 209  : 
; 210  : void GLWindow::messageBox(LPCWSTR lpText, LPCWSTR lpCaption, UINT uType)
; 211  : {
; 212  : 	MessageBox(hWnd, lpText, lpText, uType);

  00eaf	41 b9 10 00 00
	00		 mov	 r9d, 16
  00eb5	4c 8b c7	 mov	 r8, rdi
  00eb8	48 8b d7	 mov	 rdx, rdi
  00ebb	48 8b 4e 10	 mov	 rcx, QWORD PTR [rsi+16]
  00ebf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_MessageBoxW

; 224  : 
; 225  : 	messageBox(wText, wCap, MB_OK | MB_ICONERROR);
; 226  : 
; 227  : 	GlobalThread::stop = true;

  00ec5	c6 05 00 00 00
	00 01		 mov	 BYTE PTR ?stop@GlobalThread@@3_NA, 1 ; GlobalThread::stop

; 228  : 
; 229  : 	delete wText;

  00ecc	48 8b cf	 mov	 rcx, rdi
  00ecf	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete

; 230  : 	delete wCap;

  00ed4	48 8b cb	 mov	 rcx, rbx
  00ed7	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp

; 185  : 		return false;

  00edc	eb 2c		 jmp	 SHORT $LN1669@tick
$LN294@tick:

; 186  : 	}
; 187  : 	cl_int error = clSetKernelArg(preparedKernel, index, size, value);

  00ede	4c 8d 0d 08 00
	00 00		 lea	 r9, OFFSET FLAT:?gridBuffer@@3VBuffer@cl@@A+8
  00ee5	41 b8 08 00 00
	00		 mov	 r8d, 8
  00eeb	8b d3		 mov	 edx, ebx
  00eed	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_clSetKernelArg

; 188  : 	if(error != CL_SUCCESS)

  00ef3	85 c0		 test	 eax, eax
  00ef5	74 1a		 je	 SHORT $LN24@tick

; 189  : 	{
; 190  : 		GLWindow::instance->postError("Failed to set kernel argument", "OpenCL kernel argument error");

  00ef7	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG4294956366
  00efe	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG4294956365
  00f05	e8 00 00 00 00	 call	 ?postError@GLWindow@@QEAAXPEBD0@Z ; GLWindow::postError
$LN1669@tick:
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp

; 101  : 	if(!program.setArgument(1, sizeof(cl_mem), &gridBuffer)) GlobalThread::stop = true;

  00f0a	c6 05 00 00 00
	00 01		 mov	 BYTE PTR ?stop@GlobalThread@@3_NA, 1 ; GlobalThread::stop
$LN24@tick:
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp

; 182  : 	if(!preparedKernel)

  00f11	48 8b 0d 20 00
	00 00		 mov	 rcx, QWORD PTR ?program@@3VProgram@cl@@A+32
  00f18	48 85 c9	 test	 rcx, rcx
  00f1b	0f 85 9e 00 00
	00		 jne	 $LN304@tick

; 183  : 	{
; 184  : 		GLWindow::instance->postError("Tried to set argument for unprepared kernel", "OpenCL kernel argument error");

  00f21	48 8b 35 00 00
	00 00		 mov	 rsi, QWORD PTR ?instance@GLWindow@@2PEAV1@EA ; GLWindow::instance
; File c:\users\glenn\documents\github\wind\project\wind\wind\window.cpp

; 218  : 	wchar_t* wText = new wchar_t[lText + 1];

  00f28	b8 02 00 00 00	 mov	 eax, 2
  00f2d	49 f7 e6	 mul	 r14
  00f30	49 0f 40 c5	 cmovo	 rax, r13
  00f34	48 8b c8	 mov	 rcx, rax
  00f37	e8 00 00 00 00	 call	 ??_U@YAPEAX_K@Z		; operator new[]
  00f3c	48 8b f8	 mov	 rdi, rax

; 219  : 	mbstowcs_s(NULL, wText, lText + 1, text, lText);

  00f3f	48 c7 44 24 20
	2b 00 00 00	 mov	 QWORD PTR [rsp+32], 43	; 0000002bH
  00f48	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG4294956367
  00f4f	4d 8b c6	 mov	 r8, r14
  00f52	48 8b d0	 mov	 rdx, rax
  00f55	33 c9		 xor	 ecx, ecx
  00f57	e8 00 00 00 00	 call	 mbstowcs_s

; 220  : 
; 221  : 	size_t lCap = strlen(text);
; 222  : 	wchar_t* wCap = new wchar_t[lCap + 1];

  00f5c	b8 02 00 00 00	 mov	 eax, 2
  00f61	49 f7 e6	 mul	 r14
  00f64	49 0f 40 c5	 cmovo	 rax, r13
  00f68	48 8b c8	 mov	 rcx, rax
  00f6b	e8 00 00 00 00	 call	 ??_U@YAPEAX_K@Z		; operator new[]
  00f70	48 8b d8	 mov	 rbx, rax

; 223  : 	mbstowcs_s(NULL, wCap, lCap + 1, caption, lCap);

  00f73	48 c7 44 24 20
	2b 00 00 00	 mov	 QWORD PTR [rsp+32], 43	; 0000002bH
  00f7c	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG4294956368
  00f83	4d 8b c6	 mov	 r8, r14
  00f86	48 8b d0	 mov	 rdx, rax
  00f89	33 c9		 xor	 ecx, ecx
  00f8b	e8 00 00 00 00	 call	 mbstowcs_s

; 193  : }
; 194  : 
; 195  : void GLWindow::makeCurrent()
; 196  : {
; 197  : 	wglMakeCurrent(hDC, hRC);
; 198  : }
; 199  : 
; 200  : bool GLWindow::isOK()
; 201  : {
; 202  : 	return OK;
; 203  : }
; 204  : 
; 205  : HWND GLWindow::getHWnd()
; 206  : {
; 207  : 	return hWnd;
; 208  : }
; 209  : 
; 210  : void GLWindow::messageBox(LPCWSTR lpText, LPCWSTR lpCaption, UINT uType)
; 211  : {
; 212  : 	MessageBox(hWnd, lpText, lpText, uType);

  00f90	41 b9 10 00 00
	00		 mov	 r9d, 16
  00f96	4c 8b c7	 mov	 r8, rdi
  00f99	48 8b d7	 mov	 rdx, rdi
  00f9c	48 8b 4e 10	 mov	 rcx, QWORD PTR [rsi+16]
  00fa0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_MessageBoxW

; 224  : 
; 225  : 	messageBox(wText, wCap, MB_OK | MB_ICONERROR);
; 226  : 
; 227  : 	GlobalThread::stop = true;

  00fa6	c6 05 00 00 00
	00 01		 mov	 BYTE PTR ?stop@GlobalThread@@3_NA, 1 ; GlobalThread::stop

; 228  : 
; 229  : 	delete wText;

  00fad	48 8b cf	 mov	 rcx, rdi
  00fb0	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete

; 230  : 	delete wCap;

  00fb5	48 8b cb	 mov	 rcx, rbx
  00fb8	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp

; 185  : 		return false;

  00fbd	eb 2d		 jmp	 SHORT $LN1670@tick
$LN304@tick:

; 186  : 	}
; 187  : 	cl_int error = clSetKernelArg(preparedKernel, index, size, value);

  00fbf	4c 8d 0d 08 00
	00 00		 lea	 r9, OFFSET FLAT:?boolBuffer@@3VBuffer@cl@@A+8
  00fc6	ba 02 00 00 00	 mov	 edx, 2
  00fcb	44 8d 42 06	 lea	 r8d, QWORD PTR [rdx+6]
  00fcf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_clSetKernelArg

; 188  : 	if(error != CL_SUCCESS)

  00fd5	85 c0		 test	 eax, eax
  00fd7	74 1a		 je	 SHORT $LN23@tick

; 189  : 	{
; 190  : 		GLWindow::instance->postError("Failed to set kernel argument", "OpenCL kernel argument error");

  00fd9	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG4294956366
  00fe0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG4294956365
  00fe7	e8 00 00 00 00	 call	 ?postError@GLWindow@@QEAAXPEBD0@Z ; GLWindow::postError
$LN1670@tick:
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp

; 102  : 	if(!program.setArgument(2, sizeof(cl_mem), &boolBuffer)) GlobalThread::stop = true;

  00fec	c6 05 00 00 00
	00 01		 mov	 BYTE PTR ?stop@GlobalThread@@3_NA, 1 ; GlobalThread::stop
$LN23@tick:
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp

; 203  : 	if(!preparedKernel)

  00ff3	48 8b 15 20 00
	00 00		 mov	 rdx, QWORD PTR ?program@@3VProgram@cl@@A+32
  00ffa	48 85 d2	 test	 rdx, rdx
  00ffd	0f 85 a9 00 00
	00		 jne	 $LN314@tick

; 204  : 	{
; 205  : 		GLWindow::instance->postError("Tried to execute unprepared kernel", "OpenCL program execution error");

  01003	48 8b 35 00 00
	00 00		 mov	 rsi, QWORD PTR ?instance@GLWindow@@2PEAV1@EA ; GLWindow::instance
; File c:\users\glenn\documents\github\wind\project\wind\wind\window.cpp

; 218  : 	wchar_t* wText = new wchar_t[lText + 1];

  0100a	b8 02 00 00 00	 mov	 eax, 2
  0100f	41 be 23 00 00
	00		 mov	 r14d, 35		; 00000023H
  01015	49 f7 e6	 mul	 r14
  01018	49 0f 40 c5	 cmovo	 rax, r13
  0101c	48 8b c8	 mov	 rcx, rax
  0101f	e8 00 00 00 00	 call	 ??_U@YAPEAX_K@Z		; operator new[]
  01024	48 8b f8	 mov	 rdi, rax

; 219  : 	mbstowcs_s(NULL, wText, lText + 1, text, lText);

  01027	48 c7 44 24 20
	22 00 00 00	 mov	 QWORD PTR [rsp+32], 34	; 00000022H
  01030	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG4294956363
  01037	45 8b c6	 mov	 r8d, r14d
  0103a	48 8b d0	 mov	 rdx, rax
  0103d	33 c9		 xor	 ecx, ecx
  0103f	e8 00 00 00 00	 call	 mbstowcs_s

; 220  : 
; 221  : 	size_t lCap = strlen(text);
; 222  : 	wchar_t* wCap = new wchar_t[lCap + 1];

  01044	b8 02 00 00 00	 mov	 eax, 2
  01049	49 f7 e6	 mul	 r14
  0104c	49 0f 40 c5	 cmovo	 rax, r13
  01050	48 8b c8	 mov	 rcx, rax
  01053	e8 00 00 00 00	 call	 ??_U@YAPEAX_K@Z		; operator new[]
  01058	48 8b d8	 mov	 rbx, rax

; 223  : 	mbstowcs_s(NULL, wCap, lCap + 1, caption, lCap);

  0105b	48 c7 44 24 20
	22 00 00 00	 mov	 QWORD PTR [rsp+32], 34	; 00000022H
  01064	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG4294956364
  0106b	45 8b c6	 mov	 r8d, r14d
  0106e	48 8b d0	 mov	 rdx, rax
  01071	33 c9		 xor	 ecx, ecx
  01073	e8 00 00 00 00	 call	 mbstowcs_s

; 193  : }
; 194  : 
; 195  : void GLWindow::makeCurrent()
; 196  : {
; 197  : 	wglMakeCurrent(hDC, hRC);
; 198  : }
; 199  : 
; 200  : bool GLWindow::isOK()
; 201  : {
; 202  : 	return OK;
; 203  : }
; 204  : 
; 205  : HWND GLWindow::getHWnd()
; 206  : {
; 207  : 	return hWnd;
; 208  : }
; 209  : 
; 210  : void GLWindow::messageBox(LPCWSTR lpText, LPCWSTR lpCaption, UINT uType)
; 211  : {
; 212  : 	MessageBox(hWnd, lpText, lpText, uType);

  01078	45 8d 4e ed	 lea	 r9d, QWORD PTR [r14-19]
  0107c	4c 8b c7	 mov	 r8, rdi
  0107f	48 8b d7	 mov	 rdx, rdi
  01082	48 8b 4e 10	 mov	 rcx, QWORD PTR [rsi+16]
  01086	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_MessageBoxW

; 224  : 
; 225  : 	messageBox(wText, wCap, MB_OK | MB_ICONERROR);
; 226  : 
; 227  : 	GlobalThread::stop = true;

  0108c	c6 05 00 00 00
	00 01		 mov	 BYTE PTR ?stop@GlobalThread@@3_NA, 1 ; GlobalThread::stop

; 228  : 
; 229  : 	delete wText;

  01093	48 8b cf	 mov	 rcx, rdi
  01096	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete

; 230  : 	delete wCap;

  0109b	48 8b cb	 mov	 rcx, rbx
  0109e	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp

; 206  : 		return false;

  010a3	41 8d 5e de	 lea	 ebx, QWORD PTR [r14-34]
  010a7	e9 a3 00 00 00	 jmp	 $LN1671@tick
$LN314@tick:

; 207  : 	}
; 208  : 
; 209  : 	cl_int error;
; 210  : 	cl_event event;
; 211  : 
; 212  : 	error = clEnqueueNDRangeKernel(queue.queue, preparedKernel, dimensions, NULL, globalWorkSize, localWorkSize, 0, NULL, &event);

  010ac	48 8d 45 e8	 lea	 rax, QWORD PTR event$9[rbp-256]
  010b0	48 89 44 24 40	 mov	 QWORD PTR [rsp+64], rax
  010b5	4c 89 7c 24 38	 mov	 QWORD PTR [rsp+56], r15
  010ba	44 89 7c 24 30	 mov	 DWORD PTR [rsp+48], r15d
  010bf	48 8d 85 08 06
	00 00		 lea	 rax, QWORD PTR local_ws_2$[rbp-256]
  010c6	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  010cb	48 8d 85 f0 05
	00 00		 lea	 rax, QWORD PTR global_ws_2$[rbp-256]
  010d2	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  010d7	45 33 c9	 xor	 r9d, r9d
  010da	45 8d 41 03	 lea	 r8d, QWORD PTR [r9+3]
  010de	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?commandQueue@@3VCommandQueue@cl@@A
  010e5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_clEnqueueNDRangeKernel

; 213  : 	if(error != CL_SUCCESS)

  010eb	85 c0		 test	 eax, eax
  010ed	74 1a		 je	 SHORT $LN313@tick

; 214  : 	{
; 215  : 		GLWindow::instance->postError("Failed to exectue kernel", "OpenCL program execution error");

  010ef	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG4294956362
  010f6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG4294956361
  010fd	e8 00 00 00 00	 call	 ?postError@GLWindow@@QEAAXPEBD0@Z ; GLWindow::postError

; 216  : 		return false;

  01102	bb 01 00 00 00	 mov	 ebx, 1
  01107	eb 46		 jmp	 SHORT $LN1671@tick
$LN313@tick:

; 217  : 	}
; 218  : 
; 219  : 	error = clWaitForEvents(1, &event);

  01109	48 8d 55 e8	 lea	 rdx, QWORD PTR event$9[rbp-256]
  0110d	bb 01 00 00 00	 mov	 ebx, 1
  01112	8b cb		 mov	 ecx, ebx
  01114	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_clWaitForEvents

; 220  : 	if(error != CL_SUCCESS)

  0111a	85 c0		 test	 eax, eax
  0111c	74 10		 je	 SHORT $LN312@tick

; 221  : 	{
; 222  : 		GLWindow::instance->postError("Failed to wait for kernel finish event", "OpenCL program execution error");

  0111e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG4294956360
  01125	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG4294956359

; 223  : 		return false;

  0112c	eb 1c		 jmp	 SHORT $LN1692@tick
$LN312@tick:

; 224  : 	}
; 225  : 
; 226  : 	error = clReleaseEvent(event);

  0112e	48 8b 4d e8	 mov	 rcx, QWORD PTR event$9[rbp-256]
  01132	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_clReleaseEvent

; 227  : 	if(error != CL_SUCCESS)

  01138	85 c0		 test	 eax, eax
  0113a	74 1c		 je	 SHORT $LN311@tick

; 228  : 	{
; 229  : 		GLWindow::instance->postError("Failed to release kernel finish event", "OpenCL program execution error");

  0113c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG4294956358
  01143	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG4294956357
$LN1692@tick:
  0114a	e8 00 00 00 00	 call	 ?postError@GLWindow@@QEAAXPEBD0@Z ; GLWindow::postError
$LN1671@tick:
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp

; 103  : 	if(!program.invoke(commandQueue, 3, global_ws_2, local_ws_2)) GlobalThread::stop = true;

  0114f	c6 05 00 00 00
	00 01		 mov	 BYTE PTR ?stop@GlobalThread@@3_NA, 1 ; GlobalThread::stop
  01156	eb 1e		 jmp	 SHORT $LN22@tick
$LN311@tick:
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp

; 233  : 	preparedKernel = 0;

  01158	4c 89 3d 20 00
	00 00		 mov	 QWORD PTR ?program@@3VProgram@cl@@A+32, r15
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 83   : 	return (_Check_C_return(_Mtx_unlock(_Mtx)));

  0115f	48 8d 0d 18 00
	00 00		 lea	 rcx, OFFSET FLAT:?program@@3VProgram@cl@@A+24
  01166	e8 00 00 00 00	 call	 _Mtx_unlock

; 32   : 	if (_Res != _Thrd_success)

  0116b	85 c0		 test	 eax, eax
  0116d	74 07		 je	 SHORT $LN22@tick

; 33   : 		_Throw_C_error(_Res);

  0116f	8b c8		 mov	 ecx, eax
  01171	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
$LN22@tick:
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp

; 309  : 	if(!okay) return false;

  01176	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?bGrid@@3PAY1BB@BB@_NA ; bGrid
  0117d	44 38 3d 00 00
	00 00		 cmp	 BYTE PTR ?gridBuffer@@3VBuffer@cl@@A, r15b
  01184	0f 84 93 00 00
	00		 je	 $LN1672@tick

; 310  : 
; 311  : 	cl_event event;
; 312  : 
; 313  : 	cl_int error = clEnqueueReadBuffer(queue.queue, mem, CL_TRUE, offset, cb, data, 0, NULL, &event);

  0118a	48 8d 45 e0	 lea	 rax, QWORD PTR event$8[rbp-256]
  0118e	48 89 44 24 40	 mov	 QWORD PTR [rsp+64], rax
  01193	4c 89 7c 24 38	 mov	 QWORD PTR [rsp+56], r15
  01198	44 89 7c 24 30	 mov	 DWORD PTR [rsp+48], r15d
  0119d	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  011a2	48 8b 05 10 00
	00 00		 mov	 rax, QWORD PTR ?gridBuffer@@3VBuffer@cl@@A+16
  011a9	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  011ae	45 33 c9	 xor	 r9d, r9d
  011b1	44 8b c3	 mov	 r8d, ebx
  011b4	48 8b 15 08 00
	00 00		 mov	 rdx, QWORD PTR ?gridBuffer@@3VBuffer@cl@@A+8
  011bb	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?commandQueue@@3VCommandQueue@cl@@A
  011c2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_clEnqueueReadBuffer

; 314  : 	if(error)

  011c8	85 c0		 test	 eax, eax
  011ca	74 10		 je	 SHORT $LN332@tick

; 315  : 	{
; 316  : 		GLWindow::instance->postError("Failed to read buffer", "OpenCL buffer read error");

  011cc	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG4294956346
  011d3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG4294956345

; 317  : 		return false;

  011da	eb 3c		 jmp	 SHORT $LN1693@tick
$LN332@tick:

; 318  : 	}
; 319  : 
; 320  : 	error = clWaitForEvents(1, &event);

  011dc	48 8d 55 e0	 lea	 rdx, QWORD PTR event$8[rbp-256]
  011e0	8b cb		 mov	 ecx, ebx
  011e2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_clWaitForEvents

; 321  : 	if(error != CL_SUCCESS)

  011e8	85 c0		 test	 eax, eax
  011ea	74 10		 je	 SHORT $LN331@tick

; 322  : 	{
; 323  : 		GLWindow::instance->postError("Failed to wait for kernel finish event", "OpenCL program execution error");

  011ec	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG4294956344
  011f3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG4294956343

; 324  : 		return false;

  011fa	eb 1c		 jmp	 SHORT $LN1693@tick
$LN331@tick:

; 325  : 	}
; 326  : 
; 327  : 	error = clReleaseEvent(event);

  011fc	48 8b 4d e0	 mov	 rcx, QWORD PTR event$8[rbp-256]
  01200	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_clReleaseEvent

; 328  : 	if(error != CL_SUCCESS)

  01206	85 c0		 test	 eax, eax
  01208	74 1a		 je	 SHORT $LN21@tick

; 329  : 	{
; 330  : 		GLWindow::instance->postError("Failed to release kernel finish event", "OpenCL program execution error");

  0120a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG4294956342
  01211	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG4294956341
$LN1693@tick:
  01218	e8 00 00 00 00	 call	 ?postError@GLWindow@@QEAAXPEBD0@Z ; GLWindow::postError
$LN1672@tick:
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp

; 105  : 	if(!gridBuffer.read(commandQueue, bGrid)) GlobalThread::stop = true;

  0121d	c6 05 00 00 00
	00 01		 mov	 BYTE PTR ?stop@GlobalThread@@3_NA, 1 ; GlobalThread::stop
$LN21@tick:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 68   : 	return (_Check_C_return(_Mtx_lock(_Mtx)));

  01224	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?world@GlobalThread@@3VWorld@@A ; GlobalThread::world
  0122b	e8 00 00 00 00	 call	 _Mtx_lock

; 32   : 	if (_Res != _Thrd_success)

  01230	85 c0		 test	 eax, eax
  01232	74 07		 je	 SHORT $LN340@tick

; 33   : 		_Throw_C_error(_Res);

  01234	8b c8		 mov	 ecx, eax
  01236	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
$LN340@tick:

; 68   : 	return (_Check_C_return(_Mtx_lock(_Mtx)));

  0123b	48 8d 0d 18 00
	00 00		 lea	 rcx, OFFSET FLAT:?world@GlobalThread@@3VWorld@@A+24
  01242	e8 00 00 00 00	 call	 _Mtx_lock

; 32   : 	if (_Res != _Thrd_success)

  01247	85 c0		 test	 eax, eax
  01249	74 07		 je	 SHORT $LN1599@tick

; 33   : 		_Throw_C_error(_Res);

  0124b	8b c8		 mov	 ecx, eax
  0124d	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
$LN1599@tick:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 1382 : 		return (this->_Mysize == 0);

  01252	4c 39 3d 40 00
	00 00		 cmp	 QWORD PTR ?world@GlobalThread@@3VWorld@@A+64, r15
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp

; 123  : 	while(!GlobalThread::world.additionQueue.empty())

  01259	0f 84 7b 02 00
	00		 je	 $LN19@tick
  0125f	48 8d 44 24 78	 lea	 rax, QWORD PTR $T1[rsp]
  01264	48 89 85 90 00
	00 00		 mov	 QWORD PTR $T19[rbp-256], rax
  0126b	0f 1f 44 00 00	 npad	 5
$LL20@tick:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 1426 : 		return (*begin());

  01270	48 8d 95 10 03
	00 00		 lea	 rdx, QWORD PTR $T33[rbp-256]
  01277	48 8d 0d 20 00
	00 00		 lea	 rcx, OFFSET FLAT:?world@GlobalThread@@3VWorld@@A+32
  0127e	e8 00 00 00 00	 call	 ?begin@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@2@XZ ; std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::begin
  01283	48 8b d0	 mov	 rdx, rax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility

; 178  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

  01286	48 8b 00	 mov	 rax, QWORD PTR [rax]
  01289	48 85 c0	 test	 rax, rax
  0128c	75 05		 jne	 SHORT $LN364@tick
  0128e	49 8b c7	 mov	 rax, r15
  01291	eb 03		 jmp	 SHORT $LN365@tick
$LN364@tick:
  01293	48 8b 00	 mov	 rax, QWORD PTR [rax]
$LN365@tick:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 787  : 		return ((_Off / _DEQUESIZ) & (this->_Mapsize - 1));

  01296	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  0129a	48 ff c9	 dec	 rcx
  0129d	48 23 4a 10	 and	 rcx, QWORD PTR [rdx+16]

; 1426 : 		return (*begin());

  012a1	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  012a5	48 8b 0c c8	 mov	 rcx, QWORD PTR [rax+rcx*8]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 357  : 		_Reset(_Other._Ptr, _Other._Rep);

  012a9	48 8b 79 08	 mov	 rdi, QWORD PTR [rcx+8]
  012ad	48 8b 31	 mov	 rsi, QWORD PTR [rcx]

; 358  : 		}
; 359  : 
; 360  : 	template<class _Ty2>
; 361  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, bool _Throw)
; 362  : 		{	// release resource and take ownership from weak_ptr _Other._Ptr
; 363  : 		_Reset(_Other._Ptr, _Other._Rep, _Throw);
; 364  : 		}
; 365  : 
; 366  : 	template<class _Ty2>
; 367  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Static_tag&)
; 368  : 		{	// release resource and take ownership of _Other._Ptr
; 369  : 		_Reset(static_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 370  : 		}
; 371  : 
; 372  : 	template<class _Ty2>
; 373  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Const_tag&)
; 374  : 		{	// release resource and take ownership of _Other._Ptr
; 375  : 		_Reset(const_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 376  : 		}
; 377  : 
; 378  : 	template<class _Ty2>
; 379  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Dynamic_tag&)
; 380  : 		{	// release resource and take ownership of _Other._Ptr
; 381  : 		_Elem *_Ptr = dynamic_cast<_Elem *>(_Other._Ptr);
; 382  : 		if (_Ptr)
; 383  : 			_Reset(_Ptr, _Other._Rep);
; 384  : 		else
; 385  : 			_Reset();
; 386  : 		}
; 387  : 
; 388  : 	template<class _Ty2>
; 389  : 		void _Reset(auto_ptr<_Ty2>&& _Other)
; 390  : 		{	// release resource and take _Other.get()
; 391  : 		_Ty2 *_Px = _Other.get();
; 392  : 		_Reset0(_Px, new _Ref_count<_Elem>(_Px));
; 393  : 		_Other.release();
; 394  : 		_Enable_shared(_Px, _Rep);
; 395  : 		}
; 396  : 
; 397  :  #if _HAS_CPP0X
; 398  : 	template<class _Ty2>
; 399  : 		void _Reset(_Ty *_Ptr, const _Ptr_base<_Ty2>& _Other)
; 400  : 		{	// release resource and alias _Ptr with _Other_rep
; 401  : 		_Reset(_Ptr, _Other._Rep);
; 402  : 		}
; 403  :  #endif /* _HAS_CPP0X */
; 404  : 
; 405  : 	void _Reset(_Ty *_Other_ptr, _Ref_count_base *_Other_rep)
; 406  : 		{	// release resource and take _Other_ptr through _Other_rep
; 407  : 		if (_Other_rep)

  012b0	48 85 ff	 test	 rdi, rdi
  012b3	74 04		 je	 SHORT $LN385@tick

; 108  : 		_MT_INCR(_Ignored, _Uses);

  012b5	f0 ff 47 08	 lock inc DWORD PTR [rdi+8]
$LN385@tick:

; 425  : 			_Rep->_Decref();
; 426  : 		_Rep = _Other_rep;

  012b9	48 89 bd c8 00
	00 00		 mov	 QWORD PTR c$23[rbp-248], rdi

; 427  : 		_Ptr = _Other_ptr;

  012c0	48 89 b5 c0 00
	00 00		 mov	 QWORD PTR c$23[rbp-256], rsi
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 1382 : 		return (this->_Mysize == 0);

  012c7	48 83 3d 40 00
	00 00 00	 cmp	 QWORD PTR ?world@GlobalThread@@3VWorld@@A+64, 0

; 1427 : 		}
; 1428 : 
; 1429 : 	const_reference front() const
; 1430 : 		{	// return first element of nonmutable sequence
; 1431 : 		return (*begin());
; 1432 : 		}
; 1433 : 
; 1434 : 	reference back()
; 1435 : 		{	// return last element of mutable sequence
; 1436 : 		return (*(end() - 1));
; 1437 : 		}
; 1438 : 
; 1439 : 	const_reference back() const
; 1440 : 		{	// return last element of nonmutable sequence
; 1441 : 		return (*(end() - 1));
; 1442 : 		}
; 1443 : 
; 1444 : 	void push_front(const value_type& _Val)
; 1445 : 		{	// insert element at beginning
; 1446 : 		this->_Orphan_all();
; 1447 : 		_PUSH_FRONT_BEGIN;
; 1448 : 		this->_Getal().construct(
; 1449 : 			this->_Map[_Block] + _Newoff % _DEQUESIZ, _Val);
; 1450 : 		_PUSH_FRONT_END;
; 1451 : 		}
; 1452 : 
; 1453 : 	void pop_front()
; 1454 : 		{	// erase element at beginning
; 1455 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1456 : 		if (empty())
; 1457 : 			_DEBUG_ERROR("deque empty before pop");
; 1458 : 		else
; 1459 : 			{	// something to erase, do it
; 1460 : 			_Orphan_off(this->_Myoff);
; 1461 : 			size_type _Block = this->_Getblock(this->_Myoff);
; 1462 : 			this->_Getal().destroy(
; 1463 : 				this->_Map[_Block] + this->_Myoff % _DEQUESIZ);
; 1464 : 			if (--this->_Mysize == 0)
; 1465 : 				this->_Myoff = 0;
; 1466 : 			else
; 1467 : 				++this->_Myoff;
; 1468 : 			}
; 1469 : 
; 1470 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1471 : 		if (!empty())

  012cf	74 5b		 je	 SHORT $LN390@tick

; 787  : 		return ((_Off / _DEQUESIZ) & (this->_Mapsize - 1));

  012d1	48 8b 0d 30 00
	00 00		 mov	 rcx, QWORD PTR ?world@GlobalThread@@3VWorld@@A+48
  012d8	48 ff c9	 dec	 rcx
  012db	48 23 0d 38 00
	00 00		 and	 rcx, QWORD PTR ?world@GlobalThread@@3VWorld@@A+56

; 1472 : 			{	// something to erase, do it
; 1473 : 			size_type _Block = this->_Getblock(this->_Myoff);
; 1474 : 			this->_Getal().destroy(
; 1475 : 				this->_Map[_Block] + this->_Myoff % _DEQUESIZ);

  012e2	48 8b 05 28 00
	00 00		 mov	 rax, QWORD PTR ?world@GlobalThread@@3VWorld@@A+40
  012e9	48 8b 0c c8	 mov	 rcx, QWORD PTR [rax+rcx*8]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  012ed	48 8b 59 08	 mov	 rbx, QWORD PTR [rcx+8]
  012f1	48 85 db	 test	 rbx, rbx
  012f4	74 1d		 je	 SHORT $LN1680@tick

; 109  : 		}
; 110  : 
; 111  : 	void _Incwref()
; 112  : 		{	// increment weak reference count
; 113  : 		_MT_INCR(_Ignored, _Weaks);
; 114  : 		}
; 115  : 
; 116  : 	void _Decref()
; 117  : 		{	// decrement use count
; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  012f6	f0 ff 4b 08	 lock dec DWORD PTR [rbx+8]
  012fa	75 17		 jne	 SHORT $LN1680@tick

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  012fc	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  012ff	48 8b cb	 mov	 rcx, rbx
  01302	ff 10		 call	 QWORD PTR [rax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  01304	f0 ff 4b 0c	 lock dec DWORD PTR [rbx+12]
  01308	75 09		 jne	 SHORT $LN1680@tick

; 128  : 			_Delete_this();

  0130a	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  0130d	48 8b cb	 mov	 rcx, rbx
  01310	ff 50 08	 call	 QWORD PTR [rax+8]
$LN1680@tick:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 1476 : 			if (--this->_Mysize == 0)

  01313	48 ff 0d 40 00
	00 00		 dec	 QWORD PTR ?world@GlobalThread@@3VWorld@@A+64
  0131a	75 09		 jne	 SHORT $LN391@tick

; 1477 : 				this->_Myoff = 0;

  0131c	4c 89 3d 38 00
	00 00		 mov	 QWORD PTR ?world@GlobalThread@@3VWorld@@A+56, r15

; 1478 : 			else

  01323	eb 07		 jmp	 SHORT $LN390@tick
$LN391@tick:

; 1479 : 				++this->_Myoff;

  01325	48 ff 05 38 00
	00 00		 inc	 QWORD PTR ?world@GlobalThread@@3VWorld@@A+56
$LN390@tick:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 282  : 		{	// construct

  0132c	4c 89 7c 24 78	 mov	 QWORD PTR $T1[rsp], r15
  01331	4c 89 7d 80	 mov	 QWORD PTR $T1[rbp-248], r15

; 358  : 		}
; 359  : 
; 360  : 	template<class _Ty2>
; 361  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, bool _Throw)
; 362  : 		{	// release resource and take ownership from weak_ptr _Other._Ptr
; 363  : 		_Reset(_Other._Ptr, _Other._Rep, _Throw);
; 364  : 		}
; 365  : 
; 366  : 	template<class _Ty2>
; 367  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Static_tag&)
; 368  : 		{	// release resource and take ownership of _Other._Ptr
; 369  : 		_Reset(static_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 370  : 		}
; 371  : 
; 372  : 	template<class _Ty2>
; 373  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Const_tag&)
; 374  : 		{	// release resource and take ownership of _Other._Ptr
; 375  : 		_Reset(const_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 376  : 		}
; 377  : 
; 378  : 	template<class _Ty2>
; 379  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Dynamic_tag&)
; 380  : 		{	// release resource and take ownership of _Other._Ptr
; 381  : 		_Elem *_Ptr = dynamic_cast<_Elem *>(_Other._Ptr);
; 382  : 		if (_Ptr)
; 383  : 			_Reset(_Ptr, _Other._Rep);
; 384  : 		else
; 385  : 			_Reset();
; 386  : 		}
; 387  : 
; 388  : 	template<class _Ty2>
; 389  : 		void _Reset(auto_ptr<_Ty2>&& _Other)
; 390  : 		{	// release resource and take _Other.get()
; 391  : 		_Ty2 *_Px = _Other.get();
; 392  : 		_Reset0(_Px, new _Ref_count<_Elem>(_Px));
; 393  : 		_Other.release();
; 394  : 		_Enable_shared(_Px, _Rep);
; 395  : 		}
; 396  : 
; 397  :  #if _HAS_CPP0X
; 398  : 	template<class _Ty2>
; 399  : 		void _Reset(_Ty *_Ptr, const _Ptr_base<_Ty2>& _Other)
; 400  : 		{	// release resource and alias _Ptr with _Other_rep
; 401  : 		_Reset(_Ptr, _Other._Rep);
; 402  : 		}
; 403  :  #endif /* _HAS_CPP0X */
; 404  : 
; 405  : 	void _Reset(_Ty *_Other_ptr, _Ref_count_base *_Other_rep)
; 406  : 		{	// release resource and take _Other_ptr through _Other_rep
; 407  : 		if (_Other_rep)

  01335	48 85 ff	 test	 rdi, rdi
  01338	74 2a		 je	 SHORT $LN1681@tick

; 108  : 		_MT_INCR(_Ignored, _Uses);

  0133a	f0 ff 47 08	 lock inc DWORD PTR [rdi+8]

; 410  : 		}
; 411  : 
; 412  : 	void _Reset(_Ty *_Other_ptr, _Ref_count_base *_Other_rep, bool _Throw)
; 413  : 		{	// take _Other_ptr through _Other_rep from weak_ptr if not expired
; 414  : 			// otherwise, leave in default state if !_Throw,
; 415  : 			// otherwise throw exception
; 416  : 		if (_Other_rep && _Other_rep->_Incref_nz())
; 417  : 			_Reset0(_Other_ptr, _Other_rep);
; 418  : 		else if (_Throw)
; 419  : 			_THROW_NCEE(bad_weak_ptr, 0);
; 420  : 		}
; 421  : 
; 422  : 	void _Reset0(_Ty *_Other_ptr, _Ref_count_base *_Other_rep)
; 423  : 		{	// release resource and take new resource
; 424  : 		if (_Rep != 0)

  0133e	48 8b 5d 80	 mov	 rbx, QWORD PTR $T1[rbp-248]
  01342	48 85 db	 test	 rbx, rbx
  01345	74 1d		 je	 SHORT $LN1681@tick

; 109  : 		}
; 110  : 
; 111  : 	void _Incwref()
; 112  : 		{	// increment weak reference count
; 113  : 		_MT_INCR(_Ignored, _Weaks);
; 114  : 		}
; 115  : 
; 116  : 	void _Decref()
; 117  : 		{	// decrement use count
; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  01347	f0 ff 4b 08	 lock dec DWORD PTR [rbx+8]
  0134b	75 17		 jne	 SHORT $LN1681@tick

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  0134d	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  01350	48 8b cb	 mov	 rcx, rbx
  01353	ff 10		 call	 QWORD PTR [rax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  01355	f0 ff 4b 0c	 lock dec DWORD PTR [rbx+12]
  01359	75 09		 jne	 SHORT $LN1681@tick

; 128  : 			_Delete_this();

  0135b	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  0135e	48 8b cb	 mov	 rcx, rbx
  01361	ff 50 08	 call	 QWORD PTR [rax+8]
$LN1681@tick:

; 425  : 			_Rep->_Decref();
; 426  : 		_Rep = _Other_rep;

  01364	48 89 7d 80	 mov	 QWORD PTR $T1[rbp-248], rdi

; 427  : 		_Ptr = _Other_ptr;

  01368	48 89 74 24 78	 mov	 QWORD PTR $T1[rsp], rsi
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp

; 270  : 	if(chunkMap.find(chunk->pos) != chunkMap.end())

  0136d	48 8d 56 18	 lea	 rdx, QWORD PTR [rsi+24]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree

; 2092 : 		_Nodeptr _Pnode = _Root();

  01371	4c 8b 1d 08 00
	00 00		 mov	 r11, QWORD PTR ?world@GlobalThread@@3VWorld@@A+8
  01378	49 8b 4b 08	 mov	 rcx, QWORD PTR [r11+8]

; 2093 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails

  0137c	4d 8b d3	 mov	 r10, r11

; 2094 : 
; 2095 : 		while (!this->_Isnil(_Pnode))

  0137f	80 79 19 00	 cmp	 BYTE PTR [rcx+25], 0
  01383	75 6f		 jne	 SHORT $LN461@tick
  01385	44 8b 0a	 mov	 r9d, DWORD PTR [rdx]
$LL468@tick:
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp

; 287  : 	if(cp1.x < cp2.x)

  01388	8b 41 20	 mov	 eax, DWORD PTR [rcx+32]
  0138b	41 3b c1	 cmp	 eax, r9d
  0138e	7c 25		 jl	 SHORT $LN1673@tick

; 288  : 	{
; 289  : 		return true;
; 290  : 	}
; 291  : 	else if(cp1.x == cp2.x)

  01390	75 1b		 jne	 SHORT $LN466@tick

; 292  : 	{
; 293  : 		if(cp1.y < cp2.y)

  01392	8b 41 24	 mov	 eax, DWORD PTR [rcx+36]
  01395	44 8b 42 04	 mov	 r8d, DWORD PTR [rdx+4]
  01399	41 3b c0	 cmp	 eax, r8d
  0139c	7c 17		 jl	 SHORT $LN1673@tick

; 294  : 		{
; 295  : 			return true;
; 296  : 		}
; 297  : 		else if(cp1.y == cp2.y)

  0139e	75 0d		 jne	 SHORT $LN466@tick

; 298  : 		{
; 299  : 			return cp1.z < cp2.z;

  013a0	8b 42 08	 mov	 eax, DWORD PTR [rdx+8]
  013a3	39 41 28	 cmp	 DWORD PTR [rcx+40], eax
  013a6	0f 9c c0	 setl	 al
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree

; 2096 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))

  013a9	84 c0		 test	 al, al
  013ab	75 08		 jne	 SHORT $LN1673@tick
$LN466@tick:

; 2098 : 			else
; 2099 : 				{	// _Pnode not less than _Keyval, remember it
; 2100 : 				_Wherenode = _Pnode;

  013ad	4c 8b d1	 mov	 r10, rcx

; 2101 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree

  013b0	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  013b3	eb 04		 jmp	 SHORT $LN465@tick
$LN1673@tick:

; 2097 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree

  013b5	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
$LN465@tick:

; 2094 : 
; 2095 : 		while (!this->_Isnil(_Pnode))

  013b9	80 79 19 00	 cmp	 BYTE PTR [rcx+25], 0
  013bd	74 c9		 je	 SHORT $LL468@tick

; 336  : 		return (this->_Ptr == _Right._Ptr);

  013bf	4d 3b d3	 cmp	 r10, r11

; 1550 : 					? end() : _Where);

  013c2	74 30		 je	 SHORT $LN461@tick
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp

; 287  : 	if(cp1.x < cp2.x)

  013c4	41 8b 42 20	 mov	 eax, DWORD PTR [r10+32]
  013c8	44 3b c8	 cmp	 r9d, eax
  013cb	7c 27		 jl	 SHORT $LN461@tick

; 288  : 	{
; 289  : 		return true;
; 290  : 	}
; 291  : 	else if(cp1.x == cp2.x)

  013cd	75 1b		 jne	 SHORT $LN1674@tick

; 292  : 	{
; 293  : 		if(cp1.y < cp2.y)

  013cf	8b 42 04	 mov	 eax, DWORD PTR [rdx+4]
  013d2	41 8b 4a 24	 mov	 ecx, DWORD PTR [r10+36]
  013d6	3b c1		 cmp	 eax, ecx
  013d8	7c 1a		 jl	 SHORT $LN461@tick

; 294  : 		{
; 295  : 			return true;
; 296  : 		}
; 297  : 		else if(cp1.y == cp2.y)

  013da	75 0e		 jne	 SHORT $LN1674@tick

; 298  : 		{
; 299  : 			return cp1.z < cp2.z;

  013dc	41 8b 42 28	 mov	 eax, DWORD PTR [r10+40]
  013e0	39 42 08	 cmp	 DWORD PTR [rdx+8], eax
  013e3	0f 9c c0	 setl	 al
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree

; 1550 : 					? end() : _Where);

  013e6	84 c0		 test	 al, al
  013e8	75 0a		 jne	 SHORT $LN461@tick
$LN1674@tick:
  013ea	4c 89 55 10	 mov	 QWORD PTR $T12[rbp-256], r10
  013ee	48 8d 45 10	 lea	 rax, QWORD PTR $T12[rbp-256]
  013f2	eb 08		 jmp	 SHORT $LN462@tick
$LN461@tick:

; 44   : 		{	// construct with node pointer _Pnode

  013f4	4c 89 5d 20	 mov	 QWORD PTR $T13[rbp-256], r11

; 1550 : 					? end() : _Where);

  013f8	48 8d 45 20	 lea	 rax, QWORD PTR $T13[rbp-256]
$LN462@tick:

; 336  : 		return (this->_Ptr == _Right._Ptr);

  013fc	4c 39 18	 cmp	 QWORD PTR [rax], r11
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp

; 270  : 	if(chunkMap.find(chunk->pos) != chunkMap.end())

  013ff	74 2d		 je	 SHORT $LN441@tick
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  01401	48 85 ff	 test	 rdi, rdi
  01404	0f 84 a0 00 00
	00		 je	 $LN1682@tick

; 109  : 		}
; 110  : 
; 111  : 	void _Incwref()
; 112  : 		{	// increment weak reference count
; 113  : 		_MT_INCR(_Ignored, _Weaks);
; 114  : 		}
; 115  : 
; 116  : 	void _Decref()
; 117  : 		{	// decrement use count
; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  0140a	f0 ff 4f 08	 lock dec DWORD PTR [rdi+8]
  0140e	0f 85 96 00 00
	00		 jne	 $LN1682@tick

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  01414	48 8b 07	 mov	 rax, QWORD PTR [rdi]
  01417	48 8b cf	 mov	 rcx, rdi
  0141a	ff 10		 call	 QWORD PTR [rax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  0141c	f0 ff 4f 0c	 lock dec DWORD PTR [rdi+12]
  01420	0f 85 84 00 00
	00		 jne	 $LN1682@tick

; 128  : 			_Delete_this();

  01426	48 8b 07	 mov	 rax, QWORD PTR [rdi]
  01429	48 8b cf	 mov	 rcx, rdi
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp

; 272  : 		return false;

  0142c	eb 78		 jmp	 SHORT $LN1694@tick
$LN441@tick:

; 273  : 	}
; 274  : 	
; 275  : 	chunkMap[chunk->pos] = chunk;

  0142e	48 8d 0d 08 00
	00 00		 lea	 rcx, OFFSET FLAT:?world@GlobalThread@@3VWorld@@A+8
  01435	e8 00 00 00 00	 call	 ??A?$map@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@@std@@QEAAAEAV?$shared_ptr@VChunkBase@@@1@AEBVChunkPosition@@@Z ; std::map<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::operator[]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 357  : 		_Reset(_Other._Ptr, _Other._Rep);

  0143a	48 8b 55 80	 mov	 rdx, QWORD PTR $T1[rbp-248]
  0143e	4c 8b 44 24 78	 mov	 r8, QWORD PTR $T1[rsp]

; 358  : 		}
; 359  : 
; 360  : 	template<class _Ty2>
; 361  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, bool _Throw)
; 362  : 		{	// release resource and take ownership from weak_ptr _Other._Ptr
; 363  : 		_Reset(_Other._Ptr, _Other._Rep, _Throw);
; 364  : 		}
; 365  : 
; 366  : 	template<class _Ty2>
; 367  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Static_tag&)
; 368  : 		{	// release resource and take ownership of _Other._Ptr
; 369  : 		_Reset(static_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 370  : 		}
; 371  : 
; 372  : 	template<class _Ty2>
; 373  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Const_tag&)
; 374  : 		{	// release resource and take ownership of _Other._Ptr
; 375  : 		_Reset(const_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 376  : 		}
; 377  : 
; 378  : 	template<class _Ty2>
; 379  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Dynamic_tag&)
; 380  : 		{	// release resource and take ownership of _Other._Ptr
; 381  : 		_Elem *_Ptr = dynamic_cast<_Elem *>(_Other._Ptr);
; 382  : 		if (_Ptr)
; 383  : 			_Reset(_Ptr, _Other._Rep);
; 384  : 		else
; 385  : 			_Reset();
; 386  : 		}
; 387  : 
; 388  : 	template<class _Ty2>
; 389  : 		void _Reset(auto_ptr<_Ty2>&& _Other)
; 390  : 		{	// release resource and take _Other.get()
; 391  : 		_Ty2 *_Px = _Other.get();
; 392  : 		_Reset0(_Px, new _Ref_count<_Elem>(_Px));
; 393  : 		_Other.release();
; 394  : 		_Enable_shared(_Px, _Rep);
; 395  : 		}
; 396  : 
; 397  :  #if _HAS_CPP0X
; 398  : 	template<class _Ty2>
; 399  : 		void _Reset(_Ty *_Ptr, const _Ptr_base<_Ty2>& _Other)
; 400  : 		{	// release resource and alias _Ptr with _Other_rep
; 401  : 		_Reset(_Ptr, _Other._Rep);
; 402  : 		}
; 403  :  #endif /* _HAS_CPP0X */
; 404  : 
; 405  : 	void _Reset(_Ty *_Other_ptr, _Ref_count_base *_Other_rep)
; 406  : 		{	// release resource and take _Other_ptr through _Other_rep
; 407  : 		if (_Other_rep)

  01443	48 85 d2	 test	 rdx, rdx
  01446	74 04		 je	 SHORT $LN591@tick

; 108  : 		_MT_INCR(_Ignored, _Uses);

  01448	f0 ff 42 08	 lock inc DWORD PTR [rdx+8]
$LN591@tick:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility

; 48   : 	_Left = _Move(_Right);

  0144c	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  01450	48 89 4d 30	 mov	 QWORD PTR $T14[rbp-248], rcx

; 49   : 	_Right = _Move(_Tmp);

  01454	48 89 50 08	 mov	 QWORD PTR [rax+8], rdx
  01458	4c 89 00	 mov	 QWORD PTR [rax], r8
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  0145b	48 85 c9	 test	 rcx, rcx
  0145e	74 23		 je	 SHORT $LN622@tick

; 109  : 		}
; 110  : 
; 111  : 	void _Incwref()
; 112  : 		{	// increment weak reference count
; 113  : 		_MT_INCR(_Ignored, _Weaks);
; 114  : 		}
; 115  : 
; 116  : 	void _Decref()
; 117  : 		{	// decrement use count
; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  01460	f0 ff 49 08	 lock dec DWORD PTR [rcx+8]
  01464	75 1d		 jne	 SHORT $LN622@tick

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  01466	48 8b 5d 30	 mov	 rbx, QWORD PTR $T14[rbp-248]
  0146a	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  0146d	48 8b cb	 mov	 rcx, rbx
  01470	ff 10		 call	 QWORD PTR [rax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  01472	f0 ff 4b 0c	 lock dec DWORD PTR [rbx+12]
  01476	75 0b		 jne	 SHORT $LN622@tick

; 128  : 			_Delete_this();

  01478	48 8b 4d 30	 mov	 rcx, QWORD PTR $T14[rbp-248]
  0147c	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  0147f	ff 50 08	 call	 QWORD PTR [rax+8]
  01482	90		 npad	 1
$LN622@tick:

; 345  : 		if (_Rep != 0)

  01483	48 8b 5d 80	 mov	 rbx, QWORD PTR $T1[rbp-248]
  01487	48 85 db	 test	 rbx, rbx
  0148a	74 1e		 je	 SHORT $LN1682@tick

; 109  : 		}
; 110  : 
; 111  : 	void _Incwref()
; 112  : 		{	// increment weak reference count
; 113  : 		_MT_INCR(_Ignored, _Weaks);
; 114  : 		}
; 115  : 
; 116  : 	void _Decref()
; 117  : 		{	// decrement use count
; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  0148c	f0 ff 4b 08	 lock dec DWORD PTR [rbx+8]
  01490	75 18		 jne	 SHORT $LN1682@tick

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  01492	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  01495	48 8b cb	 mov	 rcx, rbx
  01498	ff 10		 call	 QWORD PTR [rax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  0149a	f0 ff 4b 0c	 lock dec DWORD PTR [rbx+12]
  0149e	75 0a		 jne	 SHORT $LN1682@tick

; 128  : 			_Delete_this();

  014a0	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  014a3	48 8b cb	 mov	 rcx, rbx
$LN1694@tick:
  014a6	ff 50 08	 call	 QWORD PTR [rax+8]
  014a9	90		 npad	 1
$LN1682@tick:

; 345  : 		if (_Rep != 0)

  014aa	48 85 ff	 test	 rdi, rdi
  014ad	74 1d		 je	 SHORT $LN1683@tick

; 109  : 		}
; 110  : 
; 111  : 	void _Incwref()
; 112  : 		{	// increment weak reference count
; 113  : 		_MT_INCR(_Ignored, _Weaks);
; 114  : 		}
; 115  : 
; 116  : 	void _Decref()
; 117  : 		{	// decrement use count
; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  014af	f0 ff 4f 08	 lock dec DWORD PTR [rdi+8]
  014b3	75 17		 jne	 SHORT $LN1683@tick

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  014b5	48 8b 07	 mov	 rax, QWORD PTR [rdi]
  014b8	48 8b cf	 mov	 rcx, rdi
  014bb	ff 10		 call	 QWORD PTR [rax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  014bd	f0 ff 4f 0c	 lock dec DWORD PTR [rdi+12]
  014c1	75 09		 jne	 SHORT $LN1683@tick

; 128  : 			_Delete_this();

  014c3	48 8b 07	 mov	 rax, QWORD PTR [rdi]
  014c6	48 8b cf	 mov	 rcx, rdi
  014c9	ff 50 08	 call	 QWORD PTR [rax+8]
$LN1683@tick:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 1382 : 		return (this->_Mysize == 0);

  014cc	48 83 3d 40 00
	00 00 00	 cmp	 QWORD PTR ?world@GlobalThread@@3VWorld@@A+64, 0
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp

; 123  : 	while(!GlobalThread::world.additionQueue.empty())

  014d4	0f 85 96 fd ff
	ff		 jne	 $LL20@tick
$LN19@tick:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 83   : 	return (_Check_C_return(_Mtx_unlock(_Mtx)));

  014da	48 8d 0d 18 00
	00 00		 lea	 rcx, OFFSET FLAT:?world@GlobalThread@@3VWorld@@A+24
  014e1	e8 00 00 00 00	 call	 _Mtx_unlock

; 32   : 	if (_Res != _Thrd_success)

  014e6	85 c0		 test	 eax, eax
  014e8	74 07		 je	 SHORT $LN651@tick

; 33   : 		_Throw_C_error(_Res);

  014ea	8b c8		 mov	 ecx, eax
  014ec	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
$LN651@tick:

; 68   : 	return (_Check_C_return(_Mtx_lock(_Mtx)));

  014f1	48 8d 0d 48 00
	00 00		 lea	 rcx, OFFSET FLAT:?world@GlobalThread@@3VWorld@@A+72
  014f8	e8 00 00 00 00	 call	 _Mtx_lock

; 32   : 	if (_Res != _Thrd_success)

  014fd	85 c0		 test	 eax, eax
  014ff	74 07		 je	 SHORT $LN1601@tick

; 33   : 		_Throw_C_error(_Res);

  01501	8b c8		 mov	 ecx, eax
  01503	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
$LN1601@tick:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 1382 : 		return (this->_Mysize == 0);

  01508	48 83 3d 70 00
	00 00 00	 cmp	 QWORD PTR ?world@GlobalThread@@3VWorld@@A+112, 0
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp

; 132  : 	while(!GlobalThread::world.removalQueue.empty())

  01510	0f 84 22 03 00
	00		 je	 $LN17@tick
  01516	66 66 0f 1f 84
	00 00 00 00 00	 npad	 10
$LL18@tick:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 1426 : 		return (*begin());

  01520	48 8d 95 28 03
	00 00		 lea	 rdx, QWORD PTR $T34[rbp-256]
  01527	48 8d 0d 50 00
	00 00		 lea	 rcx, OFFSET FLAT:?world@GlobalThread@@3VWorld@@A+80
  0152e	e8 00 00 00 00	 call	 ?begin@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@2@XZ ; std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::begin
  01533	48 8b d0	 mov	 rdx, rax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility

; 178  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

  01536	48 8b 00	 mov	 rax, QWORD PTR [rax]
  01539	48 85 c0	 test	 rax, rax
  0153c	75 05		 jne	 SHORT $LN675@tick
  0153e	49 8b c7	 mov	 rax, r15
  01541	eb 03		 jmp	 SHORT $LN676@tick
$LN675@tick:
  01543	48 8b 00	 mov	 rax, QWORD PTR [rax]
$LN676@tick:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 787  : 		return ((_Off / _DEQUESIZ) & (this->_Mapsize - 1));

  01546	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  0154a	48 ff c9	 dec	 rcx
  0154d	48 23 4a 10	 and	 rcx, QWORD PTR [rdx+16]

; 1426 : 		return (*begin());

  01551	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  01555	48 8b 0c c8	 mov	 rcx, QWORD PTR [rax+rcx*8]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 357  : 		_Reset(_Other._Ptr, _Other._Rep);

  01559	4c 8b 71 08	 mov	 r14, QWORD PTR [rcx+8]
  0155d	48 8b 39	 mov	 rdi, QWORD PTR [rcx]

; 358  : 		}
; 359  : 
; 360  : 	template<class _Ty2>
; 361  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, bool _Throw)
; 362  : 		{	// release resource and take ownership from weak_ptr _Other._Ptr
; 363  : 		_Reset(_Other._Ptr, _Other._Rep, _Throw);
; 364  : 		}
; 365  : 
; 366  : 	template<class _Ty2>
; 367  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Static_tag&)
; 368  : 		{	// release resource and take ownership of _Other._Ptr
; 369  : 		_Reset(static_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 370  : 		}
; 371  : 
; 372  : 	template<class _Ty2>
; 373  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Const_tag&)
; 374  : 		{	// release resource and take ownership of _Other._Ptr
; 375  : 		_Reset(const_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 376  : 		}
; 377  : 
; 378  : 	template<class _Ty2>
; 379  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Dynamic_tag&)
; 380  : 		{	// release resource and take ownership of _Other._Ptr
; 381  : 		_Elem *_Ptr = dynamic_cast<_Elem *>(_Other._Ptr);
; 382  : 		if (_Ptr)
; 383  : 			_Reset(_Ptr, _Other._Rep);
; 384  : 		else
; 385  : 			_Reset();
; 386  : 		}
; 387  : 
; 388  : 	template<class _Ty2>
; 389  : 		void _Reset(auto_ptr<_Ty2>&& _Other)
; 390  : 		{	// release resource and take _Other.get()
; 391  : 		_Ty2 *_Px = _Other.get();
; 392  : 		_Reset0(_Px, new _Ref_count<_Elem>(_Px));
; 393  : 		_Other.release();
; 394  : 		_Enable_shared(_Px, _Rep);
; 395  : 		}
; 396  : 
; 397  :  #if _HAS_CPP0X
; 398  : 	template<class _Ty2>
; 399  : 		void _Reset(_Ty *_Ptr, const _Ptr_base<_Ty2>& _Other)
; 400  : 		{	// release resource and alias _Ptr with _Other_rep
; 401  : 		_Reset(_Ptr, _Other._Rep);
; 402  : 		}
; 403  :  #endif /* _HAS_CPP0X */
; 404  : 
; 405  : 	void _Reset(_Ty *_Other_ptr, _Ref_count_base *_Other_rep)
; 406  : 		{	// release resource and take _Other_ptr through _Other_rep
; 407  : 		if (_Other_rep)

  01560	4d 85 f6	 test	 r14, r14
  01563	74 05		 je	 SHORT $LN696@tick

; 108  : 		_MT_INCR(_Ignored, _Uses);

  01565	f0 41 ff 46 08	 lock inc DWORD PTR [r14+8]
$LN696@tick:

; 425  : 			_Rep->_Decref();
; 426  : 		_Rep = _Other_rep;

  0156a	4c 89 b5 b8 00
	00 00		 mov	 QWORD PTR c$22[rbp-248], r14

; 427  : 		_Ptr = _Other_ptr;

  01571	48 89 bd b0 00
	00 00		 mov	 QWORD PTR c$22[rbp-256], rdi
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp

; 80   : 	unloaded = true;

  01578	c6 47 0a 01	 mov	 BYTE PTR [rdi+10], 1
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 1382 : 		return (this->_Mysize == 0);

  0157c	48 83 3d 70 00
	00 00 00	 cmp	 QWORD PTR ?world@GlobalThread@@3VWorld@@A+112, 0

; 1427 : 		}
; 1428 : 
; 1429 : 	const_reference front() const
; 1430 : 		{	// return first element of nonmutable sequence
; 1431 : 		return (*begin());
; 1432 : 		}
; 1433 : 
; 1434 : 	reference back()
; 1435 : 		{	// return last element of mutable sequence
; 1436 : 		return (*(end() - 1));
; 1437 : 		}
; 1438 : 
; 1439 : 	const_reference back() const
; 1440 : 		{	// return last element of nonmutable sequence
; 1441 : 		return (*(end() - 1));
; 1442 : 		}
; 1443 : 
; 1444 : 	void push_front(const value_type& _Val)
; 1445 : 		{	// insert element at beginning
; 1446 : 		this->_Orphan_all();
; 1447 : 		_PUSH_FRONT_BEGIN;
; 1448 : 		this->_Getal().construct(
; 1449 : 			this->_Map[_Block] + _Newoff % _DEQUESIZ, _Val);
; 1450 : 		_PUSH_FRONT_END;
; 1451 : 		}
; 1452 : 
; 1453 : 	void pop_front()
; 1454 : 		{	// erase element at beginning
; 1455 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1456 : 		if (empty())
; 1457 : 			_DEBUG_ERROR("deque empty before pop");
; 1458 : 		else
; 1459 : 			{	// something to erase, do it
; 1460 : 			_Orphan_off(this->_Myoff);
; 1461 : 			size_type _Block = this->_Getblock(this->_Myoff);
; 1462 : 			this->_Getal().destroy(
; 1463 : 				this->_Map[_Block] + this->_Myoff % _DEQUESIZ);
; 1464 : 			if (--this->_Mysize == 0)
; 1465 : 				this->_Myoff = 0;
; 1466 : 			else
; 1467 : 				++this->_Myoff;
; 1468 : 			}
; 1469 : 
; 1470 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1471 : 		if (!empty())

  01584	74 5b		 je	 SHORT $LN707@tick

; 787  : 		return ((_Off / _DEQUESIZ) & (this->_Mapsize - 1));

  01586	48 8b 0d 60 00
	00 00		 mov	 rcx, QWORD PTR ?world@GlobalThread@@3VWorld@@A+96
  0158d	48 ff c9	 dec	 rcx
  01590	48 23 0d 68 00
	00 00		 and	 rcx, QWORD PTR ?world@GlobalThread@@3VWorld@@A+104

; 1472 : 			{	// something to erase, do it
; 1473 : 			size_type _Block = this->_Getblock(this->_Myoff);
; 1474 : 			this->_Getal().destroy(
; 1475 : 				this->_Map[_Block] + this->_Myoff % _DEQUESIZ);

  01597	48 8b 05 58 00
	00 00		 mov	 rax, QWORD PTR ?world@GlobalThread@@3VWorld@@A+88
  0159e	48 8b 0c c8	 mov	 rcx, QWORD PTR [rax+rcx*8]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  015a2	48 8b 59 08	 mov	 rbx, QWORD PTR [rcx+8]
  015a6	48 85 db	 test	 rbx, rbx
  015a9	74 1d		 je	 SHORT $LN1684@tick

; 109  : 		}
; 110  : 
; 111  : 	void _Incwref()
; 112  : 		{	// increment weak reference count
; 113  : 		_MT_INCR(_Ignored, _Weaks);
; 114  : 		}
; 115  : 
; 116  : 	void _Decref()
; 117  : 		{	// decrement use count
; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  015ab	f0 ff 4b 08	 lock dec DWORD PTR [rbx+8]
  015af	75 17		 jne	 SHORT $LN1684@tick

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  015b1	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  015b4	48 8b cb	 mov	 rcx, rbx
  015b7	ff 10		 call	 QWORD PTR [rax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  015b9	f0 ff 4b 0c	 lock dec DWORD PTR [rbx+12]
  015bd	75 09		 jne	 SHORT $LN1684@tick

; 128  : 			_Delete_this();

  015bf	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  015c2	48 8b cb	 mov	 rcx, rbx
  015c5	ff 50 08	 call	 QWORD PTR [rax+8]
$LN1684@tick:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 1476 : 			if (--this->_Mysize == 0)

  015c8	48 ff 0d 70 00
	00 00		 dec	 QWORD PTR ?world@GlobalThread@@3VWorld@@A+112
  015cf	75 09		 jne	 SHORT $LN708@tick

; 1477 : 				this->_Myoff = 0;

  015d1	4c 89 3d 68 00
	00 00		 mov	 QWORD PTR ?world@GlobalThread@@3VWorld@@A+104, r15

; 1478 : 			else

  015d8	eb 07		 jmp	 SHORT $LN707@tick
$LN708@tick:

; 1479 : 				++this->_Myoff;

  015da	48 ff 05 68 00
	00 00		 inc	 QWORD PTR ?world@GlobalThread@@3VWorld@@A+104
$LN707@tick:
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp

; 137  : 		GlobalThread::world.removeChunk(c->pos);

  015e1	44 8b 47 18	 mov	 r8d, DWORD PTR [rdi+24]
  015e5	8b 57 1c	 mov	 edx, DWORD PTR [rdi+28]
  015e8	44 8b 4f 20	 mov	 r9d, DWORD PTR [rdi+32]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree

; 2026 : 		_Nodeptr _Pnode = _Root();

  015ec	4c 8b 15 08 00
	00 00		 mov	 r10, QWORD PTR ?world@GlobalThread@@3VWorld@@A+8
  015f3	49 8b 72 08	 mov	 rsi, QWORD PTR [r10+8]
  015f7	48 8b ce	 mov	 rcx, rsi

; 2027 : 		_Nodeptr _Lonode = this->_Myhead;	// end() if search fails

  015fa	49 8b da	 mov	 rbx, r10

; 2028 : 		_Nodeptr _Hinode = this->_Myhead;	// end() if search fails

  015fd	49 8b fa	 mov	 rdi, r10

; 2029 : 
; 2030 : 		while (!this->_Isnil(_Pnode))

  01600	80 7e 19 00	 cmp	 BYTE PTR [rsi+25], 0
  01604	75 57		 jne	 SHORT $LN755@tick
$LL756@tick:
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp

; 287  : 	if(cp1.x < cp2.x)

  01606	8b 41 20	 mov	 eax, DWORD PTR [rcx+32]
  01609	41 3b c0	 cmp	 eax, r8d
  0160c	7c 45		 jl	 SHORT $LN1675@tick

; 288  : 	{
; 289  : 		return true;
; 290  : 	}
; 291  : 	else if(cp1.x == cp2.x)

  0160e	75 14		 jne	 SHORT $LN754@tick

; 292  : 	{
; 293  : 		if(cp1.y < cp2.y)

  01610	8b 41 24	 mov	 eax, DWORD PTR [rcx+36]
  01613	3b c2		 cmp	 eax, edx
  01615	7c 3c		 jl	 SHORT $LN1675@tick

; 294  : 		{
; 295  : 			return true;
; 296  : 		}
; 297  : 		else if(cp1.y == cp2.y)

  01617	75 0b		 jne	 SHORT $LN754@tick

; 298  : 		{
; 299  : 			return cp1.z < cp2.z;

  01619	44 39 49 28	 cmp	 DWORD PTR [rcx+40], r9d
  0161d	0f 9c c0	 setl	 al
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree

; 2031 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))

  01620	84 c0		 test	 al, al
  01622	75 2f		 jne	 SHORT $LN1675@tick
$LN754@tick:

; 2036 : 						&& _DEBUG_LT_PRED(this->_Getcomp(), _Keyval,

  01624	80 7f 19 00	 cmp	 BYTE PTR [rdi+25], 0
  01628	74 21		 je	 SHORT $LN752@tick
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp

; 287  : 	if(cp1.x < cp2.x)

  0162a	8b 41 20	 mov	 eax, DWORD PTR [rcx+32]
  0162d	44 3b c0	 cmp	 r8d, eax
  01630	7c 16		 jl	 SHORT $LN1676@tick

; 288  : 	{
; 289  : 		return true;
; 290  : 	}
; 291  : 	else if(cp1.x == cp2.x)

  01632	75 17		 jne	 SHORT $LN752@tick

; 292  : 	{
; 293  : 		if(cp1.y < cp2.y)

  01634	8b 41 24	 mov	 eax, DWORD PTR [rcx+36]
  01637	3b d0		 cmp	 edx, eax
  01639	7c 0d		 jl	 SHORT $LN1676@tick

; 294  : 		{
; 295  : 			return true;
; 296  : 		}
; 297  : 		else if(cp1.y == cp2.y)

  0163b	75 0e		 jne	 SHORT $LN752@tick

; 298  : 		{
; 299  : 			return cp1.z < cp2.z;

  0163d	44 3b 49 28	 cmp	 r9d, DWORD PTR [rcx+40]
  01641	0f 9c c0	 setl	 al
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree

; 2036 : 						&& _DEBUG_LT_PRED(this->_Getcomp(), _Keyval,

  01644	84 c0		 test	 al, al
  01646	74 03		 je	 SHORT $LN752@tick
$LN1676@tick:

; 2037 : 						 this->_Key(_Pnode)))
; 2038 : 					_Hinode = _Pnode;	// _Pnode greater, remember it

  01648	48 8b f9	 mov	 rdi, rcx
$LN752@tick:

; 2039 : 				_Lonode = _Pnode;

  0164b	48 8b d9	 mov	 rbx, rcx

; 2040 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree

  0164e	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  01651	eb 04		 jmp	 SHORT $LN753@tick
$LN1675@tick:

; 2032 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree

  01653	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
$LN753@tick:

; 2029 : 
; 2030 : 		while (!this->_Isnil(_Pnode))

  01657	80 79 19 00	 cmp	 BYTE PTR [rcx+25], 0
  0165b	74 a9		 je	 SHORT $LL756@tick
$LN755@tick:

; 2041 : 				}
; 2042 : 
; 2043 : 		_Pnode = this->_Isnil(_Hinode) ? _Root()
; 2044 : 			: this->_Left(_Hinode);	// continue scan for upper bound

  0165d	80 7f 19 00	 cmp	 BYTE PTR [rdi+25], 0
  01661	48 8b ce	 mov	 rcx, rsi
  01664	75 03		 jne	 SHORT $LN760@tick
  01666	48 8b 0f	 mov	 rcx, QWORD PTR [rdi]
$LN760@tick:

; 2045 : 		while (!this->_Isnil(_Pnode))

  01669	80 79 19 00	 cmp	 BYTE PTR [rcx+25], 0
  0166d	75 31		 jne	 SHORT $LN750@tick
  0166f	90		 npad	 1
$LL751@tick:
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp

; 287  : 	if(cp1.x < cp2.x)

  01670	8b 41 20	 mov	 eax, DWORD PTR [rcx+32]
  01673	44 3b c0	 cmp	 r8d, eax
  01676	7c 1c		 jl	 SHORT $LN1677@tick

; 288  : 	{
; 289  : 		return true;
; 290  : 	}
; 291  : 	else if(cp1.x == cp2.x)

  01678	75 14		 jne	 SHORT $LN749@tick

; 292  : 	{
; 293  : 		if(cp1.y < cp2.y)

  0167a	8b 41 24	 mov	 eax, DWORD PTR [rcx+36]
  0167d	3b d0		 cmp	 edx, eax
  0167f	7c 13		 jl	 SHORT $LN1677@tick

; 294  : 		{
; 295  : 			return true;
; 296  : 		}
; 297  : 		else if(cp1.y == cp2.y)

  01681	75 0b		 jne	 SHORT $LN749@tick

; 298  : 		{
; 299  : 			return cp1.z < cp2.z;

  01683	44 3b 49 28	 cmp	 r9d, DWORD PTR [rcx+40]
  01687	0f 9c c0	 setl	 al
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree

; 2046 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), _Keyval, this->_Key(_Pnode)))

  0168a	84 c0		 test	 al, al
  0168c	75 06		 jne	 SHORT $LN1677@tick
$LN749@tick:

; 2050 : 				}
; 2051 : 			else
; 2052 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree

  0168e	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  01692	eb 06		 jmp	 SHORT $LN748@tick
$LN1677@tick:

; 2047 : 				{	// _Pnode greater than _Keyval, remember it
; 2048 : 				_Hinode = _Pnode;

  01694	48 8b f9	 mov	 rdi, rcx

; 2049 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree

  01697	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
$LN748@tick:

; 2045 : 		while (!this->_Isnil(_Pnode))

  0169a	80 79 19 00	 cmp	 BYTE PTR [rcx+25], 0
  0169e	74 d0		 je	 SHORT $LL751@tick
$LN750@tick:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility

; 831  : 	_Distance2(_First, _Last, _Off, _Iter_cat(_First));

  016a0	48 8b c3	 mov	 rax, rbx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree

; 336  : 		return (this->_Ptr == _Right._Ptr);

  016a3	48 3b df	 cmp	 rbx, rdi
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility

; 798  : 	for (; _First != _Last; ++_First)

  016a6	74 53		 je	 SHORT $LN891@tick
$LL902@tick:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree

; 60   : 		if (_Mytree::_Isnil(_Ptr))

  016a8	80 78 19 00	 cmp	 BYTE PTR [rax+25], 0
  016ac	75 48		 jne	 SHORT $LN1624@tick

; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  :  #if _HAS_CPP0X
; 520  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 521  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 522  : 
; 523  :  #else /* _HAS_CPP0X */
; 524  : 	typedef typename _Alloc::template rebind<_Ty>::other _Alty;
; 525  :  #endif /* _HAS_CPP0X */
; 526  : 
; 527  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 528  : 		_Voidptr;
; 529  : 	typedef _Tree_node<typename _Alty::value_type,
; 530  : 		_Voidptr> _Node;
; 531  : 
; 532  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 533  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 534  : 	typedef _Nodeptr& _Nodepref;
; 535  : 
; 536  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 537  : 		_Tree_simple_types<typename _Alty::value_type>,
; 538  : 		_Tree_iter_types<typename _Alty::value_type,
; 539  : 			typename _Alty::size_type,
; 540  : 			typename _Alty::difference_type,
; 541  : 			typename _Alty::pointer,
; 542  : 			typename _Alty::const_pointer,
; 543  : 			typename _Alty::reference,
; 544  : 			typename _Alty::const_reference,
; 545  : 			_Nodeptr> >::type
; 546  : 		_Val_types;
; 547  : 	};
; 548  : 
; 549  : 		// TEMPLATE CLASS _Tree_val
; 550  : template<class _Val_types>
; 551  : 	class _Tree_val
; 552  : 		: public _Container_base
; 553  : 	{	// base class for tree to hold data
; 554  : public:
; 555  : 	typedef _Tree_val<_Val_types> _Myt;
; 556  : 
; 557  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 558  : 	typedef _Nodeptr& _Nodepref;
; 559  : 
; 560  : 	typedef typename _Val_types::value_type value_type;
; 561  : 	typedef typename _Val_types::size_type size_type;
; 562  : 	typedef typename _Val_types::difference_type difference_type;
; 563  : 	typedef typename _Val_types::pointer pointer;
; 564  : 	typedef typename _Val_types::const_pointer const_pointer;
; 565  : 	typedef typename _Val_types::reference reference;
; 566  : 	typedef typename _Val_types::const_reference const_reference;
; 567  : 
; 568  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 569  : 	typedef _Tree_iterator<_Myt> iterator;
; 570  : 
; 571  : 	_Tree_val()
; 572  : 		{	// initialize data
; 573  : 		this->_Myhead = 0;
; 574  : 		this->_Mysize = 0;
; 575  : 		}
; 576  : 
; 577  : 	enum _Redbl
; 578  : 		{	// colors for link to parent
; 579  : 		_Red, _Black};
; 580  : 
; 581  : 	static char& _Color(_Nodeptr _Pnode)
; 582  : 		{	// return reference to color in node
; 583  : 		return ((char&)_Pnode->_Color);
; 584  : 		}
; 585  : 
; 586  : 	static char& _Isnil(_Nodeptr _Pnode)
; 587  : 		{	// return reference to nil flag in node
; 588  : 		return ((char&)_Pnode->_Isnil);

  016ae	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]

; 61   : 			;	// end() shouldn't be incremented, don't move
; 62   : 		else if (!_Mytree::_Isnil(_Mytree::_Right(_Ptr)))

  016b2	80 79 19 00	 cmp	 BYTE PTR [rcx+25], 0
  016b6	75 1a		 jne	 SHORT $LN1606@tick

; 63   : 			_Ptr = _Mytree::_Min(
; 64   : 				_Mytree::_Right(_Ptr));	// ==> smallest of right subtree

  016b8	48 8b c1	 mov	 rax, rcx

; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  :  #if _HAS_CPP0X
; 520  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 521  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 522  : 
; 523  :  #else /* _HAS_CPP0X */
; 524  : 	typedef typename _Alloc::template rebind<_Ty>::other _Alty;
; 525  :  #endif /* _HAS_CPP0X */
; 526  : 
; 527  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 528  : 		_Voidptr;
; 529  : 	typedef _Tree_node<typename _Alty::value_type,
; 530  : 		_Voidptr> _Node;
; 531  : 
; 532  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 533  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 534  : 	typedef _Nodeptr& _Nodepref;
; 535  : 
; 536  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 537  : 		_Tree_simple_types<typename _Alty::value_type>,
; 538  : 		_Tree_iter_types<typename _Alty::value_type,
; 539  : 			typename _Alty::size_type,
; 540  : 			typename _Alty::difference_type,
; 541  : 			typename _Alty::pointer,
; 542  : 			typename _Alty::const_pointer,
; 543  : 			typename _Alty::reference,
; 544  : 			typename _Alty::const_reference,
; 545  : 			_Nodeptr> >::type
; 546  : 		_Val_types;
; 547  : 	};
; 548  : 
; 549  : 		// TEMPLATE CLASS _Tree_val
; 550  : template<class _Val_types>
; 551  : 	class _Tree_val
; 552  : 		: public _Container_base
; 553  : 	{	// base class for tree to hold data
; 554  : public:
; 555  : 	typedef _Tree_val<_Val_types> _Myt;
; 556  : 
; 557  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 558  : 	typedef _Nodeptr& _Nodepref;
; 559  : 
; 560  : 	typedef typename _Val_types::value_type value_type;
; 561  : 	typedef typename _Val_types::size_type size_type;
; 562  : 	typedef typename _Val_types::difference_type difference_type;
; 563  : 	typedef typename _Val_types::pointer pointer;
; 564  : 	typedef typename _Val_types::const_pointer const_pointer;
; 565  : 	typedef typename _Val_types::reference reference;
; 566  : 	typedef typename _Val_types::const_reference const_reference;
; 567  : 
; 568  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 569  : 	typedef _Tree_iterator<_Myt> iterator;
; 570  : 
; 571  : 	_Tree_val()
; 572  : 		{	// initialize data
; 573  : 		this->_Myhead = 0;
; 574  : 		this->_Mysize = 0;
; 575  : 		}
; 576  : 
; 577  : 	enum _Redbl
; 578  : 		{	// colors for link to parent
; 579  : 		_Red, _Black};
; 580  : 
; 581  : 	static char& _Color(_Nodeptr _Pnode)
; 582  : 		{	// return reference to color in node
; 583  : 		return ((char&)_Pnode->_Color);
; 584  : 		}
; 585  : 
; 586  : 	static char& _Isnil(_Nodeptr _Pnode)
; 587  : 		{	// return reference to nil flag in node
; 588  : 		return ((char&)_Pnode->_Isnil);

  016bb	48 8b 09	 mov	 rcx, QWORD PTR [rcx]

; 589  : 		}
; 590  : 
; 591  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 592  : 		{	// return reference to left pointer in node
; 593  : 		return ((_Nodepref)_Pnode->_Left);
; 594  : 		}
; 595  : 
; 596  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 597  : 		{	// return reference to parent pointer in node
; 598  : 		return ((_Nodepref)_Pnode->_Parent);
; 599  : 		}
; 600  : 
; 601  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 602  : 		{	// return reference to right pointer in node
; 603  : 		return ((_Nodepref)_Pnode->_Right);
; 604  : 		}
; 605  : 
; 606  : 	static reference _Myval(_Nodeptr _Pnode)
; 607  : 		{	// return reference to value in node
; 608  : 		return ((reference)_Pnode->_Myval);
; 609  : 		}
; 610  : 
; 611  : 	static _Nodeptr _Max(_Nodeptr _Pnode)
; 612  : 		{	// return rightmost node in subtree at _Pnode
; 613  : 		while (!_Isnil(_Right(_Pnode)))
; 614  : 			_Pnode = _Right(_Pnode);
; 615  : 		return (_Pnode);
; 616  : 		}
; 617  : 
; 618  : 	static _Nodeptr _Min(_Nodeptr _Pnode)
; 619  : 		{	// return leftmost node in subtree at _Pnode
; 620  : 		while (!_Isnil(_Left(_Pnode)))

  016be	80 79 19 00	 cmp	 BYTE PTR [rcx+25], 0
  016c2	75 32		 jne	 SHORT $LN1624@tick
$LL917@tick:

; 621  : 			_Pnode = _Left(_Pnode);

  016c4	48 8b c1	 mov	 rax, rcx

; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  :  #if _HAS_CPP0X
; 520  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 521  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 522  : 
; 523  :  #else /* _HAS_CPP0X */
; 524  : 	typedef typename _Alloc::template rebind<_Ty>::other _Alty;
; 525  :  #endif /* _HAS_CPP0X */
; 526  : 
; 527  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 528  : 		_Voidptr;
; 529  : 	typedef _Tree_node<typename _Alty::value_type,
; 530  : 		_Voidptr> _Node;
; 531  : 
; 532  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 533  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 534  : 	typedef _Nodeptr& _Nodepref;
; 535  : 
; 536  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 537  : 		_Tree_simple_types<typename _Alty::value_type>,
; 538  : 		_Tree_iter_types<typename _Alty::value_type,
; 539  : 			typename _Alty::size_type,
; 540  : 			typename _Alty::difference_type,
; 541  : 			typename _Alty::pointer,
; 542  : 			typename _Alty::const_pointer,
; 543  : 			typename _Alty::reference,
; 544  : 			typename _Alty::const_reference,
; 545  : 			_Nodeptr> >::type
; 546  : 		_Val_types;
; 547  : 	};
; 548  : 
; 549  : 		// TEMPLATE CLASS _Tree_val
; 550  : template<class _Val_types>
; 551  : 	class _Tree_val
; 552  : 		: public _Container_base
; 553  : 	{	// base class for tree to hold data
; 554  : public:
; 555  : 	typedef _Tree_val<_Val_types> _Myt;
; 556  : 
; 557  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 558  : 	typedef _Nodeptr& _Nodepref;
; 559  : 
; 560  : 	typedef typename _Val_types::value_type value_type;
; 561  : 	typedef typename _Val_types::size_type size_type;
; 562  : 	typedef typename _Val_types::difference_type difference_type;
; 563  : 	typedef typename _Val_types::pointer pointer;
; 564  : 	typedef typename _Val_types::const_pointer const_pointer;
; 565  : 	typedef typename _Val_types::reference reference;
; 566  : 	typedef typename _Val_types::const_reference const_reference;
; 567  : 
; 568  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 569  : 	typedef _Tree_iterator<_Myt> iterator;
; 570  : 
; 571  : 	_Tree_val()
; 572  : 		{	// initialize data
; 573  : 		this->_Myhead = 0;
; 574  : 		this->_Mysize = 0;
; 575  : 		}
; 576  : 
; 577  : 	enum _Redbl
; 578  : 		{	// colors for link to parent
; 579  : 		_Red, _Black};
; 580  : 
; 581  : 	static char& _Color(_Nodeptr _Pnode)
; 582  : 		{	// return reference to color in node
; 583  : 		return ((char&)_Pnode->_Color);
; 584  : 		}
; 585  : 
; 586  : 	static char& _Isnil(_Nodeptr _Pnode)
; 587  : 		{	// return reference to nil flag in node
; 588  : 		return ((char&)_Pnode->_Isnil);

  016c7	48 8b 09	 mov	 rcx, QWORD PTR [rcx]

; 589  : 		}
; 590  : 
; 591  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 592  : 		{	// return reference to left pointer in node
; 593  : 		return ((_Nodepref)_Pnode->_Left);
; 594  : 		}
; 595  : 
; 596  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 597  : 		{	// return reference to parent pointer in node
; 598  : 		return ((_Nodepref)_Pnode->_Parent);
; 599  : 		}
; 600  : 
; 601  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 602  : 		{	// return reference to right pointer in node
; 603  : 		return ((_Nodepref)_Pnode->_Right);
; 604  : 		}
; 605  : 
; 606  : 	static reference _Myval(_Nodeptr _Pnode)
; 607  : 		{	// return reference to value in node
; 608  : 		return ((reference)_Pnode->_Myval);
; 609  : 		}
; 610  : 
; 611  : 	static _Nodeptr _Max(_Nodeptr _Pnode)
; 612  : 		{	// return rightmost node in subtree at _Pnode
; 613  : 		while (!_Isnil(_Right(_Pnode)))
; 614  : 			_Pnode = _Right(_Pnode);
; 615  : 		return (_Pnode);
; 616  : 		}
; 617  : 
; 618  : 	static _Nodeptr _Min(_Nodeptr _Pnode)
; 619  : 		{	// return leftmost node in subtree at _Pnode
; 620  : 		while (!_Isnil(_Left(_Pnode)))

  016ca	80 79 19 00	 cmp	 BYTE PTR [rcx+25], 0
  016ce	74 f4		 je	 SHORT $LL917@tick

; 65   : 		else

  016d0	eb 24		 jmp	 SHORT $LN1624@tick
$LN1606@tick:

; 66   : 			{	// climb looking for right subtree
; 67   : 			_Nodeptr _Pnode;
; 68   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 69   : 				&& _Ptr == _Mytree::_Right(_Pnode))

  016d2	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  016d6	80 79 19 00	 cmp	 BYTE PTR [rcx+25], 0
  016da	75 17		 jne	 SHORT $LN900@tick
  016dc	0f 1f 40 00	 npad	 4
$LL901@tick:
  016e0	48 3b 41 10	 cmp	 rax, QWORD PTR [rcx+16]
  016e4	75 0d		 jne	 SHORT $LN900@tick

; 70   : 				_Ptr = _Pnode;	// ==> parent while right subtree

  016e6	48 8b c1	 mov	 rax, rcx

; 66   : 			{	// climb looking for right subtree
; 67   : 			_Nodeptr _Pnode;
; 68   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 69   : 				&& _Ptr == _Mytree::_Right(_Pnode))

  016e9	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  016ed	80 79 19 00	 cmp	 BYTE PTR [rcx+25], 0
  016f1	74 ed		 je	 SHORT $LL901@tick
$LN900@tick:

; 71   : 			_Ptr = _Pnode;	// ==> parent (head if end())

  016f3	48 8b c1	 mov	 rax, rcx
$LN1624@tick:

; 336  : 		return (this->_Ptr == _Right._Ptr);

  016f6	48 3b c7	 cmp	 rax, rdi
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility

; 798  : 	for (; _First != _Last; ++_First)

  016f9	75 ad		 jne	 SHORT $LL902@tick
$LN891@tick:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree

; 336  : 		return (this->_Ptr == _Right._Ptr);

  016fb	49 3b 1a	 cmp	 rbx, QWORD PTR [r10]

; 622  : 		return (_Pnode);
; 623  : 		}
; 624  : 
; 625  : 	_Nodeptr _Myhead;	// pointer to head node
; 626  : 	size_type _Mysize;	// number of elements
; 627  : 	};
; 628  : 
; 629  : 		// TEMPLATE CLASS _Tree_alloc
; 630  : template<bool _Al_has_storage,
; 631  : 	class _Alloc_types>
; 632  : 	class _Tree_alloc
; 633  : 		: public _Tree_val<typename _Alloc_types::_Val_types>
; 634  : 	{	// base class for tree to hold allocator with storage
; 635  : public:
; 636  : 	typedef _Tree_alloc<_Al_has_storage, _Alloc_types> _Myt;
; 637  : 	typedef _Tree_val<typename _Alloc_types::_Val_types> _Mybase;
; 638  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 639  : 	typedef typename _Alloc_types::_Alnod_type _Alty;
; 640  : 	typedef typename _Alloc_types::_Node _Node;
; 641  : 	typedef typename _Alloc_types::_Nodeptr _Nodeptr;
; 642  : 
; 643  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 644  : 	_Tree_alloc(const _Alloc& _Al = _Alloc())
; 645  : 		: _Alnod(_Al)
; 646  : 		{	// construct head node, allocator from _Al
; 647  : 		this->_Myhead = _Buyheadnode();
; 648  : 		}
; 649  : 
; 650  : 	~_Tree_alloc() _NOEXCEPT
; 651  : 		{	// destroy head node
; 652  : 		_Freeheadnode(this->_Myhead);
; 653  : 		}
; 654  : 
; 655  : 	void _Change_alloc(const _Alty& _Al)
; 656  : 		{	// replace old allocator
; 657  : 		_Alnod = _Al;
; 658  : 		}
; 659  : 
; 660  : 	void _Swap_alloc(_Myt& _Right)
; 661  : 		{	// swap allocators
; 662  : 		_Swap_adl(_Alnod, _Right._Alnod);
; 663  : 		}
; 664  : 
; 665  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 666  : 	_Tree_alloc(const _Alloc& _Al = _Alloc())
; 667  : 		: _Alnod(_Al)
; 668  : 		{	// construct allocators from _Al
; 669  : 		this->_Myhead = _Buyheadnode();
; 670  : 		_TRY_BEGIN
; 671  : 		_Alloc_proxy();
; 672  : 		_CATCH_ALL
; 673  : 		_Freeheadnode(this->_Myhead);
; 674  : 		_RERAISE;
; 675  : 		_CATCH_END
; 676  : 		}
; 677  : 
; 678  : 	~_Tree_alloc() _NOEXCEPT
; 679  : 		{	// destroy proxy
; 680  : 		_Freeheadnode(this->_Myhead);
; 681  : 		_Free_proxy();
; 682  : 		}
; 683  : 
; 684  : 	void _Change_alloc(const _Alty& _Al)
; 685  : 		{	// replace old allocator
; 686  : 		_Free_proxy();
; 687  : 		_Alnod = _Al;
; 688  : 		_Alloc_proxy();
; 689  : 		}
; 690  : 
; 691  : 	void _Swap_alloc(_Myt& _Right)
; 692  : 		{	// swap allocators
; 693  : 		_Swap_adl(_Alnod, _Right._Alnod);
; 694  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 695  : 		}
; 696  : 
; 697  : 	void _Alloc_proxy()
; 698  : 		{	// construct proxy from _Alnod
; 699  : 		typename _Alty::template rebind<_Container_proxy>::other
; 700  : 			_Alproxy(_Alnod);
; 701  : 		this->_Myproxy = _Alproxy.allocate(1);
; 702  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 703  : 		this->_Myproxy->_Mycont = this;
; 704  : 		}
; 705  : 
; 706  : 	void _Free_proxy()
; 707  : 		{	// destroy proxy
; 708  : 		typename _Alty::template rebind<_Container_proxy>::other
; 709  : 			_Alproxy(_Alnod);
; 710  : 		this->_Orphan_all();
; 711  : 		_Alproxy.destroy(this->_Myproxy);
; 712  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 713  : 		this->_Myproxy = 0;
; 714  : 		}
; 715  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 716  : 
; 717  : 	_Nodeptr _Buyheadnode()
; 718  : 		{	// get head node using current allocator
; 719  : 		_Nodeptr _Pnode = _Alnod.allocate(1);
; 720  : 
; 721  : 		_TRY_BEGIN
; 722  : 		_Alnod.construct(
; 723  : 			_STD addressof(this->_Left(_Pnode)), _Pnode);
; 724  : 		_Alnod.construct(
; 725  : 			_STD addressof(this->_Parent(_Pnode)), _Pnode);
; 726  : 		_Alnod.construct(
; 727  : 			_STD addressof(this->_Right(_Pnode)), _Pnode);
; 728  : 		_CATCH_ALL
; 729  : 		_Alnod.deallocate(_Pnode, 1);
; 730  : 		_RERAISE;
; 731  : 		_CATCH_END
; 732  : 
; 733  : 		this->_Color(_Pnode) = this->_Black;
; 734  : 		this->_Isnil(_Pnode) = true;
; 735  : 		return (_Pnode);
; 736  : 		}
; 737  : 
; 738  : 	void _Freeheadnode(_Nodeptr _Pnode)
; 739  : 		{	// free head node using current allocator
; 740  : 		_Alnod.destroy(
; 741  : 			_STD addressof(this->_Left(_Pnode)));
; 742  : 		_Alnod.destroy(
; 743  : 			_STD addressof(this->_Parent(_Pnode)));
; 744  : 		_Alnod.destroy(
; 745  : 			_STD addressof(this->_Right(_Pnode)));
; 746  : 		_Alnod.deallocate(_Pnode, 1);
; 747  : 		}
; 748  : 
; 749  : 	_Alty& _Getal()
; 750  : 		{	// get reference to allocator
; 751  : 		return (_Alnod);
; 752  : 		}
; 753  : 
; 754  : 	const _Alty& _Getal() const
; 755  : 		{	// get reference to allocator
; 756  : 		return (_Alnod);
; 757  : 		}
; 758  : 
; 759  : 	_Alty _Alnod;	// allocator object for stored elements
; 760  : 	};
; 761  : 
; 762  : 		// TEMPLATE CLASS _Tree_alloc
; 763  : template<class _Alloc_types>
; 764  : 	class _Tree_alloc<false, _Alloc_types>
; 765  : 		: public _Tree_val<typename _Alloc_types::_Val_types>
; 766  : 	{	// base class for tree to hold allocator with no storage
; 767  : public:
; 768  : 	typedef _Tree_alloc<false, _Alloc_types> _Myt;
; 769  : 	typedef _Tree_val<typename _Alloc_types::_Val_types> _Mybase;
; 770  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 771  : 	typedef typename _Alloc_types::_Alnod_type _Alty;
; 772  : 	typedef typename _Alloc_types::_Node _Node;
; 773  : 	typedef typename _Alloc_types::_Nodeptr _Nodeptr;
; 774  : 
; 775  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 776  : 	_Tree_alloc(const _Alloc& = _Alloc())
; 777  : 		{	// construct head node, allocator from _Al
; 778  : 		this->_Myhead = _Buyheadnode();
; 779  : 		}
; 780  : 
; 781  : 	~_Tree_alloc() _NOEXCEPT
; 782  : 		{	// destroy head node
; 783  : 		_Freeheadnode(this->_Myhead);
; 784  : 		}
; 785  : 
; 786  : 	void _Change_alloc(const _Alty&)
; 787  : 		{	// replace old allocator
; 788  : 		}
; 789  : 
; 790  : 	void _Swap_alloc(_Myt&)
; 791  : 		{	// swap allocators
; 792  : 		}
; 793  : 
; 794  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 795  : 	_Tree_alloc(const _Alloc& = _Alloc())
; 796  : 		{	// construct allocators from _Al
; 797  : 		this->_Myhead = _Buyheadnode();
; 798  : 		_TRY_BEGIN
; 799  : 		_Alloc_proxy();
; 800  : 		_CATCH_ALL
; 801  : 		_Freeheadnode(this->_Myhead);
; 802  : 		_RERAISE;
; 803  : 		_CATCH_END
; 804  : 		}
; 805  : 
; 806  : 	~_Tree_alloc() _NOEXCEPT
; 807  : 		{	// destroy proxy
; 808  : 		_Freeheadnode(this->_Myhead);
; 809  : 		_Free_proxy();
; 810  : 		}
; 811  : 
; 812  : 	void _Change_alloc(const _Alty&)
; 813  : 		{	// replace old allocator
; 814  : 		}
; 815  : 
; 816  : 	void _Swap_alloc(_Myt&)
; 817  : 		{	// swap allocators
; 818  : 		}
; 819  : 
; 820  : 	void _Alloc_proxy()
; 821  : 		{	// construct proxy from _Alnod
; 822  : 		typename _Alty::template rebind<_Container_proxy>::other
; 823  : 			_Alproxy(_Getal());
; 824  : 		this->_Myproxy = _Alproxy.allocate(1);
; 825  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 826  : 		this->_Myproxy->_Mycont = this;
; 827  : 		}
; 828  : 
; 829  : 	void _Free_proxy()
; 830  : 		{	// destroy proxy
; 831  : 		typename _Alty::template rebind<_Container_proxy>::other
; 832  : 			_Alproxy(_Getal());
; 833  : 		this->_Orphan_all();
; 834  : 		_Alproxy.destroy(this->_Myproxy);
; 835  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 836  : 		this->_Myproxy = 0;
; 837  : 		}
; 838  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 839  : 
; 840  : 	_Nodeptr _Buyheadnode()
; 841  : 		{	// get head node using current allocator
; 842  : 		_Nodeptr _Pnode = this->_Getal().allocate(1);
; 843  : 
; 844  : 		_TRY_BEGIN
; 845  : 		this->_Getal().construct(
; 846  : 			_STD addressof(this->_Left(_Pnode)), _Pnode);
; 847  : 		this->_Getal().construct(
; 848  : 			_STD addressof(this->_Parent(_Pnode)), _Pnode);
; 849  : 		this->_Getal().construct(
; 850  : 			_STD addressof(this->_Right(_Pnode)), _Pnode);
; 851  : 		_CATCH_ALL
; 852  : 		this->_Getal().deallocate(_Pnode, 1);
; 853  : 		_RERAISE;
; 854  : 		_CATCH_END
; 855  : 
; 856  : 		this->_Color(_Pnode) = this->_Black;
; 857  : 		this->_Isnil(_Pnode) = true;
; 858  : 		return (_Pnode);
; 859  : 		}
; 860  : 
; 861  : 	void _Freeheadnode(_Nodeptr _Pnode)
; 862  : 		{	// free head node using current allocator
; 863  : 		this->_Getal().destroy(
; 864  : 			_STD addressof(this->_Left(_Pnode)));
; 865  : 		this->_Getal().destroy(
; 866  : 			_STD addressof(this->_Parent(_Pnode)));
; 867  : 		this->_Getal().destroy(
; 868  : 			_STD addressof(this->_Right(_Pnode)));
; 869  : 		this->_Getal().deallocate(_Pnode, 1);
; 870  : 		}
; 871  : 
; 872  : 	_Alty _Getal() const
; 873  : 		{	// get allocator
; 874  : 		return (_Alty());
; 875  : 		}
; 876  : 	};
; 877  : 
; 878  : 		// TEMPLATE CLASS _Tree_buy
; 879  : template<class _Ty,
; 880  : 	class _Alloc>
; 881  : 	class _Tree_buy
; 882  : 		: public _Tree_alloc<!is_empty<_Alloc>::value,
; 883  : 			_Tree_base_types<_Ty, _Alloc> >
; 884  : 	{	// base class for tree to hold buynode/freenode functions
; 885  : public:
; 886  : 	typedef _Tree_alloc<!is_empty<_Alloc>::value,
; 887  : 		_Tree_base_types<_Ty, _Alloc> > _Mybase;
; 888  : 	typedef typename _Mybase::_Alty _Alty;
; 889  : 	typedef typename _Mybase::_Nodeptr _Nodeptr;
; 890  : 
; 891  : 	_Tree_buy(const _Alloc& _Al = _Alloc())
; 892  : 		: _Mybase(_Al)
; 893  : 		{	// construct from allocator
; 894  : 		}
; 895  : 
; 896  : 	_Nodeptr _Buynode0()
; 897  : 		{	// allocate a non-value node
; 898  : 		_Nodeptr _Pnode = this->_Getal().allocate(1);
; 899  : 
; 900  : 		_TRY_BEGIN
; 901  : 		this->_Getal().construct(
; 902  : 			_STD addressof(this->_Left(_Pnode)), this->_Myhead);
; 903  : 		this->_Getal().construct(
; 904  : 			_STD addressof(this->_Parent(_Pnode)), this->_Myhead);
; 905  : 		this->_Getal().construct(
; 906  : 			_STD addressof(this->_Right(_Pnode)), this->_Myhead);
; 907  : 		_CATCH_ALL
; 908  : 		this->_Getal().deallocate(_Pnode, 1);
; 909  : 		_RERAISE;
; 910  : 		_CATCH_END
; 911  : 
; 912  : 		return (_Pnode);
; 913  : 		}
; 914  : 
; 915  : 	void _Freenode0(_Nodeptr _Pnode)
; 916  : 		{	// free non-value node using current allocator
; 917  : 		this->_Getal().destroy(
; 918  : 			_STD addressof(this->_Left(_Pnode)));
; 919  : 		this->_Getal().destroy(
; 920  : 			_STD addressof(this->_Parent(_Pnode)));
; 921  : 		this->_Getal().destroy(
; 922  : 			_STD addressof(this->_Right(_Pnode)));
; 923  : 		this->_Getal().deallocate(_Pnode, 1);
; 924  : 		}
; 925  : 
; 926  : #define _TREE_BUYNODE( \
; 927  : 	TEMPLATE_LIST, PADDING_LIST, LIST, COMMA, X1, X2, X3, X4) \
; 928  : 	TEMPLATE_LIST(_CLASS_TYPE) \
; 929  : 		_Nodeptr _Buynode(LIST(_TYPE_REFREF_ARG)) \
; 930  : 		{	/* allocate a node with defaults and set links and value */ \
; 931  : 		_Nodeptr _Pnode = _Buynode0(); \
; 932  : 		this->_Color(_Pnode) = this->_Red; \
; 933  : 		this->_Isnil(_Pnode) = false; \
; 934  : 		_TRY_BEGIN \
; 935  : 		this->_Getal().construct( \
; 936  : 			_STD addressof(this->_Myval(_Pnode)) \
; 937  : 				COMMA LIST(_FORWARD_ARG)); \
; 938  : 		_CATCH_ALL \
; 939  : 		_Freenode0(_Pnode); \
; 940  : 		_RERAISE; \
; 941  : 		_CATCH_END \
; 942  : 		return (_Pnode); \
; 943  : 		}
; 944  : 
; 945  : _VARIADIC_EXPAND_0X(_TREE_BUYNODE, , , , )
; 946  : #undef _TREE_BUYNODE
; 947  : 	};
; 948  : 
; 949  : 		// TEMPLATE CLASS _Tree_comp
; 950  : template<bool _Pr_has_storage,
; 951  : 	class _Traits>
; 952  : 	class _Tree_comp
; 953  : 		: public _Tree_buy<typename _Traits::value_type,
; 954  : 			typename _Traits::allocator_type>
; 955  : 	{	// base class for _Tree to hold ordering predicate with storage
; 956  : public:
; 957  : 	typedef _Tree_comp<_Pr_has_storage, _Traits> _Myt;
; 958  : 	typedef _Tree_buy<typename _Traits::value_type,
; 959  : 		typename _Traits::allocator_type> _Mybase;
; 960  : 
; 961  : 	typedef typename _Traits::allocator_type allocator_type;
; 962  : 	typedef typename _Traits::key_compare key_compare;
; 963  : 
; 964  : 	_Tree_comp(const key_compare& _Parg, const allocator_type& _Al)
; 965  : 		: _Mybase(_Al), comp(_Parg)
; 966  : 		{	// construct ordering predicate
; 967  : 		}
; 968  : 
; 969  : 	key_compare& _Getcomp()
; 970  : 		{	// get reference to ordering predicate
; 971  : 		return (comp);
; 972  : 		}
; 973  : 
; 974  : 	const key_compare& _Getcomp() const
; 975  : 		{	// get reference to ordering predicate
; 976  : 		return (comp);
; 977  : 		}
; 978  : 
; 979  : 	void _Setcomp(const key_compare& _Right)
; 980  : 		{	// copy ordering predicate
; 981  : 		comp = _Right;
; 982  : 		}
; 983  : 
; 984  : 	void _Swapcomp(key_compare& _Right)
; 985  : 		{	// swap ordering predicate
; 986  : 		_Swap_adl(comp, _Right);
; 987  : 		}
; 988  : 
; 989  : 	key_compare comp;
; 990  : 	};
; 991  : 
; 992  : template<class _Traits>
; 993  : 	class _Tree_comp<false, _Traits>
; 994  : 		: public _Tree_buy<typename _Traits::value_type,
; 995  : 			typename _Traits::allocator_type>
; 996  : 	{	// base class for _Tree to hold ordering predicate with no storage
; 997  : public:
; 998  : 	typedef _Tree_comp<false, _Traits> _Myt;
; 999  : 	typedef _Tree_buy<typename _Traits::value_type,
; 1000 : 		typename _Traits::allocator_type> _Mybase;
; 1001 : 
; 1002 : 	typedef typename _Traits::allocator_type allocator_type;
; 1003 : 	typedef typename _Traits::key_compare key_compare;
; 1004 : 
; 1005 : 	_Tree_comp(const key_compare&, const allocator_type& _Al)
; 1006 : 		: _Mybase(_Al)
; 1007 : 		{	// construct ordering predicate
; 1008 : 		}
; 1009 : 
; 1010 : 	key_compare _Getcomp() const
; 1011 : 		{	// get ordering predicate
; 1012 : 		return (key_compare());
; 1013 : 		}
; 1014 : 
; 1015 : 	void _Setcomp(const key_compare&)
; 1016 : 		{	// copy ordering predicate
; 1017 : 		}
; 1018 : 
; 1019 : 	void _Swapcomp(const key_compare&)
; 1020 : 		{	// swap ordering predicate
; 1021 : 		}
; 1022 : 	};
; 1023 : 
; 1024 : 		// TEMPLATE CLASS _Tree
; 1025 : template<class _Traits>
; 1026 : 	class _Tree
; 1027 : 		: public _Tree_comp<
; 1028 : 			!is_empty<typename _Traits::key_compare>::value, _Traits>
; 1029 : 	{	// ordered red-black tree for [multi_]{map set}
; 1030 : public:
; 1031 : 	typedef _Tree<_Traits> _Myt;
; 1032 : 	typedef _Tree_comp<
; 1033 : 		!is_empty<typename _Traits::key_compare>::value, _Traits> _Mybase;
; 1034 : 
; 1035 : 	typedef typename _Traits::key_type key_type;
; 1036 : 	typedef typename _Traits::value_compare value_compare;
; 1037 : 	enum
; 1038 : 		{	// get multi parameter
; 1039 : 		_Multi = _Traits::_Multi};
; 1040 : 
; 1041 : 	typedef typename _Mybase::_Node _Node;
; 1042 : 	typedef typename _Mybase::_Nodeptr _Nodeptr;
; 1043 : 	typedef typename _Mybase::_Alty _Alty;
; 1044 : 
; 1045 : 	typedef typename _Mybase::key_compare key_compare;
; 1046 : 	typedef typename _Mybase::allocator_type allocator_type;
; 1047 : 
; 1048 : 	typedef typename _Mybase::value_type value_type;
; 1049 : 	typedef typename _Mybase::size_type size_type;
; 1050 : 	typedef typename _Mybase::difference_type difference_type;
; 1051 : 	typedef typename _Mybase::pointer pointer;
; 1052 : 	typedef typename _Mybase::const_pointer const_pointer;
; 1053 : 	typedef typename _Mybase::reference reference;
; 1054 : 	typedef typename _Mybase::const_reference const_reference;
; 1055 : 
; 1056 : 	typedef typename _Mybase::const_iterator const_iterator;
; 1057 : 	typedef typename _If<is_same<key_type, value_type>::value,
; 1058 : 		typename _Mybase::const_iterator,
; 1059 : 		typename _Mybase::iterator>::type iterator;
; 1060 : 
; 1061 : 	typedef _STD reverse_iterator<iterator> reverse_iterator;
; 1062 : 	typedef _STD reverse_iterator<const_iterator> const_reverse_iterator;
; 1063 : 
; 1064 : 	typedef pair<iterator, bool> _Pairib;
; 1065 : 	typedef pair<iterator, iterator> _Pairii;
; 1066 : 	typedef pair<const_iterator, const_iterator> _Paircc;
; 1067 : 
; 1068 : 	_Tree(const key_compare& _Parg,
; 1069 : 		const allocator_type& _Al)
; 1070 : 		: _Mybase(_Parg, _Al)
; 1071 : 		{	// construct empty tree
; 1072 : 		}
; 1073 : 
; 1074 : 	_Tree(const value_type *_First, const value_type *_Last,
; 1075 : 		const key_compare& _Parg, const allocator_type& _Al)
; 1076 : 		: _Mybase(_Parg, _Al)
; 1077 : 		{	// construct tree from [_First, _Last) array
; 1078 : 		_TRY_BEGIN
; 1079 : 		insert(_First, _Last);
; 1080 : 		_CATCH_ALL
; 1081 : 		_Tidy();
; 1082 : 		_RERAISE;
; 1083 : 		_CATCH_END
; 1084 : 		}
; 1085 : 
; 1086 : 	_Tree(const _Myt& _Right, const allocator_type& _Al)
; 1087 : 		: _Mybase(_Right.key_comp(), _Al)
; 1088 : 		{	// construct tree by copying _Right, allocator
; 1089 : 		_TRY_BEGIN
; 1090 : 		_Copy(_Right, false_type());
; 1091 : 		_CATCH_ALL
; 1092 : 		_Tidy();
; 1093 : 		_RERAISE;
; 1094 : 		_CATCH_END
; 1095 : 		}
; 1096 : 
; 1097 : 	_Tree(_Myt&& _Right, const allocator_type& _Al)
; 1098 : 		: _Mybase(_Right.key_comp(), _Al)
; 1099 : 		{	// construct tree by moving _Right, allocator
; 1100 : 		if (this->_Getal() != _Right._Getal())
; 1101 : 			_Copy(_Right, true_type());
; 1102 : 		else
; 1103 : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 1104 : 		}
; 1105 : 
; 1106 : 	_Myt& operator=(_Myt&& _Right)
; 1107 : 		{	// assign by moving _Right
; 1108 : 		if (this != &_Right)
; 1109 : 			{	// different, move it
; 1110 : 			clear();
; 1111 : 
; 1112 :  #if _HAS_CPP0X
; 1113 : 			if (this->_Getal() != _Right._Getal()
; 1114 : 				&& _Alty::propagate_on_container_move_assignment::value)
; 1115 : 				this->_Change_alloc(_Right._Getal());
; 1116 :  #endif /* _HAS_CPP0X */
; 1117 : 
; 1118 : 			if (this->_Getal() != _Right._Getal())
; 1119 : 				_Copy(_Right, true_type());
; 1120 : 			else
; 1121 : 				_Assign_rv(_STD forward<_Myt>(_Right));
; 1122 : 			}
; 1123 : 		return (*this);
; 1124 : 		}
; 1125 : 
; 1126 : 	void _Assign_rv(_Myt&& _Right)
; 1127 : 		{	// assign by moving _Right
; 1128 : 		this->_Swap_all(_Right);
; 1129 : 		this->_Swapcomp(_Right._Getcomp());
; 1130 : 		_Swap_adl(this->_Myhead, _Right._Myhead);
; 1131 : 		_STD swap(this->_Mysize, _Right._Mysize);
; 1132 : 		}
; 1133 : 
; 1134 : 	_Pairib insert(value_type&& _Val)
; 1135 : 		{	// try to insert node with value _Val, favoring right side
; 1136 : 		return (_Insert_nohint(false,
; 1137 : 			_STD forward<value_type>(_Val), _Nil_obj));
; 1138 : 		}
; 1139 : 
; 1140 : 	iterator insert(const_iterator _Where, value_type&& _Val)
; 1141 : 		{	// try to insert node with value _Val using _Where as a hint
; 1142 : 		return (_Insert_hint(_Where,
; 1143 : 			_STD forward<value_type>(_Val), _Nil_obj));
; 1144 : 		}
; 1145 : 
; 1146 : 	template<class _Valty>
; 1147 : 		typename enable_if<is_convertible<_Valty, value_type>::value,
; 1148 : 			_Pairib>::type
; 1149 : 		insert(_Valty&& _Val)
; 1150 : 		{	// try to insert node with value _Val, favoring right side
; 1151 : 		_Nodeptr _Newnode = this->_Buynode(_STD forward<_Valty>(_Val));
; 1152 : 		return (_Insert_nohint(false,
; 1153 : 			this->_Myval(_Newnode), _Newnode));
; 1154 : 		}
; 1155 : 
; 1156 : 	template<class _Valty>
; 1157 : 		typename enable_if<is_convertible<_Valty, value_type>::value,
; 1158 : 			iterator>::type
; 1159 : 		insert(const_iterator _Where, _Valty&& _Val)
; 1160 : 		{	// try to insert node with value _Val using _Where as a hint
; 1161 : 		_Nodeptr _Newnode = this->_Buynode(_STD forward<_Valty>(_Val));
; 1162 : 		return (_Insert_hint(_Where,
; 1163 : 			this->_Myval(_Newnode), _Newnode));
; 1164 : 		}
; 1165 : 
; 1166 : #define _TREE_EMPLACE( \
; 1167 : 	TEMPLATE_LIST, PADDING_LIST, LIST, COMMA, X1, X2, X3, X4) \
; 1168 : 	TEMPLATE_LIST(_CLASS_TYPE) \
; 1169 : 		_Pairib emplace(LIST(_TYPE_REFREF_ARG)) \
; 1170 : 		{	/* try to insert value_type(_Val...), favoring right side */ \
; 1171 : 		_Nodeptr _Newnode = this->_Buynode(LIST(_FORWARD_ARG)); \
; 1172 : 		return (_Insert_nohint(false, \
; 1173 : 			this->_Myval(_Newnode), _Newnode)); \
; 1174 : 		} \
; 1175 : 	TEMPLATE_LIST(_CLASS_TYPE) \
; 1176 : 		iterator emplace_hint(const_iterator _Where \
; 1177 : 			COMMA LIST(_TYPE_REFREF_ARG)) \
; 1178 : 		{	/* insert value_type(_Val...) at _Where */ \
; 1179 : 		_Nodeptr _Newnode = this->_Buynode(LIST(_FORWARD_ARG)); \
; 1180 : 		return (_Insert_hint(_Where, \
; 1181 : 			this->_Myval(_Newnode), _Newnode)); \
; 1182 : 		}
; 1183 : 
; 1184 : _VARIADIC_EXPAND_0X(_TREE_EMPLACE, , , , )
; 1185 : #undef _TREE_EMPLACE
; 1186 : 
; 1187 : 	~_Tree() _NOEXCEPT
; 1188 : 		{	// destroy tree
; 1189 : 		_Tidy();
; 1190 : 		}
; 1191 : 
; 1192 : 	_Myt& operator=(const _Myt& _Right)
; 1193 : 		{	// replace contents from _Right
; 1194 : 		if (this != &_Right)
; 1195 : 			{	// different, assign it
; 1196 :  #if _HAS_CPP0X
; 1197 : 			clear();
; 1198 : 			if (this->_Getal() != _Right._Getal()
; 1199 : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 1200 : 				this->_Change_alloc(_Right._Getal());
; 1201 :  #endif /* _HAS_CPP0X */
; 1202 : 
; 1203 : 			this->_Setcomp(_Right._Getcomp());
; 1204 : 			_Copy(_Right, false_type());
; 1205 : 			}
; 1206 : 		return (*this);
; 1207 : 		}
; 1208 : 
; 1209 : 	iterator begin() _NOEXCEPT
; 1210 : 		{	// return iterator for beginning of mutable sequence
; 1211 : 		return (iterator(_Lmost(), this));
; 1212 : 		}
; 1213 : 
; 1214 : 	const_iterator begin() const _NOEXCEPT
; 1215 : 		{	// return iterator for beginning of nonmutable sequence
; 1216 : 		return (const_iterator(_Lmost(), this));
; 1217 : 		}
; 1218 : 
; 1219 : 	iterator end() _NOEXCEPT
; 1220 : 		{	// return iterator for end of mutable sequence
; 1221 : 		return (iterator(this->_Myhead, this));
; 1222 : 		}
; 1223 : 
; 1224 : 	const_iterator end() const _NOEXCEPT
; 1225 : 		{	// return iterator for end of nonmutable sequence
; 1226 : 		return (const_iterator(this->_Myhead, this));
; 1227 : 		}
; 1228 : 
; 1229 : 	reverse_iterator rbegin() _NOEXCEPT
; 1230 : 		{	// return iterator for beginning of reversed mutable sequence
; 1231 : 		return (reverse_iterator(end()));
; 1232 : 		}
; 1233 : 
; 1234 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1235 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1236 : 		return (const_reverse_iterator(end()));
; 1237 : 		}
; 1238 : 
; 1239 : 	reverse_iterator rend() _NOEXCEPT
; 1240 : 		{	// return iterator for end of reversed mutable sequence
; 1241 : 		return (reverse_iterator(begin()));
; 1242 : 		}
; 1243 : 
; 1244 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1245 : 		{	// return iterator for end of reversed nonmutable sequence
; 1246 : 		return (const_reverse_iterator(begin()));
; 1247 : 		}
; 1248 : 
; 1249 :  #if _HAS_CPP0X
; 1250 : 	const_iterator cbegin() const _NOEXCEPT
; 1251 : 		{	// return iterator for beginning of nonmutable sequence
; 1252 : 		return (((const _Myt *)this)->begin());
; 1253 : 		}
; 1254 : 
; 1255 : 	const_iterator cend() const _NOEXCEPT
; 1256 : 		{	// return iterator for end of nonmutable sequence
; 1257 : 		return (((const _Myt *)this)->end());
; 1258 : 		}
; 1259 : 
; 1260 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1261 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1262 : 		return (((const _Myt *)this)->rbegin());
; 1263 : 		}
; 1264 : 
; 1265 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1266 : 		{	// return iterator for end of reversed nonmutable sequence
; 1267 : 		return (((const _Myt *)this)->rend());
; 1268 : 		}
; 1269 :  #endif /* _HAS_CPP0X */
; 1270 : 
; 1271 : 	size_type size() const _NOEXCEPT
; 1272 : 		{	// return length of sequence
; 1273 : 		return (this->_Mysize);
; 1274 : 		}
; 1275 : 
; 1276 : 	size_type max_size() const _NOEXCEPT
; 1277 : 		{	// return maximum possible length of sequence
; 1278 : 		return (this->_Getal().max_size());
; 1279 : 		}
; 1280 : 
; 1281 : 	bool empty() const _NOEXCEPT
; 1282 : 		{	// return true only if sequence is empty
; 1283 : 		return (size() == 0);
; 1284 : 		}
; 1285 : 
; 1286 : 	allocator_type get_allocator() const _NOEXCEPT
; 1287 : 		{	// return allocator object for values
; 1288 : 		return (this->_Getal());
; 1289 : 		}
; 1290 : 
; 1291 : 	key_compare key_comp() const
; 1292 : 		{	// return object for comparing keys
; 1293 : 		return (this->_Getcomp());
; 1294 : 		}
; 1295 : 
; 1296 : 	value_compare value_comp() const
; 1297 : 		{	// return object for comparing values
; 1298 : 		return (value_compare(key_comp()));
; 1299 : 		}
; 1300 : 
; 1301 : 	_Pairib insert(const value_type& _Val)
; 1302 : 		{	// try to insert node with value _Val, favoring right side
; 1303 : 		return (_Insert_nohint(false,
; 1304 : 			_Val, _Nil_obj));
; 1305 : 		}
; 1306 : 
; 1307 : 	iterator insert(const_iterator _Where,
; 1308 : 		const value_type& _Val)
; 1309 : 		{	// try to insert node with value _Val using _Where as a hint
; 1310 : 		return (_Insert_hint(_Where,
; 1311 : 			_Val, _Nil_obj));
; 1312 : 		}
; 1313 : 
; 1314 : 	template<class _Iter>
; 1315 : 		void insert(_Iter _First, _Iter _Last)
; 1316 : 		{	// insert [_First, _Last) one at a time
; 1317 : 		_DEBUG_RANGE(_First, _Last);
; 1318 : 		for (; _First != _Last; ++_First)
; 1319 : 			insert(end(), *_First);
; 1320 : 		}
; 1321 : 
; 1322 : 	iterator erase(const_iterator _Where)
; 1323 : 		{	// erase element at _Where
; 1324 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1325 : 		if (_Where._Getcont() != this || this->_Isnil(_Where._Mynode()))
; 1326 : 			_DEBUG_ERROR("map/set erase iterator outside range");
; 1327 : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase
; 1328 : 		++_Where;	// save successor iterator for return
; 1329 : 		_Orphan_ptr(*this, _Erasednode);
; 1330 : 
; 1331 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1332 : 		if (this->_Isnil(_Where._Mynode()))
; 1333 : 			_Xout_of_range("invalid map/set<T> iterator");
; 1334 : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase
; 1335 : 		++_Where;	// save successor iterator for return
; 1336 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1337 : 
; 1338 : 		_Nodeptr _Fixnode;	// the node to recolor as needed
; 1339 : 		_Nodeptr _Fixnodeparent;	// parent of _Fixnode (which may be nil)
; 1340 : 		_Nodeptr _Pnode = _Erasednode;
; 1341 : 
; 1342 : 		if (this->_Isnil(this->_Left(_Pnode)))
; 1343 : 			_Fixnode = this->_Right(_Pnode);	// stitch up right subtree
; 1344 : 		else if (this->_Isnil(this->_Right(_Pnode)))
; 1345 : 			_Fixnode = this->_Left(_Pnode);	// stitch up left subtree
; 1346 : 		else
; 1347 : 			{	// two subtrees, must lift successor node to replace erased
; 1348 : 			_Pnode = _Where._Mynode();	// _Pnode is successor node
; 1349 : 			_Fixnode = this->_Right(_Pnode);	// _Fixnode is only subtree
; 1350 : 			}
; 1351 : 
; 1352 : 		if (_Pnode == _Erasednode)
; 1353 : 			{	// at most one subtree, relink it
; 1354 : 			_Fixnodeparent = this->_Parent(_Erasednode);
; 1355 : 			if (!this->_Isnil(_Fixnode))
; 1356 : 				this->_Parent(_Fixnode) = _Fixnodeparent;	// link up
; 1357 : 
; 1358 : 			if (_Root() == _Erasednode)
; 1359 : 				_Root() = _Fixnode;	// link down from root
; 1360 : 			else if (this->_Left(_Fixnodeparent) == _Erasednode)
; 1361 : 				this->_Left(_Fixnodeparent) = _Fixnode;	// link down to left
; 1362 : 			else
; 1363 : 				this->_Right(_Fixnodeparent) =
; 1364 : 					_Fixnode;	// link down to right
; 1365 : 
; 1366 : 			if (_Lmost() == _Erasednode)
; 1367 : 				_Lmost() = this->_Isnil(_Fixnode)
; 1368 : 					? _Fixnodeparent	// smallest is parent of erased node
; 1369 : 					: this->_Min(_Fixnode);	// smallest in relinked subtree
; 1370 : 
; 1371 : 			if (_Rmost() == _Erasednode)
; 1372 : 				_Rmost() = this->_Isnil(_Fixnode)
; 1373 : 					? _Fixnodeparent	// largest is parent of erased node
; 1374 : 					: this->_Max(_Fixnode);	// largest in relinked subtree
; 1375 : 			}
; 1376 : 		else
; 1377 : 			{	// erased has two subtrees, _Pnode is successor to erased
; 1378 : 			this->_Parent(this->_Left(_Erasednode)) =
; 1379 : 				_Pnode;	// link left up
; 1380 : 			this->_Left(_Pnode) =
; 1381 : 				this->_Left(_Erasednode);	// link successor down
; 1382 : 
; 1383 : 			if (_Pnode == this->_Right(_Erasednode))
; 1384 : 				_Fixnodeparent = _Pnode;	// successor is next to erased
; 1385 : 			else
; 1386 : 				{	// successor further down, link in place of erased
; 1387 : 				_Fixnodeparent =
; 1388 : 					this->_Parent(_Pnode);	// parent is successor's
; 1389 : 				if (!this->_Isnil(_Fixnode))
; 1390 : 					this->_Parent(_Fixnode) = _Fixnodeparent;	// link fix up
; 1391 : 				this->_Left(_Fixnodeparent) = _Fixnode;	// link fix down
; 1392 : 				this->_Right(_Pnode) =
; 1393 : 					this->_Right(_Erasednode);	// link next down
; 1394 : 				this->_Parent(this->_Right(_Erasednode)) =
; 1395 : 					_Pnode;	// right up
; 1396 : 				}
; 1397 : 
; 1398 : 			if (_Root() == _Erasednode)
; 1399 : 				_Root() = _Pnode;	// link down from root
; 1400 : 			else if (this->_Left(this->_Parent(_Erasednode)) == _Erasednode)
; 1401 : 				this->_Left(this->_Parent(_Erasednode)) =
; 1402 : 					_Pnode;	// link down to left
; 1403 : 			else
; 1404 : 				this->_Right(this->_Parent(_Erasednode)) =
; 1405 : 					_Pnode;	// link down to right
; 1406 : 
; 1407 : 			this->_Parent(_Pnode) =
; 1408 : 				this->_Parent(_Erasednode);	// link successor up
; 1409 : 			_STD swap(this->_Color(_Pnode),
; 1410 : 				this->_Color(_Erasednode));	// recolor it
; 1411 : 			}
; 1412 : 
; 1413 : 		if (this->_Color(_Erasednode) == this->_Black)
; 1414 : 			{	// erasing black link, must recolor/rebalance tree
; 1415 : 			for (; _Fixnode != _Root()
; 1416 : 				&& this->_Color(_Fixnode) == this->_Black;
; 1417 : 				_Fixnodeparent = this->_Parent(_Fixnode))
; 1418 : 				if (_Fixnode == this->_Left(_Fixnodeparent))
; 1419 : 					{	// fixup left subtree
; 1420 : 					_Pnode = this->_Right(_Fixnodeparent);
; 1421 : 					if (this->_Color(_Pnode) == this->_Red)
; 1422 : 						{	// rotate red up from right subtree
; 1423 : 						this->_Color(_Pnode) = this->_Black;
; 1424 : 						this->_Color(_Fixnodeparent) = this->_Red;
; 1425 : 						_Lrotate(_Fixnodeparent);
; 1426 : 						_Pnode = this->_Right(_Fixnodeparent);
; 1427 : 						}
; 1428 : 
; 1429 : 					if (this->_Isnil(_Pnode))
; 1430 : 						_Fixnode = _Fixnodeparent;	// shouldn't happen
; 1431 : 					else if (this->_Color(this->_Left(_Pnode)) == this->_Black
; 1432 : 						&& this->_Color(this->_Right(_Pnode)) == this->_Black)
; 1433 : 						{	// redden right subtree with black children
; 1434 : 						this->_Color(_Pnode) = this->_Red;
; 1435 : 						_Fixnode = _Fixnodeparent;
; 1436 : 						}
; 1437 : 					else
; 1438 : 						{	// must rearrange right subtree
; 1439 : 						if (this->_Color(this->_Right(_Pnode))
; 1440 : 							== this->_Black)
; 1441 : 							{	// rotate red up from left sub-subtree
; 1442 : 							this->_Color(this->_Left(_Pnode)) = this->_Black;
; 1443 : 							this->_Color(_Pnode) = this->_Red;
; 1444 : 							_Rrotate(_Pnode);
; 1445 : 							_Pnode = this->_Right(_Fixnodeparent);
; 1446 : 							}
; 1447 : 
; 1448 : 						this->_Color(_Pnode) = this->_Color(_Fixnodeparent);
; 1449 : 						this->_Color(_Fixnodeparent) = this->_Black;
; 1450 : 						this->_Color(this->_Right(_Pnode)) = this->_Black;
; 1451 : 						_Lrotate(_Fixnodeparent);
; 1452 : 						break;	// tree now recolored/rebalanced
; 1453 : 						}
; 1454 : 					}
; 1455 : 				else
; 1456 : 					{	// fixup right subtree
; 1457 : 					_Pnode = this->_Left(_Fixnodeparent);
; 1458 : 					if (this->_Color(_Pnode) == this->_Red)
; 1459 : 						{	// rotate red up from left subtree
; 1460 : 						this->_Color(_Pnode) = this->_Black;
; 1461 : 						this->_Color(_Fixnodeparent) = this->_Red;
; 1462 : 						_Rrotate(_Fixnodeparent);
; 1463 : 						_Pnode = this->_Left(_Fixnodeparent);
; 1464 : 						}
; 1465 : 
; 1466 : 					if (this->_Isnil(_Pnode))
; 1467 : 						_Fixnode = _Fixnodeparent;	// shouldn't happen
; 1468 : 					else if (this->_Color(this->_Right(_Pnode)) ==
; 1469 : 						this->_Black
; 1470 : 						&& this->_Color(this->_Left(_Pnode)) == this->_Black)
; 1471 : 						{	// redden left subtree with black children
; 1472 : 						this->_Color(_Pnode) = this->_Red;
; 1473 : 						_Fixnode = _Fixnodeparent;
; 1474 : 						}
; 1475 : 					else
; 1476 : 						{	// must rearrange left subtree
; 1477 : 						if (this->_Color(this->_Left(_Pnode)) == this->_Black)
; 1478 : 							{	// rotate red up from right sub-subtree
; 1479 : 							this->_Color(this->_Right(_Pnode)) = this->_Black;
; 1480 : 							this->_Color(_Pnode) = this->_Red;
; 1481 : 							_Lrotate(_Pnode);
; 1482 : 							_Pnode = this->_Left(_Fixnodeparent);
; 1483 : 							}
; 1484 : 
; 1485 : 						this->_Color(_Pnode) = this->_Color(_Fixnodeparent);
; 1486 : 						this->_Color(_Fixnodeparent) = this->_Black;
; 1487 : 						this->_Color(this->_Left(_Pnode)) = this->_Black;
; 1488 : 						_Rrotate(_Fixnodeparent);
; 1489 : 						break;	// tree now recolored/rebalanced
; 1490 : 						}
; 1491 : 					}
; 1492 : 
; 1493 : 			this->_Color(_Fixnode) = this->_Black;	// stopping node is black
; 1494 : 			}
; 1495 : 
; 1496 : 		this->_Getal().destroy(
; 1497 : 			_STD addressof(this->_Myval(_Erasednode)));	// delete erased node
; 1498 : 
; 1499 : 		this->_Getal().deallocate(_Erasednode, 1);
; 1500 : 
; 1501 : 		if (0 < this->_Mysize)
; 1502 : 			--this->_Mysize;
; 1503 : 
; 1504 : 		return (iterator(_Where._Ptr, this));	// return successor iterator
; 1505 : 		}
; 1506 : 
; 1507 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1508 : 		{	// erase [_First, _Last)
; 1509 : 		if (_First == begin() && _Last == end())

  016fe	0f 85 8f 00 00
	00		 jne	 $LN1608@tick

; 336  : 		return (this->_Ptr == _Right._Ptr);

  01704	49 3b fa	 cmp	 rdi, r10

; 622  : 		return (_Pnode);
; 623  : 		}
; 624  : 
; 625  : 	_Nodeptr _Myhead;	// pointer to head node
; 626  : 	size_type _Mysize;	// number of elements
; 627  : 	};
; 628  : 
; 629  : 		// TEMPLATE CLASS _Tree_alloc
; 630  : template<bool _Al_has_storage,
; 631  : 	class _Alloc_types>
; 632  : 	class _Tree_alloc
; 633  : 		: public _Tree_val<typename _Alloc_types::_Val_types>
; 634  : 	{	// base class for tree to hold allocator with storage
; 635  : public:
; 636  : 	typedef _Tree_alloc<_Al_has_storage, _Alloc_types> _Myt;
; 637  : 	typedef _Tree_val<typename _Alloc_types::_Val_types> _Mybase;
; 638  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 639  : 	typedef typename _Alloc_types::_Alnod_type _Alty;
; 640  : 	typedef typename _Alloc_types::_Node _Node;
; 641  : 	typedef typename _Alloc_types::_Nodeptr _Nodeptr;
; 642  : 
; 643  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 644  : 	_Tree_alloc(const _Alloc& _Al = _Alloc())
; 645  : 		: _Alnod(_Al)
; 646  : 		{	// construct head node, allocator from _Al
; 647  : 		this->_Myhead = _Buyheadnode();
; 648  : 		}
; 649  : 
; 650  : 	~_Tree_alloc() _NOEXCEPT
; 651  : 		{	// destroy head node
; 652  : 		_Freeheadnode(this->_Myhead);
; 653  : 		}
; 654  : 
; 655  : 	void _Change_alloc(const _Alty& _Al)
; 656  : 		{	// replace old allocator
; 657  : 		_Alnod = _Al;
; 658  : 		}
; 659  : 
; 660  : 	void _Swap_alloc(_Myt& _Right)
; 661  : 		{	// swap allocators
; 662  : 		_Swap_adl(_Alnod, _Right._Alnod);
; 663  : 		}
; 664  : 
; 665  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 666  : 	_Tree_alloc(const _Alloc& _Al = _Alloc())
; 667  : 		: _Alnod(_Al)
; 668  : 		{	// construct allocators from _Al
; 669  : 		this->_Myhead = _Buyheadnode();
; 670  : 		_TRY_BEGIN
; 671  : 		_Alloc_proxy();
; 672  : 		_CATCH_ALL
; 673  : 		_Freeheadnode(this->_Myhead);
; 674  : 		_RERAISE;
; 675  : 		_CATCH_END
; 676  : 		}
; 677  : 
; 678  : 	~_Tree_alloc() _NOEXCEPT
; 679  : 		{	// destroy proxy
; 680  : 		_Freeheadnode(this->_Myhead);
; 681  : 		_Free_proxy();
; 682  : 		}
; 683  : 
; 684  : 	void _Change_alloc(const _Alty& _Al)
; 685  : 		{	// replace old allocator
; 686  : 		_Free_proxy();
; 687  : 		_Alnod = _Al;
; 688  : 		_Alloc_proxy();
; 689  : 		}
; 690  : 
; 691  : 	void _Swap_alloc(_Myt& _Right)
; 692  : 		{	// swap allocators
; 693  : 		_Swap_adl(_Alnod, _Right._Alnod);
; 694  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 695  : 		}
; 696  : 
; 697  : 	void _Alloc_proxy()
; 698  : 		{	// construct proxy from _Alnod
; 699  : 		typename _Alty::template rebind<_Container_proxy>::other
; 700  : 			_Alproxy(_Alnod);
; 701  : 		this->_Myproxy = _Alproxy.allocate(1);
; 702  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 703  : 		this->_Myproxy->_Mycont = this;
; 704  : 		}
; 705  : 
; 706  : 	void _Free_proxy()
; 707  : 		{	// destroy proxy
; 708  : 		typename _Alty::template rebind<_Container_proxy>::other
; 709  : 			_Alproxy(_Alnod);
; 710  : 		this->_Orphan_all();
; 711  : 		_Alproxy.destroy(this->_Myproxy);
; 712  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 713  : 		this->_Myproxy = 0;
; 714  : 		}
; 715  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 716  : 
; 717  : 	_Nodeptr _Buyheadnode()
; 718  : 		{	// get head node using current allocator
; 719  : 		_Nodeptr _Pnode = _Alnod.allocate(1);
; 720  : 
; 721  : 		_TRY_BEGIN
; 722  : 		_Alnod.construct(
; 723  : 			_STD addressof(this->_Left(_Pnode)), _Pnode);
; 724  : 		_Alnod.construct(
; 725  : 			_STD addressof(this->_Parent(_Pnode)), _Pnode);
; 726  : 		_Alnod.construct(
; 727  : 			_STD addressof(this->_Right(_Pnode)), _Pnode);
; 728  : 		_CATCH_ALL
; 729  : 		_Alnod.deallocate(_Pnode, 1);
; 730  : 		_RERAISE;
; 731  : 		_CATCH_END
; 732  : 
; 733  : 		this->_Color(_Pnode) = this->_Black;
; 734  : 		this->_Isnil(_Pnode) = true;
; 735  : 		return (_Pnode);
; 736  : 		}
; 737  : 
; 738  : 	void _Freeheadnode(_Nodeptr _Pnode)
; 739  : 		{	// free head node using current allocator
; 740  : 		_Alnod.destroy(
; 741  : 			_STD addressof(this->_Left(_Pnode)));
; 742  : 		_Alnod.destroy(
; 743  : 			_STD addressof(this->_Parent(_Pnode)));
; 744  : 		_Alnod.destroy(
; 745  : 			_STD addressof(this->_Right(_Pnode)));
; 746  : 		_Alnod.deallocate(_Pnode, 1);
; 747  : 		}
; 748  : 
; 749  : 	_Alty& _Getal()
; 750  : 		{	// get reference to allocator
; 751  : 		return (_Alnod);
; 752  : 		}
; 753  : 
; 754  : 	const _Alty& _Getal() const
; 755  : 		{	// get reference to allocator
; 756  : 		return (_Alnod);
; 757  : 		}
; 758  : 
; 759  : 	_Alty _Alnod;	// allocator object for stored elements
; 760  : 	};
; 761  : 
; 762  : 		// TEMPLATE CLASS _Tree_alloc
; 763  : template<class _Alloc_types>
; 764  : 	class _Tree_alloc<false, _Alloc_types>
; 765  : 		: public _Tree_val<typename _Alloc_types::_Val_types>
; 766  : 	{	// base class for tree to hold allocator with no storage
; 767  : public:
; 768  : 	typedef _Tree_alloc<false, _Alloc_types> _Myt;
; 769  : 	typedef _Tree_val<typename _Alloc_types::_Val_types> _Mybase;
; 770  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 771  : 	typedef typename _Alloc_types::_Alnod_type _Alty;
; 772  : 	typedef typename _Alloc_types::_Node _Node;
; 773  : 	typedef typename _Alloc_types::_Nodeptr _Nodeptr;
; 774  : 
; 775  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 776  : 	_Tree_alloc(const _Alloc& = _Alloc())
; 777  : 		{	// construct head node, allocator from _Al
; 778  : 		this->_Myhead = _Buyheadnode();
; 779  : 		}
; 780  : 
; 781  : 	~_Tree_alloc() _NOEXCEPT
; 782  : 		{	// destroy head node
; 783  : 		_Freeheadnode(this->_Myhead);
; 784  : 		}
; 785  : 
; 786  : 	void _Change_alloc(const _Alty&)
; 787  : 		{	// replace old allocator
; 788  : 		}
; 789  : 
; 790  : 	void _Swap_alloc(_Myt&)
; 791  : 		{	// swap allocators
; 792  : 		}
; 793  : 
; 794  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 795  : 	_Tree_alloc(const _Alloc& = _Alloc())
; 796  : 		{	// construct allocators from _Al
; 797  : 		this->_Myhead = _Buyheadnode();
; 798  : 		_TRY_BEGIN
; 799  : 		_Alloc_proxy();
; 800  : 		_CATCH_ALL
; 801  : 		_Freeheadnode(this->_Myhead);
; 802  : 		_RERAISE;
; 803  : 		_CATCH_END
; 804  : 		}
; 805  : 
; 806  : 	~_Tree_alloc() _NOEXCEPT
; 807  : 		{	// destroy proxy
; 808  : 		_Freeheadnode(this->_Myhead);
; 809  : 		_Free_proxy();
; 810  : 		}
; 811  : 
; 812  : 	void _Change_alloc(const _Alty&)
; 813  : 		{	// replace old allocator
; 814  : 		}
; 815  : 
; 816  : 	void _Swap_alloc(_Myt&)
; 817  : 		{	// swap allocators
; 818  : 		}
; 819  : 
; 820  : 	void _Alloc_proxy()
; 821  : 		{	// construct proxy from _Alnod
; 822  : 		typename _Alty::template rebind<_Container_proxy>::other
; 823  : 			_Alproxy(_Getal());
; 824  : 		this->_Myproxy = _Alproxy.allocate(1);
; 825  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 826  : 		this->_Myproxy->_Mycont = this;
; 827  : 		}
; 828  : 
; 829  : 	void _Free_proxy()
; 830  : 		{	// destroy proxy
; 831  : 		typename _Alty::template rebind<_Container_proxy>::other
; 832  : 			_Alproxy(_Getal());
; 833  : 		this->_Orphan_all();
; 834  : 		_Alproxy.destroy(this->_Myproxy);
; 835  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 836  : 		this->_Myproxy = 0;
; 837  : 		}
; 838  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 839  : 
; 840  : 	_Nodeptr _Buyheadnode()
; 841  : 		{	// get head node using current allocator
; 842  : 		_Nodeptr _Pnode = this->_Getal().allocate(1);
; 843  : 
; 844  : 		_TRY_BEGIN
; 845  : 		this->_Getal().construct(
; 846  : 			_STD addressof(this->_Left(_Pnode)), _Pnode);
; 847  : 		this->_Getal().construct(
; 848  : 			_STD addressof(this->_Parent(_Pnode)), _Pnode);
; 849  : 		this->_Getal().construct(
; 850  : 			_STD addressof(this->_Right(_Pnode)), _Pnode);
; 851  : 		_CATCH_ALL
; 852  : 		this->_Getal().deallocate(_Pnode, 1);
; 853  : 		_RERAISE;
; 854  : 		_CATCH_END
; 855  : 
; 856  : 		this->_Color(_Pnode) = this->_Black;
; 857  : 		this->_Isnil(_Pnode) = true;
; 858  : 		return (_Pnode);
; 859  : 		}
; 860  : 
; 861  : 	void _Freeheadnode(_Nodeptr _Pnode)
; 862  : 		{	// free head node using current allocator
; 863  : 		this->_Getal().destroy(
; 864  : 			_STD addressof(this->_Left(_Pnode)));
; 865  : 		this->_Getal().destroy(
; 866  : 			_STD addressof(this->_Parent(_Pnode)));
; 867  : 		this->_Getal().destroy(
; 868  : 			_STD addressof(this->_Right(_Pnode)));
; 869  : 		this->_Getal().deallocate(_Pnode, 1);
; 870  : 		}
; 871  : 
; 872  : 	_Alty _Getal() const
; 873  : 		{	// get allocator
; 874  : 		return (_Alty());
; 875  : 		}
; 876  : 	};
; 877  : 
; 878  : 		// TEMPLATE CLASS _Tree_buy
; 879  : template<class _Ty,
; 880  : 	class _Alloc>
; 881  : 	class _Tree_buy
; 882  : 		: public _Tree_alloc<!is_empty<_Alloc>::value,
; 883  : 			_Tree_base_types<_Ty, _Alloc> >
; 884  : 	{	// base class for tree to hold buynode/freenode functions
; 885  : public:
; 886  : 	typedef _Tree_alloc<!is_empty<_Alloc>::value,
; 887  : 		_Tree_base_types<_Ty, _Alloc> > _Mybase;
; 888  : 	typedef typename _Mybase::_Alty _Alty;
; 889  : 	typedef typename _Mybase::_Nodeptr _Nodeptr;
; 890  : 
; 891  : 	_Tree_buy(const _Alloc& _Al = _Alloc())
; 892  : 		: _Mybase(_Al)
; 893  : 		{	// construct from allocator
; 894  : 		}
; 895  : 
; 896  : 	_Nodeptr _Buynode0()
; 897  : 		{	// allocate a non-value node
; 898  : 		_Nodeptr _Pnode = this->_Getal().allocate(1);
; 899  : 
; 900  : 		_TRY_BEGIN
; 901  : 		this->_Getal().construct(
; 902  : 			_STD addressof(this->_Left(_Pnode)), this->_Myhead);
; 903  : 		this->_Getal().construct(
; 904  : 			_STD addressof(this->_Parent(_Pnode)), this->_Myhead);
; 905  : 		this->_Getal().construct(
; 906  : 			_STD addressof(this->_Right(_Pnode)), this->_Myhead);
; 907  : 		_CATCH_ALL
; 908  : 		this->_Getal().deallocate(_Pnode, 1);
; 909  : 		_RERAISE;
; 910  : 		_CATCH_END
; 911  : 
; 912  : 		return (_Pnode);
; 913  : 		}
; 914  : 
; 915  : 	void _Freenode0(_Nodeptr _Pnode)
; 916  : 		{	// free non-value node using current allocator
; 917  : 		this->_Getal().destroy(
; 918  : 			_STD addressof(this->_Left(_Pnode)));
; 919  : 		this->_Getal().destroy(
; 920  : 			_STD addressof(this->_Parent(_Pnode)));
; 921  : 		this->_Getal().destroy(
; 922  : 			_STD addressof(this->_Right(_Pnode)));
; 923  : 		this->_Getal().deallocate(_Pnode, 1);
; 924  : 		}
; 925  : 
; 926  : #define _TREE_BUYNODE( \
; 927  : 	TEMPLATE_LIST, PADDING_LIST, LIST, COMMA, X1, X2, X3, X4) \
; 928  : 	TEMPLATE_LIST(_CLASS_TYPE) \
; 929  : 		_Nodeptr _Buynode(LIST(_TYPE_REFREF_ARG)) \
; 930  : 		{	/* allocate a node with defaults and set links and value */ \
; 931  : 		_Nodeptr _Pnode = _Buynode0(); \
; 932  : 		this->_Color(_Pnode) = this->_Red; \
; 933  : 		this->_Isnil(_Pnode) = false; \
; 934  : 		_TRY_BEGIN \
; 935  : 		this->_Getal().construct( \
; 936  : 			_STD addressof(this->_Myval(_Pnode)) \
; 937  : 				COMMA LIST(_FORWARD_ARG)); \
; 938  : 		_CATCH_ALL \
; 939  : 		_Freenode0(_Pnode); \
; 940  : 		_RERAISE; \
; 941  : 		_CATCH_END \
; 942  : 		return (_Pnode); \
; 943  : 		}
; 944  : 
; 945  : _VARIADIC_EXPAND_0X(_TREE_BUYNODE, , , , )
; 946  : #undef _TREE_BUYNODE
; 947  : 	};
; 948  : 
; 949  : 		// TEMPLATE CLASS _Tree_comp
; 950  : template<bool _Pr_has_storage,
; 951  : 	class _Traits>
; 952  : 	class _Tree_comp
; 953  : 		: public _Tree_buy<typename _Traits::value_type,
; 954  : 			typename _Traits::allocator_type>
; 955  : 	{	// base class for _Tree to hold ordering predicate with storage
; 956  : public:
; 957  : 	typedef _Tree_comp<_Pr_has_storage, _Traits> _Myt;
; 958  : 	typedef _Tree_buy<typename _Traits::value_type,
; 959  : 		typename _Traits::allocator_type> _Mybase;
; 960  : 
; 961  : 	typedef typename _Traits::allocator_type allocator_type;
; 962  : 	typedef typename _Traits::key_compare key_compare;
; 963  : 
; 964  : 	_Tree_comp(const key_compare& _Parg, const allocator_type& _Al)
; 965  : 		: _Mybase(_Al), comp(_Parg)
; 966  : 		{	// construct ordering predicate
; 967  : 		}
; 968  : 
; 969  : 	key_compare& _Getcomp()
; 970  : 		{	// get reference to ordering predicate
; 971  : 		return (comp);
; 972  : 		}
; 973  : 
; 974  : 	const key_compare& _Getcomp() const
; 975  : 		{	// get reference to ordering predicate
; 976  : 		return (comp);
; 977  : 		}
; 978  : 
; 979  : 	void _Setcomp(const key_compare& _Right)
; 980  : 		{	// copy ordering predicate
; 981  : 		comp = _Right;
; 982  : 		}
; 983  : 
; 984  : 	void _Swapcomp(key_compare& _Right)
; 985  : 		{	// swap ordering predicate
; 986  : 		_Swap_adl(comp, _Right);
; 987  : 		}
; 988  : 
; 989  : 	key_compare comp;
; 990  : 	};
; 991  : 
; 992  : template<class _Traits>
; 993  : 	class _Tree_comp<false, _Traits>
; 994  : 		: public _Tree_buy<typename _Traits::value_type,
; 995  : 			typename _Traits::allocator_type>
; 996  : 	{	// base class for _Tree to hold ordering predicate with no storage
; 997  : public:
; 998  : 	typedef _Tree_comp<false, _Traits> _Myt;
; 999  : 	typedef _Tree_buy<typename _Traits::value_type,
; 1000 : 		typename _Traits::allocator_type> _Mybase;
; 1001 : 
; 1002 : 	typedef typename _Traits::allocator_type allocator_type;
; 1003 : 	typedef typename _Traits::key_compare key_compare;
; 1004 : 
; 1005 : 	_Tree_comp(const key_compare&, const allocator_type& _Al)
; 1006 : 		: _Mybase(_Al)
; 1007 : 		{	// construct ordering predicate
; 1008 : 		}
; 1009 : 
; 1010 : 	key_compare _Getcomp() const
; 1011 : 		{	// get ordering predicate
; 1012 : 		return (key_compare());
; 1013 : 		}
; 1014 : 
; 1015 : 	void _Setcomp(const key_compare&)
; 1016 : 		{	// copy ordering predicate
; 1017 : 		}
; 1018 : 
; 1019 : 	void _Swapcomp(const key_compare&)
; 1020 : 		{	// swap ordering predicate
; 1021 : 		}
; 1022 : 	};
; 1023 : 
; 1024 : 		// TEMPLATE CLASS _Tree
; 1025 : template<class _Traits>
; 1026 : 	class _Tree
; 1027 : 		: public _Tree_comp<
; 1028 : 			!is_empty<typename _Traits::key_compare>::value, _Traits>
; 1029 : 	{	// ordered red-black tree for [multi_]{map set}
; 1030 : public:
; 1031 : 	typedef _Tree<_Traits> _Myt;
; 1032 : 	typedef _Tree_comp<
; 1033 : 		!is_empty<typename _Traits::key_compare>::value, _Traits> _Mybase;
; 1034 : 
; 1035 : 	typedef typename _Traits::key_type key_type;
; 1036 : 	typedef typename _Traits::value_compare value_compare;
; 1037 : 	enum
; 1038 : 		{	// get multi parameter
; 1039 : 		_Multi = _Traits::_Multi};
; 1040 : 
; 1041 : 	typedef typename _Mybase::_Node _Node;
; 1042 : 	typedef typename _Mybase::_Nodeptr _Nodeptr;
; 1043 : 	typedef typename _Mybase::_Alty _Alty;
; 1044 : 
; 1045 : 	typedef typename _Mybase::key_compare key_compare;
; 1046 : 	typedef typename _Mybase::allocator_type allocator_type;
; 1047 : 
; 1048 : 	typedef typename _Mybase::value_type value_type;
; 1049 : 	typedef typename _Mybase::size_type size_type;
; 1050 : 	typedef typename _Mybase::difference_type difference_type;
; 1051 : 	typedef typename _Mybase::pointer pointer;
; 1052 : 	typedef typename _Mybase::const_pointer const_pointer;
; 1053 : 	typedef typename _Mybase::reference reference;
; 1054 : 	typedef typename _Mybase::const_reference const_reference;
; 1055 : 
; 1056 : 	typedef typename _Mybase::const_iterator const_iterator;
; 1057 : 	typedef typename _If<is_same<key_type, value_type>::value,
; 1058 : 		typename _Mybase::const_iterator,
; 1059 : 		typename _Mybase::iterator>::type iterator;
; 1060 : 
; 1061 : 	typedef _STD reverse_iterator<iterator> reverse_iterator;
; 1062 : 	typedef _STD reverse_iterator<const_iterator> const_reverse_iterator;
; 1063 : 
; 1064 : 	typedef pair<iterator, bool> _Pairib;
; 1065 : 	typedef pair<iterator, iterator> _Pairii;
; 1066 : 	typedef pair<const_iterator, const_iterator> _Paircc;
; 1067 : 
; 1068 : 	_Tree(const key_compare& _Parg,
; 1069 : 		const allocator_type& _Al)
; 1070 : 		: _Mybase(_Parg, _Al)
; 1071 : 		{	// construct empty tree
; 1072 : 		}
; 1073 : 
; 1074 : 	_Tree(const value_type *_First, const value_type *_Last,
; 1075 : 		const key_compare& _Parg, const allocator_type& _Al)
; 1076 : 		: _Mybase(_Parg, _Al)
; 1077 : 		{	// construct tree from [_First, _Last) array
; 1078 : 		_TRY_BEGIN
; 1079 : 		insert(_First, _Last);
; 1080 : 		_CATCH_ALL
; 1081 : 		_Tidy();
; 1082 : 		_RERAISE;
; 1083 : 		_CATCH_END
; 1084 : 		}
; 1085 : 
; 1086 : 	_Tree(const _Myt& _Right, const allocator_type& _Al)
; 1087 : 		: _Mybase(_Right.key_comp(), _Al)
; 1088 : 		{	// construct tree by copying _Right, allocator
; 1089 : 		_TRY_BEGIN
; 1090 : 		_Copy(_Right, false_type());
; 1091 : 		_CATCH_ALL
; 1092 : 		_Tidy();
; 1093 : 		_RERAISE;
; 1094 : 		_CATCH_END
; 1095 : 		}
; 1096 : 
; 1097 : 	_Tree(_Myt&& _Right, const allocator_type& _Al)
; 1098 : 		: _Mybase(_Right.key_comp(), _Al)
; 1099 : 		{	// construct tree by moving _Right, allocator
; 1100 : 		if (this->_Getal() != _Right._Getal())
; 1101 : 			_Copy(_Right, true_type());
; 1102 : 		else
; 1103 : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 1104 : 		}
; 1105 : 
; 1106 : 	_Myt& operator=(_Myt&& _Right)
; 1107 : 		{	// assign by moving _Right
; 1108 : 		if (this != &_Right)
; 1109 : 			{	// different, move it
; 1110 : 			clear();
; 1111 : 
; 1112 :  #if _HAS_CPP0X
; 1113 : 			if (this->_Getal() != _Right._Getal()
; 1114 : 				&& _Alty::propagate_on_container_move_assignment::value)
; 1115 : 				this->_Change_alloc(_Right._Getal());
; 1116 :  #endif /* _HAS_CPP0X */
; 1117 : 
; 1118 : 			if (this->_Getal() != _Right._Getal())
; 1119 : 				_Copy(_Right, true_type());
; 1120 : 			else
; 1121 : 				_Assign_rv(_STD forward<_Myt>(_Right));
; 1122 : 			}
; 1123 : 		return (*this);
; 1124 : 		}
; 1125 : 
; 1126 : 	void _Assign_rv(_Myt&& _Right)
; 1127 : 		{	// assign by moving _Right
; 1128 : 		this->_Swap_all(_Right);
; 1129 : 		this->_Swapcomp(_Right._Getcomp());
; 1130 : 		_Swap_adl(this->_Myhead, _Right._Myhead);
; 1131 : 		_STD swap(this->_Mysize, _Right._Mysize);
; 1132 : 		}
; 1133 : 
; 1134 : 	_Pairib insert(value_type&& _Val)
; 1135 : 		{	// try to insert node with value _Val, favoring right side
; 1136 : 		return (_Insert_nohint(false,
; 1137 : 			_STD forward<value_type>(_Val), _Nil_obj));
; 1138 : 		}
; 1139 : 
; 1140 : 	iterator insert(const_iterator _Where, value_type&& _Val)
; 1141 : 		{	// try to insert node with value _Val using _Where as a hint
; 1142 : 		return (_Insert_hint(_Where,
; 1143 : 			_STD forward<value_type>(_Val), _Nil_obj));
; 1144 : 		}
; 1145 : 
; 1146 : 	template<class _Valty>
; 1147 : 		typename enable_if<is_convertible<_Valty, value_type>::value,
; 1148 : 			_Pairib>::type
; 1149 : 		insert(_Valty&& _Val)
; 1150 : 		{	// try to insert node with value _Val, favoring right side
; 1151 : 		_Nodeptr _Newnode = this->_Buynode(_STD forward<_Valty>(_Val));
; 1152 : 		return (_Insert_nohint(false,
; 1153 : 			this->_Myval(_Newnode), _Newnode));
; 1154 : 		}
; 1155 : 
; 1156 : 	template<class _Valty>
; 1157 : 		typename enable_if<is_convertible<_Valty, value_type>::value,
; 1158 : 			iterator>::type
; 1159 : 		insert(const_iterator _Where, _Valty&& _Val)
; 1160 : 		{	// try to insert node with value _Val using _Where as a hint
; 1161 : 		_Nodeptr _Newnode = this->_Buynode(_STD forward<_Valty>(_Val));
; 1162 : 		return (_Insert_hint(_Where,
; 1163 : 			this->_Myval(_Newnode), _Newnode));
; 1164 : 		}
; 1165 : 
; 1166 : #define _TREE_EMPLACE( \
; 1167 : 	TEMPLATE_LIST, PADDING_LIST, LIST, COMMA, X1, X2, X3, X4) \
; 1168 : 	TEMPLATE_LIST(_CLASS_TYPE) \
; 1169 : 		_Pairib emplace(LIST(_TYPE_REFREF_ARG)) \
; 1170 : 		{	/* try to insert value_type(_Val...), favoring right side */ \
; 1171 : 		_Nodeptr _Newnode = this->_Buynode(LIST(_FORWARD_ARG)); \
; 1172 : 		return (_Insert_nohint(false, \
; 1173 : 			this->_Myval(_Newnode), _Newnode)); \
; 1174 : 		} \
; 1175 : 	TEMPLATE_LIST(_CLASS_TYPE) \
; 1176 : 		iterator emplace_hint(const_iterator _Where \
; 1177 : 			COMMA LIST(_TYPE_REFREF_ARG)) \
; 1178 : 		{	/* insert value_type(_Val...) at _Where */ \
; 1179 : 		_Nodeptr _Newnode = this->_Buynode(LIST(_FORWARD_ARG)); \
; 1180 : 		return (_Insert_hint(_Where, \
; 1181 : 			this->_Myval(_Newnode), _Newnode)); \
; 1182 : 		}
; 1183 : 
; 1184 : _VARIADIC_EXPAND_0X(_TREE_EMPLACE, , , , )
; 1185 : #undef _TREE_EMPLACE
; 1186 : 
; 1187 : 	~_Tree() _NOEXCEPT
; 1188 : 		{	// destroy tree
; 1189 : 		_Tidy();
; 1190 : 		}
; 1191 : 
; 1192 : 	_Myt& operator=(const _Myt& _Right)
; 1193 : 		{	// replace contents from _Right
; 1194 : 		if (this != &_Right)
; 1195 : 			{	// different, assign it
; 1196 :  #if _HAS_CPP0X
; 1197 : 			clear();
; 1198 : 			if (this->_Getal() != _Right._Getal()
; 1199 : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 1200 : 				this->_Change_alloc(_Right._Getal());
; 1201 :  #endif /* _HAS_CPP0X */
; 1202 : 
; 1203 : 			this->_Setcomp(_Right._Getcomp());
; 1204 : 			_Copy(_Right, false_type());
; 1205 : 			}
; 1206 : 		return (*this);
; 1207 : 		}
; 1208 : 
; 1209 : 	iterator begin() _NOEXCEPT
; 1210 : 		{	// return iterator for beginning of mutable sequence
; 1211 : 		return (iterator(_Lmost(), this));
; 1212 : 		}
; 1213 : 
; 1214 : 	const_iterator begin() const _NOEXCEPT
; 1215 : 		{	// return iterator for beginning of nonmutable sequence
; 1216 : 		return (const_iterator(_Lmost(), this));
; 1217 : 		}
; 1218 : 
; 1219 : 	iterator end() _NOEXCEPT
; 1220 : 		{	// return iterator for end of mutable sequence
; 1221 : 		return (iterator(this->_Myhead, this));
; 1222 : 		}
; 1223 : 
; 1224 : 	const_iterator end() const _NOEXCEPT
; 1225 : 		{	// return iterator for end of nonmutable sequence
; 1226 : 		return (const_iterator(this->_Myhead, this));
; 1227 : 		}
; 1228 : 
; 1229 : 	reverse_iterator rbegin() _NOEXCEPT
; 1230 : 		{	// return iterator for beginning of reversed mutable sequence
; 1231 : 		return (reverse_iterator(end()));
; 1232 : 		}
; 1233 : 
; 1234 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1235 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1236 : 		return (const_reverse_iterator(end()));
; 1237 : 		}
; 1238 : 
; 1239 : 	reverse_iterator rend() _NOEXCEPT
; 1240 : 		{	// return iterator for end of reversed mutable sequence
; 1241 : 		return (reverse_iterator(begin()));
; 1242 : 		}
; 1243 : 
; 1244 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1245 : 		{	// return iterator for end of reversed nonmutable sequence
; 1246 : 		return (const_reverse_iterator(begin()));
; 1247 : 		}
; 1248 : 
; 1249 :  #if _HAS_CPP0X
; 1250 : 	const_iterator cbegin() const _NOEXCEPT
; 1251 : 		{	// return iterator for beginning of nonmutable sequence
; 1252 : 		return (((const _Myt *)this)->begin());
; 1253 : 		}
; 1254 : 
; 1255 : 	const_iterator cend() const _NOEXCEPT
; 1256 : 		{	// return iterator for end of nonmutable sequence
; 1257 : 		return (((const _Myt *)this)->end());
; 1258 : 		}
; 1259 : 
; 1260 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1261 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1262 : 		return (((const _Myt *)this)->rbegin());
; 1263 : 		}
; 1264 : 
; 1265 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1266 : 		{	// return iterator for end of reversed nonmutable sequence
; 1267 : 		return (((const _Myt *)this)->rend());
; 1268 : 		}
; 1269 :  #endif /* _HAS_CPP0X */
; 1270 : 
; 1271 : 	size_type size() const _NOEXCEPT
; 1272 : 		{	// return length of sequence
; 1273 : 		return (this->_Mysize);
; 1274 : 		}
; 1275 : 
; 1276 : 	size_type max_size() const _NOEXCEPT
; 1277 : 		{	// return maximum possible length of sequence
; 1278 : 		return (this->_Getal().max_size());
; 1279 : 		}
; 1280 : 
; 1281 : 	bool empty() const _NOEXCEPT
; 1282 : 		{	// return true only if sequence is empty
; 1283 : 		return (size() == 0);
; 1284 : 		}
; 1285 : 
; 1286 : 	allocator_type get_allocator() const _NOEXCEPT
; 1287 : 		{	// return allocator object for values
; 1288 : 		return (this->_Getal());
; 1289 : 		}
; 1290 : 
; 1291 : 	key_compare key_comp() const
; 1292 : 		{	// return object for comparing keys
; 1293 : 		return (this->_Getcomp());
; 1294 : 		}
; 1295 : 
; 1296 : 	value_compare value_comp() const
; 1297 : 		{	// return object for comparing values
; 1298 : 		return (value_compare(key_comp()));
; 1299 : 		}
; 1300 : 
; 1301 : 	_Pairib insert(const value_type& _Val)
; 1302 : 		{	// try to insert node with value _Val, favoring right side
; 1303 : 		return (_Insert_nohint(false,
; 1304 : 			_Val, _Nil_obj));
; 1305 : 		}
; 1306 : 
; 1307 : 	iterator insert(const_iterator _Where,
; 1308 : 		const value_type& _Val)
; 1309 : 		{	// try to insert node with value _Val using _Where as a hint
; 1310 : 		return (_Insert_hint(_Where,
; 1311 : 			_Val, _Nil_obj));
; 1312 : 		}
; 1313 : 
; 1314 : 	template<class _Iter>
; 1315 : 		void insert(_Iter _First, _Iter _Last)
; 1316 : 		{	// insert [_First, _Last) one at a time
; 1317 : 		_DEBUG_RANGE(_First, _Last);
; 1318 : 		for (; _First != _Last; ++_First)
; 1319 : 			insert(end(), *_First);
; 1320 : 		}
; 1321 : 
; 1322 : 	iterator erase(const_iterator _Where)
; 1323 : 		{	// erase element at _Where
; 1324 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1325 : 		if (_Where._Getcont() != this || this->_Isnil(_Where._Mynode()))
; 1326 : 			_DEBUG_ERROR("map/set erase iterator outside range");
; 1327 : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase
; 1328 : 		++_Where;	// save successor iterator for return
; 1329 : 		_Orphan_ptr(*this, _Erasednode);
; 1330 : 
; 1331 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1332 : 		if (this->_Isnil(_Where._Mynode()))
; 1333 : 			_Xout_of_range("invalid map/set<T> iterator");
; 1334 : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase
; 1335 : 		++_Where;	// save successor iterator for return
; 1336 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1337 : 
; 1338 : 		_Nodeptr _Fixnode;	// the node to recolor as needed
; 1339 : 		_Nodeptr _Fixnodeparent;	// parent of _Fixnode (which may be nil)
; 1340 : 		_Nodeptr _Pnode = _Erasednode;
; 1341 : 
; 1342 : 		if (this->_Isnil(this->_Left(_Pnode)))
; 1343 : 			_Fixnode = this->_Right(_Pnode);	// stitch up right subtree
; 1344 : 		else if (this->_Isnil(this->_Right(_Pnode)))
; 1345 : 			_Fixnode = this->_Left(_Pnode);	// stitch up left subtree
; 1346 : 		else
; 1347 : 			{	// two subtrees, must lift successor node to replace erased
; 1348 : 			_Pnode = _Where._Mynode();	// _Pnode is successor node
; 1349 : 			_Fixnode = this->_Right(_Pnode);	// _Fixnode is only subtree
; 1350 : 			}
; 1351 : 
; 1352 : 		if (_Pnode == _Erasednode)
; 1353 : 			{	// at most one subtree, relink it
; 1354 : 			_Fixnodeparent = this->_Parent(_Erasednode);
; 1355 : 			if (!this->_Isnil(_Fixnode))
; 1356 : 				this->_Parent(_Fixnode) = _Fixnodeparent;	// link up
; 1357 : 
; 1358 : 			if (_Root() == _Erasednode)
; 1359 : 				_Root() = _Fixnode;	// link down from root
; 1360 : 			else if (this->_Left(_Fixnodeparent) == _Erasednode)
; 1361 : 				this->_Left(_Fixnodeparent) = _Fixnode;	// link down to left
; 1362 : 			else
; 1363 : 				this->_Right(_Fixnodeparent) =
; 1364 : 					_Fixnode;	// link down to right
; 1365 : 
; 1366 : 			if (_Lmost() == _Erasednode)
; 1367 : 				_Lmost() = this->_Isnil(_Fixnode)
; 1368 : 					? _Fixnodeparent	// smallest is parent of erased node
; 1369 : 					: this->_Min(_Fixnode);	// smallest in relinked subtree
; 1370 : 
; 1371 : 			if (_Rmost() == _Erasednode)
; 1372 : 				_Rmost() = this->_Isnil(_Fixnode)
; 1373 : 					? _Fixnodeparent	// largest is parent of erased node
; 1374 : 					: this->_Max(_Fixnode);	// largest in relinked subtree
; 1375 : 			}
; 1376 : 		else
; 1377 : 			{	// erased has two subtrees, _Pnode is successor to erased
; 1378 : 			this->_Parent(this->_Left(_Erasednode)) =
; 1379 : 				_Pnode;	// link left up
; 1380 : 			this->_Left(_Pnode) =
; 1381 : 				this->_Left(_Erasednode);	// link successor down
; 1382 : 
; 1383 : 			if (_Pnode == this->_Right(_Erasednode))
; 1384 : 				_Fixnodeparent = _Pnode;	// successor is next to erased
; 1385 : 			else
; 1386 : 				{	// successor further down, link in place of erased
; 1387 : 				_Fixnodeparent =
; 1388 : 					this->_Parent(_Pnode);	// parent is successor's
; 1389 : 				if (!this->_Isnil(_Fixnode))
; 1390 : 					this->_Parent(_Fixnode) = _Fixnodeparent;	// link fix up
; 1391 : 				this->_Left(_Fixnodeparent) = _Fixnode;	// link fix down
; 1392 : 				this->_Right(_Pnode) =
; 1393 : 					this->_Right(_Erasednode);	// link next down
; 1394 : 				this->_Parent(this->_Right(_Erasednode)) =
; 1395 : 					_Pnode;	// right up
; 1396 : 				}
; 1397 : 
; 1398 : 			if (_Root() == _Erasednode)
; 1399 : 				_Root() = _Pnode;	// link down from root
; 1400 : 			else if (this->_Left(this->_Parent(_Erasednode)) == _Erasednode)
; 1401 : 				this->_Left(this->_Parent(_Erasednode)) =
; 1402 : 					_Pnode;	// link down to left
; 1403 : 			else
; 1404 : 				this->_Right(this->_Parent(_Erasednode)) =
; 1405 : 					_Pnode;	// link down to right
; 1406 : 
; 1407 : 			this->_Parent(_Pnode) =
; 1408 : 				this->_Parent(_Erasednode);	// link successor up
; 1409 : 			_STD swap(this->_Color(_Pnode),
; 1410 : 				this->_Color(_Erasednode));	// recolor it
; 1411 : 			}
; 1412 : 
; 1413 : 		if (this->_Color(_Erasednode) == this->_Black)
; 1414 : 			{	// erasing black link, must recolor/rebalance tree
; 1415 : 			for (; _Fixnode != _Root()
; 1416 : 				&& this->_Color(_Fixnode) == this->_Black;
; 1417 : 				_Fixnodeparent = this->_Parent(_Fixnode))
; 1418 : 				if (_Fixnode == this->_Left(_Fixnodeparent))
; 1419 : 					{	// fixup left subtree
; 1420 : 					_Pnode = this->_Right(_Fixnodeparent);
; 1421 : 					if (this->_Color(_Pnode) == this->_Red)
; 1422 : 						{	// rotate red up from right subtree
; 1423 : 						this->_Color(_Pnode) = this->_Black;
; 1424 : 						this->_Color(_Fixnodeparent) = this->_Red;
; 1425 : 						_Lrotate(_Fixnodeparent);
; 1426 : 						_Pnode = this->_Right(_Fixnodeparent);
; 1427 : 						}
; 1428 : 
; 1429 : 					if (this->_Isnil(_Pnode))
; 1430 : 						_Fixnode = _Fixnodeparent;	// shouldn't happen
; 1431 : 					else if (this->_Color(this->_Left(_Pnode)) == this->_Black
; 1432 : 						&& this->_Color(this->_Right(_Pnode)) == this->_Black)
; 1433 : 						{	// redden right subtree with black children
; 1434 : 						this->_Color(_Pnode) = this->_Red;
; 1435 : 						_Fixnode = _Fixnodeparent;
; 1436 : 						}
; 1437 : 					else
; 1438 : 						{	// must rearrange right subtree
; 1439 : 						if (this->_Color(this->_Right(_Pnode))
; 1440 : 							== this->_Black)
; 1441 : 							{	// rotate red up from left sub-subtree
; 1442 : 							this->_Color(this->_Left(_Pnode)) = this->_Black;
; 1443 : 							this->_Color(_Pnode) = this->_Red;
; 1444 : 							_Rrotate(_Pnode);
; 1445 : 							_Pnode = this->_Right(_Fixnodeparent);
; 1446 : 							}
; 1447 : 
; 1448 : 						this->_Color(_Pnode) = this->_Color(_Fixnodeparent);
; 1449 : 						this->_Color(_Fixnodeparent) = this->_Black;
; 1450 : 						this->_Color(this->_Right(_Pnode)) = this->_Black;
; 1451 : 						_Lrotate(_Fixnodeparent);
; 1452 : 						break;	// tree now recolored/rebalanced
; 1453 : 						}
; 1454 : 					}
; 1455 : 				else
; 1456 : 					{	// fixup right subtree
; 1457 : 					_Pnode = this->_Left(_Fixnodeparent);
; 1458 : 					if (this->_Color(_Pnode) == this->_Red)
; 1459 : 						{	// rotate red up from left subtree
; 1460 : 						this->_Color(_Pnode) = this->_Black;
; 1461 : 						this->_Color(_Fixnodeparent) = this->_Red;
; 1462 : 						_Rrotate(_Fixnodeparent);
; 1463 : 						_Pnode = this->_Left(_Fixnodeparent);
; 1464 : 						}
; 1465 : 
; 1466 : 					if (this->_Isnil(_Pnode))
; 1467 : 						_Fixnode = _Fixnodeparent;	// shouldn't happen
; 1468 : 					else if (this->_Color(this->_Right(_Pnode)) ==
; 1469 : 						this->_Black
; 1470 : 						&& this->_Color(this->_Left(_Pnode)) == this->_Black)
; 1471 : 						{	// redden left subtree with black children
; 1472 : 						this->_Color(_Pnode) = this->_Red;
; 1473 : 						_Fixnode = _Fixnodeparent;
; 1474 : 						}
; 1475 : 					else
; 1476 : 						{	// must rearrange left subtree
; 1477 : 						if (this->_Color(this->_Left(_Pnode)) == this->_Black)
; 1478 : 							{	// rotate red up from right sub-subtree
; 1479 : 							this->_Color(this->_Right(_Pnode)) = this->_Black;
; 1480 : 							this->_Color(_Pnode) = this->_Red;
; 1481 : 							_Lrotate(_Pnode);
; 1482 : 							_Pnode = this->_Left(_Fixnodeparent);
; 1483 : 							}
; 1484 : 
; 1485 : 						this->_Color(_Pnode) = this->_Color(_Fixnodeparent);
; 1486 : 						this->_Color(_Fixnodeparent) = this->_Black;
; 1487 : 						this->_Color(this->_Left(_Pnode)) = this->_Black;
; 1488 : 						_Rrotate(_Fixnodeparent);
; 1489 : 						break;	// tree now recolored/rebalanced
; 1490 : 						}
; 1491 : 					}
; 1492 : 
; 1493 : 			this->_Color(_Fixnode) = this->_Black;	// stopping node is black
; 1494 : 			}
; 1495 : 
; 1496 : 		this->_Getal().destroy(
; 1497 : 			_STD addressof(this->_Myval(_Erasednode)));	// delete erased node
; 1498 : 
; 1499 : 		this->_Getal().deallocate(_Erasednode, 1);
; 1500 : 
; 1501 : 		if (0 < this->_Mysize)
; 1502 : 			--this->_Mysize;
; 1503 : 
; 1504 : 		return (iterator(_Where._Ptr, this));	// return successor iterator
; 1505 : 		}
; 1506 : 
; 1507 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1508 : 		{	// erase [_First, _Last)
; 1509 : 		if (_First == begin() && _Last == end())

  01707	0f 85 86 00 00
	00		 jne	 $LN1608@tick

; 2053 : 
; 2054 : 		iterator _First = iterator(_Lonode, this);
; 2055 : 		iterator _Last = iterator(_Hinode, this);
; 2056 : 		return (_Pairii(_First, _Last));
; 2057 : 		}
; 2058 : 
; 2059 : 	void _Erase(_Nodeptr _Rootnode)
; 2060 : 		{	// free entire subtree, recursively
; 2061 : 		for (_Nodeptr _Pnode = _Rootnode;

  0170d	48 8b fe	 mov	 rdi, rsi

; 2062 : 			!this->_Isnil(_Pnode); _Rootnode = _Pnode)

  01710	80 7e 19 00	 cmp	 BYTE PTR [rsi+25], 0
  01714	75 5b		 jne	 SHORT $LN976@tick
  01716	66 66 0f 1f 84
	00 00 00 00 00	 npad	 10
$LL978@tick:

; 2063 : 			{	// free subtrees, then node
; 2064 : 			_Erase(this->_Right(_Pnode));

  01720	48 8b 57 10	 mov	 rdx, QWORD PTR [rdi+16]
  01724	48 8d 0d 08 00
	00 00		 lea	 rcx, OFFSET FLAT:?world@GlobalThread@@3VWorld@@A+8
  0172b	e8 00 00 00 00	 call	 ?_Erase@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAAXPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@Z ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Erase

; 2065 : 			_Pnode = this->_Left(_Pnode);

  01730	48 8b 3f	 mov	 rdi, QWORD PTR [rdi]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  01733	48 8b 5e 38	 mov	 rbx, QWORD PTR [rsi+56]
  01737	48 85 db	 test	 rbx, rbx
  0173a	74 1d		 je	 SHORT $LN1012@tick

; 109  : 		}
; 110  : 
; 111  : 	void _Incwref()
; 112  : 		{	// increment weak reference count
; 113  : 		_MT_INCR(_Ignored, _Weaks);
; 114  : 		}
; 115  : 
; 116  : 	void _Decref()
; 117  : 		{	// decrement use count
; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  0173c	f0 ff 4b 08	 lock dec DWORD PTR [rbx+8]
  01740	75 17		 jne	 SHORT $LN1012@tick

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  01742	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  01745	48 8b cb	 mov	 rcx, rbx
  01748	ff 10		 call	 QWORD PTR [rax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  0174a	f0 ff 4b 0c	 lock dec DWORD PTR [rbx+12]
  0174e	75 09		 jne	 SHORT $LN1012@tick

; 128  : 			_Delete_this();

  01750	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  01753	48 8b cb	 mov	 rcx, rbx
  01756	ff 50 08	 call	 QWORD PTR [rax+8]
$LN1012@tick:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 586  : 		::operator delete(_Ptr);

  01759	48 8b ce	 mov	 rcx, rsi
  0175c	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree

; 2062 : 			!this->_Isnil(_Pnode); _Rootnode = _Pnode)

  01761	48 8b f7	 mov	 rsi, rdi
  01764	80 7f 19 00	 cmp	 BYTE PTR [rdi+25], 0
  01768	74 b6		 je	 SHORT $LL978@tick
  0176a	4c 8b 15 08 00
	00 00		 mov	 r10, QWORD PTR ?world@GlobalThread@@3VWorld@@A+8
$LN976@tick:

; 1518 : 			return (iterator(_First._Ptr, this));
; 1519 : 			}
; 1520 : 		}
; 1521 : 
; 1522 : 	size_type erase(const key_type& _Keyval)
; 1523 : 		{	// erase and count all that match _Keyval
; 1524 : 		_Pairii _Where = equal_range(_Keyval);
; 1525 : 		size_type _Num = 0;
; 1526 : 		_Distance(_Where.first, _Where.second, _Num);
; 1527 : 		erase(_Where.first, _Where.second);
; 1528 : 		return (_Num);
; 1529 : 		}
; 1530 : 
; 1531 : 	void clear() _NOEXCEPT
; 1532 : 		{	// erase all
; 1533 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1534 : 		this->_Orphan_ptr(*this, 0);
; 1535 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1536 : 
; 1537 : 		_Erase(_Root());
; 1538 : 		_Root() = this->_Myhead;

  01771	4d 89 52 08	 mov	 QWORD PTR [r10+8], r10

; 1539 : 		_Lmost() = this->_Myhead;

  01775	48 8b 05 08 00
	00 00		 mov	 rax, QWORD PTR ?world@GlobalThread@@3VWorld@@A+8
  0177c	48 89 00	 mov	 QWORD PTR [rax], rax

; 1540 : 		_Rmost() = this->_Myhead;

  0177f	48 8b 05 08 00
	00 00		 mov	 rax, QWORD PTR ?world@GlobalThread@@3VWorld@@A+8
  01786	48 89 40 10	 mov	 QWORD PTR [rax+16], rax

; 1541 : 		this->_Mysize = 0;

  0178a	4c 89 3d 10 00
	00 00		 mov	 QWORD PTR ?world@GlobalThread@@3VWorld@@A+16, r15

; 1510 : 			{	// erase all
; 1511 : 			clear();
; 1512 : 			return (begin());

  01791	eb 73		 jmp	 SHORT $LN936@tick
$LN1608@tick:

; 336  : 		return (this->_Ptr == _Right._Ptr);

  01793	48 3b df	 cmp	 rbx, rdi

; 1513 : 			}
; 1514 : 		else
; 1515 : 			{	// partial erase, one at a time
; 1516 : 			while (_First != _Last)

  01796	74 6e		 je	 SHORT $LN936@tick
  01798	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL937@tick:

; 72   : 			}
; 73   : 		return (*this);
; 74   : 		}
; 75   : 
; 76   : 	_Myiter operator++(int)
; 77   : 		{	// postincrement
; 78   : 		_Myiter _Tmp = *this;
; 79   : 		++*this;
; 80   : 		return (_Tmp);
; 81   : 		}
; 82   : 
; 83   : 	_Myiter& operator--()
; 84   : 		{	// predecrement
; 85   : 		if (_Mytree::_Isnil(_Ptr))
; 86   : 			_Ptr = _Mytree::_Right(_Ptr);	// end() ==> rightmost
; 87   : 		else if (!_Mytree::_Isnil(_Mytree::_Left(_Ptr)))
; 88   : 			_Ptr = _Mytree::_Max(
; 89   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree
; 90   : 		else
; 91   : 			{	// climb looking for left subtree
; 92   : 			_Nodeptr _Pnode;
; 93   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 94   : 				&& _Ptr == _Mytree::_Left(_Pnode))
; 95   : 				_Ptr = _Pnode;	// ==> parent while left subtree
; 96   : 			if (_Mytree::_Isnil(_Ptr))
; 97   : 				;	// begin() shouldn't be decremented, don't move
; 98   : 			else
; 99   : 				_Ptr = _Pnode;	// ==> parent if not head
; 100  : 			}
; 101  : 		return (*this);
; 102  : 		}
; 103  : 
; 104  : 	_Myiter operator--(int)
; 105  : 		{	// postdecrement
; 106  : 		_Myiter _Tmp = *this;
; 107  : 		--*this;
; 108  : 		return (_Tmp);
; 109  : 		}
; 110  : 
; 111  : 	bool operator==(const _Myiter& _Right) const
; 112  : 		{	// test for iterator equality
; 113  : 		return (_Ptr == _Right._Ptr);
; 114  : 		}
; 115  : 
; 116  : 	bool operator!=(const _Myiter& _Right) const
; 117  : 		{	// test for iterator inequality
; 118  : 		return (!(*this == _Right));
; 119  : 		}
; 120  : 
; 121  : 	_Nodeptr _Mynode() const
; 122  : 		{	// return node pointer
; 123  : 		return (_Ptr);
; 124  : 		}
; 125  : 
; 126  : 	_Nodeptr _Ptr;	// pointer to node
; 127  : 	};
; 128  : 
; 129  : 	// TEMPLATE CLASS _Tree_unchecked_iterator
; 130  : template<class _Mytree>
; 131  : 	class _Tree_unchecked_iterator
; 132  : 		: public _Tree_unchecked_const_iterator<_Mytree>
; 133  : 	{	// unchecked iterator for mutable tree
; 134  : public:
; 135  : 	typedef _Tree_unchecked_iterator<_Mytree> _Myiter;
; 136  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Mybase;
; 137  : 	typedef bidirectional_iterator_tag iterator_category;
; 138  : 
; 139  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 140  : 	typedef typename _Mytree::value_type value_type;
; 141  : 	typedef typename _Mytree::difference_type difference_type;
; 142  : 	typedef typename _Mytree::pointer pointer;
; 143  : 	typedef typename _Mytree::reference reference;
; 144  : 
; 145  : 	_Tree_unchecked_iterator()
; 146  : 		{	// construct with null node
; 147  : 		}
; 148  : 
; 149  : 	_Tree_unchecked_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 150  : 		: _Mybase(_Pnode, _Plist)
; 151  : 		{	// construct with node pointer _Pnode
; 152  : 		}
; 153  : 
; 154  : 	reference operator*() const
; 155  : 		{	// return designated value
; 156  : 		return ((reference)**(_Mybase *)this);
; 157  : 		}
; 158  : 
; 159  : 	pointer operator->() const
; 160  : 		{	// return pointer to class object
; 161  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 162  : 		}
; 163  : 
; 164  : 	_Myiter& operator++()
; 165  : 		{	// preincrement
; 166  : 		++(*(_Mybase *)this);
; 167  : 		return (*this);
; 168  : 		}
; 169  : 
; 170  : 	_Myiter operator++(int)
; 171  : 		{	// postincrement
; 172  : 		_Myiter _Tmp = *this;
; 173  : 		++*this;
; 174  : 		return (_Tmp);
; 175  : 		}
; 176  : 
; 177  : 	_Myiter& operator--()
; 178  : 		{	// predecrement
; 179  : 		--(*(_Mybase *)this);
; 180  : 		return (*this);
; 181  : 		}
; 182  : 
; 183  : 	_Myiter operator--(int)
; 184  : 		{	// postdecrement
; 185  : 		_Myiter _Tmp = *this;
; 186  : 		--*this;
; 187  : 		return (_Tmp);
; 188  : 		}
; 189  : 	};
; 190  : 
; 191  : 	// TEMPLATE CLASS _Tree_const_iterator
; 192  : template<class _Mytree>
; 193  : 	class _Tree_const_iterator
; 194  : 		: public _Tree_unchecked_const_iterator<_Mytree, _Iterator_base>
; 195  : 	{	// iterator for nonmutable tree
; 196  : public:
; 197  : 	typedef _Tree_const_iterator<_Mytree> _Myiter;
; 198  : 	typedef _Tree_unchecked_const_iterator<_Mytree, _Iterator_base> _Mybase;
; 199  : 	typedef bidirectional_iterator_tag iterator_category;
; 200  : 
; 201  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 202  : 	typedef typename _Mytree::value_type value_type;
; 203  : 	typedef typename _Mytree::difference_type difference_type;
; 204  : 	typedef typename _Mytree::const_pointer pointer;
; 205  : 	typedef typename _Mytree::const_reference reference;
; 206  : 
; 207  : 	_Tree_const_iterator()
; 208  : 		: _Mybase()
; 209  : 		{	// construct with null node pointer
; 210  : 		}
; 211  : 
; 212  : 	_Tree_const_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 213  : 		: _Mybase(_Pnode, _Plist)
; 214  : 		{	// construct with node pointer _Pnode
; 215  : 		}
; 216  : 
; 217  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Unchecked_type;
; 218  : 
; 219  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 220  : 		{	// reset from unchecked iterator
; 221  : 		this->_Ptr = _Right._Ptr;
; 222  : 		return (*this);
; 223  : 		}
; 224  : 
; 225  : 	_Unchecked_type _Unchecked() const
; 226  : 		{	// make an unchecked iterator
; 227  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 228  : 		}
; 229  : 
; 230  : 	reference operator*() const
; 231  : 		{	// return designated value
; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		if (this->_Getcont() == 0
; 234  : 			|| this->_Ptr == 0
; 235  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 236  : 			{	// report error
; 237  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 238  : 			_SCL_SECURE_OUT_OF_RANGE;
; 239  : 			}
; 240  : 
; 241  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 242  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 243  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 244  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 245  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 246  : 
; 247  : 		return (_Mytree::_Myval(this->_Ptr));
; 248  : 		}
; 249  : 
; 250  : 	pointer operator->() const
; 251  : 		{	// return pointer to class object
; 252  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 253  : 		}
; 254  : 
; 255  : 	_Myiter& operator++()
; 256  : 		{	// preincrement
; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);
; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;

  017a0	4c 8b c3	 mov	 r8, rbx

; 60   : 		if (_Mytree::_Isnil(_Ptr))

  017a3	80 7b 19 00	 cmp	 BYTE PTR [rbx+25], 0
  017a7	75 45		 jne	 SHORT $LN1057@tick

; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  :  #if _HAS_CPP0X
; 520  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 521  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 522  : 
; 523  :  #else /* _HAS_CPP0X */
; 524  : 	typedef typename _Alloc::template rebind<_Ty>::other _Alty;
; 525  :  #endif /* _HAS_CPP0X */
; 526  : 
; 527  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 528  : 		_Voidptr;
; 529  : 	typedef _Tree_node<typename _Alty::value_type,
; 530  : 		_Voidptr> _Node;
; 531  : 
; 532  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 533  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 534  : 	typedef _Nodeptr& _Nodepref;
; 535  : 
; 536  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 537  : 		_Tree_simple_types<typename _Alty::value_type>,
; 538  : 		_Tree_iter_types<typename _Alty::value_type,
; 539  : 			typename _Alty::size_type,
; 540  : 			typename _Alty::difference_type,
; 541  : 			typename _Alty::pointer,
; 542  : 			typename _Alty::const_pointer,
; 543  : 			typename _Alty::reference,
; 544  : 			typename _Alty::const_reference,
; 545  : 			_Nodeptr> >::type
; 546  : 		_Val_types;
; 547  : 	};
; 548  : 
; 549  : 		// TEMPLATE CLASS _Tree_val
; 550  : template<class _Val_types>
; 551  : 	class _Tree_val
; 552  : 		: public _Container_base
; 553  : 	{	// base class for tree to hold data
; 554  : public:
; 555  : 	typedef _Tree_val<_Val_types> _Myt;
; 556  : 
; 557  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 558  : 	typedef _Nodeptr& _Nodepref;
; 559  : 
; 560  : 	typedef typename _Val_types::value_type value_type;
; 561  : 	typedef typename _Val_types::size_type size_type;
; 562  : 	typedef typename _Val_types::difference_type difference_type;
; 563  : 	typedef typename _Val_types::pointer pointer;
; 564  : 	typedef typename _Val_types::const_pointer const_pointer;
; 565  : 	typedef typename _Val_types::reference reference;
; 566  : 	typedef typename _Val_types::const_reference const_reference;
; 567  : 
; 568  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 569  : 	typedef _Tree_iterator<_Myt> iterator;
; 570  : 
; 571  : 	_Tree_val()
; 572  : 		{	// initialize data
; 573  : 		this->_Myhead = 0;
; 574  : 		this->_Mysize = 0;
; 575  : 		}
; 576  : 
; 577  : 	enum _Redbl
; 578  : 		{	// colors for link to parent
; 579  : 		_Red, _Black};
; 580  : 
; 581  : 	static char& _Color(_Nodeptr _Pnode)
; 582  : 		{	// return reference to color in node
; 583  : 		return ((char&)_Pnode->_Color);
; 584  : 		}
; 585  : 
; 586  : 	static char& _Isnil(_Nodeptr _Pnode)
; 587  : 		{	// return reference to nil flag in node
; 588  : 		return ((char&)_Pnode->_Isnil);

  017a9	48 8b 43 10	 mov	 rax, QWORD PTR [rbx+16]

; 61   : 			;	// end() shouldn't be incremented, don't move
; 62   : 		else if (!_Mytree::_Isnil(_Mytree::_Right(_Ptr)))

  017ad	80 78 19 00	 cmp	 BYTE PTR [rax+25], 0
  017b1	75 1b		 jne	 SHORT $LN1610@tick

; 63   : 			_Ptr = _Mytree::_Min(
; 64   : 				_Mytree::_Right(_Ptr));	// ==> smallest of right subtree

  017b3	48 8b d8	 mov	 rbx, rax

; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  :  #if _HAS_CPP0X
; 520  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 521  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 522  : 
; 523  :  #else /* _HAS_CPP0X */
; 524  : 	typedef typename _Alloc::template rebind<_Ty>::other _Alty;
; 525  :  #endif /* _HAS_CPP0X */
; 526  : 
; 527  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 528  : 		_Voidptr;
; 529  : 	typedef _Tree_node<typename _Alty::value_type,
; 530  : 		_Voidptr> _Node;
; 531  : 
; 532  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 533  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 534  : 	typedef _Nodeptr& _Nodepref;
; 535  : 
; 536  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 537  : 		_Tree_simple_types<typename _Alty::value_type>,
; 538  : 		_Tree_iter_types<typename _Alty::value_type,
; 539  : 			typename _Alty::size_type,
; 540  : 			typename _Alty::difference_type,
; 541  : 			typename _Alty::pointer,
; 542  : 			typename _Alty::const_pointer,
; 543  : 			typename _Alty::reference,
; 544  : 			typename _Alty::const_reference,
; 545  : 			_Nodeptr> >::type
; 546  : 		_Val_types;
; 547  : 	};
; 548  : 
; 549  : 		// TEMPLATE CLASS _Tree_val
; 550  : template<class _Val_types>
; 551  : 	class _Tree_val
; 552  : 		: public _Container_base
; 553  : 	{	// base class for tree to hold data
; 554  : public:
; 555  : 	typedef _Tree_val<_Val_types> _Myt;
; 556  : 
; 557  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 558  : 	typedef _Nodeptr& _Nodepref;
; 559  : 
; 560  : 	typedef typename _Val_types::value_type value_type;
; 561  : 	typedef typename _Val_types::size_type size_type;
; 562  : 	typedef typename _Val_types::difference_type difference_type;
; 563  : 	typedef typename _Val_types::pointer pointer;
; 564  : 	typedef typename _Val_types::const_pointer const_pointer;
; 565  : 	typedef typename _Val_types::reference reference;
; 566  : 	typedef typename _Val_types::const_reference const_reference;
; 567  : 
; 568  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 569  : 	typedef _Tree_iterator<_Myt> iterator;
; 570  : 
; 571  : 	_Tree_val()
; 572  : 		{	// initialize data
; 573  : 		this->_Myhead = 0;
; 574  : 		this->_Mysize = 0;
; 575  : 		}
; 576  : 
; 577  : 	enum _Redbl
; 578  : 		{	// colors for link to parent
; 579  : 		_Red, _Black};
; 580  : 
; 581  : 	static char& _Color(_Nodeptr _Pnode)
; 582  : 		{	// return reference to color in node
; 583  : 		return ((char&)_Pnode->_Color);
; 584  : 		}
; 585  : 
; 586  : 	static char& _Isnil(_Nodeptr _Pnode)
; 587  : 		{	// return reference to nil flag in node
; 588  : 		return ((char&)_Pnode->_Isnil);

  017b6	48 8b 00	 mov	 rax, QWORD PTR [rax]

; 589  : 		}
; 590  : 
; 591  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 592  : 		{	// return reference to left pointer in node
; 593  : 		return ((_Nodepref)_Pnode->_Left);
; 594  : 		}
; 595  : 
; 596  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 597  : 		{	// return reference to parent pointer in node
; 598  : 		return ((_Nodepref)_Pnode->_Parent);
; 599  : 		}
; 600  : 
; 601  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 602  : 		{	// return reference to right pointer in node
; 603  : 		return ((_Nodepref)_Pnode->_Right);
; 604  : 		}
; 605  : 
; 606  : 	static reference _Myval(_Nodeptr _Pnode)
; 607  : 		{	// return reference to value in node
; 608  : 		return ((reference)_Pnode->_Myval);
; 609  : 		}
; 610  : 
; 611  : 	static _Nodeptr _Max(_Nodeptr _Pnode)
; 612  : 		{	// return rightmost node in subtree at _Pnode
; 613  : 		while (!_Isnil(_Right(_Pnode)))
; 614  : 			_Pnode = _Right(_Pnode);
; 615  : 		return (_Pnode);
; 616  : 		}
; 617  : 
; 618  : 	static _Nodeptr _Min(_Nodeptr _Pnode)
; 619  : 		{	// return leftmost node in subtree at _Pnode
; 620  : 		while (!_Isnil(_Left(_Pnode)))

  017b9	80 78 19 00	 cmp	 BYTE PTR [rax+25], 0
  017bd	75 2f		 jne	 SHORT $LN1057@tick
  017bf	90		 npad	 1
$LL1072@tick:

; 621  : 			_Pnode = _Left(_Pnode);

  017c0	48 8b d8	 mov	 rbx, rax

; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  :  #if _HAS_CPP0X
; 520  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 521  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 522  : 
; 523  :  #else /* _HAS_CPP0X */
; 524  : 	typedef typename _Alloc::template rebind<_Ty>::other _Alty;
; 525  :  #endif /* _HAS_CPP0X */
; 526  : 
; 527  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 528  : 		_Voidptr;
; 529  : 	typedef _Tree_node<typename _Alty::value_type,
; 530  : 		_Voidptr> _Node;
; 531  : 
; 532  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 533  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 534  : 	typedef _Nodeptr& _Nodepref;
; 535  : 
; 536  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 537  : 		_Tree_simple_types<typename _Alty::value_type>,
; 538  : 		_Tree_iter_types<typename _Alty::value_type,
; 539  : 			typename _Alty::size_type,
; 540  : 			typename _Alty::difference_type,
; 541  : 			typename _Alty::pointer,
; 542  : 			typename _Alty::const_pointer,
; 543  : 			typename _Alty::reference,
; 544  : 			typename _Alty::const_reference,
; 545  : 			_Nodeptr> >::type
; 546  : 		_Val_types;
; 547  : 	};
; 548  : 
; 549  : 		// TEMPLATE CLASS _Tree_val
; 550  : template<class _Val_types>
; 551  : 	class _Tree_val
; 552  : 		: public _Container_base
; 553  : 	{	// base class for tree to hold data
; 554  : public:
; 555  : 	typedef _Tree_val<_Val_types> _Myt;
; 556  : 
; 557  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 558  : 	typedef _Nodeptr& _Nodepref;
; 559  : 
; 560  : 	typedef typename _Val_types::value_type value_type;
; 561  : 	typedef typename _Val_types::size_type size_type;
; 562  : 	typedef typename _Val_types::difference_type difference_type;
; 563  : 	typedef typename _Val_types::pointer pointer;
; 564  : 	typedef typename _Val_types::const_pointer const_pointer;
; 565  : 	typedef typename _Val_types::reference reference;
; 566  : 	typedef typename _Val_types::const_reference const_reference;
; 567  : 
; 568  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 569  : 	typedef _Tree_iterator<_Myt> iterator;
; 570  : 
; 571  : 	_Tree_val()
; 572  : 		{	// initialize data
; 573  : 		this->_Myhead = 0;
; 574  : 		this->_Mysize = 0;
; 575  : 		}
; 576  : 
; 577  : 	enum _Redbl
; 578  : 		{	// colors for link to parent
; 579  : 		_Red, _Black};
; 580  : 
; 581  : 	static char& _Color(_Nodeptr _Pnode)
; 582  : 		{	// return reference to color in node
; 583  : 		return ((char&)_Pnode->_Color);
; 584  : 		}
; 585  : 
; 586  : 	static char& _Isnil(_Nodeptr _Pnode)
; 587  : 		{	// return reference to nil flag in node
; 588  : 		return ((char&)_Pnode->_Isnil);

  017c3	48 8b 00	 mov	 rax, QWORD PTR [rax]

; 589  : 		}
; 590  : 
; 591  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 592  : 		{	// return reference to left pointer in node
; 593  : 		return ((_Nodepref)_Pnode->_Left);
; 594  : 		}
; 595  : 
; 596  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 597  : 		{	// return reference to parent pointer in node
; 598  : 		return ((_Nodepref)_Pnode->_Parent);
; 599  : 		}
; 600  : 
; 601  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 602  : 		{	// return reference to right pointer in node
; 603  : 		return ((_Nodepref)_Pnode->_Right);
; 604  : 		}
; 605  : 
; 606  : 	static reference _Myval(_Nodeptr _Pnode)
; 607  : 		{	// return reference to value in node
; 608  : 		return ((reference)_Pnode->_Myval);
; 609  : 		}
; 610  : 
; 611  : 	static _Nodeptr _Max(_Nodeptr _Pnode)
; 612  : 		{	// return rightmost node in subtree at _Pnode
; 613  : 		while (!_Isnil(_Right(_Pnode)))
; 614  : 			_Pnode = _Right(_Pnode);
; 615  : 		return (_Pnode);
; 616  : 		}
; 617  : 
; 618  : 	static _Nodeptr _Min(_Nodeptr _Pnode)
; 619  : 		{	// return leftmost node in subtree at _Pnode
; 620  : 		while (!_Isnil(_Left(_Pnode)))

  017c6	80 78 19 00	 cmp	 BYTE PTR [rax+25], 0
  017ca	74 f4		 je	 SHORT $LL1072@tick

; 65   : 		else

  017cc	eb 20		 jmp	 SHORT $LN1057@tick
$LN1610@tick:

; 66   : 			{	// climb looking for right subtree
; 67   : 			_Nodeptr _Pnode;
; 68   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 69   : 				&& _Ptr == _Mytree::_Right(_Pnode))

  017ce	48 8b 43 08	 mov	 rax, QWORD PTR [rbx+8]
  017d2	80 78 19 00	 cmp	 BYTE PTR [rax+25], 0
  017d6	75 13		 jne	 SHORT $LN1055@tick
$LL1056@tick:
  017d8	48 3b 58 10	 cmp	 rbx, QWORD PTR [rax+16]
  017dc	75 0d		 jne	 SHORT $LN1055@tick

; 70   : 				_Ptr = _Pnode;	// ==> parent while right subtree

  017de	48 8b d8	 mov	 rbx, rax

; 66   : 			{	// climb looking for right subtree
; 67   : 			_Nodeptr _Pnode;
; 68   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 69   : 				&& _Ptr == _Mytree::_Right(_Pnode))

  017e1	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  017e5	80 78 19 00	 cmp	 BYTE PTR [rax+25], 0
  017e9	74 ed		 je	 SHORT $LL1056@tick
$LN1055@tick:

; 71   : 			_Ptr = _Pnode;	// ==> parent (head if end())

  017eb	48 8b d8	 mov	 rbx, rax
$LN1057@tick:

; 1517 : 				erase(_First++);

  017ee	48 8d 95 a8 00
	00 00		 lea	 rdx, QWORD PTR $T21[rbp-256]
  017f5	48 8d 0d 08 00
	00 00		 lea	 rcx, OFFSET FLAT:?world@GlobalThread@@3VWorld@@A+8
  017fc	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::erase

; 336  : 		return (this->_Ptr == _Right._Ptr);

  01801	48 3b df	 cmp	 rbx, rdi

; 1513 : 			}
; 1514 : 		else
; 1515 : 			{	// partial erase, one at a time
; 1516 : 			while (_First != _Last)

  01804	75 9a		 jne	 SHORT $LL937@tick
$LN936@tick:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  01806	4d 85 f6	 test	 r14, r14
  01809	74 1f		 je	 SHORT $LN1685@tick

; 109  : 		}
; 110  : 
; 111  : 	void _Incwref()
; 112  : 		{	// increment weak reference count
; 113  : 		_MT_INCR(_Ignored, _Weaks);
; 114  : 		}
; 115  : 
; 116  : 	void _Decref()
; 117  : 		{	// decrement use count
; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  0180b	f0 41 ff 4e 08	 lock dec DWORD PTR [r14+8]
  01810	75 18		 jne	 SHORT $LN1685@tick

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  01812	49 8b 06	 mov	 rax, QWORD PTR [r14]
  01815	49 8b ce	 mov	 rcx, r14
  01818	ff 10		 call	 QWORD PTR [rax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  0181a	f0 41 ff 4e 0c	 lock dec DWORD PTR [r14+12]
  0181f	75 09		 jne	 SHORT $LN1685@tick

; 128  : 			_Delete_this();

  01821	49 8b 06	 mov	 rax, QWORD PTR [r14]
  01824	49 8b ce	 mov	 rcx, r14
  01827	ff 50 08	 call	 QWORD PTR [rax+8]
$LN1685@tick:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 1382 : 		return (this->_Mysize == 0);

  0182a	48 83 3d 70 00
	00 00 00	 cmp	 QWORD PTR ?world@GlobalThread@@3VWorld@@A+112, 0
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp

; 132  : 	while(!GlobalThread::world.removalQueue.empty())

  01832	0f 85 e8 fc ff
	ff		 jne	 $LL18@tick
$LN17@tick:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 83   : 	return (_Check_C_return(_Mtx_unlock(_Mtx)));

  01838	48 8d 0d 48 00
	00 00		 lea	 rcx, OFFSET FLAT:?world@GlobalThread@@3VWorld@@A+72
  0183f	e8 00 00 00 00	 call	 _Mtx_unlock

; 32   : 	if (_Res != _Thrd_success)

  01844	85 c0		 test	 eax, eax
  01846	74 07		 je	 SHORT $LN1110@tick

; 33   : 		_Throw_C_error(_Res);

  01848	8b c8		 mov	 ecx, eax
  0184a	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
$LN1110@tick:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector

; 486  : 		_Myfirst = pointer();

  0184f	4c 89 7c 24 60	 mov	 QWORD PTR chunksToRender$[rsp], r15

; 487  : 		_Mylast = pointer();

  01854	49 8b ff	 mov	 rdi, r15
  01857	4c 89 7c 24 68	 mov	 QWORD PTR chunksToRender$[rsp+8], r15

; 488  : 		_Myend = pointer();

  0185c	4c 89 7c 24 70	 mov	 QWORD PTR chunksToRender$[rsp+16], r15
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp

; 142  : 	for(map<ChunkPosition, std::shared_ptr<ChunkBase>>::const_iterator iter = GlobalThread::world.chunkMap.begin(); iter != GlobalThread::world.chunkMap.end(); ++iter)

  01861	48 8b 05 08 00
	00 00		 mov	 rax, QWORD PTR ?world@GlobalThread@@3VWorld@@A+8
  01868	48 8b 18	 mov	 rbx, QWORD PTR [rax]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree

; 336  : 		return (this->_Ptr == _Right._Ptr);

  0186b	48 3b d8	 cmp	 rbx, rax
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp

; 142  : 	for(map<ChunkPosition, std::shared_ptr<ChunkBase>>::const_iterator iter = GlobalThread::world.chunkMap.begin(); iter != GlobalThread::world.chunkMap.end(); ++iter)

  0186e	0f 84 11 02 00
	00		 je	 $LN14@tick
  01874	4c 8d 25 00 00
	00 00		 lea	 r12, OFFSET FLAT:?bGrid@@3PAY1BB@BB@_NA ; bGrid
  0187b	0f 1f 44 00 00	 npad	 5
$LL1139@tick:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 357  : 		_Reset(_Other._Ptr, _Other._Rep);

  01880	48 8b 73 38	 mov	 rsi, QWORD PTR [rbx+56]
  01884	4c 8b 73 30	 mov	 r14, QWORD PTR [rbx+48]

; 358  : 		}
; 359  : 
; 360  : 	template<class _Ty2>
; 361  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, bool _Throw)
; 362  : 		{	// release resource and take ownership from weak_ptr _Other._Ptr
; 363  : 		_Reset(_Other._Ptr, _Other._Rep, _Throw);
; 364  : 		}
; 365  : 
; 366  : 	template<class _Ty2>
; 367  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Static_tag&)
; 368  : 		{	// release resource and take ownership of _Other._Ptr
; 369  : 		_Reset(static_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 370  : 		}
; 371  : 
; 372  : 	template<class _Ty2>
; 373  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Const_tag&)
; 374  : 		{	// release resource and take ownership of _Other._Ptr
; 375  : 		_Reset(const_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 376  : 		}
; 377  : 
; 378  : 	template<class _Ty2>
; 379  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Dynamic_tag&)
; 380  : 		{	// release resource and take ownership of _Other._Ptr
; 381  : 		_Elem *_Ptr = dynamic_cast<_Elem *>(_Other._Ptr);
; 382  : 		if (_Ptr)
; 383  : 			_Reset(_Ptr, _Other._Rep);
; 384  : 		else
; 385  : 			_Reset();
; 386  : 		}
; 387  : 
; 388  : 	template<class _Ty2>
; 389  : 		void _Reset(auto_ptr<_Ty2>&& _Other)
; 390  : 		{	// release resource and take _Other.get()
; 391  : 		_Ty2 *_Px = _Other.get();
; 392  : 		_Reset0(_Px, new _Ref_count<_Elem>(_Px));
; 393  : 		_Other.release();
; 394  : 		_Enable_shared(_Px, _Rep);
; 395  : 		}
; 396  : 
; 397  :  #if _HAS_CPP0X
; 398  : 	template<class _Ty2>
; 399  : 		void _Reset(_Ty *_Ptr, const _Ptr_base<_Ty2>& _Other)
; 400  : 		{	// release resource and alias _Ptr with _Other_rep
; 401  : 		_Reset(_Ptr, _Other._Rep);
; 402  : 		}
; 403  :  #endif /* _HAS_CPP0X */
; 404  : 
; 405  : 	void _Reset(_Ty *_Other_ptr, _Ref_count_base *_Other_rep)
; 406  : 		{	// release resource and take _Other_ptr through _Other_rep
; 407  : 		if (_Other_rep)

  01888	48 85 f6	 test	 rsi, rsi
  0188b	74 09		 je	 SHORT $LN1210@tick

; 108  : 		_MT_INCR(_Ignored, _Uses);

  0188d	f0 ff 46 08	 lock inc DWORD PTR [rsi+8]
  01891	48 8b 7c 24 68	 mov	 rdi, QWORD PTR chunksToRender$[rsp+8]
$LN1210@tick:

; 425  : 			_Rep->_Decref();
; 426  : 		_Rep = _Other_rep;

  01896	48 89 75 08	 mov	 QWORD PTR chunk$11[rbp-248], rsi

; 427  : 		_Ptr = _Other_ptr;

  0189a	4c 89 75 00	 mov	 QWORD PTR chunk$11[rbp-256], r14
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp

; 145  : 		if(!chunk->isEmpty() && chunk->isLoaded())

  0189e	49 8b 06	 mov	 rax, QWORD PTR [r14]
  018a1	49 8b ce	 mov	 rcx, r14
  018a4	ff 50 18	 call	 QWORD PTR [rax+24]
  018a7	84 c0		 test	 al, al
  018a9	0f 85 43 01 00
	00		 jne	 $LN1260@tick
  018af	41 38 46 09	 cmp	 BYTE PTR [r14+9], al
  018b3	0f 84 39 01 00
	00		 je	 $LN1260@tick

; 146  : 		{
; 147  : 			if(chunk->pos.x - renderDistance <= xCam && chunk->pos.x + renderDistance >= xCam && chunk->pos.y - renderDistance <= yCam && chunk->pos.y + renderDistance >= yCam && chunk->pos.z - renderDistance <= zCam && chunk->pos.z + renderDistance > zCam)

  018b9	49 63 4e 18	 movsxd	 rcx, DWORD PTR [r14+24]
  018bd	8d 41 f8	 lea	 eax, DWORD PTR [rcx-8]
  018c0	48 63 54 24 50	 movsxd	 rdx, DWORD PTR xCam$[rsp]
  018c5	3b c2		 cmp	 eax, edx
  018c7	0f 8f 25 01 00
	00		 jg	 $LN1260@tick
  018cd	8d 41 08	 lea	 eax, DWORD PTR [rcx+8]
  018d0	3b c2		 cmp	 eax, edx
  018d2	0f 8c 1a 01 00
	00		 jl	 $LN1260@tick
  018d8	4d 63 46 1c	 movsxd	 r8, DWORD PTR [r14+28]
  018dc	41 8d 40 f8	 lea	 eax, DWORD PTR [r8-8]
  018e0	4c 63 4c 24 58	 movsxd	 r9, DWORD PTR yCam$[rsp]
  018e5	41 3b c1	 cmp	 eax, r9d
  018e8	0f 8f 04 01 00
	00		 jg	 $LN1260@tick
  018ee	41 8d 40 08	 lea	 eax, DWORD PTR [r8+8]
  018f2	41 3b c1	 cmp	 eax, r9d
  018f5	0f 8c f7 00 00
	00		 jl	 $LN1260@tick
  018fb	4d 63 56 20	 movsxd	 r10, DWORD PTR [r14+32]
  018ff	41 8d 42 f8	 lea	 eax, DWORD PTR [r10-8]
  01903	4c 63 5c 24 54	 movsxd	 r11, DWORD PTR zCam$[rsp]
  01908	41 3b c3	 cmp	 eax, r11d
  0190b	0f 8f e1 00 00
	00		 jg	 $LN1260@tick
  01911	41 8d 42 08	 lea	 eax, DWORD PTR [r10+8]
  01915	41 3b c3	 cmp	 eax, r11d
  01918	0f 8e d4 00 00
	00		 jle	 $LN1260@tick

; 148  : 			{
; 149  : 				if(bGrid[chunk->pos.x - xCam + renderDistance][chunk->pos.y - yCam + renderDistance][chunk->pos.z - zCam + renderDistance])

  0191e	48 2b ca	 sub	 rcx, rdx
  01921	48 6b c9 11	 imul	 rcx, 17
  01925	49 2b c9	 sub	 rcx, r9
  01928	49 03 c8	 add	 rcx, r8
  0192b	48 6b c9 11	 imul	 rcx, 17
  0192f	49 2b cb	 sub	 rcx, r11
  01932	49 03 ca	 add	 rcx, r10
  01935	42 80 bc 21 98
	09 00 00 00	 cmp	 BYTE PTR [rcx+r12+2456], 0
  0193e	0f 84 ae 00 00
	00		 je	 $LN1260@tick
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector

; 1496 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

  01944	48 8d 45 00	 lea	 rax, QWORD PTR chunk$11[rbp-256]
  01948	48 3b c7	 cmp	 rax, rdi
  0194b	73 5e		 jae	 SHORT $LN1262@tick
  0194d	48 8d 45 00	 lea	 rax, QWORD PTR chunk$11[rbp-256]
  01951	4c 8b 7c 24 60	 mov	 r15, QWORD PTR chunksToRender$[rsp]
  01956	4c 3b f8	 cmp	 r15, rax
  01959	77 4d		 ja	 SHORT $LN1690@tick

; 1088 : 		}
; 1089 : 
; 1090 : 	size_type max_size() const _NOEXCEPT
; 1091 : 		{	// return maximum possible length of sequence
; 1092 : 		return (this->_Getal().max_size());
; 1093 : 		}
; 1094 : 
; 1095 : 	bool empty() const _NOEXCEPT
; 1096 : 		{	// test if sequence is empty
; 1097 : 		return (this->_Myfirst == this->_Mylast);
; 1098 : 		}
; 1099 : 
; 1100 : 	_Alloc get_allocator() const _NOEXCEPT
; 1101 : 		{	// return allocator object for values
; 1102 : 		return (this->_Getal());
; 1103 : 		}
; 1104 : 
; 1105 : 	const_reference at(size_type _Pos) const
; 1106 : 		{	// subscript nonmutable sequence with checking
; 1107 : 		if (size() <= _Pos)
; 1108 : 			_Xran();
; 1109 : 		return (*(this->_Myfirst + _Pos));
; 1110 : 		}
; 1111 : 
; 1112 : 	reference at(size_type _Pos)
; 1113 : 		{	// subscript mutable sequence with checking
; 1114 : 		if (size() <= _Pos)
; 1115 : 			_Xran();
; 1116 : 		return (*(this->_Myfirst + _Pos));
; 1117 : 		}
; 1118 : 
; 1119 : 	const_reference operator[](size_type _Pos) const
; 1120 : 		{	// subscript nonmutable sequence
; 1121 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1122 : 		if (size() <= _Pos)
; 1123 : 			{	// report error
; 1124 : 			_DEBUG_ERROR("vector subscript out of range");
; 1125 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1126 : 			}
; 1127 : 
; 1128 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1129 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1130 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1131 : 
; 1132 : 		return (*(this->_Myfirst + _Pos));
; 1133 : 		}
; 1134 : 
; 1135 : 	reference operator[](size_type _Pos)
; 1136 : 		{	// subscript mutable sequence
; 1137 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1138 : 		if (size() <= _Pos)
; 1139 : 			{	// report error
; 1140 : 			_DEBUG_ERROR("vector subscript out of range");
; 1141 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1142 : 			}
; 1143 : 
; 1144 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1145 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1146 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1147 : 
; 1148 : 		return (*(this->_Myfirst + _Pos));
; 1149 : 		}
; 1150 : 
; 1151 :  #if _HAS_CPP0X
; 1152 : 	pointer data() _NOEXCEPT
; 1153 : 		{	// return address of first element
; 1154 : 		return (this->_Myfirst);
; 1155 : 		}
; 1156 : 
; 1157 : 	const_pointer data() const _NOEXCEPT
; 1158 : 		{	// return address of first element
; 1159 : 		return (this->_Myfirst);
; 1160 : 		}
; 1161 :  #endif /* _HAS_CPP0X */
; 1162 : 
; 1163 : 	reference front()
; 1164 : 		{	// return first element of mutable sequence
; 1165 : 		return (*begin());
; 1166 : 		}
; 1167 : 
; 1168 : 	const_reference front() const
; 1169 : 		{	// return first element of nonmutable sequence
; 1170 : 		return (*begin());
; 1171 : 		}
; 1172 : 
; 1173 : 	reference back()
; 1174 : 		{	// return last element of mutable sequence
; 1175 : 		return (*(end() - 1));
; 1176 : 		}
; 1177 : 
; 1178 : 	const_reference back() const
; 1179 : 		{	// return last element of nonmutable sequence
; 1180 : 		return (*(end() - 1));
; 1181 : 		}
; 1182 : 
; 1183 : 	void push_back(const value_type& _Val)
; 1184 : 		{	// insert element at end
; 1185 : 		if (_Inside(_STD addressof(_Val)))
; 1186 : 			{	// push back an element
; 1187 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;

  0195b	4c 8d 75 00	 lea	 r14, QWORD PTR chunk$11[rbp-256]
  0195f	4d 2b f7	 sub	 r14, r15

; 1188 : 			if (this->_Mylast == this->_Myend)

  01962	48 3b 7c 24 70	 cmp	 rdi, QWORD PTR chunksToRender$[rsp+16]
  01967	75 0f		 jne	 SHORT $LN1261@tick

; 1189 : 				_Reserve(1);

  01969	48 8d 4c 24 60	 lea	 rcx, QWORD PTR chunksToRender$[rsp]
  0196e	e8 00 00 00 00	 call	 ?_Reserve@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAX_K@Z ; std::vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::_Reserve
  01973	48 8b 7c 24 68	 mov	 rdi, QWORD PTR chunksToRender$[rsp+8]
$LN1261@tick:

; 1190 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1191 : 			this->_Getal().construct(this->_Mylast,
; 1192 : 				this->_Myfirst[_Idx]);

  01978	49 83 e6 f0	 and	 r14, -16
  0197c	4c 03 74 24 60	 add	 r14, QWORD PTR chunksToRender$[rsp]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 617  : _VARIADIC_EXPAND_0X(_ALLOC_MEMBER_CONSTRUCT, , , , )

  01981	48 85 ff	 test	 rdi, rdi
  01984	74 63		 je	 SHORT $LN1318@tick
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 282  : 		{	// construct

  01986	45 33 ff	 xor	 r15d, r15d
  01989	4c 89 3f	 mov	 QWORD PTR [rdi], r15
  0198c	4c 89 7f 08	 mov	 QWORD PTR [rdi+8], r15

; 357  : 		_Reset(_Other._Ptr, _Other._Rep);

  01990	4d 8b 46 08	 mov	 r8, QWORD PTR [r14+8]
  01994	49 8b 16	 mov	 rdx, QWORD PTR [r14]

; 358  : 		}
; 359  : 
; 360  : 	template<class _Ty2>
; 361  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, bool _Throw)
; 362  : 		{	// release resource and take ownership from weak_ptr _Other._Ptr
; 363  : 		_Reset(_Other._Ptr, _Other._Rep, _Throw);
; 364  : 		}
; 365  : 
; 366  : 	template<class _Ty2>
; 367  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Static_tag&)
; 368  : 		{	// release resource and take ownership of _Other._Ptr
; 369  : 		_Reset(static_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 370  : 		}
; 371  : 
; 372  : 	template<class _Ty2>
; 373  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Const_tag&)
; 374  : 		{	// release resource and take ownership of _Other._Ptr
; 375  : 		_Reset(const_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 376  : 		}
; 377  : 
; 378  : 	template<class _Ty2>
; 379  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Dynamic_tag&)
; 380  : 		{	// release resource and take ownership of _Other._Ptr
; 381  : 		_Elem *_Ptr = dynamic_cast<_Elem *>(_Other._Ptr);
; 382  : 		if (_Ptr)
; 383  : 			_Reset(_Ptr, _Other._Rep);
; 384  : 		else
; 385  : 			_Reset();
; 386  : 		}
; 387  : 
; 388  : 	template<class _Ty2>
; 389  : 		void _Reset(auto_ptr<_Ty2>&& _Other)
; 390  : 		{	// release resource and take _Other.get()
; 391  : 		_Ty2 *_Px = _Other.get();
; 392  : 		_Reset0(_Px, new _Ref_count<_Elem>(_Px));
; 393  : 		_Other.release();
; 394  : 		_Enable_shared(_Px, _Rep);
; 395  : 		}
; 396  : 
; 397  :  #if _HAS_CPP0X
; 398  : 	template<class _Ty2>
; 399  : 		void _Reset(_Ty *_Ptr, const _Ptr_base<_Ty2>& _Other)
; 400  : 		{	// release resource and alias _Ptr with _Other_rep
; 401  : 		_Reset(_Ptr, _Other._Rep);
; 402  : 		}
; 403  :  #endif /* _HAS_CPP0X */
; 404  : 
; 405  : 	void _Reset(_Ty *_Other_ptr, _Ref_count_base *_Other_rep)
; 406  : 		{	// release resource and take _Other_ptr through _Other_rep
; 407  : 		if (_Other_rep)

  01997	4d 85 c0	 test	 r8, r8
  0199a	74 45		 je	 SHORT $LN1302@tick

; 108  : 		_MT_INCR(_Ignored, _Uses);

  0199c	f0 41 ff 40 08	 lock inc DWORD PTR [r8+8]
  019a1	48 8b 7c 24 68	 mov	 rdi, QWORD PTR chunksToRender$[rsp+8]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector

; 1195 : 		else

  019a6	eb 39		 jmp	 SHORT $LN1302@tick
$LN1690@tick:
  019a8	45 33 ff	 xor	 r15d, r15d
$LN1262@tick:

; 1196 : 			{	// push back a non-element
; 1197 : 			if (this->_Mylast == this->_Myend)

  019ab	48 3b 7c 24 70	 cmp	 rdi, QWORD PTR chunksToRender$[rsp+16]
  019b0	75 0f		 jne	 SHORT $LN1259@tick

; 1198 : 				_Reserve(1);

  019b2	48 8d 4c 24 60	 lea	 rcx, QWORD PTR chunksToRender$[rsp]
  019b7	e8 00 00 00 00	 call	 ?_Reserve@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAX_K@Z ; std::vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::_Reserve
  019bc	48 8b 7c 24 68	 mov	 rdi, QWORD PTR chunksToRender$[rsp+8]
$LN1259@tick:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 606  : 		::new ((void *)_Ptr) _Ty(_Val);

  019c1	48 85 ff	 test	 rdi, rdi
  019c4	74 23		 je	 SHORT $LN1318@tick
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 282  : 		{	// construct

  019c6	4c 89 3f	 mov	 QWORD PTR [rdi], r15
  019c9	4c 89 7f 08	 mov	 QWORD PTR [rdi+8], r15

; 358  : 		}
; 359  : 
; 360  : 	template<class _Ty2>
; 361  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, bool _Throw)
; 362  : 		{	// release resource and take ownership from weak_ptr _Other._Ptr
; 363  : 		_Reset(_Other._Ptr, _Other._Rep, _Throw);
; 364  : 		}
; 365  : 
; 366  : 	template<class _Ty2>
; 367  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Static_tag&)
; 368  : 		{	// release resource and take ownership of _Other._Ptr
; 369  : 		_Reset(static_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 370  : 		}
; 371  : 
; 372  : 	template<class _Ty2>
; 373  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Const_tag&)
; 374  : 		{	// release resource and take ownership of _Other._Ptr
; 375  : 		_Reset(const_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 376  : 		}
; 377  : 
; 378  : 	template<class _Ty2>
; 379  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Dynamic_tag&)
; 380  : 		{	// release resource and take ownership of _Other._Ptr
; 381  : 		_Elem *_Ptr = dynamic_cast<_Elem *>(_Other._Ptr);
; 382  : 		if (_Ptr)
; 383  : 			_Reset(_Ptr, _Other._Rep);
; 384  : 		else
; 385  : 			_Reset();
; 386  : 		}
; 387  : 
; 388  : 	template<class _Ty2>
; 389  : 		void _Reset(auto_ptr<_Ty2>&& _Other)
; 390  : 		{	// release resource and take _Other.get()
; 391  : 		_Ty2 *_Px = _Other.get();
; 392  : 		_Reset0(_Px, new _Ref_count<_Elem>(_Px));
; 393  : 		_Other.release();
; 394  : 		_Enable_shared(_Px, _Rep);
; 395  : 		}
; 396  : 
; 397  :  #if _HAS_CPP0X
; 398  : 	template<class _Ty2>
; 399  : 		void _Reset(_Ty *_Ptr, const _Ptr_base<_Ty2>& _Other)
; 400  : 		{	// release resource and alias _Ptr with _Other_rep
; 401  : 		_Reset(_Ptr, _Other._Rep);
; 402  : 		}
; 403  :  #endif /* _HAS_CPP0X */
; 404  : 
; 405  : 	void _Reset(_Ty *_Other_ptr, _Ref_count_base *_Other_rep)
; 406  : 		{	// release resource and take _Other_ptr through _Other_rep
; 407  : 		if (_Other_rep)

  019cd	48 85 f6	 test	 rsi, rsi
  019d0	74 09		 je	 SHORT $LN1331@tick

; 108  : 		_MT_INCR(_Ignored, _Uses);

  019d2	f0 ff 46 08	 lock inc DWORD PTR [rsi+8]
  019d6	48 8b 7c 24 68	 mov	 rdi, QWORD PTR chunksToRender$[rsp+8]
$LN1331@tick:

; 408  : 			_Other_rep->_Incref();
; 409  : 		_Reset0(_Other_ptr, _Other_rep);

  019db	4c 8b c6	 mov	 r8, rsi
  019de	49 8b d6	 mov	 rdx, r14
$LN1302@tick:
  019e1	48 8b cf	 mov	 rcx, rdi
  019e4	e8 00 00 00 00	 call	 ?_Reset0@?$_Ptr_base@VChunkBase@@@std@@QEAAXPEAVChunkBase@@PEAV_Ref_count_base@2@@Z ; std::_Ptr_base<ChunkBase>::_Reset0
$LN1318@tick:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector

; 1202 : 			++this->_Mylast;

  019e9	48 83 c7 10	 add	 rdi, 16
  019ed	48 89 7c 24 68	 mov	 QWORD PTR chunksToRender$[rsp+8], rdi
$LN1260@tick:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  019f2	48 85 f6	 test	 rsi, rsi
  019f5	74 22		 je	 SHORT $LN15@tick

; 109  : 		}
; 110  : 
; 111  : 	void _Incwref()
; 112  : 		{	// increment weak reference count
; 113  : 		_MT_INCR(_Ignored, _Weaks);
; 114  : 		}
; 115  : 
; 116  : 	void _Decref()
; 117  : 		{	// decrement use count
; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  019f7	f0 ff 4e 08	 lock dec DWORD PTR [rsi+8]
  019fb	75 17		 jne	 SHORT $LN1686@tick

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  019fd	48 8b 06	 mov	 rax, QWORD PTR [rsi]
  01a00	48 8b ce	 mov	 rcx, rsi
  01a03	ff 10		 call	 QWORD PTR [rax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  01a05	f0 ff 4e 0c	 lock dec DWORD PTR [rsi+12]
  01a09	75 09		 jne	 SHORT $LN1686@tick

; 128  : 			_Delete_this();

  01a0b	48 8b 06	 mov	 rax, QWORD PTR [rsi]
  01a0e	48 8b ce	 mov	 rcx, rsi
  01a11	ff 50 08	 call	 QWORD PTR [rax+8]
$LN1686@tick:
  01a14	48 8b 7c 24 68	 mov	 rdi, QWORD PTR chunksToRender$[rsp+8]
$LN15@tick:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree

; 60   : 		if (_Mytree::_Isnil(_Ptr))

  01a19	80 7b 19 00	 cmp	 BYTE PTR [rbx+25], 0
  01a1d	75 4f		 jne	 SHORT $LN1631@tick

; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  :  #if _HAS_CPP0X
; 520  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 521  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 522  : 
; 523  :  #else /* _HAS_CPP0X */
; 524  : 	typedef typename _Alloc::template rebind<_Ty>::other _Alty;
; 525  :  #endif /* _HAS_CPP0X */
; 526  : 
; 527  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 528  : 		_Voidptr;
; 529  : 	typedef _Tree_node<typename _Alty::value_type,
; 530  : 		_Voidptr> _Node;
; 531  : 
; 532  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 533  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 534  : 	typedef _Nodeptr& _Nodepref;
; 535  : 
; 536  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 537  : 		_Tree_simple_types<typename _Alty::value_type>,
; 538  : 		_Tree_iter_types<typename _Alty::value_type,
; 539  : 			typename _Alty::size_type,
; 540  : 			typename _Alty::difference_type,
; 541  : 			typename _Alty::pointer,
; 542  : 			typename _Alty::const_pointer,
; 543  : 			typename _Alty::reference,
; 544  : 			typename _Alty::const_reference,
; 545  : 			_Nodeptr> >::type
; 546  : 		_Val_types;
; 547  : 	};
; 548  : 
; 549  : 		// TEMPLATE CLASS _Tree_val
; 550  : template<class _Val_types>
; 551  : 	class _Tree_val
; 552  : 		: public _Container_base
; 553  : 	{	// base class for tree to hold data
; 554  : public:
; 555  : 	typedef _Tree_val<_Val_types> _Myt;
; 556  : 
; 557  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 558  : 	typedef _Nodeptr& _Nodepref;
; 559  : 
; 560  : 	typedef typename _Val_types::value_type value_type;
; 561  : 	typedef typename _Val_types::size_type size_type;
; 562  : 	typedef typename _Val_types::difference_type difference_type;
; 563  : 	typedef typename _Val_types::pointer pointer;
; 564  : 	typedef typename _Val_types::const_pointer const_pointer;
; 565  : 	typedef typename _Val_types::reference reference;
; 566  : 	typedef typename _Val_types::const_reference const_reference;
; 567  : 
; 568  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 569  : 	typedef _Tree_iterator<_Myt> iterator;
; 570  : 
; 571  : 	_Tree_val()
; 572  : 		{	// initialize data
; 573  : 		this->_Myhead = 0;
; 574  : 		this->_Mysize = 0;
; 575  : 		}
; 576  : 
; 577  : 	enum _Redbl
; 578  : 		{	// colors for link to parent
; 579  : 		_Red, _Black};
; 580  : 
; 581  : 	static char& _Color(_Nodeptr _Pnode)
; 582  : 		{	// return reference to color in node
; 583  : 		return ((char&)_Pnode->_Color);
; 584  : 		}
; 585  : 
; 586  : 	static char& _Isnil(_Nodeptr _Pnode)
; 587  : 		{	// return reference to nil flag in node
; 588  : 		return ((char&)_Pnode->_Isnil);

  01a1f	48 8b 43 10	 mov	 rax, QWORD PTR [rbx+16]

; 61   : 			;	// end() shouldn't be incremented, don't move
; 62   : 		else if (!_Mytree::_Isnil(_Mytree::_Right(_Ptr)))

  01a23	80 78 19 00	 cmp	 BYTE PTR [rax+25], 0
  01a27	75 25		 jne	 SHORT $LN1613@tick

; 63   : 			_Ptr = _Mytree::_Min(
; 64   : 				_Mytree::_Right(_Ptr));	// ==> smallest of right subtree

  01a29	48 8b d8	 mov	 rbx, rax

; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  :  #if _HAS_CPP0X
; 520  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 521  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 522  : 
; 523  :  #else /* _HAS_CPP0X */
; 524  : 	typedef typename _Alloc::template rebind<_Ty>::other _Alty;
; 525  :  #endif /* _HAS_CPP0X */
; 526  : 
; 527  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 528  : 		_Voidptr;
; 529  : 	typedef _Tree_node<typename _Alty::value_type,
; 530  : 		_Voidptr> _Node;
; 531  : 
; 532  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 533  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 534  : 	typedef _Nodeptr& _Nodepref;
; 535  : 
; 536  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 537  : 		_Tree_simple_types<typename _Alty::value_type>,
; 538  : 		_Tree_iter_types<typename _Alty::value_type,
; 539  : 			typename _Alty::size_type,
; 540  : 			typename _Alty::difference_type,
; 541  : 			typename _Alty::pointer,
; 542  : 			typename _Alty::const_pointer,
; 543  : 			typename _Alty::reference,
; 544  : 			typename _Alty::const_reference,
; 545  : 			_Nodeptr> >::type
; 546  : 		_Val_types;
; 547  : 	};
; 548  : 
; 549  : 		// TEMPLATE CLASS _Tree_val
; 550  : template<class _Val_types>
; 551  : 	class _Tree_val
; 552  : 		: public _Container_base
; 553  : 	{	// base class for tree to hold data
; 554  : public:
; 555  : 	typedef _Tree_val<_Val_types> _Myt;
; 556  : 
; 557  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 558  : 	typedef _Nodeptr& _Nodepref;
; 559  : 
; 560  : 	typedef typename _Val_types::value_type value_type;
; 561  : 	typedef typename _Val_types::size_type size_type;
; 562  : 	typedef typename _Val_types::difference_type difference_type;
; 563  : 	typedef typename _Val_types::pointer pointer;
; 564  : 	typedef typename _Val_types::const_pointer const_pointer;
; 565  : 	typedef typename _Val_types::reference reference;
; 566  : 	typedef typename _Val_types::const_reference const_reference;
; 567  : 
; 568  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 569  : 	typedef _Tree_iterator<_Myt> iterator;
; 570  : 
; 571  : 	_Tree_val()
; 572  : 		{	// initialize data
; 573  : 		this->_Myhead = 0;
; 574  : 		this->_Mysize = 0;
; 575  : 		}
; 576  : 
; 577  : 	enum _Redbl
; 578  : 		{	// colors for link to parent
; 579  : 		_Red, _Black};
; 580  : 
; 581  : 	static char& _Color(_Nodeptr _Pnode)
; 582  : 		{	// return reference to color in node
; 583  : 		return ((char&)_Pnode->_Color);
; 584  : 		}
; 585  : 
; 586  : 	static char& _Isnil(_Nodeptr _Pnode)
; 587  : 		{	// return reference to nil flag in node
; 588  : 		return ((char&)_Pnode->_Isnil);

  01a2c	48 8b 00	 mov	 rax, QWORD PTR [rax]

; 589  : 		}
; 590  : 
; 591  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 592  : 		{	// return reference to left pointer in node
; 593  : 		return ((_Nodepref)_Pnode->_Left);
; 594  : 		}
; 595  : 
; 596  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 597  : 		{	// return reference to parent pointer in node
; 598  : 		return ((_Nodepref)_Pnode->_Parent);
; 599  : 		}
; 600  : 
; 601  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 602  : 		{	// return reference to right pointer in node
; 603  : 		return ((_Nodepref)_Pnode->_Right);
; 604  : 		}
; 605  : 
; 606  : 	static reference _Myval(_Nodeptr _Pnode)
; 607  : 		{	// return reference to value in node
; 608  : 		return ((reference)_Pnode->_Myval);
; 609  : 		}
; 610  : 
; 611  : 	static _Nodeptr _Max(_Nodeptr _Pnode)
; 612  : 		{	// return rightmost node in subtree at _Pnode
; 613  : 		while (!_Isnil(_Right(_Pnode)))
; 614  : 			_Pnode = _Right(_Pnode);
; 615  : 		return (_Pnode);
; 616  : 		}
; 617  : 
; 618  : 	static _Nodeptr _Min(_Nodeptr _Pnode)
; 619  : 		{	// return leftmost node in subtree at _Pnode
; 620  : 		while (!_Isnil(_Left(_Pnode)))

  01a2f	80 78 19 00	 cmp	 BYTE PTR [rax+25], 0
  01a33	75 39		 jne	 SHORT $LN1631@tick
  01a35	66 66 66 0f 1f
	84 00 00 00 00
	00		 npad	 11
$LL1154@tick:

; 621  : 			_Pnode = _Left(_Pnode);

  01a40	48 8b d8	 mov	 rbx, rax

; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  :  #if _HAS_CPP0X
; 520  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 521  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 522  : 
; 523  :  #else /* _HAS_CPP0X */
; 524  : 	typedef typename _Alloc::template rebind<_Ty>::other _Alty;
; 525  :  #endif /* _HAS_CPP0X */
; 526  : 
; 527  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 528  : 		_Voidptr;
; 529  : 	typedef _Tree_node<typename _Alty::value_type,
; 530  : 		_Voidptr> _Node;
; 531  : 
; 532  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 533  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 534  : 	typedef _Nodeptr& _Nodepref;
; 535  : 
; 536  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 537  : 		_Tree_simple_types<typename _Alty::value_type>,
; 538  : 		_Tree_iter_types<typename _Alty::value_type,
; 539  : 			typename _Alty::size_type,
; 540  : 			typename _Alty::difference_type,
; 541  : 			typename _Alty::pointer,
; 542  : 			typename _Alty::const_pointer,
; 543  : 			typename _Alty::reference,
; 544  : 			typename _Alty::const_reference,
; 545  : 			_Nodeptr> >::type
; 546  : 		_Val_types;
; 547  : 	};
; 548  : 
; 549  : 		// TEMPLATE CLASS _Tree_val
; 550  : template<class _Val_types>
; 551  : 	class _Tree_val
; 552  : 		: public _Container_base
; 553  : 	{	// base class for tree to hold data
; 554  : public:
; 555  : 	typedef _Tree_val<_Val_types> _Myt;
; 556  : 
; 557  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 558  : 	typedef _Nodeptr& _Nodepref;
; 559  : 
; 560  : 	typedef typename _Val_types::value_type value_type;
; 561  : 	typedef typename _Val_types::size_type size_type;
; 562  : 	typedef typename _Val_types::difference_type difference_type;
; 563  : 	typedef typename _Val_types::pointer pointer;
; 564  : 	typedef typename _Val_types::const_pointer const_pointer;
; 565  : 	typedef typename _Val_types::reference reference;
; 566  : 	typedef typename _Val_types::const_reference const_reference;
; 567  : 
; 568  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 569  : 	typedef _Tree_iterator<_Myt> iterator;
; 570  : 
; 571  : 	_Tree_val()
; 572  : 		{	// initialize data
; 573  : 		this->_Myhead = 0;
; 574  : 		this->_Mysize = 0;
; 575  : 		}
; 576  : 
; 577  : 	enum _Redbl
; 578  : 		{	// colors for link to parent
; 579  : 		_Red, _Black};
; 580  : 
; 581  : 	static char& _Color(_Nodeptr _Pnode)
; 582  : 		{	// return reference to color in node
; 583  : 		return ((char&)_Pnode->_Color);
; 584  : 		}
; 585  : 
; 586  : 	static char& _Isnil(_Nodeptr _Pnode)
; 587  : 		{	// return reference to nil flag in node
; 588  : 		return ((char&)_Pnode->_Isnil);

  01a43	48 8b 00	 mov	 rax, QWORD PTR [rax]

; 589  : 		}
; 590  : 
; 591  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 592  : 		{	// return reference to left pointer in node
; 593  : 		return ((_Nodepref)_Pnode->_Left);
; 594  : 		}
; 595  : 
; 596  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 597  : 		{	// return reference to parent pointer in node
; 598  : 		return ((_Nodepref)_Pnode->_Parent);
; 599  : 		}
; 600  : 
; 601  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 602  : 		{	// return reference to right pointer in node
; 603  : 		return ((_Nodepref)_Pnode->_Right);
; 604  : 		}
; 605  : 
; 606  : 	static reference _Myval(_Nodeptr _Pnode)
; 607  : 		{	// return reference to value in node
; 608  : 		return ((reference)_Pnode->_Myval);
; 609  : 		}
; 610  : 
; 611  : 	static _Nodeptr _Max(_Nodeptr _Pnode)
; 612  : 		{	// return rightmost node in subtree at _Pnode
; 613  : 		while (!_Isnil(_Right(_Pnode)))
; 614  : 			_Pnode = _Right(_Pnode);
; 615  : 		return (_Pnode);
; 616  : 		}
; 617  : 
; 618  : 	static _Nodeptr _Min(_Nodeptr _Pnode)
; 619  : 		{	// return leftmost node in subtree at _Pnode
; 620  : 		while (!_Isnil(_Left(_Pnode)))

  01a46	80 78 19 00	 cmp	 BYTE PTR [rax+25], 0
  01a4a	74 f4		 je	 SHORT $LL1154@tick

; 65   : 		else

  01a4c	eb 20		 jmp	 SHORT $LN1631@tick
$LN1613@tick:

; 66   : 			{	// climb looking for right subtree
; 67   : 			_Nodeptr _Pnode;
; 68   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 69   : 				&& _Ptr == _Mytree::_Right(_Pnode))

  01a4e	48 8b 43 08	 mov	 rax, QWORD PTR [rbx+8]
  01a52	80 78 19 00	 cmp	 BYTE PTR [rax+25], 0
  01a56	75 13		 jne	 SHORT $LN1137@tick
$LL1138@tick:
  01a58	48 3b 58 10	 cmp	 rbx, QWORD PTR [rax+16]
  01a5c	75 0d		 jne	 SHORT $LN1137@tick

; 70   : 				_Ptr = _Pnode;	// ==> parent while right subtree

  01a5e	48 8b d8	 mov	 rbx, rax

; 66   : 			{	// climb looking for right subtree
; 67   : 			_Nodeptr _Pnode;
; 68   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 69   : 				&& _Ptr == _Mytree::_Right(_Pnode))

  01a61	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  01a65	80 78 19 00	 cmp	 BYTE PTR [rax+25], 0
  01a69	74 ed		 je	 SHORT $LL1138@tick
$LN1137@tick:

; 71   : 			_Ptr = _Pnode;	// ==> parent (head if end())

  01a6b	48 8b d8	 mov	 rbx, rax
$LN1631@tick:

; 336  : 		return (this->_Ptr == _Right._Ptr);

  01a6e	48 3b 1d 08 00
	00 00		 cmp	 rbx, QWORD PTR ?world@GlobalThread@@3VWorld@@A+8
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp

; 142  : 	for(map<ChunkPosition, std::shared_ptr<ChunkBase>>::const_iterator iter = GlobalThread::world.chunkMap.begin(); iter != GlobalThread::world.chunkMap.end(); ++iter)

  01a75	41 bf 00 00 00
	00		 mov	 r15d, 0
  01a7b	0f 85 ff fd ff
	ff		 jne	 $LL1139@tick
  01a81	4c 8b 65 18	 mov	 r12, QWORD PTR state$1$[rbp-256]
$LN14@tick:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 83   : 	return (_Check_C_return(_Mtx_unlock(_Mtx)));

  01a85	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?world@GlobalThread@@3VWorld@@A ; GlobalThread::world
  01a8c	e8 00 00 00 00	 call	 _Mtx_unlock

; 32   : 	if (_Res != _Thrd_success)

  01a91	85 c0		 test	 eax, eax
  01a93	74 07		 je	 SHORT $LN1348@tick

; 33   : 		_Throw_C_error(_Res);

  01a95	8b c8		 mov	 ecx, eax
  01a97	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
$LN1348@tick:
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp

; 158  : 	for(int i = 0; i < chunksToRender.size(); i++)

  01a9c	45 8b f7	 mov	 r14d, r15d
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector

; 1087 : 		return (this->_Mylast - this->_Myfirst);

  01a9f	4c 8b 7c 24 60	 mov	 r15, QWORD PTR chunksToRender$[rsp]
  01aa4	49 2b ff	 sub	 rdi, r15
  01aa7	48 c1 ff 04	 sar	 rdi, 4
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp

; 158  : 	for(int i = 0; i < chunksToRender.size(); i++)

  01aab	48 85 ff	 test	 rdi, rdi
  01aae	0f 84 57 01 00
	00		 je	 $LN8@tick
$LL10@tick:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 357  : 		_Reset(_Other._Ptr, _Other._Rep);

  01ab4	49 8b 5f 08	 mov	 rbx, QWORD PTR [r15+8]
  01ab8	49 8b 37	 mov	 rsi, QWORD PTR [r15]

; 358  : 		}
; 359  : 
; 360  : 	template<class _Ty2>
; 361  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, bool _Throw)
; 362  : 		{	// release resource and take ownership from weak_ptr _Other._Ptr
; 363  : 		_Reset(_Other._Ptr, _Other._Rep, _Throw);
; 364  : 		}
; 365  : 
; 366  : 	template<class _Ty2>
; 367  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Static_tag&)
; 368  : 		{	// release resource and take ownership of _Other._Ptr
; 369  : 		_Reset(static_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 370  : 		}
; 371  : 
; 372  : 	template<class _Ty2>
; 373  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Const_tag&)
; 374  : 		{	// release resource and take ownership of _Other._Ptr
; 375  : 		_Reset(const_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 376  : 		}
; 377  : 
; 378  : 	template<class _Ty2>
; 379  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Dynamic_tag&)
; 380  : 		{	// release resource and take ownership of _Other._Ptr
; 381  : 		_Elem *_Ptr = dynamic_cast<_Elem *>(_Other._Ptr);
; 382  : 		if (_Ptr)
; 383  : 			_Reset(_Ptr, _Other._Rep);
; 384  : 		else
; 385  : 			_Reset();
; 386  : 		}
; 387  : 
; 388  : 	template<class _Ty2>
; 389  : 		void _Reset(auto_ptr<_Ty2>&& _Other)
; 390  : 		{	// release resource and take _Other.get()
; 391  : 		_Ty2 *_Px = _Other.get();
; 392  : 		_Reset0(_Px, new _Ref_count<_Elem>(_Px));
; 393  : 		_Other.release();
; 394  : 		_Enable_shared(_Px, _Rep);
; 395  : 		}
; 396  : 
; 397  :  #if _HAS_CPP0X
; 398  : 	template<class _Ty2>
; 399  : 		void _Reset(_Ty *_Ptr, const _Ptr_base<_Ty2>& _Other)
; 400  : 		{	// release resource and alias _Ptr with _Other_rep
; 401  : 		_Reset(_Ptr, _Other._Rep);
; 402  : 		}
; 403  :  #endif /* _HAS_CPP0X */
; 404  : 
; 405  : 	void _Reset(_Ty *_Other_ptr, _Ref_count_base *_Other_rep)
; 406  : 		{	// release resource and take _Other_ptr through _Other_rep
; 407  : 		if (_Other_rep)

  01abb	48 85 db	 test	 rbx, rbx
  01abe	74 04		 je	 SHORT $LN1372@tick

; 108  : 		_MT_INCR(_Ignored, _Uses);

  01ac0	f0 ff 43 08	 lock inc DWORD PTR [rbx+8]
$LN1372@tick:

; 425  : 			_Rep->_Decref();
; 426  : 		_Rep = _Other_rep;

  01ac4	48 89 9d a0 00
	00 00		 mov	 QWORD PTR chunk$20[rbp-248], rbx

; 427  : 		_Ptr = _Other_ptr;

  01acb	48 89 b5 98 00
	00 00		 mov	 QWORD PTR chunk$20[rbp-256], rsi

; 428  : 		}
; 429  : 
; 430  : 	void _Decwref()
; 431  : 		{	// decrement weak reference count
; 432  : 		if (_Rep != 0)
; 433  : 			_Rep->_Decwref();
; 434  : 		}
; 435  : 
; 436  : 	void _Resetw()
; 437  : 		{	// release weak reference to resource
; 438  : 		_Resetw((_Elem *)0, 0);
; 439  : 		}
; 440  : 
; 441  : 	template<class _Ty2>
; 442  : 		void _Resetw(const _Ptr_base<_Ty2>& _Other)
; 443  : 		{	// release weak reference to resource and take _Other._Ptr
; 444  : 		_Resetw(_Other._Ptr, _Other._Rep);
; 445  : 		}
; 446  : 
; 447  : 	template<class _Ty2>
; 448  : 		void _Resetw(const _Ty2 *_Other_ptr, _Ref_count_base *_Other_rep)
; 449  : 		{	// point to _Other_ptr through _Other_rep
; 450  : 		_Resetw(const_cast<_Ty2*>(_Other_ptr), _Other_rep);
; 451  : 		}
; 452  : 
; 453  : 	template<class _Ty2>
; 454  : 		void _Resetw(_Ty2 *_Other_ptr, _Ref_count_base *_Other_rep)
; 455  : 		{	// point to _Other_ptr through _Other_rep
; 456  : 		if (_Other_rep)
; 457  : 			_Other_rep->_Incwref();
; 458  : 		if (_Rep != 0)
; 459  : 			_Rep->_Decwref();
; 460  : 		_Rep = _Other_rep;
; 461  : 		_Ptr = _Other_ptr;
; 462  : 		}
; 463  : 
; 464  : private:
; 465  : 	_Ty *_Ptr;
; 466  : 	_Ref_count_base *_Rep;
; 467  : 	template<class _Ty0>
; 468  : 		friend class _Ptr_base;
; 469  : 	};
; 470  : 
; 471  : 	// TEMPLATE CLASS shared_ptr
; 472  : template<class _Ty>
; 473  : 	class shared_ptr
; 474  : 		: public _Ptr_base<_Ty>
; 475  : 	{	// class for reference counted resource management
; 476  : public:
; 477  : 	typedef shared_ptr<_Ty> _Myt;
; 478  : 	typedef _Ptr_base<_Ty> _Mybase;
; 479  : 
; 480  : 	shared_ptr() _NOEXCEPT
; 481  : 		{	// construct empty shared_ptr object
; 482  : 		}
; 483  : 
; 484  : 	template<class _Ux>
; 485  : 		explicit shared_ptr(_Ux *_Px)
; 486  : 		{	// construct shared_ptr object that owns _Px
; 487  : 		_Resetp(_Px);
; 488  : 		}
; 489  : 
; 490  : 	template<class _Ux,
; 491  : 		class _Dx>
; 492  : 		shared_ptr(_Ux *_Px, _Dx _Dt)
; 493  : 		{	// construct with _Px, deleter
; 494  : 		_Resetp(_Px, _Dt);
; 495  : 		}
; 496  : 
; 497  : //#if _HAS_CPP0X
; 498  : 
; 499  : 	shared_ptr(nullptr_t)
; 500  : 		{	// construct with nullptr
; 501  : 		_Resetp((_Ty *)0);
; 502  : 		}
; 503  : 
; 504  : 	template<class _Dx>
; 505  : 		shared_ptr(nullptr_t, _Dx _Dt)
; 506  : 		{	// construct with nullptr, deleter
; 507  : 		_Resetp((_Ty *)0, _Dt);
; 508  : 		}
; 509  : 
; 510  : 	template<class _Dx,
; 511  : 		class _Alloc>
; 512  : 		shared_ptr(nullptr_t, _Dx _Dt, _Alloc _Ax)
; 513  : 		{	// construct with nullptr, deleter, allocator
; 514  : 		_Resetp((_Ty *)0, _Dt, _Ax);
; 515  : 		}
; 516  : 
; 517  : 	template<class _Ux,
; 518  : 		class _Dx,
; 519  : 		class _Alloc>
; 520  : 		shared_ptr(_Ux *_Px, _Dx _Dt, _Alloc _Ax)
; 521  : 		{	// construct with _Px, deleter, allocator
; 522  : 		_Resetp(_Px, _Dt, _Ax);
; 523  : 		}
; 524  : //#endif /* _HAS_CPP0X */
; 525  : 
; 526  :  #if _HAS_CPP0X
; 527  : 	template<class _Ty2>
; 528  : 		shared_ptr(const shared_ptr<_Ty2>& _Right, _Ty *_Px) _NOEXCEPT
; 529  : 		{	// construct shared_ptr object that aliases _Right
; 530  : 		this->_Reset(_Px, _Right);
; 531  : 		}
; 532  :  #endif /* _HAS_CPP0X */
; 533  : 
; 534  : 	shared_ptr(const _Myt& _Other) _NOEXCEPT
; 535  : 		{	// construct shared_ptr object that owns same resource as _Other
; 536  : 		this->_Reset(_Other);
; 537  : 		}
; 538  : 
; 539  : 	template<class _Ty2>
; 540  : 		shared_ptr(const shared_ptr<_Ty2>& _Other,
; 541  : 			typename enable_if<is_convertible<_Ty2 *, _Ty *>::value,
; 542  : 				void>::type ** = 0) _NOEXCEPT
; 543  : 		{	// construct shared_ptr object that owns same resource as _Other
; 544  : 		this->_Reset(_Other);
; 545  : 		}
; 546  : 
; 547  : 	template<class _Ty2>
; 548  : 		explicit shared_ptr(const weak_ptr<_Ty2>& _Other,
; 549  : 			bool _Throw = true)
; 550  : 		{	// construct shared_ptr object that owns resource *_Other
; 551  : 		this->_Reset(_Other, _Throw);
; 552  : 		}
; 553  : 
; 554  : 	template<class _Ty2>
; 555  : 		shared_ptr(auto_ptr<_Ty2>&& _Other)
; 556  : 		{	// construct shared_ptr object that owns *_Other.get()
; 557  : 		this->_Reset(_STD move(_Other));
; 558  : 		}
; 559  : 
; 560  : 	template<class _Ty2>
; 561  : 		shared_ptr(const shared_ptr<_Ty2>& _Other, const _Static_tag& _Tag)
; 562  : 		{	// construct shared_ptr object for static_pointer_cast
; 563  : 		this->_Reset(_Other, _Tag);
; 564  : 		}
; 565  : 
; 566  : 	template<class _Ty2>
; 567  : 		shared_ptr(const shared_ptr<_Ty2>& _Other, const _Const_tag& _Tag)
; 568  : 		{	// construct shared_ptr object for const_pointer_cast
; 569  : 		this->_Reset(_Other, _Tag);
; 570  : 		}
; 571  : 
; 572  : 	template<class _Ty2>
; 573  : 		shared_ptr(const shared_ptr<_Ty2>& _Other, const _Dynamic_tag& _Tag)
; 574  : 		{	// construct shared_ptr object for dynamic_pointer_cast
; 575  : 		this->_Reset(_Other, _Tag);
; 576  : 		}
; 577  : 
; 578  : 	shared_ptr(_Myt&& _Right) _NOEXCEPT
; 579  : 		: _Mybase(_STD forward<_Myt>(_Right))
; 580  : 		{	// construct shared_ptr object that takes resource from _Right
; 581  : 		}
; 582  : 
; 583  : 	template<class _Ty2>
; 584  : 		shared_ptr(shared_ptr<_Ty2>&& _Right,
; 585  : 			typename enable_if<is_convertible<_Ty2 *, _Ty *>::value,
; 586  : 				void>::type ** = 0) _NOEXCEPT
; 587  : 		: _Mybase(_STD forward<shared_ptr<_Ty2> >(_Right))
; 588  : 		{	// construct shared_ptr object that takes resource from _Right
; 589  : 		}
; 590  : 
; 591  :  #if _HAS_CPP0X
; 592  : 	template<class _Ux,
; 593  : 		class _Dx>
; 594  : 		shared_ptr(unique_ptr<_Ux, _Dx>&& _Right)
; 595  : 		{	// construct from unique_ptr
; 596  : 		_Resetp(_Right.release(), _Right.get_deleter());
; 597  : 		}
; 598  : 
; 599  : 	template<class _Ux,
; 600  : 		class _Dx>
; 601  : 		_Myt& operator=(unique_ptr<_Ux, _Dx>&& _Right)
; 602  : 		{	// move from unique_ptr
; 603  : 		shared_ptr(_STD move(_Right)).swap(*this);
; 604  : 		return (*this);
; 605  : 		}
; 606  :  #endif /* _HAS_CPP0X */
; 607  : 
; 608  : 	_Myt& operator=(_Myt&& _Right) _NOEXCEPT
; 609  : 		{	// construct shared_ptr object that takes resource from _Right
; 610  : 		shared_ptr(_STD move(_Right)).swap(*this);
; 611  : 		return (*this);
; 612  : 		}
; 613  : 
; 614  : 	template<class _Ty2>
; 615  : 		_Myt& operator=(shared_ptr<_Ty2>&& _Right) _NOEXCEPT
; 616  : 		{	// construct shared_ptr object that takes resource from _Right
; 617  : 		shared_ptr(_STD move(_Right)).swap(*this);
; 618  : 		return (*this);
; 619  : 		}
; 620  : 
; 621  : 	~shared_ptr() _NOEXCEPT
; 622  : 		{	// release resource
; 623  : 		this->_Decref();
; 624  : 		}
; 625  : 
; 626  : 	_Myt& operator=(const _Myt& _Right) _NOEXCEPT
; 627  : 		{	// assign shared ownership of resource owned by _Right
; 628  : 		shared_ptr(_Right).swap(*this);
; 629  : 		return (*this);
; 630  : 		}
; 631  : 
; 632  : 	template<class _Ty2>
; 633  : 		_Myt& operator=(const shared_ptr<_Ty2>& _Right) _NOEXCEPT
; 634  : 		{	// assign shared ownership of resource owned by _Right
; 635  : 		shared_ptr(_Right).swap(*this);
; 636  : 		return (*this);
; 637  : 		}
; 638  : 
; 639  : 	template<class _Ty2>
; 640  : 		_Myt& operator=(auto_ptr<_Ty2>&& _Right)
; 641  : 		{	// assign ownership of resource pointed to by _Right
; 642  : 		shared_ptr(_STD move(_Right)).swap(*this);
; 643  : 		return (*this);
; 644  : 		}
; 645  : 
; 646  : 	void reset() _NOEXCEPT
; 647  : 		{	// release resource and convert to empty shared_ptr object
; 648  : 		shared_ptr().swap(*this);
; 649  : 		}
; 650  : 
; 651  : 	template<class _Ux>
; 652  : 		void reset(_Ux *_Px)
; 653  : 		{	// release, take ownership of _Px
; 654  : 		shared_ptr(_Px).swap(*this);
; 655  : 		}
; 656  : 
; 657  : 	template<class _Ux,
; 658  : 		class _Dx>
; 659  : 		void reset(_Ux *_Px, _Dx _Dt)
; 660  : 		{	// release, take ownership of _Px, with deleter _Dt
; 661  : 		shared_ptr(_Px, _Dt).swap(*this);
; 662  : 		}
; 663  : 
; 664  : //#if _HAS_CPP0X
; 665  : 	template<class _Ux,
; 666  : 		class _Dx,
; 667  : 		class _Alloc>
; 668  : 		void reset(_Ux *_Px, _Dx _Dt, _Alloc _Ax)
; 669  : 		{	// release, take ownership of _Px, with deleter _Dt, allocator _Ax
; 670  : 		shared_ptr(_Px, _Dt, _Ax).swap(*this);
; 671  : 		}
; 672  : //#endif /* _HAS_CPP0X */
; 673  : 
; 674  : 	void swap(_Myt& _Other) _NOEXCEPT
; 675  : 		{	// swap pointers
; 676  : 		this->_Swap(_Other);
; 677  : 		}
; 678  : 
; 679  : 	_Ty *get() const _NOEXCEPT
; 680  : 		{	// return pointer to resource
; 681  : 		return (this->_Get());
; 682  : 		}
; 683  : 
; 684  : 	typename add_reference<_Ty>::type operator*() const _NOEXCEPT
; 685  : 		{	// return reference to resource
; 686  : 		return (*this->_Get());
; 687  : 		}
; 688  : 
; 689  : 	_Ty *operator->() const _NOEXCEPT
; 690  : 		{	// return pointer to resource
; 691  : 		return (this->_Get());
; 692  : 		}
; 693  : 
; 694  : 	bool unique() const _NOEXCEPT
; 695  : 		{	// return true if no other shared_ptr object owns this resource
; 696  : 		return (this->use_count() == 1);
; 697  : 		}
; 698  : 
; 699  : 	_TYPEDEF_BOOL_TYPE;
; 700  : 
; 701  : 	_OPERATOR_BOOL() const _NOEXCEPT
; 702  : 		{	// test if shared_ptr object owns no resource
; 703  : 		return (this->_Get() != 0 ? _CONVERTIBLE_TO_TRUE : 0);

  01ad2	48 83 7e 38 00	 cmp	 QWORD PTR [rsi+56], 0
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp

; 162  : 		if(chunk->firstPass != nullptr)

  01ad7	0f 84 f9 00 00
	00		 je	 $LN7@tick

; 164  : 			gfxu::Uniforms::MMS.push(geom::Matrix::translate(chunk->pos.x * 16, chunk->pos.y * 16, chunk->pos.z * 16));

  01add	8b 46 20	 mov	 eax, DWORD PTR [rsi+32]
  01ae0	c1 e0 04	 shl	 eax, 4
  01ae3	66 0f 6e d0	 movd	 xmm2, eax
  01ae7	0f 5b d2	 cvtdq2ps xmm2, xmm2
  01aea	8b 46 1c	 mov	 eax, DWORD PTR [rsi+28]
  01aed	c1 e0 04	 shl	 eax, 4
  01af0	66 0f 6e c8	 movd	 xmm1, eax
  01af4	0f 5b c9	 cvtdq2ps xmm1, xmm1
  01af7	8b 46 18	 mov	 eax, DWORD PTR [rsi+24]
  01afa	c1 e0 04	 shl	 eax, 4
  01afd	66 0f 6e c0	 movd	 xmm0, eax
  01b01	0f 5b c0	 cvtdq2ps xmm0, xmm0
; File c:\users\glenn\documents\github\wind\project\wind\wind\geometry.cpp

; 143  : 		data[i] = 0.0f;

  01b04	33 c0		 xor	 eax, eax
  01b06	48 89 85 c0 03
	00 00		 mov	 QWORD PTR $T37[rbp-256], rax
  01b0d	48 89 85 c8 03
	00 00		 mov	 QWORD PTR $T37[rbp-248], rax
  01b14	48 89 85 d0 03
	00 00		 mov	 QWORD PTR $T37[rbp-240], rax
  01b1b	48 89 85 d8 03
	00 00		 mov	 QWORD PTR $T37[rbp-232], rax
  01b22	48 89 85 e0 03
	00 00		 mov	 QWORD PTR $T37[rbp-224], rax
  01b29	48 89 85 e8 03
	00 00		 mov	 QWORD PTR $T37[rbp-216], rax
  01b30	48 89 85 f0 03
	00 00		 mov	 QWORD PTR $T37[rbp-208], rax
  01b37	48 89 85 f8 03
	00 00		 mov	 QWORD PTR $T37[rbp-200], rax

; 144  : 	}
; 145  : }
; 146  : 
; 147  : Matrix::Matrix(float* data)
; 148  : {
; 149  : 	for(int i = 0; i < 16; i++)
; 150  : 	{
; 151  : 		this->data[i] = data[i];
; 152  : 	}
; 153  : }
; 154  : 
; 155  : const float& Matrix::operator[](int index) const
; 156  : {
; 157  : 	return data[index];
; 158  : }
; 159  : 
; 160  : float& Matrix::operator[](int index)
; 161  : {
; 162  : 	return data[index];
; 163  : }
; 164  : 
; 165  : 
; 166  : Matrix Matrix::operator*(const Matrix& mat) const
; 167  : {
; 168  : 	Matrix result;
; 169  : 
; 170  : 	for(int i = 0; i < 4; i++)
; 171  : 	{
; 172  : 		for(int j = 0; j < 4; j++)
; 173  : 		{
; 174  : 			float value = 0.0f;
; 175  : 			for(int k = 0; k < 4; k++)
; 176  : 			{
; 177  : 				value += data[index(k, j)] * mat.data[index(i, k)];
; 178  : 			}
; 179  : 			result[index(i, j)] = value;
; 180  : 		}
; 181  : 	}
; 182  : 
; 183  : 	return result;
; 184  : }
; 185  : 
; 186  : Matrix Matrix::operator*(const float& scalar) const
; 187  : {
; 188  : 	Matrix result;
; 189  : 
; 190  : 	for(int i = 0; i < 16; i++)
; 191  : 	{
; 192  : 		result[i] = data[i] * scalar;
; 193  : 	}
; 194  : 
; 195  : 	return result;
; 196  : }
; 197  : 
; 198  : Vector Matrix::operator*(const Vector& vert) const
; 199  : {
; 200  : 	Vector result;
; 201  : 
; 202  : 	result.x = vert.x * data[0] + vert.y * data[1] + vert.z * data[2] + vert.w * data[3];
; 203  : 	result.y = vert.x * data[4] + vert.y * data[5] + vert.z * data[6] + vert.w * data[7];
; 204  : 	result.z = vert.x * data[8] + vert.y * data[9] + vert.z * data[10] + vert.w * data[11];
; 205  : 	result.w = vert.x * data[12] + vert.y * data[13] + vert.z * data[14] + vert.w * data[15];
; 206  : 
; 207  : 	return result;
; 208  : }
; 209  : 
; 210  : Matrix& Matrix::operator=(const Matrix& mat)
; 211  : {
; 212  : 	for(int i = 0; i < 16; i++)
; 213  : 	{
; 214  : 		data[i] = mat.data[i];
; 215  : 	}
; 216  : 
; 217  : 	return *this;
; 218  : }
; 219  : 
; 220  : Matrix Matrix::identity()
; 221  : {
; 222  : 	Matrix result;
; 223  : 	result[0] = 1.0f;

  01b3e	c7 85 c0 03 00
	00 00 00 80 3f	 mov	 DWORD PTR $T37[rbp-256], 1065353216 ; 3f800000H

; 224  : 	result[5] = 1.0f;

  01b48	c7 85 d4 03 00
	00 00 00 80 3f	 mov	 DWORD PTR $T37[rbp-236], 1065353216 ; 3f800000H

; 225  : 	result[10] = 1.0f;

  01b52	c7 85 e8 03 00
	00 00 00 80 3f	 mov	 DWORD PTR $T37[rbp-216], 1065353216 ; 3f800000H

; 226  : 	result[15] = 1.0f;

  01b5c	c7 85 fc 03 00
	00 00 00 80 3f	 mov	 DWORD PTR $T37[rbp-196], 1065353216 ; 3f800000H

; 238  : 
; 239  : 	return result;
; 240  : }
; 241  : 
; 242  : Matrix Matrix::translate(float x, float y, float z)
; 243  : {
; 244  : 	Matrix result = identity();
; 245  : 	result[3] = x;

  01b66	f3 0f 11 85 cc
	03 00 00	 movss	 DWORD PTR $T37[rbp-244], xmm0

; 246  : 	result[7] = y;

  01b6e	f3 0f 11 8d dc
	03 00 00	 movss	 DWORD PTR $T37[rbp-228], xmm1

; 247  : 	result[11] = z;

  01b76	f3 0f 11 95 ec
	03 00 00	 movss	 DWORD PTR $T37[rbp-212], xmm2
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp

; 164  : 			gfxu::Uniforms::MMS.push(geom::Matrix::translate(chunk->pos.x * 16, chunk->pos.y * 16, chunk->pos.z * 16));

  01b7e	0f 28 85 c0 03
	00 00		 movaps	 xmm0, XMMWORD PTR $T37[rbp-256]
  01b85	0f 29 85 d0 02
	00 00		 movaps	 XMMWORD PTR $T32[rbp-256], xmm0
  01b8c	0f 28 8d d0 03
	00 00		 movaps	 xmm1, XMMWORD PTR $T37[rbp-240]
  01b93	0f 29 8d e0 02
	00 00		 movaps	 XMMWORD PTR $T32[rbp-240], xmm1
  01b9a	0f 28 85 e0 03
	00 00		 movaps	 xmm0, XMMWORD PTR $T37[rbp-224]
  01ba1	0f 29 85 f0 02
	00 00		 movaps	 XMMWORD PTR $T32[rbp-224], xmm0
  01ba8	0f 28 8d f0 03
	00 00		 movaps	 xmm1, XMMWORD PTR $T37[rbp-208]
  01baf	0f 29 8d 00 03
	00 00		 movaps	 XMMWORD PTR $T32[rbp-208], xmm1
  01bb6	48 8d 95 d0 02
	00 00		 lea	 rdx, QWORD PTR $T32[rbp-256]
  01bbd	e8 00 00 00 00	 call	 ?push@MatrixStack@gfxu@@QEAAXVMatrix@geom@@@Z ; gfxu::MatrixStack::push

; 165  : 			chunk->firstPass->draw();

  01bc2	ba 04 00 00 00	 mov	 edx, 4
  01bc7	48 8b 4e 38	 mov	 rcx, QWORD PTR [rsi+56]
  01bcb	e8 00 00 00 00	 call	 ?draw@VertexStream@gfxu@@QEAAXI@Z ; gfxu::VertexStream::draw

; 166  : 			gfxu::Uniforms::MMS.pop();

  01bd0	e8 00 00 00 00	 call	 ?pop@MatrixStack@gfxu@@QEAAXXZ ; gfxu::MatrixStack::pop
  01bd5	90		 npad	 1
$LN7@tick:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  01bd6	48 85 db	 test	 rbx, rbx
  01bd9	74 1d		 je	 SHORT $LN9@tick

; 109  : 		}
; 110  : 
; 111  : 	void _Incwref()
; 112  : 		{	// increment weak reference count
; 113  : 		_MT_INCR(_Ignored, _Weaks);
; 114  : 		}
; 115  : 
; 116  : 	void _Decref()
; 117  : 		{	// decrement use count
; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  01bdb	f0 ff 4b 08	 lock dec DWORD PTR [rbx+8]
  01bdf	75 17		 jne	 SHORT $LN9@tick

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  01be1	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  01be4	48 8b cb	 mov	 rcx, rbx
  01be7	ff 10		 call	 QWORD PTR [rax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  01be9	f0 ff 4b 0c	 lock dec DWORD PTR [rbx+12]
  01bed	75 09		 jne	 SHORT $LN9@tick

; 128  : 			_Delete_this();

  01bef	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  01bf2	48 8b cb	 mov	 rcx, rbx
  01bf5	ff 50 08	 call	 QWORD PTR [rax+8]
$LN9@tick:
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp

; 158  : 	for(int i = 0; i < chunksToRender.size(); i++)

  01bf8	41 ff c6	 inc	 r14d
  01bfb	49 83 c7 10	 add	 r15, 16
  01bff	49 63 c6	 movsxd	 rax, r14d
  01c02	48 3b c7	 cmp	 rax, rdi
  01c05	0f 82 a9 fe ff
	ff		 jb	 $LL10@tick
$LN8@tick:

; 167  : 		}
; 168  : 	}
; 169  : 
; 170  : 	glEnable(GL_BLEND);

  01c0b	b9 e2 0b 00 00	 mov	 ecx, 3042		; 00000be2H
  01c10	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_glEnable

; 171  : 	for(int i = 0; i < chunksToRender.size(); i++)

  01c16	33 c9		 xor	 ecx, ecx
  01c18	44 8b f9	 mov	 r15d, ecx
  01c1b	48 85 ff	 test	 rdi, rdi
  01c1e	0f 84 63 01 00
	00		 je	 $LN4@tick

; 167  : 		}
; 168  : 	}
; 169  : 
; 170  : 	glEnable(GL_BLEND);

  01c24	4c 8b 74 24 60	 mov	 r14, QWORD PTR chunksToRender$[rsp]
  01c29	0f 1f 80 00 00
	00 00		 npad	 7
$LL6@tick:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 357  : 		_Reset(_Other._Ptr, _Other._Rep);

  01c30	49 8b 5e 08	 mov	 rbx, QWORD PTR [r14+8]
  01c34	49 8b 36	 mov	 rsi, QWORD PTR [r14]

; 358  : 		}
; 359  : 
; 360  : 	template<class _Ty2>
; 361  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, bool _Throw)
; 362  : 		{	// release resource and take ownership from weak_ptr _Other._Ptr
; 363  : 		_Reset(_Other._Ptr, _Other._Rep, _Throw);
; 364  : 		}
; 365  : 
; 366  : 	template<class _Ty2>
; 367  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Static_tag&)
; 368  : 		{	// release resource and take ownership of _Other._Ptr
; 369  : 		_Reset(static_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 370  : 		}
; 371  : 
; 372  : 	template<class _Ty2>
; 373  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Const_tag&)
; 374  : 		{	// release resource and take ownership of _Other._Ptr
; 375  : 		_Reset(const_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 376  : 		}
; 377  : 
; 378  : 	template<class _Ty2>
; 379  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Dynamic_tag&)
; 380  : 		{	// release resource and take ownership of _Other._Ptr
; 381  : 		_Elem *_Ptr = dynamic_cast<_Elem *>(_Other._Ptr);
; 382  : 		if (_Ptr)
; 383  : 			_Reset(_Ptr, _Other._Rep);
; 384  : 		else
; 385  : 			_Reset();
; 386  : 		}
; 387  : 
; 388  : 	template<class _Ty2>
; 389  : 		void _Reset(auto_ptr<_Ty2>&& _Other)
; 390  : 		{	// release resource and take _Other.get()
; 391  : 		_Ty2 *_Px = _Other.get();
; 392  : 		_Reset0(_Px, new _Ref_count<_Elem>(_Px));
; 393  : 		_Other.release();
; 394  : 		_Enable_shared(_Px, _Rep);
; 395  : 		}
; 396  : 
; 397  :  #if _HAS_CPP0X
; 398  : 	template<class _Ty2>
; 399  : 		void _Reset(_Ty *_Ptr, const _Ptr_base<_Ty2>& _Other)
; 400  : 		{	// release resource and alias _Ptr with _Other_rep
; 401  : 		_Reset(_Ptr, _Other._Rep);
; 402  : 		}
; 403  :  #endif /* _HAS_CPP0X */
; 404  : 
; 405  : 	void _Reset(_Ty *_Other_ptr, _Ref_count_base *_Other_rep)
; 406  : 		{	// release resource and take _Other_ptr through _Other_rep
; 407  : 		if (_Other_rep)

  01c37	48 85 db	 test	 rbx, rbx
  01c3a	74 04		 je	 SHORT $LN1458@tick

; 108  : 		_MT_INCR(_Ignored, _Uses);

  01c3c	f0 ff 43 08	 lock inc DWORD PTR [rbx+8]
$LN1458@tick:

; 425  : 			_Rep->_Decref();
; 426  : 		_Rep = _Other_rep;

  01c40	48 89 9d 80 00
	00 00		 mov	 QWORD PTR chunk$17[rbp-248], rbx

; 427  : 		_Ptr = _Other_ptr;

  01c47	48 89 75 78	 mov	 QWORD PTR chunk$17[rbp-256], rsi

; 428  : 		}
; 429  : 
; 430  : 	void _Decwref()
; 431  : 		{	// decrement weak reference count
; 432  : 		if (_Rep != 0)
; 433  : 			_Rep->_Decwref();
; 434  : 		}
; 435  : 
; 436  : 	void _Resetw()
; 437  : 		{	// release weak reference to resource
; 438  : 		_Resetw((_Elem *)0, 0);
; 439  : 		}
; 440  : 
; 441  : 	template<class _Ty2>
; 442  : 		void _Resetw(const _Ptr_base<_Ty2>& _Other)
; 443  : 		{	// release weak reference to resource and take _Other._Ptr
; 444  : 		_Resetw(_Other._Ptr, _Other._Rep);
; 445  : 		}
; 446  : 
; 447  : 	template<class _Ty2>
; 448  : 		void _Resetw(const _Ty2 *_Other_ptr, _Ref_count_base *_Other_rep)
; 449  : 		{	// point to _Other_ptr through _Other_rep
; 450  : 		_Resetw(const_cast<_Ty2*>(_Other_ptr), _Other_rep);
; 451  : 		}
; 452  : 
; 453  : 	template<class _Ty2>
; 454  : 		void _Resetw(_Ty2 *_Other_ptr, _Ref_count_base *_Other_rep)
; 455  : 		{	// point to _Other_ptr through _Other_rep
; 456  : 		if (_Other_rep)
; 457  : 			_Other_rep->_Incwref();
; 458  : 		if (_Rep != 0)
; 459  : 			_Rep->_Decwref();
; 460  : 		_Rep = _Other_rep;
; 461  : 		_Ptr = _Other_ptr;
; 462  : 		}
; 463  : 
; 464  : private:
; 465  : 	_Ty *_Ptr;
; 466  : 	_Ref_count_base *_Rep;
; 467  : 	template<class _Ty0>
; 468  : 		friend class _Ptr_base;
; 469  : 	};
; 470  : 
; 471  : 	// TEMPLATE CLASS shared_ptr
; 472  : template<class _Ty>
; 473  : 	class shared_ptr
; 474  : 		: public _Ptr_base<_Ty>
; 475  : 	{	// class for reference counted resource management
; 476  : public:
; 477  : 	typedef shared_ptr<_Ty> _Myt;
; 478  : 	typedef _Ptr_base<_Ty> _Mybase;
; 479  : 
; 480  : 	shared_ptr() _NOEXCEPT
; 481  : 		{	// construct empty shared_ptr object
; 482  : 		}
; 483  : 
; 484  : 	template<class _Ux>
; 485  : 		explicit shared_ptr(_Ux *_Px)
; 486  : 		{	// construct shared_ptr object that owns _Px
; 487  : 		_Resetp(_Px);
; 488  : 		}
; 489  : 
; 490  : 	template<class _Ux,
; 491  : 		class _Dx>
; 492  : 		shared_ptr(_Ux *_Px, _Dx _Dt)
; 493  : 		{	// construct with _Px, deleter
; 494  : 		_Resetp(_Px, _Dt);
; 495  : 		}
; 496  : 
; 497  : //#if _HAS_CPP0X
; 498  : 
; 499  : 	shared_ptr(nullptr_t)
; 500  : 		{	// construct with nullptr
; 501  : 		_Resetp((_Ty *)0);
; 502  : 		}
; 503  : 
; 504  : 	template<class _Dx>
; 505  : 		shared_ptr(nullptr_t, _Dx _Dt)
; 506  : 		{	// construct with nullptr, deleter
; 507  : 		_Resetp((_Ty *)0, _Dt);
; 508  : 		}
; 509  : 
; 510  : 	template<class _Dx,
; 511  : 		class _Alloc>
; 512  : 		shared_ptr(nullptr_t, _Dx _Dt, _Alloc _Ax)
; 513  : 		{	// construct with nullptr, deleter, allocator
; 514  : 		_Resetp((_Ty *)0, _Dt, _Ax);
; 515  : 		}
; 516  : 
; 517  : 	template<class _Ux,
; 518  : 		class _Dx,
; 519  : 		class _Alloc>
; 520  : 		shared_ptr(_Ux *_Px, _Dx _Dt, _Alloc _Ax)
; 521  : 		{	// construct with _Px, deleter, allocator
; 522  : 		_Resetp(_Px, _Dt, _Ax);
; 523  : 		}
; 524  : //#endif /* _HAS_CPP0X */
; 525  : 
; 526  :  #if _HAS_CPP0X
; 527  : 	template<class _Ty2>
; 528  : 		shared_ptr(const shared_ptr<_Ty2>& _Right, _Ty *_Px) _NOEXCEPT
; 529  : 		{	// construct shared_ptr object that aliases _Right
; 530  : 		this->_Reset(_Px, _Right);
; 531  : 		}
; 532  :  #endif /* _HAS_CPP0X */
; 533  : 
; 534  : 	shared_ptr(const _Myt& _Other) _NOEXCEPT
; 535  : 		{	// construct shared_ptr object that owns same resource as _Other
; 536  : 		this->_Reset(_Other);
; 537  : 		}
; 538  : 
; 539  : 	template<class _Ty2>
; 540  : 		shared_ptr(const shared_ptr<_Ty2>& _Other,
; 541  : 			typename enable_if<is_convertible<_Ty2 *, _Ty *>::value,
; 542  : 				void>::type ** = 0) _NOEXCEPT
; 543  : 		{	// construct shared_ptr object that owns same resource as _Other
; 544  : 		this->_Reset(_Other);
; 545  : 		}
; 546  : 
; 547  : 	template<class _Ty2>
; 548  : 		explicit shared_ptr(const weak_ptr<_Ty2>& _Other,
; 549  : 			bool _Throw = true)
; 550  : 		{	// construct shared_ptr object that owns resource *_Other
; 551  : 		this->_Reset(_Other, _Throw);
; 552  : 		}
; 553  : 
; 554  : 	template<class _Ty2>
; 555  : 		shared_ptr(auto_ptr<_Ty2>&& _Other)
; 556  : 		{	// construct shared_ptr object that owns *_Other.get()
; 557  : 		this->_Reset(_STD move(_Other));
; 558  : 		}
; 559  : 
; 560  : 	template<class _Ty2>
; 561  : 		shared_ptr(const shared_ptr<_Ty2>& _Other, const _Static_tag& _Tag)
; 562  : 		{	// construct shared_ptr object for static_pointer_cast
; 563  : 		this->_Reset(_Other, _Tag);
; 564  : 		}
; 565  : 
; 566  : 	template<class _Ty2>
; 567  : 		shared_ptr(const shared_ptr<_Ty2>& _Other, const _Const_tag& _Tag)
; 568  : 		{	// construct shared_ptr object for const_pointer_cast
; 569  : 		this->_Reset(_Other, _Tag);
; 570  : 		}
; 571  : 
; 572  : 	template<class _Ty2>
; 573  : 		shared_ptr(const shared_ptr<_Ty2>& _Other, const _Dynamic_tag& _Tag)
; 574  : 		{	// construct shared_ptr object for dynamic_pointer_cast
; 575  : 		this->_Reset(_Other, _Tag);
; 576  : 		}
; 577  : 
; 578  : 	shared_ptr(_Myt&& _Right) _NOEXCEPT
; 579  : 		: _Mybase(_STD forward<_Myt>(_Right))
; 580  : 		{	// construct shared_ptr object that takes resource from _Right
; 581  : 		}
; 582  : 
; 583  : 	template<class _Ty2>
; 584  : 		shared_ptr(shared_ptr<_Ty2>&& _Right,
; 585  : 			typename enable_if<is_convertible<_Ty2 *, _Ty *>::value,
; 586  : 				void>::type ** = 0) _NOEXCEPT
; 587  : 		: _Mybase(_STD forward<shared_ptr<_Ty2> >(_Right))
; 588  : 		{	// construct shared_ptr object that takes resource from _Right
; 589  : 		}
; 590  : 
; 591  :  #if _HAS_CPP0X
; 592  : 	template<class _Ux,
; 593  : 		class _Dx>
; 594  : 		shared_ptr(unique_ptr<_Ux, _Dx>&& _Right)
; 595  : 		{	// construct from unique_ptr
; 596  : 		_Resetp(_Right.release(), _Right.get_deleter());
; 597  : 		}
; 598  : 
; 599  : 	template<class _Ux,
; 600  : 		class _Dx>
; 601  : 		_Myt& operator=(unique_ptr<_Ux, _Dx>&& _Right)
; 602  : 		{	// move from unique_ptr
; 603  : 		shared_ptr(_STD move(_Right)).swap(*this);
; 604  : 		return (*this);
; 605  : 		}
; 606  :  #endif /* _HAS_CPP0X */
; 607  : 
; 608  : 	_Myt& operator=(_Myt&& _Right) _NOEXCEPT
; 609  : 		{	// construct shared_ptr object that takes resource from _Right
; 610  : 		shared_ptr(_STD move(_Right)).swap(*this);
; 611  : 		return (*this);
; 612  : 		}
; 613  : 
; 614  : 	template<class _Ty2>
; 615  : 		_Myt& operator=(shared_ptr<_Ty2>&& _Right) _NOEXCEPT
; 616  : 		{	// construct shared_ptr object that takes resource from _Right
; 617  : 		shared_ptr(_STD move(_Right)).swap(*this);
; 618  : 		return (*this);
; 619  : 		}
; 620  : 
; 621  : 	~shared_ptr() _NOEXCEPT
; 622  : 		{	// release resource
; 623  : 		this->_Decref();
; 624  : 		}
; 625  : 
; 626  : 	_Myt& operator=(const _Myt& _Right) _NOEXCEPT
; 627  : 		{	// assign shared ownership of resource owned by _Right
; 628  : 		shared_ptr(_Right).swap(*this);
; 629  : 		return (*this);
; 630  : 		}
; 631  : 
; 632  : 	template<class _Ty2>
; 633  : 		_Myt& operator=(const shared_ptr<_Ty2>& _Right) _NOEXCEPT
; 634  : 		{	// assign shared ownership of resource owned by _Right
; 635  : 		shared_ptr(_Right).swap(*this);
; 636  : 		return (*this);
; 637  : 		}
; 638  : 
; 639  : 	template<class _Ty2>
; 640  : 		_Myt& operator=(auto_ptr<_Ty2>&& _Right)
; 641  : 		{	// assign ownership of resource pointed to by _Right
; 642  : 		shared_ptr(_STD move(_Right)).swap(*this);
; 643  : 		return (*this);
; 644  : 		}
; 645  : 
; 646  : 	void reset() _NOEXCEPT
; 647  : 		{	// release resource and convert to empty shared_ptr object
; 648  : 		shared_ptr().swap(*this);
; 649  : 		}
; 650  : 
; 651  : 	template<class _Ux>
; 652  : 		void reset(_Ux *_Px)
; 653  : 		{	// release, take ownership of _Px
; 654  : 		shared_ptr(_Px).swap(*this);
; 655  : 		}
; 656  : 
; 657  : 	template<class _Ux,
; 658  : 		class _Dx>
; 659  : 		void reset(_Ux *_Px, _Dx _Dt)
; 660  : 		{	// release, take ownership of _Px, with deleter _Dt
; 661  : 		shared_ptr(_Px, _Dt).swap(*this);
; 662  : 		}
; 663  : 
; 664  : //#if _HAS_CPP0X
; 665  : 	template<class _Ux,
; 666  : 		class _Dx,
; 667  : 		class _Alloc>
; 668  : 		void reset(_Ux *_Px, _Dx _Dt, _Alloc _Ax)
; 669  : 		{	// release, take ownership of _Px, with deleter _Dt, allocator _Ax
; 670  : 		shared_ptr(_Px, _Dt, _Ax).swap(*this);
; 671  : 		}
; 672  : //#endif /* _HAS_CPP0X */
; 673  : 
; 674  : 	void swap(_Myt& _Other) _NOEXCEPT
; 675  : 		{	// swap pointers
; 676  : 		this->_Swap(_Other);
; 677  : 		}
; 678  : 
; 679  : 	_Ty *get() const _NOEXCEPT
; 680  : 		{	// return pointer to resource
; 681  : 		return (this->_Get());
; 682  : 		}
; 683  : 
; 684  : 	typename add_reference<_Ty>::type operator*() const _NOEXCEPT
; 685  : 		{	// return reference to resource
; 686  : 		return (*this->_Get());
; 687  : 		}
; 688  : 
; 689  : 	_Ty *operator->() const _NOEXCEPT
; 690  : 		{	// return pointer to resource
; 691  : 		return (this->_Get());
; 692  : 		}
; 693  : 
; 694  : 	bool unique() const _NOEXCEPT
; 695  : 		{	// return true if no other shared_ptr object owns this resource
; 696  : 		return (this->use_count() == 1);
; 697  : 		}
; 698  : 
; 699  : 	_TYPEDEF_BOOL_TYPE;
; 700  : 
; 701  : 	_OPERATOR_BOOL() const _NOEXCEPT
; 702  : 		{	// test if shared_ptr object owns no resource
; 703  : 		return (this->_Get() != 0 ? _CONVERTIBLE_TO_TRUE : 0);

  01c4b	48 83 7e 48 00	 cmp	 QWORD PTR [rsi+72], 0
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp

; 175  : 		if(chunk->secondPass != nullptr)

  01c50	0f 84 f7 00 00
	00		 je	 $LN3@tick

; 177  : 			gfxu::Uniforms::MMS.push(geom::Matrix::translate(chunk->pos.x * 16, chunk->pos.y * 16, chunk->pos.z * 16));

  01c56	8b 46 20	 mov	 eax, DWORD PTR [rsi+32]
  01c59	c1 e0 04	 shl	 eax, 4
  01c5c	66 0f 6e d0	 movd	 xmm2, eax
  01c60	0f 5b d2	 cvtdq2ps xmm2, xmm2
  01c63	8b 46 1c	 mov	 eax, DWORD PTR [rsi+28]
  01c66	c1 e0 04	 shl	 eax, 4
  01c69	66 0f 6e c8	 movd	 xmm1, eax
  01c6d	0f 5b c9	 cvtdq2ps xmm1, xmm1
  01c70	8b 46 18	 mov	 eax, DWORD PTR [rsi+24]
  01c73	c1 e0 04	 shl	 eax, 4
  01c76	66 0f 6e c0	 movd	 xmm0, eax
  01c7a	0f 5b c0	 cvtdq2ps xmm0, xmm0
; File c:\users\glenn\documents\github\wind\project\wind\wind\geometry.cpp

; 143  : 		data[i] = 0.0f;

  01c7d	48 89 8d 40 03
	00 00		 mov	 QWORD PTR $T35[rbp-256], rcx
  01c84	48 89 8d 48 03
	00 00		 mov	 QWORD PTR $T35[rbp-248], rcx
  01c8b	48 89 8d 50 03
	00 00		 mov	 QWORD PTR $T35[rbp-240], rcx
  01c92	48 89 8d 58 03
	00 00		 mov	 QWORD PTR $T35[rbp-232], rcx
  01c99	48 89 8d 60 03
	00 00		 mov	 QWORD PTR $T35[rbp-224], rcx
  01ca0	48 89 8d 68 03
	00 00		 mov	 QWORD PTR $T35[rbp-216], rcx
  01ca7	48 89 8d 70 03
	00 00		 mov	 QWORD PTR $T35[rbp-208], rcx
  01cae	48 89 8d 78 03
	00 00		 mov	 QWORD PTR $T35[rbp-200], rcx

; 144  : 	}
; 145  : }
; 146  : 
; 147  : Matrix::Matrix(float* data)
; 148  : {
; 149  : 	for(int i = 0; i < 16; i++)
; 150  : 	{
; 151  : 		this->data[i] = data[i];
; 152  : 	}
; 153  : }
; 154  : 
; 155  : const float& Matrix::operator[](int index) const
; 156  : {
; 157  : 	return data[index];
; 158  : }
; 159  : 
; 160  : float& Matrix::operator[](int index)
; 161  : {
; 162  : 	return data[index];
; 163  : }
; 164  : 
; 165  : 
; 166  : Matrix Matrix::operator*(const Matrix& mat) const
; 167  : {
; 168  : 	Matrix result;
; 169  : 
; 170  : 	for(int i = 0; i < 4; i++)
; 171  : 	{
; 172  : 		for(int j = 0; j < 4; j++)
; 173  : 		{
; 174  : 			float value = 0.0f;
; 175  : 			for(int k = 0; k < 4; k++)
; 176  : 			{
; 177  : 				value += data[index(k, j)] * mat.data[index(i, k)];
; 178  : 			}
; 179  : 			result[index(i, j)] = value;
; 180  : 		}
; 181  : 	}
; 182  : 
; 183  : 	return result;
; 184  : }
; 185  : 
; 186  : Matrix Matrix::operator*(const float& scalar) const
; 187  : {
; 188  : 	Matrix result;
; 189  : 
; 190  : 	for(int i = 0; i < 16; i++)
; 191  : 	{
; 192  : 		result[i] = data[i] * scalar;
; 193  : 	}
; 194  : 
; 195  : 	return result;
; 196  : }
; 197  : 
; 198  : Vector Matrix::operator*(const Vector& vert) const
; 199  : {
; 200  : 	Vector result;
; 201  : 
; 202  : 	result.x = vert.x * data[0] + vert.y * data[1] + vert.z * data[2] + vert.w * data[3];
; 203  : 	result.y = vert.x * data[4] + vert.y * data[5] + vert.z * data[6] + vert.w * data[7];
; 204  : 	result.z = vert.x * data[8] + vert.y * data[9] + vert.z * data[10] + vert.w * data[11];
; 205  : 	result.w = vert.x * data[12] + vert.y * data[13] + vert.z * data[14] + vert.w * data[15];
; 206  : 
; 207  : 	return result;
; 208  : }
; 209  : 
; 210  : Matrix& Matrix::operator=(const Matrix& mat)
; 211  : {
; 212  : 	for(int i = 0; i < 16; i++)
; 213  : 	{
; 214  : 		data[i] = mat.data[i];
; 215  : 	}
; 216  : 
; 217  : 	return *this;
; 218  : }
; 219  : 
; 220  : Matrix Matrix::identity()
; 221  : {
; 222  : 	Matrix result;
; 223  : 	result[0] = 1.0f;

  01cb5	c7 85 40 03 00
	00 00 00 80 3f	 mov	 DWORD PTR $T35[rbp-256], 1065353216 ; 3f800000H

; 224  : 	result[5] = 1.0f;

  01cbf	c7 85 54 03 00
	00 00 00 80 3f	 mov	 DWORD PTR $T35[rbp-236], 1065353216 ; 3f800000H

; 225  : 	result[10] = 1.0f;

  01cc9	c7 85 68 03 00
	00 00 00 80 3f	 mov	 DWORD PTR $T35[rbp-216], 1065353216 ; 3f800000H

; 226  : 	result[15] = 1.0f;

  01cd3	c7 85 7c 03 00
	00 00 00 80 3f	 mov	 DWORD PTR $T35[rbp-196], 1065353216 ; 3f800000H

; 238  : 
; 239  : 	return result;
; 240  : }
; 241  : 
; 242  : Matrix Matrix::translate(float x, float y, float z)
; 243  : {
; 244  : 	Matrix result = identity();
; 245  : 	result[3] = x;

  01cdd	f3 0f 11 85 4c
	03 00 00	 movss	 DWORD PTR $T35[rbp-244], xmm0

; 246  : 	result[7] = y;

  01ce5	f3 0f 11 8d 5c
	03 00 00	 movss	 DWORD PTR $T35[rbp-228], xmm1

; 247  : 	result[11] = z;

  01ced	f3 0f 11 95 6c
	03 00 00	 movss	 DWORD PTR $T35[rbp-212], xmm2
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp

; 177  : 			gfxu::Uniforms::MMS.push(geom::Matrix::translate(chunk->pos.x * 16, chunk->pos.y * 16, chunk->pos.z * 16));

  01cf5	0f 28 85 40 03
	00 00		 movaps	 xmm0, XMMWORD PTR $T35[rbp-256]
  01cfc	0f 29 85 90 02
	00 00		 movaps	 XMMWORD PTR $T31[rbp-256], xmm0
  01d03	0f 28 8d 50 03
	00 00		 movaps	 xmm1, XMMWORD PTR $T35[rbp-240]
  01d0a	0f 29 8d a0 02
	00 00		 movaps	 XMMWORD PTR $T31[rbp-240], xmm1
  01d11	0f 28 85 60 03
	00 00		 movaps	 xmm0, XMMWORD PTR $T35[rbp-224]
  01d18	0f 29 85 b0 02
	00 00		 movaps	 XMMWORD PTR $T31[rbp-224], xmm0
  01d1f	0f 28 8d 70 03
	00 00		 movaps	 xmm1, XMMWORD PTR $T35[rbp-208]
  01d26	0f 29 8d c0 02
	00 00		 movaps	 XMMWORD PTR $T31[rbp-208], xmm1
  01d2d	48 8d 95 90 02
	00 00		 lea	 rdx, QWORD PTR $T31[rbp-256]
  01d34	e8 00 00 00 00	 call	 ?push@MatrixStack@gfxu@@QEAAXVMatrix@geom@@@Z ; gfxu::MatrixStack::push

; 178  : 			chunk->secondPass->draw();

  01d39	ba 04 00 00 00	 mov	 edx, 4
  01d3e	48 8b 4e 48	 mov	 rcx, QWORD PTR [rsi+72]
  01d42	e8 00 00 00 00	 call	 ?draw@VertexStream@gfxu@@QEAAXI@Z ; gfxu::VertexStream::draw

; 179  : 			gfxu::Uniforms::MMS.pop();

  01d47	e8 00 00 00 00	 call	 ?pop@MatrixStack@gfxu@@QEAAXXZ ; gfxu::MatrixStack::pop
  01d4c	90		 npad	 1
$LN3@tick:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  01d4d	48 85 db	 test	 rbx, rbx
  01d50	74 1d		 je	 SHORT $LN5@tick

; 109  : 		}
; 110  : 
; 111  : 	void _Incwref()
; 112  : 		{	// increment weak reference count
; 113  : 		_MT_INCR(_Ignored, _Weaks);
; 114  : 		}
; 115  : 
; 116  : 	void _Decref()
; 117  : 		{	// decrement use count
; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  01d52	f0 ff 4b 08	 lock dec DWORD PTR [rbx+8]
  01d56	75 17		 jne	 SHORT $LN5@tick

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  01d58	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  01d5b	48 8b cb	 mov	 rcx, rbx
  01d5e	ff 10		 call	 QWORD PTR [rax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  01d60	f0 ff 4b 0c	 lock dec DWORD PTR [rbx+12]
  01d64	75 09		 jne	 SHORT $LN5@tick

; 128  : 			_Delete_this();

  01d66	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  01d69	48 8b cb	 mov	 rcx, rbx
  01d6c	ff 50 08	 call	 QWORD PTR [rax+8]
$LN5@tick:
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp

; 171  : 	for(int i = 0; i < chunksToRender.size(); i++)

  01d6f	41 ff c7	 inc	 r15d
  01d72	49 83 c6 10	 add	 r14, 16
  01d76	49 63 c7	 movsxd	 rax, r15d
  01d79	48 3b c7	 cmp	 rax, rdi
  01d7c	b9 00 00 00 00	 mov	 ecx, 0
  01d81	0f 82 a9 fe ff
	ff		 jb	 $LL6@tick
$LN4@tick:

; 180  : 		}
; 181  : 	}
; 182  : 
; 183  : 	noTexShaderProgram->bind();

  01d87	48 8b 1d 00 00
	00 00		 mov	 rbx, QWORD PTR ?noTexShaderProgram@@3PEAVShaderProgram@gfxu@@EA ; noTexShaderProgram
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp

; 474  : 	glUseProgram(object);

  01d8e	8b 4b 18	 mov	 ecx, DWORD PTR [rbx+24]
  01d91	ff 15 00 00 00
	00		 call	 QWORD PTR __glewUseProgram

; 713  : 	int error = glGetError();

  01d97	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_glGetError

; 714  : 	if(error != GL_NO_ERROR)

  01d9d	85 c0		 test	 eax, eax
  01d9f	74 17		 je	 SHORT $LN1526@tick

; 715  : 	{
; 716  : 		const char* errorString = (const char*)gluErrorString(error);

  01da1	8b c8		 mov	 ecx, eax
  01da3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_gluErrorString

; 717  : 		GLWindow::instance->postError(errorString, caption);

  01da9	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG4294928712
  01db0	48 8b d0	 mov	 rdx, rax
  01db3	e8 00 00 00 00	 call	 ?postError@GLWindow@@QEAAXPEBD0@Z ; GLWindow::postError
$LN1526@tick:

; 475  : 	gfxu::getError();
; 476  : 	current = this;

  01db8	48 89 1d 00 00
	00 00		 mov	 QWORD PTR ?current@ShaderProgram@gfxu@@2PEAV12@EA, rbx ; gfxu::ShaderProgram::current

; 601  : }
; 602  : 
; 603  : void Uniforms::setForceUpload()
; 604  : {
; 605  : 	MMS.changed = PMS.changed = true;

  01dbf	c6 05 68 00 00
	00 01		 mov	 BYTE PTR ?PMS@Uniforms@gfxu@@2VMatrixStack@2@A+104, 1
  01dc6	c6 05 68 00 00
	00 01		 mov	 BYTE PTR ?MMS@Uniforms@gfxu@@2VMatrixStack@2@A+104, 1
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp

; 190  : 	if(state->devEnabled)

  01dcd	41 80 7c 24 24
	00		 cmp	 BYTE PTR [r12+36], 0
  01dd3	0f 84 75 02 00
	00		 je	 $LN2@tick
; File c:\users\glenn\documents\github\wind\project\wind\wind\geometry.cpp

; 16   : {

  01dd9	48 c7 45 98 00
	00 80 3f	 mov	 QWORD PTR $T3[rbp-256], 1065353216 ; 3f800000H
  01de1	48 c7 45 a0 00
	00 00 00	 mov	 QWORD PTR $T3[rbp-248], 0
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.h

; 245  : 			val = value;

  01de9	48 8b 45 98	 mov	 rax, QWORD PTR $T3[rbp-256]
  01ded	48 89 05 00 00
	00 00		 mov	 QWORD PTR ?fogColor@Uniforms@gfxu@@2V?$Uniform@VVector@geom@@@2@A, rax
  01df4	48 8b 45 a0	 mov	 rax, QWORD PTR $T3[rbp-248]
  01df8	48 89 05 08 00
	00 00		 mov	 QWORD PTR ?fogColor@Uniforms@gfxu@@2V?$Uniform@VVector@geom@@@2@A+8, rax

; 246  : 			changed = true;

  01dff	c6 05 10 00 00
	00 01		 mov	 BYTE PTR ?fogColor@Uniforms@gfxu@@2V?$Uniform@VVector@geom@@@2@A+16, 1

; 245  : 			val = value;

  01e06	c7 05 00 00 00
	00 00 00 00 43	 mov	 DWORD PTR ?fogDist@Uniforms@gfxu@@2V?$Uniform@M@2@A, 1124073472 ; 43000000H

; 246  : 			changed = true;

  01e10	c6 05 04 00 00
	00 01		 mov	 BYTE PTR ?fogDist@Uniforms@gfxu@@2V?$Uniform@M@2@A+4, 1
; File c:\users\glenn\documents\github\wind\project\wind\wind\geometry.cpp

; 143  : 		data[i] = 0.0f;

  01e17	45 33 ff	 xor	 r15d, r15d
  01e1a	4c 89 bd 40 04
	00 00		 mov	 QWORD PTR $T39[rbp-256], r15
  01e21	4c 89 bd 48 04
	00 00		 mov	 QWORD PTR $T39[rbp-248], r15
  01e28	4c 89 bd 50 04
	00 00		 mov	 QWORD PTR $T39[rbp-240], r15
  01e2f	4c 89 bd 58 04
	00 00		 mov	 QWORD PTR $T39[rbp-232], r15
  01e36	4c 89 bd 60 04
	00 00		 mov	 QWORD PTR $T39[rbp-224], r15
  01e3d	4c 89 bd 68 04
	00 00		 mov	 QWORD PTR $T39[rbp-216], r15
  01e44	4c 89 bd 70 04
	00 00		 mov	 QWORD PTR $T39[rbp-208], r15
  01e4b	4c 89 bd 78 04
	00 00		 mov	 QWORD PTR $T39[rbp-200], r15

; 227  : 
; 228  : 	return result;
; 229  : }
; 230  : 
; 231  : Matrix Matrix::scale(float x, float y, float z)
; 232  : {
; 233  : 	Matrix result;
; 234  : 	result[0] = x;

  01e52	c7 85 40 04 00
	00 00 00 80 41	 mov	 DWORD PTR $T39[rbp-256], 1098907648 ; 41800000H

; 235  : 	result[5] = y;

  01e5c	c7 85 54 04 00
	00 00 00 80 41	 mov	 DWORD PTR $T39[rbp-236], 1098907648 ; 41800000H

; 236  : 	result[10] = z;

  01e66	c7 85 68 04 00
	00 00 00 80 41	 mov	 DWORD PTR $T39[rbp-216], 1098907648 ; 41800000H

; 237  : 	result[15] = 1.0f;

  01e70	c7 85 7c 04 00
	00 00 00 80 3f	 mov	 DWORD PTR $T39[rbp-196], 1065353216 ; 3f800000H
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp

; 194  : 		gfxu::Uniforms::MMS.push(geom::Matrix::scale(16.0f, 16.0f, 16.0f));

  01e7a	0f 28 85 40 04
	00 00		 movaps	 xmm0, XMMWORD PTR $T39[rbp-256]
  01e81	0f 29 85 90 01
	00 00		 movaps	 XMMWORD PTR $T27[rbp-256], xmm0
  01e88	0f 28 8d 50 04
	00 00		 movaps	 xmm1, XMMWORD PTR $T39[rbp-240]
  01e8f	0f 29 8d a0 01
	00 00		 movaps	 XMMWORD PTR $T27[rbp-240], xmm1
  01e96	0f 28 85 60 04
	00 00		 movaps	 xmm0, XMMWORD PTR $T39[rbp-224]
  01e9d	0f 29 85 b0 01
	00 00		 movaps	 XMMWORD PTR $T27[rbp-224], xmm0
  01ea4	0f 28 8d 70 04
	00 00		 movaps	 xmm1, XMMWORD PTR $T39[rbp-208]
  01eab	0f 29 8d c0 01
	00 00		 movaps	 XMMWORD PTR $T27[rbp-208], xmm1
  01eb2	48 8d 95 90 01
	00 00		 lea	 rdx, QWORD PTR $T27[rbp-256]
  01eb9	e8 00 00 00 00	 call	 ?push@MatrixStack@gfxu@@QEAAXVMatrix@geom@@@Z ; gfxu::MatrixStack::push
  01ebe	66 0f 6e 54 24
	54		 movd	 xmm2, DWORD PTR zCam$[rsp]

; 195  : 		gfxu::Uniforms::MMS.mult(geom::Matrix::translate(xCam, yCam, zCam));

  01ec4	0f 5b d2	 cvtdq2ps xmm2, xmm2
  01ec7	66 0f 6e 4c 24
	58		 movd	 xmm1, DWORD PTR yCam$[rsp]
  01ecd	0f 5b c9	 cvtdq2ps xmm1, xmm1
  01ed0	66 0f 6e 44 24
	50		 movd	 xmm0, DWORD PTR xCam$[rsp]
  01ed6	0f 5b c0	 cvtdq2ps xmm0, xmm0
; File c:\users\glenn\documents\github\wind\project\wind\wind\geometry.cpp

; 143  : 		data[i] = 0.0f;

  01ed9	4c 89 bd 00 04
	00 00		 mov	 QWORD PTR $T38[rbp-256], r15
  01ee0	4c 89 bd 08 04
	00 00		 mov	 QWORD PTR $T38[rbp-248], r15
  01ee7	4c 89 bd 10 04
	00 00		 mov	 QWORD PTR $T38[rbp-240], r15
  01eee	4c 89 bd 18 04
	00 00		 mov	 QWORD PTR $T38[rbp-232], r15
  01ef5	4c 89 bd 20 04
	00 00		 mov	 QWORD PTR $T38[rbp-224], r15
  01efc	4c 89 bd 28 04
	00 00		 mov	 QWORD PTR $T38[rbp-216], r15
  01f03	4c 89 bd 30 04
	00 00		 mov	 QWORD PTR $T38[rbp-208], r15
  01f0a	4c 89 bd 38 04
	00 00		 mov	 QWORD PTR $T38[rbp-200], r15

; 144  : 	}
; 145  : }
; 146  : 
; 147  : Matrix::Matrix(float* data)
; 148  : {
; 149  : 	for(int i = 0; i < 16; i++)
; 150  : 	{
; 151  : 		this->data[i] = data[i];
; 152  : 	}
; 153  : }
; 154  : 
; 155  : const float& Matrix::operator[](int index) const
; 156  : {
; 157  : 	return data[index];
; 158  : }
; 159  : 
; 160  : float& Matrix::operator[](int index)
; 161  : {
; 162  : 	return data[index];
; 163  : }
; 164  : 
; 165  : 
; 166  : Matrix Matrix::operator*(const Matrix& mat) const
; 167  : {
; 168  : 	Matrix result;
; 169  : 
; 170  : 	for(int i = 0; i < 4; i++)
; 171  : 	{
; 172  : 		for(int j = 0; j < 4; j++)
; 173  : 		{
; 174  : 			float value = 0.0f;
; 175  : 			for(int k = 0; k < 4; k++)
; 176  : 			{
; 177  : 				value += data[index(k, j)] * mat.data[index(i, k)];
; 178  : 			}
; 179  : 			result[index(i, j)] = value;
; 180  : 		}
; 181  : 	}
; 182  : 
; 183  : 	return result;
; 184  : }
; 185  : 
; 186  : Matrix Matrix::operator*(const float& scalar) const
; 187  : {
; 188  : 	Matrix result;
; 189  : 
; 190  : 	for(int i = 0; i < 16; i++)
; 191  : 	{
; 192  : 		result[i] = data[i] * scalar;
; 193  : 	}
; 194  : 
; 195  : 	return result;
; 196  : }
; 197  : 
; 198  : Vector Matrix::operator*(const Vector& vert) const
; 199  : {
; 200  : 	Vector result;
; 201  : 
; 202  : 	result.x = vert.x * data[0] + vert.y * data[1] + vert.z * data[2] + vert.w * data[3];
; 203  : 	result.y = vert.x * data[4] + vert.y * data[5] + vert.z * data[6] + vert.w * data[7];
; 204  : 	result.z = vert.x * data[8] + vert.y * data[9] + vert.z * data[10] + vert.w * data[11];
; 205  : 	result.w = vert.x * data[12] + vert.y * data[13] + vert.z * data[14] + vert.w * data[15];
; 206  : 
; 207  : 	return result;
; 208  : }
; 209  : 
; 210  : Matrix& Matrix::operator=(const Matrix& mat)
; 211  : {
; 212  : 	for(int i = 0; i < 16; i++)
; 213  : 	{
; 214  : 		data[i] = mat.data[i];
; 215  : 	}
; 216  : 
; 217  : 	return *this;
; 218  : }
; 219  : 
; 220  : Matrix Matrix::identity()
; 221  : {
; 222  : 	Matrix result;
; 223  : 	result[0] = 1.0f;

  01f11	c7 85 00 04 00
	00 00 00 80 3f	 mov	 DWORD PTR $T38[rbp-256], 1065353216 ; 3f800000H

; 224  : 	result[5] = 1.0f;

  01f1b	c7 85 14 04 00
	00 00 00 80 3f	 mov	 DWORD PTR $T38[rbp-236], 1065353216 ; 3f800000H

; 225  : 	result[10] = 1.0f;

  01f25	c7 85 28 04 00
	00 00 00 80 3f	 mov	 DWORD PTR $T38[rbp-216], 1065353216 ; 3f800000H

; 226  : 	result[15] = 1.0f;

  01f2f	c7 85 3c 04 00
	00 00 00 80 3f	 mov	 DWORD PTR $T38[rbp-196], 1065353216 ; 3f800000H

; 238  : 
; 239  : 	return result;
; 240  : }
; 241  : 
; 242  : Matrix Matrix::translate(float x, float y, float z)
; 243  : {
; 244  : 	Matrix result = identity();
; 245  : 	result[3] = x;

  01f39	f3 0f 11 85 0c
	04 00 00	 movss	 DWORD PTR $T38[rbp-244], xmm0

; 246  : 	result[7] = y;

  01f41	f3 0f 11 8d 1c
	04 00 00	 movss	 DWORD PTR $T38[rbp-228], xmm1

; 247  : 	result[11] = z;

  01f49	f3 0f 11 95 2c
	04 00 00	 movss	 DWORD PTR $T38[rbp-212], xmm2
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp

; 195  : 		gfxu::Uniforms::MMS.mult(geom::Matrix::translate(xCam, yCam, zCam));

  01f51	0f 28 85 00 04
	00 00		 movaps	 xmm0, XMMWORD PTR $T38[rbp-256]
  01f58	0f 29 85 d0 00
	00 00		 movaps	 XMMWORD PTR $T24[rbp-256], xmm0
  01f5f	0f 28 8d 10 04
	00 00		 movaps	 xmm1, XMMWORD PTR $T38[rbp-240]
  01f66	0f 29 8d e0 00
	00 00		 movaps	 XMMWORD PTR $T24[rbp-240], xmm1
  01f6d	0f 28 85 20 04
	00 00		 movaps	 xmm0, XMMWORD PTR $T38[rbp-224]
  01f74	0f 29 85 f0 00
	00 00		 movaps	 XMMWORD PTR $T24[rbp-224], xmm0
  01f7b	0f 28 8d 30 04
	00 00		 movaps	 xmm1, XMMWORD PTR $T38[rbp-208]
  01f82	0f 29 8d 00 01
	00 00		 movaps	 XMMWORD PTR $T24[rbp-208], xmm1
  01f89	48 8d 95 d0 00
	00 00		 lea	 rdx, QWORD PTR $T24[rbp-256]
  01f90	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?MMS@Uniforms@gfxu@@2VMatrixStack@2@A ; gfxu::Uniforms::MMS
  01f97	e8 00 00 00 00	 call	 ?mult@MatrixStack@gfxu@@QEAAXVMatrix@geom@@@Z ; gfxu::MatrixStack::mult
; File c:\users\glenn\documents\github\wind\project\wind\wind\geometry.cpp

; 16   : {

  01f9c	48 c7 45 b8 00
	00 80 3f	 mov	 QWORD PTR $T5[rbp-256], 1065353216 ; 3f800000H
  01fa4	44 89 7d c0	 mov	 DWORD PTR $T5[rbp-248], r15d
  01fa8	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3e800000
  01fb0	f3 0f 11 45 c4	 movss	 DWORD PTR $T5[rbp-244], xmm0
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.h

; 245  : 			val = value;

  01fb5	48 8b 45 b8	 mov	 rax, QWORD PTR $T5[rbp-256]
  01fb9	48 89 05 00 00
	00 00		 mov	 QWORD PTR ?color@Uniforms@gfxu@@2V?$Uniform@VVector@geom@@@2@A, rax
  01fc0	48 8b 45 c0	 mov	 rax, QWORD PTR $T5[rbp-248]
  01fc4	48 89 05 08 00
	00 00		 mov	 QWORD PTR ?color@Uniforms@gfxu@@2V?$Uniform@VVector@geom@@@2@A+8, rax

; 246  : 			changed = true;

  01fcb	c6 05 10 00 00
	00 01		 mov	 BYTE PTR ?color@Uniforms@gfxu@@2V?$Uniform@VVector@geom@@@2@A+16, 1
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp

; 197  : 		grid->draw(GL_LINES);

  01fd2	bb 01 00 00 00	 mov	 ebx, 1
  01fd7	8b d3		 mov	 edx, ebx
  01fd9	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?grid@@3PEAVVertexStream@gfxu@@EA ; grid
  01fe0	e8 00 00 00 00	 call	 ?draw@VertexStream@gfxu@@QEAAXI@Z ; gfxu::VertexStream::draw

; 198  : 
; 199  : 		glDepthFunc(GL_GREATER);

  01fe5	b9 04 02 00 00	 mov	 ecx, 516		; 00000204H
  01fea	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_glDepthFunc
; File c:\users\glenn\documents\github\wind\project\wind\wind\geometry.cpp

; 16   : {

  01ff0	48 c7 45 d0 00
	00 80 3f	 mov	 QWORD PTR $T7[rbp-256], 1065353216 ; 3f800000H
  01ff8	44 89 7d d8	 mov	 DWORD PTR $T7[rbp-248], r15d
  01ffc	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3e000000
  02004	f3 0f 11 45 dc	 movss	 DWORD PTR $T7[rbp-244], xmm0
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.h

; 245  : 			val = value;

  02009	48 8b 45 d0	 mov	 rax, QWORD PTR $T7[rbp-256]
  0200d	48 89 05 00 00
	00 00		 mov	 QWORD PTR ?color@Uniforms@gfxu@@2V?$Uniform@VVector@geom@@@2@A, rax
  02014	48 8b 45 d8	 mov	 rax, QWORD PTR $T7[rbp-248]
  02018	48 89 05 08 00
	00 00		 mov	 QWORD PTR ?color@Uniforms@gfxu@@2V?$Uniform@VVector@geom@@@2@A+8, rax

; 246  : 			changed = true;

  0201f	88 1d 10 00 00
	00		 mov	 BYTE PTR ?color@Uniforms@gfxu@@2V?$Uniform@VVector@geom@@@2@A+16, bl
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp

; 201  : 		grid->draw(GL_LINES);

  02025	8b d3		 mov	 edx, ebx
  02027	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?grid@@3PEAVVertexStream@gfxu@@EA ; grid
  0202e	e8 00 00 00 00	 call	 ?draw@VertexStream@gfxu@@QEAAXI@Z ; gfxu::VertexStream::draw

; 202  : 		gfxu::Uniforms::MMS.pop();

  02033	e8 00 00 00 00	 call	 ?pop@MatrixStack@gfxu@@QEAAXXZ ; gfxu::MatrixStack::pop

; 203  : 		glDepthFunc(GL_LEQUAL);

  02038	b9 03 02 00 00	 mov	 ecx, 515		; 00000203H
  0203d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_glDepthFunc

; 204  : 		glDisable(GL_BLEND);

  02043	b9 e2 0b 00 00	 mov	 ecx, 3042		; 00000be2H
  02048	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_glDisable
$LN2@tick:

; 205  : 	}
; 206  : 
; 207  : 	glFlush();

  0204e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_glFlush
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp

; 713  : 	int error = glGetError();

  02054	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_glGetError

; 714  : 	if(error != GL_NO_ERROR)

  0205a	85 c0		 test	 eax, eax
  0205c	74 1e		 je	 SHORT $LN1@tick

; 715  : 	{
; 716  : 		const char* errorString = (const char*)gluErrorString(error);

  0205e	8b c8		 mov	 ecx, eax
  02060	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_gluErrorString

; 717  : 		GLWindow::instance->postError(errorString, caption);

  02066	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG4294950233
  0206d	48 8b d0	 mov	 rdx, rax
  02070	e8 00 00 00 00	 call	 ?postError@GLWindow@@QEAAXPEBD0@Z ; GLWindow::postError
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp

; 208  : 	if(gfxu::getError("Graphics thread loop error")) GlobalThread::stop = true;

  02075	c6 05 00 00 00
	00 01		 mov	 BYTE PTR ?stop@GlobalThread@@3_NA, 1 ; GlobalThread::stop
$LN1@tick:
; File c:\users\glenn\documents\github\wind\project\wind\wind\window.cpp

; 192  : 	SwapBuffers(hDC);

  0207c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?instance@GLWindow@@2PEAV1@EA ; GLWindow::instance
  02083	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  02087	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_SwapBuffers
  0208d	90		 npad	 1
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector

; 900  : 		_Tidy();

  0208e	48 8d 4c 24 60	 lea	 rcx, QWORD PTR chunksToRender$[rsp]
  02093	e8 00 00 00 00	 call	 ?_Tidy@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAXXZ ; std::vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::_Tidy
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp

; 211  : 	return true;

  02098	b0 01		 mov	 al, 1
$LN41@tick:

; 212  : }

  0209a	48 8b 8d 20 06
	00 00		 mov	 rcx, QWORD PTR __$ArrayPad$[rbp-256]
  020a1	48 33 cc	 xor	 rcx, rsp
  020a4	e8 00 00 00 00	 call	 __security_check_cookie
  020a9	4c 8d 9c 24 50
	07 00 00	 lea	 r11, QWORD PTR [rsp+1872]
  020b1	49 8b 5b 38	 mov	 rbx, QWORD PTR [r11+56]
  020b5	49 8b 73 40	 mov	 rsi, QWORD PTR [r11+64]
  020b9	49 8b 7b 48	 mov	 rdi, QWORD PTR [r11+72]
  020bd	41 0f 28 73 f0	 movaps	 xmm6, XMMWORD PTR [r11-16]
  020c2	41 0f 28 7b e0	 movaps	 xmm7, XMMWORD PTR [r11-32]
  020c7	49 8b e3	 mov	 rsp, r11
  020ca	41 5f		 pop	 r15
  020cc	41 5e		 pop	 r14
  020ce	41 5d		 pop	 r13
  020d0	41 5c		 pop	 r12
  020d2	5d		 pop	 rbp
  020d3	c3		 ret	 0
?tick@RenderThread@@EEAA_NXZ ENDP			; RenderThread::tick
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
xCam$ = 80
zCam$ = 84
yCam$ = 88
chunksToRender$ = 96
$T1 = 120
$T2 = 136
$T3 = 152
$T4 = 168
$T5 = 184
event$6 = 200
$T7 = 208
event$8 = 224
event$9 = 232
$T10 = 240
chunk$11 = 256
$T12 = 272
state$1$ = 280
$T13 = 288
$T14 = 296
$T15 = 312
$T16 = 344
chunk$17 = 376
$T18 = 392
$T19 = 400
chunk$20 = 408
$T21 = 424
c$22 = 432
c$23 = 448
$T24 = 464
$T25 = 528
$T26 = 592
$T27 = 656
$T28 = 720
$T29 = 784
$T30 = 848
$T31 = 912
$T32 = 976
$T33 = 1040
$T34 = 1064
$T35 = 1088
$T36 = 1152
$T37 = 1216
$T38 = 1280
$T39 = 1344
projectionMatrix$ = 1408
$T40 = 1472
$T41 = 1536
$T42 = 1600
$T43 = 1664
local_ws_1$ = 1728
global_ws_1$ = 1752
global_ws_2$ = 1776
local_ws_2$ = 1800
__$ArrayPad$ = 1824
this$ = 1920
?dtor$2@?0??tick@RenderThread@@EEAA_NXZ@4HA PROC	; `RenderThread::tick'::`1'::dtor$2
  00000	48 8d 8a c0 01
	00 00		 lea	 rcx, QWORD PTR c$23[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1?$shared_ptr@VChunkBase@@@std@@QEAA@XZ ; std::shared_ptr<ChunkBase>::~shared_ptr<ChunkBase>
?dtor$2@?0??tick@RenderThread@@EEAA_NXZ@4HA ENDP	; `RenderThread::tick'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
xCam$ = 80
zCam$ = 84
yCam$ = 88
chunksToRender$ = 96
$T1 = 120
$T2 = 136
$T3 = 152
$T4 = 168
$T5 = 184
event$6 = 200
$T7 = 208
event$8 = 224
event$9 = 232
$T10 = 240
chunk$11 = 256
$T12 = 272
state$1$ = 280
$T13 = 288
$T14 = 296
$T15 = 312
$T16 = 344
chunk$17 = 376
$T18 = 392
$T19 = 400
chunk$20 = 408
$T21 = 424
c$22 = 432
c$23 = 448
$T24 = 464
$T25 = 528
$T26 = 592
$T27 = 656
$T28 = 720
$T29 = 784
$T30 = 848
$T31 = 912
$T32 = 976
$T33 = 1040
$T34 = 1064
$T35 = 1088
$T36 = 1152
$T37 = 1216
$T38 = 1280
$T39 = 1344
projectionMatrix$ = 1408
$T40 = 1472
$T41 = 1536
$T42 = 1600
$T43 = 1664
local_ws_1$ = 1728
global_ws_1$ = 1752
global_ws_2$ = 1776
local_ws_2$ = 1800
__$ArrayPad$ = 1824
this$ = 1920
?dtor$9@?0??tick@RenderThread@@EEAA_NXZ@4HA PROC	; `RenderThread::tick'::`1'::dtor$9
  0000c	48 8b 8a 90 01
	00 00		 mov	 rcx, QWORD PTR $T19[rdx]
  00013	e9 00 00 00 00	 jmp	 ??1?$shared_ptr@VChunkBase@@@std@@QEAA@XZ ; std::shared_ptr<ChunkBase>::~shared_ptr<ChunkBase>
?dtor$9@?0??tick@RenderThread@@EEAA_NXZ@4HA ENDP	; `RenderThread::tick'::`1'::dtor$9
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
xCam$ = 80
zCam$ = 84
yCam$ = 88
chunksToRender$ = 96
$T1 = 120
$T2 = 136
$T3 = 152
$T4 = 168
$T5 = 184
event$6 = 200
$T7 = 208
event$8 = 224
event$9 = 232
$T10 = 240
chunk$11 = 256
$T12 = 272
state$1$ = 280
$T13 = 288
$T14 = 296
$T15 = 312
$T16 = 344
chunk$17 = 376
$T18 = 392
$T19 = 400
chunk$20 = 408
$T21 = 424
c$22 = 432
c$23 = 448
$T24 = 464
$T25 = 528
$T26 = 592
$T27 = 656
$T28 = 720
$T29 = 784
$T30 = 848
$T31 = 912
$T32 = 976
$T33 = 1040
$T34 = 1064
$T35 = 1088
$T36 = 1152
$T37 = 1216
$T38 = 1280
$T39 = 1344
projectionMatrix$ = 1408
$T40 = 1472
$T41 = 1536
$T42 = 1600
$T43 = 1664
local_ws_1$ = 1728
global_ws_1$ = 1752
global_ws_2$ = 1776
local_ws_2$ = 1800
__$ArrayPad$ = 1824
this$ = 1920
?dtor$4@?0??tick@RenderThread@@EEAA_NXZ@4HA PROC	; `RenderThread::tick'::`1'::dtor$4
  00018	48 8d 8a b0 01
	00 00		 lea	 rcx, QWORD PTR c$22[rdx]
  0001f	e9 00 00 00 00	 jmp	 ??1?$shared_ptr@VChunkBase@@@std@@QEAA@XZ ; std::shared_ptr<ChunkBase>::~shared_ptr<ChunkBase>
?dtor$4@?0??tick@RenderThread@@EEAA_NXZ@4HA ENDP	; `RenderThread::tick'::`1'::dtor$4
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
xCam$ = 80
zCam$ = 84
yCam$ = 88
chunksToRender$ = 96
$T1 = 120
$T2 = 136
$T3 = 152
$T4 = 168
$T5 = 184
event$6 = 200
$T7 = 208
event$8 = 224
event$9 = 232
$T10 = 240
chunk$11 = 256
$T12 = 272
state$1$ = 280
$T13 = 288
$T14 = 296
$T15 = 312
$T16 = 344
chunk$17 = 376
$T18 = 392
$T19 = 400
chunk$20 = 408
$T21 = 424
c$22 = 432
c$23 = 448
$T24 = 464
$T25 = 528
$T26 = 592
$T27 = 656
$T28 = 720
$T29 = 784
$T30 = 848
$T31 = 912
$T32 = 976
$T33 = 1040
$T34 = 1064
$T35 = 1088
$T36 = 1152
$T37 = 1216
$T38 = 1280
$T39 = 1344
projectionMatrix$ = 1408
$T40 = 1472
$T41 = 1536
$T42 = 1600
$T43 = 1664
local_ws_1$ = 1728
global_ws_1$ = 1752
global_ws_2$ = 1776
local_ws_2$ = 1800
__$ArrayPad$ = 1824
this$ = 1920
?dtor$5@?0??tick@RenderThread@@EEAA_NXZ@4HA PROC	; `RenderThread::tick'::`1'::dtor$5
  00024	48 8d 8a 60 00
	00 00		 lea	 rcx, QWORD PTR chunksToRender$[rdx]
  0002b	e9 00 00 00 00	 jmp	 ??1?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAA@XZ ; std::vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::~vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >
?dtor$5@?0??tick@RenderThread@@EEAA_NXZ@4HA ENDP	; `RenderThread::tick'::`1'::dtor$5
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
xCam$ = 80
zCam$ = 84
yCam$ = 88
chunksToRender$ = 96
$T1 = 120
$T2 = 136
$T3 = 152
$T4 = 168
$T5 = 184
event$6 = 200
$T7 = 208
event$8 = 224
event$9 = 232
$T10 = 240
chunk$11 = 256
$T12 = 272
state$1$ = 280
$T13 = 288
$T14 = 296
$T15 = 312
$T16 = 344
chunk$17 = 376
$T18 = 392
$T19 = 400
chunk$20 = 408
$T21 = 424
c$22 = 432
c$23 = 448
$T24 = 464
$T25 = 528
$T26 = 592
$T27 = 656
$T28 = 720
$T29 = 784
$T30 = 848
$T31 = 912
$T32 = 976
$T33 = 1040
$T34 = 1064
$T35 = 1088
$T36 = 1152
$T37 = 1216
$T38 = 1280
$T39 = 1344
projectionMatrix$ = 1408
$T40 = 1472
$T41 = 1536
$T42 = 1600
$T43 = 1664
local_ws_1$ = 1728
global_ws_1$ = 1752
global_ws_2$ = 1776
local_ws_2$ = 1800
__$ArrayPad$ = 1824
this$ = 1920
?dtor$6@?0??tick@RenderThread@@EEAA_NXZ@4HA PROC	; `RenderThread::tick'::`1'::dtor$6
  00030	48 8d 8a 00 01
	00 00		 lea	 rcx, QWORD PTR chunk$11[rdx]
  00037	e9 00 00 00 00	 jmp	 ??1?$shared_ptr@VChunkBase@@@std@@QEAA@XZ ; std::shared_ptr<ChunkBase>::~shared_ptr<ChunkBase>
?dtor$6@?0??tick@RenderThread@@EEAA_NXZ@4HA ENDP	; `RenderThread::tick'::`1'::dtor$6
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
xCam$ = 80
zCam$ = 84
yCam$ = 88
chunksToRender$ = 96
$T1 = 120
$T2 = 136
$T3 = 152
$T4 = 168
$T5 = 184
event$6 = 200
$T7 = 208
event$8 = 224
event$9 = 232
$T10 = 240
chunk$11 = 256
$T12 = 272
state$1$ = 280
$T13 = 288
$T14 = 296
$T15 = 312
$T16 = 344
chunk$17 = 376
$T18 = 392
$T19 = 400
chunk$20 = 408
$T21 = 424
c$22 = 432
c$23 = 448
$T24 = 464
$T25 = 528
$T26 = 592
$T27 = 656
$T28 = 720
$T29 = 784
$T30 = 848
$T31 = 912
$T32 = 976
$T33 = 1040
$T34 = 1064
$T35 = 1088
$T36 = 1152
$T37 = 1216
$T38 = 1280
$T39 = 1344
projectionMatrix$ = 1408
$T40 = 1472
$T41 = 1536
$T42 = 1600
$T43 = 1664
local_ws_1$ = 1728
global_ws_1$ = 1752
global_ws_2$ = 1776
local_ws_2$ = 1800
__$ArrayPad$ = 1824
this$ = 1920
?dtor$7@?0??tick@RenderThread@@EEAA_NXZ@4HA PROC	; `RenderThread::tick'::`1'::dtor$7
  0003c	48 8d 8a 98 01
	00 00		 lea	 rcx, QWORD PTR chunk$20[rdx]
  00043	e9 00 00 00 00	 jmp	 ??1?$shared_ptr@VChunkBase@@@std@@QEAA@XZ ; std::shared_ptr<ChunkBase>::~shared_ptr<ChunkBase>
?dtor$7@?0??tick@RenderThread@@EEAA_NXZ@4HA ENDP	; `RenderThread::tick'::`1'::dtor$7
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
xCam$ = 80
zCam$ = 84
yCam$ = 88
chunksToRender$ = 96
$T1 = 120
$T2 = 136
$T3 = 152
$T4 = 168
$T5 = 184
event$6 = 200
$T7 = 208
event$8 = 224
event$9 = 232
$T10 = 240
chunk$11 = 256
$T12 = 272
state$1$ = 280
$T13 = 288
$T14 = 296
$T15 = 312
$T16 = 344
chunk$17 = 376
$T18 = 392
$T19 = 400
chunk$20 = 408
$T21 = 424
c$22 = 432
c$23 = 448
$T24 = 464
$T25 = 528
$T26 = 592
$T27 = 656
$T28 = 720
$T29 = 784
$T30 = 848
$T31 = 912
$T32 = 976
$T33 = 1040
$T34 = 1064
$T35 = 1088
$T36 = 1152
$T37 = 1216
$T38 = 1280
$T39 = 1344
projectionMatrix$ = 1408
$T40 = 1472
$T41 = 1536
$T42 = 1600
$T43 = 1664
local_ws_1$ = 1728
global_ws_1$ = 1752
global_ws_2$ = 1776
local_ws_2$ = 1800
__$ArrayPad$ = 1824
this$ = 1920
?dtor$8@?0??tick@RenderThread@@EEAA_NXZ@4HA PROC	; `RenderThread::tick'::`1'::dtor$8
  00048	48 8d 8a 78 01
	00 00		 lea	 rcx, QWORD PTR chunk$17[rdx]
  0004f	e9 00 00 00 00	 jmp	 ??1?$shared_ptr@VChunkBase@@@std@@QEAA@XZ ; std::shared_ptr<ChunkBase>::~shared_ptr<ChunkBase>
?dtor$8@?0??tick@RenderThread@@EEAA_NXZ@4HA ENDP	; `RenderThread::tick'::`1'::dtor$8
text$x	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\window.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp
;	COMDAT ?preStart@RenderThread@@UEAAXXZ
_TEXT	SEGMENT
error$1 = 48
error$2 = 48
$T3 = 48
$T4 = 48
$T5 = 48
$T6 = 48
$T7 = 48
$T8 = 48
$T9 = 48
error$10 = 56
error$11 = 56
$T12 = 64
$T13 = 64
$T14 = 64
$T15 = 64
$T16 = 64
$T17 = 64
$T18 = 96
filePath$ = 104
__$ArrayPad$ = 136
this$ = 224
?preStart@RenderThread@@UEAAXXZ PROC			; RenderThread::preStart, COMDAT

; 215  : {

$LN901:
  00000	48 8b c4	 mov	 rax, rsp
  00003	55		 push	 rbp
  00004	41 56		 push	 r14
  00006	41 57		 push	 r15
  00008	48 8d 68 a1	 lea	 rbp, QWORD PTR [rax-95]
  0000c	48 81 ec c0 00
	00 00		 sub	 rsp, 192		; 000000c0H
  00013	48 c7 45 e7 fe
	ff ff ff	 mov	 QWORD PTR $T18[rbp-121], -2
  0001b	48 89 58 08	 mov	 QWORD PTR [rax+8], rbx
  0001f	48 89 70 10	 mov	 QWORD PTR [rax+16], rsi
  00023	48 89 78 18	 mov	 QWORD PTR [rax+24], rdi
  00027	0f 29 70 d8	 movaps	 XMMWORD PTR [rax-40], xmm6
  0002b	0f 29 78 c8	 movaps	 XMMWORD PTR [rax-56], xmm7
  0002f	44 0f 29 40 b8	 movaps	 XMMWORD PTR [rax-72], xmm8
  00034	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0003b	48 33 c4	 xor	 rax, rsp
  0003e	48 89 45 0f	 mov	 QWORD PTR __$ArrayPad$[rbp-121], rax
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp

; 54   : 	cl_int error = 0;

  00042	33 ff		 xor	 edi, edi
  00044	89 7d bf	 mov	 DWORD PTR error$11[rbp-121], edi

; 55   : 	queue = clCreateCommandQueue(cl::context, cl::device, 0, &error);

  00047	4c 8d 4d bf	 lea	 r9, QWORD PTR error$11[rbp-121]
  0004b	45 33 c0	 xor	 r8d, r8d
  0004e	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR ?device@cl@@3PEAU_cl_device_id@@EA ; cl::device
  00055	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?context@cl@@3PEAU_cl_context@@EA ; cl::context
  0005c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_clCreateCommandQueue
  00062	48 89 05 00 00
	00 00		 mov	 QWORD PTR ?commandQueue@@3VCommandQueue@cl@@A, rax

; 56   : 	if(error != CL_SUCCESS)

  00069	39 7d bf	 cmp	 DWORD PTR error$11[rbp-121], edi
  0006c	74 15		 je	 SHORT $LN45@preStart

; 57   : 	{
; 58   : 		GLWindow::instance->postError("Could not create command queue", "Command queue creation error");

  0006e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG4294956381
  00075	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG4294956380
  0007c	e8 00 00 00 00	 call	 ?postError@GLWindow@@QEAAXPEBD0@Z ; GLWindow::postError

; 59   : 		return false;

  00081	eb 07		 jmp	 SHORT $LN46@preStart
$LN45@preStart:

; 60   : 	}
; 61   : 
; 62   : 	okay = true;

  00083	c6 05 08 00 00
	00 01		 mov	 BYTE PTR ?commandQueue@@3VCommandQueue@cl@@A+8, 1
$LN46@preStart:

; 63   : 	return true;
; 64   : }
; 65   : 
; 66   : cl::Program::Program()
; 67   : 	: okay(false)
; 68   : {
; 69   : 
; 70   : }
; 71   : 
; 72   : cl::Program::Program(std::wstring fileName)
; 73   : 	: okay(false), preparedKernel(0)
; 74   : {
; 75   : 	create(fileName);
; 76   : }
; 77   : 
; 78   : bool cl::Program::create(std::wstring fileName)
; 79   : {
; 80   : 	cl_int error = 0;
; 81   : 
; 82   : 	std::ifstream file(fileName);
; 83   : 
; 84   : 	if(!file.good())
; 85   : 	{
; 86   : 		GLWindow::instance->postError("Invalid/missing file", "OpenCL program creation error");
; 87   : 		file.close();
; 88   : 		return false;
; 89   : 	}
; 90   : 
; 91   : 	std::string source_str = std::string((std::istreambuf_iterator<char>(file)), std::istreambuf_iterator<char>());
; 92   : 	file.close();
; 93   : 	const char* source = source_str.c_str();
; 94   : 
; 95   : 	program = clCreateProgramWithSource(context, 1, &source, NULL, &error);
; 96   : 	if(error != CL_SUCCESS)
; 97   : 	{
; 98   : 		GLWindow::instance->postError("Could not create program", "OpenCL program creation error");
; 99   : 		return false;
; 100  : 	}
; 101  : 
; 102  : 	error = clBuildProgram(program, 1, &device, NULL, NULL, NULL);
; 103  : 	if(error != CL_SUCCESS)
; 104  : 	{
; 105  : 		size_t log_size;
; 106  : 		clGetProgramBuildInfo(program, device, CL_PROGRAM_BUILD_LOG, 0, NULL, &log_size);
; 107  : 		char* log_msg = new char[log_size + 1];
; 108  : 		clGetProgramBuildInfo(program, device, CL_PROGRAM_BUILD_LOG, log_size, log_msg, NULL);
; 109  : 
; 110  : 		GLWindow::instance->postError(log_msg, "OpenCL program compilation error");
; 111  : 
; 112  : 		delete[] log_msg;
; 113  : 		return false;
; 114  : 	}
; 115  : 
; 116  : 	okay = true;
; 117  : 	return true;
; 118  : }
; 119  : 
; 120  : cl::Program::~Program()
; 121  : {
; 122  : 	if(okay)
; 123  : 	{
; 124  : 		cl_int error;
; 125  : 
; 126  : 		for(map<std::string, cl_kernel>::const_iterator iter = kernels.begin(); iter != kernels.end(); ++iter)
; 127  : 		{
; 128  : 			error = clReleaseKernel(iter->second);
; 129  : 			if(error != CL_SUCCESS)
; 130  : 			{
; 131  : 				GLWindow::instance->postError("Could not release kernel", "OpenCL program deletion error");
; 132  : 			}
; 133  : 		}
; 134  : 		error = clReleaseProgram(program);
; 135  : 		if(error != CL_SUCCESS)
; 136  : 		{
; 137  : 			GLWindow::instance->postError("Could not release program", "OpenCL program deletion error");
; 138  : 		}
; 139  : 	}
; 140  : }
; 141  : 
; 142  : cl_kernel cl::Program::getKernel(std::string kernel)
; 143  : {
; 144  : 	if(!okay) return 0;
; 145  : 	map<std::string, cl_kernel>::iterator it = kernels.find(kernel);
; 146  : 	if(it != kernels.end())
; 147  : 	{
; 148  : 		return it->second;
; 149  : 	}
; 150  : 
; 151  : 	cl_int error = 0;
; 152  : 	cl_kernel k = clCreateKernel(program, kernel.c_str(), &error);
; 153  : 
; 154  : 	if(error == CL_SUCCESS)
; 155  : 	{
; 156  : 		kernels[kernel] = k;
; 157  : 		return k;
; 158  : 	}
; 159  : 
; 160  : 	GLWindow::instance->postError("Tried to use nonexistant kernel", "OpenCL kernel error");
; 161  : 	return 0;
; 162  : }
; 163  : 
; 164  : bool cl::Program::prepare(std::string kernel)
; 165  : {
; 166  : 	cl_kernel k = getKernel(kernel);
; 167  : 
; 168  : 	if(k)
; 169  : 	{
; 170  : 		mut.lock();
; 171  : 		preparedKernel = k;
; 172  : 		return true;
; 173  : 	}
; 174  : 	else
; 175  : 	{
; 176  : 		return false;
; 177  : 	}
; 178  : }
; 179  : 
; 180  : bool cl::Program::setArgument(int index, size_t size, const void* value)
; 181  : {
; 182  : 	if(!preparedKernel)
; 183  : 	{
; 184  : 		GLWindow::instance->postError("Tried to set argument for unprepared kernel", "OpenCL kernel argument error");
; 185  : 		return false;
; 186  : 	}
; 187  : 	cl_int error = clSetKernelArg(preparedKernel, index, size, value);
; 188  : 	if(error != CL_SUCCESS)
; 189  : 	{
; 190  : 		GLWindow::instance->postError("Failed to set kernel argument", "OpenCL kernel argument error");
; 191  : 		return false;
; 192  : 	}
; 193  : 	return true;
; 194  : }
; 195  : 
; 196  : bool cl::Program::setArgument(int index, size_t size, Buffer* value)
; 197  : {
; 198  : 	return setArgument(index, size, &value->mem);
; 199  : }
; 200  : 
; 201  : bool cl::Program::invoke(CommandQueue& queue, cl_uint dimensions, const size_t* globalWorkSize, const size_t* localWorkSize)
; 202  : {
; 203  : 	if(!preparedKernel)
; 204  : 	{
; 205  : 		GLWindow::instance->postError("Tried to execute unprepared kernel", "OpenCL program execution error");
; 206  : 		return false;
; 207  : 	}
; 208  : 
; 209  : 	cl_int error;
; 210  : 	cl_event event;
; 211  : 
; 212  : 	error = clEnqueueNDRangeKernel(queue.queue, preparedKernel, dimensions, NULL, globalWorkSize, localWorkSize, 0, NULL, &event);
; 213  : 	if(error != CL_SUCCESS)
; 214  : 	{
; 215  : 		GLWindow::instance->postError("Failed to exectue kernel", "OpenCL program execution error");
; 216  : 		return false;
; 217  : 	}
; 218  : 
; 219  : 	error = clWaitForEvents(1, &event);
; 220  : 	if(error != CL_SUCCESS)
; 221  : 	{
; 222  : 		GLWindow::instance->postError("Failed to wait for kernel finish event", "OpenCL program execution error");
; 223  : 		return false;
; 224  : 	}
; 225  : 
; 226  : 	error = clReleaseEvent(event);
; 227  : 	if(error != CL_SUCCESS)
; 228  : 	{
; 229  : 		GLWindow::instance->postError("Failed to release kernel finish event", "OpenCL program execution error");
; 230  : 		return false;
; 231  : 	}
; 232  : 
; 233  : 	preparedKernel = 0;
; 234  : 	mut.unlock();
; 235  : 
; 236  : 	return true;
; 237  : }
; 238  : 
; 239  : cl::Buffer::Buffer()
; 240  : 	: okay(false)
; 241  : {
; 242  : 
; 243  : }
; 244  : 
; 245  : cl::Buffer::~Buffer()
; 246  : {
; 247  : 	if(okay)
; 248  : 	{
; 249  : 		cl_int error = clReleaseMemObject(mem);
; 250  : 		if(error != CL_SUCCESS)
; 251  : 		{
; 252  : 			GLWindow::instance->postError("Failed to delete buffer", "OpenCL buffer deletion error");
; 253  : 		}
; 254  : 	}
; 255  : }
; 256  : 
; 257  : bool cl::Buffer::create(size_t size, int flags, void* data)
; 258  : {
; 259  : 	cl_int error;
; 260  : 	mem = clCreateBuffer(context, flags, size, data, &error);

  0008a	48 8d 45 b7	 lea	 rax, QWORD PTR error$2[rbp-121]
  0008e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00093	45 33 c9	 xor	 r9d, r9d
  00096	41 8d 51 04	 lea	 edx, QWORD PTR [r9+4]
  0009a	45 8d 41 40	 lea	 r8d, QWORD PTR [r9+64]
  0009e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?context@cl@@3PEAU_cl_context@@EA ; cl::context
  000a5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_clCreateBuffer
  000ab	48 89 05 08 00
	00 00		 mov	 QWORD PTR ?projectionMatrixBuffer@@3VBuffer@cl@@A+8, rax

; 261  : 	if(error != CL_SUCCESS)

  000b2	39 7d b7	 cmp	 DWORD PTR error$2[rbp-121], edi
  000b5	74 15		 je	 SHORT $LN48@preStart

; 262  : 	{
; 263  : 		GLWindow::instance->postError("Failed to create buffer", "OpenCL buffer creation error");

  000b7	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG4294956354
  000be	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG4294956353
  000c5	e8 00 00 00 00	 call	 ?postError@GLWindow@@QEAAXPEBD0@Z ; GLWindow::postError

; 264  : 		return false;

  000ca	eb 12		 jmp	 SHORT $LN49@preStart
$LN48@preStart:

; 265  : 	}
; 266  : 
; 267  : 	this->size = size;

  000cc	48 c7 05 10 00
	00 00 40 00 00
	00		 mov	 QWORD PTR ?projectionMatrixBuffer@@3VBuffer@cl@@A+16, 64 ; 00000040H

; 268  : 	okay = true;

  000d7	c6 05 00 00 00
	00 01		 mov	 BYTE PTR ?projectionMatrixBuffer@@3VBuffer@cl@@A, 1
$LN49@preStart:

; 63   : 	return true;
; 64   : }
; 65   : 
; 66   : cl::Program::Program()
; 67   : 	: okay(false)
; 68   : {
; 69   : 
; 70   : }
; 71   : 
; 72   : cl::Program::Program(std::wstring fileName)
; 73   : 	: okay(false), preparedKernel(0)
; 74   : {
; 75   : 	create(fileName);
; 76   : }
; 77   : 
; 78   : bool cl::Program::create(std::wstring fileName)
; 79   : {
; 80   : 	cl_int error = 0;
; 81   : 
; 82   : 	std::ifstream file(fileName);
; 83   : 
; 84   : 	if(!file.good())
; 85   : 	{
; 86   : 		GLWindow::instance->postError("Invalid/missing file", "OpenCL program creation error");
; 87   : 		file.close();
; 88   : 		return false;
; 89   : 	}
; 90   : 
; 91   : 	std::string source_str = std::string((std::istreambuf_iterator<char>(file)), std::istreambuf_iterator<char>());
; 92   : 	file.close();
; 93   : 	const char* source = source_str.c_str();
; 94   : 
; 95   : 	program = clCreateProgramWithSource(context, 1, &source, NULL, &error);
; 96   : 	if(error != CL_SUCCESS)
; 97   : 	{
; 98   : 		GLWindow::instance->postError("Could not create program", "OpenCL program creation error");
; 99   : 		return false;
; 100  : 	}
; 101  : 
; 102  : 	error = clBuildProgram(program, 1, &device, NULL, NULL, NULL);
; 103  : 	if(error != CL_SUCCESS)
; 104  : 	{
; 105  : 		size_t log_size;
; 106  : 		clGetProgramBuildInfo(program, device, CL_PROGRAM_BUILD_LOG, 0, NULL, &log_size);
; 107  : 		char* log_msg = new char[log_size + 1];
; 108  : 		clGetProgramBuildInfo(program, device, CL_PROGRAM_BUILD_LOG, log_size, log_msg, NULL);
; 109  : 
; 110  : 		GLWindow::instance->postError(log_msg, "OpenCL program compilation error");
; 111  : 
; 112  : 		delete[] log_msg;
; 113  : 		return false;
; 114  : 	}
; 115  : 
; 116  : 	okay = true;
; 117  : 	return true;
; 118  : }
; 119  : 
; 120  : cl::Program::~Program()
; 121  : {
; 122  : 	if(okay)
; 123  : 	{
; 124  : 		cl_int error;
; 125  : 
; 126  : 		for(map<std::string, cl_kernel>::const_iterator iter = kernels.begin(); iter != kernels.end(); ++iter)
; 127  : 		{
; 128  : 			error = clReleaseKernel(iter->second);
; 129  : 			if(error != CL_SUCCESS)
; 130  : 			{
; 131  : 				GLWindow::instance->postError("Could not release kernel", "OpenCL program deletion error");
; 132  : 			}
; 133  : 		}
; 134  : 		error = clReleaseProgram(program);
; 135  : 		if(error != CL_SUCCESS)
; 136  : 		{
; 137  : 			GLWindow::instance->postError("Could not release program", "OpenCL program deletion error");
; 138  : 		}
; 139  : 	}
; 140  : }
; 141  : 
; 142  : cl_kernel cl::Program::getKernel(std::string kernel)
; 143  : {
; 144  : 	if(!okay) return 0;
; 145  : 	map<std::string, cl_kernel>::iterator it = kernels.find(kernel);
; 146  : 	if(it != kernels.end())
; 147  : 	{
; 148  : 		return it->second;
; 149  : 	}
; 150  : 
; 151  : 	cl_int error = 0;
; 152  : 	cl_kernel k = clCreateKernel(program, kernel.c_str(), &error);
; 153  : 
; 154  : 	if(error == CL_SUCCESS)
; 155  : 	{
; 156  : 		kernels[kernel] = k;
; 157  : 		return k;
; 158  : 	}
; 159  : 
; 160  : 	GLWindow::instance->postError("Tried to use nonexistant kernel", "OpenCL kernel error");
; 161  : 	return 0;
; 162  : }
; 163  : 
; 164  : bool cl::Program::prepare(std::string kernel)
; 165  : {
; 166  : 	cl_kernel k = getKernel(kernel);
; 167  : 
; 168  : 	if(k)
; 169  : 	{
; 170  : 		mut.lock();
; 171  : 		preparedKernel = k;
; 172  : 		return true;
; 173  : 	}
; 174  : 	else
; 175  : 	{
; 176  : 		return false;
; 177  : 	}
; 178  : }
; 179  : 
; 180  : bool cl::Program::setArgument(int index, size_t size, const void* value)
; 181  : {
; 182  : 	if(!preparedKernel)
; 183  : 	{
; 184  : 		GLWindow::instance->postError("Tried to set argument for unprepared kernel", "OpenCL kernel argument error");
; 185  : 		return false;
; 186  : 	}
; 187  : 	cl_int error = clSetKernelArg(preparedKernel, index, size, value);
; 188  : 	if(error != CL_SUCCESS)
; 189  : 	{
; 190  : 		GLWindow::instance->postError("Failed to set kernel argument", "OpenCL kernel argument error");
; 191  : 		return false;
; 192  : 	}
; 193  : 	return true;
; 194  : }
; 195  : 
; 196  : bool cl::Program::setArgument(int index, size_t size, Buffer* value)
; 197  : {
; 198  : 	return setArgument(index, size, &value->mem);
; 199  : }
; 200  : 
; 201  : bool cl::Program::invoke(CommandQueue& queue, cl_uint dimensions, const size_t* globalWorkSize, const size_t* localWorkSize)
; 202  : {
; 203  : 	if(!preparedKernel)
; 204  : 	{
; 205  : 		GLWindow::instance->postError("Tried to execute unprepared kernel", "OpenCL program execution error");
; 206  : 		return false;
; 207  : 	}
; 208  : 
; 209  : 	cl_int error;
; 210  : 	cl_event event;
; 211  : 
; 212  : 	error = clEnqueueNDRangeKernel(queue.queue, preparedKernel, dimensions, NULL, globalWorkSize, localWorkSize, 0, NULL, &event);
; 213  : 	if(error != CL_SUCCESS)
; 214  : 	{
; 215  : 		GLWindow::instance->postError("Failed to exectue kernel", "OpenCL program execution error");
; 216  : 		return false;
; 217  : 	}
; 218  : 
; 219  : 	error = clWaitForEvents(1, &event);
; 220  : 	if(error != CL_SUCCESS)
; 221  : 	{
; 222  : 		GLWindow::instance->postError("Failed to wait for kernel finish event", "OpenCL program execution error");
; 223  : 		return false;
; 224  : 	}
; 225  : 
; 226  : 	error = clReleaseEvent(event);
; 227  : 	if(error != CL_SUCCESS)
; 228  : 	{
; 229  : 		GLWindow::instance->postError("Failed to release kernel finish event", "OpenCL program execution error");
; 230  : 		return false;
; 231  : 	}
; 232  : 
; 233  : 	preparedKernel = 0;
; 234  : 	mut.unlock();
; 235  : 
; 236  : 	return true;
; 237  : }
; 238  : 
; 239  : cl::Buffer::Buffer()
; 240  : 	: okay(false)
; 241  : {
; 242  : 
; 243  : }
; 244  : 
; 245  : cl::Buffer::~Buffer()
; 246  : {
; 247  : 	if(okay)
; 248  : 	{
; 249  : 		cl_int error = clReleaseMemObject(mem);
; 250  : 		if(error != CL_SUCCESS)
; 251  : 		{
; 252  : 			GLWindow::instance->postError("Failed to delete buffer", "OpenCL buffer deletion error");
; 253  : 		}
; 254  : 	}
; 255  : }
; 256  : 
; 257  : bool cl::Buffer::create(size_t size, int flags, void* data)
; 258  : {
; 259  : 	cl_int error;
; 260  : 	mem = clCreateBuffer(context, flags, size, data, &error);

  000de	48 8d 45 bf	 lea	 rax, QWORD PTR error$10[rbp-121]
  000e2	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000e7	45 33 c9	 xor	 r9d, r9d
  000ea	41 8d 51 02	 lea	 edx, QWORD PTR [r9+2]
  000ee	41 b8 31 13 00
	00		 mov	 r8d, 4913		; 00001331H
  000f4	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?context@cl@@3PEAU_cl_context@@EA ; cl::context
  000fb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_clCreateBuffer
  00101	48 89 05 08 00
	00 00		 mov	 QWORD PTR ?gridBuffer@@3VBuffer@cl@@A+8, rax

; 261  : 	if(error != CL_SUCCESS)

  00108	39 7d bf	 cmp	 DWORD PTR error$10[rbp-121], edi
  0010b	74 15		 je	 SHORT $LN51@preStart

; 262  : 	{
; 263  : 		GLWindow::instance->postError("Failed to create buffer", "OpenCL buffer creation error");

  0010d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG4294956354
  00114	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG4294956353
  0011b	e8 00 00 00 00	 call	 ?postError@GLWindow@@QEAAXPEBD0@Z ; GLWindow::postError

; 264  : 		return false;

  00120	eb 12		 jmp	 SHORT $LN52@preStart
$LN51@preStart:

; 265  : 	}
; 266  : 
; 267  : 	this->size = size;

  00122	48 c7 05 10 00
	00 00 31 13 00
	00		 mov	 QWORD PTR ?gridBuffer@@3VBuffer@cl@@A+16, 4913 ; 00001331H

; 268  : 	okay = true;

  0012d	c6 05 00 00 00
	00 01		 mov	 BYTE PTR ?gridBuffer@@3VBuffer@cl@@A, 1
$LN52@preStart:

; 63   : 	return true;
; 64   : }
; 65   : 
; 66   : cl::Program::Program()
; 67   : 	: okay(false)
; 68   : {
; 69   : 
; 70   : }
; 71   : 
; 72   : cl::Program::Program(std::wstring fileName)
; 73   : 	: okay(false), preparedKernel(0)
; 74   : {
; 75   : 	create(fileName);
; 76   : }
; 77   : 
; 78   : bool cl::Program::create(std::wstring fileName)
; 79   : {
; 80   : 	cl_int error = 0;
; 81   : 
; 82   : 	std::ifstream file(fileName);
; 83   : 
; 84   : 	if(!file.good())
; 85   : 	{
; 86   : 		GLWindow::instance->postError("Invalid/missing file", "OpenCL program creation error");
; 87   : 		file.close();
; 88   : 		return false;
; 89   : 	}
; 90   : 
; 91   : 	std::string source_str = std::string((std::istreambuf_iterator<char>(file)), std::istreambuf_iterator<char>());
; 92   : 	file.close();
; 93   : 	const char* source = source_str.c_str();
; 94   : 
; 95   : 	program = clCreateProgramWithSource(context, 1, &source, NULL, &error);
; 96   : 	if(error != CL_SUCCESS)
; 97   : 	{
; 98   : 		GLWindow::instance->postError("Could not create program", "OpenCL program creation error");
; 99   : 		return false;
; 100  : 	}
; 101  : 
; 102  : 	error = clBuildProgram(program, 1, &device, NULL, NULL, NULL);
; 103  : 	if(error != CL_SUCCESS)
; 104  : 	{
; 105  : 		size_t log_size;
; 106  : 		clGetProgramBuildInfo(program, device, CL_PROGRAM_BUILD_LOG, 0, NULL, &log_size);
; 107  : 		char* log_msg = new char[log_size + 1];
; 108  : 		clGetProgramBuildInfo(program, device, CL_PROGRAM_BUILD_LOG, log_size, log_msg, NULL);
; 109  : 
; 110  : 		GLWindow::instance->postError(log_msg, "OpenCL program compilation error");
; 111  : 
; 112  : 		delete[] log_msg;
; 113  : 		return false;
; 114  : 	}
; 115  : 
; 116  : 	okay = true;
; 117  : 	return true;
; 118  : }
; 119  : 
; 120  : cl::Program::~Program()
; 121  : {
; 122  : 	if(okay)
; 123  : 	{
; 124  : 		cl_int error;
; 125  : 
; 126  : 		for(map<std::string, cl_kernel>::const_iterator iter = kernels.begin(); iter != kernels.end(); ++iter)
; 127  : 		{
; 128  : 			error = clReleaseKernel(iter->second);
; 129  : 			if(error != CL_SUCCESS)
; 130  : 			{
; 131  : 				GLWindow::instance->postError("Could not release kernel", "OpenCL program deletion error");
; 132  : 			}
; 133  : 		}
; 134  : 		error = clReleaseProgram(program);
; 135  : 		if(error != CL_SUCCESS)
; 136  : 		{
; 137  : 			GLWindow::instance->postError("Could not release program", "OpenCL program deletion error");
; 138  : 		}
; 139  : 	}
; 140  : }
; 141  : 
; 142  : cl_kernel cl::Program::getKernel(std::string kernel)
; 143  : {
; 144  : 	if(!okay) return 0;
; 145  : 	map<std::string, cl_kernel>::iterator it = kernels.find(kernel);
; 146  : 	if(it != kernels.end())
; 147  : 	{
; 148  : 		return it->second;
; 149  : 	}
; 150  : 
; 151  : 	cl_int error = 0;
; 152  : 	cl_kernel k = clCreateKernel(program, kernel.c_str(), &error);
; 153  : 
; 154  : 	if(error == CL_SUCCESS)
; 155  : 	{
; 156  : 		kernels[kernel] = k;
; 157  : 		return k;
; 158  : 	}
; 159  : 
; 160  : 	GLWindow::instance->postError("Tried to use nonexistant kernel", "OpenCL kernel error");
; 161  : 	return 0;
; 162  : }
; 163  : 
; 164  : bool cl::Program::prepare(std::string kernel)
; 165  : {
; 166  : 	cl_kernel k = getKernel(kernel);
; 167  : 
; 168  : 	if(k)
; 169  : 	{
; 170  : 		mut.lock();
; 171  : 		preparedKernel = k;
; 172  : 		return true;
; 173  : 	}
; 174  : 	else
; 175  : 	{
; 176  : 		return false;
; 177  : 	}
; 178  : }
; 179  : 
; 180  : bool cl::Program::setArgument(int index, size_t size, const void* value)
; 181  : {
; 182  : 	if(!preparedKernel)
; 183  : 	{
; 184  : 		GLWindow::instance->postError("Tried to set argument for unprepared kernel", "OpenCL kernel argument error");
; 185  : 		return false;
; 186  : 	}
; 187  : 	cl_int error = clSetKernelArg(preparedKernel, index, size, value);
; 188  : 	if(error != CL_SUCCESS)
; 189  : 	{
; 190  : 		GLWindow::instance->postError("Failed to set kernel argument", "OpenCL kernel argument error");
; 191  : 		return false;
; 192  : 	}
; 193  : 	return true;
; 194  : }
; 195  : 
; 196  : bool cl::Program::setArgument(int index, size_t size, Buffer* value)
; 197  : {
; 198  : 	return setArgument(index, size, &value->mem);
; 199  : }
; 200  : 
; 201  : bool cl::Program::invoke(CommandQueue& queue, cl_uint dimensions, const size_t* globalWorkSize, const size_t* localWorkSize)
; 202  : {
; 203  : 	if(!preparedKernel)
; 204  : 	{
; 205  : 		GLWindow::instance->postError("Tried to execute unprepared kernel", "OpenCL program execution error");
; 206  : 		return false;
; 207  : 	}
; 208  : 
; 209  : 	cl_int error;
; 210  : 	cl_event event;
; 211  : 
; 212  : 	error = clEnqueueNDRangeKernel(queue.queue, preparedKernel, dimensions, NULL, globalWorkSize, localWorkSize, 0, NULL, &event);
; 213  : 	if(error != CL_SUCCESS)
; 214  : 	{
; 215  : 		GLWindow::instance->postError("Failed to exectue kernel", "OpenCL program execution error");
; 216  : 		return false;
; 217  : 	}
; 218  : 
; 219  : 	error = clWaitForEvents(1, &event);
; 220  : 	if(error != CL_SUCCESS)
; 221  : 	{
; 222  : 		GLWindow::instance->postError("Failed to wait for kernel finish event", "OpenCL program execution error");
; 223  : 		return false;
; 224  : 	}
; 225  : 
; 226  : 	error = clReleaseEvent(event);
; 227  : 	if(error != CL_SUCCESS)
; 228  : 	{
; 229  : 		GLWindow::instance->postError("Failed to release kernel finish event", "OpenCL program execution error");
; 230  : 		return false;
; 231  : 	}
; 232  : 
; 233  : 	preparedKernel = 0;
; 234  : 	mut.unlock();
; 235  : 
; 236  : 	return true;
; 237  : }
; 238  : 
; 239  : cl::Buffer::Buffer()
; 240  : 	: okay(false)
; 241  : {
; 242  : 
; 243  : }
; 244  : 
; 245  : cl::Buffer::~Buffer()
; 246  : {
; 247  : 	if(okay)
; 248  : 	{
; 249  : 		cl_int error = clReleaseMemObject(mem);
; 250  : 		if(error != CL_SUCCESS)
; 251  : 		{
; 252  : 			GLWindow::instance->postError("Failed to delete buffer", "OpenCL buffer deletion error");
; 253  : 		}
; 254  : 	}
; 255  : }
; 256  : 
; 257  : bool cl::Buffer::create(size_t size, int flags, void* data)
; 258  : {
; 259  : 	cl_int error;
; 260  : 	mem = clCreateBuffer(context, flags, size, data, &error);

  00134	48 8d 45 b7	 lea	 rax, QWORD PTR error$1[rbp-121]
  00138	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0013d	45 33 c9	 xor	 r9d, r9d
  00140	41 8d 51 01	 lea	 edx, QWORD PTR [r9+1]
  00144	41 b8 c8 16 00
	00		 mov	 r8d, 5832		; 000016c8H
  0014a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?context@cl@@3PEAU_cl_context@@EA ; cl::context
  00151	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_clCreateBuffer
  00157	48 89 05 08 00
	00 00		 mov	 QWORD PTR ?boolBuffer@@3VBuffer@cl@@A+8, rax

; 261  : 	if(error != CL_SUCCESS)

  0015e	39 7d b7	 cmp	 DWORD PTR error$1[rbp-121], edi
  00161	74 15		 je	 SHORT $LN54@preStart

; 262  : 	{
; 263  : 		GLWindow::instance->postError("Failed to create buffer", "OpenCL buffer creation error");

  00163	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG4294956354
  0016a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG4294956353
  00171	e8 00 00 00 00	 call	 ?postError@GLWindow@@QEAAXPEBD0@Z ; GLWindow::postError

; 264  : 		return false;

  00176	eb 12		 jmp	 SHORT $LN55@preStart
$LN54@preStart:

; 265  : 	}
; 266  : 
; 267  : 	this->size = size;

  00178	48 c7 05 10 00
	00 00 c8 16 00
	00		 mov	 QWORD PTR ?boolBuffer@@3VBuffer@cl@@A+16, 5832 ; 000016c8H

; 268  : 	okay = true;

  00183	c6 05 00 00 00
	00 01		 mov	 BYTE PTR ?boolBuffer@@3VBuffer@cl@@A, 1
$LN55@preStart:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 2265 : 		this->_Myres = this->_BUF_SIZE - 1;

  0018a	48 c7 45 07 07
	00 00 00	 mov	 QWORD PTR filePath$[rbp-97], 7

; 1100 : 		}
; 1101 : 
; 1102 : 	_Myt& assign(const _Myt& _Right,
; 1103 : 		size_type _Roff, size_type _Count)
; 1104 : 		{	// assign _Right [_Roff, _Roff + _Count)
; 1105 : 		if (_Right.size() < _Roff)
; 1106 : 			_Xran();	// _Roff off end
; 1107 : 		size_type _Num = _Right.size() - _Roff;
; 1108 : 		if (_Count < _Num)
; 1109 : 			_Num = _Count;	// trim _Num to size
; 1110 : 
; 1111 : 		if (this == &_Right)
; 1112 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring
; 1113 : 		else if (_Grow(_Num))
; 1114 : 			{	// make room and assign new stuff
; 1115 : 			_Traits::copy(this->_Myptr(),
; 1116 : 				_Right._Myptr() + _Roff, _Num);
; 1117 : 			_Eos(_Num);
; 1118 : 			}
; 1119 : 		return (*this);
; 1120 : 		}
; 1121 : 
; 1122 : 	_Myt& assign(const _Elem *_Ptr, size_type _Count)
; 1123 : 		{	// assign [_Ptr, _Ptr + _Count)
; 1124 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1125 : 		if (_Count != 0)
; 1126 : 			_DEBUG_POINTER(_Ptr);
; 1127 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1128 : 
; 1129 : 		if (_Inside(_Ptr))
; 1130 : 			return (assign(*this,
; 1131 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1132 : 
; 1133 : 		if (_Grow(_Count))
; 1134 : 			{	// make room and assign new stuff
; 1135 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);
; 1136 : 			_Eos(_Count);
; 1137 : 			}
; 1138 : 		return (*this);
; 1139 : 		}
; 1140 : 
; 1141 : 	_Myt& assign(const _Elem *_Ptr)
; 1142 : 		{	// assign [_Ptr, <null>)
; 1143 : 		_DEBUG_POINTER(_Ptr);
; 1144 : 		return (assign(_Ptr, _Traits::length(_Ptr)));
; 1145 : 		}
; 1146 : 
; 1147 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1148 : 		{	// assign _Count * _Ch
; 1149 : 		if (_Count == npos)
; 1150 : 			_Xlen();	// result too long
; 1151 : 
; 1152 : 		if (_Grow(_Count))
; 1153 : 			{	// make room and assign new stuff
; 1154 : 			_Chassign(0, _Count, _Ch);
; 1155 : 			_Eos(_Count);
; 1156 : 			}
; 1157 : 		return (*this);
; 1158 : 		}
; 1159 : 
; 1160 : 	template<class _Iter>
; 1161 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1162 : 			_Myt&>::type
; 1163 : 		assign(_Iter _First, _Iter _Last)
; 1164 : 		{	// assign [First, _Last), input iterators
; 1165 : 		return (replace(begin(), end(), _First, _Last));
; 1166 : 		}
; 1167 : 
; 1168 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1169 : 		{	// assign [First, _Last), const pointers
; 1170 : 		return (replace(begin(), end(), _First, _Last));
; 1171 : 		}
; 1172 : 
; 1173 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1174 : 		{	// assign [First, _Last), const_iterators
; 1175 : 		return (replace(begin(), end(), _First, _Last));
; 1176 : 		}
; 1177 : 
; 1178 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1179 : 		{	// insert _Right at _Off
; 1180 : 		return (insert(_Off, _Right, 0, npos));
; 1181 : 		}
; 1182 : 
; 1183 : 	_Myt& insert(size_type _Off,
; 1184 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1185 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1186 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1187 : 			_Xran();	// _Off or _Roff off end
; 1188 : 		size_type _Num = _Right.size() - _Roff;
; 1189 : 		if (_Num < _Count)
; 1190 : 			_Count = _Num;	// trim _Count to size
; 1191 : 		if (npos - this->_Mysize <= _Count)
; 1192 : 			_Xlen();	// result too long
; 1193 : 
; 1194 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1195 : 			{	// make room and insert new stuff
; 1196 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1197 : 				this->_Myptr() + _Off,
; 1198 : 				this->_Mysize - _Off);	// empty out hole
; 1199 : 			if (this == &_Right)
; 1200 : 				_Traits::move(this->_Myptr() + _Off,
; 1201 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1202 : 						_Count);	// substring
; 1203 : 			else
; 1204 : 				_Traits::copy(this->_Myptr() + _Off,
; 1205 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1206 : 			_Eos(_Num);
; 1207 : 			}
; 1208 : 		return (*this);
; 1209 : 		}
; 1210 : 
; 1211 : 	_Myt& insert(size_type _Off,
; 1212 : 		const _Elem *_Ptr, size_type _Count)
; 1213 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1214 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1215 : 		if (_Count != 0)
; 1216 : 			_DEBUG_POINTER(_Ptr);
; 1217 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1218 : 
; 1219 : 		if (_Inside(_Ptr))
; 1220 : 			return (insert(_Off, *this,
; 1221 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1222 : 		if (this->_Mysize < _Off)
; 1223 : 			_Xran();	// _Off off end
; 1224 : 		if (npos - this->_Mysize <= _Count)
; 1225 : 			_Xlen();	// result too long
; 1226 : 		size_type _Num;
; 1227 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1228 : 			{	// make room and insert new stuff
; 1229 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1230 : 				this->_Myptr() + _Off,
; 1231 : 				this->_Mysize - _Off);	// empty out hole
; 1232 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1233 : 			_Eos(_Num);
; 1234 : 			}
; 1235 : 		return (*this);
; 1236 : 		}
; 1237 : 
; 1238 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1239 : 		{	// insert [_Ptr, <null>) at _Off
; 1240 : 		_DEBUG_POINTER(_Ptr);
; 1241 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1242 : 		}
; 1243 : 
; 1244 : 	_Myt& insert(size_type _Off,
; 1245 : 		size_type _Count, _Elem _Ch)
; 1246 : 		{	// insert _Count * _Ch at _Off
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	iterator insert(const_iterator _Where)
; 1264 : 		{	// insert <null> at _Where
; 1265 : 		return (insert(_Where, _Elem()));
; 1266 : 		}
; 1267 : 
; 1268 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1269 : 		{	// insert _Ch at _Where
; 1270 : 		size_type _Off = _Pdif(_Where, begin());
; 1271 : 		insert(_Off, 1, _Ch);
; 1272 : 		return (begin() + _Off);
; 1273 : 		}
; 1274 : 
; 1275 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1276 : 		{	// insert _Count * _Elem at _Where
; 1277 : 		size_type _Off = _Pdif(_Where, begin());
; 1278 : 		insert(_Off, _Count, _Ch);
; 1279 : 		return (begin() + _Off);
; 1280 : 		}
; 1281 : 
; 1282 : 	template<class _Iter>
; 1283 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1284 : 			iterator>::type
; 1285 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1286 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1287 : 		size_type _Off = _Pdif(_Where, begin());
; 1288 : 		replace(_Where, _Where, _First, _Last);
; 1289 : 		return (begin() + _Off);
; 1290 : 		}
; 1291 : 
; 1292 : 	iterator insert(const_iterator _Where,
; 1293 : 		const_pointer _First, const_pointer _Last)
; 1294 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		replace(_Where, _Where, _First, _Last);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where,
; 1301 : 		const_iterator _First, const_iterator _Last)
; 1302 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1303 : 		size_type _Off = _Pdif(_Where, begin());
; 1304 : 		replace(_Where, _Where, _First, _Last);
; 1305 : 		return (begin() + _Off);
; 1306 : 		}
; 1307 : 
; 1308 : 	_Myt& erase(size_type _Off = 0)
; 1309 : 		{	// erase elements [_Off, ...)
; 1310 : 		if (this->_Mysize < _Off)
; 1311 : 			_Xran();	// _Off off end
; 1312 : 		_Eos(_Off);
; 1313 : 		return (*this);
; 1314 : 		}
; 1315 : 
; 1316 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1317 : 		{	// erase elements [_Off, _Off + _Count)
; 1318 : 		if (this->_Mysize < _Off)
; 1319 : 			_Xran();	// _Off off end
; 1320 : 		if (this->_Mysize - _Off <= _Count)
; 1321 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1322 : 		else if (0 < _Count)
; 1323 : 			{	// move elements down
; 1324 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1325 : 			size_type _Newsize = this->_Mysize - _Count;
; 1326 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1327 : 			_Eos(_Newsize);
; 1328 : 			}
; 1329 : 		return (*this);
; 1330 : 		}
; 1331 : 
; 1332 : 	iterator erase(const_iterator _Where)
; 1333 : 		{	// erase element at _Where
; 1334 : 		size_type _Count = _Pdif(_Where, begin());
; 1335 : 		erase(_Count, 1);
; 1336 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1337 : 		}
; 1338 : 
; 1339 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1340 : 		{	// erase substring [_First, _Last)
; 1341 : 		_DEBUG_RANGE(_First, _Last);
; 1342 : 		size_type _Count = _Pdif(_First, begin());
; 1343 : 		erase(_Count, _Pdif(_Last, _First));
; 1344 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1345 : 		}
; 1346 : 
; 1347 : 	void clear() _NOEXCEPT
; 1348 : 		{	// erase all
; 1349 : 		_Eos(0);
; 1350 : 		}
; 1351 : 
; 1352 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1353 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1354 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1355 : 		}
; 1356 : 
; 1357 : 	_Myt& replace(size_type _Off,
; 1358 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1359 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1360 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1361 : 			_Xran();	// _Off or _Roff off end
; 1362 : 		if (this->_Mysize - _Off < _N0)
; 1363 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1364 : 		size_type _Num = _Right.size() - _Roff;
; 1365 : 		if (_Num < _Count)
; 1366 : 			_Count = _Num;	// trim _Count to size
; 1367 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1368 : 			_Xlen();	// result too long
; 1369 : 
; 1370 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1371 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1372 : 		if (this->_Mysize < _Newsize)
; 1373 : 			_Grow(_Newsize);
; 1374 : 
; 1375 : 		if (this != &_Right)
; 1376 : 			{	// no overlap, just move down and copy in new stuff
; 1377 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1378 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1379 : 			_Traits::copy(this->_Myptr() + _Off,
; 1380 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1381 : 			}
; 1382 : 		else if (_Count <= _N0)
; 1383 : 			{	// hole doesn't get larger, just copy in substring
; 1384 : 			_Traits::move(this->_Myptr() + _Off,
; 1385 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1386 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1387 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1388 : 			}
; 1389 : 		else if (_Roff <= _Off)
; 1390 : 			{	// hole gets larger, substring begins before hole
; 1391 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1392 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1393 : 			_Traits::move(this->_Myptr() + _Off,
; 1394 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1395 : 			}
; 1396 : 		else if (_Off + _N0 <= _Roff)
; 1397 : 			{	// hole gets larger, substring begins after hole
; 1398 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1399 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1400 : 			_Traits::move(this->_Myptr() + _Off,
; 1401 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1402 : 				_Count);	// fill hole
; 1403 : 			}
; 1404 : 		else
; 1405 : 			{	// hole gets larger, substring begins in hole
; 1406 : 			_Traits::move(this->_Myptr() + _Off,
; 1407 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1408 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1409 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1410 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1411 : 				this->_Myptr() + _Roff + _Count,
; 1412 : 				_Count - _N0);	// fill rest of new hole
; 1413 : 			}
; 1414 : 
; 1415 : 		_Eos(_Newsize);
; 1416 : 		return (*this);
; 1417 : 		}
; 1418 : 
; 1419 : 	_Myt& replace(size_type _Off,
; 1420 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1421 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1422 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1423 : 		if (_Count != 0)
; 1424 : 			_DEBUG_POINTER(_Ptr);
; 1425 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1426 : 
; 1427 : 		if (_Inside(_Ptr))
; 1428 : 			return (replace(_Off, _N0, *this,
; 1429 : 				_Ptr - this->_Myptr(),
; 1430 : 				_Count));	// substring, replace carefully
; 1431 : 		if (this->_Mysize < _Off)
; 1432 : 			_Xran();	// _Off off end
; 1433 : 		if (this->_Mysize - _Off < _N0)
; 1434 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1435 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1436 : 			_Xlen();	// result too long
; 1437 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1438 : 
; 1439 : 		if (_Count < _N0)
; 1440 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1441 : 				this->_Myptr() + _Off + _N0,
; 1442 : 				_Nm);	// smaller hole, move tail up
; 1443 : 		size_type _Num;
; 1444 : 		if ((0 < _Count || 0 < _N0)
; 1445 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1446 : 			{	// make room and rearrange
; 1447 : 			if (_N0 < _Count)
; 1448 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1449 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1450 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1451 : 			_Eos(_Num);
; 1452 : 			}
; 1453 : 		return (*this);
; 1454 : 		}
; 1455 : 
; 1456 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1457 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1458 : 		_DEBUG_POINTER(_Ptr);
; 1459 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1460 : 		}
; 1461 : 
; 1462 : 	_Myt& replace(size_type _Off,
; 1463 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1464 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1465 : 		if (this->_Mysize < _Off)
; 1466 : 			_Xran();	// _Off off end
; 1467 : 		if (this->_Mysize - _Off < _N0)
; 1468 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1469 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1470 : 			_Xlen();	// result too long
; 1471 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1472 : 
; 1473 : 		if (_Count < _N0)
; 1474 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1475 : 				this->_Myptr() + _Off + _N0,
; 1476 : 				_Nm);	// smaller hole, move tail up
; 1477 : 		size_type _Num;
; 1478 : 		if ((0 < _Count || 0 < _N0)
; 1479 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1480 : 			{	// make room and rearrange
; 1481 : 			if (_N0 < _Count)
; 1482 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1483 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1484 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1485 : 			_Eos(_Num);
; 1486 : 			}
; 1487 : 		return (*this);
; 1488 : 		}
; 1489 : 
; 1490 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1491 : 		const _Myt& _Right)
; 1492 : 		{	// replace [_First, _Last) with _Right
; 1493 : 		return (replace(
; 1494 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1495 : 		}
; 1496 : 
; 1497 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1498 : 		const _Elem *_Ptr, size_type _Count)
; 1499 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1500 : 		return (replace(
; 1501 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1502 : 		}
; 1503 : 
; 1504 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1505 : 		const _Elem *_Ptr)
; 1506 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1507 : 		return (replace(
; 1508 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1509 : 		}
; 1510 : 
; 1511 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1512 : 		size_type _Count, _Elem _Ch)
; 1513 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1514 : 		return (replace(
; 1515 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1516 : 		}
; 1517 : 
; 1518 : 	template<class _Iter>
; 1519 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1520 : 			_Myt&>::type
; 1521 : 		replace(const_iterator _First, const_iterator _Last,
; 1522 : 			_Iter _First2, _Iter _Last2)
; 1523 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1524 : 		_Myt _Right(_First2, _Last2);
; 1525 : 		replace(_First, _Last, _Right);
; 1526 : 		return (*this);
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const_pointer _First2, const_pointer _Last2)
; 1531 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1532 : 		if (_First2 == _Last2)
; 1533 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1534 : 		else
; 1535 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1536 : 				&*_First2, _Last2 - _First2);
; 1537 : 		return (*this);
; 1538 : 		}
; 1539 : 
; 1540 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1541 : 		pointer _First2, pointer _Last2)
; 1542 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1543 : 		if (_First2 == _Last2)
; 1544 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1545 : 		else
; 1546 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1547 : 				&*_First2, _Last2 - _First2);
; 1548 : 		return (*this);
; 1549 : 		}
; 1550 : 
; 1551 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1552 : 		const_iterator _First2, const_iterator _Last2)
; 1553 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1554 : 		if (_First2 == _Last2)
; 1555 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1556 : 		else
; 1557 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1558 : 				&*_First2, _Last2 - _First2);
; 1559 : 		return (*this);
; 1560 : 		}
; 1561 : 
; 1562 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1563 : 		iterator _First2, iterator _Last2)
; 1564 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1565 : 		if (_First2 == _Last2)
; 1566 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1567 : 		else
; 1568 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1569 : 				&*_First2, _Last2 - _First2);
; 1570 : 		return (*this);
; 1571 : 		}
; 1572 : 
; 1573 : 	iterator begin() _NOEXCEPT
; 1574 : 		{	// return iterator for beginning of mutable sequence
; 1575 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1576 : 		}
; 1577 : 
; 1578 : 	const_iterator begin() const _NOEXCEPT
; 1579 : 		{	// return iterator for beginning of nonmutable sequence
; 1580 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1581 : 		}
; 1582 : 
; 1583 : 	iterator end() _NOEXCEPT
; 1584 : 		{	// return iterator for end of mutable sequence
; 1585 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1586 : 		}
; 1587 : 
; 1588 : 	const_iterator end() const _NOEXCEPT
; 1589 : 		{	// return iterator for end of nonmutable sequence
; 1590 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1591 : 		}
; 1592 : 
; 1593 : 	reverse_iterator rbegin() _NOEXCEPT
; 1594 : 		{	// return iterator for beginning of reversed mutable sequence
; 1595 : 		return (reverse_iterator(end()));
; 1596 : 		}
; 1597 : 
; 1598 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1600 : 		return (const_reverse_iterator(end()));
; 1601 : 		}
; 1602 : 
; 1603 : 	reverse_iterator rend() _NOEXCEPT
; 1604 : 		{	// return iterator for end of reversed mutable sequence
; 1605 : 		return (reverse_iterator(begin()));
; 1606 : 		}
; 1607 : 
; 1608 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1609 : 		{	// return iterator for end of reversed nonmutable sequence
; 1610 : 		return (const_reverse_iterator(begin()));
; 1611 : 		}
; 1612 : 
; 1613 :  #if _HAS_CPP0X
; 1614 : 	const_iterator cbegin() const _NOEXCEPT
; 1615 : 		{	// return iterator for beginning of nonmutable sequence
; 1616 : 		return (((const _Myt *)this)->begin());
; 1617 : 		}
; 1618 : 
; 1619 : 	const_iterator cend() const _NOEXCEPT
; 1620 : 		{	// return iterator for end of nonmutable sequence
; 1621 : 		return (((const _Myt *)this)->end());
; 1622 : 		}
; 1623 : 
; 1624 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1625 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1626 : 		return (((const _Myt *)this)->rbegin());
; 1627 : 		}
; 1628 : 
; 1629 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1630 : 		{	// return iterator for end of reversed nonmutable sequence
; 1631 : 		return (((const _Myt *)this)->rend());
; 1632 : 		}
; 1633 : 
; 1634 : 	void shrink_to_fit()
; 1635 : 		{	// reduce capacity
; 1636 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1637 : 			{	// worth shrinking, do it
; 1638 : 			_Myt _Tmp(*this);
; 1639 : 			swap(_Tmp);
; 1640 : 			}
; 1641 : 		}
; 1642 :  #endif /* _HAS_CPP0X */
; 1643 : 
; 1644 : 	reference at(size_type _Off)
; 1645 : 		{	// subscript mutable sequence with checking
; 1646 : 		if (this->_Mysize <= _Off)
; 1647 : 			_Xran();	// _Off off end
; 1648 : 		return (this->_Myptr()[_Off]);
; 1649 : 		}
; 1650 : 
; 1651 : 	const_reference at(size_type _Off) const
; 1652 : 		{	// subscript nonmutable sequence with checking
; 1653 : 		if (this->_Mysize <= _Off)
; 1654 : 			_Xran();	// _Off off end
; 1655 : 		return (this->_Myptr()[_Off]);
; 1656 : 		}
; 1657 : 
; 1658 : 	reference operator[](size_type _Off)
; 1659 : 		{	// subscript mutable sequence
; 1660 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1661 : 		if (this->_Mysize < _Off)	// sic
; 1662 : 			_DEBUG_ERROR("string subscript out of range");
; 1663 : 
; 1664 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1665 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1666 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1667 : 
; 1668 : 		return (this->_Myptr()[_Off]);
; 1669 : 		}
; 1670 : 
; 1671 : 	const_reference operator[](size_type _Off) const
; 1672 : 		{	// subscript nonmutable sequence
; 1673 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1674 : 		if (this->_Mysize < _Off)	// sic
; 1675 : 			_DEBUG_ERROR("string subscript out of range");
; 1676 : 
; 1677 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1678 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1679 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1680 : 
; 1681 : 		return (this->_Myptr()[_Off]);
; 1682 : 		}
; 1683 : 
; 1684 : 	void push_back(_Elem _Ch)
; 1685 : 		{	// insert element at end
; 1686 : 		insert(end(), _Ch);
; 1687 : 		}
; 1688 : 
; 1689 :  #if _HAS_CPP0X
; 1690 : 	void pop_back()
; 1691 : 		{	// erase element at end
; 1692 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1693 : 		}
; 1694 : 
; 1695 : 	reference front()
; 1696 : 		{	// return first element of mutable sequence
; 1697 : 		return (*begin());
; 1698 : 		}
; 1699 : 
; 1700 : 	const_reference front() const
; 1701 : 		{	// return first element of nonmutable sequence
; 1702 : 		return (*begin());
; 1703 : 		}
; 1704 : 
; 1705 : 	reference back()
; 1706 : 		{	// return last element of mutable sequence
; 1707 : 		return (*(end() - 1));
; 1708 : 		}
; 1709 : 
; 1710 : 	const_reference back() const
; 1711 : 		{	// return last element of nonmutable sequence
; 1712 : 		return (*(end() - 1));
; 1713 : 		}
; 1714 :  #endif /* _HAS_CPP0X */
; 1715 : 
; 1716 : 	const _Elem *c_str() const _NOEXCEPT
; 1717 : 		{	// return pointer to null-terminated nonmutable array
; 1718 : 		return (this->_Myptr());
; 1719 : 		}
; 1720 : 
; 1721 : 	const _Elem *data() const _NOEXCEPT
; 1722 : 		{	// return pointer to nonmutable array
; 1723 : 		return (c_str());
; 1724 : 		}
; 1725 : 
; 1726 : 	size_type length() const _NOEXCEPT
; 1727 : 		{	// return length of sequence
; 1728 : 		return (this->_Mysize);
; 1729 : 		}
; 1730 : 
; 1731 : 	size_type size() const _NOEXCEPT
; 1732 : 		{	// return length of sequence
; 1733 : 		return (this->_Mysize);
; 1734 : 		}
; 1735 : 
; 1736 : 	size_type max_size() const _NOEXCEPT
; 1737 : 		{	// return maximum possible length of sequence
; 1738 : 		size_type _Num = this->_Getal().max_size();
; 1739 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1740 : 		}
; 1741 : 
; 1742 : 	void resize(size_type _Newsize)
; 1743 : 		{	// determine new length, padding with null elements as needed
; 1744 : 		resize(_Newsize, _Elem());
; 1745 : 		}
; 1746 : 
; 1747 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1748 : 		{	// determine new length, padding with _Ch elements as needed
; 1749 : 		if (_Newsize <= this->_Mysize)
; 1750 : 			_Eos(_Newsize);
; 1751 : 		else
; 1752 : 			append(_Newsize - this->_Mysize, _Ch);
; 1753 : 		}
; 1754 : 
; 1755 : 	size_type capacity() const _NOEXCEPT
; 1756 : 		{	// return current length of allocated storage
; 1757 : 		return (this->_Myres);
; 1758 : 		}
; 1759 : 
; 1760 : 	void reserve(size_type _Newcap = 0)
; 1761 : 		{	// determine new minimum length of allocated storage
; 1762 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1763 : 			{	// change reservation
; 1764 : 			size_type _Size = this->_Mysize;
; 1765 : 			if (_Grow(_Newcap, true))
; 1766 : 				_Eos(_Size);
; 1767 : 			}
; 1768 : 		}
; 1769 : 
; 1770 : 	bool empty() const _NOEXCEPT
; 1771 : 		{	// test if sequence is empty
; 1772 : 		return (this->_Mysize == 0);
; 1773 : 		}
; 1774 : 
; 1775 : 	_SCL_INSECURE_DEPRECATE
; 1776 : 
; 1777 : 	size_type copy(_Elem *_Ptr,
; 1778 : 		size_type _Count, size_type _Off = 0) const
; 1779 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1780 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1781 : 		if (_Count != 0)
; 1782 : 			_DEBUG_POINTER(_Ptr);
; 1783 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1784 : 
; 1785 : 		if (this->_Mysize < _Off)
; 1786 : 			_Xran();	// _Off off end
; 1787 : 		if (this->_Mysize - _Off < _Count)
; 1788 : 			_Count = this->_Mysize - _Off;
; 1789 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1790 : 		return (_Count);
; 1791 : 		}
; 1792 : 
; 1793 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1794 : 		size_type _Count, size_type _Off = 0) const
; 1795 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1796 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1797 : 		if (_Count != 0)
; 1798 : 			_DEBUG_POINTER(_Dest);
; 1799 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1800 : 
; 1801 : 		if (this->_Mysize < _Off)
; 1802 : 			_Xran();	// _Off off end
; 1803 : 		if (this->_Mysize - _Off < _Count)
; 1804 : 			_Count = this->_Mysize - _Off;
; 1805 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1806 : 		return (_Count);
; 1807 : 		}
; 1808 : 
; 1809 : 	void _Swap_bx(_Myt& _Right)
; 1810 : 		{	// exchange _Bx with _Right._Bx
; 1811 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1812 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1813 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1814 : 			else
; 1815 : 				{	// swap large with small
; 1816 : 				pointer _Ptr = this->_Bx._Ptr;
; 1817 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1818 : 				_Traits::copy(this->_Bx._Buf,
; 1819 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1820 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1821 : 				}
; 1822 : 		else
; 1823 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1824 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1825 : 			else
; 1826 : 				{	// swap small with large
; 1827 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1828 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1829 : 				_Traits::copy(_Right._Bx._Buf,
; 1830 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1831 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1832 : 				}
; 1833 : 		}
; 1834 : 
; 1835 : 	void swap(_Myt& _Right)
; 1836 : 		{	// exchange contents with _Right
; 1837 : 		if (this == &_Right)
; 1838 : 			;	// same object, do nothing
; 1839 : 		else if (this->_Getal() == _Right._Getal())
; 1840 : 			{	// same allocator, swap control information
; 1841 : 			this->_Swap_all(_Right);
; 1842 : 			_Swap_bx(_Right);
; 1843 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1844 : 			_STD swap(this->_Myres, _Right._Myres);
; 1845 : 			}
; 1846 : 
; 1847 :  #if _HAS_CPP0X
; 1848 : 		else if (_Alty::propagate_on_container_swap::value)
; 1849 : 			{	// swap allocators and control information
; 1850 : 			this->_Swap_alloc(_Right);
; 1851 : 			_Swap_bx(_Right);
; 1852 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1853 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1854 : 			_STD swap(this->_Myres, _Right._Myres);
; 1855 : 			}
; 1856 :  #endif /* _HAS_CPP0X */
; 1857 : 
; 1858 : 		else
; 1859 : 			{	// different allocator, do multiple assigns
; 1860 : 			_Myt _Tmp = *this;
; 1861 : 
; 1862 : 			*this = _Right;
; 1863 : 			_Right = _Tmp;
; 1864 : 			}
; 1865 : 		}
; 1866 : 
; 1867 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1868 : 		{	// look for _Right beginning at or after _Off
; 1869 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1870 : 		}
; 1871 : 
; 1872 : 	size_type find(const _Elem *_Ptr,
; 1873 : 		size_type _Off, size_type _Count) const
; 1874 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1875 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1876 : 		if (_Count != 0)
; 1877 : 			_DEBUG_POINTER(_Ptr);
; 1878 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1879 : 
; 1880 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1881 : 			return (_Off);	// null string always matches (if inside string)
; 1882 : 
; 1883 : 		size_type _Nm;
; 1884 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1885 : 			{	// room for match, look for it
; 1886 : 			const _Elem *_Uptr, *_Vptr;
; 1887 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1888 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1889 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1890 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1891 : 					return (_Uptr - this->_Myptr());	// found a match
; 1892 : 			}
; 1893 : 
; 1894 : 		return (npos);	// no match
; 1895 : 		}
; 1896 : 
; 1897 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1898 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1899 : 		_DEBUG_POINTER(_Ptr);
; 1900 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1901 : 		}
; 1902 : 
; 1903 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1904 : 		{	// look for _Ch at or after _Off
; 1905 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1906 : 		}
; 1907 : 
; 1908 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1909 : 		{	// look for _Right beginning before _Off
; 1910 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1911 : 		}
; 1912 : 
; 1913 : 	size_type rfind(const _Elem *_Ptr,
; 1914 : 		size_type _Off, size_type _Count) const
; 1915 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1916 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1917 : 		if (_Count != 0)
; 1918 : 			_DEBUG_POINTER(_Ptr);
; 1919 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1920 : 
; 1921 : 		if (_Count == 0)
; 1922 : 			return (_Off < this->_Mysize ? _Off
; 1923 : 				: this->_Mysize);	// null always matches
; 1924 : 		if (_Count <= this->_Mysize)
; 1925 : 			{	// room for match, look for it
; 1926 : 			const _Elem *_Uptr = this->_Myptr() +
; 1927 : 				(_Off < this->_Mysize - _Count ? _Off
; 1928 : 					: this->_Mysize - _Count);
; 1929 : 			for (; ; --_Uptr)
; 1930 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1931 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1932 : 					return (_Uptr - this->_Myptr());	// found a match
; 1933 : 				else if (_Uptr == this->_Myptr())
; 1934 : 					break;	// at beginning, no more chance for match
; 1935 : 			}
; 1936 : 
; 1937 : 		return (npos);	// no match
; 1938 : 		}
; 1939 : 
; 1940 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1941 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1942 : 		_DEBUG_POINTER(_Ptr);
; 1943 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1944 : 		}
; 1945 : 
; 1946 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1947 : 		{	// look for _Ch before _Off
; 1948 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1949 : 		}
; 1950 : 
; 1951 : 	size_type find_first_of(const _Myt& _Right,
; 1952 : 		size_type _Off = 0) const _NOEXCEPT
; 1953 : 		{	// look for one of _Right at or after _Off
; 1954 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1955 : 		}
; 1956 : 
; 1957 : 	size_type find_first_of(const _Elem *_Ptr,
; 1958 : 		size_type _Off, size_type _Count) const
; 1959 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1960 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1961 : 		if (_Count != 0)
; 1962 : 			_DEBUG_POINTER(_Ptr);
; 1963 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1964 : 
; 1965 : 		if (0 < _Count && _Off < this->_Mysize)
; 1966 : 			{	// room for match, look for it
; 1967 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1968 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1969 : 				_Uptr < _Vptr; ++_Uptr)
; 1970 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1971 : 					return (_Uptr - this->_Myptr());	// found a match
; 1972 : 			}
; 1973 : 
; 1974 : 		return (npos);	// no match
; 1975 : 		}
; 1976 : 
; 1977 : 	size_type find_first_of(const _Elem *_Ptr,
; 1978 : 		size_type _Off = 0) const
; 1979 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1980 : 		_DEBUG_POINTER(_Ptr);
; 1981 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 1982 : 		}
; 1983 : 
; 1984 : 	size_type find_first_of(_Elem _Ch,
; 1985 : 		size_type _Off = 0) const
; 1986 : 		{	// look for _Ch at or after _Off
; 1987 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1988 : 		}
; 1989 : 
; 1990 : 	size_type find_last_of(const _Myt& _Right,
; 1991 : 		size_type _Off = npos) const _NOEXCEPT
; 1992 : 		{	// look for one of _Right before _Off
; 1993 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_last_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off, size_type _Count) const
; 1998 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 1999 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2000 : 		if (_Count != 0)
; 2001 : 			_DEBUG_POINTER(_Ptr);
; 2002 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2003 : 
; 2004 : 		if (0 < _Count && 0 < this->_Mysize)
; 2005 : 			{	// worth searching, do it
; 2006 : 			const _Elem *_Uptr = this->_Myptr()
; 2007 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2008 : 			for (; ; --_Uptr)
; 2009 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2010 : 					return (_Uptr - this->_Myptr());	// found a match
; 2011 : 				else if (_Uptr == this->_Myptr())
; 2012 : 					break;	// at beginning, no more chance for match
; 2013 : 			}
; 2014 : 
; 2015 : 		return (npos);	// no match
; 2016 : 		}
; 2017 : 
; 2018 : 	size_type find_last_of(const _Elem *_Ptr,
; 2019 : 		size_type _Off = npos) const
; 2020 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2021 : 		_DEBUG_POINTER(_Ptr);
; 2022 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2023 : 		}
; 2024 : 
; 2025 : 	size_type find_last_of(_Elem _Ch,
; 2026 : 		size_type _Off = npos) const
; 2027 : 		{	// look for _Ch before _Off
; 2028 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2029 : 		}
; 2030 : 
; 2031 : 	size_type find_first_not_of(const _Myt& _Right,
; 2032 : 		size_type _Off = 0) const _NOEXCEPT
; 2033 : 		{	// look for none of _Right at or after _Off
; 2034 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2035 : 			_Right.size()));
; 2036 : 		}
; 2037 : 
; 2038 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2039 : 		size_type _Off, size_type _Count) const
; 2040 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2041 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2042 : 		if (_Count != 0)
; 2043 : 			_DEBUG_POINTER(_Ptr);
; 2044 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2045 : 
; 2046 : 		if (_Off < this->_Mysize)
; 2047 : 			{	// room for match, look for it
; 2048 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2049 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2050 : 				_Uptr < _Vptr; ++_Uptr)
; 2051 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2052 : 					return (_Uptr - this->_Myptr());
; 2053 : 			}
; 2054 : 		return (npos);
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off = 0) const
; 2059 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2060 : 		_DEBUG_POINTER(_Ptr);
; 2061 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2062 : 		}
; 2063 : 
; 2064 : 	size_type find_first_not_of(_Elem _Ch,
; 2065 : 		size_type _Off = 0) const
; 2066 : 		{	// look for non _Ch at or after _Off
; 2067 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2068 : 		}
; 2069 : 
; 2070 : 	size_type find_last_not_of(const _Myt& _Right,
; 2071 : 		size_type _Off = npos) const _NOEXCEPT
; 2072 : 		{	// look for none of _Right before _Off
; 2073 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off, size_type _Count) const
; 2078 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2079 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2080 : 		if (_Count != 0)
; 2081 : 			_DEBUG_POINTER(_Ptr);
; 2082 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2083 : 
; 2084 : 		if (0 < this->_Mysize)
; 2085 : 			{	// worth searching, do it
; 2086 : 			const _Elem *_Uptr = this->_Myptr()
; 2087 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2088 : 			for (; ; --_Uptr)
; 2089 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2090 : 					return (_Uptr - this->_Myptr());
; 2091 : 				else if (_Uptr == this->_Myptr())
; 2092 : 					break;
; 2093 : 			}
; 2094 : 		return (npos);
; 2095 : 		}
; 2096 : 
; 2097 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2098 : 		size_type _Off = npos) const
; 2099 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2100 : 		_DEBUG_POINTER(_Ptr);
; 2101 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2102 : 		}
; 2103 : 
; 2104 : 	size_type find_last_not_of(_Elem _Ch,
; 2105 : 		size_type _Off = npos) const
; 2106 : 		{	// look for non _Ch before _Off
; 2107 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2108 : 		}
; 2109 : 
; 2110 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2111 : 		{	// return [_Off, _Off + _Count) as new string
; 2112 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2113 : 		}
; 2114 : 
; 2115 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2116 : 		{	// compare [0, _Mysize) with _Right
; 2117 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2118 : 		}
; 2119 : 
; 2120 : 	int compare(size_type _Off, size_type _N0,
; 2121 : 		const _Myt& _Right) const
; 2122 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2123 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2124 : 		}
; 2125 : 
; 2126 : 	int compare(size_type _Off,
; 2127 : 		size_type _N0, const _Myt& _Right,
; 2128 : 		size_type _Roff, size_type _Count) const
; 2129 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2130 : 		if (_Right.size() < _Roff)
; 2131 : 			_Xran();	// _Off off end
; 2132 : 		if (_Right._Mysize - _Roff < _Count)
; 2133 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2134 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2135 : 		}
; 2136 : 
; 2137 : 	int compare(const _Elem *_Ptr) const
; 2138 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2139 : 		_DEBUG_POINTER(_Ptr);
; 2140 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2141 : 		}
; 2142 : 
; 2143 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2144 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2145 : 		_DEBUG_POINTER(_Ptr);
; 2146 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2147 : 		}
; 2148 : 
; 2149 : 	int compare(size_type _Off,
; 2150 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2151 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2152 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2153 : 		if (_Count != 0)
; 2154 : 			_DEBUG_POINTER(_Ptr);
; 2155 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2156 : 
; 2157 : 		if (this->_Mysize < _Off)
; 2158 : 			_Xran();	// _Off off end
; 2159 : 		if (this->_Mysize - _Off < _N0)
; 2160 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2161 : 
; 2162 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2163 : 			_N0 < _Count ? _N0 : _Count);
; 2164 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2165 : 			: _N0 == _Count ? 0 : +1);
; 2166 : 		}
; 2167 : 
; 2168 : 	allocator_type get_allocator() const _NOEXCEPT
; 2169 : 		{	// return allocator object for values
; 2170 : 		return (this->_Getal());
; 2171 : 		}
; 2172 : 
; 2173 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2174 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2175 : 		if (_Count == 1)
; 2176 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2177 : 		else
; 2178 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2179 : 		}
; 2180 : 
; 2181 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2182 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2183 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2184 : 		if (max_size() < _Newres)
; 2185 : 			_Newres = _Newsize;	// undo roundup if too big
; 2186 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2187 : 			;
; 2188 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2189 : 			_Newres = this->_Myres
; 2190 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2191 : 		else
; 2192 : 			_Newres = max_size();	// settle for max_size()
; 2193 : 
; 2194 : 		_Elem *_Ptr;
; 2195 : 		_TRY_BEGIN
; 2196 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2197 : 		_CATCH_ALL
; 2198 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2199 : 			_TRY_BEGIN
; 2200 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2201 : 			_CATCH_ALL
; 2202 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2203 : 			_RERAISE;
; 2204 : 			_CATCH_END
; 2205 : 		_CATCH_END
; 2206 : 
; 2207 : 		if (0 < _Oldlen)
; 2208 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2209 : 				_Oldlen);	// copy existing elements
; 2210 : 		_Tidy(true);
; 2211 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2212 : 		this->_Myres = _Newres;
; 2213 : 		_Eos(_Oldlen);
; 2214 : 		}
; 2215 : 
; 2216 : 	void _Eos(size_type _Newsize)
; 2217 : 		{	// set new length and null terminator
; 2218 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  00192	48 89 7d ff	 mov	 QWORD PTR filePath$[rbp-105], rdi
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd

; 347  : 		_Left = _Right;

  00196	66 89 7d ef	 mov	 WORD PTR filePath$[rbp-121], di
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 735  : 		assign(_Right, 0, npos);

  0019a	49 83 c9 ff	 or	 r9, -1
  0019e	45 33 c0	 xor	 r8d, r8d
  001a1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?EXE_DIR@IOUtil@@3V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@A ; IOUtil::EXE_DIR
  001a8	48 8d 4d ef	 lea	 rcx, QWORD PTR filePath$[rbp-121]
  001ac	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@AEBV12@_K1@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
  001b1	90		 npad	 1

; 736  : 		}
; 737  : 
; 738  :  #if _HAS_CPP0X
; 739  : 	basic_string(const _Myt& _Right, const _Alloc& _Al)
; 740  : 		: _Mybase(_Al)
; 741  : 		{	// construct by copying with allocator
; 742  : 		_Tidy();
; 743  : 		assign(_Right, 0, npos);
; 744  : 		}
; 745  :  #endif /* _HAS_CPP0X */
; 746  : 
; 747  : 	basic_string()
; 748  : 		: _Mybase()
; 749  : 		{	// construct empty string
; 750  : 		_Tidy();
; 751  : 		}
; 752  : 
; 753  : 	explicit basic_string(const _Alloc& _Al)
; 754  : 		: _Mybase(_Al)
; 755  : 		{	// construct empty string with allocator
; 756  : 		_Tidy();
; 757  : 		}
; 758  : 
; 759  : 	basic_string(const _Myt& _Right, size_type _Roff,
; 760  : 		size_type _Count = npos)
; 761  : 		: _Mybase(_Right._Getal())
; 762  : 		{	// construct from _Right [_Roff, _Roff + _Count)
; 763  : 		_Tidy();
; 764  : 		assign(_Right, _Roff, _Count);
; 765  : 		}
; 766  : 
; 767  : 	basic_string(const _Myt& _Right, size_type _Roff, size_type _Count,
; 768  : 		const _Alloc& _Al)
; 769  : 		: _Mybase(_Al)
; 770  : 		{	// construct from _Right [_Roff, _Roff + _Count) with allocator
; 771  : 		_Tidy();
; 772  : 		assign(_Right, _Roff, _Count);
; 773  : 		}
; 774  : 
; 775  : 	basic_string(const _Elem *_Ptr, size_type _Count)
; 776  : 		: _Mybase()
; 777  : 		{	// construct from [_Ptr, _Ptr + _Count)
; 778  : 		_Tidy();
; 779  : 		assign(_Ptr, _Count);
; 780  : 		}
; 781  : 
; 782  : 	basic_string(const _Elem *_Ptr, size_type _Count, const _Alloc& _Al)
; 783  : 		: _Mybase(_Al)
; 784  : 		{	// construct from [_Ptr, _Ptr + _Count) with allocator
; 785  : 		_Tidy();
; 786  : 		assign(_Ptr, _Count);
; 787  : 		}
; 788  : 
; 789  : 	basic_string(const _Elem *_Ptr)
; 790  : 		: _Mybase()
; 791  : 		{	// construct from [_Ptr, <null>)
; 792  : 		_Tidy();
; 793  : 		assign(_Ptr);
; 794  : 		}
; 795  : 
; 796  : 	basic_string(const _Elem *_Ptr, const _Alloc& _Al)
; 797  : 		: _Mybase(_Al)
; 798  : 		{	// construct from [_Ptr, <null>) with allocator
; 799  : 		_Tidy();
; 800  : 		assign(_Ptr);
; 801  : 		}
; 802  : 
; 803  : 	basic_string(size_type _Count, _Elem _Ch)
; 804  : 		: _Mybase()
; 805  : 		{	// construct from _Count * _Ch
; 806  : 		_Tidy();
; 807  : 		assign(_Count, _Ch);
; 808  : 		}
; 809  : 
; 810  : 	basic_string(size_type _Count, _Elem _Ch, const _Alloc& _Al)
; 811  : 		: _Mybase(_Al)
; 812  : 		{	// construct from _Count * _Ch with allocator
; 813  : 		_Tidy();
; 814  : 		assign(_Count, _Ch);
; 815  : 		}
; 816  : 
; 817  : 	template<class _Iter>
; 818  : 		basic_string(_Iter _First, _Iter _Last,
; 819  : 			typename enable_if<_Is_iterator<_Iter>::value,
; 820  : 				void>::type ** = 0)
; 821  : 		: _Mybase()
; 822  : 		{	// construct from [_First, _Last)
; 823  : 		_Tidy();
; 824  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 825  : 		}
; 826  : 
; 827  : 	template<class _Iter>
; 828  : 		basic_string(_Iter _First, _Iter _Last, const _Alloc& _Al,
; 829  : 			typename enable_if<_Is_iterator<_Iter>::value,
; 830  : 				void>::type ** = 0)
; 831  : 		: _Mybase(_Al)
; 832  : 		{	// construct from [_First, _Last) with allocator
; 833  : 		_Tidy();
; 834  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 835  : 		}
; 836  : 
; 837  : 	template<class _Iter>
; 838  : 		void _Construct(_Iter _First,
; 839  : 			_Iter _Last, input_iterator_tag)
; 840  : 		{	// initialize from [_First, _Last), input iterators
; 841  : 		_TRY_BEGIN
; 842  : 		for (; _First != _Last; ++_First)
; 843  : 			append((size_type)1, (_Elem)*_First);
; 844  : 		_CATCH_ALL
; 845  : 		_Tidy(true);
; 846  : 		_RERAISE;
; 847  : 		_CATCH_END
; 848  : 		}
; 849  : 
; 850  : 	template<class _Iter>
; 851  : 		void _Construct(_Iter _First,
; 852  : 			_Iter _Last, forward_iterator_tag)
; 853  : 		{	// initialize from [_First, _Last), forward iterators
; 854  : 		_DEBUG_RANGE(_First, _Last);
; 855  : 		size_type _Count = 0;
; 856  : 		_Distance(_First, _Last, _Count);
; 857  : 		reserve(_Count);
; 858  : 
; 859  : 		_TRY_BEGIN
; 860  : 		for (; _First != _Last; ++_First)
; 861  : 			append((size_type)1, (_Elem)*_First);
; 862  : 		_CATCH_ALL
; 863  : 		_Tidy(true);
; 864  : 		_RERAISE;
; 865  : 		_CATCH_END
; 866  : 		}
; 867  : 
; 868  : 	basic_string(const_pointer _First, const_pointer _Last)
; 869  : 		: _Mybase()
; 870  : 		{	// construct from [_First, _Last), const pointers
; 871  : 		_DEBUG_RANGE(_First, _Last);
; 872  : 		_Tidy();
; 873  : 		if (_First != _Last)
; 874  : 			assign(&*_First, _Last - _First);
; 875  : 		}
; 876  : 
; 877  : 	basic_string(const_pointer _First, const_pointer _Last,
; 878  : 		const _Alloc& _Al)
; 879  : 		: _Mybase(_Al)
; 880  : 		{	// construct from [_First, _Last), const pointers
; 881  : 		_DEBUG_RANGE(_First, _Last);
; 882  : 		_Tidy();
; 883  : 		if (_First != _Last)
; 884  : 			assign(&*_First, _Last - _First);
; 885  : 		}
; 886  : 
; 887  : 	basic_string(const_iterator _First, const_iterator _Last)
; 888  : 		: _Mybase()
; 889  : 		{	// construct from [_First, _Last), const_iterators
; 890  : 		_DEBUG_RANGE(_First, _Last);
; 891  : 		_Tidy();
; 892  : 		if (_First != _Last)
; 893  : 			assign(&*_First, _Last - _First);
; 894  : 		}
; 895  : 
; 896  : 	basic_string(_Myt&& _Right) _NOEXCEPT
; 897  : 		: _Mybase(_Right._Getal())
; 898  : 		{	// construct by moving _Right
; 899  : 		_Tidy();
; 900  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 901  : 		}
; 902  : 
; 903  : 	basic_string(_Myt&& _Right, const _Alloc& _Al)
; 904  : 		: _Mybase(_Al)
; 905  : 		{	// construct by moving _Right, allocator
; 906  : 		if (this->_Getal() != _Right._Getal())
; 907  : 			assign(_Right.begin(), _Right.end());
; 908  : 		else
; 909  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 910  : 		}
; 911  : 
; 912  : 	_Myt& operator=(_Myt&& _Right) _NOEXCEPT
; 913  : 		{	// assign by moving _Right
; 914  : 		if (this != &_Right)
; 915  : 			{	// different, assign it
; 916  : 			_Tidy(true);
; 917  : 
; 918  :  #if _HAS_CPP0X
; 919  : 			if (this->_Getal() != _Right._Getal()
; 920  : 				&& _Alty::propagate_on_container_move_assignment::value)
; 921  : 				this->_Change_alloc(_Right._Getal());
; 922  :  #endif /* _HAS_CPP0X */
; 923  : 
; 924  : 			if (this->_Getal() != _Right._Getal())
; 925  : 				assign(_Right.begin(), _Right.end());
; 926  : 			else
; 927  : 				_Assign_rv(_STD forward<_Myt>(_Right));
; 928  : 			}
; 929  : 		return (*this);
; 930  : 		}
; 931  : 
; 932  : 	_Myt& assign(_Myt&& _Right) _NOEXCEPT
; 933  : 		{	// assign by moving _Right
; 934  : 		if (this == &_Right)
; 935  : 			;
; 936  : 		else if (get_allocator() != _Right.get_allocator()
; 937  : 			&& this->_BUF_SIZE <= _Right._Myres)
; 938  : 			*this = _Right;
; 939  : 		else
; 940  : 			{	// not same, clear this and steal from _Right
; 941  : 			_Tidy(true);
; 942  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 943  : 			}
; 944  : 		return (*this);
; 945  : 		}
; 946  : 
; 947  : 	void _Assign_rv(_Myt&& _Right)
; 948  : 		{	// assign by moving _Right
; 949  : 		if (_Right._Myres < this->_BUF_SIZE)
; 950  : 			_Traits::move(this->_Bx._Buf, _Right._Bx._Buf,
; 951  : 				_Right._Mysize + 1);
; 952  : 		else
; 953  : 			{	// copy pointer
; 954  : 			this->_Getal().construct(&this->_Bx._Ptr, _Right._Bx._Ptr);
; 955  : 			_Right._Bx._Ptr = pointer();
; 956  : 			}
; 957  : 		this->_Mysize = _Right._Mysize;
; 958  : 		this->_Myres = _Right._Myres;
; 959  : 		_Right._Tidy();
; 960  : 		}
; 961  : 
; 962  : 	~basic_string() _NOEXCEPT
; 963  : 		{	// destroy the string
; 964  : 		_Tidy(true);
; 965  : 		}
; 966  : 
; 967  : 	_PGLOBAL static const size_type npos;	// bad/missing length/position
; 968  : 
; 969  : 	_Myt& operator=(const _Myt& _Right)
; 970  : 		{	// assign _Right
; 971  : 		if (this != &_Right)
; 972  : 			{	// different, assign it
; 973  :  #if _HAS_CPP0X
; 974  : 			if (this->_Getal() != _Right._Getal()
; 975  : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 976  : 				{	// change allocator before copying
; 977  : 				_Tidy(true);
; 978  : 				this->_Change_alloc(_Right._Getal());
; 979  : 				}
; 980  :  #endif /* _HAS_CPP0X */
; 981  : 
; 982  : 			assign(_Right);
; 983  : 			}
; 984  : 		return (*this);
; 985  : 		}
; 986  : 
; 987  : 	_Myt& operator=(const _Elem *_Ptr)
; 988  : 		{	// assign [_Ptr, <null>)
; 989  : 		return (assign(_Ptr));
; 990  : 		}
; 991  : 
; 992  : 	_Myt& operator=(_Elem _Ch)
; 993  : 		{	// assign 1 * _Ch
; 994  : 		return (assign(1, _Ch));
; 995  : 		}
; 996  : 
; 997  : 	_Myt& operator+=(const _Myt& _Right)
; 998  : 		{	// append _Right
; 999  : 		return (append(_Right));
; 1000 : 		}
; 1001 : 
; 1002 : 	_Myt& operator+=(const _Elem *_Ptr)
; 1003 : 		{	// append [_Ptr, <null>)
; 1004 : 		return (append(_Ptr));
; 1005 : 		}
; 1006 : 
; 1007 : 	_Myt& operator+=(_Elem _Ch)
; 1008 : 		{	// append 1 * _Ch
; 1009 : 		return (append((size_type)1, _Ch));
; 1010 : 		}
; 1011 : 
; 1012 : 	_Myt& append(const _Myt& _Right)
; 1013 : 		{	// append _Right
; 1014 : 		return (append(_Right, 0, npos));
; 1015 : 		}
; 1016 : 
; 1017 : 	_Myt& append(const _Myt& _Right,
; 1018 : 		size_type _Roff, size_type _Count)
; 1019 : 		{	// append _Right [_Roff, _Roff + _Count)
; 1020 : 		if (_Right.size() < _Roff)
; 1021 : 			_Xran();	// _Roff off end
; 1022 : 		size_type _Num = _Right.size() - _Roff;
; 1023 : 		if (_Num < _Count)
; 1024 : 			_Count = _Num;	// trim _Count to size
; 1025 : 		if (npos - this->_Mysize <= _Count)
; 1026 : 			_Xlen();	// result too long
; 1027 : 
; 1028 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1029 : 			{	// make room and append new stuff
; 1030 : 			_Traits::copy(this->_Myptr() + this->_Mysize,
; 1031 : 				_Right._Myptr() + _Roff, _Count);
; 1032 : 			_Eos(_Num);
; 1033 : 			}
; 1034 : 		return (*this);
; 1035 : 		}
; 1036 : 
; 1037 : 	_Myt& append(const _Elem *_Ptr, size_type _Count)
; 1038 : 		{	// append [_Ptr, _Ptr + _Count)
; 1039 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1040 : 		if (_Count != 0)
; 1041 : 			_DEBUG_POINTER(_Ptr);
; 1042 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1043 : 
; 1044 : 		if (_Inside(_Ptr))
; 1045 : 			return (append(*this,
; 1046 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1047 : 		if (npos - this->_Mysize <= _Count)
; 1048 : 			_Xlen();	// result too long
; 1049 : 
; 1050 : 		size_type _Num;
; 1051 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1052 : 			{	// make room and append new stuff
; 1053 : 			_Traits::copy(this->_Myptr() + this->_Mysize, _Ptr, _Count);
; 1054 : 			_Eos(_Num);
; 1055 : 			}
; 1056 : 		return (*this);
; 1057 : 		}
; 1058 : 
; 1059 : 	_Myt& append(const _Elem *_Ptr)
; 1060 : 		{	// append [_Ptr, <null>)
; 1061 : 		_DEBUG_POINTER(_Ptr);
; 1062 : 		return (append(_Ptr, _Traits::length(_Ptr)));

  001b2	41 b8 18 00 00
	00		 mov	 r8d, 24
  001b8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG4294950232
  001bf	48 8d 4d ef	 lea	 rcx, QWORD PTR filePath$[rbp-121]
  001c3	e8 00 00 00 00	 call	 ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@PEB_W_K@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append

; 2265 : 		this->_Myres = this->_BUF_SIZE - 1;

  001c8	48 c7 45 df 07
	00 00 00	 mov	 QWORD PTR $T17[rbp-97], 7

; 1100 : 		}
; 1101 : 
; 1102 : 	_Myt& assign(const _Myt& _Right,
; 1103 : 		size_type _Roff, size_type _Count)
; 1104 : 		{	// assign _Right [_Roff, _Roff + _Count)
; 1105 : 		if (_Right.size() < _Roff)
; 1106 : 			_Xran();	// _Roff off end
; 1107 : 		size_type _Num = _Right.size() - _Roff;
; 1108 : 		if (_Count < _Num)
; 1109 : 			_Num = _Count;	// trim _Num to size
; 1110 : 
; 1111 : 		if (this == &_Right)
; 1112 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring
; 1113 : 		else if (_Grow(_Num))
; 1114 : 			{	// make room and assign new stuff
; 1115 : 			_Traits::copy(this->_Myptr(),
; 1116 : 				_Right._Myptr() + _Roff, _Num);
; 1117 : 			_Eos(_Num);
; 1118 : 			}
; 1119 : 		return (*this);
; 1120 : 		}
; 1121 : 
; 1122 : 	_Myt& assign(const _Elem *_Ptr, size_type _Count)
; 1123 : 		{	// assign [_Ptr, _Ptr + _Count)
; 1124 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1125 : 		if (_Count != 0)
; 1126 : 			_DEBUG_POINTER(_Ptr);
; 1127 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1128 : 
; 1129 : 		if (_Inside(_Ptr))
; 1130 : 			return (assign(*this,
; 1131 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1132 : 
; 1133 : 		if (_Grow(_Count))
; 1134 : 			{	// make room and assign new stuff
; 1135 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);
; 1136 : 			_Eos(_Count);
; 1137 : 			}
; 1138 : 		return (*this);
; 1139 : 		}
; 1140 : 
; 1141 : 	_Myt& assign(const _Elem *_Ptr)
; 1142 : 		{	// assign [_Ptr, <null>)
; 1143 : 		_DEBUG_POINTER(_Ptr);
; 1144 : 		return (assign(_Ptr, _Traits::length(_Ptr)));
; 1145 : 		}
; 1146 : 
; 1147 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1148 : 		{	// assign _Count * _Ch
; 1149 : 		if (_Count == npos)
; 1150 : 			_Xlen();	// result too long
; 1151 : 
; 1152 : 		if (_Grow(_Count))
; 1153 : 			{	// make room and assign new stuff
; 1154 : 			_Chassign(0, _Count, _Ch);
; 1155 : 			_Eos(_Count);
; 1156 : 			}
; 1157 : 		return (*this);
; 1158 : 		}
; 1159 : 
; 1160 : 	template<class _Iter>
; 1161 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1162 : 			_Myt&>::type
; 1163 : 		assign(_Iter _First, _Iter _Last)
; 1164 : 		{	// assign [First, _Last), input iterators
; 1165 : 		return (replace(begin(), end(), _First, _Last));
; 1166 : 		}
; 1167 : 
; 1168 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1169 : 		{	// assign [First, _Last), const pointers
; 1170 : 		return (replace(begin(), end(), _First, _Last));
; 1171 : 		}
; 1172 : 
; 1173 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1174 : 		{	// assign [First, _Last), const_iterators
; 1175 : 		return (replace(begin(), end(), _First, _Last));
; 1176 : 		}
; 1177 : 
; 1178 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1179 : 		{	// insert _Right at _Off
; 1180 : 		return (insert(_Off, _Right, 0, npos));
; 1181 : 		}
; 1182 : 
; 1183 : 	_Myt& insert(size_type _Off,
; 1184 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1185 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1186 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1187 : 			_Xran();	// _Off or _Roff off end
; 1188 : 		size_type _Num = _Right.size() - _Roff;
; 1189 : 		if (_Num < _Count)
; 1190 : 			_Count = _Num;	// trim _Count to size
; 1191 : 		if (npos - this->_Mysize <= _Count)
; 1192 : 			_Xlen();	// result too long
; 1193 : 
; 1194 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1195 : 			{	// make room and insert new stuff
; 1196 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1197 : 				this->_Myptr() + _Off,
; 1198 : 				this->_Mysize - _Off);	// empty out hole
; 1199 : 			if (this == &_Right)
; 1200 : 				_Traits::move(this->_Myptr() + _Off,
; 1201 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1202 : 						_Count);	// substring
; 1203 : 			else
; 1204 : 				_Traits::copy(this->_Myptr() + _Off,
; 1205 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1206 : 			_Eos(_Num);
; 1207 : 			}
; 1208 : 		return (*this);
; 1209 : 		}
; 1210 : 
; 1211 : 	_Myt& insert(size_type _Off,
; 1212 : 		const _Elem *_Ptr, size_type _Count)
; 1213 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1214 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1215 : 		if (_Count != 0)
; 1216 : 			_DEBUG_POINTER(_Ptr);
; 1217 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1218 : 
; 1219 : 		if (_Inside(_Ptr))
; 1220 : 			return (insert(_Off, *this,
; 1221 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1222 : 		if (this->_Mysize < _Off)
; 1223 : 			_Xran();	// _Off off end
; 1224 : 		if (npos - this->_Mysize <= _Count)
; 1225 : 			_Xlen();	// result too long
; 1226 : 		size_type _Num;
; 1227 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1228 : 			{	// make room and insert new stuff
; 1229 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1230 : 				this->_Myptr() + _Off,
; 1231 : 				this->_Mysize - _Off);	// empty out hole
; 1232 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1233 : 			_Eos(_Num);
; 1234 : 			}
; 1235 : 		return (*this);
; 1236 : 		}
; 1237 : 
; 1238 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1239 : 		{	// insert [_Ptr, <null>) at _Off
; 1240 : 		_DEBUG_POINTER(_Ptr);
; 1241 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1242 : 		}
; 1243 : 
; 1244 : 	_Myt& insert(size_type _Off,
; 1245 : 		size_type _Count, _Elem _Ch)
; 1246 : 		{	// insert _Count * _Ch at _Off
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	iterator insert(const_iterator _Where)
; 1264 : 		{	// insert <null> at _Where
; 1265 : 		return (insert(_Where, _Elem()));
; 1266 : 		}
; 1267 : 
; 1268 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1269 : 		{	// insert _Ch at _Where
; 1270 : 		size_type _Off = _Pdif(_Where, begin());
; 1271 : 		insert(_Off, 1, _Ch);
; 1272 : 		return (begin() + _Off);
; 1273 : 		}
; 1274 : 
; 1275 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1276 : 		{	// insert _Count * _Elem at _Where
; 1277 : 		size_type _Off = _Pdif(_Where, begin());
; 1278 : 		insert(_Off, _Count, _Ch);
; 1279 : 		return (begin() + _Off);
; 1280 : 		}
; 1281 : 
; 1282 : 	template<class _Iter>
; 1283 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1284 : 			iterator>::type
; 1285 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1286 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1287 : 		size_type _Off = _Pdif(_Where, begin());
; 1288 : 		replace(_Where, _Where, _First, _Last);
; 1289 : 		return (begin() + _Off);
; 1290 : 		}
; 1291 : 
; 1292 : 	iterator insert(const_iterator _Where,
; 1293 : 		const_pointer _First, const_pointer _Last)
; 1294 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		replace(_Where, _Where, _First, _Last);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where,
; 1301 : 		const_iterator _First, const_iterator _Last)
; 1302 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1303 : 		size_type _Off = _Pdif(_Where, begin());
; 1304 : 		replace(_Where, _Where, _First, _Last);
; 1305 : 		return (begin() + _Off);
; 1306 : 		}
; 1307 : 
; 1308 : 	_Myt& erase(size_type _Off = 0)
; 1309 : 		{	// erase elements [_Off, ...)
; 1310 : 		if (this->_Mysize < _Off)
; 1311 : 			_Xran();	// _Off off end
; 1312 : 		_Eos(_Off);
; 1313 : 		return (*this);
; 1314 : 		}
; 1315 : 
; 1316 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1317 : 		{	// erase elements [_Off, _Off + _Count)
; 1318 : 		if (this->_Mysize < _Off)
; 1319 : 			_Xran();	// _Off off end
; 1320 : 		if (this->_Mysize - _Off <= _Count)
; 1321 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1322 : 		else if (0 < _Count)
; 1323 : 			{	// move elements down
; 1324 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1325 : 			size_type _Newsize = this->_Mysize - _Count;
; 1326 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1327 : 			_Eos(_Newsize);
; 1328 : 			}
; 1329 : 		return (*this);
; 1330 : 		}
; 1331 : 
; 1332 : 	iterator erase(const_iterator _Where)
; 1333 : 		{	// erase element at _Where
; 1334 : 		size_type _Count = _Pdif(_Where, begin());
; 1335 : 		erase(_Count, 1);
; 1336 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1337 : 		}
; 1338 : 
; 1339 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1340 : 		{	// erase substring [_First, _Last)
; 1341 : 		_DEBUG_RANGE(_First, _Last);
; 1342 : 		size_type _Count = _Pdif(_First, begin());
; 1343 : 		erase(_Count, _Pdif(_Last, _First));
; 1344 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1345 : 		}
; 1346 : 
; 1347 : 	void clear() _NOEXCEPT
; 1348 : 		{	// erase all
; 1349 : 		_Eos(0);
; 1350 : 		}
; 1351 : 
; 1352 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1353 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1354 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1355 : 		}
; 1356 : 
; 1357 : 	_Myt& replace(size_type _Off,
; 1358 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1359 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1360 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1361 : 			_Xran();	// _Off or _Roff off end
; 1362 : 		if (this->_Mysize - _Off < _N0)
; 1363 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1364 : 		size_type _Num = _Right.size() - _Roff;
; 1365 : 		if (_Num < _Count)
; 1366 : 			_Count = _Num;	// trim _Count to size
; 1367 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1368 : 			_Xlen();	// result too long
; 1369 : 
; 1370 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1371 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1372 : 		if (this->_Mysize < _Newsize)
; 1373 : 			_Grow(_Newsize);
; 1374 : 
; 1375 : 		if (this != &_Right)
; 1376 : 			{	// no overlap, just move down and copy in new stuff
; 1377 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1378 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1379 : 			_Traits::copy(this->_Myptr() + _Off,
; 1380 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1381 : 			}
; 1382 : 		else if (_Count <= _N0)
; 1383 : 			{	// hole doesn't get larger, just copy in substring
; 1384 : 			_Traits::move(this->_Myptr() + _Off,
; 1385 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1386 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1387 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1388 : 			}
; 1389 : 		else if (_Roff <= _Off)
; 1390 : 			{	// hole gets larger, substring begins before hole
; 1391 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1392 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1393 : 			_Traits::move(this->_Myptr() + _Off,
; 1394 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1395 : 			}
; 1396 : 		else if (_Off + _N0 <= _Roff)
; 1397 : 			{	// hole gets larger, substring begins after hole
; 1398 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1399 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1400 : 			_Traits::move(this->_Myptr() + _Off,
; 1401 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1402 : 				_Count);	// fill hole
; 1403 : 			}
; 1404 : 		else
; 1405 : 			{	// hole gets larger, substring begins in hole
; 1406 : 			_Traits::move(this->_Myptr() + _Off,
; 1407 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1408 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1409 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1410 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1411 : 				this->_Myptr() + _Roff + _Count,
; 1412 : 				_Count - _N0);	// fill rest of new hole
; 1413 : 			}
; 1414 : 
; 1415 : 		_Eos(_Newsize);
; 1416 : 		return (*this);
; 1417 : 		}
; 1418 : 
; 1419 : 	_Myt& replace(size_type _Off,
; 1420 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1421 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1422 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1423 : 		if (_Count != 0)
; 1424 : 			_DEBUG_POINTER(_Ptr);
; 1425 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1426 : 
; 1427 : 		if (_Inside(_Ptr))
; 1428 : 			return (replace(_Off, _N0, *this,
; 1429 : 				_Ptr - this->_Myptr(),
; 1430 : 				_Count));	// substring, replace carefully
; 1431 : 		if (this->_Mysize < _Off)
; 1432 : 			_Xran();	// _Off off end
; 1433 : 		if (this->_Mysize - _Off < _N0)
; 1434 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1435 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1436 : 			_Xlen();	// result too long
; 1437 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1438 : 
; 1439 : 		if (_Count < _N0)
; 1440 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1441 : 				this->_Myptr() + _Off + _N0,
; 1442 : 				_Nm);	// smaller hole, move tail up
; 1443 : 		size_type _Num;
; 1444 : 		if ((0 < _Count || 0 < _N0)
; 1445 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1446 : 			{	// make room and rearrange
; 1447 : 			if (_N0 < _Count)
; 1448 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1449 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1450 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1451 : 			_Eos(_Num);
; 1452 : 			}
; 1453 : 		return (*this);
; 1454 : 		}
; 1455 : 
; 1456 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1457 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1458 : 		_DEBUG_POINTER(_Ptr);
; 1459 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1460 : 		}
; 1461 : 
; 1462 : 	_Myt& replace(size_type _Off,
; 1463 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1464 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1465 : 		if (this->_Mysize < _Off)
; 1466 : 			_Xran();	// _Off off end
; 1467 : 		if (this->_Mysize - _Off < _N0)
; 1468 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1469 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1470 : 			_Xlen();	// result too long
; 1471 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1472 : 
; 1473 : 		if (_Count < _N0)
; 1474 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1475 : 				this->_Myptr() + _Off + _N0,
; 1476 : 				_Nm);	// smaller hole, move tail up
; 1477 : 		size_type _Num;
; 1478 : 		if ((0 < _Count || 0 < _N0)
; 1479 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1480 : 			{	// make room and rearrange
; 1481 : 			if (_N0 < _Count)
; 1482 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1483 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1484 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1485 : 			_Eos(_Num);
; 1486 : 			}
; 1487 : 		return (*this);
; 1488 : 		}
; 1489 : 
; 1490 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1491 : 		const _Myt& _Right)
; 1492 : 		{	// replace [_First, _Last) with _Right
; 1493 : 		return (replace(
; 1494 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1495 : 		}
; 1496 : 
; 1497 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1498 : 		const _Elem *_Ptr, size_type _Count)
; 1499 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1500 : 		return (replace(
; 1501 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1502 : 		}
; 1503 : 
; 1504 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1505 : 		const _Elem *_Ptr)
; 1506 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1507 : 		return (replace(
; 1508 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1509 : 		}
; 1510 : 
; 1511 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1512 : 		size_type _Count, _Elem _Ch)
; 1513 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1514 : 		return (replace(
; 1515 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1516 : 		}
; 1517 : 
; 1518 : 	template<class _Iter>
; 1519 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1520 : 			_Myt&>::type
; 1521 : 		replace(const_iterator _First, const_iterator _Last,
; 1522 : 			_Iter _First2, _Iter _Last2)
; 1523 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1524 : 		_Myt _Right(_First2, _Last2);
; 1525 : 		replace(_First, _Last, _Right);
; 1526 : 		return (*this);
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const_pointer _First2, const_pointer _Last2)
; 1531 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1532 : 		if (_First2 == _Last2)
; 1533 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1534 : 		else
; 1535 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1536 : 				&*_First2, _Last2 - _First2);
; 1537 : 		return (*this);
; 1538 : 		}
; 1539 : 
; 1540 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1541 : 		pointer _First2, pointer _Last2)
; 1542 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1543 : 		if (_First2 == _Last2)
; 1544 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1545 : 		else
; 1546 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1547 : 				&*_First2, _Last2 - _First2);
; 1548 : 		return (*this);
; 1549 : 		}
; 1550 : 
; 1551 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1552 : 		const_iterator _First2, const_iterator _Last2)
; 1553 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1554 : 		if (_First2 == _Last2)
; 1555 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1556 : 		else
; 1557 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1558 : 				&*_First2, _Last2 - _First2);
; 1559 : 		return (*this);
; 1560 : 		}
; 1561 : 
; 1562 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1563 : 		iterator _First2, iterator _Last2)
; 1564 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1565 : 		if (_First2 == _Last2)
; 1566 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1567 : 		else
; 1568 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1569 : 				&*_First2, _Last2 - _First2);
; 1570 : 		return (*this);
; 1571 : 		}
; 1572 : 
; 1573 : 	iterator begin() _NOEXCEPT
; 1574 : 		{	// return iterator for beginning of mutable sequence
; 1575 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1576 : 		}
; 1577 : 
; 1578 : 	const_iterator begin() const _NOEXCEPT
; 1579 : 		{	// return iterator for beginning of nonmutable sequence
; 1580 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1581 : 		}
; 1582 : 
; 1583 : 	iterator end() _NOEXCEPT
; 1584 : 		{	// return iterator for end of mutable sequence
; 1585 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1586 : 		}
; 1587 : 
; 1588 : 	const_iterator end() const _NOEXCEPT
; 1589 : 		{	// return iterator for end of nonmutable sequence
; 1590 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1591 : 		}
; 1592 : 
; 1593 : 	reverse_iterator rbegin() _NOEXCEPT
; 1594 : 		{	// return iterator for beginning of reversed mutable sequence
; 1595 : 		return (reverse_iterator(end()));
; 1596 : 		}
; 1597 : 
; 1598 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1600 : 		return (const_reverse_iterator(end()));
; 1601 : 		}
; 1602 : 
; 1603 : 	reverse_iterator rend() _NOEXCEPT
; 1604 : 		{	// return iterator for end of reversed mutable sequence
; 1605 : 		return (reverse_iterator(begin()));
; 1606 : 		}
; 1607 : 
; 1608 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1609 : 		{	// return iterator for end of reversed nonmutable sequence
; 1610 : 		return (const_reverse_iterator(begin()));
; 1611 : 		}
; 1612 : 
; 1613 :  #if _HAS_CPP0X
; 1614 : 	const_iterator cbegin() const _NOEXCEPT
; 1615 : 		{	// return iterator for beginning of nonmutable sequence
; 1616 : 		return (((const _Myt *)this)->begin());
; 1617 : 		}
; 1618 : 
; 1619 : 	const_iterator cend() const _NOEXCEPT
; 1620 : 		{	// return iterator for end of nonmutable sequence
; 1621 : 		return (((const _Myt *)this)->end());
; 1622 : 		}
; 1623 : 
; 1624 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1625 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1626 : 		return (((const _Myt *)this)->rbegin());
; 1627 : 		}
; 1628 : 
; 1629 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1630 : 		{	// return iterator for end of reversed nonmutable sequence
; 1631 : 		return (((const _Myt *)this)->rend());
; 1632 : 		}
; 1633 : 
; 1634 : 	void shrink_to_fit()
; 1635 : 		{	// reduce capacity
; 1636 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1637 : 			{	// worth shrinking, do it
; 1638 : 			_Myt _Tmp(*this);
; 1639 : 			swap(_Tmp);
; 1640 : 			}
; 1641 : 		}
; 1642 :  #endif /* _HAS_CPP0X */
; 1643 : 
; 1644 : 	reference at(size_type _Off)
; 1645 : 		{	// subscript mutable sequence with checking
; 1646 : 		if (this->_Mysize <= _Off)
; 1647 : 			_Xran();	// _Off off end
; 1648 : 		return (this->_Myptr()[_Off]);
; 1649 : 		}
; 1650 : 
; 1651 : 	const_reference at(size_type _Off) const
; 1652 : 		{	// subscript nonmutable sequence with checking
; 1653 : 		if (this->_Mysize <= _Off)
; 1654 : 			_Xran();	// _Off off end
; 1655 : 		return (this->_Myptr()[_Off]);
; 1656 : 		}
; 1657 : 
; 1658 : 	reference operator[](size_type _Off)
; 1659 : 		{	// subscript mutable sequence
; 1660 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1661 : 		if (this->_Mysize < _Off)	// sic
; 1662 : 			_DEBUG_ERROR("string subscript out of range");
; 1663 : 
; 1664 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1665 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1666 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1667 : 
; 1668 : 		return (this->_Myptr()[_Off]);
; 1669 : 		}
; 1670 : 
; 1671 : 	const_reference operator[](size_type _Off) const
; 1672 : 		{	// subscript nonmutable sequence
; 1673 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1674 : 		if (this->_Mysize < _Off)	// sic
; 1675 : 			_DEBUG_ERROR("string subscript out of range");
; 1676 : 
; 1677 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1678 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1679 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1680 : 
; 1681 : 		return (this->_Myptr()[_Off]);
; 1682 : 		}
; 1683 : 
; 1684 : 	void push_back(_Elem _Ch)
; 1685 : 		{	// insert element at end
; 1686 : 		insert(end(), _Ch);
; 1687 : 		}
; 1688 : 
; 1689 :  #if _HAS_CPP0X
; 1690 : 	void pop_back()
; 1691 : 		{	// erase element at end
; 1692 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1693 : 		}
; 1694 : 
; 1695 : 	reference front()
; 1696 : 		{	// return first element of mutable sequence
; 1697 : 		return (*begin());
; 1698 : 		}
; 1699 : 
; 1700 : 	const_reference front() const
; 1701 : 		{	// return first element of nonmutable sequence
; 1702 : 		return (*begin());
; 1703 : 		}
; 1704 : 
; 1705 : 	reference back()
; 1706 : 		{	// return last element of mutable sequence
; 1707 : 		return (*(end() - 1));
; 1708 : 		}
; 1709 : 
; 1710 : 	const_reference back() const
; 1711 : 		{	// return last element of nonmutable sequence
; 1712 : 		return (*(end() - 1));
; 1713 : 		}
; 1714 :  #endif /* _HAS_CPP0X */
; 1715 : 
; 1716 : 	const _Elem *c_str() const _NOEXCEPT
; 1717 : 		{	// return pointer to null-terminated nonmutable array
; 1718 : 		return (this->_Myptr());
; 1719 : 		}
; 1720 : 
; 1721 : 	const _Elem *data() const _NOEXCEPT
; 1722 : 		{	// return pointer to nonmutable array
; 1723 : 		return (c_str());
; 1724 : 		}
; 1725 : 
; 1726 : 	size_type length() const _NOEXCEPT
; 1727 : 		{	// return length of sequence
; 1728 : 		return (this->_Mysize);
; 1729 : 		}
; 1730 : 
; 1731 : 	size_type size() const _NOEXCEPT
; 1732 : 		{	// return length of sequence
; 1733 : 		return (this->_Mysize);
; 1734 : 		}
; 1735 : 
; 1736 : 	size_type max_size() const _NOEXCEPT
; 1737 : 		{	// return maximum possible length of sequence
; 1738 : 		size_type _Num = this->_Getal().max_size();
; 1739 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1740 : 		}
; 1741 : 
; 1742 : 	void resize(size_type _Newsize)
; 1743 : 		{	// determine new length, padding with null elements as needed
; 1744 : 		resize(_Newsize, _Elem());
; 1745 : 		}
; 1746 : 
; 1747 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1748 : 		{	// determine new length, padding with _Ch elements as needed
; 1749 : 		if (_Newsize <= this->_Mysize)
; 1750 : 			_Eos(_Newsize);
; 1751 : 		else
; 1752 : 			append(_Newsize - this->_Mysize, _Ch);
; 1753 : 		}
; 1754 : 
; 1755 : 	size_type capacity() const _NOEXCEPT
; 1756 : 		{	// return current length of allocated storage
; 1757 : 		return (this->_Myres);
; 1758 : 		}
; 1759 : 
; 1760 : 	void reserve(size_type _Newcap = 0)
; 1761 : 		{	// determine new minimum length of allocated storage
; 1762 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1763 : 			{	// change reservation
; 1764 : 			size_type _Size = this->_Mysize;
; 1765 : 			if (_Grow(_Newcap, true))
; 1766 : 				_Eos(_Size);
; 1767 : 			}
; 1768 : 		}
; 1769 : 
; 1770 : 	bool empty() const _NOEXCEPT
; 1771 : 		{	// test if sequence is empty
; 1772 : 		return (this->_Mysize == 0);
; 1773 : 		}
; 1774 : 
; 1775 : 	_SCL_INSECURE_DEPRECATE
; 1776 : 
; 1777 : 	size_type copy(_Elem *_Ptr,
; 1778 : 		size_type _Count, size_type _Off = 0) const
; 1779 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1780 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1781 : 		if (_Count != 0)
; 1782 : 			_DEBUG_POINTER(_Ptr);
; 1783 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1784 : 
; 1785 : 		if (this->_Mysize < _Off)
; 1786 : 			_Xran();	// _Off off end
; 1787 : 		if (this->_Mysize - _Off < _Count)
; 1788 : 			_Count = this->_Mysize - _Off;
; 1789 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1790 : 		return (_Count);
; 1791 : 		}
; 1792 : 
; 1793 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1794 : 		size_type _Count, size_type _Off = 0) const
; 1795 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1796 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1797 : 		if (_Count != 0)
; 1798 : 			_DEBUG_POINTER(_Dest);
; 1799 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1800 : 
; 1801 : 		if (this->_Mysize < _Off)
; 1802 : 			_Xran();	// _Off off end
; 1803 : 		if (this->_Mysize - _Off < _Count)
; 1804 : 			_Count = this->_Mysize - _Off;
; 1805 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1806 : 		return (_Count);
; 1807 : 		}
; 1808 : 
; 1809 : 	void _Swap_bx(_Myt& _Right)
; 1810 : 		{	// exchange _Bx with _Right._Bx
; 1811 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1812 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1813 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1814 : 			else
; 1815 : 				{	// swap large with small
; 1816 : 				pointer _Ptr = this->_Bx._Ptr;
; 1817 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1818 : 				_Traits::copy(this->_Bx._Buf,
; 1819 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1820 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1821 : 				}
; 1822 : 		else
; 1823 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1824 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1825 : 			else
; 1826 : 				{	// swap small with large
; 1827 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1828 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1829 : 				_Traits::copy(_Right._Bx._Buf,
; 1830 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1831 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1832 : 				}
; 1833 : 		}
; 1834 : 
; 1835 : 	void swap(_Myt& _Right)
; 1836 : 		{	// exchange contents with _Right
; 1837 : 		if (this == &_Right)
; 1838 : 			;	// same object, do nothing
; 1839 : 		else if (this->_Getal() == _Right._Getal())
; 1840 : 			{	// same allocator, swap control information
; 1841 : 			this->_Swap_all(_Right);
; 1842 : 			_Swap_bx(_Right);
; 1843 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1844 : 			_STD swap(this->_Myres, _Right._Myres);
; 1845 : 			}
; 1846 : 
; 1847 :  #if _HAS_CPP0X
; 1848 : 		else if (_Alty::propagate_on_container_swap::value)
; 1849 : 			{	// swap allocators and control information
; 1850 : 			this->_Swap_alloc(_Right);
; 1851 : 			_Swap_bx(_Right);
; 1852 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1853 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1854 : 			_STD swap(this->_Myres, _Right._Myres);
; 1855 : 			}
; 1856 :  #endif /* _HAS_CPP0X */
; 1857 : 
; 1858 : 		else
; 1859 : 			{	// different allocator, do multiple assigns
; 1860 : 			_Myt _Tmp = *this;
; 1861 : 
; 1862 : 			*this = _Right;
; 1863 : 			_Right = _Tmp;
; 1864 : 			}
; 1865 : 		}
; 1866 : 
; 1867 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1868 : 		{	// look for _Right beginning at or after _Off
; 1869 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1870 : 		}
; 1871 : 
; 1872 : 	size_type find(const _Elem *_Ptr,
; 1873 : 		size_type _Off, size_type _Count) const
; 1874 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1875 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1876 : 		if (_Count != 0)
; 1877 : 			_DEBUG_POINTER(_Ptr);
; 1878 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1879 : 
; 1880 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1881 : 			return (_Off);	// null string always matches (if inside string)
; 1882 : 
; 1883 : 		size_type _Nm;
; 1884 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1885 : 			{	// room for match, look for it
; 1886 : 			const _Elem *_Uptr, *_Vptr;
; 1887 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1888 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1889 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1890 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1891 : 					return (_Uptr - this->_Myptr());	// found a match
; 1892 : 			}
; 1893 : 
; 1894 : 		return (npos);	// no match
; 1895 : 		}
; 1896 : 
; 1897 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1898 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1899 : 		_DEBUG_POINTER(_Ptr);
; 1900 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1901 : 		}
; 1902 : 
; 1903 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1904 : 		{	// look for _Ch at or after _Off
; 1905 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1906 : 		}
; 1907 : 
; 1908 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1909 : 		{	// look for _Right beginning before _Off
; 1910 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1911 : 		}
; 1912 : 
; 1913 : 	size_type rfind(const _Elem *_Ptr,
; 1914 : 		size_type _Off, size_type _Count) const
; 1915 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1916 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1917 : 		if (_Count != 0)
; 1918 : 			_DEBUG_POINTER(_Ptr);
; 1919 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1920 : 
; 1921 : 		if (_Count == 0)
; 1922 : 			return (_Off < this->_Mysize ? _Off
; 1923 : 				: this->_Mysize);	// null always matches
; 1924 : 		if (_Count <= this->_Mysize)
; 1925 : 			{	// room for match, look for it
; 1926 : 			const _Elem *_Uptr = this->_Myptr() +
; 1927 : 				(_Off < this->_Mysize - _Count ? _Off
; 1928 : 					: this->_Mysize - _Count);
; 1929 : 			for (; ; --_Uptr)
; 1930 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1931 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1932 : 					return (_Uptr - this->_Myptr());	// found a match
; 1933 : 				else if (_Uptr == this->_Myptr())
; 1934 : 					break;	// at beginning, no more chance for match
; 1935 : 			}
; 1936 : 
; 1937 : 		return (npos);	// no match
; 1938 : 		}
; 1939 : 
; 1940 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1941 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1942 : 		_DEBUG_POINTER(_Ptr);
; 1943 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1944 : 		}
; 1945 : 
; 1946 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1947 : 		{	// look for _Ch before _Off
; 1948 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1949 : 		}
; 1950 : 
; 1951 : 	size_type find_first_of(const _Myt& _Right,
; 1952 : 		size_type _Off = 0) const _NOEXCEPT
; 1953 : 		{	// look for one of _Right at or after _Off
; 1954 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1955 : 		}
; 1956 : 
; 1957 : 	size_type find_first_of(const _Elem *_Ptr,
; 1958 : 		size_type _Off, size_type _Count) const
; 1959 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1960 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1961 : 		if (_Count != 0)
; 1962 : 			_DEBUG_POINTER(_Ptr);
; 1963 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1964 : 
; 1965 : 		if (0 < _Count && _Off < this->_Mysize)
; 1966 : 			{	// room for match, look for it
; 1967 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1968 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1969 : 				_Uptr < _Vptr; ++_Uptr)
; 1970 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1971 : 					return (_Uptr - this->_Myptr());	// found a match
; 1972 : 			}
; 1973 : 
; 1974 : 		return (npos);	// no match
; 1975 : 		}
; 1976 : 
; 1977 : 	size_type find_first_of(const _Elem *_Ptr,
; 1978 : 		size_type _Off = 0) const
; 1979 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1980 : 		_DEBUG_POINTER(_Ptr);
; 1981 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 1982 : 		}
; 1983 : 
; 1984 : 	size_type find_first_of(_Elem _Ch,
; 1985 : 		size_type _Off = 0) const
; 1986 : 		{	// look for _Ch at or after _Off
; 1987 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1988 : 		}
; 1989 : 
; 1990 : 	size_type find_last_of(const _Myt& _Right,
; 1991 : 		size_type _Off = npos) const _NOEXCEPT
; 1992 : 		{	// look for one of _Right before _Off
; 1993 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_last_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off, size_type _Count) const
; 1998 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 1999 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2000 : 		if (_Count != 0)
; 2001 : 			_DEBUG_POINTER(_Ptr);
; 2002 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2003 : 
; 2004 : 		if (0 < _Count && 0 < this->_Mysize)
; 2005 : 			{	// worth searching, do it
; 2006 : 			const _Elem *_Uptr = this->_Myptr()
; 2007 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2008 : 			for (; ; --_Uptr)
; 2009 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2010 : 					return (_Uptr - this->_Myptr());	// found a match
; 2011 : 				else if (_Uptr == this->_Myptr())
; 2012 : 					break;	// at beginning, no more chance for match
; 2013 : 			}
; 2014 : 
; 2015 : 		return (npos);	// no match
; 2016 : 		}
; 2017 : 
; 2018 : 	size_type find_last_of(const _Elem *_Ptr,
; 2019 : 		size_type _Off = npos) const
; 2020 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2021 : 		_DEBUG_POINTER(_Ptr);
; 2022 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2023 : 		}
; 2024 : 
; 2025 : 	size_type find_last_of(_Elem _Ch,
; 2026 : 		size_type _Off = npos) const
; 2027 : 		{	// look for _Ch before _Off
; 2028 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2029 : 		}
; 2030 : 
; 2031 : 	size_type find_first_not_of(const _Myt& _Right,
; 2032 : 		size_type _Off = 0) const _NOEXCEPT
; 2033 : 		{	// look for none of _Right at or after _Off
; 2034 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2035 : 			_Right.size()));
; 2036 : 		}
; 2037 : 
; 2038 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2039 : 		size_type _Off, size_type _Count) const
; 2040 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2041 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2042 : 		if (_Count != 0)
; 2043 : 			_DEBUG_POINTER(_Ptr);
; 2044 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2045 : 
; 2046 : 		if (_Off < this->_Mysize)
; 2047 : 			{	// room for match, look for it
; 2048 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2049 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2050 : 				_Uptr < _Vptr; ++_Uptr)
; 2051 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2052 : 					return (_Uptr - this->_Myptr());
; 2053 : 			}
; 2054 : 		return (npos);
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off = 0) const
; 2059 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2060 : 		_DEBUG_POINTER(_Ptr);
; 2061 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2062 : 		}
; 2063 : 
; 2064 : 	size_type find_first_not_of(_Elem _Ch,
; 2065 : 		size_type _Off = 0) const
; 2066 : 		{	// look for non _Ch at or after _Off
; 2067 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2068 : 		}
; 2069 : 
; 2070 : 	size_type find_last_not_of(const _Myt& _Right,
; 2071 : 		size_type _Off = npos) const _NOEXCEPT
; 2072 : 		{	// look for none of _Right before _Off
; 2073 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off, size_type _Count) const
; 2078 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2079 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2080 : 		if (_Count != 0)
; 2081 : 			_DEBUG_POINTER(_Ptr);
; 2082 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2083 : 
; 2084 : 		if (0 < this->_Mysize)
; 2085 : 			{	// worth searching, do it
; 2086 : 			const _Elem *_Uptr = this->_Myptr()
; 2087 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2088 : 			for (; ; --_Uptr)
; 2089 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2090 : 					return (_Uptr - this->_Myptr());
; 2091 : 				else if (_Uptr == this->_Myptr())
; 2092 : 					break;
; 2093 : 			}
; 2094 : 		return (npos);
; 2095 : 		}
; 2096 : 
; 2097 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2098 : 		size_type _Off = npos) const
; 2099 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2100 : 		_DEBUG_POINTER(_Ptr);
; 2101 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2102 : 		}
; 2103 : 
; 2104 : 	size_type find_last_not_of(_Elem _Ch,
; 2105 : 		size_type _Off = npos) const
; 2106 : 		{	// look for non _Ch before _Off
; 2107 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2108 : 		}
; 2109 : 
; 2110 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2111 : 		{	// return [_Off, _Off + _Count) as new string
; 2112 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2113 : 		}
; 2114 : 
; 2115 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2116 : 		{	// compare [0, _Mysize) with _Right
; 2117 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2118 : 		}
; 2119 : 
; 2120 : 	int compare(size_type _Off, size_type _N0,
; 2121 : 		const _Myt& _Right) const
; 2122 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2123 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2124 : 		}
; 2125 : 
; 2126 : 	int compare(size_type _Off,
; 2127 : 		size_type _N0, const _Myt& _Right,
; 2128 : 		size_type _Roff, size_type _Count) const
; 2129 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2130 : 		if (_Right.size() < _Roff)
; 2131 : 			_Xran();	// _Off off end
; 2132 : 		if (_Right._Mysize - _Roff < _Count)
; 2133 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2134 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2135 : 		}
; 2136 : 
; 2137 : 	int compare(const _Elem *_Ptr) const
; 2138 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2139 : 		_DEBUG_POINTER(_Ptr);
; 2140 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2141 : 		}
; 2142 : 
; 2143 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2144 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2145 : 		_DEBUG_POINTER(_Ptr);
; 2146 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2147 : 		}
; 2148 : 
; 2149 : 	int compare(size_type _Off,
; 2150 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2151 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2152 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2153 : 		if (_Count != 0)
; 2154 : 			_DEBUG_POINTER(_Ptr);
; 2155 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2156 : 
; 2157 : 		if (this->_Mysize < _Off)
; 2158 : 			_Xran();	// _Off off end
; 2159 : 		if (this->_Mysize - _Off < _N0)
; 2160 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2161 : 
; 2162 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2163 : 			_N0 < _Count ? _N0 : _Count);
; 2164 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2165 : 			: _N0 == _Count ? 0 : +1);
; 2166 : 		}
; 2167 : 
; 2168 : 	allocator_type get_allocator() const _NOEXCEPT
; 2169 : 		{	// return allocator object for values
; 2170 : 		return (this->_Getal());
; 2171 : 		}
; 2172 : 
; 2173 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2174 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2175 : 		if (_Count == 1)
; 2176 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2177 : 		else
; 2178 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2179 : 		}
; 2180 : 
; 2181 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2182 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2183 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2184 : 		if (max_size() < _Newres)
; 2185 : 			_Newres = _Newsize;	// undo roundup if too big
; 2186 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2187 : 			;
; 2188 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2189 : 			_Newres = this->_Myres
; 2190 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2191 : 		else
; 2192 : 			_Newres = max_size();	// settle for max_size()
; 2193 : 
; 2194 : 		_Elem *_Ptr;
; 2195 : 		_TRY_BEGIN
; 2196 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2197 : 		_CATCH_ALL
; 2198 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2199 : 			_TRY_BEGIN
; 2200 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2201 : 			_CATCH_ALL
; 2202 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2203 : 			_RERAISE;
; 2204 : 			_CATCH_END
; 2205 : 		_CATCH_END
; 2206 : 
; 2207 : 		if (0 < _Oldlen)
; 2208 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2209 : 				_Oldlen);	// copy existing elements
; 2210 : 		_Tidy(true);
; 2211 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2212 : 		this->_Myres = _Newres;
; 2213 : 		_Eos(_Oldlen);
; 2214 : 		}
; 2215 : 
; 2216 : 	void _Eos(size_type _Newsize)
; 2217 : 		{	// set new length and null terminator
; 2218 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  001d0	48 89 7d d7	 mov	 QWORD PTR $T17[rbp-105], rdi
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd

; 347  : 		_Left = _Right;

  001d4	66 89 7d c7	 mov	 WORD PTR $T17[rbp-121], di
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 735  : 		assign(_Right, 0, npos);

  001d8	49 83 c9 ff	 or	 r9, -1
  001dc	45 33 c0	 xor	 r8d, r8d
  001df	48 8d 55 ef	 lea	 rdx, QWORD PTR filePath$[rbp-121]
  001e3	48 8d 4d c7	 lea	 rcx, QWORD PTR $T17[rbp-121]
  001e7	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@AEBV12@_K1@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp

; 225  : 	program.create(filePath);

  001ec	48 8d 55 c7	 lea	 rdx, QWORD PTR $T17[rbp-121]
  001f0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?program@@3VProgram@cl@@A ; program
  001f7	e8 00 00 00 00	 call	 ?create@Program@cl@@QEAA_NV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z ; cl::Program::create

; 227  : 	grid = new VertexStream();

  001fc	b9 58 00 00 00	 mov	 ecx, 88			; 00000058H
  00201	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  00206	48 8b d8	 mov	 rbx, rax
  00209	4c 8d 3d 00 00
	00 00		 lea	 r15, OFFSET FLAT:??_7VertexStream@gfxu@@6B@
  00210	48 85 c0	 test	 rax, rax
  00213	74 4b		 je	 SHORT $LN10@preStart
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp

; 91   : {

  00215	4c 89 38	 mov	 QWORD PTR [rax], r15
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector

; 486  : 		_Myfirst = pointer();

  00218	48 89 78 08	 mov	 QWORD PTR [rax+8], rdi

; 487  : 		_Mylast = pointer();

  0021c	48 89 78 10	 mov	 QWORD PTR [rax+16], rdi

; 488  : 		_Myend = pointer();

  00220	48 89 78 18	 mov	 QWORD PTR [rax+24], rdi
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp

; 19   : {}

  00224	48 89 78 20	 mov	 QWORD PTR [rax+32], rdi
  00228	48 89 78 28	 mov	 QWORD PTR [rax+40], rdi

; 20   : Vertex::Vertex(const Vertex& v)
; 21   : 	: x(v.x), y(v.y), z(v.z)
; 22   : {}
; 23   : Vertex::Vertex(const VertexUV& v)
; 24   : 	: x(v.x), y(v.y), z(v.z)
; 25   : {}
; 26   : Vertex::Vertex(const VertexRGBA& v)
; 27   : 	: x(v.x), y(v.y), z(v.z)
; 28   : {}
; 29   : Vertex::Vertex(const VertexUVRGBA& v)
; 30   : 	: x(v.x), y(v.y), z(v.z)
; 31   : {}
; 32   : 
; 33   : VertexUV::VertexUV(float x, float y, float z, float u, float v)
; 34   : 	: x(x), y(y), z(z), u(u), v(v)
; 35   : {}
; 36   : VertexUV::VertexUV(const Vertex& v)
; 37   : 	: x(v.x), y(v.y), z(v.z), u(0.0f), v(0.0f)
; 38   : {}
; 39   : VertexUV::VertexUV(const VertexUV& v)
; 40   : 	: x(v.x), y(v.y), z(v.z), u(v.u), v(v.v)
; 41   : {}
; 42   : VertexUV::VertexUV(const VertexRGBA& v)
; 43   : 	: x(v.x), y(v.y), z(v.z), u(0.0f), v(0.0f)
; 44   : {}
; 45   : VertexUV::VertexUV(const VertexUVRGBA& v)
; 46   : 	: x(v.x), y(v.y), z(v.z), u(v.u), v(v.v)
; 47   : {}
; 48   : 
; 49   : VertexRGBA::VertexRGBA(float x, float y, float z, float r, float g, float b, float a)
; 50   : 	: x(x), y(y), z(z), r(r * 255.0f), g(g * 255.0f), b(b * 255.0f), a(a * 255.0f)
; 51   : {}
; 52   : VertexRGBA::VertexRGBA(float x, float y, float z, unsigned char r, unsigned char g, unsigned char b, unsigned char a)
; 53   : 	: x(x), y(y), z(z), r(r), g(g), b(b), a(a)
; 54   : {}
; 55   : VertexRGBA::VertexRGBA(const Vertex& v)
; 56   : 	: x(v.x), y(v.y), z(v.z), r(255), g(255), b(255), a(255)
; 57   : {}
; 58   : VertexRGBA::VertexRGBA(const VertexUV& v)
; 59   : 	: x(v.x), y(v.y), z(v.z), r(255), g(255), b(255), a(255)
; 60   : {}
; 61   : VertexRGBA::VertexRGBA(const VertexRGBA& v)
; 62   : 	: x(v.x), y(v.y), z(v.z), r(v.r), g(v.g), b(v.b), a(v.a)
; 63   : {}
; 64   : VertexRGBA::VertexRGBA(const VertexUVRGBA& v)
; 65   : 	: x(v.x), y(v.y), z(v.z), r(v.r), g(v.g), b(v.b), a(v.a)
; 66   : {}
; 67   : 
; 68   : VertexUVRGBA::VertexUVRGBA(float x, float y, float z, float u, float v, float r, float g, float b, float a)
; 69   : 	: x(x), y(y), z(z), u(u), v(v), r(r * 255.0f), g(g * 255.0f), b(b * 255.0f), a(a * 255.0f)
; 70   : {}

  0022c	48 89 78 30	 mov	 QWORD PTR [rax+48], rdi
  00230	48 89 78 38	 mov	 QWORD PTR [rax+56], rdi
  00234	c7 40 40 ff ff
	ff ff		 mov	 DWORD PTR [rax+64], -1	; ffffffffH

; 91   : {

  0023b	66 c7 40 4c 00
	00		 mov	 WORD PTR [rax+76], 0
  00241	c6 40 4e 00	 mov	 BYTE PTR [rax+78], 0
  00245	48 8d 48 50	 lea	 rcx, QWORD PTR [rax+80]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 63   : 	return (_Check_C_return(_Mtx_init(_Mtx, _Type)));

  00249	ba 02 00 00 00	 mov	 edx, 2
  0024e	e8 00 00 00 00	 call	 _Mtx_init

; 32   : 	if (_Res != _Thrd_success)

  00253	85 c0		 test	 eax, eax
  00255	74 0c		 je	 SHORT $LN11@preStart

; 33   : 		_Throw_C_error(_Res);

  00257	8b c8		 mov	 ecx, eax
  00259	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp

; 227  : 	grid = new VertexStream();

  0025e	eb 03		 jmp	 SHORT $LN11@preStart
$LN10@preStart:
  00260	48 8b df	 mov	 rbx, rdi
$LN11@preStart:
  00263	48 89 1d 00 00
	00 00		 mov	 QWORD PTR ?grid@@3PEAVVertexStream@gfxu@@EA, rbx ; grid

; 228  : 	for(int i = -8; i <= 8; i++)

  0026a	be f8 ff ff ff	 mov	 esi, -8
  0026f	f3 44 0f 10 05
	00 00 00 00	 movss	 xmm8, DWORD PTR __real@41000000
  00278	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL7@preStart:

; 230  : 		for(int j = -8; j <= 8; j++)

  00280	41 be f8 ff ff
	ff		 mov	 r14d, -8
  00286	66 0f 6e fe	 movd	 xmm7, esi
  0028a	0f 5b ff	 cvtdq2ps xmm7, xmm7
  0028d	0f 1f 00	 npad	 3
$LL4@preStart:
  00290	66 41 0f 6e f6	 movd	 xmm6, r14d

; 231  : 		{
; 232  : 			grid->put(Vertex(i, j, -8));

  00295	0f 5b f6	 cvtdq2ps xmm6, xmm6
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp

; 108  : 	vertex.x = x + translation.x;

  00298	48 8d 53 2c	 lea	 rdx, QWORD PTR [rbx+44]
  0029c	0f 28 c7	 movaps	 xmm0, xmm7
  0029f	f3 0f 58 43 20	 addss	 xmm0, DWORD PTR [rbx+32]
  002a4	f3 0f 11 02	 movss	 DWORD PTR [rdx], xmm0

; 109  : 	vertex.y = y + translation.y;

  002a8	0f 28 ce	 movaps	 xmm1, xmm6
  002ab	f3 0f 58 4b 24	 addss	 xmm1, DWORD PTR [rbx+36]
  002b0	f3 0f 11 4b 30	 movss	 DWORD PTR [rbx+48], xmm1

; 110  : 	vertex.z = z + translation.z;

  002b5	f3 0f 10 43 28	 movss	 xmm0, DWORD PTR [rbx+40]
  002ba	f3 41 0f 5c c0	 subss	 xmm0, xmm8
  002bf	f3 0f 11 43 34	 movss	 DWORD PTR [rbx+52], xmm0

; 111  : 
; 112  : 	vertices.push_back(vertex);

  002c4	48 8d 4b 08	 lea	 rcx, QWORD PTR [rbx+8]
  002c8	e8 00 00 00 00	 call	 ?push_back@?$vector@VVertexUVRGBA@gfxu@@V?$allocator@VVertexUVRGBA@gfxu@@@std@@@std@@QEAAXAEBVVertexUVRGBA@gfxu@@@Z ; std::vector<gfxu::VertexUVRGBA,std::allocator<gfxu::VertexUVRGBA> >::push_back

; 113  : 
; 114  : 	vs++;

  002cd	ff 05 00 00 00
	00		 inc	 DWORD PTR ?vs@@3HA	; vs

; 108  : 	vertex.x = x + translation.x;

  002d3	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?grid@@3PEAVVertexStream@gfxu@@EA ; grid
  002da	48 8d 51 2c	 lea	 rdx, QWORD PTR [rcx+44]
  002de	0f 28 c7	 movaps	 xmm0, xmm7
  002e1	f3 0f 58 41 20	 addss	 xmm0, DWORD PTR [rcx+32]
  002e6	f3 0f 11 02	 movss	 DWORD PTR [rdx], xmm0

; 109  : 	vertex.y = y + translation.y;

  002ea	0f 28 ce	 movaps	 xmm1, xmm6
  002ed	f3 0f 58 49 24	 addss	 xmm1, DWORD PTR [rcx+36]
  002f2	f3 0f 11 49 30	 movss	 DWORD PTR [rcx+48], xmm1

; 110  : 	vertex.z = z + translation.z;

  002f7	f3 0f 10 41 28	 movss	 xmm0, DWORD PTR [rcx+40]
  002fc	f3 41 0f 58 c0	 addss	 xmm0, xmm8
  00301	f3 0f 11 41 34	 movss	 DWORD PTR [rcx+52], xmm0

; 111  : 
; 112  : 	vertices.push_back(vertex);

  00306	48 83 c1 08	 add	 rcx, 8
  0030a	e8 00 00 00 00	 call	 ?push_back@?$vector@VVertexUVRGBA@gfxu@@V?$allocator@VVertexUVRGBA@gfxu@@@std@@@std@@QEAAXAEBVVertexUVRGBA@gfxu@@@Z ; std::vector<gfxu::VertexUVRGBA,std::allocator<gfxu::VertexUVRGBA> >::push_back

; 113  : 
; 114  : 	vs++;

  0030f	ff 05 00 00 00
	00		 inc	 DWORD PTR ?vs@@3HA	; vs

; 108  : 	vertex.x = x + translation.x;

  00315	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?grid@@3PEAVVertexStream@gfxu@@EA ; grid
  0031c	48 8d 51 2c	 lea	 rdx, QWORD PTR [rcx+44]
  00320	0f 28 c7	 movaps	 xmm0, xmm7
  00323	f3 0f 58 41 20	 addss	 xmm0, DWORD PTR [rcx+32]
  00328	f3 0f 11 02	 movss	 DWORD PTR [rdx], xmm0

; 109  : 	vertex.y = y + translation.y;

  0032c	f3 0f 10 49 24	 movss	 xmm1, DWORD PTR [rcx+36]
  00331	f3 41 0f 5c c8	 subss	 xmm1, xmm8
  00336	f3 0f 11 49 30	 movss	 DWORD PTR [rcx+48], xmm1

; 110  : 	vertex.z = z + translation.z;

  0033b	0f 28 c6	 movaps	 xmm0, xmm6
  0033e	f3 0f 58 41 28	 addss	 xmm0, DWORD PTR [rcx+40]
  00343	f3 0f 11 41 34	 movss	 DWORD PTR [rcx+52], xmm0

; 111  : 
; 112  : 	vertices.push_back(vertex);

  00348	48 83 c1 08	 add	 rcx, 8
  0034c	e8 00 00 00 00	 call	 ?push_back@?$vector@VVertexUVRGBA@gfxu@@V?$allocator@VVertexUVRGBA@gfxu@@@std@@@std@@QEAAXAEBVVertexUVRGBA@gfxu@@@Z ; std::vector<gfxu::VertexUVRGBA,std::allocator<gfxu::VertexUVRGBA> >::push_back

; 113  : 
; 114  : 	vs++;

  00351	ff 05 00 00 00
	00		 inc	 DWORD PTR ?vs@@3HA	; vs

; 108  : 	vertex.x = x + translation.x;

  00357	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?grid@@3PEAVVertexStream@gfxu@@EA ; grid
  0035e	48 8d 51 2c	 lea	 rdx, QWORD PTR [rcx+44]
  00362	0f 28 c7	 movaps	 xmm0, xmm7
  00365	f3 0f 58 41 20	 addss	 xmm0, DWORD PTR [rcx+32]
  0036a	f3 0f 11 02	 movss	 DWORD PTR [rdx], xmm0

; 109  : 	vertex.y = y + translation.y;

  0036e	f3 0f 10 49 24	 movss	 xmm1, DWORD PTR [rcx+36]
  00373	f3 41 0f 58 c8	 addss	 xmm1, xmm8
  00378	f3 0f 11 49 30	 movss	 DWORD PTR [rcx+48], xmm1

; 110  : 	vertex.z = z + translation.z;

  0037d	0f 28 c6	 movaps	 xmm0, xmm6
  00380	f3 0f 58 41 28	 addss	 xmm0, DWORD PTR [rcx+40]
  00385	f3 0f 11 41 34	 movss	 DWORD PTR [rcx+52], xmm0

; 111  : 
; 112  : 	vertices.push_back(vertex);

  0038a	48 83 c1 08	 add	 rcx, 8
  0038e	e8 00 00 00 00	 call	 ?push_back@?$vector@VVertexUVRGBA@gfxu@@V?$allocator@VVertexUVRGBA@gfxu@@@std@@@std@@QEAAXAEBVVertexUVRGBA@gfxu@@@Z ; std::vector<gfxu::VertexUVRGBA,std::allocator<gfxu::VertexUVRGBA> >::push_back

; 113  : 
; 114  : 	vs++;

  00393	ff 05 00 00 00
	00		 inc	 DWORD PTR ?vs@@3HA	; vs

; 108  : 	vertex.x = x + translation.x;

  00399	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?grid@@3PEAVVertexStream@gfxu@@EA ; grid
  003a0	48 8d 51 2c	 lea	 rdx, QWORD PTR [rcx+44]
  003a4	f3 0f 10 41 20	 movss	 xmm0, DWORD PTR [rcx+32]
  003a9	f3 41 0f 5c c0	 subss	 xmm0, xmm8
  003ae	f3 0f 11 02	 movss	 DWORD PTR [rdx], xmm0

; 109  : 	vertex.y = y + translation.y;

  003b2	0f 28 cf	 movaps	 xmm1, xmm7
  003b5	f3 0f 58 49 24	 addss	 xmm1, DWORD PTR [rcx+36]
  003ba	f3 0f 11 49 30	 movss	 DWORD PTR [rcx+48], xmm1

; 110  : 	vertex.z = z + translation.z;

  003bf	0f 28 c6	 movaps	 xmm0, xmm6
  003c2	f3 0f 58 41 28	 addss	 xmm0, DWORD PTR [rcx+40]
  003c7	f3 0f 11 41 34	 movss	 DWORD PTR [rcx+52], xmm0

; 111  : 
; 112  : 	vertices.push_back(vertex);

  003cc	48 83 c1 08	 add	 rcx, 8
  003d0	e8 00 00 00 00	 call	 ?push_back@?$vector@VVertexUVRGBA@gfxu@@V?$allocator@VVertexUVRGBA@gfxu@@@std@@@std@@QEAAXAEBVVertexUVRGBA@gfxu@@@Z ; std::vector<gfxu::VertexUVRGBA,std::allocator<gfxu::VertexUVRGBA> >::push_back

; 113  : 
; 114  : 	vs++;

  003d5	ff 05 00 00 00
	00		 inc	 DWORD PTR ?vs@@3HA	; vs

; 108  : 	vertex.x = x + translation.x;

  003db	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?grid@@3PEAVVertexStream@gfxu@@EA ; grid
  003e2	48 8d 51 2c	 lea	 rdx, QWORD PTR [rcx+44]
  003e6	f3 0f 10 41 20	 movss	 xmm0, DWORD PTR [rcx+32]
  003eb	f3 41 0f 58 c0	 addss	 xmm0, xmm8
  003f0	f3 0f 11 02	 movss	 DWORD PTR [rdx], xmm0

; 109  : 	vertex.y = y + translation.y;

  003f4	0f 28 cf	 movaps	 xmm1, xmm7
  003f7	f3 0f 58 49 24	 addss	 xmm1, DWORD PTR [rcx+36]
  003fc	f3 0f 11 49 30	 movss	 DWORD PTR [rcx+48], xmm1

; 110  : 	vertex.z = z + translation.z;

  00401	f3 0f 58 71 28	 addss	 xmm6, DWORD PTR [rcx+40]
  00406	f3 0f 11 71 34	 movss	 DWORD PTR [rcx+52], xmm6

; 111  : 
; 112  : 	vertices.push_back(vertex);

  0040b	48 83 c1 08	 add	 rcx, 8
  0040f	e8 00 00 00 00	 call	 ?push_back@?$vector@VVertexUVRGBA@gfxu@@V?$allocator@VVertexUVRGBA@gfxu@@@std@@@std@@QEAAXAEBVVertexUVRGBA@gfxu@@@Z ; std::vector<gfxu::VertexUVRGBA,std::allocator<gfxu::VertexUVRGBA> >::push_back

; 113  : 
; 114  : 	vs++;

  00414	ff 05 00 00 00
	00		 inc	 DWORD PTR ?vs@@3HA	; vs
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp

; 230  : 		for(int j = -8; j <= 8; j++)

  0041a	41 ff c6	 inc	 r14d
  0041d	41 83 fe 08	 cmp	 r14d, 8
  00421	7f 0c		 jg	 SHORT $LN899@preStart
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp

; 19   : {}

  00423	48 8b 1d 00 00
	00 00		 mov	 rbx, QWORD PTR ?grid@@3PEAVVertexStream@gfxu@@EA ; grid
  0042a	e9 61 fe ff ff	 jmp	 $LL4@preStart
$LN899@preStart:
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp

; 228  : 	for(int i = -8; i <= 8; i++)

  0042f	ff c6		 inc	 esi
  00431	83 fe 08	 cmp	 esi, 8
  00434	7f 0c		 jg	 SHORT $LN900@preStart
  00436	48 8b 1d 00 00
	00 00		 mov	 rbx, QWORD PTR ?grid@@3PEAVVertexStream@gfxu@@EA ; grid
  0043d	e9 3e fe ff ff	 jmp	 $LL7@preStart
$LN900@preStart:

; 241  : 	square = new VertexStream();

  00442	b9 58 00 00 00	 mov	 ecx, 88			; 00000058H
  00447	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  0044c	48 8b d8	 mov	 rbx, rax
  0044f	48 85 c0	 test	 rax, rax
  00452	74 4b		 je	 SHORT $LN12@preStart
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp

; 91   : {

  00454	4c 89 38	 mov	 QWORD PTR [rax], r15
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector

; 486  : 		_Myfirst = pointer();

  00457	48 89 78 08	 mov	 QWORD PTR [rax+8], rdi

; 487  : 		_Mylast = pointer();

  0045b	48 89 78 10	 mov	 QWORD PTR [rax+16], rdi

; 488  : 		_Myend = pointer();

  0045f	48 89 78 18	 mov	 QWORD PTR [rax+24], rdi
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp

; 19   : {}

  00463	48 89 78 20	 mov	 QWORD PTR [rax+32], rdi
  00467	48 89 78 28	 mov	 QWORD PTR [rax+40], rdi

; 20   : Vertex::Vertex(const Vertex& v)
; 21   : 	: x(v.x), y(v.y), z(v.z)
; 22   : {}
; 23   : Vertex::Vertex(const VertexUV& v)
; 24   : 	: x(v.x), y(v.y), z(v.z)
; 25   : {}
; 26   : Vertex::Vertex(const VertexRGBA& v)
; 27   : 	: x(v.x), y(v.y), z(v.z)
; 28   : {}
; 29   : Vertex::Vertex(const VertexUVRGBA& v)
; 30   : 	: x(v.x), y(v.y), z(v.z)
; 31   : {}
; 32   : 
; 33   : VertexUV::VertexUV(float x, float y, float z, float u, float v)
; 34   : 	: x(x), y(y), z(z), u(u), v(v)
; 35   : {}
; 36   : VertexUV::VertexUV(const Vertex& v)
; 37   : 	: x(v.x), y(v.y), z(v.z), u(0.0f), v(0.0f)
; 38   : {}
; 39   : VertexUV::VertexUV(const VertexUV& v)
; 40   : 	: x(v.x), y(v.y), z(v.z), u(v.u), v(v.v)
; 41   : {}
; 42   : VertexUV::VertexUV(const VertexRGBA& v)
; 43   : 	: x(v.x), y(v.y), z(v.z), u(0.0f), v(0.0f)
; 44   : {}
; 45   : VertexUV::VertexUV(const VertexUVRGBA& v)
; 46   : 	: x(v.x), y(v.y), z(v.z), u(v.u), v(v.v)
; 47   : {}
; 48   : 
; 49   : VertexRGBA::VertexRGBA(float x, float y, float z, float r, float g, float b, float a)
; 50   : 	: x(x), y(y), z(z), r(r * 255.0f), g(g * 255.0f), b(b * 255.0f), a(a * 255.0f)
; 51   : {}
; 52   : VertexRGBA::VertexRGBA(float x, float y, float z, unsigned char r, unsigned char g, unsigned char b, unsigned char a)
; 53   : 	: x(x), y(y), z(z), r(r), g(g), b(b), a(a)
; 54   : {}
; 55   : VertexRGBA::VertexRGBA(const Vertex& v)
; 56   : 	: x(v.x), y(v.y), z(v.z), r(255), g(255), b(255), a(255)
; 57   : {}
; 58   : VertexRGBA::VertexRGBA(const VertexUV& v)
; 59   : 	: x(v.x), y(v.y), z(v.z), r(255), g(255), b(255), a(255)
; 60   : {}
; 61   : VertexRGBA::VertexRGBA(const VertexRGBA& v)
; 62   : 	: x(v.x), y(v.y), z(v.z), r(v.r), g(v.g), b(v.b), a(v.a)
; 63   : {}
; 64   : VertexRGBA::VertexRGBA(const VertexUVRGBA& v)
; 65   : 	: x(v.x), y(v.y), z(v.z), r(v.r), g(v.g), b(v.b), a(v.a)
; 66   : {}
; 67   : 
; 68   : VertexUVRGBA::VertexUVRGBA(float x, float y, float z, float u, float v, float r, float g, float b, float a)
; 69   : 	: x(x), y(y), z(z), u(u), v(v), r(r * 255.0f), g(g * 255.0f), b(b * 255.0f), a(a * 255.0f)
; 70   : {}

  0046b	48 89 78 30	 mov	 QWORD PTR [rax+48], rdi
  0046f	48 89 78 38	 mov	 QWORD PTR [rax+56], rdi
  00473	c7 40 40 ff ff
	ff ff		 mov	 DWORD PTR [rax+64], -1	; ffffffffH

; 91   : {

  0047a	66 c7 40 4c 00
	00		 mov	 WORD PTR [rax+76], 0
  00480	c6 40 4e 00	 mov	 BYTE PTR [rax+78], 0
  00484	48 8d 48 50	 lea	 rcx, QWORD PTR [rax+80]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 63   : 	return (_Check_C_return(_Mtx_init(_Mtx, _Type)));

  00488	ba 02 00 00 00	 mov	 edx, 2
  0048d	e8 00 00 00 00	 call	 _Mtx_init

; 32   : 	if (_Res != _Thrd_success)

  00492	85 c0		 test	 eax, eax
  00494	74 0c		 je	 SHORT $LN13@preStart

; 33   : 		_Throw_C_error(_Res);

  00496	8b c8		 mov	 ecx, eax
  00498	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp

; 241  : 	square = new VertexStream();

  0049d	eb 03		 jmp	 SHORT $LN13@preStart
$LN12@preStart:
  0049f	48 8b df	 mov	 rbx, rdi
$LN13@preStart:
  004a2	48 89 1d 00 00
	00 00		 mov	 QWORD PTR ?square@@3PEAVVertexStream@gfxu@@EA, rbx ; square
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp

; 108  : 	vertex.x = x + translation.x;

  004a9	48 8d 53 2c	 lea	 rdx, QWORD PTR [rbx+44]
  004ad	f3 0f 10 43 20	 movss	 xmm0, DWORD PTR [rbx+32]
  004b2	0f 57 f6	 xorps	 xmm6, xmm6
  004b5	f3 0f 58 c6	 addss	 xmm0, xmm6
  004b9	f3 0f 11 02	 movss	 DWORD PTR [rdx], xmm0

; 109  : 	vertex.y = y + translation.y;

  004bd	f3 0f 10 43 24	 movss	 xmm0, DWORD PTR [rbx+36]
  004c2	f3 0f 58 c6	 addss	 xmm0, xmm6
  004c6	f3 0f 11 43 30	 movss	 DWORD PTR [rbx+48], xmm0

; 110  : 	vertex.z = z + translation.z;

  004cb	f3 0f 10 4b 28	 movss	 xmm1, DWORD PTR [rbx+40]
  004d0	f3 0f 58 ce	 addss	 xmm1, xmm6
  004d4	f3 0f 11 4b 34	 movss	 DWORD PTR [rbx+52], xmm1

; 111  : 
; 112  : 	vertices.push_back(vertex);

  004d9	48 8d 4b 08	 lea	 rcx, QWORD PTR [rbx+8]
  004dd	e8 00 00 00 00	 call	 ?push_back@?$vector@VVertexUVRGBA@gfxu@@V?$allocator@VVertexUVRGBA@gfxu@@@std@@@std@@QEAAXAEBVVertexUVRGBA@gfxu@@@Z ; std::vector<gfxu::VertexUVRGBA,std::allocator<gfxu::VertexUVRGBA> >::push_back

; 113  : 
; 114  : 	vs++;

  004e2	ff 05 00 00 00
	00		 inc	 DWORD PTR ?vs@@3HA	; vs

; 108  : 	vertex.x = x + translation.x;

  004e8	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?square@@3PEAVVertexStream@gfxu@@EA ; square
  004ef	48 8d 51 2c	 lea	 rdx, QWORD PTR [rcx+44]
  004f3	f3 0f 10 41 20	 movss	 xmm0, DWORD PTR [rcx+32]
  004f8	f3 0f 10 3d 00
	00 00 00	 movss	 xmm7, DWORD PTR __real@3f800000
  00500	f3 0f 58 c7	 addss	 xmm0, xmm7
  00504	f3 0f 11 02	 movss	 DWORD PTR [rdx], xmm0

; 109  : 	vertex.y = y + translation.y;

  00508	f3 0f 10 49 24	 movss	 xmm1, DWORD PTR [rcx+36]
  0050d	f3 0f 58 ce	 addss	 xmm1, xmm6
  00511	f3 0f 11 49 30	 movss	 DWORD PTR [rcx+48], xmm1

; 110  : 	vertex.z = z + translation.z;

  00516	f3 0f 10 41 28	 movss	 xmm0, DWORD PTR [rcx+40]
  0051b	f3 0f 58 c6	 addss	 xmm0, xmm6
  0051f	f3 0f 11 41 34	 movss	 DWORD PTR [rcx+52], xmm0

; 111  : 
; 112  : 	vertices.push_back(vertex);

  00524	48 83 c1 08	 add	 rcx, 8
  00528	e8 00 00 00 00	 call	 ?push_back@?$vector@VVertexUVRGBA@gfxu@@V?$allocator@VVertexUVRGBA@gfxu@@@std@@@std@@QEAAXAEBVVertexUVRGBA@gfxu@@@Z ; std::vector<gfxu::VertexUVRGBA,std::allocator<gfxu::VertexUVRGBA> >::push_back

; 113  : 
; 114  : 	vs++;

  0052d	ff 05 00 00 00
	00		 inc	 DWORD PTR ?vs@@3HA	; vs

; 108  : 	vertex.x = x + translation.x;

  00533	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?square@@3PEAVVertexStream@gfxu@@EA ; square
  0053a	48 8d 51 2c	 lea	 rdx, QWORD PTR [rcx+44]
  0053e	f3 0f 10 41 20	 movss	 xmm0, DWORD PTR [rcx+32]
  00543	f3 0f 58 c7	 addss	 xmm0, xmm7
  00547	f3 0f 11 02	 movss	 DWORD PTR [rdx], xmm0

; 109  : 	vertex.y = y + translation.y;

  0054b	f3 0f 10 49 24	 movss	 xmm1, DWORD PTR [rcx+36]
  00550	f3 0f 58 ce	 addss	 xmm1, xmm6
  00554	f3 0f 11 49 30	 movss	 DWORD PTR [rcx+48], xmm1

; 110  : 	vertex.z = z + translation.z;

  00559	f3 0f 10 41 28	 movss	 xmm0, DWORD PTR [rcx+40]
  0055e	f3 0f 58 c7	 addss	 xmm0, xmm7
  00562	f3 0f 11 41 34	 movss	 DWORD PTR [rcx+52], xmm0

; 111  : 
; 112  : 	vertices.push_back(vertex);

  00567	48 83 c1 08	 add	 rcx, 8
  0056b	e8 00 00 00 00	 call	 ?push_back@?$vector@VVertexUVRGBA@gfxu@@V?$allocator@VVertexUVRGBA@gfxu@@@std@@@std@@QEAAXAEBVVertexUVRGBA@gfxu@@@Z ; std::vector<gfxu::VertexUVRGBA,std::allocator<gfxu::VertexUVRGBA> >::push_back

; 113  : 
; 114  : 	vs++;

  00570	ff 05 00 00 00
	00		 inc	 DWORD PTR ?vs@@3HA	; vs

; 108  : 	vertex.x = x + translation.x;

  00576	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?square@@3PEAVVertexStream@gfxu@@EA ; square
  0057d	48 8d 51 2c	 lea	 rdx, QWORD PTR [rcx+44]
  00581	f3 0f 10 41 20	 movss	 xmm0, DWORD PTR [rcx+32]
  00586	f3 0f 58 c7	 addss	 xmm0, xmm7
  0058a	f3 0f 11 02	 movss	 DWORD PTR [rdx], xmm0

; 109  : 	vertex.y = y + translation.y;

  0058e	f3 0f 10 49 24	 movss	 xmm1, DWORD PTR [rcx+36]
  00593	f3 0f 58 ce	 addss	 xmm1, xmm6
  00597	f3 0f 11 49 30	 movss	 DWORD PTR [rcx+48], xmm1

; 110  : 	vertex.z = z + translation.z;

  0059c	f3 0f 10 41 28	 movss	 xmm0, DWORD PTR [rcx+40]
  005a1	f3 0f 58 c7	 addss	 xmm0, xmm7
  005a5	f3 0f 11 41 34	 movss	 DWORD PTR [rcx+52], xmm0

; 111  : 
; 112  : 	vertices.push_back(vertex);

  005aa	48 83 c1 08	 add	 rcx, 8
  005ae	e8 00 00 00 00	 call	 ?push_back@?$vector@VVertexUVRGBA@gfxu@@V?$allocator@VVertexUVRGBA@gfxu@@@std@@@std@@QEAAXAEBVVertexUVRGBA@gfxu@@@Z ; std::vector<gfxu::VertexUVRGBA,std::allocator<gfxu::VertexUVRGBA> >::push_back

; 113  : 
; 114  : 	vs++;

  005b3	ff 05 00 00 00
	00		 inc	 DWORD PTR ?vs@@3HA	; vs

; 108  : 	vertex.x = x + translation.x;

  005b9	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?square@@3PEAVVertexStream@gfxu@@EA ; square
  005c0	48 8d 51 2c	 lea	 rdx, QWORD PTR [rcx+44]
  005c4	f3 0f 10 41 20	 movss	 xmm0, DWORD PTR [rcx+32]
  005c9	f3 0f 58 c6	 addss	 xmm0, xmm6
  005cd	f3 0f 11 02	 movss	 DWORD PTR [rdx], xmm0

; 109  : 	vertex.y = y + translation.y;

  005d1	f3 0f 10 49 24	 movss	 xmm1, DWORD PTR [rcx+36]
  005d6	f3 0f 58 ce	 addss	 xmm1, xmm6
  005da	f3 0f 11 49 30	 movss	 DWORD PTR [rcx+48], xmm1

; 110  : 	vertex.z = z + translation.z;

  005df	f3 0f 10 41 28	 movss	 xmm0, DWORD PTR [rcx+40]
  005e4	f3 0f 58 c7	 addss	 xmm0, xmm7
  005e8	f3 0f 11 41 34	 movss	 DWORD PTR [rcx+52], xmm0

; 111  : 
; 112  : 	vertices.push_back(vertex);

  005ed	48 83 c1 08	 add	 rcx, 8
  005f1	e8 00 00 00 00	 call	 ?push_back@?$vector@VVertexUVRGBA@gfxu@@V?$allocator@VVertexUVRGBA@gfxu@@@std@@@std@@QEAAXAEBVVertexUVRGBA@gfxu@@@Z ; std::vector<gfxu::VertexUVRGBA,std::allocator<gfxu::VertexUVRGBA> >::push_back

; 113  : 
; 114  : 	vs++;

  005f6	ff 05 00 00 00
	00		 inc	 DWORD PTR ?vs@@3HA	; vs

; 108  : 	vertex.x = x + translation.x;

  005fc	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?square@@3PEAVVertexStream@gfxu@@EA ; square
  00603	48 8d 51 2c	 lea	 rdx, QWORD PTR [rcx+44]
  00607	f3 0f 10 41 20	 movss	 xmm0, DWORD PTR [rcx+32]
  0060c	f3 0f 58 c6	 addss	 xmm0, xmm6
  00610	f3 0f 11 02	 movss	 DWORD PTR [rdx], xmm0

; 109  : 	vertex.y = y + translation.y;

  00614	f3 0f 10 49 24	 movss	 xmm1, DWORD PTR [rcx+36]
  00619	f3 0f 58 ce	 addss	 xmm1, xmm6
  0061d	f3 0f 11 49 30	 movss	 DWORD PTR [rcx+48], xmm1

; 110  : 	vertex.z = z + translation.z;

  00622	f3 0f 10 41 28	 movss	 xmm0, DWORD PTR [rcx+40]
  00627	f3 0f 58 c6	 addss	 xmm0, xmm6
  0062b	f3 0f 11 41 34	 movss	 DWORD PTR [rcx+52], xmm0

; 111  : 
; 112  : 	vertices.push_back(vertex);

  00630	48 83 c1 08	 add	 rcx, 8
  00634	e8 00 00 00 00	 call	 ?push_back@?$vector@VVertexUVRGBA@gfxu@@V?$allocator@VVertexUVRGBA@gfxu@@@std@@@std@@QEAAXAEBVVertexUVRGBA@gfxu@@@Z ; std::vector<gfxu::VertexUVRGBA,std::allocator<gfxu::VertexUVRGBA> >::push_back

; 113  : 
; 114  : 	vs++;

  00639	ff 05 00 00 00
	00		 inc	 DWORD PTR ?vs@@3HA	; vs
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp

; 249  : 	GLWindow::instance->initGL();

  0063f	e8 00 00 00 00	 call	 ?initGL@GLWindow@@QEAAXXZ ; GLWindow::initGL
; File c:\users\glenn\documents\github\wind\project\wind\wind\window.cpp

; 202  : 	return OK;

  00644	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?instance@GLWindow@@2PEAV1@EA ; GLWindow::instance
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp

; 251  : 	if(!GLWindow::instance->isOK())

  0064b	80 38 00	 cmp	 BYTE PTR [rax], 0
  0064e	0f 84 60 03 00
	00		 je	 $LN44@preStart
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 1099 : 		return (assign(_Right, 0, npos));

  00654	49 83 c9 ff	 or	 r9, -1
  00658	45 33 c0	 xor	 r8d, r8d
  0065b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?EXE_DIR@IOUtil@@3V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@A ; IOUtil::EXE_DIR
  00662	48 8d 4d ef	 lea	 rcx, QWORD PTR filePath$[rbp-121]
  00666	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@AEBV12@_K1@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign

; 736  : 		}
; 737  : 
; 738  :  #if _HAS_CPP0X
; 739  : 	basic_string(const _Myt& _Right, const _Alloc& _Al)
; 740  : 		: _Mybase(_Al)
; 741  : 		{	// construct by copying with allocator
; 742  : 		_Tidy();
; 743  : 		assign(_Right, 0, npos);
; 744  : 		}
; 745  :  #endif /* _HAS_CPP0X */
; 746  : 
; 747  : 	basic_string()
; 748  : 		: _Mybase()
; 749  : 		{	// construct empty string
; 750  : 		_Tidy();
; 751  : 		}
; 752  : 
; 753  : 	explicit basic_string(const _Alloc& _Al)
; 754  : 		: _Mybase(_Al)
; 755  : 		{	// construct empty string with allocator
; 756  : 		_Tidy();
; 757  : 		}
; 758  : 
; 759  : 	basic_string(const _Myt& _Right, size_type _Roff,
; 760  : 		size_type _Count = npos)
; 761  : 		: _Mybase(_Right._Getal())
; 762  : 		{	// construct from _Right [_Roff, _Roff + _Count)
; 763  : 		_Tidy();
; 764  : 		assign(_Right, _Roff, _Count);
; 765  : 		}
; 766  : 
; 767  : 	basic_string(const _Myt& _Right, size_type _Roff, size_type _Count,
; 768  : 		const _Alloc& _Al)
; 769  : 		: _Mybase(_Al)
; 770  : 		{	// construct from _Right [_Roff, _Roff + _Count) with allocator
; 771  : 		_Tidy();
; 772  : 		assign(_Right, _Roff, _Count);
; 773  : 		}
; 774  : 
; 775  : 	basic_string(const _Elem *_Ptr, size_type _Count)
; 776  : 		: _Mybase()
; 777  : 		{	// construct from [_Ptr, _Ptr + _Count)
; 778  : 		_Tidy();
; 779  : 		assign(_Ptr, _Count);
; 780  : 		}
; 781  : 
; 782  : 	basic_string(const _Elem *_Ptr, size_type _Count, const _Alloc& _Al)
; 783  : 		: _Mybase(_Al)
; 784  : 		{	// construct from [_Ptr, _Ptr + _Count) with allocator
; 785  : 		_Tidy();
; 786  : 		assign(_Ptr, _Count);
; 787  : 		}
; 788  : 
; 789  : 	basic_string(const _Elem *_Ptr)
; 790  : 		: _Mybase()
; 791  : 		{	// construct from [_Ptr, <null>)
; 792  : 		_Tidy();
; 793  : 		assign(_Ptr);
; 794  : 		}
; 795  : 
; 796  : 	basic_string(const _Elem *_Ptr, const _Alloc& _Al)
; 797  : 		: _Mybase(_Al)
; 798  : 		{	// construct from [_Ptr, <null>) with allocator
; 799  : 		_Tidy();
; 800  : 		assign(_Ptr);
; 801  : 		}
; 802  : 
; 803  : 	basic_string(size_type _Count, _Elem _Ch)
; 804  : 		: _Mybase()
; 805  : 		{	// construct from _Count * _Ch
; 806  : 		_Tidy();
; 807  : 		assign(_Count, _Ch);
; 808  : 		}
; 809  : 
; 810  : 	basic_string(size_type _Count, _Elem _Ch, const _Alloc& _Al)
; 811  : 		: _Mybase(_Al)
; 812  : 		{	// construct from _Count * _Ch with allocator
; 813  : 		_Tidy();
; 814  : 		assign(_Count, _Ch);
; 815  : 		}
; 816  : 
; 817  : 	template<class _Iter>
; 818  : 		basic_string(_Iter _First, _Iter _Last,
; 819  : 			typename enable_if<_Is_iterator<_Iter>::value,
; 820  : 				void>::type ** = 0)
; 821  : 		: _Mybase()
; 822  : 		{	// construct from [_First, _Last)
; 823  : 		_Tidy();
; 824  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 825  : 		}
; 826  : 
; 827  : 	template<class _Iter>
; 828  : 		basic_string(_Iter _First, _Iter _Last, const _Alloc& _Al,
; 829  : 			typename enable_if<_Is_iterator<_Iter>::value,
; 830  : 				void>::type ** = 0)
; 831  : 		: _Mybase(_Al)
; 832  : 		{	// construct from [_First, _Last) with allocator
; 833  : 		_Tidy();
; 834  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 835  : 		}
; 836  : 
; 837  : 	template<class _Iter>
; 838  : 		void _Construct(_Iter _First,
; 839  : 			_Iter _Last, input_iterator_tag)
; 840  : 		{	// initialize from [_First, _Last), input iterators
; 841  : 		_TRY_BEGIN
; 842  : 		for (; _First != _Last; ++_First)
; 843  : 			append((size_type)1, (_Elem)*_First);
; 844  : 		_CATCH_ALL
; 845  : 		_Tidy(true);
; 846  : 		_RERAISE;
; 847  : 		_CATCH_END
; 848  : 		}
; 849  : 
; 850  : 	template<class _Iter>
; 851  : 		void _Construct(_Iter _First,
; 852  : 			_Iter _Last, forward_iterator_tag)
; 853  : 		{	// initialize from [_First, _Last), forward iterators
; 854  : 		_DEBUG_RANGE(_First, _Last);
; 855  : 		size_type _Count = 0;
; 856  : 		_Distance(_First, _Last, _Count);
; 857  : 		reserve(_Count);
; 858  : 
; 859  : 		_TRY_BEGIN
; 860  : 		for (; _First != _Last; ++_First)
; 861  : 			append((size_type)1, (_Elem)*_First);
; 862  : 		_CATCH_ALL
; 863  : 		_Tidy(true);
; 864  : 		_RERAISE;
; 865  : 		_CATCH_END
; 866  : 		}
; 867  : 
; 868  : 	basic_string(const_pointer _First, const_pointer _Last)
; 869  : 		: _Mybase()
; 870  : 		{	// construct from [_First, _Last), const pointers
; 871  : 		_DEBUG_RANGE(_First, _Last);
; 872  : 		_Tidy();
; 873  : 		if (_First != _Last)
; 874  : 			assign(&*_First, _Last - _First);
; 875  : 		}
; 876  : 
; 877  : 	basic_string(const_pointer _First, const_pointer _Last,
; 878  : 		const _Alloc& _Al)
; 879  : 		: _Mybase(_Al)
; 880  : 		{	// construct from [_First, _Last), const pointers
; 881  : 		_DEBUG_RANGE(_First, _Last);
; 882  : 		_Tidy();
; 883  : 		if (_First != _Last)
; 884  : 			assign(&*_First, _Last - _First);
; 885  : 		}
; 886  : 
; 887  : 	basic_string(const_iterator _First, const_iterator _Last)
; 888  : 		: _Mybase()
; 889  : 		{	// construct from [_First, _Last), const_iterators
; 890  : 		_DEBUG_RANGE(_First, _Last);
; 891  : 		_Tidy();
; 892  : 		if (_First != _Last)
; 893  : 			assign(&*_First, _Last - _First);
; 894  : 		}
; 895  : 
; 896  : 	basic_string(_Myt&& _Right) _NOEXCEPT
; 897  : 		: _Mybase(_Right._Getal())
; 898  : 		{	// construct by moving _Right
; 899  : 		_Tidy();
; 900  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 901  : 		}
; 902  : 
; 903  : 	basic_string(_Myt&& _Right, const _Alloc& _Al)
; 904  : 		: _Mybase(_Al)
; 905  : 		{	// construct by moving _Right, allocator
; 906  : 		if (this->_Getal() != _Right._Getal())
; 907  : 			assign(_Right.begin(), _Right.end());
; 908  : 		else
; 909  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 910  : 		}
; 911  : 
; 912  : 	_Myt& operator=(_Myt&& _Right) _NOEXCEPT
; 913  : 		{	// assign by moving _Right
; 914  : 		if (this != &_Right)
; 915  : 			{	// different, assign it
; 916  : 			_Tidy(true);
; 917  : 
; 918  :  #if _HAS_CPP0X
; 919  : 			if (this->_Getal() != _Right._Getal()
; 920  : 				&& _Alty::propagate_on_container_move_assignment::value)
; 921  : 				this->_Change_alloc(_Right._Getal());
; 922  :  #endif /* _HAS_CPP0X */
; 923  : 
; 924  : 			if (this->_Getal() != _Right._Getal())
; 925  : 				assign(_Right.begin(), _Right.end());
; 926  : 			else
; 927  : 				_Assign_rv(_STD forward<_Myt>(_Right));
; 928  : 			}
; 929  : 		return (*this);
; 930  : 		}
; 931  : 
; 932  : 	_Myt& assign(_Myt&& _Right) _NOEXCEPT
; 933  : 		{	// assign by moving _Right
; 934  : 		if (this == &_Right)
; 935  : 			;
; 936  : 		else if (get_allocator() != _Right.get_allocator()
; 937  : 			&& this->_BUF_SIZE <= _Right._Myres)
; 938  : 			*this = _Right;
; 939  : 		else
; 940  : 			{	// not same, clear this and steal from _Right
; 941  : 			_Tidy(true);
; 942  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 943  : 			}
; 944  : 		return (*this);
; 945  : 		}
; 946  : 
; 947  : 	void _Assign_rv(_Myt&& _Right)
; 948  : 		{	// assign by moving _Right
; 949  : 		if (_Right._Myres < this->_BUF_SIZE)
; 950  : 			_Traits::move(this->_Bx._Buf, _Right._Bx._Buf,
; 951  : 				_Right._Mysize + 1);
; 952  : 		else
; 953  : 			{	// copy pointer
; 954  : 			this->_Getal().construct(&this->_Bx._Ptr, _Right._Bx._Ptr);
; 955  : 			_Right._Bx._Ptr = pointer();
; 956  : 			}
; 957  : 		this->_Mysize = _Right._Mysize;
; 958  : 		this->_Myres = _Right._Myres;
; 959  : 		_Right._Tidy();
; 960  : 		}
; 961  : 
; 962  : 	~basic_string() _NOEXCEPT
; 963  : 		{	// destroy the string
; 964  : 		_Tidy(true);
; 965  : 		}
; 966  : 
; 967  : 	_PGLOBAL static const size_type npos;	// bad/missing length/position
; 968  : 
; 969  : 	_Myt& operator=(const _Myt& _Right)
; 970  : 		{	// assign _Right
; 971  : 		if (this != &_Right)
; 972  : 			{	// different, assign it
; 973  :  #if _HAS_CPP0X
; 974  : 			if (this->_Getal() != _Right._Getal()
; 975  : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 976  : 				{	// change allocator before copying
; 977  : 				_Tidy(true);
; 978  : 				this->_Change_alloc(_Right._Getal());
; 979  : 				}
; 980  :  #endif /* _HAS_CPP0X */
; 981  : 
; 982  : 			assign(_Right);
; 983  : 			}
; 984  : 		return (*this);
; 985  : 		}
; 986  : 
; 987  : 	_Myt& operator=(const _Elem *_Ptr)
; 988  : 		{	// assign [_Ptr, <null>)
; 989  : 		return (assign(_Ptr));
; 990  : 		}
; 991  : 
; 992  : 	_Myt& operator=(_Elem _Ch)
; 993  : 		{	// assign 1 * _Ch
; 994  : 		return (assign(1, _Ch));
; 995  : 		}
; 996  : 
; 997  : 	_Myt& operator+=(const _Myt& _Right)
; 998  : 		{	// append _Right
; 999  : 		return (append(_Right));
; 1000 : 		}
; 1001 : 
; 1002 : 	_Myt& operator+=(const _Elem *_Ptr)
; 1003 : 		{	// append [_Ptr, <null>)
; 1004 : 		return (append(_Ptr));
; 1005 : 		}
; 1006 : 
; 1007 : 	_Myt& operator+=(_Elem _Ch)
; 1008 : 		{	// append 1 * _Ch
; 1009 : 		return (append((size_type)1, _Ch));
; 1010 : 		}
; 1011 : 
; 1012 : 	_Myt& append(const _Myt& _Right)
; 1013 : 		{	// append _Right
; 1014 : 		return (append(_Right, 0, npos));
; 1015 : 		}
; 1016 : 
; 1017 : 	_Myt& append(const _Myt& _Right,
; 1018 : 		size_type _Roff, size_type _Count)
; 1019 : 		{	// append _Right [_Roff, _Roff + _Count)
; 1020 : 		if (_Right.size() < _Roff)
; 1021 : 			_Xran();	// _Roff off end
; 1022 : 		size_type _Num = _Right.size() - _Roff;
; 1023 : 		if (_Num < _Count)
; 1024 : 			_Count = _Num;	// trim _Count to size
; 1025 : 		if (npos - this->_Mysize <= _Count)
; 1026 : 			_Xlen();	// result too long
; 1027 : 
; 1028 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1029 : 			{	// make room and append new stuff
; 1030 : 			_Traits::copy(this->_Myptr() + this->_Mysize,
; 1031 : 				_Right._Myptr() + _Roff, _Count);
; 1032 : 			_Eos(_Num);
; 1033 : 			}
; 1034 : 		return (*this);
; 1035 : 		}
; 1036 : 
; 1037 : 	_Myt& append(const _Elem *_Ptr, size_type _Count)
; 1038 : 		{	// append [_Ptr, _Ptr + _Count)
; 1039 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1040 : 		if (_Count != 0)
; 1041 : 			_DEBUG_POINTER(_Ptr);
; 1042 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1043 : 
; 1044 : 		if (_Inside(_Ptr))
; 1045 : 			return (append(*this,
; 1046 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1047 : 		if (npos - this->_Mysize <= _Count)
; 1048 : 			_Xlen();	// result too long
; 1049 : 
; 1050 : 		size_type _Num;
; 1051 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1052 : 			{	// make room and append new stuff
; 1053 : 			_Traits::copy(this->_Myptr() + this->_Mysize, _Ptr, _Count);
; 1054 : 			_Eos(_Num);
; 1055 : 			}
; 1056 : 		return (*this);
; 1057 : 		}
; 1058 : 
; 1059 : 	_Myt& append(const _Elem *_Ptr)
; 1060 : 		{	// append [_Ptr, <null>)
; 1061 : 		_DEBUG_POINTER(_Ptr);
; 1062 : 		return (append(_Ptr, _Traits::length(_Ptr)));

  0066b	41 b8 14 00 00
	00		 mov	 r8d, 20
  00671	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG4294950231
  00678	48 8d 4d ef	 lea	 rcx, QWORD PTR filePath$[rbp-121]
  0067c	e8 00 00 00 00	 call	 ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@PEB_W_K@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp

; 258  : 	normalVShader = new gfxu::VertexShader(filePath);

  00681	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00686	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  0068b	48 8b d8	 mov	 rbx, rax
  0068e	48 89 45 b7	 mov	 QWORD PTR $T9[rbp-121], rax
  00692	48 85 c0	 test	 rax, rax
  00695	74 32		 je	 SHORT $LN14@preStart
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 2265 : 		this->_Myres = this->_BUF_SIZE - 1;

  00697	48 c7 45 df 07
	00 00 00	 mov	 QWORD PTR $T16[rbp-97], 7

; 1100 : 		}
; 1101 : 
; 1102 : 	_Myt& assign(const _Myt& _Right,
; 1103 : 		size_type _Roff, size_type _Count)
; 1104 : 		{	// assign _Right [_Roff, _Roff + _Count)
; 1105 : 		if (_Right.size() < _Roff)
; 1106 : 			_Xran();	// _Roff off end
; 1107 : 		size_type _Num = _Right.size() - _Roff;
; 1108 : 		if (_Count < _Num)
; 1109 : 			_Num = _Count;	// trim _Num to size
; 1110 : 
; 1111 : 		if (this == &_Right)
; 1112 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring
; 1113 : 		else if (_Grow(_Num))
; 1114 : 			{	// make room and assign new stuff
; 1115 : 			_Traits::copy(this->_Myptr(),
; 1116 : 				_Right._Myptr() + _Roff, _Num);
; 1117 : 			_Eos(_Num);
; 1118 : 			}
; 1119 : 		return (*this);
; 1120 : 		}
; 1121 : 
; 1122 : 	_Myt& assign(const _Elem *_Ptr, size_type _Count)
; 1123 : 		{	// assign [_Ptr, _Ptr + _Count)
; 1124 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1125 : 		if (_Count != 0)
; 1126 : 			_DEBUG_POINTER(_Ptr);
; 1127 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1128 : 
; 1129 : 		if (_Inside(_Ptr))
; 1130 : 			return (assign(*this,
; 1131 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1132 : 
; 1133 : 		if (_Grow(_Count))
; 1134 : 			{	// make room and assign new stuff
; 1135 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);
; 1136 : 			_Eos(_Count);
; 1137 : 			}
; 1138 : 		return (*this);
; 1139 : 		}
; 1140 : 
; 1141 : 	_Myt& assign(const _Elem *_Ptr)
; 1142 : 		{	// assign [_Ptr, <null>)
; 1143 : 		_DEBUG_POINTER(_Ptr);
; 1144 : 		return (assign(_Ptr, _Traits::length(_Ptr)));
; 1145 : 		}
; 1146 : 
; 1147 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1148 : 		{	// assign _Count * _Ch
; 1149 : 		if (_Count == npos)
; 1150 : 			_Xlen();	// result too long
; 1151 : 
; 1152 : 		if (_Grow(_Count))
; 1153 : 			{	// make room and assign new stuff
; 1154 : 			_Chassign(0, _Count, _Ch);
; 1155 : 			_Eos(_Count);
; 1156 : 			}
; 1157 : 		return (*this);
; 1158 : 		}
; 1159 : 
; 1160 : 	template<class _Iter>
; 1161 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1162 : 			_Myt&>::type
; 1163 : 		assign(_Iter _First, _Iter _Last)
; 1164 : 		{	// assign [First, _Last), input iterators
; 1165 : 		return (replace(begin(), end(), _First, _Last));
; 1166 : 		}
; 1167 : 
; 1168 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1169 : 		{	// assign [First, _Last), const pointers
; 1170 : 		return (replace(begin(), end(), _First, _Last));
; 1171 : 		}
; 1172 : 
; 1173 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1174 : 		{	// assign [First, _Last), const_iterators
; 1175 : 		return (replace(begin(), end(), _First, _Last));
; 1176 : 		}
; 1177 : 
; 1178 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1179 : 		{	// insert _Right at _Off
; 1180 : 		return (insert(_Off, _Right, 0, npos));
; 1181 : 		}
; 1182 : 
; 1183 : 	_Myt& insert(size_type _Off,
; 1184 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1185 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1186 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1187 : 			_Xran();	// _Off or _Roff off end
; 1188 : 		size_type _Num = _Right.size() - _Roff;
; 1189 : 		if (_Num < _Count)
; 1190 : 			_Count = _Num;	// trim _Count to size
; 1191 : 		if (npos - this->_Mysize <= _Count)
; 1192 : 			_Xlen();	// result too long
; 1193 : 
; 1194 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1195 : 			{	// make room and insert new stuff
; 1196 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1197 : 				this->_Myptr() + _Off,
; 1198 : 				this->_Mysize - _Off);	// empty out hole
; 1199 : 			if (this == &_Right)
; 1200 : 				_Traits::move(this->_Myptr() + _Off,
; 1201 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1202 : 						_Count);	// substring
; 1203 : 			else
; 1204 : 				_Traits::copy(this->_Myptr() + _Off,
; 1205 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1206 : 			_Eos(_Num);
; 1207 : 			}
; 1208 : 		return (*this);
; 1209 : 		}
; 1210 : 
; 1211 : 	_Myt& insert(size_type _Off,
; 1212 : 		const _Elem *_Ptr, size_type _Count)
; 1213 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1214 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1215 : 		if (_Count != 0)
; 1216 : 			_DEBUG_POINTER(_Ptr);
; 1217 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1218 : 
; 1219 : 		if (_Inside(_Ptr))
; 1220 : 			return (insert(_Off, *this,
; 1221 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1222 : 		if (this->_Mysize < _Off)
; 1223 : 			_Xran();	// _Off off end
; 1224 : 		if (npos - this->_Mysize <= _Count)
; 1225 : 			_Xlen();	// result too long
; 1226 : 		size_type _Num;
; 1227 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1228 : 			{	// make room and insert new stuff
; 1229 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1230 : 				this->_Myptr() + _Off,
; 1231 : 				this->_Mysize - _Off);	// empty out hole
; 1232 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1233 : 			_Eos(_Num);
; 1234 : 			}
; 1235 : 		return (*this);
; 1236 : 		}
; 1237 : 
; 1238 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1239 : 		{	// insert [_Ptr, <null>) at _Off
; 1240 : 		_DEBUG_POINTER(_Ptr);
; 1241 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1242 : 		}
; 1243 : 
; 1244 : 	_Myt& insert(size_type _Off,
; 1245 : 		size_type _Count, _Elem _Ch)
; 1246 : 		{	// insert _Count * _Ch at _Off
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	iterator insert(const_iterator _Where)
; 1264 : 		{	// insert <null> at _Where
; 1265 : 		return (insert(_Where, _Elem()));
; 1266 : 		}
; 1267 : 
; 1268 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1269 : 		{	// insert _Ch at _Where
; 1270 : 		size_type _Off = _Pdif(_Where, begin());
; 1271 : 		insert(_Off, 1, _Ch);
; 1272 : 		return (begin() + _Off);
; 1273 : 		}
; 1274 : 
; 1275 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1276 : 		{	// insert _Count * _Elem at _Where
; 1277 : 		size_type _Off = _Pdif(_Where, begin());
; 1278 : 		insert(_Off, _Count, _Ch);
; 1279 : 		return (begin() + _Off);
; 1280 : 		}
; 1281 : 
; 1282 : 	template<class _Iter>
; 1283 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1284 : 			iterator>::type
; 1285 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1286 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1287 : 		size_type _Off = _Pdif(_Where, begin());
; 1288 : 		replace(_Where, _Where, _First, _Last);
; 1289 : 		return (begin() + _Off);
; 1290 : 		}
; 1291 : 
; 1292 : 	iterator insert(const_iterator _Where,
; 1293 : 		const_pointer _First, const_pointer _Last)
; 1294 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		replace(_Where, _Where, _First, _Last);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where,
; 1301 : 		const_iterator _First, const_iterator _Last)
; 1302 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1303 : 		size_type _Off = _Pdif(_Where, begin());
; 1304 : 		replace(_Where, _Where, _First, _Last);
; 1305 : 		return (begin() + _Off);
; 1306 : 		}
; 1307 : 
; 1308 : 	_Myt& erase(size_type _Off = 0)
; 1309 : 		{	// erase elements [_Off, ...)
; 1310 : 		if (this->_Mysize < _Off)
; 1311 : 			_Xran();	// _Off off end
; 1312 : 		_Eos(_Off);
; 1313 : 		return (*this);
; 1314 : 		}
; 1315 : 
; 1316 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1317 : 		{	// erase elements [_Off, _Off + _Count)
; 1318 : 		if (this->_Mysize < _Off)
; 1319 : 			_Xran();	// _Off off end
; 1320 : 		if (this->_Mysize - _Off <= _Count)
; 1321 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1322 : 		else if (0 < _Count)
; 1323 : 			{	// move elements down
; 1324 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1325 : 			size_type _Newsize = this->_Mysize - _Count;
; 1326 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1327 : 			_Eos(_Newsize);
; 1328 : 			}
; 1329 : 		return (*this);
; 1330 : 		}
; 1331 : 
; 1332 : 	iterator erase(const_iterator _Where)
; 1333 : 		{	// erase element at _Where
; 1334 : 		size_type _Count = _Pdif(_Where, begin());
; 1335 : 		erase(_Count, 1);
; 1336 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1337 : 		}
; 1338 : 
; 1339 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1340 : 		{	// erase substring [_First, _Last)
; 1341 : 		_DEBUG_RANGE(_First, _Last);
; 1342 : 		size_type _Count = _Pdif(_First, begin());
; 1343 : 		erase(_Count, _Pdif(_Last, _First));
; 1344 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1345 : 		}
; 1346 : 
; 1347 : 	void clear() _NOEXCEPT
; 1348 : 		{	// erase all
; 1349 : 		_Eos(0);
; 1350 : 		}
; 1351 : 
; 1352 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1353 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1354 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1355 : 		}
; 1356 : 
; 1357 : 	_Myt& replace(size_type _Off,
; 1358 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1359 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1360 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1361 : 			_Xran();	// _Off or _Roff off end
; 1362 : 		if (this->_Mysize - _Off < _N0)
; 1363 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1364 : 		size_type _Num = _Right.size() - _Roff;
; 1365 : 		if (_Num < _Count)
; 1366 : 			_Count = _Num;	// trim _Count to size
; 1367 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1368 : 			_Xlen();	// result too long
; 1369 : 
; 1370 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1371 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1372 : 		if (this->_Mysize < _Newsize)
; 1373 : 			_Grow(_Newsize);
; 1374 : 
; 1375 : 		if (this != &_Right)
; 1376 : 			{	// no overlap, just move down and copy in new stuff
; 1377 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1378 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1379 : 			_Traits::copy(this->_Myptr() + _Off,
; 1380 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1381 : 			}
; 1382 : 		else if (_Count <= _N0)
; 1383 : 			{	// hole doesn't get larger, just copy in substring
; 1384 : 			_Traits::move(this->_Myptr() + _Off,
; 1385 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1386 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1387 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1388 : 			}
; 1389 : 		else if (_Roff <= _Off)
; 1390 : 			{	// hole gets larger, substring begins before hole
; 1391 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1392 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1393 : 			_Traits::move(this->_Myptr() + _Off,
; 1394 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1395 : 			}
; 1396 : 		else if (_Off + _N0 <= _Roff)
; 1397 : 			{	// hole gets larger, substring begins after hole
; 1398 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1399 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1400 : 			_Traits::move(this->_Myptr() + _Off,
; 1401 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1402 : 				_Count);	// fill hole
; 1403 : 			}
; 1404 : 		else
; 1405 : 			{	// hole gets larger, substring begins in hole
; 1406 : 			_Traits::move(this->_Myptr() + _Off,
; 1407 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1408 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1409 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1410 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1411 : 				this->_Myptr() + _Roff + _Count,
; 1412 : 				_Count - _N0);	// fill rest of new hole
; 1413 : 			}
; 1414 : 
; 1415 : 		_Eos(_Newsize);
; 1416 : 		return (*this);
; 1417 : 		}
; 1418 : 
; 1419 : 	_Myt& replace(size_type _Off,
; 1420 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1421 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1422 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1423 : 		if (_Count != 0)
; 1424 : 			_DEBUG_POINTER(_Ptr);
; 1425 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1426 : 
; 1427 : 		if (_Inside(_Ptr))
; 1428 : 			return (replace(_Off, _N0, *this,
; 1429 : 				_Ptr - this->_Myptr(),
; 1430 : 				_Count));	// substring, replace carefully
; 1431 : 		if (this->_Mysize < _Off)
; 1432 : 			_Xran();	// _Off off end
; 1433 : 		if (this->_Mysize - _Off < _N0)
; 1434 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1435 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1436 : 			_Xlen();	// result too long
; 1437 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1438 : 
; 1439 : 		if (_Count < _N0)
; 1440 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1441 : 				this->_Myptr() + _Off + _N0,
; 1442 : 				_Nm);	// smaller hole, move tail up
; 1443 : 		size_type _Num;
; 1444 : 		if ((0 < _Count || 0 < _N0)
; 1445 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1446 : 			{	// make room and rearrange
; 1447 : 			if (_N0 < _Count)
; 1448 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1449 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1450 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1451 : 			_Eos(_Num);
; 1452 : 			}
; 1453 : 		return (*this);
; 1454 : 		}
; 1455 : 
; 1456 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1457 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1458 : 		_DEBUG_POINTER(_Ptr);
; 1459 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1460 : 		}
; 1461 : 
; 1462 : 	_Myt& replace(size_type _Off,
; 1463 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1464 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1465 : 		if (this->_Mysize < _Off)
; 1466 : 			_Xran();	// _Off off end
; 1467 : 		if (this->_Mysize - _Off < _N0)
; 1468 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1469 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1470 : 			_Xlen();	// result too long
; 1471 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1472 : 
; 1473 : 		if (_Count < _N0)
; 1474 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1475 : 				this->_Myptr() + _Off + _N0,
; 1476 : 				_Nm);	// smaller hole, move tail up
; 1477 : 		size_type _Num;
; 1478 : 		if ((0 < _Count || 0 < _N0)
; 1479 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1480 : 			{	// make room and rearrange
; 1481 : 			if (_N0 < _Count)
; 1482 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1483 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1484 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1485 : 			_Eos(_Num);
; 1486 : 			}
; 1487 : 		return (*this);
; 1488 : 		}
; 1489 : 
; 1490 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1491 : 		const _Myt& _Right)
; 1492 : 		{	// replace [_First, _Last) with _Right
; 1493 : 		return (replace(
; 1494 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1495 : 		}
; 1496 : 
; 1497 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1498 : 		const _Elem *_Ptr, size_type _Count)
; 1499 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1500 : 		return (replace(
; 1501 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1502 : 		}
; 1503 : 
; 1504 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1505 : 		const _Elem *_Ptr)
; 1506 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1507 : 		return (replace(
; 1508 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1509 : 		}
; 1510 : 
; 1511 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1512 : 		size_type _Count, _Elem _Ch)
; 1513 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1514 : 		return (replace(
; 1515 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1516 : 		}
; 1517 : 
; 1518 : 	template<class _Iter>
; 1519 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1520 : 			_Myt&>::type
; 1521 : 		replace(const_iterator _First, const_iterator _Last,
; 1522 : 			_Iter _First2, _Iter _Last2)
; 1523 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1524 : 		_Myt _Right(_First2, _Last2);
; 1525 : 		replace(_First, _Last, _Right);
; 1526 : 		return (*this);
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const_pointer _First2, const_pointer _Last2)
; 1531 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1532 : 		if (_First2 == _Last2)
; 1533 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1534 : 		else
; 1535 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1536 : 				&*_First2, _Last2 - _First2);
; 1537 : 		return (*this);
; 1538 : 		}
; 1539 : 
; 1540 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1541 : 		pointer _First2, pointer _Last2)
; 1542 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1543 : 		if (_First2 == _Last2)
; 1544 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1545 : 		else
; 1546 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1547 : 				&*_First2, _Last2 - _First2);
; 1548 : 		return (*this);
; 1549 : 		}
; 1550 : 
; 1551 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1552 : 		const_iterator _First2, const_iterator _Last2)
; 1553 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1554 : 		if (_First2 == _Last2)
; 1555 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1556 : 		else
; 1557 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1558 : 				&*_First2, _Last2 - _First2);
; 1559 : 		return (*this);
; 1560 : 		}
; 1561 : 
; 1562 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1563 : 		iterator _First2, iterator _Last2)
; 1564 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1565 : 		if (_First2 == _Last2)
; 1566 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1567 : 		else
; 1568 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1569 : 				&*_First2, _Last2 - _First2);
; 1570 : 		return (*this);
; 1571 : 		}
; 1572 : 
; 1573 : 	iterator begin() _NOEXCEPT
; 1574 : 		{	// return iterator for beginning of mutable sequence
; 1575 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1576 : 		}
; 1577 : 
; 1578 : 	const_iterator begin() const _NOEXCEPT
; 1579 : 		{	// return iterator for beginning of nonmutable sequence
; 1580 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1581 : 		}
; 1582 : 
; 1583 : 	iterator end() _NOEXCEPT
; 1584 : 		{	// return iterator for end of mutable sequence
; 1585 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1586 : 		}
; 1587 : 
; 1588 : 	const_iterator end() const _NOEXCEPT
; 1589 : 		{	// return iterator for end of nonmutable sequence
; 1590 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1591 : 		}
; 1592 : 
; 1593 : 	reverse_iterator rbegin() _NOEXCEPT
; 1594 : 		{	// return iterator for beginning of reversed mutable sequence
; 1595 : 		return (reverse_iterator(end()));
; 1596 : 		}
; 1597 : 
; 1598 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1600 : 		return (const_reverse_iterator(end()));
; 1601 : 		}
; 1602 : 
; 1603 : 	reverse_iterator rend() _NOEXCEPT
; 1604 : 		{	// return iterator for end of reversed mutable sequence
; 1605 : 		return (reverse_iterator(begin()));
; 1606 : 		}
; 1607 : 
; 1608 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1609 : 		{	// return iterator for end of reversed nonmutable sequence
; 1610 : 		return (const_reverse_iterator(begin()));
; 1611 : 		}
; 1612 : 
; 1613 :  #if _HAS_CPP0X
; 1614 : 	const_iterator cbegin() const _NOEXCEPT
; 1615 : 		{	// return iterator for beginning of nonmutable sequence
; 1616 : 		return (((const _Myt *)this)->begin());
; 1617 : 		}
; 1618 : 
; 1619 : 	const_iterator cend() const _NOEXCEPT
; 1620 : 		{	// return iterator for end of nonmutable sequence
; 1621 : 		return (((const _Myt *)this)->end());
; 1622 : 		}
; 1623 : 
; 1624 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1625 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1626 : 		return (((const _Myt *)this)->rbegin());
; 1627 : 		}
; 1628 : 
; 1629 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1630 : 		{	// return iterator for end of reversed nonmutable sequence
; 1631 : 		return (((const _Myt *)this)->rend());
; 1632 : 		}
; 1633 : 
; 1634 : 	void shrink_to_fit()
; 1635 : 		{	// reduce capacity
; 1636 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1637 : 			{	// worth shrinking, do it
; 1638 : 			_Myt _Tmp(*this);
; 1639 : 			swap(_Tmp);
; 1640 : 			}
; 1641 : 		}
; 1642 :  #endif /* _HAS_CPP0X */
; 1643 : 
; 1644 : 	reference at(size_type _Off)
; 1645 : 		{	// subscript mutable sequence with checking
; 1646 : 		if (this->_Mysize <= _Off)
; 1647 : 			_Xran();	// _Off off end
; 1648 : 		return (this->_Myptr()[_Off]);
; 1649 : 		}
; 1650 : 
; 1651 : 	const_reference at(size_type _Off) const
; 1652 : 		{	// subscript nonmutable sequence with checking
; 1653 : 		if (this->_Mysize <= _Off)
; 1654 : 			_Xran();	// _Off off end
; 1655 : 		return (this->_Myptr()[_Off]);
; 1656 : 		}
; 1657 : 
; 1658 : 	reference operator[](size_type _Off)
; 1659 : 		{	// subscript mutable sequence
; 1660 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1661 : 		if (this->_Mysize < _Off)	// sic
; 1662 : 			_DEBUG_ERROR("string subscript out of range");
; 1663 : 
; 1664 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1665 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1666 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1667 : 
; 1668 : 		return (this->_Myptr()[_Off]);
; 1669 : 		}
; 1670 : 
; 1671 : 	const_reference operator[](size_type _Off) const
; 1672 : 		{	// subscript nonmutable sequence
; 1673 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1674 : 		if (this->_Mysize < _Off)	// sic
; 1675 : 			_DEBUG_ERROR("string subscript out of range");
; 1676 : 
; 1677 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1678 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1679 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1680 : 
; 1681 : 		return (this->_Myptr()[_Off]);
; 1682 : 		}
; 1683 : 
; 1684 : 	void push_back(_Elem _Ch)
; 1685 : 		{	// insert element at end
; 1686 : 		insert(end(), _Ch);
; 1687 : 		}
; 1688 : 
; 1689 :  #if _HAS_CPP0X
; 1690 : 	void pop_back()
; 1691 : 		{	// erase element at end
; 1692 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1693 : 		}
; 1694 : 
; 1695 : 	reference front()
; 1696 : 		{	// return first element of mutable sequence
; 1697 : 		return (*begin());
; 1698 : 		}
; 1699 : 
; 1700 : 	const_reference front() const
; 1701 : 		{	// return first element of nonmutable sequence
; 1702 : 		return (*begin());
; 1703 : 		}
; 1704 : 
; 1705 : 	reference back()
; 1706 : 		{	// return last element of mutable sequence
; 1707 : 		return (*(end() - 1));
; 1708 : 		}
; 1709 : 
; 1710 : 	const_reference back() const
; 1711 : 		{	// return last element of nonmutable sequence
; 1712 : 		return (*(end() - 1));
; 1713 : 		}
; 1714 :  #endif /* _HAS_CPP0X */
; 1715 : 
; 1716 : 	const _Elem *c_str() const _NOEXCEPT
; 1717 : 		{	// return pointer to null-terminated nonmutable array
; 1718 : 		return (this->_Myptr());
; 1719 : 		}
; 1720 : 
; 1721 : 	const _Elem *data() const _NOEXCEPT
; 1722 : 		{	// return pointer to nonmutable array
; 1723 : 		return (c_str());
; 1724 : 		}
; 1725 : 
; 1726 : 	size_type length() const _NOEXCEPT
; 1727 : 		{	// return length of sequence
; 1728 : 		return (this->_Mysize);
; 1729 : 		}
; 1730 : 
; 1731 : 	size_type size() const _NOEXCEPT
; 1732 : 		{	// return length of sequence
; 1733 : 		return (this->_Mysize);
; 1734 : 		}
; 1735 : 
; 1736 : 	size_type max_size() const _NOEXCEPT
; 1737 : 		{	// return maximum possible length of sequence
; 1738 : 		size_type _Num = this->_Getal().max_size();
; 1739 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1740 : 		}
; 1741 : 
; 1742 : 	void resize(size_type _Newsize)
; 1743 : 		{	// determine new length, padding with null elements as needed
; 1744 : 		resize(_Newsize, _Elem());
; 1745 : 		}
; 1746 : 
; 1747 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1748 : 		{	// determine new length, padding with _Ch elements as needed
; 1749 : 		if (_Newsize <= this->_Mysize)
; 1750 : 			_Eos(_Newsize);
; 1751 : 		else
; 1752 : 			append(_Newsize - this->_Mysize, _Ch);
; 1753 : 		}
; 1754 : 
; 1755 : 	size_type capacity() const _NOEXCEPT
; 1756 : 		{	// return current length of allocated storage
; 1757 : 		return (this->_Myres);
; 1758 : 		}
; 1759 : 
; 1760 : 	void reserve(size_type _Newcap = 0)
; 1761 : 		{	// determine new minimum length of allocated storage
; 1762 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1763 : 			{	// change reservation
; 1764 : 			size_type _Size = this->_Mysize;
; 1765 : 			if (_Grow(_Newcap, true))
; 1766 : 				_Eos(_Size);
; 1767 : 			}
; 1768 : 		}
; 1769 : 
; 1770 : 	bool empty() const _NOEXCEPT
; 1771 : 		{	// test if sequence is empty
; 1772 : 		return (this->_Mysize == 0);
; 1773 : 		}
; 1774 : 
; 1775 : 	_SCL_INSECURE_DEPRECATE
; 1776 : 
; 1777 : 	size_type copy(_Elem *_Ptr,
; 1778 : 		size_type _Count, size_type _Off = 0) const
; 1779 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1780 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1781 : 		if (_Count != 0)
; 1782 : 			_DEBUG_POINTER(_Ptr);
; 1783 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1784 : 
; 1785 : 		if (this->_Mysize < _Off)
; 1786 : 			_Xran();	// _Off off end
; 1787 : 		if (this->_Mysize - _Off < _Count)
; 1788 : 			_Count = this->_Mysize - _Off;
; 1789 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1790 : 		return (_Count);
; 1791 : 		}
; 1792 : 
; 1793 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1794 : 		size_type _Count, size_type _Off = 0) const
; 1795 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1796 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1797 : 		if (_Count != 0)
; 1798 : 			_DEBUG_POINTER(_Dest);
; 1799 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1800 : 
; 1801 : 		if (this->_Mysize < _Off)
; 1802 : 			_Xran();	// _Off off end
; 1803 : 		if (this->_Mysize - _Off < _Count)
; 1804 : 			_Count = this->_Mysize - _Off;
; 1805 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1806 : 		return (_Count);
; 1807 : 		}
; 1808 : 
; 1809 : 	void _Swap_bx(_Myt& _Right)
; 1810 : 		{	// exchange _Bx with _Right._Bx
; 1811 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1812 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1813 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1814 : 			else
; 1815 : 				{	// swap large with small
; 1816 : 				pointer _Ptr = this->_Bx._Ptr;
; 1817 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1818 : 				_Traits::copy(this->_Bx._Buf,
; 1819 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1820 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1821 : 				}
; 1822 : 		else
; 1823 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1824 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1825 : 			else
; 1826 : 				{	// swap small with large
; 1827 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1828 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1829 : 				_Traits::copy(_Right._Bx._Buf,
; 1830 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1831 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1832 : 				}
; 1833 : 		}
; 1834 : 
; 1835 : 	void swap(_Myt& _Right)
; 1836 : 		{	// exchange contents with _Right
; 1837 : 		if (this == &_Right)
; 1838 : 			;	// same object, do nothing
; 1839 : 		else if (this->_Getal() == _Right._Getal())
; 1840 : 			{	// same allocator, swap control information
; 1841 : 			this->_Swap_all(_Right);
; 1842 : 			_Swap_bx(_Right);
; 1843 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1844 : 			_STD swap(this->_Myres, _Right._Myres);
; 1845 : 			}
; 1846 : 
; 1847 :  #if _HAS_CPP0X
; 1848 : 		else if (_Alty::propagate_on_container_swap::value)
; 1849 : 			{	// swap allocators and control information
; 1850 : 			this->_Swap_alloc(_Right);
; 1851 : 			_Swap_bx(_Right);
; 1852 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1853 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1854 : 			_STD swap(this->_Myres, _Right._Myres);
; 1855 : 			}
; 1856 :  #endif /* _HAS_CPP0X */
; 1857 : 
; 1858 : 		else
; 1859 : 			{	// different allocator, do multiple assigns
; 1860 : 			_Myt _Tmp = *this;
; 1861 : 
; 1862 : 			*this = _Right;
; 1863 : 			_Right = _Tmp;
; 1864 : 			}
; 1865 : 		}
; 1866 : 
; 1867 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1868 : 		{	// look for _Right beginning at or after _Off
; 1869 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1870 : 		}
; 1871 : 
; 1872 : 	size_type find(const _Elem *_Ptr,
; 1873 : 		size_type _Off, size_type _Count) const
; 1874 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1875 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1876 : 		if (_Count != 0)
; 1877 : 			_DEBUG_POINTER(_Ptr);
; 1878 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1879 : 
; 1880 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1881 : 			return (_Off);	// null string always matches (if inside string)
; 1882 : 
; 1883 : 		size_type _Nm;
; 1884 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1885 : 			{	// room for match, look for it
; 1886 : 			const _Elem *_Uptr, *_Vptr;
; 1887 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1888 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1889 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1890 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1891 : 					return (_Uptr - this->_Myptr());	// found a match
; 1892 : 			}
; 1893 : 
; 1894 : 		return (npos);	// no match
; 1895 : 		}
; 1896 : 
; 1897 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1898 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1899 : 		_DEBUG_POINTER(_Ptr);
; 1900 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1901 : 		}
; 1902 : 
; 1903 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1904 : 		{	// look for _Ch at or after _Off
; 1905 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1906 : 		}
; 1907 : 
; 1908 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1909 : 		{	// look for _Right beginning before _Off
; 1910 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1911 : 		}
; 1912 : 
; 1913 : 	size_type rfind(const _Elem *_Ptr,
; 1914 : 		size_type _Off, size_type _Count) const
; 1915 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1916 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1917 : 		if (_Count != 0)
; 1918 : 			_DEBUG_POINTER(_Ptr);
; 1919 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1920 : 
; 1921 : 		if (_Count == 0)
; 1922 : 			return (_Off < this->_Mysize ? _Off
; 1923 : 				: this->_Mysize);	// null always matches
; 1924 : 		if (_Count <= this->_Mysize)
; 1925 : 			{	// room for match, look for it
; 1926 : 			const _Elem *_Uptr = this->_Myptr() +
; 1927 : 				(_Off < this->_Mysize - _Count ? _Off
; 1928 : 					: this->_Mysize - _Count);
; 1929 : 			for (; ; --_Uptr)
; 1930 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1931 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1932 : 					return (_Uptr - this->_Myptr());	// found a match
; 1933 : 				else if (_Uptr == this->_Myptr())
; 1934 : 					break;	// at beginning, no more chance for match
; 1935 : 			}
; 1936 : 
; 1937 : 		return (npos);	// no match
; 1938 : 		}
; 1939 : 
; 1940 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1941 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1942 : 		_DEBUG_POINTER(_Ptr);
; 1943 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1944 : 		}
; 1945 : 
; 1946 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1947 : 		{	// look for _Ch before _Off
; 1948 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1949 : 		}
; 1950 : 
; 1951 : 	size_type find_first_of(const _Myt& _Right,
; 1952 : 		size_type _Off = 0) const _NOEXCEPT
; 1953 : 		{	// look for one of _Right at or after _Off
; 1954 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1955 : 		}
; 1956 : 
; 1957 : 	size_type find_first_of(const _Elem *_Ptr,
; 1958 : 		size_type _Off, size_type _Count) const
; 1959 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1960 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1961 : 		if (_Count != 0)
; 1962 : 			_DEBUG_POINTER(_Ptr);
; 1963 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1964 : 
; 1965 : 		if (0 < _Count && _Off < this->_Mysize)
; 1966 : 			{	// room for match, look for it
; 1967 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1968 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1969 : 				_Uptr < _Vptr; ++_Uptr)
; 1970 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1971 : 					return (_Uptr - this->_Myptr());	// found a match
; 1972 : 			}
; 1973 : 
; 1974 : 		return (npos);	// no match
; 1975 : 		}
; 1976 : 
; 1977 : 	size_type find_first_of(const _Elem *_Ptr,
; 1978 : 		size_type _Off = 0) const
; 1979 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1980 : 		_DEBUG_POINTER(_Ptr);
; 1981 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 1982 : 		}
; 1983 : 
; 1984 : 	size_type find_first_of(_Elem _Ch,
; 1985 : 		size_type _Off = 0) const
; 1986 : 		{	// look for _Ch at or after _Off
; 1987 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1988 : 		}
; 1989 : 
; 1990 : 	size_type find_last_of(const _Myt& _Right,
; 1991 : 		size_type _Off = npos) const _NOEXCEPT
; 1992 : 		{	// look for one of _Right before _Off
; 1993 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_last_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off, size_type _Count) const
; 1998 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 1999 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2000 : 		if (_Count != 0)
; 2001 : 			_DEBUG_POINTER(_Ptr);
; 2002 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2003 : 
; 2004 : 		if (0 < _Count && 0 < this->_Mysize)
; 2005 : 			{	// worth searching, do it
; 2006 : 			const _Elem *_Uptr = this->_Myptr()
; 2007 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2008 : 			for (; ; --_Uptr)
; 2009 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2010 : 					return (_Uptr - this->_Myptr());	// found a match
; 2011 : 				else if (_Uptr == this->_Myptr())
; 2012 : 					break;	// at beginning, no more chance for match
; 2013 : 			}
; 2014 : 
; 2015 : 		return (npos);	// no match
; 2016 : 		}
; 2017 : 
; 2018 : 	size_type find_last_of(const _Elem *_Ptr,
; 2019 : 		size_type _Off = npos) const
; 2020 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2021 : 		_DEBUG_POINTER(_Ptr);
; 2022 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2023 : 		}
; 2024 : 
; 2025 : 	size_type find_last_of(_Elem _Ch,
; 2026 : 		size_type _Off = npos) const
; 2027 : 		{	// look for _Ch before _Off
; 2028 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2029 : 		}
; 2030 : 
; 2031 : 	size_type find_first_not_of(const _Myt& _Right,
; 2032 : 		size_type _Off = 0) const _NOEXCEPT
; 2033 : 		{	// look for none of _Right at or after _Off
; 2034 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2035 : 			_Right.size()));
; 2036 : 		}
; 2037 : 
; 2038 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2039 : 		size_type _Off, size_type _Count) const
; 2040 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2041 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2042 : 		if (_Count != 0)
; 2043 : 			_DEBUG_POINTER(_Ptr);
; 2044 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2045 : 
; 2046 : 		if (_Off < this->_Mysize)
; 2047 : 			{	// room for match, look for it
; 2048 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2049 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2050 : 				_Uptr < _Vptr; ++_Uptr)
; 2051 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2052 : 					return (_Uptr - this->_Myptr());
; 2053 : 			}
; 2054 : 		return (npos);
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off = 0) const
; 2059 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2060 : 		_DEBUG_POINTER(_Ptr);
; 2061 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2062 : 		}
; 2063 : 
; 2064 : 	size_type find_first_not_of(_Elem _Ch,
; 2065 : 		size_type _Off = 0) const
; 2066 : 		{	// look for non _Ch at or after _Off
; 2067 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2068 : 		}
; 2069 : 
; 2070 : 	size_type find_last_not_of(const _Myt& _Right,
; 2071 : 		size_type _Off = npos) const _NOEXCEPT
; 2072 : 		{	// look for none of _Right before _Off
; 2073 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off, size_type _Count) const
; 2078 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2079 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2080 : 		if (_Count != 0)
; 2081 : 			_DEBUG_POINTER(_Ptr);
; 2082 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2083 : 
; 2084 : 		if (0 < this->_Mysize)
; 2085 : 			{	// worth searching, do it
; 2086 : 			const _Elem *_Uptr = this->_Myptr()
; 2087 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2088 : 			for (; ; --_Uptr)
; 2089 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2090 : 					return (_Uptr - this->_Myptr());
; 2091 : 				else if (_Uptr == this->_Myptr())
; 2092 : 					break;
; 2093 : 			}
; 2094 : 		return (npos);
; 2095 : 		}
; 2096 : 
; 2097 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2098 : 		size_type _Off = npos) const
; 2099 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2100 : 		_DEBUG_POINTER(_Ptr);
; 2101 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2102 : 		}
; 2103 : 
; 2104 : 	size_type find_last_not_of(_Elem _Ch,
; 2105 : 		size_type _Off = npos) const
; 2106 : 		{	// look for non _Ch before _Off
; 2107 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2108 : 		}
; 2109 : 
; 2110 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2111 : 		{	// return [_Off, _Off + _Count) as new string
; 2112 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2113 : 		}
; 2114 : 
; 2115 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2116 : 		{	// compare [0, _Mysize) with _Right
; 2117 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2118 : 		}
; 2119 : 
; 2120 : 	int compare(size_type _Off, size_type _N0,
; 2121 : 		const _Myt& _Right) const
; 2122 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2123 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2124 : 		}
; 2125 : 
; 2126 : 	int compare(size_type _Off,
; 2127 : 		size_type _N0, const _Myt& _Right,
; 2128 : 		size_type _Roff, size_type _Count) const
; 2129 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2130 : 		if (_Right.size() < _Roff)
; 2131 : 			_Xran();	// _Off off end
; 2132 : 		if (_Right._Mysize - _Roff < _Count)
; 2133 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2134 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2135 : 		}
; 2136 : 
; 2137 : 	int compare(const _Elem *_Ptr) const
; 2138 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2139 : 		_DEBUG_POINTER(_Ptr);
; 2140 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2141 : 		}
; 2142 : 
; 2143 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2144 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2145 : 		_DEBUG_POINTER(_Ptr);
; 2146 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2147 : 		}
; 2148 : 
; 2149 : 	int compare(size_type _Off,
; 2150 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2151 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2152 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2153 : 		if (_Count != 0)
; 2154 : 			_DEBUG_POINTER(_Ptr);
; 2155 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2156 : 
; 2157 : 		if (this->_Mysize < _Off)
; 2158 : 			_Xran();	// _Off off end
; 2159 : 		if (this->_Mysize - _Off < _N0)
; 2160 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2161 : 
; 2162 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2163 : 			_N0 < _Count ? _N0 : _Count);
; 2164 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2165 : 			: _N0 == _Count ? 0 : +1);
; 2166 : 		}
; 2167 : 
; 2168 : 	allocator_type get_allocator() const _NOEXCEPT
; 2169 : 		{	// return allocator object for values
; 2170 : 		return (this->_Getal());
; 2171 : 		}
; 2172 : 
; 2173 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2174 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2175 : 		if (_Count == 1)
; 2176 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2177 : 		else
; 2178 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2179 : 		}
; 2180 : 
; 2181 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2182 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2183 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2184 : 		if (max_size() < _Newres)
; 2185 : 			_Newres = _Newsize;	// undo roundup if too big
; 2186 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2187 : 			;
; 2188 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2189 : 			_Newres = this->_Myres
; 2190 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2191 : 		else
; 2192 : 			_Newres = max_size();	// settle for max_size()
; 2193 : 
; 2194 : 		_Elem *_Ptr;
; 2195 : 		_TRY_BEGIN
; 2196 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2197 : 		_CATCH_ALL
; 2198 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2199 : 			_TRY_BEGIN
; 2200 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2201 : 			_CATCH_ALL
; 2202 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2203 : 			_RERAISE;
; 2204 : 			_CATCH_END
; 2205 : 		_CATCH_END
; 2206 : 
; 2207 : 		if (0 < _Oldlen)
; 2208 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2209 : 				_Oldlen);	// copy existing elements
; 2210 : 		_Tidy(true);
; 2211 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2212 : 		this->_Myres = _Newres;
; 2213 : 		_Eos(_Oldlen);
; 2214 : 		}
; 2215 : 
; 2216 : 	void _Eos(size_type _Newsize)
; 2217 : 		{	// set new length and null terminator
; 2218 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  0069f	48 89 7d d7	 mov	 QWORD PTR $T16[rbp-105], rdi
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd

; 347  : 		_Left = _Right;

  006a3	66 89 7d c7	 mov	 WORD PTR $T16[rbp-121], di
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 735  : 		assign(_Right, 0, npos);

  006a7	49 83 c9 ff	 or	 r9, -1
  006ab	45 33 c0	 xor	 r8d, r8d
  006ae	48 8d 55 ef	 lea	 rdx, QWORD PTR filePath$[rbp-121]
  006b2	48 8d 4d c7	 lea	 rcx, QWORD PTR $T16[rbp-121]
  006b6	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@AEBV12@_K1@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp

; 258  : 	normalVShader = new gfxu::VertexShader(filePath);

  006bb	48 8d 55 c7	 lea	 rdx, QWORD PTR $T16[rbp-121]
  006bf	48 8b cb	 mov	 rcx, rbx
  006c2	e8 00 00 00 00	 call	 ??0VertexShader@gfxu@@QEAA@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z ; gfxu::VertexShader::VertexShader
  006c7	eb 03		 jmp	 SHORT $LN15@preStart
$LN14@preStart:
  006c9	48 8b c7	 mov	 rax, rdi
$LN15@preStart:
  006cc	48 89 05 00 00
	00 00		 mov	 QWORD PTR ?normalVShader@@3PEAVVertexShader@gfxu@@EA, rax ; normalVShader
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 1099 : 		return (assign(_Right, 0, npos));

  006d3	49 83 c9 ff	 or	 r9, -1
  006d7	45 33 c0	 xor	 r8d, r8d
  006da	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?EXE_DIR@IOUtil@@3V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@A ; IOUtil::EXE_DIR
  006e1	48 8d 4d ef	 lea	 rcx, QWORD PTR filePath$[rbp-121]
  006e5	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@AEBV12@_K1@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign

; 736  : 		}
; 737  : 
; 738  :  #if _HAS_CPP0X
; 739  : 	basic_string(const _Myt& _Right, const _Alloc& _Al)
; 740  : 		: _Mybase(_Al)
; 741  : 		{	// construct by copying with allocator
; 742  : 		_Tidy();
; 743  : 		assign(_Right, 0, npos);
; 744  : 		}
; 745  :  #endif /* _HAS_CPP0X */
; 746  : 
; 747  : 	basic_string()
; 748  : 		: _Mybase()
; 749  : 		{	// construct empty string
; 750  : 		_Tidy();
; 751  : 		}
; 752  : 
; 753  : 	explicit basic_string(const _Alloc& _Al)
; 754  : 		: _Mybase(_Al)
; 755  : 		{	// construct empty string with allocator
; 756  : 		_Tidy();
; 757  : 		}
; 758  : 
; 759  : 	basic_string(const _Myt& _Right, size_type _Roff,
; 760  : 		size_type _Count = npos)
; 761  : 		: _Mybase(_Right._Getal())
; 762  : 		{	// construct from _Right [_Roff, _Roff + _Count)
; 763  : 		_Tidy();
; 764  : 		assign(_Right, _Roff, _Count);
; 765  : 		}
; 766  : 
; 767  : 	basic_string(const _Myt& _Right, size_type _Roff, size_type _Count,
; 768  : 		const _Alloc& _Al)
; 769  : 		: _Mybase(_Al)
; 770  : 		{	// construct from _Right [_Roff, _Roff + _Count) with allocator
; 771  : 		_Tidy();
; 772  : 		assign(_Right, _Roff, _Count);
; 773  : 		}
; 774  : 
; 775  : 	basic_string(const _Elem *_Ptr, size_type _Count)
; 776  : 		: _Mybase()
; 777  : 		{	// construct from [_Ptr, _Ptr + _Count)
; 778  : 		_Tidy();
; 779  : 		assign(_Ptr, _Count);
; 780  : 		}
; 781  : 
; 782  : 	basic_string(const _Elem *_Ptr, size_type _Count, const _Alloc& _Al)
; 783  : 		: _Mybase(_Al)
; 784  : 		{	// construct from [_Ptr, _Ptr + _Count) with allocator
; 785  : 		_Tidy();
; 786  : 		assign(_Ptr, _Count);
; 787  : 		}
; 788  : 
; 789  : 	basic_string(const _Elem *_Ptr)
; 790  : 		: _Mybase()
; 791  : 		{	// construct from [_Ptr, <null>)
; 792  : 		_Tidy();
; 793  : 		assign(_Ptr);
; 794  : 		}
; 795  : 
; 796  : 	basic_string(const _Elem *_Ptr, const _Alloc& _Al)
; 797  : 		: _Mybase(_Al)
; 798  : 		{	// construct from [_Ptr, <null>) with allocator
; 799  : 		_Tidy();
; 800  : 		assign(_Ptr);
; 801  : 		}
; 802  : 
; 803  : 	basic_string(size_type _Count, _Elem _Ch)
; 804  : 		: _Mybase()
; 805  : 		{	// construct from _Count * _Ch
; 806  : 		_Tidy();
; 807  : 		assign(_Count, _Ch);
; 808  : 		}
; 809  : 
; 810  : 	basic_string(size_type _Count, _Elem _Ch, const _Alloc& _Al)
; 811  : 		: _Mybase(_Al)
; 812  : 		{	// construct from _Count * _Ch with allocator
; 813  : 		_Tidy();
; 814  : 		assign(_Count, _Ch);
; 815  : 		}
; 816  : 
; 817  : 	template<class _Iter>
; 818  : 		basic_string(_Iter _First, _Iter _Last,
; 819  : 			typename enable_if<_Is_iterator<_Iter>::value,
; 820  : 				void>::type ** = 0)
; 821  : 		: _Mybase()
; 822  : 		{	// construct from [_First, _Last)
; 823  : 		_Tidy();
; 824  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 825  : 		}
; 826  : 
; 827  : 	template<class _Iter>
; 828  : 		basic_string(_Iter _First, _Iter _Last, const _Alloc& _Al,
; 829  : 			typename enable_if<_Is_iterator<_Iter>::value,
; 830  : 				void>::type ** = 0)
; 831  : 		: _Mybase(_Al)
; 832  : 		{	// construct from [_First, _Last) with allocator
; 833  : 		_Tidy();
; 834  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 835  : 		}
; 836  : 
; 837  : 	template<class _Iter>
; 838  : 		void _Construct(_Iter _First,
; 839  : 			_Iter _Last, input_iterator_tag)
; 840  : 		{	// initialize from [_First, _Last), input iterators
; 841  : 		_TRY_BEGIN
; 842  : 		for (; _First != _Last; ++_First)
; 843  : 			append((size_type)1, (_Elem)*_First);
; 844  : 		_CATCH_ALL
; 845  : 		_Tidy(true);
; 846  : 		_RERAISE;
; 847  : 		_CATCH_END
; 848  : 		}
; 849  : 
; 850  : 	template<class _Iter>
; 851  : 		void _Construct(_Iter _First,
; 852  : 			_Iter _Last, forward_iterator_tag)
; 853  : 		{	// initialize from [_First, _Last), forward iterators
; 854  : 		_DEBUG_RANGE(_First, _Last);
; 855  : 		size_type _Count = 0;
; 856  : 		_Distance(_First, _Last, _Count);
; 857  : 		reserve(_Count);
; 858  : 
; 859  : 		_TRY_BEGIN
; 860  : 		for (; _First != _Last; ++_First)
; 861  : 			append((size_type)1, (_Elem)*_First);
; 862  : 		_CATCH_ALL
; 863  : 		_Tidy(true);
; 864  : 		_RERAISE;
; 865  : 		_CATCH_END
; 866  : 		}
; 867  : 
; 868  : 	basic_string(const_pointer _First, const_pointer _Last)
; 869  : 		: _Mybase()
; 870  : 		{	// construct from [_First, _Last), const pointers
; 871  : 		_DEBUG_RANGE(_First, _Last);
; 872  : 		_Tidy();
; 873  : 		if (_First != _Last)
; 874  : 			assign(&*_First, _Last - _First);
; 875  : 		}
; 876  : 
; 877  : 	basic_string(const_pointer _First, const_pointer _Last,
; 878  : 		const _Alloc& _Al)
; 879  : 		: _Mybase(_Al)
; 880  : 		{	// construct from [_First, _Last), const pointers
; 881  : 		_DEBUG_RANGE(_First, _Last);
; 882  : 		_Tidy();
; 883  : 		if (_First != _Last)
; 884  : 			assign(&*_First, _Last - _First);
; 885  : 		}
; 886  : 
; 887  : 	basic_string(const_iterator _First, const_iterator _Last)
; 888  : 		: _Mybase()
; 889  : 		{	// construct from [_First, _Last), const_iterators
; 890  : 		_DEBUG_RANGE(_First, _Last);
; 891  : 		_Tidy();
; 892  : 		if (_First != _Last)
; 893  : 			assign(&*_First, _Last - _First);
; 894  : 		}
; 895  : 
; 896  : 	basic_string(_Myt&& _Right) _NOEXCEPT
; 897  : 		: _Mybase(_Right._Getal())
; 898  : 		{	// construct by moving _Right
; 899  : 		_Tidy();
; 900  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 901  : 		}
; 902  : 
; 903  : 	basic_string(_Myt&& _Right, const _Alloc& _Al)
; 904  : 		: _Mybase(_Al)
; 905  : 		{	// construct by moving _Right, allocator
; 906  : 		if (this->_Getal() != _Right._Getal())
; 907  : 			assign(_Right.begin(), _Right.end());
; 908  : 		else
; 909  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 910  : 		}
; 911  : 
; 912  : 	_Myt& operator=(_Myt&& _Right) _NOEXCEPT
; 913  : 		{	// assign by moving _Right
; 914  : 		if (this != &_Right)
; 915  : 			{	// different, assign it
; 916  : 			_Tidy(true);
; 917  : 
; 918  :  #if _HAS_CPP0X
; 919  : 			if (this->_Getal() != _Right._Getal()
; 920  : 				&& _Alty::propagate_on_container_move_assignment::value)
; 921  : 				this->_Change_alloc(_Right._Getal());
; 922  :  #endif /* _HAS_CPP0X */
; 923  : 
; 924  : 			if (this->_Getal() != _Right._Getal())
; 925  : 				assign(_Right.begin(), _Right.end());
; 926  : 			else
; 927  : 				_Assign_rv(_STD forward<_Myt>(_Right));
; 928  : 			}
; 929  : 		return (*this);
; 930  : 		}
; 931  : 
; 932  : 	_Myt& assign(_Myt&& _Right) _NOEXCEPT
; 933  : 		{	// assign by moving _Right
; 934  : 		if (this == &_Right)
; 935  : 			;
; 936  : 		else if (get_allocator() != _Right.get_allocator()
; 937  : 			&& this->_BUF_SIZE <= _Right._Myres)
; 938  : 			*this = _Right;
; 939  : 		else
; 940  : 			{	// not same, clear this and steal from _Right
; 941  : 			_Tidy(true);
; 942  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 943  : 			}
; 944  : 		return (*this);
; 945  : 		}
; 946  : 
; 947  : 	void _Assign_rv(_Myt&& _Right)
; 948  : 		{	// assign by moving _Right
; 949  : 		if (_Right._Myres < this->_BUF_SIZE)
; 950  : 			_Traits::move(this->_Bx._Buf, _Right._Bx._Buf,
; 951  : 				_Right._Mysize + 1);
; 952  : 		else
; 953  : 			{	// copy pointer
; 954  : 			this->_Getal().construct(&this->_Bx._Ptr, _Right._Bx._Ptr);
; 955  : 			_Right._Bx._Ptr = pointer();
; 956  : 			}
; 957  : 		this->_Mysize = _Right._Mysize;
; 958  : 		this->_Myres = _Right._Myres;
; 959  : 		_Right._Tidy();
; 960  : 		}
; 961  : 
; 962  : 	~basic_string() _NOEXCEPT
; 963  : 		{	// destroy the string
; 964  : 		_Tidy(true);
; 965  : 		}
; 966  : 
; 967  : 	_PGLOBAL static const size_type npos;	// bad/missing length/position
; 968  : 
; 969  : 	_Myt& operator=(const _Myt& _Right)
; 970  : 		{	// assign _Right
; 971  : 		if (this != &_Right)
; 972  : 			{	// different, assign it
; 973  :  #if _HAS_CPP0X
; 974  : 			if (this->_Getal() != _Right._Getal()
; 975  : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 976  : 				{	// change allocator before copying
; 977  : 				_Tidy(true);
; 978  : 				this->_Change_alloc(_Right._Getal());
; 979  : 				}
; 980  :  #endif /* _HAS_CPP0X */
; 981  : 
; 982  : 			assign(_Right);
; 983  : 			}
; 984  : 		return (*this);
; 985  : 		}
; 986  : 
; 987  : 	_Myt& operator=(const _Elem *_Ptr)
; 988  : 		{	// assign [_Ptr, <null>)
; 989  : 		return (assign(_Ptr));
; 990  : 		}
; 991  : 
; 992  : 	_Myt& operator=(_Elem _Ch)
; 993  : 		{	// assign 1 * _Ch
; 994  : 		return (assign(1, _Ch));
; 995  : 		}
; 996  : 
; 997  : 	_Myt& operator+=(const _Myt& _Right)
; 998  : 		{	// append _Right
; 999  : 		return (append(_Right));
; 1000 : 		}
; 1001 : 
; 1002 : 	_Myt& operator+=(const _Elem *_Ptr)
; 1003 : 		{	// append [_Ptr, <null>)
; 1004 : 		return (append(_Ptr));
; 1005 : 		}
; 1006 : 
; 1007 : 	_Myt& operator+=(_Elem _Ch)
; 1008 : 		{	// append 1 * _Ch
; 1009 : 		return (append((size_type)1, _Ch));
; 1010 : 		}
; 1011 : 
; 1012 : 	_Myt& append(const _Myt& _Right)
; 1013 : 		{	// append _Right
; 1014 : 		return (append(_Right, 0, npos));
; 1015 : 		}
; 1016 : 
; 1017 : 	_Myt& append(const _Myt& _Right,
; 1018 : 		size_type _Roff, size_type _Count)
; 1019 : 		{	// append _Right [_Roff, _Roff + _Count)
; 1020 : 		if (_Right.size() < _Roff)
; 1021 : 			_Xran();	// _Roff off end
; 1022 : 		size_type _Num = _Right.size() - _Roff;
; 1023 : 		if (_Num < _Count)
; 1024 : 			_Count = _Num;	// trim _Count to size
; 1025 : 		if (npos - this->_Mysize <= _Count)
; 1026 : 			_Xlen();	// result too long
; 1027 : 
; 1028 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1029 : 			{	// make room and append new stuff
; 1030 : 			_Traits::copy(this->_Myptr() + this->_Mysize,
; 1031 : 				_Right._Myptr() + _Roff, _Count);
; 1032 : 			_Eos(_Num);
; 1033 : 			}
; 1034 : 		return (*this);
; 1035 : 		}
; 1036 : 
; 1037 : 	_Myt& append(const _Elem *_Ptr, size_type _Count)
; 1038 : 		{	// append [_Ptr, _Ptr + _Count)
; 1039 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1040 : 		if (_Count != 0)
; 1041 : 			_DEBUG_POINTER(_Ptr);
; 1042 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1043 : 
; 1044 : 		if (_Inside(_Ptr))
; 1045 : 			return (append(*this,
; 1046 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1047 : 		if (npos - this->_Mysize <= _Count)
; 1048 : 			_Xlen();	// result too long
; 1049 : 
; 1050 : 		size_type _Num;
; 1051 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1052 : 			{	// make room and append new stuff
; 1053 : 			_Traits::copy(this->_Myptr() + this->_Mysize, _Ptr, _Count);
; 1054 : 			_Eos(_Num);
; 1055 : 			}
; 1056 : 		return (*this);
; 1057 : 		}
; 1058 : 
; 1059 : 	_Myt& append(const _Elem *_Ptr)
; 1060 : 		{	// append [_Ptr, <null>)
; 1061 : 		_DEBUG_POINTER(_Ptr);
; 1062 : 		return (append(_Ptr, _Traits::length(_Ptr)));

  006ea	41 b8 14 00 00
	00		 mov	 r8d, 20
  006f0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG4294950230
  006f7	48 8d 4d ef	 lea	 rcx, QWORD PTR filePath$[rbp-121]
  006fb	e8 00 00 00 00	 call	 ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@PEB_W_K@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp

; 262  : 	normalFShader = new gfxu::FragmentShader(filePath);

  00700	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00705	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  0070a	48 8b d8	 mov	 rbx, rax
  0070d	48 89 45 b7	 mov	 QWORD PTR $T8[rbp-121], rax
  00711	48 85 c0	 test	 rax, rax
  00714	74 32		 je	 SHORT $LN16@preStart
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 2265 : 		this->_Myres = this->_BUF_SIZE - 1;

  00716	48 c7 45 df 07
	00 00 00	 mov	 QWORD PTR $T15[rbp-97], 7

; 1100 : 		}
; 1101 : 
; 1102 : 	_Myt& assign(const _Myt& _Right,
; 1103 : 		size_type _Roff, size_type _Count)
; 1104 : 		{	// assign _Right [_Roff, _Roff + _Count)
; 1105 : 		if (_Right.size() < _Roff)
; 1106 : 			_Xran();	// _Roff off end
; 1107 : 		size_type _Num = _Right.size() - _Roff;
; 1108 : 		if (_Count < _Num)
; 1109 : 			_Num = _Count;	// trim _Num to size
; 1110 : 
; 1111 : 		if (this == &_Right)
; 1112 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring
; 1113 : 		else if (_Grow(_Num))
; 1114 : 			{	// make room and assign new stuff
; 1115 : 			_Traits::copy(this->_Myptr(),
; 1116 : 				_Right._Myptr() + _Roff, _Num);
; 1117 : 			_Eos(_Num);
; 1118 : 			}
; 1119 : 		return (*this);
; 1120 : 		}
; 1121 : 
; 1122 : 	_Myt& assign(const _Elem *_Ptr, size_type _Count)
; 1123 : 		{	// assign [_Ptr, _Ptr + _Count)
; 1124 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1125 : 		if (_Count != 0)
; 1126 : 			_DEBUG_POINTER(_Ptr);
; 1127 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1128 : 
; 1129 : 		if (_Inside(_Ptr))
; 1130 : 			return (assign(*this,
; 1131 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1132 : 
; 1133 : 		if (_Grow(_Count))
; 1134 : 			{	// make room and assign new stuff
; 1135 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);
; 1136 : 			_Eos(_Count);
; 1137 : 			}
; 1138 : 		return (*this);
; 1139 : 		}
; 1140 : 
; 1141 : 	_Myt& assign(const _Elem *_Ptr)
; 1142 : 		{	// assign [_Ptr, <null>)
; 1143 : 		_DEBUG_POINTER(_Ptr);
; 1144 : 		return (assign(_Ptr, _Traits::length(_Ptr)));
; 1145 : 		}
; 1146 : 
; 1147 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1148 : 		{	// assign _Count * _Ch
; 1149 : 		if (_Count == npos)
; 1150 : 			_Xlen();	// result too long
; 1151 : 
; 1152 : 		if (_Grow(_Count))
; 1153 : 			{	// make room and assign new stuff
; 1154 : 			_Chassign(0, _Count, _Ch);
; 1155 : 			_Eos(_Count);
; 1156 : 			}
; 1157 : 		return (*this);
; 1158 : 		}
; 1159 : 
; 1160 : 	template<class _Iter>
; 1161 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1162 : 			_Myt&>::type
; 1163 : 		assign(_Iter _First, _Iter _Last)
; 1164 : 		{	// assign [First, _Last), input iterators
; 1165 : 		return (replace(begin(), end(), _First, _Last));
; 1166 : 		}
; 1167 : 
; 1168 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1169 : 		{	// assign [First, _Last), const pointers
; 1170 : 		return (replace(begin(), end(), _First, _Last));
; 1171 : 		}
; 1172 : 
; 1173 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1174 : 		{	// assign [First, _Last), const_iterators
; 1175 : 		return (replace(begin(), end(), _First, _Last));
; 1176 : 		}
; 1177 : 
; 1178 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1179 : 		{	// insert _Right at _Off
; 1180 : 		return (insert(_Off, _Right, 0, npos));
; 1181 : 		}
; 1182 : 
; 1183 : 	_Myt& insert(size_type _Off,
; 1184 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1185 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1186 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1187 : 			_Xran();	// _Off or _Roff off end
; 1188 : 		size_type _Num = _Right.size() - _Roff;
; 1189 : 		if (_Num < _Count)
; 1190 : 			_Count = _Num;	// trim _Count to size
; 1191 : 		if (npos - this->_Mysize <= _Count)
; 1192 : 			_Xlen();	// result too long
; 1193 : 
; 1194 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1195 : 			{	// make room and insert new stuff
; 1196 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1197 : 				this->_Myptr() + _Off,
; 1198 : 				this->_Mysize - _Off);	// empty out hole
; 1199 : 			if (this == &_Right)
; 1200 : 				_Traits::move(this->_Myptr() + _Off,
; 1201 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1202 : 						_Count);	// substring
; 1203 : 			else
; 1204 : 				_Traits::copy(this->_Myptr() + _Off,
; 1205 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1206 : 			_Eos(_Num);
; 1207 : 			}
; 1208 : 		return (*this);
; 1209 : 		}
; 1210 : 
; 1211 : 	_Myt& insert(size_type _Off,
; 1212 : 		const _Elem *_Ptr, size_type _Count)
; 1213 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1214 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1215 : 		if (_Count != 0)
; 1216 : 			_DEBUG_POINTER(_Ptr);
; 1217 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1218 : 
; 1219 : 		if (_Inside(_Ptr))
; 1220 : 			return (insert(_Off, *this,
; 1221 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1222 : 		if (this->_Mysize < _Off)
; 1223 : 			_Xran();	// _Off off end
; 1224 : 		if (npos - this->_Mysize <= _Count)
; 1225 : 			_Xlen();	// result too long
; 1226 : 		size_type _Num;
; 1227 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1228 : 			{	// make room and insert new stuff
; 1229 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1230 : 				this->_Myptr() + _Off,
; 1231 : 				this->_Mysize - _Off);	// empty out hole
; 1232 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1233 : 			_Eos(_Num);
; 1234 : 			}
; 1235 : 		return (*this);
; 1236 : 		}
; 1237 : 
; 1238 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1239 : 		{	// insert [_Ptr, <null>) at _Off
; 1240 : 		_DEBUG_POINTER(_Ptr);
; 1241 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1242 : 		}
; 1243 : 
; 1244 : 	_Myt& insert(size_type _Off,
; 1245 : 		size_type _Count, _Elem _Ch)
; 1246 : 		{	// insert _Count * _Ch at _Off
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	iterator insert(const_iterator _Where)
; 1264 : 		{	// insert <null> at _Where
; 1265 : 		return (insert(_Where, _Elem()));
; 1266 : 		}
; 1267 : 
; 1268 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1269 : 		{	// insert _Ch at _Where
; 1270 : 		size_type _Off = _Pdif(_Where, begin());
; 1271 : 		insert(_Off, 1, _Ch);
; 1272 : 		return (begin() + _Off);
; 1273 : 		}
; 1274 : 
; 1275 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1276 : 		{	// insert _Count * _Elem at _Where
; 1277 : 		size_type _Off = _Pdif(_Where, begin());
; 1278 : 		insert(_Off, _Count, _Ch);
; 1279 : 		return (begin() + _Off);
; 1280 : 		}
; 1281 : 
; 1282 : 	template<class _Iter>
; 1283 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1284 : 			iterator>::type
; 1285 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1286 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1287 : 		size_type _Off = _Pdif(_Where, begin());
; 1288 : 		replace(_Where, _Where, _First, _Last);
; 1289 : 		return (begin() + _Off);
; 1290 : 		}
; 1291 : 
; 1292 : 	iterator insert(const_iterator _Where,
; 1293 : 		const_pointer _First, const_pointer _Last)
; 1294 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		replace(_Where, _Where, _First, _Last);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where,
; 1301 : 		const_iterator _First, const_iterator _Last)
; 1302 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1303 : 		size_type _Off = _Pdif(_Where, begin());
; 1304 : 		replace(_Where, _Where, _First, _Last);
; 1305 : 		return (begin() + _Off);
; 1306 : 		}
; 1307 : 
; 1308 : 	_Myt& erase(size_type _Off = 0)
; 1309 : 		{	// erase elements [_Off, ...)
; 1310 : 		if (this->_Mysize < _Off)
; 1311 : 			_Xran();	// _Off off end
; 1312 : 		_Eos(_Off);
; 1313 : 		return (*this);
; 1314 : 		}
; 1315 : 
; 1316 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1317 : 		{	// erase elements [_Off, _Off + _Count)
; 1318 : 		if (this->_Mysize < _Off)
; 1319 : 			_Xran();	// _Off off end
; 1320 : 		if (this->_Mysize - _Off <= _Count)
; 1321 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1322 : 		else if (0 < _Count)
; 1323 : 			{	// move elements down
; 1324 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1325 : 			size_type _Newsize = this->_Mysize - _Count;
; 1326 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1327 : 			_Eos(_Newsize);
; 1328 : 			}
; 1329 : 		return (*this);
; 1330 : 		}
; 1331 : 
; 1332 : 	iterator erase(const_iterator _Where)
; 1333 : 		{	// erase element at _Where
; 1334 : 		size_type _Count = _Pdif(_Where, begin());
; 1335 : 		erase(_Count, 1);
; 1336 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1337 : 		}
; 1338 : 
; 1339 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1340 : 		{	// erase substring [_First, _Last)
; 1341 : 		_DEBUG_RANGE(_First, _Last);
; 1342 : 		size_type _Count = _Pdif(_First, begin());
; 1343 : 		erase(_Count, _Pdif(_Last, _First));
; 1344 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1345 : 		}
; 1346 : 
; 1347 : 	void clear() _NOEXCEPT
; 1348 : 		{	// erase all
; 1349 : 		_Eos(0);
; 1350 : 		}
; 1351 : 
; 1352 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1353 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1354 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1355 : 		}
; 1356 : 
; 1357 : 	_Myt& replace(size_type _Off,
; 1358 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1359 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1360 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1361 : 			_Xran();	// _Off or _Roff off end
; 1362 : 		if (this->_Mysize - _Off < _N0)
; 1363 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1364 : 		size_type _Num = _Right.size() - _Roff;
; 1365 : 		if (_Num < _Count)
; 1366 : 			_Count = _Num;	// trim _Count to size
; 1367 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1368 : 			_Xlen();	// result too long
; 1369 : 
; 1370 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1371 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1372 : 		if (this->_Mysize < _Newsize)
; 1373 : 			_Grow(_Newsize);
; 1374 : 
; 1375 : 		if (this != &_Right)
; 1376 : 			{	// no overlap, just move down and copy in new stuff
; 1377 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1378 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1379 : 			_Traits::copy(this->_Myptr() + _Off,
; 1380 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1381 : 			}
; 1382 : 		else if (_Count <= _N0)
; 1383 : 			{	// hole doesn't get larger, just copy in substring
; 1384 : 			_Traits::move(this->_Myptr() + _Off,
; 1385 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1386 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1387 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1388 : 			}
; 1389 : 		else if (_Roff <= _Off)
; 1390 : 			{	// hole gets larger, substring begins before hole
; 1391 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1392 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1393 : 			_Traits::move(this->_Myptr() + _Off,
; 1394 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1395 : 			}
; 1396 : 		else if (_Off + _N0 <= _Roff)
; 1397 : 			{	// hole gets larger, substring begins after hole
; 1398 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1399 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1400 : 			_Traits::move(this->_Myptr() + _Off,
; 1401 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1402 : 				_Count);	// fill hole
; 1403 : 			}
; 1404 : 		else
; 1405 : 			{	// hole gets larger, substring begins in hole
; 1406 : 			_Traits::move(this->_Myptr() + _Off,
; 1407 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1408 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1409 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1410 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1411 : 				this->_Myptr() + _Roff + _Count,
; 1412 : 				_Count - _N0);	// fill rest of new hole
; 1413 : 			}
; 1414 : 
; 1415 : 		_Eos(_Newsize);
; 1416 : 		return (*this);
; 1417 : 		}
; 1418 : 
; 1419 : 	_Myt& replace(size_type _Off,
; 1420 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1421 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1422 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1423 : 		if (_Count != 0)
; 1424 : 			_DEBUG_POINTER(_Ptr);
; 1425 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1426 : 
; 1427 : 		if (_Inside(_Ptr))
; 1428 : 			return (replace(_Off, _N0, *this,
; 1429 : 				_Ptr - this->_Myptr(),
; 1430 : 				_Count));	// substring, replace carefully
; 1431 : 		if (this->_Mysize < _Off)
; 1432 : 			_Xran();	// _Off off end
; 1433 : 		if (this->_Mysize - _Off < _N0)
; 1434 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1435 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1436 : 			_Xlen();	// result too long
; 1437 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1438 : 
; 1439 : 		if (_Count < _N0)
; 1440 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1441 : 				this->_Myptr() + _Off + _N0,
; 1442 : 				_Nm);	// smaller hole, move tail up
; 1443 : 		size_type _Num;
; 1444 : 		if ((0 < _Count || 0 < _N0)
; 1445 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1446 : 			{	// make room and rearrange
; 1447 : 			if (_N0 < _Count)
; 1448 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1449 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1450 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1451 : 			_Eos(_Num);
; 1452 : 			}
; 1453 : 		return (*this);
; 1454 : 		}
; 1455 : 
; 1456 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1457 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1458 : 		_DEBUG_POINTER(_Ptr);
; 1459 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1460 : 		}
; 1461 : 
; 1462 : 	_Myt& replace(size_type _Off,
; 1463 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1464 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1465 : 		if (this->_Mysize < _Off)
; 1466 : 			_Xran();	// _Off off end
; 1467 : 		if (this->_Mysize - _Off < _N0)
; 1468 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1469 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1470 : 			_Xlen();	// result too long
; 1471 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1472 : 
; 1473 : 		if (_Count < _N0)
; 1474 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1475 : 				this->_Myptr() + _Off + _N0,
; 1476 : 				_Nm);	// smaller hole, move tail up
; 1477 : 		size_type _Num;
; 1478 : 		if ((0 < _Count || 0 < _N0)
; 1479 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1480 : 			{	// make room and rearrange
; 1481 : 			if (_N0 < _Count)
; 1482 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1483 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1484 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1485 : 			_Eos(_Num);
; 1486 : 			}
; 1487 : 		return (*this);
; 1488 : 		}
; 1489 : 
; 1490 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1491 : 		const _Myt& _Right)
; 1492 : 		{	// replace [_First, _Last) with _Right
; 1493 : 		return (replace(
; 1494 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1495 : 		}
; 1496 : 
; 1497 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1498 : 		const _Elem *_Ptr, size_type _Count)
; 1499 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1500 : 		return (replace(
; 1501 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1502 : 		}
; 1503 : 
; 1504 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1505 : 		const _Elem *_Ptr)
; 1506 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1507 : 		return (replace(
; 1508 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1509 : 		}
; 1510 : 
; 1511 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1512 : 		size_type _Count, _Elem _Ch)
; 1513 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1514 : 		return (replace(
; 1515 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1516 : 		}
; 1517 : 
; 1518 : 	template<class _Iter>
; 1519 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1520 : 			_Myt&>::type
; 1521 : 		replace(const_iterator _First, const_iterator _Last,
; 1522 : 			_Iter _First2, _Iter _Last2)
; 1523 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1524 : 		_Myt _Right(_First2, _Last2);
; 1525 : 		replace(_First, _Last, _Right);
; 1526 : 		return (*this);
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const_pointer _First2, const_pointer _Last2)
; 1531 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1532 : 		if (_First2 == _Last2)
; 1533 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1534 : 		else
; 1535 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1536 : 				&*_First2, _Last2 - _First2);
; 1537 : 		return (*this);
; 1538 : 		}
; 1539 : 
; 1540 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1541 : 		pointer _First2, pointer _Last2)
; 1542 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1543 : 		if (_First2 == _Last2)
; 1544 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1545 : 		else
; 1546 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1547 : 				&*_First2, _Last2 - _First2);
; 1548 : 		return (*this);
; 1549 : 		}
; 1550 : 
; 1551 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1552 : 		const_iterator _First2, const_iterator _Last2)
; 1553 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1554 : 		if (_First2 == _Last2)
; 1555 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1556 : 		else
; 1557 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1558 : 				&*_First2, _Last2 - _First2);
; 1559 : 		return (*this);
; 1560 : 		}
; 1561 : 
; 1562 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1563 : 		iterator _First2, iterator _Last2)
; 1564 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1565 : 		if (_First2 == _Last2)
; 1566 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1567 : 		else
; 1568 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1569 : 				&*_First2, _Last2 - _First2);
; 1570 : 		return (*this);
; 1571 : 		}
; 1572 : 
; 1573 : 	iterator begin() _NOEXCEPT
; 1574 : 		{	// return iterator for beginning of mutable sequence
; 1575 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1576 : 		}
; 1577 : 
; 1578 : 	const_iterator begin() const _NOEXCEPT
; 1579 : 		{	// return iterator for beginning of nonmutable sequence
; 1580 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1581 : 		}
; 1582 : 
; 1583 : 	iterator end() _NOEXCEPT
; 1584 : 		{	// return iterator for end of mutable sequence
; 1585 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1586 : 		}
; 1587 : 
; 1588 : 	const_iterator end() const _NOEXCEPT
; 1589 : 		{	// return iterator for end of nonmutable sequence
; 1590 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1591 : 		}
; 1592 : 
; 1593 : 	reverse_iterator rbegin() _NOEXCEPT
; 1594 : 		{	// return iterator for beginning of reversed mutable sequence
; 1595 : 		return (reverse_iterator(end()));
; 1596 : 		}
; 1597 : 
; 1598 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1600 : 		return (const_reverse_iterator(end()));
; 1601 : 		}
; 1602 : 
; 1603 : 	reverse_iterator rend() _NOEXCEPT
; 1604 : 		{	// return iterator for end of reversed mutable sequence
; 1605 : 		return (reverse_iterator(begin()));
; 1606 : 		}
; 1607 : 
; 1608 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1609 : 		{	// return iterator for end of reversed nonmutable sequence
; 1610 : 		return (const_reverse_iterator(begin()));
; 1611 : 		}
; 1612 : 
; 1613 :  #if _HAS_CPP0X
; 1614 : 	const_iterator cbegin() const _NOEXCEPT
; 1615 : 		{	// return iterator for beginning of nonmutable sequence
; 1616 : 		return (((const _Myt *)this)->begin());
; 1617 : 		}
; 1618 : 
; 1619 : 	const_iterator cend() const _NOEXCEPT
; 1620 : 		{	// return iterator for end of nonmutable sequence
; 1621 : 		return (((const _Myt *)this)->end());
; 1622 : 		}
; 1623 : 
; 1624 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1625 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1626 : 		return (((const _Myt *)this)->rbegin());
; 1627 : 		}
; 1628 : 
; 1629 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1630 : 		{	// return iterator for end of reversed nonmutable sequence
; 1631 : 		return (((const _Myt *)this)->rend());
; 1632 : 		}
; 1633 : 
; 1634 : 	void shrink_to_fit()
; 1635 : 		{	// reduce capacity
; 1636 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1637 : 			{	// worth shrinking, do it
; 1638 : 			_Myt _Tmp(*this);
; 1639 : 			swap(_Tmp);
; 1640 : 			}
; 1641 : 		}
; 1642 :  #endif /* _HAS_CPP0X */
; 1643 : 
; 1644 : 	reference at(size_type _Off)
; 1645 : 		{	// subscript mutable sequence with checking
; 1646 : 		if (this->_Mysize <= _Off)
; 1647 : 			_Xran();	// _Off off end
; 1648 : 		return (this->_Myptr()[_Off]);
; 1649 : 		}
; 1650 : 
; 1651 : 	const_reference at(size_type _Off) const
; 1652 : 		{	// subscript nonmutable sequence with checking
; 1653 : 		if (this->_Mysize <= _Off)
; 1654 : 			_Xran();	// _Off off end
; 1655 : 		return (this->_Myptr()[_Off]);
; 1656 : 		}
; 1657 : 
; 1658 : 	reference operator[](size_type _Off)
; 1659 : 		{	// subscript mutable sequence
; 1660 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1661 : 		if (this->_Mysize < _Off)	// sic
; 1662 : 			_DEBUG_ERROR("string subscript out of range");
; 1663 : 
; 1664 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1665 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1666 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1667 : 
; 1668 : 		return (this->_Myptr()[_Off]);
; 1669 : 		}
; 1670 : 
; 1671 : 	const_reference operator[](size_type _Off) const
; 1672 : 		{	// subscript nonmutable sequence
; 1673 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1674 : 		if (this->_Mysize < _Off)	// sic
; 1675 : 			_DEBUG_ERROR("string subscript out of range");
; 1676 : 
; 1677 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1678 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1679 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1680 : 
; 1681 : 		return (this->_Myptr()[_Off]);
; 1682 : 		}
; 1683 : 
; 1684 : 	void push_back(_Elem _Ch)
; 1685 : 		{	// insert element at end
; 1686 : 		insert(end(), _Ch);
; 1687 : 		}
; 1688 : 
; 1689 :  #if _HAS_CPP0X
; 1690 : 	void pop_back()
; 1691 : 		{	// erase element at end
; 1692 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1693 : 		}
; 1694 : 
; 1695 : 	reference front()
; 1696 : 		{	// return first element of mutable sequence
; 1697 : 		return (*begin());
; 1698 : 		}
; 1699 : 
; 1700 : 	const_reference front() const
; 1701 : 		{	// return first element of nonmutable sequence
; 1702 : 		return (*begin());
; 1703 : 		}
; 1704 : 
; 1705 : 	reference back()
; 1706 : 		{	// return last element of mutable sequence
; 1707 : 		return (*(end() - 1));
; 1708 : 		}
; 1709 : 
; 1710 : 	const_reference back() const
; 1711 : 		{	// return last element of nonmutable sequence
; 1712 : 		return (*(end() - 1));
; 1713 : 		}
; 1714 :  #endif /* _HAS_CPP0X */
; 1715 : 
; 1716 : 	const _Elem *c_str() const _NOEXCEPT
; 1717 : 		{	// return pointer to null-terminated nonmutable array
; 1718 : 		return (this->_Myptr());
; 1719 : 		}
; 1720 : 
; 1721 : 	const _Elem *data() const _NOEXCEPT
; 1722 : 		{	// return pointer to nonmutable array
; 1723 : 		return (c_str());
; 1724 : 		}
; 1725 : 
; 1726 : 	size_type length() const _NOEXCEPT
; 1727 : 		{	// return length of sequence
; 1728 : 		return (this->_Mysize);
; 1729 : 		}
; 1730 : 
; 1731 : 	size_type size() const _NOEXCEPT
; 1732 : 		{	// return length of sequence
; 1733 : 		return (this->_Mysize);
; 1734 : 		}
; 1735 : 
; 1736 : 	size_type max_size() const _NOEXCEPT
; 1737 : 		{	// return maximum possible length of sequence
; 1738 : 		size_type _Num = this->_Getal().max_size();
; 1739 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1740 : 		}
; 1741 : 
; 1742 : 	void resize(size_type _Newsize)
; 1743 : 		{	// determine new length, padding with null elements as needed
; 1744 : 		resize(_Newsize, _Elem());
; 1745 : 		}
; 1746 : 
; 1747 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1748 : 		{	// determine new length, padding with _Ch elements as needed
; 1749 : 		if (_Newsize <= this->_Mysize)
; 1750 : 			_Eos(_Newsize);
; 1751 : 		else
; 1752 : 			append(_Newsize - this->_Mysize, _Ch);
; 1753 : 		}
; 1754 : 
; 1755 : 	size_type capacity() const _NOEXCEPT
; 1756 : 		{	// return current length of allocated storage
; 1757 : 		return (this->_Myres);
; 1758 : 		}
; 1759 : 
; 1760 : 	void reserve(size_type _Newcap = 0)
; 1761 : 		{	// determine new minimum length of allocated storage
; 1762 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1763 : 			{	// change reservation
; 1764 : 			size_type _Size = this->_Mysize;
; 1765 : 			if (_Grow(_Newcap, true))
; 1766 : 				_Eos(_Size);
; 1767 : 			}
; 1768 : 		}
; 1769 : 
; 1770 : 	bool empty() const _NOEXCEPT
; 1771 : 		{	// test if sequence is empty
; 1772 : 		return (this->_Mysize == 0);
; 1773 : 		}
; 1774 : 
; 1775 : 	_SCL_INSECURE_DEPRECATE
; 1776 : 
; 1777 : 	size_type copy(_Elem *_Ptr,
; 1778 : 		size_type _Count, size_type _Off = 0) const
; 1779 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1780 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1781 : 		if (_Count != 0)
; 1782 : 			_DEBUG_POINTER(_Ptr);
; 1783 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1784 : 
; 1785 : 		if (this->_Mysize < _Off)
; 1786 : 			_Xran();	// _Off off end
; 1787 : 		if (this->_Mysize - _Off < _Count)
; 1788 : 			_Count = this->_Mysize - _Off;
; 1789 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1790 : 		return (_Count);
; 1791 : 		}
; 1792 : 
; 1793 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1794 : 		size_type _Count, size_type _Off = 0) const
; 1795 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1796 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1797 : 		if (_Count != 0)
; 1798 : 			_DEBUG_POINTER(_Dest);
; 1799 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1800 : 
; 1801 : 		if (this->_Mysize < _Off)
; 1802 : 			_Xran();	// _Off off end
; 1803 : 		if (this->_Mysize - _Off < _Count)
; 1804 : 			_Count = this->_Mysize - _Off;
; 1805 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1806 : 		return (_Count);
; 1807 : 		}
; 1808 : 
; 1809 : 	void _Swap_bx(_Myt& _Right)
; 1810 : 		{	// exchange _Bx with _Right._Bx
; 1811 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1812 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1813 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1814 : 			else
; 1815 : 				{	// swap large with small
; 1816 : 				pointer _Ptr = this->_Bx._Ptr;
; 1817 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1818 : 				_Traits::copy(this->_Bx._Buf,
; 1819 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1820 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1821 : 				}
; 1822 : 		else
; 1823 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1824 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1825 : 			else
; 1826 : 				{	// swap small with large
; 1827 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1828 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1829 : 				_Traits::copy(_Right._Bx._Buf,
; 1830 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1831 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1832 : 				}
; 1833 : 		}
; 1834 : 
; 1835 : 	void swap(_Myt& _Right)
; 1836 : 		{	// exchange contents with _Right
; 1837 : 		if (this == &_Right)
; 1838 : 			;	// same object, do nothing
; 1839 : 		else if (this->_Getal() == _Right._Getal())
; 1840 : 			{	// same allocator, swap control information
; 1841 : 			this->_Swap_all(_Right);
; 1842 : 			_Swap_bx(_Right);
; 1843 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1844 : 			_STD swap(this->_Myres, _Right._Myres);
; 1845 : 			}
; 1846 : 
; 1847 :  #if _HAS_CPP0X
; 1848 : 		else if (_Alty::propagate_on_container_swap::value)
; 1849 : 			{	// swap allocators and control information
; 1850 : 			this->_Swap_alloc(_Right);
; 1851 : 			_Swap_bx(_Right);
; 1852 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1853 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1854 : 			_STD swap(this->_Myres, _Right._Myres);
; 1855 : 			}
; 1856 :  #endif /* _HAS_CPP0X */
; 1857 : 
; 1858 : 		else
; 1859 : 			{	// different allocator, do multiple assigns
; 1860 : 			_Myt _Tmp = *this;
; 1861 : 
; 1862 : 			*this = _Right;
; 1863 : 			_Right = _Tmp;
; 1864 : 			}
; 1865 : 		}
; 1866 : 
; 1867 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1868 : 		{	// look for _Right beginning at or after _Off
; 1869 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1870 : 		}
; 1871 : 
; 1872 : 	size_type find(const _Elem *_Ptr,
; 1873 : 		size_type _Off, size_type _Count) const
; 1874 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1875 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1876 : 		if (_Count != 0)
; 1877 : 			_DEBUG_POINTER(_Ptr);
; 1878 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1879 : 
; 1880 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1881 : 			return (_Off);	// null string always matches (if inside string)
; 1882 : 
; 1883 : 		size_type _Nm;
; 1884 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1885 : 			{	// room for match, look for it
; 1886 : 			const _Elem *_Uptr, *_Vptr;
; 1887 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1888 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1889 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1890 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1891 : 					return (_Uptr - this->_Myptr());	// found a match
; 1892 : 			}
; 1893 : 
; 1894 : 		return (npos);	// no match
; 1895 : 		}
; 1896 : 
; 1897 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1898 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1899 : 		_DEBUG_POINTER(_Ptr);
; 1900 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1901 : 		}
; 1902 : 
; 1903 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1904 : 		{	// look for _Ch at or after _Off
; 1905 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1906 : 		}
; 1907 : 
; 1908 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1909 : 		{	// look for _Right beginning before _Off
; 1910 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1911 : 		}
; 1912 : 
; 1913 : 	size_type rfind(const _Elem *_Ptr,
; 1914 : 		size_type _Off, size_type _Count) const
; 1915 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1916 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1917 : 		if (_Count != 0)
; 1918 : 			_DEBUG_POINTER(_Ptr);
; 1919 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1920 : 
; 1921 : 		if (_Count == 0)
; 1922 : 			return (_Off < this->_Mysize ? _Off
; 1923 : 				: this->_Mysize);	// null always matches
; 1924 : 		if (_Count <= this->_Mysize)
; 1925 : 			{	// room for match, look for it
; 1926 : 			const _Elem *_Uptr = this->_Myptr() +
; 1927 : 				(_Off < this->_Mysize - _Count ? _Off
; 1928 : 					: this->_Mysize - _Count);
; 1929 : 			for (; ; --_Uptr)
; 1930 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1931 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1932 : 					return (_Uptr - this->_Myptr());	// found a match
; 1933 : 				else if (_Uptr == this->_Myptr())
; 1934 : 					break;	// at beginning, no more chance for match
; 1935 : 			}
; 1936 : 
; 1937 : 		return (npos);	// no match
; 1938 : 		}
; 1939 : 
; 1940 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1941 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1942 : 		_DEBUG_POINTER(_Ptr);
; 1943 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1944 : 		}
; 1945 : 
; 1946 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1947 : 		{	// look for _Ch before _Off
; 1948 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1949 : 		}
; 1950 : 
; 1951 : 	size_type find_first_of(const _Myt& _Right,
; 1952 : 		size_type _Off = 0) const _NOEXCEPT
; 1953 : 		{	// look for one of _Right at or after _Off
; 1954 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1955 : 		}
; 1956 : 
; 1957 : 	size_type find_first_of(const _Elem *_Ptr,
; 1958 : 		size_type _Off, size_type _Count) const
; 1959 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1960 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1961 : 		if (_Count != 0)
; 1962 : 			_DEBUG_POINTER(_Ptr);
; 1963 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1964 : 
; 1965 : 		if (0 < _Count && _Off < this->_Mysize)
; 1966 : 			{	// room for match, look for it
; 1967 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1968 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1969 : 				_Uptr < _Vptr; ++_Uptr)
; 1970 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1971 : 					return (_Uptr - this->_Myptr());	// found a match
; 1972 : 			}
; 1973 : 
; 1974 : 		return (npos);	// no match
; 1975 : 		}
; 1976 : 
; 1977 : 	size_type find_first_of(const _Elem *_Ptr,
; 1978 : 		size_type _Off = 0) const
; 1979 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1980 : 		_DEBUG_POINTER(_Ptr);
; 1981 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 1982 : 		}
; 1983 : 
; 1984 : 	size_type find_first_of(_Elem _Ch,
; 1985 : 		size_type _Off = 0) const
; 1986 : 		{	// look for _Ch at or after _Off
; 1987 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1988 : 		}
; 1989 : 
; 1990 : 	size_type find_last_of(const _Myt& _Right,
; 1991 : 		size_type _Off = npos) const _NOEXCEPT
; 1992 : 		{	// look for one of _Right before _Off
; 1993 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_last_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off, size_type _Count) const
; 1998 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 1999 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2000 : 		if (_Count != 0)
; 2001 : 			_DEBUG_POINTER(_Ptr);
; 2002 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2003 : 
; 2004 : 		if (0 < _Count && 0 < this->_Mysize)
; 2005 : 			{	// worth searching, do it
; 2006 : 			const _Elem *_Uptr = this->_Myptr()
; 2007 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2008 : 			for (; ; --_Uptr)
; 2009 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2010 : 					return (_Uptr - this->_Myptr());	// found a match
; 2011 : 				else if (_Uptr == this->_Myptr())
; 2012 : 					break;	// at beginning, no more chance for match
; 2013 : 			}
; 2014 : 
; 2015 : 		return (npos);	// no match
; 2016 : 		}
; 2017 : 
; 2018 : 	size_type find_last_of(const _Elem *_Ptr,
; 2019 : 		size_type _Off = npos) const
; 2020 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2021 : 		_DEBUG_POINTER(_Ptr);
; 2022 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2023 : 		}
; 2024 : 
; 2025 : 	size_type find_last_of(_Elem _Ch,
; 2026 : 		size_type _Off = npos) const
; 2027 : 		{	// look for _Ch before _Off
; 2028 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2029 : 		}
; 2030 : 
; 2031 : 	size_type find_first_not_of(const _Myt& _Right,
; 2032 : 		size_type _Off = 0) const _NOEXCEPT
; 2033 : 		{	// look for none of _Right at or after _Off
; 2034 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2035 : 			_Right.size()));
; 2036 : 		}
; 2037 : 
; 2038 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2039 : 		size_type _Off, size_type _Count) const
; 2040 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2041 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2042 : 		if (_Count != 0)
; 2043 : 			_DEBUG_POINTER(_Ptr);
; 2044 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2045 : 
; 2046 : 		if (_Off < this->_Mysize)
; 2047 : 			{	// room for match, look for it
; 2048 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2049 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2050 : 				_Uptr < _Vptr; ++_Uptr)
; 2051 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2052 : 					return (_Uptr - this->_Myptr());
; 2053 : 			}
; 2054 : 		return (npos);
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off = 0) const
; 2059 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2060 : 		_DEBUG_POINTER(_Ptr);
; 2061 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2062 : 		}
; 2063 : 
; 2064 : 	size_type find_first_not_of(_Elem _Ch,
; 2065 : 		size_type _Off = 0) const
; 2066 : 		{	// look for non _Ch at or after _Off
; 2067 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2068 : 		}
; 2069 : 
; 2070 : 	size_type find_last_not_of(const _Myt& _Right,
; 2071 : 		size_type _Off = npos) const _NOEXCEPT
; 2072 : 		{	// look for none of _Right before _Off
; 2073 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off, size_type _Count) const
; 2078 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2079 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2080 : 		if (_Count != 0)
; 2081 : 			_DEBUG_POINTER(_Ptr);
; 2082 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2083 : 
; 2084 : 		if (0 < this->_Mysize)
; 2085 : 			{	// worth searching, do it
; 2086 : 			const _Elem *_Uptr = this->_Myptr()
; 2087 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2088 : 			for (; ; --_Uptr)
; 2089 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2090 : 					return (_Uptr - this->_Myptr());
; 2091 : 				else if (_Uptr == this->_Myptr())
; 2092 : 					break;
; 2093 : 			}
; 2094 : 		return (npos);
; 2095 : 		}
; 2096 : 
; 2097 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2098 : 		size_type _Off = npos) const
; 2099 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2100 : 		_DEBUG_POINTER(_Ptr);
; 2101 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2102 : 		}
; 2103 : 
; 2104 : 	size_type find_last_not_of(_Elem _Ch,
; 2105 : 		size_type _Off = npos) const
; 2106 : 		{	// look for non _Ch before _Off
; 2107 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2108 : 		}
; 2109 : 
; 2110 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2111 : 		{	// return [_Off, _Off + _Count) as new string
; 2112 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2113 : 		}
; 2114 : 
; 2115 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2116 : 		{	// compare [0, _Mysize) with _Right
; 2117 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2118 : 		}
; 2119 : 
; 2120 : 	int compare(size_type _Off, size_type _N0,
; 2121 : 		const _Myt& _Right) const
; 2122 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2123 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2124 : 		}
; 2125 : 
; 2126 : 	int compare(size_type _Off,
; 2127 : 		size_type _N0, const _Myt& _Right,
; 2128 : 		size_type _Roff, size_type _Count) const
; 2129 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2130 : 		if (_Right.size() < _Roff)
; 2131 : 			_Xran();	// _Off off end
; 2132 : 		if (_Right._Mysize - _Roff < _Count)
; 2133 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2134 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2135 : 		}
; 2136 : 
; 2137 : 	int compare(const _Elem *_Ptr) const
; 2138 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2139 : 		_DEBUG_POINTER(_Ptr);
; 2140 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2141 : 		}
; 2142 : 
; 2143 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2144 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2145 : 		_DEBUG_POINTER(_Ptr);
; 2146 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2147 : 		}
; 2148 : 
; 2149 : 	int compare(size_type _Off,
; 2150 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2151 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2152 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2153 : 		if (_Count != 0)
; 2154 : 			_DEBUG_POINTER(_Ptr);
; 2155 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2156 : 
; 2157 : 		if (this->_Mysize < _Off)
; 2158 : 			_Xran();	// _Off off end
; 2159 : 		if (this->_Mysize - _Off < _N0)
; 2160 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2161 : 
; 2162 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2163 : 			_N0 < _Count ? _N0 : _Count);
; 2164 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2165 : 			: _N0 == _Count ? 0 : +1);
; 2166 : 		}
; 2167 : 
; 2168 : 	allocator_type get_allocator() const _NOEXCEPT
; 2169 : 		{	// return allocator object for values
; 2170 : 		return (this->_Getal());
; 2171 : 		}
; 2172 : 
; 2173 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2174 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2175 : 		if (_Count == 1)
; 2176 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2177 : 		else
; 2178 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2179 : 		}
; 2180 : 
; 2181 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2182 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2183 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2184 : 		if (max_size() < _Newres)
; 2185 : 			_Newres = _Newsize;	// undo roundup if too big
; 2186 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2187 : 			;
; 2188 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2189 : 			_Newres = this->_Myres
; 2190 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2191 : 		else
; 2192 : 			_Newres = max_size();	// settle for max_size()
; 2193 : 
; 2194 : 		_Elem *_Ptr;
; 2195 : 		_TRY_BEGIN
; 2196 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2197 : 		_CATCH_ALL
; 2198 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2199 : 			_TRY_BEGIN
; 2200 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2201 : 			_CATCH_ALL
; 2202 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2203 : 			_RERAISE;
; 2204 : 			_CATCH_END
; 2205 : 		_CATCH_END
; 2206 : 
; 2207 : 		if (0 < _Oldlen)
; 2208 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2209 : 				_Oldlen);	// copy existing elements
; 2210 : 		_Tidy(true);
; 2211 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2212 : 		this->_Myres = _Newres;
; 2213 : 		_Eos(_Oldlen);
; 2214 : 		}
; 2215 : 
; 2216 : 	void _Eos(size_type _Newsize)
; 2217 : 		{	// set new length and null terminator
; 2218 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  0071e	48 89 7d d7	 mov	 QWORD PTR $T15[rbp-105], rdi
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd

; 347  : 		_Left = _Right;

  00722	66 89 7d c7	 mov	 WORD PTR $T15[rbp-121], di
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 735  : 		assign(_Right, 0, npos);

  00726	49 83 c9 ff	 or	 r9, -1
  0072a	45 33 c0	 xor	 r8d, r8d
  0072d	48 8d 55 ef	 lea	 rdx, QWORD PTR filePath$[rbp-121]
  00731	48 8d 4d c7	 lea	 rcx, QWORD PTR $T15[rbp-121]
  00735	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@AEBV12@_K1@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp

; 262  : 	normalFShader = new gfxu::FragmentShader(filePath);

  0073a	48 8d 55 c7	 lea	 rdx, QWORD PTR $T15[rbp-121]
  0073e	48 8b cb	 mov	 rcx, rbx
  00741	e8 00 00 00 00	 call	 ??0FragmentShader@gfxu@@QEAA@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z ; gfxu::FragmentShader::FragmentShader
  00746	eb 03		 jmp	 SHORT $LN17@preStart
$LN16@preStart:
  00748	48 8b c7	 mov	 rax, rdi
$LN17@preStart:
  0074b	48 89 05 00 00
	00 00		 mov	 QWORD PTR ?normalFShader@@3PEAVFragmentShader@gfxu@@EA, rax ; normalFShader

; 264  : 	normalShaderProgram = new gfxu::ShaderProgram(normalVShader, nullptr, normalFShader);

  00752	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  00757	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  0075c	48 8b d8	 mov	 rbx, rax
  0075f	48 89 45 b7	 mov	 QWORD PTR $T7[rbp-121], rax
  00763	48 85 c0	 test	 rax, rax
  00766	74 27		 je	 SHORT $LN18@preStart
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp

; 379  : {

  00768	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?normalVShader@@3PEAVVertexShader@gfxu@@EA ; normalVShader
  0076f	48 89 08	 mov	 QWORD PTR [rax], rcx
  00772	48 89 78 08	 mov	 QWORD PTR [rax+8], rdi
  00776	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?normalFShader@@3PEAVFragmentShader@gfxu@@EA ; normalFShader
  0077d	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx
  00781	c6 40 1c 00	 mov	 BYTE PTR [rax+28], 0

; 380  : 	create();

  00785	48 8b c8	 mov	 rcx, rax
  00788	e8 00 00 00 00	 call	 ?create@ShaderProgram@gfxu@@AEAA_NXZ ; gfxu::ShaderProgram::create
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp

; 264  : 	normalShaderProgram = new gfxu::ShaderProgram(normalVShader, nullptr, normalFShader);

  0078d	eb 03		 jmp	 SHORT $LN19@preStart
$LN18@preStart:
  0078f	48 8b df	 mov	 rbx, rdi
$LN19@preStart:
  00792	48 89 1d 00 00
	00 00		 mov	 QWORD PTR ?normalShaderProgram@@3PEAVShaderProgram@gfxu@@EA, rbx ; normalShaderProgram
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 1099 : 		return (assign(_Right, 0, npos));

  00799	49 83 c9 ff	 or	 r9, -1
  0079d	45 33 c0	 xor	 r8d, r8d
  007a0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?EXE_DIR@IOUtil@@3V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@A ; IOUtil::EXE_DIR
  007a7	48 8d 4d ef	 lea	 rcx, QWORD PTR filePath$[rbp-121]
  007ab	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@AEBV12@_K1@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign

; 736  : 		}
; 737  : 
; 738  :  #if _HAS_CPP0X
; 739  : 	basic_string(const _Myt& _Right, const _Alloc& _Al)
; 740  : 		: _Mybase(_Al)
; 741  : 		{	// construct by copying with allocator
; 742  : 		_Tidy();
; 743  : 		assign(_Right, 0, npos);
; 744  : 		}
; 745  :  #endif /* _HAS_CPP0X */
; 746  : 
; 747  : 	basic_string()
; 748  : 		: _Mybase()
; 749  : 		{	// construct empty string
; 750  : 		_Tidy();
; 751  : 		}
; 752  : 
; 753  : 	explicit basic_string(const _Alloc& _Al)
; 754  : 		: _Mybase(_Al)
; 755  : 		{	// construct empty string with allocator
; 756  : 		_Tidy();
; 757  : 		}
; 758  : 
; 759  : 	basic_string(const _Myt& _Right, size_type _Roff,
; 760  : 		size_type _Count = npos)
; 761  : 		: _Mybase(_Right._Getal())
; 762  : 		{	// construct from _Right [_Roff, _Roff + _Count)
; 763  : 		_Tidy();
; 764  : 		assign(_Right, _Roff, _Count);
; 765  : 		}
; 766  : 
; 767  : 	basic_string(const _Myt& _Right, size_type _Roff, size_type _Count,
; 768  : 		const _Alloc& _Al)
; 769  : 		: _Mybase(_Al)
; 770  : 		{	// construct from _Right [_Roff, _Roff + _Count) with allocator
; 771  : 		_Tidy();
; 772  : 		assign(_Right, _Roff, _Count);
; 773  : 		}
; 774  : 
; 775  : 	basic_string(const _Elem *_Ptr, size_type _Count)
; 776  : 		: _Mybase()
; 777  : 		{	// construct from [_Ptr, _Ptr + _Count)
; 778  : 		_Tidy();
; 779  : 		assign(_Ptr, _Count);
; 780  : 		}
; 781  : 
; 782  : 	basic_string(const _Elem *_Ptr, size_type _Count, const _Alloc& _Al)
; 783  : 		: _Mybase(_Al)
; 784  : 		{	// construct from [_Ptr, _Ptr + _Count) with allocator
; 785  : 		_Tidy();
; 786  : 		assign(_Ptr, _Count);
; 787  : 		}
; 788  : 
; 789  : 	basic_string(const _Elem *_Ptr)
; 790  : 		: _Mybase()
; 791  : 		{	// construct from [_Ptr, <null>)
; 792  : 		_Tidy();
; 793  : 		assign(_Ptr);
; 794  : 		}
; 795  : 
; 796  : 	basic_string(const _Elem *_Ptr, const _Alloc& _Al)
; 797  : 		: _Mybase(_Al)
; 798  : 		{	// construct from [_Ptr, <null>) with allocator
; 799  : 		_Tidy();
; 800  : 		assign(_Ptr);
; 801  : 		}
; 802  : 
; 803  : 	basic_string(size_type _Count, _Elem _Ch)
; 804  : 		: _Mybase()
; 805  : 		{	// construct from _Count * _Ch
; 806  : 		_Tidy();
; 807  : 		assign(_Count, _Ch);
; 808  : 		}
; 809  : 
; 810  : 	basic_string(size_type _Count, _Elem _Ch, const _Alloc& _Al)
; 811  : 		: _Mybase(_Al)
; 812  : 		{	// construct from _Count * _Ch with allocator
; 813  : 		_Tidy();
; 814  : 		assign(_Count, _Ch);
; 815  : 		}
; 816  : 
; 817  : 	template<class _Iter>
; 818  : 		basic_string(_Iter _First, _Iter _Last,
; 819  : 			typename enable_if<_Is_iterator<_Iter>::value,
; 820  : 				void>::type ** = 0)
; 821  : 		: _Mybase()
; 822  : 		{	// construct from [_First, _Last)
; 823  : 		_Tidy();
; 824  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 825  : 		}
; 826  : 
; 827  : 	template<class _Iter>
; 828  : 		basic_string(_Iter _First, _Iter _Last, const _Alloc& _Al,
; 829  : 			typename enable_if<_Is_iterator<_Iter>::value,
; 830  : 				void>::type ** = 0)
; 831  : 		: _Mybase(_Al)
; 832  : 		{	// construct from [_First, _Last) with allocator
; 833  : 		_Tidy();
; 834  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 835  : 		}
; 836  : 
; 837  : 	template<class _Iter>
; 838  : 		void _Construct(_Iter _First,
; 839  : 			_Iter _Last, input_iterator_tag)
; 840  : 		{	// initialize from [_First, _Last), input iterators
; 841  : 		_TRY_BEGIN
; 842  : 		for (; _First != _Last; ++_First)
; 843  : 			append((size_type)1, (_Elem)*_First);
; 844  : 		_CATCH_ALL
; 845  : 		_Tidy(true);
; 846  : 		_RERAISE;
; 847  : 		_CATCH_END
; 848  : 		}
; 849  : 
; 850  : 	template<class _Iter>
; 851  : 		void _Construct(_Iter _First,
; 852  : 			_Iter _Last, forward_iterator_tag)
; 853  : 		{	// initialize from [_First, _Last), forward iterators
; 854  : 		_DEBUG_RANGE(_First, _Last);
; 855  : 		size_type _Count = 0;
; 856  : 		_Distance(_First, _Last, _Count);
; 857  : 		reserve(_Count);
; 858  : 
; 859  : 		_TRY_BEGIN
; 860  : 		for (; _First != _Last; ++_First)
; 861  : 			append((size_type)1, (_Elem)*_First);
; 862  : 		_CATCH_ALL
; 863  : 		_Tidy(true);
; 864  : 		_RERAISE;
; 865  : 		_CATCH_END
; 866  : 		}
; 867  : 
; 868  : 	basic_string(const_pointer _First, const_pointer _Last)
; 869  : 		: _Mybase()
; 870  : 		{	// construct from [_First, _Last), const pointers
; 871  : 		_DEBUG_RANGE(_First, _Last);
; 872  : 		_Tidy();
; 873  : 		if (_First != _Last)
; 874  : 			assign(&*_First, _Last - _First);
; 875  : 		}
; 876  : 
; 877  : 	basic_string(const_pointer _First, const_pointer _Last,
; 878  : 		const _Alloc& _Al)
; 879  : 		: _Mybase(_Al)
; 880  : 		{	// construct from [_First, _Last), const pointers
; 881  : 		_DEBUG_RANGE(_First, _Last);
; 882  : 		_Tidy();
; 883  : 		if (_First != _Last)
; 884  : 			assign(&*_First, _Last - _First);
; 885  : 		}
; 886  : 
; 887  : 	basic_string(const_iterator _First, const_iterator _Last)
; 888  : 		: _Mybase()
; 889  : 		{	// construct from [_First, _Last), const_iterators
; 890  : 		_DEBUG_RANGE(_First, _Last);
; 891  : 		_Tidy();
; 892  : 		if (_First != _Last)
; 893  : 			assign(&*_First, _Last - _First);
; 894  : 		}
; 895  : 
; 896  : 	basic_string(_Myt&& _Right) _NOEXCEPT
; 897  : 		: _Mybase(_Right._Getal())
; 898  : 		{	// construct by moving _Right
; 899  : 		_Tidy();
; 900  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 901  : 		}
; 902  : 
; 903  : 	basic_string(_Myt&& _Right, const _Alloc& _Al)
; 904  : 		: _Mybase(_Al)
; 905  : 		{	// construct by moving _Right, allocator
; 906  : 		if (this->_Getal() != _Right._Getal())
; 907  : 			assign(_Right.begin(), _Right.end());
; 908  : 		else
; 909  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 910  : 		}
; 911  : 
; 912  : 	_Myt& operator=(_Myt&& _Right) _NOEXCEPT
; 913  : 		{	// assign by moving _Right
; 914  : 		if (this != &_Right)
; 915  : 			{	// different, assign it
; 916  : 			_Tidy(true);
; 917  : 
; 918  :  #if _HAS_CPP0X
; 919  : 			if (this->_Getal() != _Right._Getal()
; 920  : 				&& _Alty::propagate_on_container_move_assignment::value)
; 921  : 				this->_Change_alloc(_Right._Getal());
; 922  :  #endif /* _HAS_CPP0X */
; 923  : 
; 924  : 			if (this->_Getal() != _Right._Getal())
; 925  : 				assign(_Right.begin(), _Right.end());
; 926  : 			else
; 927  : 				_Assign_rv(_STD forward<_Myt>(_Right));
; 928  : 			}
; 929  : 		return (*this);
; 930  : 		}
; 931  : 
; 932  : 	_Myt& assign(_Myt&& _Right) _NOEXCEPT
; 933  : 		{	// assign by moving _Right
; 934  : 		if (this == &_Right)
; 935  : 			;
; 936  : 		else if (get_allocator() != _Right.get_allocator()
; 937  : 			&& this->_BUF_SIZE <= _Right._Myres)
; 938  : 			*this = _Right;
; 939  : 		else
; 940  : 			{	// not same, clear this and steal from _Right
; 941  : 			_Tidy(true);
; 942  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 943  : 			}
; 944  : 		return (*this);
; 945  : 		}
; 946  : 
; 947  : 	void _Assign_rv(_Myt&& _Right)
; 948  : 		{	// assign by moving _Right
; 949  : 		if (_Right._Myres < this->_BUF_SIZE)
; 950  : 			_Traits::move(this->_Bx._Buf, _Right._Bx._Buf,
; 951  : 				_Right._Mysize + 1);
; 952  : 		else
; 953  : 			{	// copy pointer
; 954  : 			this->_Getal().construct(&this->_Bx._Ptr, _Right._Bx._Ptr);
; 955  : 			_Right._Bx._Ptr = pointer();
; 956  : 			}
; 957  : 		this->_Mysize = _Right._Mysize;
; 958  : 		this->_Myres = _Right._Myres;
; 959  : 		_Right._Tidy();
; 960  : 		}
; 961  : 
; 962  : 	~basic_string() _NOEXCEPT
; 963  : 		{	// destroy the string
; 964  : 		_Tidy(true);
; 965  : 		}
; 966  : 
; 967  : 	_PGLOBAL static const size_type npos;	// bad/missing length/position
; 968  : 
; 969  : 	_Myt& operator=(const _Myt& _Right)
; 970  : 		{	// assign _Right
; 971  : 		if (this != &_Right)
; 972  : 			{	// different, assign it
; 973  :  #if _HAS_CPP0X
; 974  : 			if (this->_Getal() != _Right._Getal()
; 975  : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 976  : 				{	// change allocator before copying
; 977  : 				_Tidy(true);
; 978  : 				this->_Change_alloc(_Right._Getal());
; 979  : 				}
; 980  :  #endif /* _HAS_CPP0X */
; 981  : 
; 982  : 			assign(_Right);
; 983  : 			}
; 984  : 		return (*this);
; 985  : 		}
; 986  : 
; 987  : 	_Myt& operator=(const _Elem *_Ptr)
; 988  : 		{	// assign [_Ptr, <null>)
; 989  : 		return (assign(_Ptr));
; 990  : 		}
; 991  : 
; 992  : 	_Myt& operator=(_Elem _Ch)
; 993  : 		{	// assign 1 * _Ch
; 994  : 		return (assign(1, _Ch));
; 995  : 		}
; 996  : 
; 997  : 	_Myt& operator+=(const _Myt& _Right)
; 998  : 		{	// append _Right
; 999  : 		return (append(_Right));
; 1000 : 		}
; 1001 : 
; 1002 : 	_Myt& operator+=(const _Elem *_Ptr)
; 1003 : 		{	// append [_Ptr, <null>)
; 1004 : 		return (append(_Ptr));
; 1005 : 		}
; 1006 : 
; 1007 : 	_Myt& operator+=(_Elem _Ch)
; 1008 : 		{	// append 1 * _Ch
; 1009 : 		return (append((size_type)1, _Ch));
; 1010 : 		}
; 1011 : 
; 1012 : 	_Myt& append(const _Myt& _Right)
; 1013 : 		{	// append _Right
; 1014 : 		return (append(_Right, 0, npos));
; 1015 : 		}
; 1016 : 
; 1017 : 	_Myt& append(const _Myt& _Right,
; 1018 : 		size_type _Roff, size_type _Count)
; 1019 : 		{	// append _Right [_Roff, _Roff + _Count)
; 1020 : 		if (_Right.size() < _Roff)
; 1021 : 			_Xran();	// _Roff off end
; 1022 : 		size_type _Num = _Right.size() - _Roff;
; 1023 : 		if (_Num < _Count)
; 1024 : 			_Count = _Num;	// trim _Count to size
; 1025 : 		if (npos - this->_Mysize <= _Count)
; 1026 : 			_Xlen();	// result too long
; 1027 : 
; 1028 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1029 : 			{	// make room and append new stuff
; 1030 : 			_Traits::copy(this->_Myptr() + this->_Mysize,
; 1031 : 				_Right._Myptr() + _Roff, _Count);
; 1032 : 			_Eos(_Num);
; 1033 : 			}
; 1034 : 		return (*this);
; 1035 : 		}
; 1036 : 
; 1037 : 	_Myt& append(const _Elem *_Ptr, size_type _Count)
; 1038 : 		{	// append [_Ptr, _Ptr + _Count)
; 1039 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1040 : 		if (_Count != 0)
; 1041 : 			_DEBUG_POINTER(_Ptr);
; 1042 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1043 : 
; 1044 : 		if (_Inside(_Ptr))
; 1045 : 			return (append(*this,
; 1046 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1047 : 		if (npos - this->_Mysize <= _Count)
; 1048 : 			_Xlen();	// result too long
; 1049 : 
; 1050 : 		size_type _Num;
; 1051 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1052 : 			{	// make room and append new stuff
; 1053 : 			_Traits::copy(this->_Myptr() + this->_Mysize, _Ptr, _Count);
; 1054 : 			_Eos(_Num);
; 1055 : 			}
; 1056 : 		return (*this);
; 1057 : 		}
; 1058 : 
; 1059 : 	_Myt& append(const _Elem *_Ptr)
; 1060 : 		{	// append [_Ptr, <null>)
; 1061 : 		_DEBUG_POINTER(_Ptr);
; 1062 : 		return (append(_Ptr, _Traits::length(_Ptr)));

  007b0	41 b8 13 00 00
	00		 mov	 r8d, 19
  007b6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG4294950229
  007bd	48 8d 4d ef	 lea	 rcx, QWORD PTR filePath$[rbp-121]
  007c1	e8 00 00 00 00	 call	 ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@PEB_W_K@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp

; 268  : 	noTexVShader = new gfxu::VertexShader(filePath);

  007c6	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  007cb	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  007d0	48 8b d8	 mov	 rbx, rax
  007d3	48 89 45 b7	 mov	 QWORD PTR $T6[rbp-121], rax
  007d7	48 85 c0	 test	 rax, rax
  007da	74 32		 je	 SHORT $LN20@preStart
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 2265 : 		this->_Myres = this->_BUF_SIZE - 1;

  007dc	48 c7 45 df 07
	00 00 00	 mov	 QWORD PTR $T14[rbp-97], 7

; 1100 : 		}
; 1101 : 
; 1102 : 	_Myt& assign(const _Myt& _Right,
; 1103 : 		size_type _Roff, size_type _Count)
; 1104 : 		{	// assign _Right [_Roff, _Roff + _Count)
; 1105 : 		if (_Right.size() < _Roff)
; 1106 : 			_Xran();	// _Roff off end
; 1107 : 		size_type _Num = _Right.size() - _Roff;
; 1108 : 		if (_Count < _Num)
; 1109 : 			_Num = _Count;	// trim _Num to size
; 1110 : 
; 1111 : 		if (this == &_Right)
; 1112 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring
; 1113 : 		else if (_Grow(_Num))
; 1114 : 			{	// make room and assign new stuff
; 1115 : 			_Traits::copy(this->_Myptr(),
; 1116 : 				_Right._Myptr() + _Roff, _Num);
; 1117 : 			_Eos(_Num);
; 1118 : 			}
; 1119 : 		return (*this);
; 1120 : 		}
; 1121 : 
; 1122 : 	_Myt& assign(const _Elem *_Ptr, size_type _Count)
; 1123 : 		{	// assign [_Ptr, _Ptr + _Count)
; 1124 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1125 : 		if (_Count != 0)
; 1126 : 			_DEBUG_POINTER(_Ptr);
; 1127 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1128 : 
; 1129 : 		if (_Inside(_Ptr))
; 1130 : 			return (assign(*this,
; 1131 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1132 : 
; 1133 : 		if (_Grow(_Count))
; 1134 : 			{	// make room and assign new stuff
; 1135 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);
; 1136 : 			_Eos(_Count);
; 1137 : 			}
; 1138 : 		return (*this);
; 1139 : 		}
; 1140 : 
; 1141 : 	_Myt& assign(const _Elem *_Ptr)
; 1142 : 		{	// assign [_Ptr, <null>)
; 1143 : 		_DEBUG_POINTER(_Ptr);
; 1144 : 		return (assign(_Ptr, _Traits::length(_Ptr)));
; 1145 : 		}
; 1146 : 
; 1147 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1148 : 		{	// assign _Count * _Ch
; 1149 : 		if (_Count == npos)
; 1150 : 			_Xlen();	// result too long
; 1151 : 
; 1152 : 		if (_Grow(_Count))
; 1153 : 			{	// make room and assign new stuff
; 1154 : 			_Chassign(0, _Count, _Ch);
; 1155 : 			_Eos(_Count);
; 1156 : 			}
; 1157 : 		return (*this);
; 1158 : 		}
; 1159 : 
; 1160 : 	template<class _Iter>
; 1161 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1162 : 			_Myt&>::type
; 1163 : 		assign(_Iter _First, _Iter _Last)
; 1164 : 		{	// assign [First, _Last), input iterators
; 1165 : 		return (replace(begin(), end(), _First, _Last));
; 1166 : 		}
; 1167 : 
; 1168 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1169 : 		{	// assign [First, _Last), const pointers
; 1170 : 		return (replace(begin(), end(), _First, _Last));
; 1171 : 		}
; 1172 : 
; 1173 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1174 : 		{	// assign [First, _Last), const_iterators
; 1175 : 		return (replace(begin(), end(), _First, _Last));
; 1176 : 		}
; 1177 : 
; 1178 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1179 : 		{	// insert _Right at _Off
; 1180 : 		return (insert(_Off, _Right, 0, npos));
; 1181 : 		}
; 1182 : 
; 1183 : 	_Myt& insert(size_type _Off,
; 1184 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1185 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1186 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1187 : 			_Xran();	// _Off or _Roff off end
; 1188 : 		size_type _Num = _Right.size() - _Roff;
; 1189 : 		if (_Num < _Count)
; 1190 : 			_Count = _Num;	// trim _Count to size
; 1191 : 		if (npos - this->_Mysize <= _Count)
; 1192 : 			_Xlen();	// result too long
; 1193 : 
; 1194 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1195 : 			{	// make room and insert new stuff
; 1196 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1197 : 				this->_Myptr() + _Off,
; 1198 : 				this->_Mysize - _Off);	// empty out hole
; 1199 : 			if (this == &_Right)
; 1200 : 				_Traits::move(this->_Myptr() + _Off,
; 1201 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1202 : 						_Count);	// substring
; 1203 : 			else
; 1204 : 				_Traits::copy(this->_Myptr() + _Off,
; 1205 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1206 : 			_Eos(_Num);
; 1207 : 			}
; 1208 : 		return (*this);
; 1209 : 		}
; 1210 : 
; 1211 : 	_Myt& insert(size_type _Off,
; 1212 : 		const _Elem *_Ptr, size_type _Count)
; 1213 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1214 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1215 : 		if (_Count != 0)
; 1216 : 			_DEBUG_POINTER(_Ptr);
; 1217 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1218 : 
; 1219 : 		if (_Inside(_Ptr))
; 1220 : 			return (insert(_Off, *this,
; 1221 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1222 : 		if (this->_Mysize < _Off)
; 1223 : 			_Xran();	// _Off off end
; 1224 : 		if (npos - this->_Mysize <= _Count)
; 1225 : 			_Xlen();	// result too long
; 1226 : 		size_type _Num;
; 1227 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1228 : 			{	// make room and insert new stuff
; 1229 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1230 : 				this->_Myptr() + _Off,
; 1231 : 				this->_Mysize - _Off);	// empty out hole
; 1232 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1233 : 			_Eos(_Num);
; 1234 : 			}
; 1235 : 		return (*this);
; 1236 : 		}
; 1237 : 
; 1238 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1239 : 		{	// insert [_Ptr, <null>) at _Off
; 1240 : 		_DEBUG_POINTER(_Ptr);
; 1241 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1242 : 		}
; 1243 : 
; 1244 : 	_Myt& insert(size_type _Off,
; 1245 : 		size_type _Count, _Elem _Ch)
; 1246 : 		{	// insert _Count * _Ch at _Off
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	iterator insert(const_iterator _Where)
; 1264 : 		{	// insert <null> at _Where
; 1265 : 		return (insert(_Where, _Elem()));
; 1266 : 		}
; 1267 : 
; 1268 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1269 : 		{	// insert _Ch at _Where
; 1270 : 		size_type _Off = _Pdif(_Where, begin());
; 1271 : 		insert(_Off, 1, _Ch);
; 1272 : 		return (begin() + _Off);
; 1273 : 		}
; 1274 : 
; 1275 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1276 : 		{	// insert _Count * _Elem at _Where
; 1277 : 		size_type _Off = _Pdif(_Where, begin());
; 1278 : 		insert(_Off, _Count, _Ch);
; 1279 : 		return (begin() + _Off);
; 1280 : 		}
; 1281 : 
; 1282 : 	template<class _Iter>
; 1283 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1284 : 			iterator>::type
; 1285 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1286 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1287 : 		size_type _Off = _Pdif(_Where, begin());
; 1288 : 		replace(_Where, _Where, _First, _Last);
; 1289 : 		return (begin() + _Off);
; 1290 : 		}
; 1291 : 
; 1292 : 	iterator insert(const_iterator _Where,
; 1293 : 		const_pointer _First, const_pointer _Last)
; 1294 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		replace(_Where, _Where, _First, _Last);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where,
; 1301 : 		const_iterator _First, const_iterator _Last)
; 1302 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1303 : 		size_type _Off = _Pdif(_Where, begin());
; 1304 : 		replace(_Where, _Where, _First, _Last);
; 1305 : 		return (begin() + _Off);
; 1306 : 		}
; 1307 : 
; 1308 : 	_Myt& erase(size_type _Off = 0)
; 1309 : 		{	// erase elements [_Off, ...)
; 1310 : 		if (this->_Mysize < _Off)
; 1311 : 			_Xran();	// _Off off end
; 1312 : 		_Eos(_Off);
; 1313 : 		return (*this);
; 1314 : 		}
; 1315 : 
; 1316 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1317 : 		{	// erase elements [_Off, _Off + _Count)
; 1318 : 		if (this->_Mysize < _Off)
; 1319 : 			_Xran();	// _Off off end
; 1320 : 		if (this->_Mysize - _Off <= _Count)
; 1321 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1322 : 		else if (0 < _Count)
; 1323 : 			{	// move elements down
; 1324 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1325 : 			size_type _Newsize = this->_Mysize - _Count;
; 1326 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1327 : 			_Eos(_Newsize);
; 1328 : 			}
; 1329 : 		return (*this);
; 1330 : 		}
; 1331 : 
; 1332 : 	iterator erase(const_iterator _Where)
; 1333 : 		{	// erase element at _Where
; 1334 : 		size_type _Count = _Pdif(_Where, begin());
; 1335 : 		erase(_Count, 1);
; 1336 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1337 : 		}
; 1338 : 
; 1339 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1340 : 		{	// erase substring [_First, _Last)
; 1341 : 		_DEBUG_RANGE(_First, _Last);
; 1342 : 		size_type _Count = _Pdif(_First, begin());
; 1343 : 		erase(_Count, _Pdif(_Last, _First));
; 1344 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1345 : 		}
; 1346 : 
; 1347 : 	void clear() _NOEXCEPT
; 1348 : 		{	// erase all
; 1349 : 		_Eos(0);
; 1350 : 		}
; 1351 : 
; 1352 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1353 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1354 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1355 : 		}
; 1356 : 
; 1357 : 	_Myt& replace(size_type _Off,
; 1358 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1359 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1360 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1361 : 			_Xran();	// _Off or _Roff off end
; 1362 : 		if (this->_Mysize - _Off < _N0)
; 1363 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1364 : 		size_type _Num = _Right.size() - _Roff;
; 1365 : 		if (_Num < _Count)
; 1366 : 			_Count = _Num;	// trim _Count to size
; 1367 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1368 : 			_Xlen();	// result too long
; 1369 : 
; 1370 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1371 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1372 : 		if (this->_Mysize < _Newsize)
; 1373 : 			_Grow(_Newsize);
; 1374 : 
; 1375 : 		if (this != &_Right)
; 1376 : 			{	// no overlap, just move down and copy in new stuff
; 1377 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1378 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1379 : 			_Traits::copy(this->_Myptr() + _Off,
; 1380 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1381 : 			}
; 1382 : 		else if (_Count <= _N0)
; 1383 : 			{	// hole doesn't get larger, just copy in substring
; 1384 : 			_Traits::move(this->_Myptr() + _Off,
; 1385 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1386 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1387 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1388 : 			}
; 1389 : 		else if (_Roff <= _Off)
; 1390 : 			{	// hole gets larger, substring begins before hole
; 1391 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1392 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1393 : 			_Traits::move(this->_Myptr() + _Off,
; 1394 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1395 : 			}
; 1396 : 		else if (_Off + _N0 <= _Roff)
; 1397 : 			{	// hole gets larger, substring begins after hole
; 1398 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1399 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1400 : 			_Traits::move(this->_Myptr() + _Off,
; 1401 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1402 : 				_Count);	// fill hole
; 1403 : 			}
; 1404 : 		else
; 1405 : 			{	// hole gets larger, substring begins in hole
; 1406 : 			_Traits::move(this->_Myptr() + _Off,
; 1407 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1408 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1409 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1410 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1411 : 				this->_Myptr() + _Roff + _Count,
; 1412 : 				_Count - _N0);	// fill rest of new hole
; 1413 : 			}
; 1414 : 
; 1415 : 		_Eos(_Newsize);
; 1416 : 		return (*this);
; 1417 : 		}
; 1418 : 
; 1419 : 	_Myt& replace(size_type _Off,
; 1420 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1421 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1422 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1423 : 		if (_Count != 0)
; 1424 : 			_DEBUG_POINTER(_Ptr);
; 1425 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1426 : 
; 1427 : 		if (_Inside(_Ptr))
; 1428 : 			return (replace(_Off, _N0, *this,
; 1429 : 				_Ptr - this->_Myptr(),
; 1430 : 				_Count));	// substring, replace carefully
; 1431 : 		if (this->_Mysize < _Off)
; 1432 : 			_Xran();	// _Off off end
; 1433 : 		if (this->_Mysize - _Off < _N0)
; 1434 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1435 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1436 : 			_Xlen();	// result too long
; 1437 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1438 : 
; 1439 : 		if (_Count < _N0)
; 1440 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1441 : 				this->_Myptr() + _Off + _N0,
; 1442 : 				_Nm);	// smaller hole, move tail up
; 1443 : 		size_type _Num;
; 1444 : 		if ((0 < _Count || 0 < _N0)
; 1445 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1446 : 			{	// make room and rearrange
; 1447 : 			if (_N0 < _Count)
; 1448 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1449 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1450 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1451 : 			_Eos(_Num);
; 1452 : 			}
; 1453 : 		return (*this);
; 1454 : 		}
; 1455 : 
; 1456 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1457 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1458 : 		_DEBUG_POINTER(_Ptr);
; 1459 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1460 : 		}
; 1461 : 
; 1462 : 	_Myt& replace(size_type _Off,
; 1463 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1464 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1465 : 		if (this->_Mysize < _Off)
; 1466 : 			_Xran();	// _Off off end
; 1467 : 		if (this->_Mysize - _Off < _N0)
; 1468 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1469 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1470 : 			_Xlen();	// result too long
; 1471 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1472 : 
; 1473 : 		if (_Count < _N0)
; 1474 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1475 : 				this->_Myptr() + _Off + _N0,
; 1476 : 				_Nm);	// smaller hole, move tail up
; 1477 : 		size_type _Num;
; 1478 : 		if ((0 < _Count || 0 < _N0)
; 1479 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1480 : 			{	// make room and rearrange
; 1481 : 			if (_N0 < _Count)
; 1482 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1483 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1484 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1485 : 			_Eos(_Num);
; 1486 : 			}
; 1487 : 		return (*this);
; 1488 : 		}
; 1489 : 
; 1490 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1491 : 		const _Myt& _Right)
; 1492 : 		{	// replace [_First, _Last) with _Right
; 1493 : 		return (replace(
; 1494 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1495 : 		}
; 1496 : 
; 1497 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1498 : 		const _Elem *_Ptr, size_type _Count)
; 1499 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1500 : 		return (replace(
; 1501 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1502 : 		}
; 1503 : 
; 1504 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1505 : 		const _Elem *_Ptr)
; 1506 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1507 : 		return (replace(
; 1508 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1509 : 		}
; 1510 : 
; 1511 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1512 : 		size_type _Count, _Elem _Ch)
; 1513 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1514 : 		return (replace(
; 1515 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1516 : 		}
; 1517 : 
; 1518 : 	template<class _Iter>
; 1519 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1520 : 			_Myt&>::type
; 1521 : 		replace(const_iterator _First, const_iterator _Last,
; 1522 : 			_Iter _First2, _Iter _Last2)
; 1523 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1524 : 		_Myt _Right(_First2, _Last2);
; 1525 : 		replace(_First, _Last, _Right);
; 1526 : 		return (*this);
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const_pointer _First2, const_pointer _Last2)
; 1531 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1532 : 		if (_First2 == _Last2)
; 1533 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1534 : 		else
; 1535 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1536 : 				&*_First2, _Last2 - _First2);
; 1537 : 		return (*this);
; 1538 : 		}
; 1539 : 
; 1540 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1541 : 		pointer _First2, pointer _Last2)
; 1542 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1543 : 		if (_First2 == _Last2)
; 1544 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1545 : 		else
; 1546 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1547 : 				&*_First2, _Last2 - _First2);
; 1548 : 		return (*this);
; 1549 : 		}
; 1550 : 
; 1551 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1552 : 		const_iterator _First2, const_iterator _Last2)
; 1553 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1554 : 		if (_First2 == _Last2)
; 1555 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1556 : 		else
; 1557 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1558 : 				&*_First2, _Last2 - _First2);
; 1559 : 		return (*this);
; 1560 : 		}
; 1561 : 
; 1562 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1563 : 		iterator _First2, iterator _Last2)
; 1564 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1565 : 		if (_First2 == _Last2)
; 1566 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1567 : 		else
; 1568 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1569 : 				&*_First2, _Last2 - _First2);
; 1570 : 		return (*this);
; 1571 : 		}
; 1572 : 
; 1573 : 	iterator begin() _NOEXCEPT
; 1574 : 		{	// return iterator for beginning of mutable sequence
; 1575 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1576 : 		}
; 1577 : 
; 1578 : 	const_iterator begin() const _NOEXCEPT
; 1579 : 		{	// return iterator for beginning of nonmutable sequence
; 1580 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1581 : 		}
; 1582 : 
; 1583 : 	iterator end() _NOEXCEPT
; 1584 : 		{	// return iterator for end of mutable sequence
; 1585 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1586 : 		}
; 1587 : 
; 1588 : 	const_iterator end() const _NOEXCEPT
; 1589 : 		{	// return iterator for end of nonmutable sequence
; 1590 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1591 : 		}
; 1592 : 
; 1593 : 	reverse_iterator rbegin() _NOEXCEPT
; 1594 : 		{	// return iterator for beginning of reversed mutable sequence
; 1595 : 		return (reverse_iterator(end()));
; 1596 : 		}
; 1597 : 
; 1598 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1600 : 		return (const_reverse_iterator(end()));
; 1601 : 		}
; 1602 : 
; 1603 : 	reverse_iterator rend() _NOEXCEPT
; 1604 : 		{	// return iterator for end of reversed mutable sequence
; 1605 : 		return (reverse_iterator(begin()));
; 1606 : 		}
; 1607 : 
; 1608 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1609 : 		{	// return iterator for end of reversed nonmutable sequence
; 1610 : 		return (const_reverse_iterator(begin()));
; 1611 : 		}
; 1612 : 
; 1613 :  #if _HAS_CPP0X
; 1614 : 	const_iterator cbegin() const _NOEXCEPT
; 1615 : 		{	// return iterator for beginning of nonmutable sequence
; 1616 : 		return (((const _Myt *)this)->begin());
; 1617 : 		}
; 1618 : 
; 1619 : 	const_iterator cend() const _NOEXCEPT
; 1620 : 		{	// return iterator for end of nonmutable sequence
; 1621 : 		return (((const _Myt *)this)->end());
; 1622 : 		}
; 1623 : 
; 1624 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1625 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1626 : 		return (((const _Myt *)this)->rbegin());
; 1627 : 		}
; 1628 : 
; 1629 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1630 : 		{	// return iterator for end of reversed nonmutable sequence
; 1631 : 		return (((const _Myt *)this)->rend());
; 1632 : 		}
; 1633 : 
; 1634 : 	void shrink_to_fit()
; 1635 : 		{	// reduce capacity
; 1636 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1637 : 			{	// worth shrinking, do it
; 1638 : 			_Myt _Tmp(*this);
; 1639 : 			swap(_Tmp);
; 1640 : 			}
; 1641 : 		}
; 1642 :  #endif /* _HAS_CPP0X */
; 1643 : 
; 1644 : 	reference at(size_type _Off)
; 1645 : 		{	// subscript mutable sequence with checking
; 1646 : 		if (this->_Mysize <= _Off)
; 1647 : 			_Xran();	// _Off off end
; 1648 : 		return (this->_Myptr()[_Off]);
; 1649 : 		}
; 1650 : 
; 1651 : 	const_reference at(size_type _Off) const
; 1652 : 		{	// subscript nonmutable sequence with checking
; 1653 : 		if (this->_Mysize <= _Off)
; 1654 : 			_Xran();	// _Off off end
; 1655 : 		return (this->_Myptr()[_Off]);
; 1656 : 		}
; 1657 : 
; 1658 : 	reference operator[](size_type _Off)
; 1659 : 		{	// subscript mutable sequence
; 1660 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1661 : 		if (this->_Mysize < _Off)	// sic
; 1662 : 			_DEBUG_ERROR("string subscript out of range");
; 1663 : 
; 1664 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1665 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1666 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1667 : 
; 1668 : 		return (this->_Myptr()[_Off]);
; 1669 : 		}
; 1670 : 
; 1671 : 	const_reference operator[](size_type _Off) const
; 1672 : 		{	// subscript nonmutable sequence
; 1673 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1674 : 		if (this->_Mysize < _Off)	// sic
; 1675 : 			_DEBUG_ERROR("string subscript out of range");
; 1676 : 
; 1677 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1678 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1679 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1680 : 
; 1681 : 		return (this->_Myptr()[_Off]);
; 1682 : 		}
; 1683 : 
; 1684 : 	void push_back(_Elem _Ch)
; 1685 : 		{	// insert element at end
; 1686 : 		insert(end(), _Ch);
; 1687 : 		}
; 1688 : 
; 1689 :  #if _HAS_CPP0X
; 1690 : 	void pop_back()
; 1691 : 		{	// erase element at end
; 1692 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1693 : 		}
; 1694 : 
; 1695 : 	reference front()
; 1696 : 		{	// return first element of mutable sequence
; 1697 : 		return (*begin());
; 1698 : 		}
; 1699 : 
; 1700 : 	const_reference front() const
; 1701 : 		{	// return first element of nonmutable sequence
; 1702 : 		return (*begin());
; 1703 : 		}
; 1704 : 
; 1705 : 	reference back()
; 1706 : 		{	// return last element of mutable sequence
; 1707 : 		return (*(end() - 1));
; 1708 : 		}
; 1709 : 
; 1710 : 	const_reference back() const
; 1711 : 		{	// return last element of nonmutable sequence
; 1712 : 		return (*(end() - 1));
; 1713 : 		}
; 1714 :  #endif /* _HAS_CPP0X */
; 1715 : 
; 1716 : 	const _Elem *c_str() const _NOEXCEPT
; 1717 : 		{	// return pointer to null-terminated nonmutable array
; 1718 : 		return (this->_Myptr());
; 1719 : 		}
; 1720 : 
; 1721 : 	const _Elem *data() const _NOEXCEPT
; 1722 : 		{	// return pointer to nonmutable array
; 1723 : 		return (c_str());
; 1724 : 		}
; 1725 : 
; 1726 : 	size_type length() const _NOEXCEPT
; 1727 : 		{	// return length of sequence
; 1728 : 		return (this->_Mysize);
; 1729 : 		}
; 1730 : 
; 1731 : 	size_type size() const _NOEXCEPT
; 1732 : 		{	// return length of sequence
; 1733 : 		return (this->_Mysize);
; 1734 : 		}
; 1735 : 
; 1736 : 	size_type max_size() const _NOEXCEPT
; 1737 : 		{	// return maximum possible length of sequence
; 1738 : 		size_type _Num = this->_Getal().max_size();
; 1739 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1740 : 		}
; 1741 : 
; 1742 : 	void resize(size_type _Newsize)
; 1743 : 		{	// determine new length, padding with null elements as needed
; 1744 : 		resize(_Newsize, _Elem());
; 1745 : 		}
; 1746 : 
; 1747 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1748 : 		{	// determine new length, padding with _Ch elements as needed
; 1749 : 		if (_Newsize <= this->_Mysize)
; 1750 : 			_Eos(_Newsize);
; 1751 : 		else
; 1752 : 			append(_Newsize - this->_Mysize, _Ch);
; 1753 : 		}
; 1754 : 
; 1755 : 	size_type capacity() const _NOEXCEPT
; 1756 : 		{	// return current length of allocated storage
; 1757 : 		return (this->_Myres);
; 1758 : 		}
; 1759 : 
; 1760 : 	void reserve(size_type _Newcap = 0)
; 1761 : 		{	// determine new minimum length of allocated storage
; 1762 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1763 : 			{	// change reservation
; 1764 : 			size_type _Size = this->_Mysize;
; 1765 : 			if (_Grow(_Newcap, true))
; 1766 : 				_Eos(_Size);
; 1767 : 			}
; 1768 : 		}
; 1769 : 
; 1770 : 	bool empty() const _NOEXCEPT
; 1771 : 		{	// test if sequence is empty
; 1772 : 		return (this->_Mysize == 0);
; 1773 : 		}
; 1774 : 
; 1775 : 	_SCL_INSECURE_DEPRECATE
; 1776 : 
; 1777 : 	size_type copy(_Elem *_Ptr,
; 1778 : 		size_type _Count, size_type _Off = 0) const
; 1779 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1780 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1781 : 		if (_Count != 0)
; 1782 : 			_DEBUG_POINTER(_Ptr);
; 1783 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1784 : 
; 1785 : 		if (this->_Mysize < _Off)
; 1786 : 			_Xran();	// _Off off end
; 1787 : 		if (this->_Mysize - _Off < _Count)
; 1788 : 			_Count = this->_Mysize - _Off;
; 1789 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1790 : 		return (_Count);
; 1791 : 		}
; 1792 : 
; 1793 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1794 : 		size_type _Count, size_type _Off = 0) const
; 1795 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1796 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1797 : 		if (_Count != 0)
; 1798 : 			_DEBUG_POINTER(_Dest);
; 1799 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1800 : 
; 1801 : 		if (this->_Mysize < _Off)
; 1802 : 			_Xran();	// _Off off end
; 1803 : 		if (this->_Mysize - _Off < _Count)
; 1804 : 			_Count = this->_Mysize - _Off;
; 1805 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1806 : 		return (_Count);
; 1807 : 		}
; 1808 : 
; 1809 : 	void _Swap_bx(_Myt& _Right)
; 1810 : 		{	// exchange _Bx with _Right._Bx
; 1811 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1812 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1813 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1814 : 			else
; 1815 : 				{	// swap large with small
; 1816 : 				pointer _Ptr = this->_Bx._Ptr;
; 1817 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1818 : 				_Traits::copy(this->_Bx._Buf,
; 1819 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1820 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1821 : 				}
; 1822 : 		else
; 1823 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1824 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1825 : 			else
; 1826 : 				{	// swap small with large
; 1827 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1828 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1829 : 				_Traits::copy(_Right._Bx._Buf,
; 1830 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1831 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1832 : 				}
; 1833 : 		}
; 1834 : 
; 1835 : 	void swap(_Myt& _Right)
; 1836 : 		{	// exchange contents with _Right
; 1837 : 		if (this == &_Right)
; 1838 : 			;	// same object, do nothing
; 1839 : 		else if (this->_Getal() == _Right._Getal())
; 1840 : 			{	// same allocator, swap control information
; 1841 : 			this->_Swap_all(_Right);
; 1842 : 			_Swap_bx(_Right);
; 1843 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1844 : 			_STD swap(this->_Myres, _Right._Myres);
; 1845 : 			}
; 1846 : 
; 1847 :  #if _HAS_CPP0X
; 1848 : 		else if (_Alty::propagate_on_container_swap::value)
; 1849 : 			{	// swap allocators and control information
; 1850 : 			this->_Swap_alloc(_Right);
; 1851 : 			_Swap_bx(_Right);
; 1852 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1853 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1854 : 			_STD swap(this->_Myres, _Right._Myres);
; 1855 : 			}
; 1856 :  #endif /* _HAS_CPP0X */
; 1857 : 
; 1858 : 		else
; 1859 : 			{	// different allocator, do multiple assigns
; 1860 : 			_Myt _Tmp = *this;
; 1861 : 
; 1862 : 			*this = _Right;
; 1863 : 			_Right = _Tmp;
; 1864 : 			}
; 1865 : 		}
; 1866 : 
; 1867 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1868 : 		{	// look for _Right beginning at or after _Off
; 1869 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1870 : 		}
; 1871 : 
; 1872 : 	size_type find(const _Elem *_Ptr,
; 1873 : 		size_type _Off, size_type _Count) const
; 1874 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1875 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1876 : 		if (_Count != 0)
; 1877 : 			_DEBUG_POINTER(_Ptr);
; 1878 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1879 : 
; 1880 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1881 : 			return (_Off);	// null string always matches (if inside string)
; 1882 : 
; 1883 : 		size_type _Nm;
; 1884 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1885 : 			{	// room for match, look for it
; 1886 : 			const _Elem *_Uptr, *_Vptr;
; 1887 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1888 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1889 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1890 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1891 : 					return (_Uptr - this->_Myptr());	// found a match
; 1892 : 			}
; 1893 : 
; 1894 : 		return (npos);	// no match
; 1895 : 		}
; 1896 : 
; 1897 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1898 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1899 : 		_DEBUG_POINTER(_Ptr);
; 1900 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1901 : 		}
; 1902 : 
; 1903 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1904 : 		{	// look for _Ch at or after _Off
; 1905 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1906 : 		}
; 1907 : 
; 1908 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1909 : 		{	// look for _Right beginning before _Off
; 1910 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1911 : 		}
; 1912 : 
; 1913 : 	size_type rfind(const _Elem *_Ptr,
; 1914 : 		size_type _Off, size_type _Count) const
; 1915 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1916 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1917 : 		if (_Count != 0)
; 1918 : 			_DEBUG_POINTER(_Ptr);
; 1919 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1920 : 
; 1921 : 		if (_Count == 0)
; 1922 : 			return (_Off < this->_Mysize ? _Off
; 1923 : 				: this->_Mysize);	// null always matches
; 1924 : 		if (_Count <= this->_Mysize)
; 1925 : 			{	// room for match, look for it
; 1926 : 			const _Elem *_Uptr = this->_Myptr() +
; 1927 : 				(_Off < this->_Mysize - _Count ? _Off
; 1928 : 					: this->_Mysize - _Count);
; 1929 : 			for (; ; --_Uptr)
; 1930 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1931 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1932 : 					return (_Uptr - this->_Myptr());	// found a match
; 1933 : 				else if (_Uptr == this->_Myptr())
; 1934 : 					break;	// at beginning, no more chance for match
; 1935 : 			}
; 1936 : 
; 1937 : 		return (npos);	// no match
; 1938 : 		}
; 1939 : 
; 1940 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1941 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1942 : 		_DEBUG_POINTER(_Ptr);
; 1943 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1944 : 		}
; 1945 : 
; 1946 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1947 : 		{	// look for _Ch before _Off
; 1948 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1949 : 		}
; 1950 : 
; 1951 : 	size_type find_first_of(const _Myt& _Right,
; 1952 : 		size_type _Off = 0) const _NOEXCEPT
; 1953 : 		{	// look for one of _Right at or after _Off
; 1954 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1955 : 		}
; 1956 : 
; 1957 : 	size_type find_first_of(const _Elem *_Ptr,
; 1958 : 		size_type _Off, size_type _Count) const
; 1959 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1960 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1961 : 		if (_Count != 0)
; 1962 : 			_DEBUG_POINTER(_Ptr);
; 1963 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1964 : 
; 1965 : 		if (0 < _Count && _Off < this->_Mysize)
; 1966 : 			{	// room for match, look for it
; 1967 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1968 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1969 : 				_Uptr < _Vptr; ++_Uptr)
; 1970 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1971 : 					return (_Uptr - this->_Myptr());	// found a match
; 1972 : 			}
; 1973 : 
; 1974 : 		return (npos);	// no match
; 1975 : 		}
; 1976 : 
; 1977 : 	size_type find_first_of(const _Elem *_Ptr,
; 1978 : 		size_type _Off = 0) const
; 1979 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1980 : 		_DEBUG_POINTER(_Ptr);
; 1981 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 1982 : 		}
; 1983 : 
; 1984 : 	size_type find_first_of(_Elem _Ch,
; 1985 : 		size_type _Off = 0) const
; 1986 : 		{	// look for _Ch at or after _Off
; 1987 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1988 : 		}
; 1989 : 
; 1990 : 	size_type find_last_of(const _Myt& _Right,
; 1991 : 		size_type _Off = npos) const _NOEXCEPT
; 1992 : 		{	// look for one of _Right before _Off
; 1993 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_last_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off, size_type _Count) const
; 1998 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 1999 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2000 : 		if (_Count != 0)
; 2001 : 			_DEBUG_POINTER(_Ptr);
; 2002 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2003 : 
; 2004 : 		if (0 < _Count && 0 < this->_Mysize)
; 2005 : 			{	// worth searching, do it
; 2006 : 			const _Elem *_Uptr = this->_Myptr()
; 2007 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2008 : 			for (; ; --_Uptr)
; 2009 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2010 : 					return (_Uptr - this->_Myptr());	// found a match
; 2011 : 				else if (_Uptr == this->_Myptr())
; 2012 : 					break;	// at beginning, no more chance for match
; 2013 : 			}
; 2014 : 
; 2015 : 		return (npos);	// no match
; 2016 : 		}
; 2017 : 
; 2018 : 	size_type find_last_of(const _Elem *_Ptr,
; 2019 : 		size_type _Off = npos) const
; 2020 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2021 : 		_DEBUG_POINTER(_Ptr);
; 2022 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2023 : 		}
; 2024 : 
; 2025 : 	size_type find_last_of(_Elem _Ch,
; 2026 : 		size_type _Off = npos) const
; 2027 : 		{	// look for _Ch before _Off
; 2028 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2029 : 		}
; 2030 : 
; 2031 : 	size_type find_first_not_of(const _Myt& _Right,
; 2032 : 		size_type _Off = 0) const _NOEXCEPT
; 2033 : 		{	// look for none of _Right at or after _Off
; 2034 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2035 : 			_Right.size()));
; 2036 : 		}
; 2037 : 
; 2038 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2039 : 		size_type _Off, size_type _Count) const
; 2040 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2041 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2042 : 		if (_Count != 0)
; 2043 : 			_DEBUG_POINTER(_Ptr);
; 2044 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2045 : 
; 2046 : 		if (_Off < this->_Mysize)
; 2047 : 			{	// room for match, look for it
; 2048 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2049 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2050 : 				_Uptr < _Vptr; ++_Uptr)
; 2051 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2052 : 					return (_Uptr - this->_Myptr());
; 2053 : 			}
; 2054 : 		return (npos);
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off = 0) const
; 2059 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2060 : 		_DEBUG_POINTER(_Ptr);
; 2061 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2062 : 		}
; 2063 : 
; 2064 : 	size_type find_first_not_of(_Elem _Ch,
; 2065 : 		size_type _Off = 0) const
; 2066 : 		{	// look for non _Ch at or after _Off
; 2067 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2068 : 		}
; 2069 : 
; 2070 : 	size_type find_last_not_of(const _Myt& _Right,
; 2071 : 		size_type _Off = npos) const _NOEXCEPT
; 2072 : 		{	// look for none of _Right before _Off
; 2073 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off, size_type _Count) const
; 2078 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2079 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2080 : 		if (_Count != 0)
; 2081 : 			_DEBUG_POINTER(_Ptr);
; 2082 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2083 : 
; 2084 : 		if (0 < this->_Mysize)
; 2085 : 			{	// worth searching, do it
; 2086 : 			const _Elem *_Uptr = this->_Myptr()
; 2087 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2088 : 			for (; ; --_Uptr)
; 2089 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2090 : 					return (_Uptr - this->_Myptr());
; 2091 : 				else if (_Uptr == this->_Myptr())
; 2092 : 					break;
; 2093 : 			}
; 2094 : 		return (npos);
; 2095 : 		}
; 2096 : 
; 2097 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2098 : 		size_type _Off = npos) const
; 2099 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2100 : 		_DEBUG_POINTER(_Ptr);
; 2101 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2102 : 		}
; 2103 : 
; 2104 : 	size_type find_last_not_of(_Elem _Ch,
; 2105 : 		size_type _Off = npos) const
; 2106 : 		{	// look for non _Ch before _Off
; 2107 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2108 : 		}
; 2109 : 
; 2110 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2111 : 		{	// return [_Off, _Off + _Count) as new string
; 2112 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2113 : 		}
; 2114 : 
; 2115 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2116 : 		{	// compare [0, _Mysize) with _Right
; 2117 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2118 : 		}
; 2119 : 
; 2120 : 	int compare(size_type _Off, size_type _N0,
; 2121 : 		const _Myt& _Right) const
; 2122 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2123 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2124 : 		}
; 2125 : 
; 2126 : 	int compare(size_type _Off,
; 2127 : 		size_type _N0, const _Myt& _Right,
; 2128 : 		size_type _Roff, size_type _Count) const
; 2129 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2130 : 		if (_Right.size() < _Roff)
; 2131 : 			_Xran();	// _Off off end
; 2132 : 		if (_Right._Mysize - _Roff < _Count)
; 2133 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2134 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2135 : 		}
; 2136 : 
; 2137 : 	int compare(const _Elem *_Ptr) const
; 2138 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2139 : 		_DEBUG_POINTER(_Ptr);
; 2140 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2141 : 		}
; 2142 : 
; 2143 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2144 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2145 : 		_DEBUG_POINTER(_Ptr);
; 2146 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2147 : 		}
; 2148 : 
; 2149 : 	int compare(size_type _Off,
; 2150 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2151 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2152 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2153 : 		if (_Count != 0)
; 2154 : 			_DEBUG_POINTER(_Ptr);
; 2155 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2156 : 
; 2157 : 		if (this->_Mysize < _Off)
; 2158 : 			_Xran();	// _Off off end
; 2159 : 		if (this->_Mysize - _Off < _N0)
; 2160 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2161 : 
; 2162 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2163 : 			_N0 < _Count ? _N0 : _Count);
; 2164 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2165 : 			: _N0 == _Count ? 0 : +1);
; 2166 : 		}
; 2167 : 
; 2168 : 	allocator_type get_allocator() const _NOEXCEPT
; 2169 : 		{	// return allocator object for values
; 2170 : 		return (this->_Getal());
; 2171 : 		}
; 2172 : 
; 2173 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2174 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2175 : 		if (_Count == 1)
; 2176 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2177 : 		else
; 2178 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2179 : 		}
; 2180 : 
; 2181 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2182 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2183 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2184 : 		if (max_size() < _Newres)
; 2185 : 			_Newres = _Newsize;	// undo roundup if too big
; 2186 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2187 : 			;
; 2188 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2189 : 			_Newres = this->_Myres
; 2190 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2191 : 		else
; 2192 : 			_Newres = max_size();	// settle for max_size()
; 2193 : 
; 2194 : 		_Elem *_Ptr;
; 2195 : 		_TRY_BEGIN
; 2196 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2197 : 		_CATCH_ALL
; 2198 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2199 : 			_TRY_BEGIN
; 2200 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2201 : 			_CATCH_ALL
; 2202 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2203 : 			_RERAISE;
; 2204 : 			_CATCH_END
; 2205 : 		_CATCH_END
; 2206 : 
; 2207 : 		if (0 < _Oldlen)
; 2208 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2209 : 				_Oldlen);	// copy existing elements
; 2210 : 		_Tidy(true);
; 2211 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2212 : 		this->_Myres = _Newres;
; 2213 : 		_Eos(_Oldlen);
; 2214 : 		}
; 2215 : 
; 2216 : 	void _Eos(size_type _Newsize)
; 2217 : 		{	// set new length and null terminator
; 2218 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  007e4	48 89 7d d7	 mov	 QWORD PTR $T14[rbp-105], rdi
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd

; 347  : 		_Left = _Right;

  007e8	66 89 7d c7	 mov	 WORD PTR $T14[rbp-121], di
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 735  : 		assign(_Right, 0, npos);

  007ec	49 83 c9 ff	 or	 r9, -1
  007f0	45 33 c0	 xor	 r8d, r8d
  007f3	48 8d 55 ef	 lea	 rdx, QWORD PTR filePath$[rbp-121]
  007f7	48 8d 4d c7	 lea	 rcx, QWORD PTR $T14[rbp-121]
  007fb	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@AEBV12@_K1@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp

; 268  : 	noTexVShader = new gfxu::VertexShader(filePath);

  00800	48 8d 55 c7	 lea	 rdx, QWORD PTR $T14[rbp-121]
  00804	48 8b cb	 mov	 rcx, rbx
  00807	e8 00 00 00 00	 call	 ??0VertexShader@gfxu@@QEAA@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z ; gfxu::VertexShader::VertexShader
  0080c	eb 03		 jmp	 SHORT $LN21@preStart
$LN20@preStart:
  0080e	48 8b c7	 mov	 rax, rdi
$LN21@preStart:
  00811	48 89 05 00 00
	00 00		 mov	 QWORD PTR ?noTexVShader@@3PEAVVertexShader@gfxu@@EA, rax ; noTexVShader
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 1099 : 		return (assign(_Right, 0, npos));

  00818	49 83 c9 ff	 or	 r9, -1
  0081c	45 33 c0	 xor	 r8d, r8d
  0081f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?EXE_DIR@IOUtil@@3V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@A ; IOUtil::EXE_DIR
  00826	48 8d 4d ef	 lea	 rcx, QWORD PTR filePath$[rbp-121]
  0082a	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@AEBV12@_K1@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign

; 736  : 		}
; 737  : 
; 738  :  #if _HAS_CPP0X
; 739  : 	basic_string(const _Myt& _Right, const _Alloc& _Al)
; 740  : 		: _Mybase(_Al)
; 741  : 		{	// construct by copying with allocator
; 742  : 		_Tidy();
; 743  : 		assign(_Right, 0, npos);
; 744  : 		}
; 745  :  #endif /* _HAS_CPP0X */
; 746  : 
; 747  : 	basic_string()
; 748  : 		: _Mybase()
; 749  : 		{	// construct empty string
; 750  : 		_Tidy();
; 751  : 		}
; 752  : 
; 753  : 	explicit basic_string(const _Alloc& _Al)
; 754  : 		: _Mybase(_Al)
; 755  : 		{	// construct empty string with allocator
; 756  : 		_Tidy();
; 757  : 		}
; 758  : 
; 759  : 	basic_string(const _Myt& _Right, size_type _Roff,
; 760  : 		size_type _Count = npos)
; 761  : 		: _Mybase(_Right._Getal())
; 762  : 		{	// construct from _Right [_Roff, _Roff + _Count)
; 763  : 		_Tidy();
; 764  : 		assign(_Right, _Roff, _Count);
; 765  : 		}
; 766  : 
; 767  : 	basic_string(const _Myt& _Right, size_type _Roff, size_type _Count,
; 768  : 		const _Alloc& _Al)
; 769  : 		: _Mybase(_Al)
; 770  : 		{	// construct from _Right [_Roff, _Roff + _Count) with allocator
; 771  : 		_Tidy();
; 772  : 		assign(_Right, _Roff, _Count);
; 773  : 		}
; 774  : 
; 775  : 	basic_string(const _Elem *_Ptr, size_type _Count)
; 776  : 		: _Mybase()
; 777  : 		{	// construct from [_Ptr, _Ptr + _Count)
; 778  : 		_Tidy();
; 779  : 		assign(_Ptr, _Count);
; 780  : 		}
; 781  : 
; 782  : 	basic_string(const _Elem *_Ptr, size_type _Count, const _Alloc& _Al)
; 783  : 		: _Mybase(_Al)
; 784  : 		{	// construct from [_Ptr, _Ptr + _Count) with allocator
; 785  : 		_Tidy();
; 786  : 		assign(_Ptr, _Count);
; 787  : 		}
; 788  : 
; 789  : 	basic_string(const _Elem *_Ptr)
; 790  : 		: _Mybase()
; 791  : 		{	// construct from [_Ptr, <null>)
; 792  : 		_Tidy();
; 793  : 		assign(_Ptr);
; 794  : 		}
; 795  : 
; 796  : 	basic_string(const _Elem *_Ptr, const _Alloc& _Al)
; 797  : 		: _Mybase(_Al)
; 798  : 		{	// construct from [_Ptr, <null>) with allocator
; 799  : 		_Tidy();
; 800  : 		assign(_Ptr);
; 801  : 		}
; 802  : 
; 803  : 	basic_string(size_type _Count, _Elem _Ch)
; 804  : 		: _Mybase()
; 805  : 		{	// construct from _Count * _Ch
; 806  : 		_Tidy();
; 807  : 		assign(_Count, _Ch);
; 808  : 		}
; 809  : 
; 810  : 	basic_string(size_type _Count, _Elem _Ch, const _Alloc& _Al)
; 811  : 		: _Mybase(_Al)
; 812  : 		{	// construct from _Count * _Ch with allocator
; 813  : 		_Tidy();
; 814  : 		assign(_Count, _Ch);
; 815  : 		}
; 816  : 
; 817  : 	template<class _Iter>
; 818  : 		basic_string(_Iter _First, _Iter _Last,
; 819  : 			typename enable_if<_Is_iterator<_Iter>::value,
; 820  : 				void>::type ** = 0)
; 821  : 		: _Mybase()
; 822  : 		{	// construct from [_First, _Last)
; 823  : 		_Tidy();
; 824  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 825  : 		}
; 826  : 
; 827  : 	template<class _Iter>
; 828  : 		basic_string(_Iter _First, _Iter _Last, const _Alloc& _Al,
; 829  : 			typename enable_if<_Is_iterator<_Iter>::value,
; 830  : 				void>::type ** = 0)
; 831  : 		: _Mybase(_Al)
; 832  : 		{	// construct from [_First, _Last) with allocator
; 833  : 		_Tidy();
; 834  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 835  : 		}
; 836  : 
; 837  : 	template<class _Iter>
; 838  : 		void _Construct(_Iter _First,
; 839  : 			_Iter _Last, input_iterator_tag)
; 840  : 		{	// initialize from [_First, _Last), input iterators
; 841  : 		_TRY_BEGIN
; 842  : 		for (; _First != _Last; ++_First)
; 843  : 			append((size_type)1, (_Elem)*_First);
; 844  : 		_CATCH_ALL
; 845  : 		_Tidy(true);
; 846  : 		_RERAISE;
; 847  : 		_CATCH_END
; 848  : 		}
; 849  : 
; 850  : 	template<class _Iter>
; 851  : 		void _Construct(_Iter _First,
; 852  : 			_Iter _Last, forward_iterator_tag)
; 853  : 		{	// initialize from [_First, _Last), forward iterators
; 854  : 		_DEBUG_RANGE(_First, _Last);
; 855  : 		size_type _Count = 0;
; 856  : 		_Distance(_First, _Last, _Count);
; 857  : 		reserve(_Count);
; 858  : 
; 859  : 		_TRY_BEGIN
; 860  : 		for (; _First != _Last; ++_First)
; 861  : 			append((size_type)1, (_Elem)*_First);
; 862  : 		_CATCH_ALL
; 863  : 		_Tidy(true);
; 864  : 		_RERAISE;
; 865  : 		_CATCH_END
; 866  : 		}
; 867  : 
; 868  : 	basic_string(const_pointer _First, const_pointer _Last)
; 869  : 		: _Mybase()
; 870  : 		{	// construct from [_First, _Last), const pointers
; 871  : 		_DEBUG_RANGE(_First, _Last);
; 872  : 		_Tidy();
; 873  : 		if (_First != _Last)
; 874  : 			assign(&*_First, _Last - _First);
; 875  : 		}
; 876  : 
; 877  : 	basic_string(const_pointer _First, const_pointer _Last,
; 878  : 		const _Alloc& _Al)
; 879  : 		: _Mybase(_Al)
; 880  : 		{	// construct from [_First, _Last), const pointers
; 881  : 		_DEBUG_RANGE(_First, _Last);
; 882  : 		_Tidy();
; 883  : 		if (_First != _Last)
; 884  : 			assign(&*_First, _Last - _First);
; 885  : 		}
; 886  : 
; 887  : 	basic_string(const_iterator _First, const_iterator _Last)
; 888  : 		: _Mybase()
; 889  : 		{	// construct from [_First, _Last), const_iterators
; 890  : 		_DEBUG_RANGE(_First, _Last);
; 891  : 		_Tidy();
; 892  : 		if (_First != _Last)
; 893  : 			assign(&*_First, _Last - _First);
; 894  : 		}
; 895  : 
; 896  : 	basic_string(_Myt&& _Right) _NOEXCEPT
; 897  : 		: _Mybase(_Right._Getal())
; 898  : 		{	// construct by moving _Right
; 899  : 		_Tidy();
; 900  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 901  : 		}
; 902  : 
; 903  : 	basic_string(_Myt&& _Right, const _Alloc& _Al)
; 904  : 		: _Mybase(_Al)
; 905  : 		{	// construct by moving _Right, allocator
; 906  : 		if (this->_Getal() != _Right._Getal())
; 907  : 			assign(_Right.begin(), _Right.end());
; 908  : 		else
; 909  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 910  : 		}
; 911  : 
; 912  : 	_Myt& operator=(_Myt&& _Right) _NOEXCEPT
; 913  : 		{	// assign by moving _Right
; 914  : 		if (this != &_Right)
; 915  : 			{	// different, assign it
; 916  : 			_Tidy(true);
; 917  : 
; 918  :  #if _HAS_CPP0X
; 919  : 			if (this->_Getal() != _Right._Getal()
; 920  : 				&& _Alty::propagate_on_container_move_assignment::value)
; 921  : 				this->_Change_alloc(_Right._Getal());
; 922  :  #endif /* _HAS_CPP0X */
; 923  : 
; 924  : 			if (this->_Getal() != _Right._Getal())
; 925  : 				assign(_Right.begin(), _Right.end());
; 926  : 			else
; 927  : 				_Assign_rv(_STD forward<_Myt>(_Right));
; 928  : 			}
; 929  : 		return (*this);
; 930  : 		}
; 931  : 
; 932  : 	_Myt& assign(_Myt&& _Right) _NOEXCEPT
; 933  : 		{	// assign by moving _Right
; 934  : 		if (this == &_Right)
; 935  : 			;
; 936  : 		else if (get_allocator() != _Right.get_allocator()
; 937  : 			&& this->_BUF_SIZE <= _Right._Myres)
; 938  : 			*this = _Right;
; 939  : 		else
; 940  : 			{	// not same, clear this and steal from _Right
; 941  : 			_Tidy(true);
; 942  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 943  : 			}
; 944  : 		return (*this);
; 945  : 		}
; 946  : 
; 947  : 	void _Assign_rv(_Myt&& _Right)
; 948  : 		{	// assign by moving _Right
; 949  : 		if (_Right._Myres < this->_BUF_SIZE)
; 950  : 			_Traits::move(this->_Bx._Buf, _Right._Bx._Buf,
; 951  : 				_Right._Mysize + 1);
; 952  : 		else
; 953  : 			{	// copy pointer
; 954  : 			this->_Getal().construct(&this->_Bx._Ptr, _Right._Bx._Ptr);
; 955  : 			_Right._Bx._Ptr = pointer();
; 956  : 			}
; 957  : 		this->_Mysize = _Right._Mysize;
; 958  : 		this->_Myres = _Right._Myres;
; 959  : 		_Right._Tidy();
; 960  : 		}
; 961  : 
; 962  : 	~basic_string() _NOEXCEPT
; 963  : 		{	// destroy the string
; 964  : 		_Tidy(true);
; 965  : 		}
; 966  : 
; 967  : 	_PGLOBAL static const size_type npos;	// bad/missing length/position
; 968  : 
; 969  : 	_Myt& operator=(const _Myt& _Right)
; 970  : 		{	// assign _Right
; 971  : 		if (this != &_Right)
; 972  : 			{	// different, assign it
; 973  :  #if _HAS_CPP0X
; 974  : 			if (this->_Getal() != _Right._Getal()
; 975  : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 976  : 				{	// change allocator before copying
; 977  : 				_Tidy(true);
; 978  : 				this->_Change_alloc(_Right._Getal());
; 979  : 				}
; 980  :  #endif /* _HAS_CPP0X */
; 981  : 
; 982  : 			assign(_Right);
; 983  : 			}
; 984  : 		return (*this);
; 985  : 		}
; 986  : 
; 987  : 	_Myt& operator=(const _Elem *_Ptr)
; 988  : 		{	// assign [_Ptr, <null>)
; 989  : 		return (assign(_Ptr));
; 990  : 		}
; 991  : 
; 992  : 	_Myt& operator=(_Elem _Ch)
; 993  : 		{	// assign 1 * _Ch
; 994  : 		return (assign(1, _Ch));
; 995  : 		}
; 996  : 
; 997  : 	_Myt& operator+=(const _Myt& _Right)
; 998  : 		{	// append _Right
; 999  : 		return (append(_Right));
; 1000 : 		}
; 1001 : 
; 1002 : 	_Myt& operator+=(const _Elem *_Ptr)
; 1003 : 		{	// append [_Ptr, <null>)
; 1004 : 		return (append(_Ptr));
; 1005 : 		}
; 1006 : 
; 1007 : 	_Myt& operator+=(_Elem _Ch)
; 1008 : 		{	// append 1 * _Ch
; 1009 : 		return (append((size_type)1, _Ch));
; 1010 : 		}
; 1011 : 
; 1012 : 	_Myt& append(const _Myt& _Right)
; 1013 : 		{	// append _Right
; 1014 : 		return (append(_Right, 0, npos));
; 1015 : 		}
; 1016 : 
; 1017 : 	_Myt& append(const _Myt& _Right,
; 1018 : 		size_type _Roff, size_type _Count)
; 1019 : 		{	// append _Right [_Roff, _Roff + _Count)
; 1020 : 		if (_Right.size() < _Roff)
; 1021 : 			_Xran();	// _Roff off end
; 1022 : 		size_type _Num = _Right.size() - _Roff;
; 1023 : 		if (_Num < _Count)
; 1024 : 			_Count = _Num;	// trim _Count to size
; 1025 : 		if (npos - this->_Mysize <= _Count)
; 1026 : 			_Xlen();	// result too long
; 1027 : 
; 1028 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1029 : 			{	// make room and append new stuff
; 1030 : 			_Traits::copy(this->_Myptr() + this->_Mysize,
; 1031 : 				_Right._Myptr() + _Roff, _Count);
; 1032 : 			_Eos(_Num);
; 1033 : 			}
; 1034 : 		return (*this);
; 1035 : 		}
; 1036 : 
; 1037 : 	_Myt& append(const _Elem *_Ptr, size_type _Count)
; 1038 : 		{	// append [_Ptr, _Ptr + _Count)
; 1039 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1040 : 		if (_Count != 0)
; 1041 : 			_DEBUG_POINTER(_Ptr);
; 1042 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1043 : 
; 1044 : 		if (_Inside(_Ptr))
; 1045 : 			return (append(*this,
; 1046 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1047 : 		if (npos - this->_Mysize <= _Count)
; 1048 : 			_Xlen();	// result too long
; 1049 : 
; 1050 : 		size_type _Num;
; 1051 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1052 : 			{	// make room and append new stuff
; 1053 : 			_Traits::copy(this->_Myptr() + this->_Mysize, _Ptr, _Count);
; 1054 : 			_Eos(_Num);
; 1055 : 			}
; 1056 : 		return (*this);
; 1057 : 		}
; 1058 : 
; 1059 : 	_Myt& append(const _Elem *_Ptr)
; 1060 : 		{	// append [_Ptr, <null>)
; 1061 : 		_DEBUG_POINTER(_Ptr);
; 1062 : 		return (append(_Ptr, _Traits::length(_Ptr)));

  0082f	41 b8 13 00 00
	00		 mov	 r8d, 19
  00835	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG4294950228
  0083c	48 8d 4d ef	 lea	 rcx, QWORD PTR filePath$[rbp-121]
  00840	e8 00 00 00 00	 call	 ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@PEB_W_K@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp

; 272  : 	noTexFShader = new gfxu::FragmentShader(filePath);

  00845	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  0084a	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  0084f	48 8b d8	 mov	 rbx, rax
  00852	48 89 45 b7	 mov	 QWORD PTR $T5[rbp-121], rax
  00856	48 85 c0	 test	 rax, rax
  00859	74 32		 je	 SHORT $LN22@preStart
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 2265 : 		this->_Myres = this->_BUF_SIZE - 1;

  0085b	48 c7 45 df 07
	00 00 00	 mov	 QWORD PTR $T13[rbp-97], 7

; 1100 : 		}
; 1101 : 
; 1102 : 	_Myt& assign(const _Myt& _Right,
; 1103 : 		size_type _Roff, size_type _Count)
; 1104 : 		{	// assign _Right [_Roff, _Roff + _Count)
; 1105 : 		if (_Right.size() < _Roff)
; 1106 : 			_Xran();	// _Roff off end
; 1107 : 		size_type _Num = _Right.size() - _Roff;
; 1108 : 		if (_Count < _Num)
; 1109 : 			_Num = _Count;	// trim _Num to size
; 1110 : 
; 1111 : 		if (this == &_Right)
; 1112 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring
; 1113 : 		else if (_Grow(_Num))
; 1114 : 			{	// make room and assign new stuff
; 1115 : 			_Traits::copy(this->_Myptr(),
; 1116 : 				_Right._Myptr() + _Roff, _Num);
; 1117 : 			_Eos(_Num);
; 1118 : 			}
; 1119 : 		return (*this);
; 1120 : 		}
; 1121 : 
; 1122 : 	_Myt& assign(const _Elem *_Ptr, size_type _Count)
; 1123 : 		{	// assign [_Ptr, _Ptr + _Count)
; 1124 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1125 : 		if (_Count != 0)
; 1126 : 			_DEBUG_POINTER(_Ptr);
; 1127 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1128 : 
; 1129 : 		if (_Inside(_Ptr))
; 1130 : 			return (assign(*this,
; 1131 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1132 : 
; 1133 : 		if (_Grow(_Count))
; 1134 : 			{	// make room and assign new stuff
; 1135 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);
; 1136 : 			_Eos(_Count);
; 1137 : 			}
; 1138 : 		return (*this);
; 1139 : 		}
; 1140 : 
; 1141 : 	_Myt& assign(const _Elem *_Ptr)
; 1142 : 		{	// assign [_Ptr, <null>)
; 1143 : 		_DEBUG_POINTER(_Ptr);
; 1144 : 		return (assign(_Ptr, _Traits::length(_Ptr)));
; 1145 : 		}
; 1146 : 
; 1147 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1148 : 		{	// assign _Count * _Ch
; 1149 : 		if (_Count == npos)
; 1150 : 			_Xlen();	// result too long
; 1151 : 
; 1152 : 		if (_Grow(_Count))
; 1153 : 			{	// make room and assign new stuff
; 1154 : 			_Chassign(0, _Count, _Ch);
; 1155 : 			_Eos(_Count);
; 1156 : 			}
; 1157 : 		return (*this);
; 1158 : 		}
; 1159 : 
; 1160 : 	template<class _Iter>
; 1161 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1162 : 			_Myt&>::type
; 1163 : 		assign(_Iter _First, _Iter _Last)
; 1164 : 		{	// assign [First, _Last), input iterators
; 1165 : 		return (replace(begin(), end(), _First, _Last));
; 1166 : 		}
; 1167 : 
; 1168 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1169 : 		{	// assign [First, _Last), const pointers
; 1170 : 		return (replace(begin(), end(), _First, _Last));
; 1171 : 		}
; 1172 : 
; 1173 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1174 : 		{	// assign [First, _Last), const_iterators
; 1175 : 		return (replace(begin(), end(), _First, _Last));
; 1176 : 		}
; 1177 : 
; 1178 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1179 : 		{	// insert _Right at _Off
; 1180 : 		return (insert(_Off, _Right, 0, npos));
; 1181 : 		}
; 1182 : 
; 1183 : 	_Myt& insert(size_type _Off,
; 1184 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1185 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1186 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1187 : 			_Xran();	// _Off or _Roff off end
; 1188 : 		size_type _Num = _Right.size() - _Roff;
; 1189 : 		if (_Num < _Count)
; 1190 : 			_Count = _Num;	// trim _Count to size
; 1191 : 		if (npos - this->_Mysize <= _Count)
; 1192 : 			_Xlen();	// result too long
; 1193 : 
; 1194 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1195 : 			{	// make room and insert new stuff
; 1196 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1197 : 				this->_Myptr() + _Off,
; 1198 : 				this->_Mysize - _Off);	// empty out hole
; 1199 : 			if (this == &_Right)
; 1200 : 				_Traits::move(this->_Myptr() + _Off,
; 1201 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1202 : 						_Count);	// substring
; 1203 : 			else
; 1204 : 				_Traits::copy(this->_Myptr() + _Off,
; 1205 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1206 : 			_Eos(_Num);
; 1207 : 			}
; 1208 : 		return (*this);
; 1209 : 		}
; 1210 : 
; 1211 : 	_Myt& insert(size_type _Off,
; 1212 : 		const _Elem *_Ptr, size_type _Count)
; 1213 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1214 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1215 : 		if (_Count != 0)
; 1216 : 			_DEBUG_POINTER(_Ptr);
; 1217 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1218 : 
; 1219 : 		if (_Inside(_Ptr))
; 1220 : 			return (insert(_Off, *this,
; 1221 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1222 : 		if (this->_Mysize < _Off)
; 1223 : 			_Xran();	// _Off off end
; 1224 : 		if (npos - this->_Mysize <= _Count)
; 1225 : 			_Xlen();	// result too long
; 1226 : 		size_type _Num;
; 1227 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1228 : 			{	// make room and insert new stuff
; 1229 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1230 : 				this->_Myptr() + _Off,
; 1231 : 				this->_Mysize - _Off);	// empty out hole
; 1232 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1233 : 			_Eos(_Num);
; 1234 : 			}
; 1235 : 		return (*this);
; 1236 : 		}
; 1237 : 
; 1238 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1239 : 		{	// insert [_Ptr, <null>) at _Off
; 1240 : 		_DEBUG_POINTER(_Ptr);
; 1241 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1242 : 		}
; 1243 : 
; 1244 : 	_Myt& insert(size_type _Off,
; 1245 : 		size_type _Count, _Elem _Ch)
; 1246 : 		{	// insert _Count * _Ch at _Off
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	iterator insert(const_iterator _Where)
; 1264 : 		{	// insert <null> at _Where
; 1265 : 		return (insert(_Where, _Elem()));
; 1266 : 		}
; 1267 : 
; 1268 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1269 : 		{	// insert _Ch at _Where
; 1270 : 		size_type _Off = _Pdif(_Where, begin());
; 1271 : 		insert(_Off, 1, _Ch);
; 1272 : 		return (begin() + _Off);
; 1273 : 		}
; 1274 : 
; 1275 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1276 : 		{	// insert _Count * _Elem at _Where
; 1277 : 		size_type _Off = _Pdif(_Where, begin());
; 1278 : 		insert(_Off, _Count, _Ch);
; 1279 : 		return (begin() + _Off);
; 1280 : 		}
; 1281 : 
; 1282 : 	template<class _Iter>
; 1283 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1284 : 			iterator>::type
; 1285 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1286 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1287 : 		size_type _Off = _Pdif(_Where, begin());
; 1288 : 		replace(_Where, _Where, _First, _Last);
; 1289 : 		return (begin() + _Off);
; 1290 : 		}
; 1291 : 
; 1292 : 	iterator insert(const_iterator _Where,
; 1293 : 		const_pointer _First, const_pointer _Last)
; 1294 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		replace(_Where, _Where, _First, _Last);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where,
; 1301 : 		const_iterator _First, const_iterator _Last)
; 1302 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1303 : 		size_type _Off = _Pdif(_Where, begin());
; 1304 : 		replace(_Where, _Where, _First, _Last);
; 1305 : 		return (begin() + _Off);
; 1306 : 		}
; 1307 : 
; 1308 : 	_Myt& erase(size_type _Off = 0)
; 1309 : 		{	// erase elements [_Off, ...)
; 1310 : 		if (this->_Mysize < _Off)
; 1311 : 			_Xran();	// _Off off end
; 1312 : 		_Eos(_Off);
; 1313 : 		return (*this);
; 1314 : 		}
; 1315 : 
; 1316 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1317 : 		{	// erase elements [_Off, _Off + _Count)
; 1318 : 		if (this->_Mysize < _Off)
; 1319 : 			_Xran();	// _Off off end
; 1320 : 		if (this->_Mysize - _Off <= _Count)
; 1321 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1322 : 		else if (0 < _Count)
; 1323 : 			{	// move elements down
; 1324 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1325 : 			size_type _Newsize = this->_Mysize - _Count;
; 1326 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1327 : 			_Eos(_Newsize);
; 1328 : 			}
; 1329 : 		return (*this);
; 1330 : 		}
; 1331 : 
; 1332 : 	iterator erase(const_iterator _Where)
; 1333 : 		{	// erase element at _Where
; 1334 : 		size_type _Count = _Pdif(_Where, begin());
; 1335 : 		erase(_Count, 1);
; 1336 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1337 : 		}
; 1338 : 
; 1339 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1340 : 		{	// erase substring [_First, _Last)
; 1341 : 		_DEBUG_RANGE(_First, _Last);
; 1342 : 		size_type _Count = _Pdif(_First, begin());
; 1343 : 		erase(_Count, _Pdif(_Last, _First));
; 1344 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1345 : 		}
; 1346 : 
; 1347 : 	void clear() _NOEXCEPT
; 1348 : 		{	// erase all
; 1349 : 		_Eos(0);
; 1350 : 		}
; 1351 : 
; 1352 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1353 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1354 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1355 : 		}
; 1356 : 
; 1357 : 	_Myt& replace(size_type _Off,
; 1358 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1359 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1360 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1361 : 			_Xran();	// _Off or _Roff off end
; 1362 : 		if (this->_Mysize - _Off < _N0)
; 1363 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1364 : 		size_type _Num = _Right.size() - _Roff;
; 1365 : 		if (_Num < _Count)
; 1366 : 			_Count = _Num;	// trim _Count to size
; 1367 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1368 : 			_Xlen();	// result too long
; 1369 : 
; 1370 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1371 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1372 : 		if (this->_Mysize < _Newsize)
; 1373 : 			_Grow(_Newsize);
; 1374 : 
; 1375 : 		if (this != &_Right)
; 1376 : 			{	// no overlap, just move down and copy in new stuff
; 1377 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1378 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1379 : 			_Traits::copy(this->_Myptr() + _Off,
; 1380 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1381 : 			}
; 1382 : 		else if (_Count <= _N0)
; 1383 : 			{	// hole doesn't get larger, just copy in substring
; 1384 : 			_Traits::move(this->_Myptr() + _Off,
; 1385 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1386 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1387 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1388 : 			}
; 1389 : 		else if (_Roff <= _Off)
; 1390 : 			{	// hole gets larger, substring begins before hole
; 1391 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1392 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1393 : 			_Traits::move(this->_Myptr() + _Off,
; 1394 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1395 : 			}
; 1396 : 		else if (_Off + _N0 <= _Roff)
; 1397 : 			{	// hole gets larger, substring begins after hole
; 1398 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1399 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1400 : 			_Traits::move(this->_Myptr() + _Off,
; 1401 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1402 : 				_Count);	// fill hole
; 1403 : 			}
; 1404 : 		else
; 1405 : 			{	// hole gets larger, substring begins in hole
; 1406 : 			_Traits::move(this->_Myptr() + _Off,
; 1407 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1408 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1409 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1410 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1411 : 				this->_Myptr() + _Roff + _Count,
; 1412 : 				_Count - _N0);	// fill rest of new hole
; 1413 : 			}
; 1414 : 
; 1415 : 		_Eos(_Newsize);
; 1416 : 		return (*this);
; 1417 : 		}
; 1418 : 
; 1419 : 	_Myt& replace(size_type _Off,
; 1420 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1421 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1422 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1423 : 		if (_Count != 0)
; 1424 : 			_DEBUG_POINTER(_Ptr);
; 1425 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1426 : 
; 1427 : 		if (_Inside(_Ptr))
; 1428 : 			return (replace(_Off, _N0, *this,
; 1429 : 				_Ptr - this->_Myptr(),
; 1430 : 				_Count));	// substring, replace carefully
; 1431 : 		if (this->_Mysize < _Off)
; 1432 : 			_Xran();	// _Off off end
; 1433 : 		if (this->_Mysize - _Off < _N0)
; 1434 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1435 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1436 : 			_Xlen();	// result too long
; 1437 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1438 : 
; 1439 : 		if (_Count < _N0)
; 1440 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1441 : 				this->_Myptr() + _Off + _N0,
; 1442 : 				_Nm);	// smaller hole, move tail up
; 1443 : 		size_type _Num;
; 1444 : 		if ((0 < _Count || 0 < _N0)
; 1445 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1446 : 			{	// make room and rearrange
; 1447 : 			if (_N0 < _Count)
; 1448 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1449 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1450 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1451 : 			_Eos(_Num);
; 1452 : 			}
; 1453 : 		return (*this);
; 1454 : 		}
; 1455 : 
; 1456 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1457 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1458 : 		_DEBUG_POINTER(_Ptr);
; 1459 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1460 : 		}
; 1461 : 
; 1462 : 	_Myt& replace(size_type _Off,
; 1463 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1464 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1465 : 		if (this->_Mysize < _Off)
; 1466 : 			_Xran();	// _Off off end
; 1467 : 		if (this->_Mysize - _Off < _N0)
; 1468 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1469 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1470 : 			_Xlen();	// result too long
; 1471 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1472 : 
; 1473 : 		if (_Count < _N0)
; 1474 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1475 : 				this->_Myptr() + _Off + _N0,
; 1476 : 				_Nm);	// smaller hole, move tail up
; 1477 : 		size_type _Num;
; 1478 : 		if ((0 < _Count || 0 < _N0)
; 1479 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1480 : 			{	// make room and rearrange
; 1481 : 			if (_N0 < _Count)
; 1482 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1483 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1484 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1485 : 			_Eos(_Num);
; 1486 : 			}
; 1487 : 		return (*this);
; 1488 : 		}
; 1489 : 
; 1490 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1491 : 		const _Myt& _Right)
; 1492 : 		{	// replace [_First, _Last) with _Right
; 1493 : 		return (replace(
; 1494 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1495 : 		}
; 1496 : 
; 1497 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1498 : 		const _Elem *_Ptr, size_type _Count)
; 1499 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1500 : 		return (replace(
; 1501 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1502 : 		}
; 1503 : 
; 1504 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1505 : 		const _Elem *_Ptr)
; 1506 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1507 : 		return (replace(
; 1508 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1509 : 		}
; 1510 : 
; 1511 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1512 : 		size_type _Count, _Elem _Ch)
; 1513 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1514 : 		return (replace(
; 1515 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1516 : 		}
; 1517 : 
; 1518 : 	template<class _Iter>
; 1519 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1520 : 			_Myt&>::type
; 1521 : 		replace(const_iterator _First, const_iterator _Last,
; 1522 : 			_Iter _First2, _Iter _Last2)
; 1523 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1524 : 		_Myt _Right(_First2, _Last2);
; 1525 : 		replace(_First, _Last, _Right);
; 1526 : 		return (*this);
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const_pointer _First2, const_pointer _Last2)
; 1531 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1532 : 		if (_First2 == _Last2)
; 1533 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1534 : 		else
; 1535 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1536 : 				&*_First2, _Last2 - _First2);
; 1537 : 		return (*this);
; 1538 : 		}
; 1539 : 
; 1540 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1541 : 		pointer _First2, pointer _Last2)
; 1542 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1543 : 		if (_First2 == _Last2)
; 1544 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1545 : 		else
; 1546 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1547 : 				&*_First2, _Last2 - _First2);
; 1548 : 		return (*this);
; 1549 : 		}
; 1550 : 
; 1551 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1552 : 		const_iterator _First2, const_iterator _Last2)
; 1553 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1554 : 		if (_First2 == _Last2)
; 1555 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1556 : 		else
; 1557 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1558 : 				&*_First2, _Last2 - _First2);
; 1559 : 		return (*this);
; 1560 : 		}
; 1561 : 
; 1562 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1563 : 		iterator _First2, iterator _Last2)
; 1564 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1565 : 		if (_First2 == _Last2)
; 1566 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1567 : 		else
; 1568 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1569 : 				&*_First2, _Last2 - _First2);
; 1570 : 		return (*this);
; 1571 : 		}
; 1572 : 
; 1573 : 	iterator begin() _NOEXCEPT
; 1574 : 		{	// return iterator for beginning of mutable sequence
; 1575 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1576 : 		}
; 1577 : 
; 1578 : 	const_iterator begin() const _NOEXCEPT
; 1579 : 		{	// return iterator for beginning of nonmutable sequence
; 1580 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1581 : 		}
; 1582 : 
; 1583 : 	iterator end() _NOEXCEPT
; 1584 : 		{	// return iterator for end of mutable sequence
; 1585 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1586 : 		}
; 1587 : 
; 1588 : 	const_iterator end() const _NOEXCEPT
; 1589 : 		{	// return iterator for end of nonmutable sequence
; 1590 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1591 : 		}
; 1592 : 
; 1593 : 	reverse_iterator rbegin() _NOEXCEPT
; 1594 : 		{	// return iterator for beginning of reversed mutable sequence
; 1595 : 		return (reverse_iterator(end()));
; 1596 : 		}
; 1597 : 
; 1598 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1600 : 		return (const_reverse_iterator(end()));
; 1601 : 		}
; 1602 : 
; 1603 : 	reverse_iterator rend() _NOEXCEPT
; 1604 : 		{	// return iterator for end of reversed mutable sequence
; 1605 : 		return (reverse_iterator(begin()));
; 1606 : 		}
; 1607 : 
; 1608 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1609 : 		{	// return iterator for end of reversed nonmutable sequence
; 1610 : 		return (const_reverse_iterator(begin()));
; 1611 : 		}
; 1612 : 
; 1613 :  #if _HAS_CPP0X
; 1614 : 	const_iterator cbegin() const _NOEXCEPT
; 1615 : 		{	// return iterator for beginning of nonmutable sequence
; 1616 : 		return (((const _Myt *)this)->begin());
; 1617 : 		}
; 1618 : 
; 1619 : 	const_iterator cend() const _NOEXCEPT
; 1620 : 		{	// return iterator for end of nonmutable sequence
; 1621 : 		return (((const _Myt *)this)->end());
; 1622 : 		}
; 1623 : 
; 1624 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1625 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1626 : 		return (((const _Myt *)this)->rbegin());
; 1627 : 		}
; 1628 : 
; 1629 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1630 : 		{	// return iterator for end of reversed nonmutable sequence
; 1631 : 		return (((const _Myt *)this)->rend());
; 1632 : 		}
; 1633 : 
; 1634 : 	void shrink_to_fit()
; 1635 : 		{	// reduce capacity
; 1636 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1637 : 			{	// worth shrinking, do it
; 1638 : 			_Myt _Tmp(*this);
; 1639 : 			swap(_Tmp);
; 1640 : 			}
; 1641 : 		}
; 1642 :  #endif /* _HAS_CPP0X */
; 1643 : 
; 1644 : 	reference at(size_type _Off)
; 1645 : 		{	// subscript mutable sequence with checking
; 1646 : 		if (this->_Mysize <= _Off)
; 1647 : 			_Xran();	// _Off off end
; 1648 : 		return (this->_Myptr()[_Off]);
; 1649 : 		}
; 1650 : 
; 1651 : 	const_reference at(size_type _Off) const
; 1652 : 		{	// subscript nonmutable sequence with checking
; 1653 : 		if (this->_Mysize <= _Off)
; 1654 : 			_Xran();	// _Off off end
; 1655 : 		return (this->_Myptr()[_Off]);
; 1656 : 		}
; 1657 : 
; 1658 : 	reference operator[](size_type _Off)
; 1659 : 		{	// subscript mutable sequence
; 1660 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1661 : 		if (this->_Mysize < _Off)	// sic
; 1662 : 			_DEBUG_ERROR("string subscript out of range");
; 1663 : 
; 1664 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1665 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1666 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1667 : 
; 1668 : 		return (this->_Myptr()[_Off]);
; 1669 : 		}
; 1670 : 
; 1671 : 	const_reference operator[](size_type _Off) const
; 1672 : 		{	// subscript nonmutable sequence
; 1673 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1674 : 		if (this->_Mysize < _Off)	// sic
; 1675 : 			_DEBUG_ERROR("string subscript out of range");
; 1676 : 
; 1677 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1678 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1679 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1680 : 
; 1681 : 		return (this->_Myptr()[_Off]);
; 1682 : 		}
; 1683 : 
; 1684 : 	void push_back(_Elem _Ch)
; 1685 : 		{	// insert element at end
; 1686 : 		insert(end(), _Ch);
; 1687 : 		}
; 1688 : 
; 1689 :  #if _HAS_CPP0X
; 1690 : 	void pop_back()
; 1691 : 		{	// erase element at end
; 1692 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1693 : 		}
; 1694 : 
; 1695 : 	reference front()
; 1696 : 		{	// return first element of mutable sequence
; 1697 : 		return (*begin());
; 1698 : 		}
; 1699 : 
; 1700 : 	const_reference front() const
; 1701 : 		{	// return first element of nonmutable sequence
; 1702 : 		return (*begin());
; 1703 : 		}
; 1704 : 
; 1705 : 	reference back()
; 1706 : 		{	// return last element of mutable sequence
; 1707 : 		return (*(end() - 1));
; 1708 : 		}
; 1709 : 
; 1710 : 	const_reference back() const
; 1711 : 		{	// return last element of nonmutable sequence
; 1712 : 		return (*(end() - 1));
; 1713 : 		}
; 1714 :  #endif /* _HAS_CPP0X */
; 1715 : 
; 1716 : 	const _Elem *c_str() const _NOEXCEPT
; 1717 : 		{	// return pointer to null-terminated nonmutable array
; 1718 : 		return (this->_Myptr());
; 1719 : 		}
; 1720 : 
; 1721 : 	const _Elem *data() const _NOEXCEPT
; 1722 : 		{	// return pointer to nonmutable array
; 1723 : 		return (c_str());
; 1724 : 		}
; 1725 : 
; 1726 : 	size_type length() const _NOEXCEPT
; 1727 : 		{	// return length of sequence
; 1728 : 		return (this->_Mysize);
; 1729 : 		}
; 1730 : 
; 1731 : 	size_type size() const _NOEXCEPT
; 1732 : 		{	// return length of sequence
; 1733 : 		return (this->_Mysize);
; 1734 : 		}
; 1735 : 
; 1736 : 	size_type max_size() const _NOEXCEPT
; 1737 : 		{	// return maximum possible length of sequence
; 1738 : 		size_type _Num = this->_Getal().max_size();
; 1739 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1740 : 		}
; 1741 : 
; 1742 : 	void resize(size_type _Newsize)
; 1743 : 		{	// determine new length, padding with null elements as needed
; 1744 : 		resize(_Newsize, _Elem());
; 1745 : 		}
; 1746 : 
; 1747 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1748 : 		{	// determine new length, padding with _Ch elements as needed
; 1749 : 		if (_Newsize <= this->_Mysize)
; 1750 : 			_Eos(_Newsize);
; 1751 : 		else
; 1752 : 			append(_Newsize - this->_Mysize, _Ch);
; 1753 : 		}
; 1754 : 
; 1755 : 	size_type capacity() const _NOEXCEPT
; 1756 : 		{	// return current length of allocated storage
; 1757 : 		return (this->_Myres);
; 1758 : 		}
; 1759 : 
; 1760 : 	void reserve(size_type _Newcap = 0)
; 1761 : 		{	// determine new minimum length of allocated storage
; 1762 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1763 : 			{	// change reservation
; 1764 : 			size_type _Size = this->_Mysize;
; 1765 : 			if (_Grow(_Newcap, true))
; 1766 : 				_Eos(_Size);
; 1767 : 			}
; 1768 : 		}
; 1769 : 
; 1770 : 	bool empty() const _NOEXCEPT
; 1771 : 		{	// test if sequence is empty
; 1772 : 		return (this->_Mysize == 0);
; 1773 : 		}
; 1774 : 
; 1775 : 	_SCL_INSECURE_DEPRECATE
; 1776 : 
; 1777 : 	size_type copy(_Elem *_Ptr,
; 1778 : 		size_type _Count, size_type _Off = 0) const
; 1779 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1780 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1781 : 		if (_Count != 0)
; 1782 : 			_DEBUG_POINTER(_Ptr);
; 1783 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1784 : 
; 1785 : 		if (this->_Mysize < _Off)
; 1786 : 			_Xran();	// _Off off end
; 1787 : 		if (this->_Mysize - _Off < _Count)
; 1788 : 			_Count = this->_Mysize - _Off;
; 1789 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1790 : 		return (_Count);
; 1791 : 		}
; 1792 : 
; 1793 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1794 : 		size_type _Count, size_type _Off = 0) const
; 1795 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1796 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1797 : 		if (_Count != 0)
; 1798 : 			_DEBUG_POINTER(_Dest);
; 1799 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1800 : 
; 1801 : 		if (this->_Mysize < _Off)
; 1802 : 			_Xran();	// _Off off end
; 1803 : 		if (this->_Mysize - _Off < _Count)
; 1804 : 			_Count = this->_Mysize - _Off;
; 1805 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1806 : 		return (_Count);
; 1807 : 		}
; 1808 : 
; 1809 : 	void _Swap_bx(_Myt& _Right)
; 1810 : 		{	// exchange _Bx with _Right._Bx
; 1811 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1812 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1813 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1814 : 			else
; 1815 : 				{	// swap large with small
; 1816 : 				pointer _Ptr = this->_Bx._Ptr;
; 1817 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1818 : 				_Traits::copy(this->_Bx._Buf,
; 1819 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1820 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1821 : 				}
; 1822 : 		else
; 1823 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1824 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1825 : 			else
; 1826 : 				{	// swap small with large
; 1827 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1828 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1829 : 				_Traits::copy(_Right._Bx._Buf,
; 1830 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1831 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1832 : 				}
; 1833 : 		}
; 1834 : 
; 1835 : 	void swap(_Myt& _Right)
; 1836 : 		{	// exchange contents with _Right
; 1837 : 		if (this == &_Right)
; 1838 : 			;	// same object, do nothing
; 1839 : 		else if (this->_Getal() == _Right._Getal())
; 1840 : 			{	// same allocator, swap control information
; 1841 : 			this->_Swap_all(_Right);
; 1842 : 			_Swap_bx(_Right);
; 1843 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1844 : 			_STD swap(this->_Myres, _Right._Myres);
; 1845 : 			}
; 1846 : 
; 1847 :  #if _HAS_CPP0X
; 1848 : 		else if (_Alty::propagate_on_container_swap::value)
; 1849 : 			{	// swap allocators and control information
; 1850 : 			this->_Swap_alloc(_Right);
; 1851 : 			_Swap_bx(_Right);
; 1852 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1853 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1854 : 			_STD swap(this->_Myres, _Right._Myres);
; 1855 : 			}
; 1856 :  #endif /* _HAS_CPP0X */
; 1857 : 
; 1858 : 		else
; 1859 : 			{	// different allocator, do multiple assigns
; 1860 : 			_Myt _Tmp = *this;
; 1861 : 
; 1862 : 			*this = _Right;
; 1863 : 			_Right = _Tmp;
; 1864 : 			}
; 1865 : 		}
; 1866 : 
; 1867 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1868 : 		{	// look for _Right beginning at or after _Off
; 1869 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1870 : 		}
; 1871 : 
; 1872 : 	size_type find(const _Elem *_Ptr,
; 1873 : 		size_type _Off, size_type _Count) const
; 1874 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1875 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1876 : 		if (_Count != 0)
; 1877 : 			_DEBUG_POINTER(_Ptr);
; 1878 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1879 : 
; 1880 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1881 : 			return (_Off);	// null string always matches (if inside string)
; 1882 : 
; 1883 : 		size_type _Nm;
; 1884 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1885 : 			{	// room for match, look for it
; 1886 : 			const _Elem *_Uptr, *_Vptr;
; 1887 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1888 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1889 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1890 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1891 : 					return (_Uptr - this->_Myptr());	// found a match
; 1892 : 			}
; 1893 : 
; 1894 : 		return (npos);	// no match
; 1895 : 		}
; 1896 : 
; 1897 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1898 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1899 : 		_DEBUG_POINTER(_Ptr);
; 1900 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1901 : 		}
; 1902 : 
; 1903 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1904 : 		{	// look for _Ch at or after _Off
; 1905 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1906 : 		}
; 1907 : 
; 1908 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1909 : 		{	// look for _Right beginning before _Off
; 1910 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1911 : 		}
; 1912 : 
; 1913 : 	size_type rfind(const _Elem *_Ptr,
; 1914 : 		size_type _Off, size_type _Count) const
; 1915 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1916 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1917 : 		if (_Count != 0)
; 1918 : 			_DEBUG_POINTER(_Ptr);
; 1919 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1920 : 
; 1921 : 		if (_Count == 0)
; 1922 : 			return (_Off < this->_Mysize ? _Off
; 1923 : 				: this->_Mysize);	// null always matches
; 1924 : 		if (_Count <= this->_Mysize)
; 1925 : 			{	// room for match, look for it
; 1926 : 			const _Elem *_Uptr = this->_Myptr() +
; 1927 : 				(_Off < this->_Mysize - _Count ? _Off
; 1928 : 					: this->_Mysize - _Count);
; 1929 : 			for (; ; --_Uptr)
; 1930 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1931 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1932 : 					return (_Uptr - this->_Myptr());	// found a match
; 1933 : 				else if (_Uptr == this->_Myptr())
; 1934 : 					break;	// at beginning, no more chance for match
; 1935 : 			}
; 1936 : 
; 1937 : 		return (npos);	// no match
; 1938 : 		}
; 1939 : 
; 1940 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1941 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1942 : 		_DEBUG_POINTER(_Ptr);
; 1943 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1944 : 		}
; 1945 : 
; 1946 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1947 : 		{	// look for _Ch before _Off
; 1948 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1949 : 		}
; 1950 : 
; 1951 : 	size_type find_first_of(const _Myt& _Right,
; 1952 : 		size_type _Off = 0) const _NOEXCEPT
; 1953 : 		{	// look for one of _Right at or after _Off
; 1954 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1955 : 		}
; 1956 : 
; 1957 : 	size_type find_first_of(const _Elem *_Ptr,
; 1958 : 		size_type _Off, size_type _Count) const
; 1959 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1960 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1961 : 		if (_Count != 0)
; 1962 : 			_DEBUG_POINTER(_Ptr);
; 1963 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1964 : 
; 1965 : 		if (0 < _Count && _Off < this->_Mysize)
; 1966 : 			{	// room for match, look for it
; 1967 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1968 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1969 : 				_Uptr < _Vptr; ++_Uptr)
; 1970 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1971 : 					return (_Uptr - this->_Myptr());	// found a match
; 1972 : 			}
; 1973 : 
; 1974 : 		return (npos);	// no match
; 1975 : 		}
; 1976 : 
; 1977 : 	size_type find_first_of(const _Elem *_Ptr,
; 1978 : 		size_type _Off = 0) const
; 1979 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1980 : 		_DEBUG_POINTER(_Ptr);
; 1981 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 1982 : 		}
; 1983 : 
; 1984 : 	size_type find_first_of(_Elem _Ch,
; 1985 : 		size_type _Off = 0) const
; 1986 : 		{	// look for _Ch at or after _Off
; 1987 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1988 : 		}
; 1989 : 
; 1990 : 	size_type find_last_of(const _Myt& _Right,
; 1991 : 		size_type _Off = npos) const _NOEXCEPT
; 1992 : 		{	// look for one of _Right before _Off
; 1993 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_last_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off, size_type _Count) const
; 1998 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 1999 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2000 : 		if (_Count != 0)
; 2001 : 			_DEBUG_POINTER(_Ptr);
; 2002 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2003 : 
; 2004 : 		if (0 < _Count && 0 < this->_Mysize)
; 2005 : 			{	// worth searching, do it
; 2006 : 			const _Elem *_Uptr = this->_Myptr()
; 2007 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2008 : 			for (; ; --_Uptr)
; 2009 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2010 : 					return (_Uptr - this->_Myptr());	// found a match
; 2011 : 				else if (_Uptr == this->_Myptr())
; 2012 : 					break;	// at beginning, no more chance for match
; 2013 : 			}
; 2014 : 
; 2015 : 		return (npos);	// no match
; 2016 : 		}
; 2017 : 
; 2018 : 	size_type find_last_of(const _Elem *_Ptr,
; 2019 : 		size_type _Off = npos) const
; 2020 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2021 : 		_DEBUG_POINTER(_Ptr);
; 2022 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2023 : 		}
; 2024 : 
; 2025 : 	size_type find_last_of(_Elem _Ch,
; 2026 : 		size_type _Off = npos) const
; 2027 : 		{	// look for _Ch before _Off
; 2028 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2029 : 		}
; 2030 : 
; 2031 : 	size_type find_first_not_of(const _Myt& _Right,
; 2032 : 		size_type _Off = 0) const _NOEXCEPT
; 2033 : 		{	// look for none of _Right at or after _Off
; 2034 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2035 : 			_Right.size()));
; 2036 : 		}
; 2037 : 
; 2038 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2039 : 		size_type _Off, size_type _Count) const
; 2040 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2041 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2042 : 		if (_Count != 0)
; 2043 : 			_DEBUG_POINTER(_Ptr);
; 2044 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2045 : 
; 2046 : 		if (_Off < this->_Mysize)
; 2047 : 			{	// room for match, look for it
; 2048 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2049 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2050 : 				_Uptr < _Vptr; ++_Uptr)
; 2051 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2052 : 					return (_Uptr - this->_Myptr());
; 2053 : 			}
; 2054 : 		return (npos);
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off = 0) const
; 2059 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2060 : 		_DEBUG_POINTER(_Ptr);
; 2061 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2062 : 		}
; 2063 : 
; 2064 : 	size_type find_first_not_of(_Elem _Ch,
; 2065 : 		size_type _Off = 0) const
; 2066 : 		{	// look for non _Ch at or after _Off
; 2067 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2068 : 		}
; 2069 : 
; 2070 : 	size_type find_last_not_of(const _Myt& _Right,
; 2071 : 		size_type _Off = npos) const _NOEXCEPT
; 2072 : 		{	// look for none of _Right before _Off
; 2073 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off, size_type _Count) const
; 2078 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2079 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2080 : 		if (_Count != 0)
; 2081 : 			_DEBUG_POINTER(_Ptr);
; 2082 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2083 : 
; 2084 : 		if (0 < this->_Mysize)
; 2085 : 			{	// worth searching, do it
; 2086 : 			const _Elem *_Uptr = this->_Myptr()
; 2087 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2088 : 			for (; ; --_Uptr)
; 2089 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2090 : 					return (_Uptr - this->_Myptr());
; 2091 : 				else if (_Uptr == this->_Myptr())
; 2092 : 					break;
; 2093 : 			}
; 2094 : 		return (npos);
; 2095 : 		}
; 2096 : 
; 2097 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2098 : 		size_type _Off = npos) const
; 2099 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2100 : 		_DEBUG_POINTER(_Ptr);
; 2101 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2102 : 		}
; 2103 : 
; 2104 : 	size_type find_last_not_of(_Elem _Ch,
; 2105 : 		size_type _Off = npos) const
; 2106 : 		{	// look for non _Ch before _Off
; 2107 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2108 : 		}
; 2109 : 
; 2110 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2111 : 		{	// return [_Off, _Off + _Count) as new string
; 2112 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2113 : 		}
; 2114 : 
; 2115 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2116 : 		{	// compare [0, _Mysize) with _Right
; 2117 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2118 : 		}
; 2119 : 
; 2120 : 	int compare(size_type _Off, size_type _N0,
; 2121 : 		const _Myt& _Right) const
; 2122 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2123 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2124 : 		}
; 2125 : 
; 2126 : 	int compare(size_type _Off,
; 2127 : 		size_type _N0, const _Myt& _Right,
; 2128 : 		size_type _Roff, size_type _Count) const
; 2129 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2130 : 		if (_Right.size() < _Roff)
; 2131 : 			_Xran();	// _Off off end
; 2132 : 		if (_Right._Mysize - _Roff < _Count)
; 2133 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2134 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2135 : 		}
; 2136 : 
; 2137 : 	int compare(const _Elem *_Ptr) const
; 2138 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2139 : 		_DEBUG_POINTER(_Ptr);
; 2140 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2141 : 		}
; 2142 : 
; 2143 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2144 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2145 : 		_DEBUG_POINTER(_Ptr);
; 2146 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2147 : 		}
; 2148 : 
; 2149 : 	int compare(size_type _Off,
; 2150 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2151 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2152 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2153 : 		if (_Count != 0)
; 2154 : 			_DEBUG_POINTER(_Ptr);
; 2155 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2156 : 
; 2157 : 		if (this->_Mysize < _Off)
; 2158 : 			_Xran();	// _Off off end
; 2159 : 		if (this->_Mysize - _Off < _N0)
; 2160 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2161 : 
; 2162 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2163 : 			_N0 < _Count ? _N0 : _Count);
; 2164 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2165 : 			: _N0 == _Count ? 0 : +1);
; 2166 : 		}
; 2167 : 
; 2168 : 	allocator_type get_allocator() const _NOEXCEPT
; 2169 : 		{	// return allocator object for values
; 2170 : 		return (this->_Getal());
; 2171 : 		}
; 2172 : 
; 2173 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2174 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2175 : 		if (_Count == 1)
; 2176 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2177 : 		else
; 2178 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2179 : 		}
; 2180 : 
; 2181 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2182 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2183 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2184 : 		if (max_size() < _Newres)
; 2185 : 			_Newres = _Newsize;	// undo roundup if too big
; 2186 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2187 : 			;
; 2188 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2189 : 			_Newres = this->_Myres
; 2190 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2191 : 		else
; 2192 : 			_Newres = max_size();	// settle for max_size()
; 2193 : 
; 2194 : 		_Elem *_Ptr;
; 2195 : 		_TRY_BEGIN
; 2196 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2197 : 		_CATCH_ALL
; 2198 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2199 : 			_TRY_BEGIN
; 2200 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2201 : 			_CATCH_ALL
; 2202 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2203 : 			_RERAISE;
; 2204 : 			_CATCH_END
; 2205 : 		_CATCH_END
; 2206 : 
; 2207 : 		if (0 < _Oldlen)
; 2208 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2209 : 				_Oldlen);	// copy existing elements
; 2210 : 		_Tidy(true);
; 2211 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2212 : 		this->_Myres = _Newres;
; 2213 : 		_Eos(_Oldlen);
; 2214 : 		}
; 2215 : 
; 2216 : 	void _Eos(size_type _Newsize)
; 2217 : 		{	// set new length and null terminator
; 2218 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  00863	48 89 7d d7	 mov	 QWORD PTR $T13[rbp-105], rdi
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd

; 347  : 		_Left = _Right;

  00867	66 89 7d c7	 mov	 WORD PTR $T13[rbp-121], di
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 735  : 		assign(_Right, 0, npos);

  0086b	49 83 c9 ff	 or	 r9, -1
  0086f	45 33 c0	 xor	 r8d, r8d
  00872	48 8d 55 ef	 lea	 rdx, QWORD PTR filePath$[rbp-121]
  00876	48 8d 4d c7	 lea	 rcx, QWORD PTR $T13[rbp-121]
  0087a	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@AEBV12@_K1@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp

; 272  : 	noTexFShader = new gfxu::FragmentShader(filePath);

  0087f	48 8d 55 c7	 lea	 rdx, QWORD PTR $T13[rbp-121]
  00883	48 8b cb	 mov	 rcx, rbx
  00886	e8 00 00 00 00	 call	 ??0FragmentShader@gfxu@@QEAA@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z ; gfxu::FragmentShader::FragmentShader
  0088b	eb 03		 jmp	 SHORT $LN23@preStart
$LN22@preStart:
  0088d	48 8b c7	 mov	 rax, rdi
$LN23@preStart:
  00890	48 89 05 00 00
	00 00		 mov	 QWORD PTR ?noTexFShader@@3PEAVFragmentShader@gfxu@@EA, rax ; noTexFShader

; 274  : 	noTexShaderProgram = new gfxu::ShaderProgram(noTexVShader, nullptr, noTexFShader);

  00897	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  0089c	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  008a1	48 8b d8	 mov	 rbx, rax
  008a4	48 89 45 b7	 mov	 QWORD PTR $T4[rbp-121], rax
  008a8	48 85 c0	 test	 rax, rax
  008ab	74 27		 je	 SHORT $LN24@preStart
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp

; 379  : {

  008ad	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?noTexVShader@@3PEAVVertexShader@gfxu@@EA ; noTexVShader
  008b4	48 89 08	 mov	 QWORD PTR [rax], rcx
  008b7	48 89 78 08	 mov	 QWORD PTR [rax+8], rdi
  008bb	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?noTexFShader@@3PEAVFragmentShader@gfxu@@EA ; noTexFShader
  008c2	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx
  008c6	c6 40 1c 00	 mov	 BYTE PTR [rax+28], 0

; 380  : 	create();

  008ca	48 8b c8	 mov	 rcx, rax
  008cd	e8 00 00 00 00	 call	 ?create@ShaderProgram@gfxu@@AEAA_NXZ ; gfxu::ShaderProgram::create
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp

; 274  : 	noTexShaderProgram = new gfxu::ShaderProgram(noTexVShader, nullptr, noTexFShader);

  008d2	eb 03		 jmp	 SHORT $LN25@preStart
$LN24@preStart:
  008d4	48 8b df	 mov	 rbx, rdi
$LN25@preStart:
  008d7	48 89 1d 00 00
	00 00		 mov	 QWORD PTR ?noTexShaderProgram@@3PEAVShaderProgram@gfxu@@EA, rbx ; noTexShaderProgram
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp

; 599  : 	MMS.clear();

  008de	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?MMS@Uniforms@gfxu@@2VMatrixStack@2@A ; gfxu::Uniforms::MMS
  008e5	e8 00 00 00 00	 call	 ?clear@MatrixStack@gfxu@@QEAAXXZ ; gfxu::MatrixStack::clear

; 600  : 	PMS.clear();

  008ea	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?PMS@Uniforms@gfxu@@2VMatrixStack@2@A ; gfxu::Uniforms::PMS
  008f1	e8 00 00 00 00	 call	 ?clear@MatrixStack@gfxu@@QEAAXXZ ; gfxu::MatrixStack::clear
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 1099 : 		return (assign(_Right, 0, npos));

  008f6	49 83 c9 ff	 or	 r9, -1
  008fa	45 33 c0	 xor	 r8d, r8d
  008fd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?EXE_DIR@IOUtil@@3V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@A ; IOUtil::EXE_DIR
  00904	48 8d 4d ef	 lea	 rcx, QWORD PTR filePath$[rbp-121]
  00908	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@AEBV12@_K1@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign

; 736  : 		}
; 737  : 
; 738  :  #if _HAS_CPP0X
; 739  : 	basic_string(const _Myt& _Right, const _Alloc& _Al)
; 740  : 		: _Mybase(_Al)
; 741  : 		{	// construct by copying with allocator
; 742  : 		_Tidy();
; 743  : 		assign(_Right, 0, npos);
; 744  : 		}
; 745  :  #endif /* _HAS_CPP0X */
; 746  : 
; 747  : 	basic_string()
; 748  : 		: _Mybase()
; 749  : 		{	// construct empty string
; 750  : 		_Tidy();
; 751  : 		}
; 752  : 
; 753  : 	explicit basic_string(const _Alloc& _Al)
; 754  : 		: _Mybase(_Al)
; 755  : 		{	// construct empty string with allocator
; 756  : 		_Tidy();
; 757  : 		}
; 758  : 
; 759  : 	basic_string(const _Myt& _Right, size_type _Roff,
; 760  : 		size_type _Count = npos)
; 761  : 		: _Mybase(_Right._Getal())
; 762  : 		{	// construct from _Right [_Roff, _Roff + _Count)
; 763  : 		_Tidy();
; 764  : 		assign(_Right, _Roff, _Count);
; 765  : 		}
; 766  : 
; 767  : 	basic_string(const _Myt& _Right, size_type _Roff, size_type _Count,
; 768  : 		const _Alloc& _Al)
; 769  : 		: _Mybase(_Al)
; 770  : 		{	// construct from _Right [_Roff, _Roff + _Count) with allocator
; 771  : 		_Tidy();
; 772  : 		assign(_Right, _Roff, _Count);
; 773  : 		}
; 774  : 
; 775  : 	basic_string(const _Elem *_Ptr, size_type _Count)
; 776  : 		: _Mybase()
; 777  : 		{	// construct from [_Ptr, _Ptr + _Count)
; 778  : 		_Tidy();
; 779  : 		assign(_Ptr, _Count);
; 780  : 		}
; 781  : 
; 782  : 	basic_string(const _Elem *_Ptr, size_type _Count, const _Alloc& _Al)
; 783  : 		: _Mybase(_Al)
; 784  : 		{	// construct from [_Ptr, _Ptr + _Count) with allocator
; 785  : 		_Tidy();
; 786  : 		assign(_Ptr, _Count);
; 787  : 		}
; 788  : 
; 789  : 	basic_string(const _Elem *_Ptr)
; 790  : 		: _Mybase()
; 791  : 		{	// construct from [_Ptr, <null>)
; 792  : 		_Tidy();
; 793  : 		assign(_Ptr);
; 794  : 		}
; 795  : 
; 796  : 	basic_string(const _Elem *_Ptr, const _Alloc& _Al)
; 797  : 		: _Mybase(_Al)
; 798  : 		{	// construct from [_Ptr, <null>) with allocator
; 799  : 		_Tidy();
; 800  : 		assign(_Ptr);
; 801  : 		}
; 802  : 
; 803  : 	basic_string(size_type _Count, _Elem _Ch)
; 804  : 		: _Mybase()
; 805  : 		{	// construct from _Count * _Ch
; 806  : 		_Tidy();
; 807  : 		assign(_Count, _Ch);
; 808  : 		}
; 809  : 
; 810  : 	basic_string(size_type _Count, _Elem _Ch, const _Alloc& _Al)
; 811  : 		: _Mybase(_Al)
; 812  : 		{	// construct from _Count * _Ch with allocator
; 813  : 		_Tidy();
; 814  : 		assign(_Count, _Ch);
; 815  : 		}
; 816  : 
; 817  : 	template<class _Iter>
; 818  : 		basic_string(_Iter _First, _Iter _Last,
; 819  : 			typename enable_if<_Is_iterator<_Iter>::value,
; 820  : 				void>::type ** = 0)
; 821  : 		: _Mybase()
; 822  : 		{	// construct from [_First, _Last)
; 823  : 		_Tidy();
; 824  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 825  : 		}
; 826  : 
; 827  : 	template<class _Iter>
; 828  : 		basic_string(_Iter _First, _Iter _Last, const _Alloc& _Al,
; 829  : 			typename enable_if<_Is_iterator<_Iter>::value,
; 830  : 				void>::type ** = 0)
; 831  : 		: _Mybase(_Al)
; 832  : 		{	// construct from [_First, _Last) with allocator
; 833  : 		_Tidy();
; 834  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 835  : 		}
; 836  : 
; 837  : 	template<class _Iter>
; 838  : 		void _Construct(_Iter _First,
; 839  : 			_Iter _Last, input_iterator_tag)
; 840  : 		{	// initialize from [_First, _Last), input iterators
; 841  : 		_TRY_BEGIN
; 842  : 		for (; _First != _Last; ++_First)
; 843  : 			append((size_type)1, (_Elem)*_First);
; 844  : 		_CATCH_ALL
; 845  : 		_Tidy(true);
; 846  : 		_RERAISE;
; 847  : 		_CATCH_END
; 848  : 		}
; 849  : 
; 850  : 	template<class _Iter>
; 851  : 		void _Construct(_Iter _First,
; 852  : 			_Iter _Last, forward_iterator_tag)
; 853  : 		{	// initialize from [_First, _Last), forward iterators
; 854  : 		_DEBUG_RANGE(_First, _Last);
; 855  : 		size_type _Count = 0;
; 856  : 		_Distance(_First, _Last, _Count);
; 857  : 		reserve(_Count);
; 858  : 
; 859  : 		_TRY_BEGIN
; 860  : 		for (; _First != _Last; ++_First)
; 861  : 			append((size_type)1, (_Elem)*_First);
; 862  : 		_CATCH_ALL
; 863  : 		_Tidy(true);
; 864  : 		_RERAISE;
; 865  : 		_CATCH_END
; 866  : 		}
; 867  : 
; 868  : 	basic_string(const_pointer _First, const_pointer _Last)
; 869  : 		: _Mybase()
; 870  : 		{	// construct from [_First, _Last), const pointers
; 871  : 		_DEBUG_RANGE(_First, _Last);
; 872  : 		_Tidy();
; 873  : 		if (_First != _Last)
; 874  : 			assign(&*_First, _Last - _First);
; 875  : 		}
; 876  : 
; 877  : 	basic_string(const_pointer _First, const_pointer _Last,
; 878  : 		const _Alloc& _Al)
; 879  : 		: _Mybase(_Al)
; 880  : 		{	// construct from [_First, _Last), const pointers
; 881  : 		_DEBUG_RANGE(_First, _Last);
; 882  : 		_Tidy();
; 883  : 		if (_First != _Last)
; 884  : 			assign(&*_First, _Last - _First);
; 885  : 		}
; 886  : 
; 887  : 	basic_string(const_iterator _First, const_iterator _Last)
; 888  : 		: _Mybase()
; 889  : 		{	// construct from [_First, _Last), const_iterators
; 890  : 		_DEBUG_RANGE(_First, _Last);
; 891  : 		_Tidy();
; 892  : 		if (_First != _Last)
; 893  : 			assign(&*_First, _Last - _First);
; 894  : 		}
; 895  : 
; 896  : 	basic_string(_Myt&& _Right) _NOEXCEPT
; 897  : 		: _Mybase(_Right._Getal())
; 898  : 		{	// construct by moving _Right
; 899  : 		_Tidy();
; 900  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 901  : 		}
; 902  : 
; 903  : 	basic_string(_Myt&& _Right, const _Alloc& _Al)
; 904  : 		: _Mybase(_Al)
; 905  : 		{	// construct by moving _Right, allocator
; 906  : 		if (this->_Getal() != _Right._Getal())
; 907  : 			assign(_Right.begin(), _Right.end());
; 908  : 		else
; 909  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 910  : 		}
; 911  : 
; 912  : 	_Myt& operator=(_Myt&& _Right) _NOEXCEPT
; 913  : 		{	// assign by moving _Right
; 914  : 		if (this != &_Right)
; 915  : 			{	// different, assign it
; 916  : 			_Tidy(true);
; 917  : 
; 918  :  #if _HAS_CPP0X
; 919  : 			if (this->_Getal() != _Right._Getal()
; 920  : 				&& _Alty::propagate_on_container_move_assignment::value)
; 921  : 				this->_Change_alloc(_Right._Getal());
; 922  :  #endif /* _HAS_CPP0X */
; 923  : 
; 924  : 			if (this->_Getal() != _Right._Getal())
; 925  : 				assign(_Right.begin(), _Right.end());
; 926  : 			else
; 927  : 				_Assign_rv(_STD forward<_Myt>(_Right));
; 928  : 			}
; 929  : 		return (*this);
; 930  : 		}
; 931  : 
; 932  : 	_Myt& assign(_Myt&& _Right) _NOEXCEPT
; 933  : 		{	// assign by moving _Right
; 934  : 		if (this == &_Right)
; 935  : 			;
; 936  : 		else if (get_allocator() != _Right.get_allocator()
; 937  : 			&& this->_BUF_SIZE <= _Right._Myres)
; 938  : 			*this = _Right;
; 939  : 		else
; 940  : 			{	// not same, clear this and steal from _Right
; 941  : 			_Tidy(true);
; 942  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 943  : 			}
; 944  : 		return (*this);
; 945  : 		}
; 946  : 
; 947  : 	void _Assign_rv(_Myt&& _Right)
; 948  : 		{	// assign by moving _Right
; 949  : 		if (_Right._Myres < this->_BUF_SIZE)
; 950  : 			_Traits::move(this->_Bx._Buf, _Right._Bx._Buf,
; 951  : 				_Right._Mysize + 1);
; 952  : 		else
; 953  : 			{	// copy pointer
; 954  : 			this->_Getal().construct(&this->_Bx._Ptr, _Right._Bx._Ptr);
; 955  : 			_Right._Bx._Ptr = pointer();
; 956  : 			}
; 957  : 		this->_Mysize = _Right._Mysize;
; 958  : 		this->_Myres = _Right._Myres;
; 959  : 		_Right._Tidy();
; 960  : 		}
; 961  : 
; 962  : 	~basic_string() _NOEXCEPT
; 963  : 		{	// destroy the string
; 964  : 		_Tidy(true);
; 965  : 		}
; 966  : 
; 967  : 	_PGLOBAL static const size_type npos;	// bad/missing length/position
; 968  : 
; 969  : 	_Myt& operator=(const _Myt& _Right)
; 970  : 		{	// assign _Right
; 971  : 		if (this != &_Right)
; 972  : 			{	// different, assign it
; 973  :  #if _HAS_CPP0X
; 974  : 			if (this->_Getal() != _Right._Getal()
; 975  : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 976  : 				{	// change allocator before copying
; 977  : 				_Tidy(true);
; 978  : 				this->_Change_alloc(_Right._Getal());
; 979  : 				}
; 980  :  #endif /* _HAS_CPP0X */
; 981  : 
; 982  : 			assign(_Right);
; 983  : 			}
; 984  : 		return (*this);
; 985  : 		}
; 986  : 
; 987  : 	_Myt& operator=(const _Elem *_Ptr)
; 988  : 		{	// assign [_Ptr, <null>)
; 989  : 		return (assign(_Ptr));
; 990  : 		}
; 991  : 
; 992  : 	_Myt& operator=(_Elem _Ch)
; 993  : 		{	// assign 1 * _Ch
; 994  : 		return (assign(1, _Ch));
; 995  : 		}
; 996  : 
; 997  : 	_Myt& operator+=(const _Myt& _Right)
; 998  : 		{	// append _Right
; 999  : 		return (append(_Right));
; 1000 : 		}
; 1001 : 
; 1002 : 	_Myt& operator+=(const _Elem *_Ptr)
; 1003 : 		{	// append [_Ptr, <null>)
; 1004 : 		return (append(_Ptr));
; 1005 : 		}
; 1006 : 
; 1007 : 	_Myt& operator+=(_Elem _Ch)
; 1008 : 		{	// append 1 * _Ch
; 1009 : 		return (append((size_type)1, _Ch));
; 1010 : 		}
; 1011 : 
; 1012 : 	_Myt& append(const _Myt& _Right)
; 1013 : 		{	// append _Right
; 1014 : 		return (append(_Right, 0, npos));
; 1015 : 		}
; 1016 : 
; 1017 : 	_Myt& append(const _Myt& _Right,
; 1018 : 		size_type _Roff, size_type _Count)
; 1019 : 		{	// append _Right [_Roff, _Roff + _Count)
; 1020 : 		if (_Right.size() < _Roff)
; 1021 : 			_Xran();	// _Roff off end
; 1022 : 		size_type _Num = _Right.size() - _Roff;
; 1023 : 		if (_Num < _Count)
; 1024 : 			_Count = _Num;	// trim _Count to size
; 1025 : 		if (npos - this->_Mysize <= _Count)
; 1026 : 			_Xlen();	// result too long
; 1027 : 
; 1028 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1029 : 			{	// make room and append new stuff
; 1030 : 			_Traits::copy(this->_Myptr() + this->_Mysize,
; 1031 : 				_Right._Myptr() + _Roff, _Count);
; 1032 : 			_Eos(_Num);
; 1033 : 			}
; 1034 : 		return (*this);
; 1035 : 		}
; 1036 : 
; 1037 : 	_Myt& append(const _Elem *_Ptr, size_type _Count)
; 1038 : 		{	// append [_Ptr, _Ptr + _Count)
; 1039 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1040 : 		if (_Count != 0)
; 1041 : 			_DEBUG_POINTER(_Ptr);
; 1042 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1043 : 
; 1044 : 		if (_Inside(_Ptr))
; 1045 : 			return (append(*this,
; 1046 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1047 : 		if (npos - this->_Mysize <= _Count)
; 1048 : 			_Xlen();	// result too long
; 1049 : 
; 1050 : 		size_type _Num;
; 1051 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1052 : 			{	// make room and append new stuff
; 1053 : 			_Traits::copy(this->_Myptr() + this->_Mysize, _Ptr, _Count);
; 1054 : 			_Eos(_Num);
; 1055 : 			}
; 1056 : 		return (*this);
; 1057 : 		}
; 1058 : 
; 1059 : 	_Myt& append(const _Elem *_Ptr)
; 1060 : 		{	// append [_Ptr, <null>)
; 1061 : 		_DEBUG_POINTER(_Ptr);
; 1062 : 		return (append(_Ptr, _Traits::length(_Ptr)));

  0090d	41 b8 12 00 00
	00		 mov	 r8d, 18
  00913	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG4294950227
  0091a	48 8d 4d ef	 lea	 rcx, QWORD PTR filePath$[rbp-121]
  0091e	e8 00 00 00 00	 call	 ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@PEB_W_K@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp

; 280  : 	testure = new gfxu::Texture2D(filePath, GL_NEAREST, GL_NEAREST, GL_CLAMP_TO_EDGE, false);

  00923	b9 28 00 00 00	 mov	 ecx, 40			; 00000028H
  00928	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  0092d	48 8b d8	 mov	 rbx, rax
  00930	48 89 45 b7	 mov	 QWORD PTR $T3[rbp-121], rax
  00934	48 85 c0	 test	 rax, rax
  00937	74 33		 je	 SHORT $LN27@preStart
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 2265 : 		this->_Myres = this->_BUF_SIZE - 1;

  00939	48 c7 45 df 07
	00 00 00	 mov	 QWORD PTR $T12[rbp-97], 7

; 1100 : 		}
; 1101 : 
; 1102 : 	_Myt& assign(const _Myt& _Right,
; 1103 : 		size_type _Roff, size_type _Count)
; 1104 : 		{	// assign _Right [_Roff, _Roff + _Count)
; 1105 : 		if (_Right.size() < _Roff)
; 1106 : 			_Xran();	// _Roff off end
; 1107 : 		size_type _Num = _Right.size() - _Roff;
; 1108 : 		if (_Count < _Num)
; 1109 : 			_Num = _Count;	// trim _Num to size
; 1110 : 
; 1111 : 		if (this == &_Right)
; 1112 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring
; 1113 : 		else if (_Grow(_Num))
; 1114 : 			{	// make room and assign new stuff
; 1115 : 			_Traits::copy(this->_Myptr(),
; 1116 : 				_Right._Myptr() + _Roff, _Num);
; 1117 : 			_Eos(_Num);
; 1118 : 			}
; 1119 : 		return (*this);
; 1120 : 		}
; 1121 : 
; 1122 : 	_Myt& assign(const _Elem *_Ptr, size_type _Count)
; 1123 : 		{	// assign [_Ptr, _Ptr + _Count)
; 1124 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1125 : 		if (_Count != 0)
; 1126 : 			_DEBUG_POINTER(_Ptr);
; 1127 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1128 : 
; 1129 : 		if (_Inside(_Ptr))
; 1130 : 			return (assign(*this,
; 1131 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1132 : 
; 1133 : 		if (_Grow(_Count))
; 1134 : 			{	// make room and assign new stuff
; 1135 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);
; 1136 : 			_Eos(_Count);
; 1137 : 			}
; 1138 : 		return (*this);
; 1139 : 		}
; 1140 : 
; 1141 : 	_Myt& assign(const _Elem *_Ptr)
; 1142 : 		{	// assign [_Ptr, <null>)
; 1143 : 		_DEBUG_POINTER(_Ptr);
; 1144 : 		return (assign(_Ptr, _Traits::length(_Ptr)));
; 1145 : 		}
; 1146 : 
; 1147 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1148 : 		{	// assign _Count * _Ch
; 1149 : 		if (_Count == npos)
; 1150 : 			_Xlen();	// result too long
; 1151 : 
; 1152 : 		if (_Grow(_Count))
; 1153 : 			{	// make room and assign new stuff
; 1154 : 			_Chassign(0, _Count, _Ch);
; 1155 : 			_Eos(_Count);
; 1156 : 			}
; 1157 : 		return (*this);
; 1158 : 		}
; 1159 : 
; 1160 : 	template<class _Iter>
; 1161 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1162 : 			_Myt&>::type
; 1163 : 		assign(_Iter _First, _Iter _Last)
; 1164 : 		{	// assign [First, _Last), input iterators
; 1165 : 		return (replace(begin(), end(), _First, _Last));
; 1166 : 		}
; 1167 : 
; 1168 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1169 : 		{	// assign [First, _Last), const pointers
; 1170 : 		return (replace(begin(), end(), _First, _Last));
; 1171 : 		}
; 1172 : 
; 1173 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1174 : 		{	// assign [First, _Last), const_iterators
; 1175 : 		return (replace(begin(), end(), _First, _Last));
; 1176 : 		}
; 1177 : 
; 1178 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1179 : 		{	// insert _Right at _Off
; 1180 : 		return (insert(_Off, _Right, 0, npos));
; 1181 : 		}
; 1182 : 
; 1183 : 	_Myt& insert(size_type _Off,
; 1184 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1185 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1186 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1187 : 			_Xran();	// _Off or _Roff off end
; 1188 : 		size_type _Num = _Right.size() - _Roff;
; 1189 : 		if (_Num < _Count)
; 1190 : 			_Count = _Num;	// trim _Count to size
; 1191 : 		if (npos - this->_Mysize <= _Count)
; 1192 : 			_Xlen();	// result too long
; 1193 : 
; 1194 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1195 : 			{	// make room and insert new stuff
; 1196 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1197 : 				this->_Myptr() + _Off,
; 1198 : 				this->_Mysize - _Off);	// empty out hole
; 1199 : 			if (this == &_Right)
; 1200 : 				_Traits::move(this->_Myptr() + _Off,
; 1201 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1202 : 						_Count);	// substring
; 1203 : 			else
; 1204 : 				_Traits::copy(this->_Myptr() + _Off,
; 1205 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1206 : 			_Eos(_Num);
; 1207 : 			}
; 1208 : 		return (*this);
; 1209 : 		}
; 1210 : 
; 1211 : 	_Myt& insert(size_type _Off,
; 1212 : 		const _Elem *_Ptr, size_type _Count)
; 1213 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1214 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1215 : 		if (_Count != 0)
; 1216 : 			_DEBUG_POINTER(_Ptr);
; 1217 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1218 : 
; 1219 : 		if (_Inside(_Ptr))
; 1220 : 			return (insert(_Off, *this,
; 1221 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1222 : 		if (this->_Mysize < _Off)
; 1223 : 			_Xran();	// _Off off end
; 1224 : 		if (npos - this->_Mysize <= _Count)
; 1225 : 			_Xlen();	// result too long
; 1226 : 		size_type _Num;
; 1227 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1228 : 			{	// make room and insert new stuff
; 1229 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1230 : 				this->_Myptr() + _Off,
; 1231 : 				this->_Mysize - _Off);	// empty out hole
; 1232 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1233 : 			_Eos(_Num);
; 1234 : 			}
; 1235 : 		return (*this);
; 1236 : 		}
; 1237 : 
; 1238 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1239 : 		{	// insert [_Ptr, <null>) at _Off
; 1240 : 		_DEBUG_POINTER(_Ptr);
; 1241 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1242 : 		}
; 1243 : 
; 1244 : 	_Myt& insert(size_type _Off,
; 1245 : 		size_type _Count, _Elem _Ch)
; 1246 : 		{	// insert _Count * _Ch at _Off
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	iterator insert(const_iterator _Where)
; 1264 : 		{	// insert <null> at _Where
; 1265 : 		return (insert(_Where, _Elem()));
; 1266 : 		}
; 1267 : 
; 1268 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1269 : 		{	// insert _Ch at _Where
; 1270 : 		size_type _Off = _Pdif(_Where, begin());
; 1271 : 		insert(_Off, 1, _Ch);
; 1272 : 		return (begin() + _Off);
; 1273 : 		}
; 1274 : 
; 1275 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1276 : 		{	// insert _Count * _Elem at _Where
; 1277 : 		size_type _Off = _Pdif(_Where, begin());
; 1278 : 		insert(_Off, _Count, _Ch);
; 1279 : 		return (begin() + _Off);
; 1280 : 		}
; 1281 : 
; 1282 : 	template<class _Iter>
; 1283 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1284 : 			iterator>::type
; 1285 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1286 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1287 : 		size_type _Off = _Pdif(_Where, begin());
; 1288 : 		replace(_Where, _Where, _First, _Last);
; 1289 : 		return (begin() + _Off);
; 1290 : 		}
; 1291 : 
; 1292 : 	iterator insert(const_iterator _Where,
; 1293 : 		const_pointer _First, const_pointer _Last)
; 1294 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		replace(_Where, _Where, _First, _Last);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where,
; 1301 : 		const_iterator _First, const_iterator _Last)
; 1302 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1303 : 		size_type _Off = _Pdif(_Where, begin());
; 1304 : 		replace(_Where, _Where, _First, _Last);
; 1305 : 		return (begin() + _Off);
; 1306 : 		}
; 1307 : 
; 1308 : 	_Myt& erase(size_type _Off = 0)
; 1309 : 		{	// erase elements [_Off, ...)
; 1310 : 		if (this->_Mysize < _Off)
; 1311 : 			_Xran();	// _Off off end
; 1312 : 		_Eos(_Off);
; 1313 : 		return (*this);
; 1314 : 		}
; 1315 : 
; 1316 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1317 : 		{	// erase elements [_Off, _Off + _Count)
; 1318 : 		if (this->_Mysize < _Off)
; 1319 : 			_Xran();	// _Off off end
; 1320 : 		if (this->_Mysize - _Off <= _Count)
; 1321 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1322 : 		else if (0 < _Count)
; 1323 : 			{	// move elements down
; 1324 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1325 : 			size_type _Newsize = this->_Mysize - _Count;
; 1326 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1327 : 			_Eos(_Newsize);
; 1328 : 			}
; 1329 : 		return (*this);
; 1330 : 		}
; 1331 : 
; 1332 : 	iterator erase(const_iterator _Where)
; 1333 : 		{	// erase element at _Where
; 1334 : 		size_type _Count = _Pdif(_Where, begin());
; 1335 : 		erase(_Count, 1);
; 1336 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1337 : 		}
; 1338 : 
; 1339 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1340 : 		{	// erase substring [_First, _Last)
; 1341 : 		_DEBUG_RANGE(_First, _Last);
; 1342 : 		size_type _Count = _Pdif(_First, begin());
; 1343 : 		erase(_Count, _Pdif(_Last, _First));
; 1344 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1345 : 		}
; 1346 : 
; 1347 : 	void clear() _NOEXCEPT
; 1348 : 		{	// erase all
; 1349 : 		_Eos(0);
; 1350 : 		}
; 1351 : 
; 1352 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1353 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1354 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1355 : 		}
; 1356 : 
; 1357 : 	_Myt& replace(size_type _Off,
; 1358 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1359 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1360 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1361 : 			_Xran();	// _Off or _Roff off end
; 1362 : 		if (this->_Mysize - _Off < _N0)
; 1363 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1364 : 		size_type _Num = _Right.size() - _Roff;
; 1365 : 		if (_Num < _Count)
; 1366 : 			_Count = _Num;	// trim _Count to size
; 1367 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1368 : 			_Xlen();	// result too long
; 1369 : 
; 1370 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1371 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1372 : 		if (this->_Mysize < _Newsize)
; 1373 : 			_Grow(_Newsize);
; 1374 : 
; 1375 : 		if (this != &_Right)
; 1376 : 			{	// no overlap, just move down and copy in new stuff
; 1377 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1378 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1379 : 			_Traits::copy(this->_Myptr() + _Off,
; 1380 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1381 : 			}
; 1382 : 		else if (_Count <= _N0)
; 1383 : 			{	// hole doesn't get larger, just copy in substring
; 1384 : 			_Traits::move(this->_Myptr() + _Off,
; 1385 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1386 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1387 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1388 : 			}
; 1389 : 		else if (_Roff <= _Off)
; 1390 : 			{	// hole gets larger, substring begins before hole
; 1391 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1392 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1393 : 			_Traits::move(this->_Myptr() + _Off,
; 1394 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1395 : 			}
; 1396 : 		else if (_Off + _N0 <= _Roff)
; 1397 : 			{	// hole gets larger, substring begins after hole
; 1398 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1399 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1400 : 			_Traits::move(this->_Myptr() + _Off,
; 1401 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1402 : 				_Count);	// fill hole
; 1403 : 			}
; 1404 : 		else
; 1405 : 			{	// hole gets larger, substring begins in hole
; 1406 : 			_Traits::move(this->_Myptr() + _Off,
; 1407 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1408 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1409 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1410 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1411 : 				this->_Myptr() + _Roff + _Count,
; 1412 : 				_Count - _N0);	// fill rest of new hole
; 1413 : 			}
; 1414 : 
; 1415 : 		_Eos(_Newsize);
; 1416 : 		return (*this);
; 1417 : 		}
; 1418 : 
; 1419 : 	_Myt& replace(size_type _Off,
; 1420 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1421 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1422 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1423 : 		if (_Count != 0)
; 1424 : 			_DEBUG_POINTER(_Ptr);
; 1425 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1426 : 
; 1427 : 		if (_Inside(_Ptr))
; 1428 : 			return (replace(_Off, _N0, *this,
; 1429 : 				_Ptr - this->_Myptr(),
; 1430 : 				_Count));	// substring, replace carefully
; 1431 : 		if (this->_Mysize < _Off)
; 1432 : 			_Xran();	// _Off off end
; 1433 : 		if (this->_Mysize - _Off < _N0)
; 1434 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1435 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1436 : 			_Xlen();	// result too long
; 1437 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1438 : 
; 1439 : 		if (_Count < _N0)
; 1440 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1441 : 				this->_Myptr() + _Off + _N0,
; 1442 : 				_Nm);	// smaller hole, move tail up
; 1443 : 		size_type _Num;
; 1444 : 		if ((0 < _Count || 0 < _N0)
; 1445 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1446 : 			{	// make room and rearrange
; 1447 : 			if (_N0 < _Count)
; 1448 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1449 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1450 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1451 : 			_Eos(_Num);
; 1452 : 			}
; 1453 : 		return (*this);
; 1454 : 		}
; 1455 : 
; 1456 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1457 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1458 : 		_DEBUG_POINTER(_Ptr);
; 1459 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1460 : 		}
; 1461 : 
; 1462 : 	_Myt& replace(size_type _Off,
; 1463 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1464 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1465 : 		if (this->_Mysize < _Off)
; 1466 : 			_Xran();	// _Off off end
; 1467 : 		if (this->_Mysize - _Off < _N0)
; 1468 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1469 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1470 : 			_Xlen();	// result too long
; 1471 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1472 : 
; 1473 : 		if (_Count < _N0)
; 1474 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1475 : 				this->_Myptr() + _Off + _N0,
; 1476 : 				_Nm);	// smaller hole, move tail up
; 1477 : 		size_type _Num;
; 1478 : 		if ((0 < _Count || 0 < _N0)
; 1479 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1480 : 			{	// make room and rearrange
; 1481 : 			if (_N0 < _Count)
; 1482 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1483 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1484 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1485 : 			_Eos(_Num);
; 1486 : 			}
; 1487 : 		return (*this);
; 1488 : 		}
; 1489 : 
; 1490 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1491 : 		const _Myt& _Right)
; 1492 : 		{	// replace [_First, _Last) with _Right
; 1493 : 		return (replace(
; 1494 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1495 : 		}
; 1496 : 
; 1497 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1498 : 		const _Elem *_Ptr, size_type _Count)
; 1499 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1500 : 		return (replace(
; 1501 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1502 : 		}
; 1503 : 
; 1504 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1505 : 		const _Elem *_Ptr)
; 1506 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1507 : 		return (replace(
; 1508 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1509 : 		}
; 1510 : 
; 1511 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1512 : 		size_type _Count, _Elem _Ch)
; 1513 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1514 : 		return (replace(
; 1515 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1516 : 		}
; 1517 : 
; 1518 : 	template<class _Iter>
; 1519 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1520 : 			_Myt&>::type
; 1521 : 		replace(const_iterator _First, const_iterator _Last,
; 1522 : 			_Iter _First2, _Iter _Last2)
; 1523 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1524 : 		_Myt _Right(_First2, _Last2);
; 1525 : 		replace(_First, _Last, _Right);
; 1526 : 		return (*this);
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const_pointer _First2, const_pointer _Last2)
; 1531 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1532 : 		if (_First2 == _Last2)
; 1533 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1534 : 		else
; 1535 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1536 : 				&*_First2, _Last2 - _First2);
; 1537 : 		return (*this);
; 1538 : 		}
; 1539 : 
; 1540 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1541 : 		pointer _First2, pointer _Last2)
; 1542 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1543 : 		if (_First2 == _Last2)
; 1544 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1545 : 		else
; 1546 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1547 : 				&*_First2, _Last2 - _First2);
; 1548 : 		return (*this);
; 1549 : 		}
; 1550 : 
; 1551 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1552 : 		const_iterator _First2, const_iterator _Last2)
; 1553 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1554 : 		if (_First2 == _Last2)
; 1555 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1556 : 		else
; 1557 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1558 : 				&*_First2, _Last2 - _First2);
; 1559 : 		return (*this);
; 1560 : 		}
; 1561 : 
; 1562 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1563 : 		iterator _First2, iterator _Last2)
; 1564 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1565 : 		if (_First2 == _Last2)
; 1566 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1567 : 		else
; 1568 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1569 : 				&*_First2, _Last2 - _First2);
; 1570 : 		return (*this);
; 1571 : 		}
; 1572 : 
; 1573 : 	iterator begin() _NOEXCEPT
; 1574 : 		{	// return iterator for beginning of mutable sequence
; 1575 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1576 : 		}
; 1577 : 
; 1578 : 	const_iterator begin() const _NOEXCEPT
; 1579 : 		{	// return iterator for beginning of nonmutable sequence
; 1580 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1581 : 		}
; 1582 : 
; 1583 : 	iterator end() _NOEXCEPT
; 1584 : 		{	// return iterator for end of mutable sequence
; 1585 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1586 : 		}
; 1587 : 
; 1588 : 	const_iterator end() const _NOEXCEPT
; 1589 : 		{	// return iterator for end of nonmutable sequence
; 1590 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1591 : 		}
; 1592 : 
; 1593 : 	reverse_iterator rbegin() _NOEXCEPT
; 1594 : 		{	// return iterator for beginning of reversed mutable sequence
; 1595 : 		return (reverse_iterator(end()));
; 1596 : 		}
; 1597 : 
; 1598 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1600 : 		return (const_reverse_iterator(end()));
; 1601 : 		}
; 1602 : 
; 1603 : 	reverse_iterator rend() _NOEXCEPT
; 1604 : 		{	// return iterator for end of reversed mutable sequence
; 1605 : 		return (reverse_iterator(begin()));
; 1606 : 		}
; 1607 : 
; 1608 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1609 : 		{	// return iterator for end of reversed nonmutable sequence
; 1610 : 		return (const_reverse_iterator(begin()));
; 1611 : 		}
; 1612 : 
; 1613 :  #if _HAS_CPP0X
; 1614 : 	const_iterator cbegin() const _NOEXCEPT
; 1615 : 		{	// return iterator for beginning of nonmutable sequence
; 1616 : 		return (((const _Myt *)this)->begin());
; 1617 : 		}
; 1618 : 
; 1619 : 	const_iterator cend() const _NOEXCEPT
; 1620 : 		{	// return iterator for end of nonmutable sequence
; 1621 : 		return (((const _Myt *)this)->end());
; 1622 : 		}
; 1623 : 
; 1624 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1625 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1626 : 		return (((const _Myt *)this)->rbegin());
; 1627 : 		}
; 1628 : 
; 1629 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1630 : 		{	// return iterator for end of reversed nonmutable sequence
; 1631 : 		return (((const _Myt *)this)->rend());
; 1632 : 		}
; 1633 : 
; 1634 : 	void shrink_to_fit()
; 1635 : 		{	// reduce capacity
; 1636 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1637 : 			{	// worth shrinking, do it
; 1638 : 			_Myt _Tmp(*this);
; 1639 : 			swap(_Tmp);
; 1640 : 			}
; 1641 : 		}
; 1642 :  #endif /* _HAS_CPP0X */
; 1643 : 
; 1644 : 	reference at(size_type _Off)
; 1645 : 		{	// subscript mutable sequence with checking
; 1646 : 		if (this->_Mysize <= _Off)
; 1647 : 			_Xran();	// _Off off end
; 1648 : 		return (this->_Myptr()[_Off]);
; 1649 : 		}
; 1650 : 
; 1651 : 	const_reference at(size_type _Off) const
; 1652 : 		{	// subscript nonmutable sequence with checking
; 1653 : 		if (this->_Mysize <= _Off)
; 1654 : 			_Xran();	// _Off off end
; 1655 : 		return (this->_Myptr()[_Off]);
; 1656 : 		}
; 1657 : 
; 1658 : 	reference operator[](size_type _Off)
; 1659 : 		{	// subscript mutable sequence
; 1660 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1661 : 		if (this->_Mysize < _Off)	// sic
; 1662 : 			_DEBUG_ERROR("string subscript out of range");
; 1663 : 
; 1664 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1665 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1666 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1667 : 
; 1668 : 		return (this->_Myptr()[_Off]);
; 1669 : 		}
; 1670 : 
; 1671 : 	const_reference operator[](size_type _Off) const
; 1672 : 		{	// subscript nonmutable sequence
; 1673 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1674 : 		if (this->_Mysize < _Off)	// sic
; 1675 : 			_DEBUG_ERROR("string subscript out of range");
; 1676 : 
; 1677 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1678 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1679 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1680 : 
; 1681 : 		return (this->_Myptr()[_Off]);
; 1682 : 		}
; 1683 : 
; 1684 : 	void push_back(_Elem _Ch)
; 1685 : 		{	// insert element at end
; 1686 : 		insert(end(), _Ch);
; 1687 : 		}
; 1688 : 
; 1689 :  #if _HAS_CPP0X
; 1690 : 	void pop_back()
; 1691 : 		{	// erase element at end
; 1692 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1693 : 		}
; 1694 : 
; 1695 : 	reference front()
; 1696 : 		{	// return first element of mutable sequence
; 1697 : 		return (*begin());
; 1698 : 		}
; 1699 : 
; 1700 : 	const_reference front() const
; 1701 : 		{	// return first element of nonmutable sequence
; 1702 : 		return (*begin());
; 1703 : 		}
; 1704 : 
; 1705 : 	reference back()
; 1706 : 		{	// return last element of mutable sequence
; 1707 : 		return (*(end() - 1));
; 1708 : 		}
; 1709 : 
; 1710 : 	const_reference back() const
; 1711 : 		{	// return last element of nonmutable sequence
; 1712 : 		return (*(end() - 1));
; 1713 : 		}
; 1714 :  #endif /* _HAS_CPP0X */
; 1715 : 
; 1716 : 	const _Elem *c_str() const _NOEXCEPT
; 1717 : 		{	// return pointer to null-terminated nonmutable array
; 1718 : 		return (this->_Myptr());
; 1719 : 		}
; 1720 : 
; 1721 : 	const _Elem *data() const _NOEXCEPT
; 1722 : 		{	// return pointer to nonmutable array
; 1723 : 		return (c_str());
; 1724 : 		}
; 1725 : 
; 1726 : 	size_type length() const _NOEXCEPT
; 1727 : 		{	// return length of sequence
; 1728 : 		return (this->_Mysize);
; 1729 : 		}
; 1730 : 
; 1731 : 	size_type size() const _NOEXCEPT
; 1732 : 		{	// return length of sequence
; 1733 : 		return (this->_Mysize);
; 1734 : 		}
; 1735 : 
; 1736 : 	size_type max_size() const _NOEXCEPT
; 1737 : 		{	// return maximum possible length of sequence
; 1738 : 		size_type _Num = this->_Getal().max_size();
; 1739 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1740 : 		}
; 1741 : 
; 1742 : 	void resize(size_type _Newsize)
; 1743 : 		{	// determine new length, padding with null elements as needed
; 1744 : 		resize(_Newsize, _Elem());
; 1745 : 		}
; 1746 : 
; 1747 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1748 : 		{	// determine new length, padding with _Ch elements as needed
; 1749 : 		if (_Newsize <= this->_Mysize)
; 1750 : 			_Eos(_Newsize);
; 1751 : 		else
; 1752 : 			append(_Newsize - this->_Mysize, _Ch);
; 1753 : 		}
; 1754 : 
; 1755 : 	size_type capacity() const _NOEXCEPT
; 1756 : 		{	// return current length of allocated storage
; 1757 : 		return (this->_Myres);
; 1758 : 		}
; 1759 : 
; 1760 : 	void reserve(size_type _Newcap = 0)
; 1761 : 		{	// determine new minimum length of allocated storage
; 1762 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1763 : 			{	// change reservation
; 1764 : 			size_type _Size = this->_Mysize;
; 1765 : 			if (_Grow(_Newcap, true))
; 1766 : 				_Eos(_Size);
; 1767 : 			}
; 1768 : 		}
; 1769 : 
; 1770 : 	bool empty() const _NOEXCEPT
; 1771 : 		{	// test if sequence is empty
; 1772 : 		return (this->_Mysize == 0);
; 1773 : 		}
; 1774 : 
; 1775 : 	_SCL_INSECURE_DEPRECATE
; 1776 : 
; 1777 : 	size_type copy(_Elem *_Ptr,
; 1778 : 		size_type _Count, size_type _Off = 0) const
; 1779 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1780 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1781 : 		if (_Count != 0)
; 1782 : 			_DEBUG_POINTER(_Ptr);
; 1783 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1784 : 
; 1785 : 		if (this->_Mysize < _Off)
; 1786 : 			_Xran();	// _Off off end
; 1787 : 		if (this->_Mysize - _Off < _Count)
; 1788 : 			_Count = this->_Mysize - _Off;
; 1789 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1790 : 		return (_Count);
; 1791 : 		}
; 1792 : 
; 1793 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1794 : 		size_type _Count, size_type _Off = 0) const
; 1795 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1796 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1797 : 		if (_Count != 0)
; 1798 : 			_DEBUG_POINTER(_Dest);
; 1799 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1800 : 
; 1801 : 		if (this->_Mysize < _Off)
; 1802 : 			_Xran();	// _Off off end
; 1803 : 		if (this->_Mysize - _Off < _Count)
; 1804 : 			_Count = this->_Mysize - _Off;
; 1805 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1806 : 		return (_Count);
; 1807 : 		}
; 1808 : 
; 1809 : 	void _Swap_bx(_Myt& _Right)
; 1810 : 		{	// exchange _Bx with _Right._Bx
; 1811 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1812 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1813 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1814 : 			else
; 1815 : 				{	// swap large with small
; 1816 : 				pointer _Ptr = this->_Bx._Ptr;
; 1817 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1818 : 				_Traits::copy(this->_Bx._Buf,
; 1819 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1820 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1821 : 				}
; 1822 : 		else
; 1823 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1824 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1825 : 			else
; 1826 : 				{	// swap small with large
; 1827 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1828 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1829 : 				_Traits::copy(_Right._Bx._Buf,
; 1830 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1831 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1832 : 				}
; 1833 : 		}
; 1834 : 
; 1835 : 	void swap(_Myt& _Right)
; 1836 : 		{	// exchange contents with _Right
; 1837 : 		if (this == &_Right)
; 1838 : 			;	// same object, do nothing
; 1839 : 		else if (this->_Getal() == _Right._Getal())
; 1840 : 			{	// same allocator, swap control information
; 1841 : 			this->_Swap_all(_Right);
; 1842 : 			_Swap_bx(_Right);
; 1843 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1844 : 			_STD swap(this->_Myres, _Right._Myres);
; 1845 : 			}
; 1846 : 
; 1847 :  #if _HAS_CPP0X
; 1848 : 		else if (_Alty::propagate_on_container_swap::value)
; 1849 : 			{	// swap allocators and control information
; 1850 : 			this->_Swap_alloc(_Right);
; 1851 : 			_Swap_bx(_Right);
; 1852 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1853 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1854 : 			_STD swap(this->_Myres, _Right._Myres);
; 1855 : 			}
; 1856 :  #endif /* _HAS_CPP0X */
; 1857 : 
; 1858 : 		else
; 1859 : 			{	// different allocator, do multiple assigns
; 1860 : 			_Myt _Tmp = *this;
; 1861 : 
; 1862 : 			*this = _Right;
; 1863 : 			_Right = _Tmp;
; 1864 : 			}
; 1865 : 		}
; 1866 : 
; 1867 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1868 : 		{	// look for _Right beginning at or after _Off
; 1869 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1870 : 		}
; 1871 : 
; 1872 : 	size_type find(const _Elem *_Ptr,
; 1873 : 		size_type _Off, size_type _Count) const
; 1874 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1875 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1876 : 		if (_Count != 0)
; 1877 : 			_DEBUG_POINTER(_Ptr);
; 1878 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1879 : 
; 1880 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1881 : 			return (_Off);	// null string always matches (if inside string)
; 1882 : 
; 1883 : 		size_type _Nm;
; 1884 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1885 : 			{	// room for match, look for it
; 1886 : 			const _Elem *_Uptr, *_Vptr;
; 1887 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1888 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1889 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1890 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1891 : 					return (_Uptr - this->_Myptr());	// found a match
; 1892 : 			}
; 1893 : 
; 1894 : 		return (npos);	// no match
; 1895 : 		}
; 1896 : 
; 1897 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1898 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1899 : 		_DEBUG_POINTER(_Ptr);
; 1900 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1901 : 		}
; 1902 : 
; 1903 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1904 : 		{	// look for _Ch at or after _Off
; 1905 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1906 : 		}
; 1907 : 
; 1908 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1909 : 		{	// look for _Right beginning before _Off
; 1910 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1911 : 		}
; 1912 : 
; 1913 : 	size_type rfind(const _Elem *_Ptr,
; 1914 : 		size_type _Off, size_type _Count) const
; 1915 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1916 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1917 : 		if (_Count != 0)
; 1918 : 			_DEBUG_POINTER(_Ptr);
; 1919 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1920 : 
; 1921 : 		if (_Count == 0)
; 1922 : 			return (_Off < this->_Mysize ? _Off
; 1923 : 				: this->_Mysize);	// null always matches
; 1924 : 		if (_Count <= this->_Mysize)
; 1925 : 			{	// room for match, look for it
; 1926 : 			const _Elem *_Uptr = this->_Myptr() +
; 1927 : 				(_Off < this->_Mysize - _Count ? _Off
; 1928 : 					: this->_Mysize - _Count);
; 1929 : 			for (; ; --_Uptr)
; 1930 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1931 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1932 : 					return (_Uptr - this->_Myptr());	// found a match
; 1933 : 				else if (_Uptr == this->_Myptr())
; 1934 : 					break;	// at beginning, no more chance for match
; 1935 : 			}
; 1936 : 
; 1937 : 		return (npos);	// no match
; 1938 : 		}
; 1939 : 
; 1940 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1941 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1942 : 		_DEBUG_POINTER(_Ptr);
; 1943 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1944 : 		}
; 1945 : 
; 1946 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1947 : 		{	// look for _Ch before _Off
; 1948 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1949 : 		}
; 1950 : 
; 1951 : 	size_type find_first_of(const _Myt& _Right,
; 1952 : 		size_type _Off = 0) const _NOEXCEPT
; 1953 : 		{	// look for one of _Right at or after _Off
; 1954 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1955 : 		}
; 1956 : 
; 1957 : 	size_type find_first_of(const _Elem *_Ptr,
; 1958 : 		size_type _Off, size_type _Count) const
; 1959 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1960 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1961 : 		if (_Count != 0)
; 1962 : 			_DEBUG_POINTER(_Ptr);
; 1963 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1964 : 
; 1965 : 		if (0 < _Count && _Off < this->_Mysize)
; 1966 : 			{	// room for match, look for it
; 1967 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1968 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1969 : 				_Uptr < _Vptr; ++_Uptr)
; 1970 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1971 : 					return (_Uptr - this->_Myptr());	// found a match
; 1972 : 			}
; 1973 : 
; 1974 : 		return (npos);	// no match
; 1975 : 		}
; 1976 : 
; 1977 : 	size_type find_first_of(const _Elem *_Ptr,
; 1978 : 		size_type _Off = 0) const
; 1979 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1980 : 		_DEBUG_POINTER(_Ptr);
; 1981 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 1982 : 		}
; 1983 : 
; 1984 : 	size_type find_first_of(_Elem _Ch,
; 1985 : 		size_type _Off = 0) const
; 1986 : 		{	// look for _Ch at or after _Off
; 1987 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1988 : 		}
; 1989 : 
; 1990 : 	size_type find_last_of(const _Myt& _Right,
; 1991 : 		size_type _Off = npos) const _NOEXCEPT
; 1992 : 		{	// look for one of _Right before _Off
; 1993 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_last_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off, size_type _Count) const
; 1998 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 1999 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2000 : 		if (_Count != 0)
; 2001 : 			_DEBUG_POINTER(_Ptr);
; 2002 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2003 : 
; 2004 : 		if (0 < _Count && 0 < this->_Mysize)
; 2005 : 			{	// worth searching, do it
; 2006 : 			const _Elem *_Uptr = this->_Myptr()
; 2007 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2008 : 			for (; ; --_Uptr)
; 2009 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2010 : 					return (_Uptr - this->_Myptr());	// found a match
; 2011 : 				else if (_Uptr == this->_Myptr())
; 2012 : 					break;	// at beginning, no more chance for match
; 2013 : 			}
; 2014 : 
; 2015 : 		return (npos);	// no match
; 2016 : 		}
; 2017 : 
; 2018 : 	size_type find_last_of(const _Elem *_Ptr,
; 2019 : 		size_type _Off = npos) const
; 2020 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2021 : 		_DEBUG_POINTER(_Ptr);
; 2022 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2023 : 		}
; 2024 : 
; 2025 : 	size_type find_last_of(_Elem _Ch,
; 2026 : 		size_type _Off = npos) const
; 2027 : 		{	// look for _Ch before _Off
; 2028 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2029 : 		}
; 2030 : 
; 2031 : 	size_type find_first_not_of(const _Myt& _Right,
; 2032 : 		size_type _Off = 0) const _NOEXCEPT
; 2033 : 		{	// look for none of _Right at or after _Off
; 2034 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2035 : 			_Right.size()));
; 2036 : 		}
; 2037 : 
; 2038 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2039 : 		size_type _Off, size_type _Count) const
; 2040 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2041 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2042 : 		if (_Count != 0)
; 2043 : 			_DEBUG_POINTER(_Ptr);
; 2044 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2045 : 
; 2046 : 		if (_Off < this->_Mysize)
; 2047 : 			{	// room for match, look for it
; 2048 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2049 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2050 : 				_Uptr < _Vptr; ++_Uptr)
; 2051 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2052 : 					return (_Uptr - this->_Myptr());
; 2053 : 			}
; 2054 : 		return (npos);
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off = 0) const
; 2059 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2060 : 		_DEBUG_POINTER(_Ptr);
; 2061 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2062 : 		}
; 2063 : 
; 2064 : 	size_type find_first_not_of(_Elem _Ch,
; 2065 : 		size_type _Off = 0) const
; 2066 : 		{	// look for non _Ch at or after _Off
; 2067 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2068 : 		}
; 2069 : 
; 2070 : 	size_type find_last_not_of(const _Myt& _Right,
; 2071 : 		size_type _Off = npos) const _NOEXCEPT
; 2072 : 		{	// look for none of _Right before _Off
; 2073 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off, size_type _Count) const
; 2078 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2079 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2080 : 		if (_Count != 0)
; 2081 : 			_DEBUG_POINTER(_Ptr);
; 2082 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2083 : 
; 2084 : 		if (0 < this->_Mysize)
; 2085 : 			{	// worth searching, do it
; 2086 : 			const _Elem *_Uptr = this->_Myptr()
; 2087 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2088 : 			for (; ; --_Uptr)
; 2089 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2090 : 					return (_Uptr - this->_Myptr());
; 2091 : 				else if (_Uptr == this->_Myptr())
; 2092 : 					break;
; 2093 : 			}
; 2094 : 		return (npos);
; 2095 : 		}
; 2096 : 
; 2097 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2098 : 		size_type _Off = npos) const
; 2099 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2100 : 		_DEBUG_POINTER(_Ptr);
; 2101 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2102 : 		}
; 2103 : 
; 2104 : 	size_type find_last_not_of(_Elem _Ch,
; 2105 : 		size_type _Off = npos) const
; 2106 : 		{	// look for non _Ch before _Off
; 2107 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2108 : 		}
; 2109 : 
; 2110 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2111 : 		{	// return [_Off, _Off + _Count) as new string
; 2112 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2113 : 		}
; 2114 : 
; 2115 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2116 : 		{	// compare [0, _Mysize) with _Right
; 2117 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2118 : 		}
; 2119 : 
; 2120 : 	int compare(size_type _Off, size_type _N0,
; 2121 : 		const _Myt& _Right) const
; 2122 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2123 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2124 : 		}
; 2125 : 
; 2126 : 	int compare(size_type _Off,
; 2127 : 		size_type _N0, const _Myt& _Right,
; 2128 : 		size_type _Roff, size_type _Count) const
; 2129 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2130 : 		if (_Right.size() < _Roff)
; 2131 : 			_Xran();	// _Off off end
; 2132 : 		if (_Right._Mysize - _Roff < _Count)
; 2133 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2134 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2135 : 		}
; 2136 : 
; 2137 : 	int compare(const _Elem *_Ptr) const
; 2138 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2139 : 		_DEBUG_POINTER(_Ptr);
; 2140 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2141 : 		}
; 2142 : 
; 2143 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2144 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2145 : 		_DEBUG_POINTER(_Ptr);
; 2146 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2147 : 		}
; 2148 : 
; 2149 : 	int compare(size_type _Off,
; 2150 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2151 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2152 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2153 : 		if (_Count != 0)
; 2154 : 			_DEBUG_POINTER(_Ptr);
; 2155 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2156 : 
; 2157 : 		if (this->_Mysize < _Off)
; 2158 : 			_Xran();	// _Off off end
; 2159 : 		if (this->_Mysize - _Off < _N0)
; 2160 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2161 : 
; 2162 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2163 : 			_N0 < _Count ? _N0 : _Count);
; 2164 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2165 : 			: _N0 == _Count ? 0 : +1);
; 2166 : 		}
; 2167 : 
; 2168 : 	allocator_type get_allocator() const _NOEXCEPT
; 2169 : 		{	// return allocator object for values
; 2170 : 		return (this->_Getal());
; 2171 : 		}
; 2172 : 
; 2173 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2174 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2175 : 		if (_Count == 1)
; 2176 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2177 : 		else
; 2178 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2179 : 		}
; 2180 : 
; 2181 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2182 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2183 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2184 : 		if (max_size() < _Newres)
; 2185 : 			_Newres = _Newsize;	// undo roundup if too big
; 2186 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2187 : 			;
; 2188 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2189 : 			_Newres = this->_Myres
; 2190 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2191 : 		else
; 2192 : 			_Newres = max_size();	// settle for max_size()
; 2193 : 
; 2194 : 		_Elem *_Ptr;
; 2195 : 		_TRY_BEGIN
; 2196 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2197 : 		_CATCH_ALL
; 2198 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2199 : 			_TRY_BEGIN
; 2200 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2201 : 			_CATCH_ALL
; 2202 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2203 : 			_RERAISE;
; 2204 : 			_CATCH_END
; 2205 : 		_CATCH_END
; 2206 : 
; 2207 : 		if (0 < _Oldlen)
; 2208 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2209 : 				_Oldlen);	// copy existing elements
; 2210 : 		_Tidy(true);
; 2211 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2212 : 		this->_Myres = _Newres;
; 2213 : 		_Eos(_Oldlen);
; 2214 : 		}
; 2215 : 
; 2216 : 	void _Eos(size_type _Newsize)
; 2217 : 		{	// set new length and null terminator
; 2218 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  00941	48 89 7d d7	 mov	 QWORD PTR $T12[rbp-105], rdi
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd

; 347  : 		_Left = _Right;

  00945	66 89 7d c7	 mov	 WORD PTR $T12[rbp-121], di
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 735  : 		assign(_Right, 0, npos);

  00949	49 83 c9 ff	 or	 r9, -1
  0094d	45 33 c0	 xor	 r8d, r8d
  00950	48 8d 55 ef	 lea	 rdx, QWORD PTR filePath$[rbp-121]
  00954	48 8d 4d c7	 lea	 rcx, QWORD PTR $T12[rbp-121]
  00958	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@AEBV12@_K1@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp

; 280  : 	testure = new gfxu::Texture2D(filePath, GL_NEAREST, GL_NEAREST, GL_CLAMP_TO_EDGE, false);

  0095d	48 8d 55 c7	 lea	 rdx, QWORD PTR $T12[rbp-121]
  00961	48 8b cb	 mov	 rcx, rbx
  00964	e8 00 00 00 00	 call	 ??0Texture2D@gfxu@@QEAA@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@III_N@Z ; gfxu::Texture2D::Texture2D
  00969	48 8b f8	 mov	 rdi, rax
$LN27@preStart:
  0096c	48 89 3d 00 00
	00 00		 mov	 QWORD PTR ?testure@@3PEAVTexture2D@gfxu@@EA, rdi ; testure

; 281  : 
; 282  : 	glClearColor(0.5f, 0.875f, 1.0f, 1.0f);

  00973	0f 28 df	 movaps	 xmm3, xmm7
  00976	0f 28 d7	 movaps	 xmm2, xmm7
  00979	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@3f600000
  00981	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f000000
  00989	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_glClearColor

; 283  : 	glEnable(GL_DEPTH_TEST);

  0098f	b9 71 0b 00 00	 mov	 ecx, 2929		; 00000b71H
  00994	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_glEnable

; 284  : 	glEnable(GL_CULL_FACE);

  0099a	b9 44 0b 00 00	 mov	 ecx, 2884		; 00000b44H
  0099f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_glEnable

; 285  : 	glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);

  009a5	ba 03 03 00 00	 mov	 edx, 771		; 00000303H
  009aa	8d 4a ff	 lea	 ecx, QWORD PTR [rdx-1]
  009ad	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_glBlendFunc
  009b3	90		 npad	 1
$LN44@preStart:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 2256 : 		else if (this->_BUF_SIZE <= this->_Myres)

  009b4	48 83 7d 07 08	 cmp	 QWORD PTR filePath$[rbp-97], 8
  009b9	72 09		 jb	 SHORT $LN875@preStart
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 586  : 		::operator delete(_Ptr);

  009bb	48 8b 4d ef	 mov	 rcx, QWORD PTR filePath$[rbp-121]
  009bf	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
$LN875@preStart:
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp

; 286  : }

  009c4	48 8b 4d 0f	 mov	 rcx, QWORD PTR __$ArrayPad$[rbp-121]
  009c8	48 33 cc	 xor	 rcx, rsp
  009cb	e8 00 00 00 00	 call	 __security_check_cookie
  009d0	4c 8d 9c 24 c0
	00 00 00	 lea	 r11, QWORD PTR [rsp+192]
  009d8	49 8b 5b 20	 mov	 rbx, QWORD PTR [r11+32]
  009dc	49 8b 73 28	 mov	 rsi, QWORD PTR [r11+40]
  009e0	49 8b 7b 30	 mov	 rdi, QWORD PTR [r11+48]
  009e4	41 0f 28 73 f0	 movaps	 xmm6, XMMWORD PTR [r11-16]
  009e9	41 0f 28 7b e0	 movaps	 xmm7, XMMWORD PTR [r11-32]
  009ee	45 0f 28 43 d0	 movaps	 xmm8, XMMWORD PTR [r11-48]
  009f3	49 8b e3	 mov	 rsp, r11
  009f6	41 5f		 pop	 r15
  009f8	41 5e		 pop	 r14
  009fa	5d		 pop	 rbp
  009fb	c3		 ret	 0
?preStart@RenderThread@@UEAAXXZ ENDP			; RenderThread::preStart
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
error$1 = 48
error$2 = 48
$T3 = 48
$T4 = 48
$T5 = 48
$T6 = 48
$T7 = 48
$T8 = 48
$T9 = 48
error$10 = 56
error$11 = 56
$T12 = 64
$T13 = 64
$T14 = 64
$T15 = 64
$T16 = 64
$T17 = 64
$T18 = 96
filePath$ = 104
__$ArrayPad$ = 136
this$ = 224
?dtor$0@?0??preStart@RenderThread@@UEAAXXZ@4HA PROC	; `RenderThread::preStart'::`1'::dtor$0
  00000	48 8d 8a 68 00
	00 00		 lea	 rcx, QWORD PTR filePath$[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
?dtor$0@?0??preStart@RenderThread@@UEAAXXZ@4HA ENDP	; `RenderThread::preStart'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
error$1 = 48
error$2 = 48
$T3 = 48
$T4 = 48
$T5 = 48
$T6 = 48
$T7 = 48
$T8 = 48
$T9 = 48
error$10 = 56
error$11 = 56
$T12 = 64
$T13 = 64
$T14 = 64
$T15 = 64
$T16 = 64
$T17 = 64
$T18 = 96
filePath$ = 104
__$ArrayPad$ = 136
this$ = 224
?dtor$4@?0??preStart@RenderThread@@UEAAXXZ@4HA PROC	; `RenderThread::preStart'::`1'::dtor$4
  0000c	48 8b 8a 30 00
	00 00		 mov	 rcx, QWORD PTR $T9[rdx]
  00013	e9 00 00 00 00	 jmp	 ??3@YAXPEAX@Z		; operator delete
?dtor$4@?0??preStart@RenderThread@@UEAAXXZ@4HA ENDP	; `RenderThread::preStart'::`1'::dtor$4
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
error$1 = 48
error$2 = 48
$T3 = 48
$T4 = 48
$T5 = 48
$T6 = 48
$T7 = 48
$T8 = 48
$T9 = 48
error$10 = 56
error$11 = 56
$T12 = 64
$T13 = 64
$T14 = 64
$T15 = 64
$T16 = 64
$T17 = 64
$T18 = 96
filePath$ = 104
__$ArrayPad$ = 136
this$ = 224
?dtor$6@?0??preStart@RenderThread@@UEAAXXZ@4HA PROC	; `RenderThread::preStart'::`1'::dtor$6
  00018	48 8b 8a 30 00
	00 00		 mov	 rcx, QWORD PTR $T8[rdx]
  0001f	e9 00 00 00 00	 jmp	 ??3@YAXPEAX@Z		; operator delete
?dtor$6@?0??preStart@RenderThread@@UEAAXXZ@4HA ENDP	; `RenderThread::preStart'::`1'::dtor$6
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
error$1 = 48
error$2 = 48
$T3 = 48
$T4 = 48
$T5 = 48
$T6 = 48
$T7 = 48
$T8 = 48
$T9 = 48
error$10 = 56
error$11 = 56
$T12 = 64
$T13 = 64
$T14 = 64
$T15 = 64
$T16 = 64
$T17 = 64
$T18 = 96
filePath$ = 104
__$ArrayPad$ = 136
this$ = 224
?dtor$8@?0??preStart@RenderThread@@UEAAXXZ@4HA PROC	; `RenderThread::preStart'::`1'::dtor$8
  00024	48 8b 8a 30 00
	00 00		 mov	 rcx, QWORD PTR $T7[rdx]
  0002b	e9 00 00 00 00	 jmp	 ??3@YAXPEAX@Z		; operator delete
?dtor$8@?0??preStart@RenderThread@@UEAAXXZ@4HA ENDP	; `RenderThread::preStart'::`1'::dtor$8
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
error$1 = 48
error$2 = 48
$T3 = 48
$T4 = 48
$T5 = 48
$T6 = 48
$T7 = 48
$T8 = 48
$T9 = 48
error$10 = 56
error$11 = 56
$T12 = 64
$T13 = 64
$T14 = 64
$T15 = 64
$T16 = 64
$T17 = 64
$T18 = 96
filePath$ = 104
__$ArrayPad$ = 136
this$ = 224
?dtor$9@?0??preStart@RenderThread@@UEAAXXZ@4HA PROC	; `RenderThread::preStart'::`1'::dtor$9
  00030	48 8b 8a 30 00
	00 00		 mov	 rcx, QWORD PTR $T6[rdx]
  00037	e9 00 00 00 00	 jmp	 ??3@YAXPEAX@Z		; operator delete
?dtor$9@?0??preStart@RenderThread@@UEAAXXZ@4HA ENDP	; `RenderThread::preStart'::`1'::dtor$9
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
error$1 = 48
error$2 = 48
$T3 = 48
$T4 = 48
$T5 = 48
$T6 = 48
$T7 = 48
$T8 = 48
$T9 = 48
error$10 = 56
error$11 = 56
$T12 = 64
$T13 = 64
$T14 = 64
$T15 = 64
$T16 = 64
$T17 = 64
$T18 = 96
filePath$ = 104
__$ArrayPad$ = 136
this$ = 224
?dtor$11@?0??preStart@RenderThread@@UEAAXXZ@4HA PROC	; `RenderThread::preStart'::`1'::dtor$11
  0003c	48 8b 8a 30 00
	00 00		 mov	 rcx, QWORD PTR $T5[rdx]
  00043	e9 00 00 00 00	 jmp	 ??3@YAXPEAX@Z		; operator delete
?dtor$11@?0??preStart@RenderThread@@UEAAXXZ@4HA ENDP	; `RenderThread::preStart'::`1'::dtor$11
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
error$1 = 48
error$2 = 48
$T3 = 48
$T4 = 48
$T5 = 48
$T6 = 48
$T7 = 48
$T8 = 48
$T9 = 48
error$10 = 56
error$11 = 56
$T12 = 64
$T13 = 64
$T14 = 64
$T15 = 64
$T16 = 64
$T17 = 64
$T18 = 96
filePath$ = 104
__$ArrayPad$ = 136
this$ = 224
?dtor$13@?0??preStart@RenderThread@@UEAAXXZ@4HA PROC	; `RenderThread::preStart'::`1'::dtor$13
  00048	48 8b 8a 30 00
	00 00		 mov	 rcx, QWORD PTR $T4[rdx]
  0004f	e9 00 00 00 00	 jmp	 ??3@YAXPEAX@Z		; operator delete
?dtor$13@?0??preStart@RenderThread@@UEAAXXZ@4HA ENDP	; `RenderThread::preStart'::`1'::dtor$13
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
error$1 = 48
error$2 = 48
$T3 = 48
$T4 = 48
$T5 = 48
$T6 = 48
$T7 = 48
$T8 = 48
$T9 = 48
error$10 = 56
error$11 = 56
$T12 = 64
$T13 = 64
$T14 = 64
$T15 = 64
$T16 = 64
$T17 = 64
$T18 = 96
filePath$ = 104
__$ArrayPad$ = 136
this$ = 224
?dtor$14@?0??preStart@RenderThread@@UEAAXXZ@4HA PROC	; `RenderThread::preStart'::`1'::dtor$14
  00054	48 8b 8a 30 00
	00 00		 mov	 rcx, QWORD PTR $T3[rdx]
  0005b	e9 00 00 00 00	 jmp	 ??3@YAXPEAX@Z		; operator delete
?dtor$14@?0??preStart@RenderThread@@UEAAXXZ@4HA ENDP	; `RenderThread::preStart'::`1'::dtor$14
text$x	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\window.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\window.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp
;	COMDAT ?postStop@RenderThread@@UEAAXXZ
_TEXT	SEGMENT
this$ = 48
?postStop@RenderThread@@UEAAXXZ PROC			; RenderThread::postStop, COMDAT

; 289  : {

$LN44:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 290  : 	delete grid;

  00006	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?grid@@3PEAVVertexStream@gfxu@@EA ; grid
  0000d	48 85 c9	 test	 rcx, rcx
  00010	74 0a		 je	 SHORT $LN3@postStop
  00012	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00015	ba 01 00 00 00	 mov	 edx, 1
  0001a	ff 10		 call	 QWORD PTR [rax]
$LN3@postStop:

; 291  : 	delete square;

  0001c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?square@@3PEAVVertexStream@gfxu@@EA ; square
  00023	48 85 c9	 test	 rcx, rcx
  00026	74 0a		 je	 SHORT $LN5@postStop
  00028	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  0002b	ba 01 00 00 00	 mov	 edx, 1
  00030	ff 10		 call	 QWORD PTR [rax]
$LN5@postStop:

; 292  : 	delete normalVShader;

  00032	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?normalVShader@@3PEAVVertexShader@gfxu@@EA ; normalVShader
  00039	48 85 c9	 test	 rcx, rcx
  0003c	74 05		 je	 SHORT $LN7@postStop
  0003e	e8 00 00 00 00	 call	 ??_GVertexShader@gfxu@@QEAAPEAXI@Z
$LN7@postStop:

; 293  : 	delete normalFShader;

  00043	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?normalFShader@@3PEAVFragmentShader@gfxu@@EA ; normalFShader
  0004a	48 85 c9	 test	 rcx, rcx
  0004d	74 05		 je	 SHORT $LN9@postStop
  0004f	e8 00 00 00 00	 call	 ??_GFragmentShader@gfxu@@QEAAPEAXI@Z
$LN9@postStop:

; 294  : 	delete normalShaderProgram;

  00054	48 8b 1d 00 00
	00 00		 mov	 rbx, QWORD PTR ?normalShaderProgram@@3PEAVShaderProgram@gfxu@@EA ; normalShaderProgram
  0005b	48 85 db	 test	 rbx, rbx
  0005e	74 19		 je	 SHORT $LN21@postStop
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp

; 385  : 	glUseProgram(0);

  00060	33 c9		 xor	 ecx, ecx
  00062	ff 15 00 00 00
	00		 call	 QWORD PTR __glewUseProgram

; 386  : 	glDeleteProgram(object);

  00068	8b 4b 18	 mov	 ecx, DWORD PTR [rbx+24]
  0006b	ff 15 00 00 00
	00		 call	 QWORD PTR __glewDeleteProgram
  00071	48 8b cb	 mov	 rcx, rbx
  00074	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
$LN21@postStop:
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp

; 295  : 	delete noTexVShader;

  00079	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?noTexVShader@@3PEAVVertexShader@gfxu@@EA ; noTexVShader
  00080	48 85 c9	 test	 rcx, rcx
  00083	74 05		 je	 SHORT $LN13@postStop
  00085	e8 00 00 00 00	 call	 ??_GVertexShader@gfxu@@QEAAPEAXI@Z
$LN13@postStop:

; 296  : 	delete noTexFShader;

  0008a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?noTexFShader@@3PEAVFragmentShader@gfxu@@EA ; noTexFShader
  00091	48 85 c9	 test	 rcx, rcx
  00094	74 05		 je	 SHORT $LN15@postStop
  00096	e8 00 00 00 00	 call	 ??_GFragmentShader@gfxu@@QEAAPEAXI@Z
$LN15@postStop:

; 297  : 	delete noTexShaderProgram;

  0009b	48 8b 1d 00 00
	00 00		 mov	 rbx, QWORD PTR ?noTexShaderProgram@@3PEAVShaderProgram@gfxu@@EA ; noTexShaderProgram
  000a2	48 85 db	 test	 rbx, rbx
  000a5	74 19		 je	 SHORT $LN26@postStop
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp

; 385  : 	glUseProgram(0);

  000a7	33 c9		 xor	 ecx, ecx
  000a9	ff 15 00 00 00
	00		 call	 QWORD PTR __glewUseProgram

; 386  : 	glDeleteProgram(object);

  000af	8b 4b 18	 mov	 ecx, DWORD PTR [rbx+24]
  000b2	ff 15 00 00 00
	00		 call	 QWORD PTR __glewDeleteProgram
  000b8	48 8b cb	 mov	 rcx, rbx
  000bb	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
$LN26@postStop:
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp

; 298  : 	delete testure;

  000c0	48 8b 1d 00 00
	00 00		 mov	 rbx, QWORD PTR ?testure@@3PEAVTexture2D@gfxu@@EA ; testure
  000c7	48 85 db	 test	 rbx, rbx
  000ca	74 2a		 je	 SHORT $LN31@postStop
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp

; 664  : 	if(data != nullptr)

  000cc	48 8b 4b 18	 mov	 rcx, QWORD PTR [rbx+24]
  000d0	48 85 c9	 test	 rcx, rcx
  000d3	74 05		 je	 SHORT $LN35@postStop

; 665  : 	{
; 666  : 		delete[] data;

  000d5	e8 00 00 00 00	 call	 ??_V@YAXPEAX@Z		; operator delete[]
$LN35@postStop:

; 667  : 	}
; 668  : 
; 669  : 	if(uploaded)

  000da	80 7b 11 00	 cmp	 BYTE PTR [rbx+17], 0
  000de	74 0e		 je	 SHORT $LN34@postStop

; 670  : 	{
; 671  : 		glDeleteTextures(1, &object);

  000e0	48 8b d3	 mov	 rdx, rbx
  000e3	b9 01 00 00 00	 mov	 ecx, 1
  000e8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_glDeleteTextures
$LN34@postStop:
  000ee	48 8b cb	 mov	 rcx, rbx
  000f1	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
$LN31@postStop:
; File c:\users\glenn\documents\github\wind\project\wind\wind\window.cpp

; 239  : 	if(hRC)

  000f6	48 8b 1d 00 00
	00 00		 mov	 rbx, QWORD PTR ?instance@GLWindow@@2PEAV1@EA ; GLWindow::instance
  000fd	48 83 7b 20 00	 cmp	 QWORD PTR [rbx+32], 0
  00102	74 1a		 je	 SHORT $LN38@postStop

; 240  : 	{
; 241  : 		if(!wglMakeCurrent(NULL, NULL))

  00104	33 d2		 xor	 edx, edx
  00106	33 c9		 xor	 ecx, ecx
  00108	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_wglMakeCurrent

; 246  : 		if(!wglDeleteContext(hRC))

  0010e	48 8b 4b 20	 mov	 rcx, QWORD PTR [rbx+32]
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp

; 301  : }

  00112	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00116	5b		 pop	 rbx
; File c:\users\glenn\documents\github\wind\project\wind\wind\window.cpp

; 246  : 		if(!wglDeleteContext(hRC))

  00117	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_wglDeleteContext
$LN38@postStop:
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp

  0011e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00122	5b		 pop	 rbx
  00123	c3		 ret	 0
?postStop@RenderThread@@UEAAXXZ ENDP			; RenderThread::postStop
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
;	COMDAT ??_GVertexShader@gfxu@@QEAAPEAXI@Z
_TEXT	SEGMENT
$T1 = 32
this$ = 64
__flags$dead$ = 72
??_GVertexShader@gfxu@@QEAAPEAXI@Z PROC			; gfxu::VertexShader::`scalar deleting destructor', COMDAT
$LN45:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	53		 push	 rbx
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 c7 44 24 20
	fe ff ff ff	 mov	 QWORD PTR $T1[rsp], -2
  00013	48 8b d9	 mov	 rbx, rcx
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp

; 336  : {

  00016	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7Shader@gfxu@@6B@
  0001d	48 89 01	 mov	 QWORD PTR [rcx], rax

; 337  : 	if(compiled)

  00020	80 79 2c 00	 cmp	 BYTE PTR [rcx+44], 0
  00024	74 0a		 je	 SHORT $LN7@scalar

; 338  : 	{
; 339  : 		glDeleteShader(object);

  00026	8b 49 28	 mov	 ecx, DWORD PTR [rcx+40]
  00029	ff 15 00 00 00
	00		 call	 QWORD PTR __glewDeleteShader
  0002f	90		 npad	 1
$LN7@scalar:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 2256 : 		else if (this->_BUF_SIZE <= this->_Myres)

  00030	48 83 7b 20 08	 cmp	 QWORD PTR [rbx+32], 8
  00035	72 09		 jb	 SHORT $LN33@scalar
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 586  : 		::operator delete(_Ptr);

  00037	48 8b 4b 08	 mov	 rcx, QWORD PTR [rbx+8]
  0003b	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
$LN33@scalar:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 2265 : 		this->_Myres = this->_BUF_SIZE - 1;

  00040	48 c7 43 20 07
	00 00 00	 mov	 QWORD PTR [rbx+32], 7

; 2218 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  00048	33 c0		 xor	 eax, eax
  0004a	48 89 43 18	 mov	 QWORD PTR [rbx+24], rax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd

; 347  : 		_Left = _Right;

  0004e	66 89 43 08	 mov	 WORD PTR [rbx+8], ax
  00052	48 8b cb	 mov	 rcx, rbx
  00055	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
  0005a	48 8b c3	 mov	 rax, rbx
  0005d	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00061	5b		 pop	 rbx
  00062	c3		 ret	 0
??_GVertexShader@gfxu@@QEAAPEAXI@Z ENDP			; gfxu::VertexShader::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
__flags$dead$ = 72
?dtor$1@?0???_GVertexShader@gfxu@@QEAAPEAXI@Z@4HA PROC	; `gfxu::VertexShader::`scalar deleting destructor''::`1'::dtor$1
  00000	48 8b 8a 40 00
	00 00		 mov	 rcx, QWORD PTR this$[rdx]
  00007	48 83 c1 08	 add	 rcx, 8
  0000b	e9 00 00 00 00	 jmp	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
?dtor$1@?0???_GVertexShader@gfxu@@QEAAPEAXI@Z@4HA ENDP	; `gfxu::VertexShader::`scalar deleting destructor''::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
;	COMDAT ??_GFragmentShader@gfxu@@QEAAPEAXI@Z
_TEXT	SEGMENT
$T1 = 32
this$ = 64
__flags$dead$ = 72
??_GFragmentShader@gfxu@@QEAAPEAXI@Z PROC		; gfxu::FragmentShader::`scalar deleting destructor', COMDAT
$LN45:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	53		 push	 rbx
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 c7 44 24 20
	fe ff ff ff	 mov	 QWORD PTR $T1[rsp], -2
  00013	48 8b d9	 mov	 rbx, rcx
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp

; 336  : {

  00016	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7Shader@gfxu@@6B@
  0001d	48 89 01	 mov	 QWORD PTR [rcx], rax

; 337  : 	if(compiled)

  00020	80 79 2c 00	 cmp	 BYTE PTR [rcx+44], 0
  00024	74 0a		 je	 SHORT $LN7@scalar

; 338  : 	{
; 339  : 		glDeleteShader(object);

  00026	8b 49 28	 mov	 ecx, DWORD PTR [rcx+40]
  00029	ff 15 00 00 00
	00		 call	 QWORD PTR __glewDeleteShader
  0002f	90		 npad	 1
$LN7@scalar:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 2256 : 		else if (this->_BUF_SIZE <= this->_Myres)

  00030	48 83 7b 20 08	 cmp	 QWORD PTR [rbx+32], 8
  00035	72 09		 jb	 SHORT $LN33@scalar
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 586  : 		::operator delete(_Ptr);

  00037	48 8b 4b 08	 mov	 rcx, QWORD PTR [rbx+8]
  0003b	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
$LN33@scalar:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 2265 : 		this->_Myres = this->_BUF_SIZE - 1;

  00040	48 c7 43 20 07
	00 00 00	 mov	 QWORD PTR [rbx+32], 7

; 2218 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  00048	33 c0		 xor	 eax, eax
  0004a	48 89 43 18	 mov	 QWORD PTR [rbx+24], rax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd

; 347  : 		_Left = _Right;

  0004e	66 89 43 08	 mov	 WORD PTR [rbx+8], ax
  00052	48 8b cb	 mov	 rcx, rbx
  00055	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
  0005a	48 8b c3	 mov	 rax, rbx
  0005d	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00061	5b		 pop	 rbx
  00062	c3		 ret	 0
??_GFragmentShader@gfxu@@QEAAPEAXI@Z ENDP		; gfxu::FragmentShader::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
__flags$dead$ = 72
?dtor$1@?0???_GFragmentShader@gfxu@@QEAAPEAXI@Z@4HA PROC ; `gfxu::FragmentShader::`scalar deleting destructor''::`1'::dtor$1
  00000	48 8b 8a 40 00
	00 00		 mov	 rcx, QWORD PTR this$[rdx]
  00007	48 83 c1 08	 add	 rcx, 8
  0000b	e9 00 00 00 00	 jmp	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
?dtor$1@?0???_GFragmentShader@gfxu@@QEAAPEAXI@Z@4HA ENDP ; `gfxu::FragmentShader::`scalar deleting destructor''::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp
;	COMDAT ??_GShaderProgram@gfxu@@QEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$dead$ = 56
??_GShaderProgram@gfxu@@QEAAPEAXI@Z PROC		; gfxu::ShaderProgram::`scalar deleting destructor', COMDAT
$LN7:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 385  : 	glUseProgram(0);

  00009	33 c9		 xor	 ecx, ecx
  0000b	ff 15 00 00 00
	00		 call	 QWORD PTR __glewUseProgram

; 386  : 	glDeleteProgram(object);

  00011	8b 4b 18	 mov	 ecx, DWORD PTR [rbx+24]
  00014	ff 15 00 00 00
	00		 call	 QWORD PTR __glewDeleteProgram
  0001a	48 8b cb	 mov	 rcx, rbx
  0001d	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
  00022	48 8b c3	 mov	 rax, rbx
  00025	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00029	5b		 pop	 rbx
  0002a	c3		 ret	 0
??_GShaderProgram@gfxu@@QEAAPEAXI@Z ENDP		; gfxu::ShaderProgram::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp
;	COMDAT ??_GTexture2D@gfxu@@QEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$dead$ = 56
??_GTexture2D@gfxu@@QEAAPEAXI@Z PROC			; gfxu::Texture2D::`scalar deleting destructor', COMDAT
$LN9:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 664  : 	if(data != nullptr)

  00009	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  0000d	48 85 c9	 test	 rcx, rcx
  00010	74 05		 je	 SHORT $LN5@scalar

; 665  : 	{
; 666  : 		delete[] data;

  00012	e8 00 00 00 00	 call	 ??_V@YAXPEAX@Z		; operator delete[]
$LN5@scalar:

; 667  : 	}
; 668  : 
; 669  : 	if(uploaded)

  00017	80 7b 11 00	 cmp	 BYTE PTR [rbx+17], 0
  0001b	74 0e		 je	 SHORT $LN4@scalar

; 670  : 	{
; 671  : 		glDeleteTextures(1, &object);

  0001d	48 8b d3	 mov	 rdx, rbx
  00020	b9 01 00 00 00	 mov	 ecx, 1
  00025	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_glDeleteTextures
$LN4@scalar:
  0002b	48 8b cb	 mov	 rcx, rbx
  0002e	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
  00033	48 8b c3	 mov	 rax, rbx
  00036	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003a	5b		 pop	 rbx
  0003b	c3		 ret	 0
??_GTexture2D@gfxu@@QEAAPEAXI@Z ENDP			; gfxu::Texture2D::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
;	COMDAT ??1VertexShader@gfxu@@QEAA@XZ
_TEXT	SEGMENT
$T1 = 32
this$ = 64
??1VertexShader@gfxu@@QEAA@XZ PROC			; gfxu::VertexShader::~VertexShader, COMDAT
$LN42:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	53		 push	 rbx
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 c7 44 24 20
	fe ff ff ff	 mov	 QWORD PTR $T1[rsp], -2
  00013	48 8b d9	 mov	 rbx, rcx
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp

; 336  : {

  00016	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7Shader@gfxu@@6B@
  0001d	48 89 01	 mov	 QWORD PTR [rcx], rax

; 337  : 	if(compiled)

  00020	80 79 2c 00	 cmp	 BYTE PTR [rcx+44], 0
  00024	74 0a		 je	 SHORT $LN4@VertexShad

; 338  : 	{
; 339  : 		glDeleteShader(object);

  00026	8b 49 28	 mov	 ecx, DWORD PTR [rcx+40]
  00029	ff 15 00 00 00
	00		 call	 QWORD PTR __glewDeleteShader
  0002f	90		 npad	 1
$LN4@VertexShad:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 2256 : 		else if (this->_BUF_SIZE <= this->_Myres)

  00030	48 83 7b 20 08	 cmp	 QWORD PTR [rbx+32], 8
  00035	72 09		 jb	 SHORT $LN30@VertexShad
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 586  : 		::operator delete(_Ptr);

  00037	48 8b 4b 08	 mov	 rcx, QWORD PTR [rbx+8]
  0003b	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
$LN30@VertexShad:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 2265 : 		this->_Myres = this->_BUF_SIZE - 1;

  00040	48 c7 43 20 07
	00 00 00	 mov	 QWORD PTR [rbx+32], 7

; 2218 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  00048	33 c0		 xor	 eax, eax
  0004a	48 89 43 18	 mov	 QWORD PTR [rbx+24], rax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd

; 347  : 		_Left = _Right;

  0004e	66 89 43 08	 mov	 WORD PTR [rbx+8], ax
  00052	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00056	5b		 pop	 rbx
  00057	c3		 ret	 0
??1VertexShader@gfxu@@QEAA@XZ ENDP			; gfxu::VertexShader::~VertexShader
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
?dtor$1@?0???1VertexShader@gfxu@@QEAA@XZ@4HA PROC	; `gfxu::VertexShader::~VertexShader'::`1'::dtor$1
  00000	48 8b 8a 40 00
	00 00		 mov	 rcx, QWORD PTR this$[rdx]
  00007	48 83 c1 08	 add	 rcx, 8
  0000b	e9 00 00 00 00	 jmp	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
?dtor$1@?0???1VertexShader@gfxu@@QEAA@XZ@4HA ENDP	; `gfxu::VertexShader::~VertexShader'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
;	COMDAT ??1FragmentShader@gfxu@@QEAA@XZ
_TEXT	SEGMENT
$T1 = 32
this$ = 64
??1FragmentShader@gfxu@@QEAA@XZ PROC			; gfxu::FragmentShader::~FragmentShader, COMDAT
$LN42:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	53		 push	 rbx
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 c7 44 24 20
	fe ff ff ff	 mov	 QWORD PTR $T1[rsp], -2
  00013	48 8b d9	 mov	 rbx, rcx
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp

; 336  : {

  00016	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7Shader@gfxu@@6B@
  0001d	48 89 01	 mov	 QWORD PTR [rcx], rax

; 337  : 	if(compiled)

  00020	80 79 2c 00	 cmp	 BYTE PTR [rcx+44], 0
  00024	74 0a		 je	 SHORT $LN4@FragmentSh

; 338  : 	{
; 339  : 		glDeleteShader(object);

  00026	8b 49 28	 mov	 ecx, DWORD PTR [rcx+40]
  00029	ff 15 00 00 00
	00		 call	 QWORD PTR __glewDeleteShader
  0002f	90		 npad	 1
$LN4@FragmentSh:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 2256 : 		else if (this->_BUF_SIZE <= this->_Myres)

  00030	48 83 7b 20 08	 cmp	 QWORD PTR [rbx+32], 8
  00035	72 09		 jb	 SHORT $LN30@FragmentSh
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 586  : 		::operator delete(_Ptr);

  00037	48 8b 4b 08	 mov	 rcx, QWORD PTR [rbx+8]
  0003b	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
$LN30@FragmentSh:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 2265 : 		this->_Myres = this->_BUF_SIZE - 1;

  00040	48 c7 43 20 07
	00 00 00	 mov	 QWORD PTR [rbx+32], 7

; 2218 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  00048	33 c0		 xor	 eax, eax
  0004a	48 89 43 18	 mov	 QWORD PTR [rbx+24], rax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd

; 347  : 		_Left = _Right;

  0004e	66 89 43 08	 mov	 WORD PTR [rbx+8], ax
  00052	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00056	5b		 pop	 rbx
  00057	c3		 ret	 0
??1FragmentShader@gfxu@@QEAA@XZ ENDP			; gfxu::FragmentShader::~FragmentShader
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
?dtor$1@?0???1FragmentShader@gfxu@@QEAA@XZ@4HA PROC	; `gfxu::FragmentShader::~FragmentShader'::`1'::dtor$1
  00000	48 8b 8a 40 00
	00 00		 mov	 rcx, QWORD PTR this$[rdx]
  00007	48 83 c1 08	 add	 rcx, 8
  0000b	e9 00 00 00 00	 jmp	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
?dtor$1@?0???1FragmentShader@gfxu@@QEAA@XZ@4HA ENDP	; `gfxu::FragmentShader::~FragmentShader'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV01@AEBV01@@Z
_TEXT	SEGMENT
this$ = 48
_Right$ = 56
??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV01@AEBV01@@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::operator=, COMDAT

; 970  : 		{	// assign _Right

$LN59:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 971  : 		if (this != &_Right)

  00009	48 3b ca	 cmp	 rcx, rdx
  0000c	74 0c		 je	 SHORT $LN57@operator

; 986  : 
; 987  : 	_Myt& operator=(const _Elem *_Ptr)
; 988  : 		{	// assign [_Ptr, <null>)
; 989  : 		return (assign(_Ptr));
; 990  : 		}
; 991  : 
; 992  : 	_Myt& operator=(_Elem _Ch)
; 993  : 		{	// assign 1 * _Ch
; 994  : 		return (assign(1, _Ch));
; 995  : 		}
; 996  : 
; 997  : 	_Myt& operator+=(const _Myt& _Right)
; 998  : 		{	// append _Right
; 999  : 		return (append(_Right));
; 1000 : 		}
; 1001 : 
; 1002 : 	_Myt& operator+=(const _Elem *_Ptr)
; 1003 : 		{	// append [_Ptr, <null>)
; 1004 : 		return (append(_Ptr));
; 1005 : 		}
; 1006 : 
; 1007 : 	_Myt& operator+=(_Elem _Ch)
; 1008 : 		{	// append 1 * _Ch
; 1009 : 		return (append((size_type)1, _Ch));
; 1010 : 		}
; 1011 : 
; 1012 : 	_Myt& append(const _Myt& _Right)
; 1013 : 		{	// append _Right
; 1014 : 		return (append(_Right, 0, npos));
; 1015 : 		}
; 1016 : 
; 1017 : 	_Myt& append(const _Myt& _Right,
; 1018 : 		size_type _Roff, size_type _Count)
; 1019 : 		{	// append _Right [_Roff, _Roff + _Count)
; 1020 : 		if (_Right.size() < _Roff)
; 1021 : 			_Xran();	// _Roff off end
; 1022 : 		size_type _Num = _Right.size() - _Roff;
; 1023 : 		if (_Num < _Count)
; 1024 : 			_Count = _Num;	// trim _Count to size
; 1025 : 		if (npos - this->_Mysize <= _Count)
; 1026 : 			_Xlen();	// result too long
; 1027 : 
; 1028 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1029 : 			{	// make room and append new stuff
; 1030 : 			_Traits::copy(this->_Myptr() + this->_Mysize,
; 1031 : 				_Right._Myptr() + _Roff, _Count);
; 1032 : 			_Eos(_Num);
; 1033 : 			}
; 1034 : 		return (*this);
; 1035 : 		}
; 1036 : 
; 1037 : 	_Myt& append(const _Elem *_Ptr, size_type _Count)
; 1038 : 		{	// append [_Ptr, _Ptr + _Count)
; 1039 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1040 : 		if (_Count != 0)
; 1041 : 			_DEBUG_POINTER(_Ptr);
; 1042 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1043 : 
; 1044 : 		if (_Inside(_Ptr))
; 1045 : 			return (append(*this,
; 1046 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1047 : 		if (npos - this->_Mysize <= _Count)
; 1048 : 			_Xlen();	// result too long
; 1049 : 
; 1050 : 		size_type _Num;
; 1051 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1052 : 			{	// make room and append new stuff
; 1053 : 			_Traits::copy(this->_Myptr() + this->_Mysize, _Ptr, _Count);
; 1054 : 			_Eos(_Num);
; 1055 : 			}
; 1056 : 		return (*this);
; 1057 : 		}
; 1058 : 
; 1059 : 	_Myt& append(const _Elem *_Ptr)
; 1060 : 		{	// append [_Ptr, <null>)
; 1061 : 		_DEBUG_POINTER(_Ptr);
; 1062 : 		return (append(_Ptr, _Traits::length(_Ptr)));
; 1063 : 		}
; 1064 : 
; 1065 : 	_Myt& append(size_type _Count, _Elem _Ch)
; 1066 : 		{	// append _Count * _Ch
; 1067 : 		if (npos - this->_Mysize <= _Count)
; 1068 : 			_Xlen();	// result too long
; 1069 : 
; 1070 : 		size_type _Num;
; 1071 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1072 : 			{	// make room and append new stuff using assign
; 1073 : 			_Chassign(this->_Mysize, _Count, _Ch);
; 1074 : 			_Eos(_Num);
; 1075 : 			}
; 1076 : 		return (*this);
; 1077 : 		}
; 1078 : 
; 1079 : 	template<class _Iter>
; 1080 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1081 : 			_Myt&>::type
; 1082 : 		append(_Iter _First, _Iter _Last)
; 1083 : 		{	// append [_First, _Last), input iterators
; 1084 : 		return (replace(end(), end(), _First, _Last));
; 1085 : 		}
; 1086 : 
; 1087 : 	_Myt& append(const_pointer _First, const_pointer _Last)
; 1088 : 		{	// append [_First, _Last), const pointers
; 1089 : 		return (replace(end(), end(), _First, _Last));
; 1090 : 		}
; 1091 : 
; 1092 : 	_Myt& append(const_iterator _First, const_iterator _Last)
; 1093 : 		{	// append [_First, _Last), const_iterators
; 1094 : 		return (replace(end(), end(), _First, _Last));
; 1095 : 		}
; 1096 : 
; 1097 : 	_Myt& assign(const _Myt& _Right)
; 1098 : 		{	// assign _Right
; 1099 : 		return (assign(_Right, 0, npos));

  0000e	49 83 c9 ff	 or	 r9, -1
  00012	45 33 c0	 xor	 r8d, r8d
  00015	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@AEBV12@_K1@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
$LN57@operator:

; 972  : 			{	// different, assign it
; 973  :  #if _HAS_CPP0X
; 974  : 			if (this->_Getal() != _Right._Getal()
; 975  : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 976  : 				{	// change allocator before copying
; 977  : 				_Tidy(true);
; 978  : 				this->_Change_alloc(_Right._Getal());
; 979  : 				}
; 980  :  #endif /* _HAS_CPP0X */
; 981  : 
; 982  : 			assign(_Right);
; 983  : 			}
; 984  : 		return (*this);

  0001a	48 8b c3	 mov	 rax, rbx

; 985  : 		}

  0001d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00021	5b		 pop	 rbx
  00022	c3		 ret	 0
??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV01@AEBV01@@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::operator=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV01@PEB_W@Z
_TEXT	SEGMENT
this$ = 8
_Ptr$ = 16
??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV01@PEB_W@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::operator+=, COMDAT
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd

; 306  : 			: _CSTD wcslen(_First));

  00000	66 83 3a 00	 cmp	 WORD PTR [rdx], 0
  00004	75 08		 jne	 SHORT $LN7@operator
  00006	45 33 c0	 xor	 r8d, r8d
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 1062 : 		return (append(_Ptr, _Traits::length(_Ptr)));

  00009	e9 00 00 00 00	 jmp	 ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@PEB_W_K@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append
$LN7@operator:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd

; 306  : 			: _CSTD wcslen(_First));

  0000e	49 83 c8 ff	 or	 r8, -1
$LL9@operator:
  00012	49 ff c0	 inc	 r8
  00015	66 42 83 3c 42
	00		 cmp	 WORD PTR [rdx+r8*2], 0
  0001b	75 f5		 jne	 SHORT $LL9@operator
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 1062 : 		return (append(_Ptr, _Traits::length(_Ptr)));

  0001d	e9 00 00 00 00	 jmp	 ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@PEB_W_K@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append
??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV01@PEB_W@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.h
;	COMDAT ?set@?$Uniform@VVector@geom@@@gfxu@@QEAAXVVector@geom@@@Z
_TEXT	SEGMENT
this$ = 8
value$ = 16
?set@?$Uniform@VVector@geom@@@gfxu@@QEAAXVVector@geom@@@Z PROC ; gfxu::Uniform<geom::Vector>::set, COMDAT

; 245  : 			val = value;

  00000	8b 02		 mov	 eax, DWORD PTR [rdx]
  00002	89 01		 mov	 DWORD PTR [rcx], eax
  00004	8b 42 04	 mov	 eax, DWORD PTR [rdx+4]
  00007	89 41 04	 mov	 DWORD PTR [rcx+4], eax
  0000a	8b 42 08	 mov	 eax, DWORD PTR [rdx+8]
  0000d	89 41 08	 mov	 DWORD PTR [rcx+8], eax
  00010	8b 42 0c	 mov	 eax, DWORD PTR [rdx+12]

; 246  : 			changed = true;

  00013	c6 41 10 01	 mov	 BYTE PTR [rcx+16], 1
  00017	89 41 0c	 mov	 DWORD PTR [rcx+12], eax

; 247  : 		}

  0001a	c3		 ret	 0
?set@?$Uniform@VVector@geom@@@gfxu@@QEAAXVVector@geom@@@Z ENDP ; gfxu::Uniform<geom::Vector>::set
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.h
;	COMDAT ?set@?$Uniform@M@gfxu@@QEAAXM@Z
_TEXT	SEGMENT
this$dead$ = 8
value$ = 16
?set@?$Uniform@M@gfxu@@QEAAXM@Z PROC			; gfxu::Uniform<float>::set, COMDAT

; 245  : 			val = value;

  00000	f3 0f 11 0d 00
	00 00 00	 movss	 DWORD PTR ?fogDist@Uniforms@gfxu@@2V?$Uniform@M@2@A, xmm1

; 246  : 			changed = true;

  00008	c6 05 04 00 00
	00 01		 mov	 BYTE PTR ?fogDist@Uniforms@gfxu@@2V?$Uniform@M@2@A+4, 1

; 247  : 		}

  0000f	c3		 ret	 0
?set@?$Uniform@M@gfxu@@QEAAXM@Z ENDP			; gfxu::Uniform<float>::set
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ??C?$shared_ptr@VVertexStream@gfxu@@@std@@QEBAPEAVVertexStream@gfxu@@XZ
_TEXT	SEGMENT
this$ = 8
??C?$shared_ptr@VVertexStream@gfxu@@@std@@QEBAPEAVVertexStream@gfxu@@XZ PROC ; std::shared_ptr<gfxu::VertexStream>::operator->, COMDAT

; 691  : 		return (this->_Get());

  00000	48 8b 01	 mov	 rax, QWORD PTR [rcx]

; 692  : 		}

  00003	c3		 ret	 0
??C?$shared_ptr@VVertexStream@gfxu@@@std@@QEBAPEAVVertexStream@gfxu@@XZ ENDP ; std::shared_ptr<gfxu::VertexStream>::operator->
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ??B?$shared_ptr@VVertexStream@gfxu@@@std@@QEBAPEQ?$_Bool_struct@V?$shared_ptr@VVertexStream@gfxu@@@std@@@1@HXZ
_TEXT	SEGMENT
this$ = 8
??B?$shared_ptr@VVertexStream@gfxu@@@std@@QEBAPEQ?$_Bool_struct@V?$shared_ptr@VVertexStream@gfxu@@@std@@@1@HXZ PROC ; std::shared_ptr<gfxu::VertexStream>::operator int std::_Bool_struct<std::shared_ptr<gfxu::VertexStream> >::* __ptr64, COMDAT

; 703  : 		return (this->_Get() != 0 ? _CONVERTIBLE_TO_TRUE : 0);

  00000	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00003	48 f7 d8	 neg	 rax
  00006	1b c0		 sbb	 eax, eax
  00008	f7 d8		 neg	 eax
  0000a	ff c8		 dec	 eax

; 704  : 		}

  0000c	c3		 ret	 0
??B?$shared_ptr@VVertexStream@gfxu@@@std@@QEBAPEQ?$_Bool_struct@V?$shared_ptr@VVertexStream@gfxu@@@std@@@1@HXZ ENDP ; std::shared_ptr<gfxu::VertexStream>::operator int std::_Bool_struct<std::shared_ptr<gfxu::VertexStream> >::* __ptr64
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
;	COMDAT ?begin@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
?begin@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::begin, COMDAT

; 45   : 		this->_Adopt(_Plist);
; 46   : 		}
; 47   : 
; 48   : 	reference operator*() const
; 49   : 		{	// return designated value
; 50   : 		return (_Mytree::_Myval(_Ptr));
; 51   : 		}
; 52   : 
; 53   : 	pointer operator->() const
; 54   : 		{	// return pointer to class object
; 55   : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 56   : 		}
; 57   : 
; 58   : 	_Myiter& operator++()
; 59   : 		{	// preincrement
; 60   : 		if (_Mytree::_Isnil(_Ptr))
; 61   : 			;	// end() shouldn't be incremented, don't move
; 62   : 		else if (!_Mytree::_Isnil(_Mytree::_Right(_Ptr)))
; 63   : 			_Ptr = _Mytree::_Min(
; 64   : 				_Mytree::_Right(_Ptr));	// ==> smallest of right subtree
; 65   : 		else
; 66   : 			{	// climb looking for right subtree
; 67   : 			_Nodeptr _Pnode;
; 68   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 69   : 				&& _Ptr == _Mytree::_Right(_Pnode))
; 70   : 				_Ptr = _Pnode;	// ==> parent while right subtree
; 71   : 			_Ptr = _Pnode;	// ==> parent (head if end())
; 72   : 			}
; 73   : 		return (*this);
; 74   : 		}
; 75   : 
; 76   : 	_Myiter operator++(int)
; 77   : 		{	// postincrement
; 78   : 		_Myiter _Tmp = *this;
; 79   : 		++*this;
; 80   : 		return (_Tmp);
; 81   : 		}
; 82   : 
; 83   : 	_Myiter& operator--()
; 84   : 		{	// predecrement
; 85   : 		if (_Mytree::_Isnil(_Ptr))
; 86   : 			_Ptr = _Mytree::_Right(_Ptr);	// end() ==> rightmost
; 87   : 		else if (!_Mytree::_Isnil(_Mytree::_Left(_Ptr)))
; 88   : 			_Ptr = _Mytree::_Max(
; 89   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree
; 90   : 		else
; 91   : 			{	// climb looking for left subtree
; 92   : 			_Nodeptr _Pnode;
; 93   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 94   : 				&& _Ptr == _Mytree::_Left(_Pnode))
; 95   : 				_Ptr = _Pnode;	// ==> parent while left subtree
; 96   : 			if (_Mytree::_Isnil(_Ptr))
; 97   : 				;	// begin() shouldn't be decremented, don't move
; 98   : 			else
; 99   : 				_Ptr = _Pnode;	// ==> parent if not head
; 100  : 			}
; 101  : 		return (*this);
; 102  : 		}
; 103  : 
; 104  : 	_Myiter operator--(int)
; 105  : 		{	// postdecrement
; 106  : 		_Myiter _Tmp = *this;
; 107  : 		--*this;
; 108  : 		return (_Tmp);
; 109  : 		}
; 110  : 
; 111  : 	bool operator==(const _Myiter& _Right) const
; 112  : 		{	// test for iterator equality
; 113  : 		return (_Ptr == _Right._Ptr);
; 114  : 		}
; 115  : 
; 116  : 	bool operator!=(const _Myiter& _Right) const
; 117  : 		{	// test for iterator inequality
; 118  : 		return (!(*this == _Right));
; 119  : 		}
; 120  : 
; 121  : 	_Nodeptr _Mynode() const
; 122  : 		{	// return node pointer
; 123  : 		return (_Ptr);
; 124  : 		}
; 125  : 
; 126  : 	_Nodeptr _Ptr;	// pointer to node
; 127  : 	};
; 128  : 
; 129  : 	// TEMPLATE CLASS _Tree_unchecked_iterator
; 130  : template<class _Mytree>
; 131  : 	class _Tree_unchecked_iterator
; 132  : 		: public _Tree_unchecked_const_iterator<_Mytree>
; 133  : 	{	// unchecked iterator for mutable tree
; 134  : public:
; 135  : 	typedef _Tree_unchecked_iterator<_Mytree> _Myiter;
; 136  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Mybase;
; 137  : 	typedef bidirectional_iterator_tag iterator_category;
; 138  : 
; 139  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 140  : 	typedef typename _Mytree::value_type value_type;
; 141  : 	typedef typename _Mytree::difference_type difference_type;
; 142  : 	typedef typename _Mytree::pointer pointer;
; 143  : 	typedef typename _Mytree::reference reference;
; 144  : 
; 145  : 	_Tree_unchecked_iterator()
; 146  : 		{	// construct with null node
; 147  : 		}
; 148  : 
; 149  : 	_Tree_unchecked_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 150  : 		: _Mybase(_Pnode, _Plist)
; 151  : 		{	// construct with node pointer _Pnode
; 152  : 		}
; 153  : 
; 154  : 	reference operator*() const
; 155  : 		{	// return designated value
; 156  : 		return ((reference)**(_Mybase *)this);
; 157  : 		}
; 158  : 
; 159  : 	pointer operator->() const
; 160  : 		{	// return pointer to class object
; 161  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 162  : 		}
; 163  : 
; 164  : 	_Myiter& operator++()
; 165  : 		{	// preincrement
; 166  : 		++(*(_Mybase *)this);
; 167  : 		return (*this);
; 168  : 		}
; 169  : 
; 170  : 	_Myiter operator++(int)
; 171  : 		{	// postincrement
; 172  : 		_Myiter _Tmp = *this;
; 173  : 		++*this;
; 174  : 		return (_Tmp);
; 175  : 		}
; 176  : 
; 177  : 	_Myiter& operator--()
; 178  : 		{	// predecrement
; 179  : 		--(*(_Mybase *)this);
; 180  : 		return (*this);
; 181  : 		}
; 182  : 
; 183  : 	_Myiter operator--(int)
; 184  : 		{	// postdecrement
; 185  : 		_Myiter _Tmp = *this;
; 186  : 		--*this;
; 187  : 		return (_Tmp);
; 188  : 		}
; 189  : 	};
; 190  : 
; 191  : 	// TEMPLATE CLASS _Tree_const_iterator
; 192  : template<class _Mytree>
; 193  : 	class _Tree_const_iterator
; 194  : 		: public _Tree_unchecked_const_iterator<_Mytree, _Iterator_base>
; 195  : 	{	// iterator for nonmutable tree
; 196  : public:
; 197  : 	typedef _Tree_const_iterator<_Mytree> _Myiter;
; 198  : 	typedef _Tree_unchecked_const_iterator<_Mytree, _Iterator_base> _Mybase;
; 199  : 	typedef bidirectional_iterator_tag iterator_category;
; 200  : 
; 201  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 202  : 	typedef typename _Mytree::value_type value_type;
; 203  : 	typedef typename _Mytree::difference_type difference_type;
; 204  : 	typedef typename _Mytree::const_pointer pointer;
; 205  : 	typedef typename _Mytree::const_reference reference;
; 206  : 
; 207  : 	_Tree_const_iterator()
; 208  : 		: _Mybase()
; 209  : 		{	// construct with null node pointer
; 210  : 		}
; 211  : 
; 212  : 	_Tree_const_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 213  : 		: _Mybase(_Pnode, _Plist)
; 214  : 		{	// construct with node pointer _Pnode
; 215  : 		}
; 216  : 
; 217  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Unchecked_type;
; 218  : 
; 219  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 220  : 		{	// reset from unchecked iterator
; 221  : 		this->_Ptr = _Right._Ptr;
; 222  : 		return (*this);
; 223  : 		}
; 224  : 
; 225  : 	_Unchecked_type _Unchecked() const
; 226  : 		{	// make an unchecked iterator
; 227  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 228  : 		}
; 229  : 
; 230  : 	reference operator*() const
; 231  : 		{	// return designated value
; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		if (this->_Getcont() == 0
; 234  : 			|| this->_Ptr == 0
; 235  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 236  : 			{	// report error
; 237  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 238  : 			_SCL_SECURE_OUT_OF_RANGE;
; 239  : 			}
; 240  : 
; 241  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 242  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 243  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 244  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 245  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 246  : 
; 247  : 		return (_Mytree::_Myval(this->_Ptr));
; 248  : 		}
; 249  : 
; 250  : 	pointer operator->() const
; 251  : 		{	// return pointer to class object
; 252  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 253  : 		}
; 254  : 
; 255  : 	_Myiter& operator++()
; 256  : 		{	// preincrement
; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);
; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);
; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  :  #if _HAS_CPP0X
; 520  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 521  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 522  : 
; 523  :  #else /* _HAS_CPP0X */
; 524  : 	typedef typename _Alloc::template rebind<_Ty>::other _Alty;
; 525  :  #endif /* _HAS_CPP0X */
; 526  : 
; 527  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 528  : 		_Voidptr;
; 529  : 	typedef _Tree_node<typename _Alty::value_type,
; 530  : 		_Voidptr> _Node;
; 531  : 
; 532  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 533  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 534  : 	typedef _Nodeptr& _Nodepref;
; 535  : 
; 536  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 537  : 		_Tree_simple_types<typename _Alty::value_type>,
; 538  : 		_Tree_iter_types<typename _Alty::value_type,
; 539  : 			typename _Alty::size_type,
; 540  : 			typename _Alty::difference_type,
; 541  : 			typename _Alty::pointer,
; 542  : 			typename _Alty::const_pointer,
; 543  : 			typename _Alty::reference,
; 544  : 			typename _Alty::const_reference,
; 545  : 			_Nodeptr> >::type
; 546  : 		_Val_types;
; 547  : 	};
; 548  : 
; 549  : 		// TEMPLATE CLASS _Tree_val
; 550  : template<class _Val_types>
; 551  : 	class _Tree_val
; 552  : 		: public _Container_base
; 553  : 	{	// base class for tree to hold data
; 554  : public:
; 555  : 	typedef _Tree_val<_Val_types> _Myt;
; 556  : 
; 557  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 558  : 	typedef _Nodeptr& _Nodepref;
; 559  : 
; 560  : 	typedef typename _Val_types::value_type value_type;
; 561  : 	typedef typename _Val_types::size_type size_type;
; 562  : 	typedef typename _Val_types::difference_type difference_type;
; 563  : 	typedef typename _Val_types::pointer pointer;
; 564  : 	typedef typename _Val_types::const_pointer const_pointer;
; 565  : 	typedef typename _Val_types::reference reference;
; 566  : 	typedef typename _Val_types::const_reference const_reference;
; 567  : 
; 568  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 569  : 	typedef _Tree_iterator<_Myt> iterator;
; 570  : 
; 571  : 	_Tree_val()
; 572  : 		{	// initialize data
; 573  : 		this->_Myhead = 0;
; 574  : 		this->_Mysize = 0;
; 575  : 		}
; 576  : 
; 577  : 	enum _Redbl
; 578  : 		{	// colors for link to parent
; 579  : 		_Red, _Black};
; 580  : 
; 581  : 	static char& _Color(_Nodeptr _Pnode)
; 582  : 		{	// return reference to color in node
; 583  : 		return ((char&)_Pnode->_Color);
; 584  : 		}
; 585  : 
; 586  : 	static char& _Isnil(_Nodeptr _Pnode)
; 587  : 		{	// return reference to nil flag in node
; 588  : 		return ((char&)_Pnode->_Isnil);
; 589  : 		}
; 590  : 
; 591  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 592  : 		{	// return reference to left pointer in node
; 593  : 		return ((_Nodepref)_Pnode->_Left);

  00000	48 8b 01	 mov	 rax, QWORD PTR [rcx]

; 44   : 		{	// construct with node pointer _Pnode

  00003	48 8b 08	 mov	 rcx, QWORD PTR [rax]

; 1211 : 		return (iterator(_Lmost(), this));

  00006	48 8b c2	 mov	 rax, rdx

; 44   : 		{	// construct with node pointer _Pnode

  00009	48 89 0a	 mov	 QWORD PTR [rdx], rcx

; 1212 : 		}

  0000c	c3		 ret	 0
?begin@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
?end@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::end, COMDAT

; 44   : 		{	// construct with node pointer _Pnode

  00000	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00003	48 89 02	 mov	 QWORD PTR [rdx], rax

; 1221 : 		return (iterator(this->_Myhead, this));

  00006	48 8b c2	 mov	 rax, rdx

; 1222 : 		}

  00009	c3		 ret	 0
?end@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::end
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\list.h
;	COMDAT ??A?$VirtualList@VTask@Tasks@@$0BAA@$0BAAC@@@QEAAPEAVTask@Tasks@@H@Z
_TEXT	SEGMENT
this$ = 8
index$ = 16
??A?$VirtualList@VTask@Tasks@@$0BAA@$0BAAC@@@QEAAPEAVTask@Tasks@@H@Z PROC ; VirtualList<Tasks::Task,256,4098>::operator[], COMDAT

; 19   : 		return content[index];

  00000	48 63 c2	 movsxd	 rax, edx

; 53   : 		return List::operator[](index);

  00003	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]

; 54   : 	}

  00007	c3		 ret	 0
??A?$VirtualList@VTask@Tasks@@$0BAA@$0BAAC@@@QEAAPEAVTask@Tasks@@H@Z ENDP ; VirtualList<Tasks::Task,256,4098>::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\list.h
;	COMDAT ?getSize@?$VirtualList@VTask@Tasks@@$0BAA@$0BAAC@@@QEAAHXZ
_TEXT	SEGMENT
this$ = 8
?getSize@?$VirtualList@VTask@Tasks@@$0BAA@$0BAAC@@@QEAAHXZ PROC ; VirtualList<Tasks::Task,256,4098>::getSize, COMDAT

; 66   : 		return List::getSize();

  00000	8b 81 00 08 00
	00		 mov	 eax, DWORD PTR [rcx+2048]

; 67   : 	}

  00006	c3		 ret	 0
?getSize@?$VirtualList@VTask@Tasks@@$0BAA@$0BAAC@@@QEAAHXZ ENDP ; VirtualList<Tasks::Task,256,4098>::getSize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\list.h
; File c:\users\glenn\documents\github\wind\project\wind\wind\memutil.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\list.h
;	COMDAT ?clear@?$VirtualList@VTask@Tasks@@$0BAA@$0BAAC@@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?clear@?$VirtualList@VTask@Tasks@@$0BAA@$0BAAC@@@QEAAXXZ PROC ; VirtualList<Tasks::Task,256,4098>::clear, COMDAT

; 37   : 		count = 0;

  00000	33 c0		 xor	 eax, eax
  00002	89 81 00 08 00
	00		 mov	 DWORD PTR [rcx+2048], eax
; File c:\users\glenn\documents\github\wind\project\wind\wind\memutil.cpp

; 18   : 	pos = 0;

  00008	89 81 14 08 00
	00		 mov	 DWORD PTR [rcx+2068], eax
; File c:\users\glenn\documents\github\wind\project\wind\wind\list.h

; 73   : 	}

  0000e	c3		 ret	 0
?clear@?$VirtualList@VTask@Tasks@@$0BAA@$0BAAC@@@QEAAXXZ ENDP ; VirtualList<Tasks::Task,256,4098>::clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ??0?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAA@XZ PROC ; std::vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >, COMDAT

; 486  : 		_Myfirst = pointer();

  00000	33 c0		 xor	 eax, eax
  00002	48 89 01	 mov	 QWORD PTR [rcx], rax

; 487  : 		_Mylast = pointer();

  00005	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 488  : 		_Myend = pointer();

  00009	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 686  : 		}

  0000d	48 8b c1	 mov	 rax, rcx
  00010	c3		 ret	 0
??0?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAA@XZ ENDP ; std::vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ??1?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAA@XZ PROC ; std::vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::~vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >, COMDAT

; 900  : 		_Tidy();

  00000	e9 00 00 00 00	 jmp	 ?_Tidy@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAXXZ ; std::vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::_Tidy
??1?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAA@XZ ENDP ; std::vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::~vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?size@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?size@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEBA_KXZ PROC ; std::vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::size, COMDAT

; 1087 : 		return (this->_Mylast - this->_Myfirst);

  00000	48 8b 41 08	 mov	 rax, QWORD PTR [rcx+8]
  00004	48 2b 01	 sub	 rax, QWORD PTR [rcx]
  00007	48 c1 f8 04	 sar	 rax, 4

; 1088 : 		}

  0000b	c3		 ret	 0
?size@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEBA_KXZ ENDP ; std::vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ??A?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAAAEAV?$shared_ptr@VChunkBase@@@1@_K@Z
_TEXT	SEGMENT
this$ = 8
_Pos$ = 16
??A?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAAAEAV?$shared_ptr@VChunkBase@@@1@_K@Z PROC ; std::vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::operator[], COMDAT

; 1137 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1138 : 		if (size() <= _Pos)
; 1139 : 			{	// report error
; 1140 : 			_DEBUG_ERROR("vector subscript out of range");
; 1141 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1142 : 			}
; 1143 : 
; 1144 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1145 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1146 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1147 : 
; 1148 : 		return (*(this->_Myfirst + _Pos));

  00000	48 c1 e2 04	 shl	 rdx, 4
  00004	48 03 11	 add	 rdx, QWORD PTR [rcx]
  00007	48 8b c2	 mov	 rax, rdx

; 1149 : 		}

  0000a	c3		 ret	 0
??A?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAAAEAV?$shared_ptr@VChunkBase@@@1@_K@Z ENDP ; std::vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?push_back@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAAXAEBV?$shared_ptr@VChunkBase@@@2@@Z
_TEXT	SEGMENT
this$ = 48
_Val$ = 56
?push_back@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAAXAEBV?$shared_ptr@VChunkBase@@@2@@Z PROC ; std::vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::push_back, COMDAT

; 1184 : 		{	// insert element at end

$LN80:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1205 : 
; 1206 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1207 : 	void pop_back()
; 1208 : 		{	// erase element at end
; 1209 : 		if (empty())
; 1210 : 			_DEBUG_ERROR("vector empty before pop");
; 1211 : 		else
; 1212 : 			{	// erase last element
; 1213 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1214 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1215 : 			--this->_Mylast;
; 1216 : 			}
; 1217 : 		}
; 1218 : 
; 1219 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1220 : 	void pop_back()
; 1221 : 		{	// erase element at end
; 1222 : 		if (!empty())
; 1223 : 			{	// erase last element
; 1224 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1225 : 			--this->_Mylast;
; 1226 : 			}
; 1227 : 		}
; 1228 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1229 : 
; 1230 : 	template<class _Iter>
; 1231 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1232 : 			void>::type
; 1233 : 		assign(_Iter _First, _Iter _Last)
; 1234 : 		{	// assign [_First, _Last), input iterators
; 1235 : 		erase(begin(), end());
; 1236 : 		insert(begin(), _First, _Last);
; 1237 : 		}
; 1238 : 
; 1239 : 	void assign(size_type _Count, const value_type& _Val)
; 1240 : 		{	// assign _Count * _Val
; 1241 : 		_Assign_n(_Count, _Val);
; 1242 : 		}
; 1243 : 
; 1244 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1245 : 		{	// insert _Val at _Where
; 1246 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1247 : 		}
; 1248 : 
; 1249 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1250 : 		const _Ty& _Val)
; 1251 : 		{	// insert _Count * _Val at _Where
; 1252 : 		return (_Insert_n(_Where, _Count, _Val));
; 1253 : 		}
; 1254 : 
; 1255 : 	template<class _Iter>
; 1256 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1257 : 			iterator>::type
; 1258 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1259 : 		{	// insert [_First, _Last) at _Where
; 1260 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1261 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1262 : 		return (begin() + _Off);
; 1263 : 		}
; 1264 : 
; 1265 : 	template<class _Iter>
; 1266 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1267 : 			input_iterator_tag)
; 1268 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1269 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1270 : 
; 1271 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1272 : 		if (size() < _Off)
; 1273 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1274 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1275 : 
; 1276 : 		if (_First != _Last)
; 1277 : 			{	// worth doing, gather at end and rotate into place
; 1278 : 			size_type _Oldsize = size();
; 1279 : 
; 1280 : 			_TRY_BEGIN
; 1281 : 			for (; _First != _Last; ++_First)
; 1282 : 				push_back(*_First);	// append
; 1283 : 
; 1284 : 			_CATCH_ALL
; 1285 : 			erase(begin() + _Oldsize, end());
; 1286 : 			_RERAISE;
; 1287 : 			_CATCH_END
; 1288 : 
; 1289 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1290 : 			}
; 1291 : 		}
; 1292 : 
; 1293 : 	template<class _Iter>
; 1294 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1295 : 			forward_iterator_tag)
; 1296 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1297 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1298 : 		if (_VICONT(_Where) != this
; 1299 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1300 : 			|| this->_Mylast < _VIPTR(_Where))
; 1301 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1302 : 		_DEBUG_RANGE(_First, _Last);
; 1303 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1304 : 
; 1305 : 		size_type _Count = 0;
; 1306 : 		_Distance(_First, _Last, _Count);
; 1307 : 
; 1308 : 		if (_Count == 0)
; 1309 : 			;
; 1310 : 		else if (_Unused_capacity() < _Count)
; 1311 : 			{	// not enough room, reallocate
; 1312 : 			if (max_size() - size() < _Count)
; 1313 : 				_Xlen();	// result too long
; 1314 : 
; 1315 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1316 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1317 : 			pointer _Ptr = _Newvec;
; 1318 : 
; 1319 : 			_TRY_BEGIN
; 1320 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1321 : 				_Newvec);	// copy prefix
; 1322 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1323 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1324 : 				_Ptr);	// copy suffix
; 1325 : 			_CATCH_ALL
; 1326 : 			_Destroy(_Newvec, _Ptr);
; 1327 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1328 : 			_RERAISE;
; 1329 : 			_CATCH_END
; 1330 : 
; 1331 : 			_Count += size();
; 1332 : 			if (this->_Myfirst != pointer())
; 1333 : 				{	// destroy and deallocate old array
; 1334 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1335 : 				this->_Getal().deallocate(this->_Myfirst,
; 1336 : 					this->_Myend - this->_Myfirst);
; 1337 : 				}
; 1338 : 
; 1339 : 			this->_Orphan_all();
; 1340 : 			this->_Myend = _Newvec + _Capacity;
; 1341 : 			this->_Mylast = _Newvec + _Count;
; 1342 : 			this->_Myfirst = _Newvec;
; 1343 : 			}
; 1344 : 		else
; 1345 : 			{	// new stuff fits, append and rotate into place
; 1346 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1347 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1348 : 				this->_Mylast + _Count);
; 1349 : 			this->_Mylast += _Count;
; 1350 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1351 : 			}
; 1352 : 		}
; 1353 : 
; 1354 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1355 : 	iterator erase(const_iterator _Where)
; 1356 : 		{	// erase element at where
; 1357 : 		if (_VICONT(_Where) != this
; 1358 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1359 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1360 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1361 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1362 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1363 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1364 : 		--this->_Mylast;
; 1365 : 		return (_Make_iter(_Where));
; 1366 : 		}
; 1367 : 
; 1368 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1369 : 	iterator erase(const_iterator _Where)
; 1370 : 		{	// erase element at where
; 1371 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1372 : 			_VIPTR(_Where));
; 1373 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1374 : 		--this->_Mylast;
; 1375 : 		return (_Make_iter(_Where));
; 1376 : 		}
; 1377 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1378 : 
; 1379 : 	iterator erase(const_iterator _First_arg,
; 1380 : 		const_iterator _Last_arg)
; 1381 : 		{	// erase [_First, _Last)
; 1382 : 		if (_First_arg == begin() && _Last_arg == end())
; 1383 : 			clear();
; 1384 : 		else if (_First_arg != _Last_arg)
; 1385 : 			{	// clear partial
; 1386 : 			iterator _First = _Make_iter(_First_arg);
; 1387 : 			iterator _Last = _Make_iter(_Last_arg);
; 1388 : 
; 1389 : 			if (_First != _Last)
; 1390 : 				{	// worth doing, copy down over hole
; 1391 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1392 : 				if (_Last < _First || _VICONT(_First) != this
; 1393 : 					|| _VIPTR(_First) < this->_Myfirst
; 1394 : 					|| this->_Mylast < _VIPTR(_Last))
; 1395 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1396 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1397 : 					_VIPTR(_First));
; 1398 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1399 : 
; 1400 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1401 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1402 : 					_VIPTR(_First));
; 1403 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1404 : 
; 1405 : 				_Destroy(_Ptr, this->_Mylast);
; 1406 : 				this->_Mylast = _Ptr;
; 1407 : 				}
; 1408 : 			}
; 1409 : 		return (_Make_iter(_First_arg));
; 1410 : 		}
; 1411 : 
; 1412 : 	void clear() _NOEXCEPT
; 1413 : 		{	// erase all
; 1414 : 		this->_Orphan_all();
; 1415 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1416 : 		this->_Mylast = this->_Myfirst;
; 1417 : 		}
; 1418 : 
; 1419 : 	void swap(_Myt& _Right)
; 1420 : 		{	// exchange contents with _Right
; 1421 : 		if (this == &_Right)
; 1422 : 			;	// same object, do nothing
; 1423 : 		else if (this->_Getal() == _Right._Getal())
; 1424 : 			{	// same allocator, swap control information
; 1425 : 			this->_Swap_all(_Right);
; 1426 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1427 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1428 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1429 : 			}
; 1430 : 
; 1431 :  #if _HAS_CPP0X
; 1432 : 		else if (_Alty::propagate_on_container_swap::value)
; 1433 : 			{	// swap allocators and control information
; 1434 : 			this->_Swap_alloc(_Right);
; 1435 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1436 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1437 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1438 : 			}
; 1439 :  #endif /* _HAS_CPP0X */
; 1440 : 
; 1441 : 		else
; 1442 : 			{	// different allocator, do multiple moves
; 1443 : 			_Myt _Ts = _Move(*this);
; 1444 : 
; 1445 : 			*this = _Move(_Right);
; 1446 : 			_Right = _Move(_Ts);
; 1447 : 			}
; 1448 : 		}
; 1449 : 
; 1450 : protected:
; 1451 : 	void _Assign_n(size_type _Count, const value_type& _Val)
; 1452 : 		{	// assign _Count * _Val
; 1453 : 		value_type _Tmp = _Val;	// in case _Val is in sequence
; 1454 : 		erase(begin(), end());
; 1455 : 		insert(begin(), _Count, _Tmp);
; 1456 : 		}
; 1457 : 
; 1458 : 	bool _Buy(size_type _Capacity)
; 1459 : 		{	// allocate array with _Capacity elements
; 1460 : 		this->_Myfirst = pointer();
; 1461 : 		this->_Mylast = pointer();
; 1462 : 		this->_Myend = pointer();
; 1463 : 
; 1464 : 		if (_Capacity == 0)
; 1465 : 			return (false);
; 1466 : 		else if (max_size() < _Capacity)
; 1467 : 			_Xlen();	// result too long
; 1468 : 		else
; 1469 : 			{	// nonempty array, allocate storage
; 1470 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1471 : 			this->_Mylast = this->_Myfirst;
; 1472 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1473 : 			}
; 1474 : 		return (true);
; 1475 : 		}
; 1476 : 
; 1477 : 	void _Destroy(pointer _First, pointer _Last)
; 1478 : 		{	// destroy [_First, _Last) using allocator
; 1479 : 		_Alty _Alval(this->_Getal());
; 1480 : 		_Destroy_range(_First, _Last, _Alval);
; 1481 : 		}
; 1482 : 
; 1483 : 	size_type _Grow_to(size_type _Count) const
; 1484 : 		{	// grow by 50% or at least to _Count
; 1485 : 		size_type _Capacity = capacity();
; 1486 : 
; 1487 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1488 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1489 : 		if (_Capacity < _Count)
; 1490 : 			_Capacity = _Count;
; 1491 : 		return (_Capacity);
; 1492 : 		}
; 1493 : 
; 1494 : 	bool _Inside(const value_type *_Ptr) const
; 1495 : 		{	// test if _Ptr points inside vector
; 1496 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

  0000a	48 8b 41 08	 mov	 rax, QWORD PTR [rcx+8]

; 1184 : 		{	// insert element at end

  0000e	48 8b fa	 mov	 rdi, rdx
  00011	48 8b d9	 mov	 rbx, rcx

; 1205 : 
; 1206 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1207 : 	void pop_back()
; 1208 : 		{	// erase element at end
; 1209 : 		if (empty())
; 1210 : 			_DEBUG_ERROR("vector empty before pop");
; 1211 : 		else
; 1212 : 			{	// erase last element
; 1213 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1214 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1215 : 			--this->_Mylast;
; 1216 : 			}
; 1217 : 		}
; 1218 : 
; 1219 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1220 : 	void pop_back()
; 1221 : 		{	// erase element at end
; 1222 : 		if (!empty())
; 1223 : 			{	// erase last element
; 1224 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1225 : 			--this->_Mylast;
; 1226 : 			}
; 1227 : 		}
; 1228 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1229 : 
; 1230 : 	template<class _Iter>
; 1231 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1232 : 			void>::type
; 1233 : 		assign(_Iter _First, _Iter _Last)
; 1234 : 		{	// assign [_First, _Last), input iterators
; 1235 : 		erase(begin(), end());
; 1236 : 		insert(begin(), _First, _Last);
; 1237 : 		}
; 1238 : 
; 1239 : 	void assign(size_type _Count, const value_type& _Val)
; 1240 : 		{	// assign _Count * _Val
; 1241 : 		_Assign_n(_Count, _Val);
; 1242 : 		}
; 1243 : 
; 1244 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1245 : 		{	// insert _Val at _Where
; 1246 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1247 : 		}
; 1248 : 
; 1249 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1250 : 		const _Ty& _Val)
; 1251 : 		{	// insert _Count * _Val at _Where
; 1252 : 		return (_Insert_n(_Where, _Count, _Val));
; 1253 : 		}
; 1254 : 
; 1255 : 	template<class _Iter>
; 1256 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1257 : 			iterator>::type
; 1258 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1259 : 		{	// insert [_First, _Last) at _Where
; 1260 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1261 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1262 : 		return (begin() + _Off);
; 1263 : 		}
; 1264 : 
; 1265 : 	template<class _Iter>
; 1266 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1267 : 			input_iterator_tag)
; 1268 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1269 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1270 : 
; 1271 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1272 : 		if (size() < _Off)
; 1273 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1274 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1275 : 
; 1276 : 		if (_First != _Last)
; 1277 : 			{	// worth doing, gather at end and rotate into place
; 1278 : 			size_type _Oldsize = size();
; 1279 : 
; 1280 : 			_TRY_BEGIN
; 1281 : 			for (; _First != _Last; ++_First)
; 1282 : 				push_back(*_First);	// append
; 1283 : 
; 1284 : 			_CATCH_ALL
; 1285 : 			erase(begin() + _Oldsize, end());
; 1286 : 			_RERAISE;
; 1287 : 			_CATCH_END
; 1288 : 
; 1289 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1290 : 			}
; 1291 : 		}
; 1292 : 
; 1293 : 	template<class _Iter>
; 1294 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1295 : 			forward_iterator_tag)
; 1296 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1297 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1298 : 		if (_VICONT(_Where) != this
; 1299 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1300 : 			|| this->_Mylast < _VIPTR(_Where))
; 1301 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1302 : 		_DEBUG_RANGE(_First, _Last);
; 1303 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1304 : 
; 1305 : 		size_type _Count = 0;
; 1306 : 		_Distance(_First, _Last, _Count);
; 1307 : 
; 1308 : 		if (_Count == 0)
; 1309 : 			;
; 1310 : 		else if (_Unused_capacity() < _Count)
; 1311 : 			{	// not enough room, reallocate
; 1312 : 			if (max_size() - size() < _Count)
; 1313 : 				_Xlen();	// result too long
; 1314 : 
; 1315 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1316 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1317 : 			pointer _Ptr = _Newvec;
; 1318 : 
; 1319 : 			_TRY_BEGIN
; 1320 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1321 : 				_Newvec);	// copy prefix
; 1322 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1323 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1324 : 				_Ptr);	// copy suffix
; 1325 : 			_CATCH_ALL
; 1326 : 			_Destroy(_Newvec, _Ptr);
; 1327 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1328 : 			_RERAISE;
; 1329 : 			_CATCH_END
; 1330 : 
; 1331 : 			_Count += size();
; 1332 : 			if (this->_Myfirst != pointer())
; 1333 : 				{	// destroy and deallocate old array
; 1334 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1335 : 				this->_Getal().deallocate(this->_Myfirst,
; 1336 : 					this->_Myend - this->_Myfirst);
; 1337 : 				}
; 1338 : 
; 1339 : 			this->_Orphan_all();
; 1340 : 			this->_Myend = _Newvec + _Capacity;
; 1341 : 			this->_Mylast = _Newvec + _Count;
; 1342 : 			this->_Myfirst = _Newvec;
; 1343 : 			}
; 1344 : 		else
; 1345 : 			{	// new stuff fits, append and rotate into place
; 1346 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1347 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1348 : 				this->_Mylast + _Count);
; 1349 : 			this->_Mylast += _Count;
; 1350 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1351 : 			}
; 1352 : 		}
; 1353 : 
; 1354 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1355 : 	iterator erase(const_iterator _Where)
; 1356 : 		{	// erase element at where
; 1357 : 		if (_VICONT(_Where) != this
; 1358 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1359 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1360 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1361 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1362 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1363 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1364 : 		--this->_Mylast;
; 1365 : 		return (_Make_iter(_Where));
; 1366 : 		}
; 1367 : 
; 1368 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1369 : 	iterator erase(const_iterator _Where)
; 1370 : 		{	// erase element at where
; 1371 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1372 : 			_VIPTR(_Where));
; 1373 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1374 : 		--this->_Mylast;
; 1375 : 		return (_Make_iter(_Where));
; 1376 : 		}
; 1377 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1378 : 
; 1379 : 	iterator erase(const_iterator _First_arg,
; 1380 : 		const_iterator _Last_arg)
; 1381 : 		{	// erase [_First, _Last)
; 1382 : 		if (_First_arg == begin() && _Last_arg == end())
; 1383 : 			clear();
; 1384 : 		else if (_First_arg != _Last_arg)
; 1385 : 			{	// clear partial
; 1386 : 			iterator _First = _Make_iter(_First_arg);
; 1387 : 			iterator _Last = _Make_iter(_Last_arg);
; 1388 : 
; 1389 : 			if (_First != _Last)
; 1390 : 				{	// worth doing, copy down over hole
; 1391 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1392 : 				if (_Last < _First || _VICONT(_First) != this
; 1393 : 					|| _VIPTR(_First) < this->_Myfirst
; 1394 : 					|| this->_Mylast < _VIPTR(_Last))
; 1395 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1396 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1397 : 					_VIPTR(_First));
; 1398 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1399 : 
; 1400 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1401 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1402 : 					_VIPTR(_First));
; 1403 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1404 : 
; 1405 : 				_Destroy(_Ptr, this->_Mylast);
; 1406 : 				this->_Mylast = _Ptr;
; 1407 : 				}
; 1408 : 			}
; 1409 : 		return (_Make_iter(_First_arg));
; 1410 : 		}
; 1411 : 
; 1412 : 	void clear() _NOEXCEPT
; 1413 : 		{	// erase all
; 1414 : 		this->_Orphan_all();
; 1415 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1416 : 		this->_Mylast = this->_Myfirst;
; 1417 : 		}
; 1418 : 
; 1419 : 	void swap(_Myt& _Right)
; 1420 : 		{	// exchange contents with _Right
; 1421 : 		if (this == &_Right)
; 1422 : 			;	// same object, do nothing
; 1423 : 		else if (this->_Getal() == _Right._Getal())
; 1424 : 			{	// same allocator, swap control information
; 1425 : 			this->_Swap_all(_Right);
; 1426 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1427 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1428 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1429 : 			}
; 1430 : 
; 1431 :  #if _HAS_CPP0X
; 1432 : 		else if (_Alty::propagate_on_container_swap::value)
; 1433 : 			{	// swap allocators and control information
; 1434 : 			this->_Swap_alloc(_Right);
; 1435 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1436 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1437 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1438 : 			}
; 1439 :  #endif /* _HAS_CPP0X */
; 1440 : 
; 1441 : 		else
; 1442 : 			{	// different allocator, do multiple moves
; 1443 : 			_Myt _Ts = _Move(*this);
; 1444 : 
; 1445 : 			*this = _Move(_Right);
; 1446 : 			_Right = _Move(_Ts);
; 1447 : 			}
; 1448 : 		}
; 1449 : 
; 1450 : protected:
; 1451 : 	void _Assign_n(size_type _Count, const value_type& _Val)
; 1452 : 		{	// assign _Count * _Val
; 1453 : 		value_type _Tmp = _Val;	// in case _Val is in sequence
; 1454 : 		erase(begin(), end());
; 1455 : 		insert(begin(), _Count, _Tmp);
; 1456 : 		}
; 1457 : 
; 1458 : 	bool _Buy(size_type _Capacity)
; 1459 : 		{	// allocate array with _Capacity elements
; 1460 : 		this->_Myfirst = pointer();
; 1461 : 		this->_Mylast = pointer();
; 1462 : 		this->_Myend = pointer();
; 1463 : 
; 1464 : 		if (_Capacity == 0)
; 1465 : 			return (false);
; 1466 : 		else if (max_size() < _Capacity)
; 1467 : 			_Xlen();	// result too long
; 1468 : 		else
; 1469 : 			{	// nonempty array, allocate storage
; 1470 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1471 : 			this->_Mylast = this->_Myfirst;
; 1472 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1473 : 			}
; 1474 : 		return (true);
; 1475 : 		}
; 1476 : 
; 1477 : 	void _Destroy(pointer _First, pointer _Last)
; 1478 : 		{	// destroy [_First, _Last) using allocator
; 1479 : 		_Alty _Alval(this->_Getal());
; 1480 : 		_Destroy_range(_First, _Last, _Alval);
; 1481 : 		}
; 1482 : 
; 1483 : 	size_type _Grow_to(size_type _Count) const
; 1484 : 		{	// grow by 50% or at least to _Count
; 1485 : 		size_type _Capacity = capacity();
; 1486 : 
; 1487 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1488 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1489 : 		if (_Capacity < _Count)
; 1490 : 			_Capacity = _Count;
; 1491 : 		return (_Capacity);
; 1492 : 		}
; 1493 : 
; 1494 : 	bool _Inside(const value_type *_Ptr) const
; 1495 : 		{	// test if _Ptr points inside vector
; 1496 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

  00014	48 3b d0	 cmp	 rdx, rax
  00017	73 22		 jae	 SHORT $LN4@push_back
  00019	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0001c	48 3b ca	 cmp	 rcx, rdx
  0001f	77 1a		 ja	 SHORT $LN4@push_back

; 1185 : 		if (_Inside(_STD addressof(_Val)))
; 1186 : 			{	// push back an element
; 1187 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 1188 : 			if (this->_Mylast == this->_Myend)

  00021	48 2b f9	 sub	 rdi, rcx
  00024	48 3b 43 10	 cmp	 rax, QWORD PTR [rbx+16]
  00028	75 08		 jne	 SHORT $LN3@push_back

; 1189 : 				_Reserve(1);

  0002a	48 8b cb	 mov	 rcx, rbx
  0002d	e8 00 00 00 00	 call	 ?_Reserve@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAX_K@Z ; std::vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::_Reserve
$LN3@push_back:

; 1190 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1191 : 			this->_Getal().construct(this->_Mylast,
; 1192 : 				this->_Myfirst[_Idx]);

  00032	48 83 e7 f0	 and	 rdi, -16
  00036	48 03 3b	 add	 rdi, QWORD PTR [rbx]

; 1193 : 			++this->_Mylast;
; 1194 : 			}
; 1195 : 		else

  00039	eb 0e		 jmp	 SHORT $LN1@push_back
$LN4@push_back:

; 1196 : 			{	// push back a non-element
; 1197 : 			if (this->_Mylast == this->_Myend)

  0003b	48 3b 43 10	 cmp	 rax, QWORD PTR [rbx+16]
  0003f	75 08		 jne	 SHORT $LN1@push_back

; 1198 : 				_Reserve(1);

  00041	48 8b cb	 mov	 rcx, rbx
  00044	e8 00 00 00 00	 call	 ?_Reserve@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAX_K@Z ; std::vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::_Reserve
$LN1@push_back:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 606  : 		::new ((void *)_Ptr) _Ty(_Val);

  00049	48 8b 4b 08	 mov	 rcx, QWORD PTR [rbx+8]
  0004d	48 85 c9	 test	 rcx, rcx
  00050	74 1f		 je	 SHORT $LN60@push_back
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 282  : 		{	// construct

  00052	33 c0		 xor	 eax, eax
  00054	48 89 01	 mov	 QWORD PTR [rcx], rax
  00057	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 283  : 		}
; 284  : 
; 285  : 	_Ptr_base(_Myt&& _Right)
; 286  : 		: _Ptr(0), _Rep(0)
; 287  : 		{	// construct _Ptr_base object that takes resource from _Right
; 288  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 289  : 		}
; 290  : 
; 291  : 	template<class _Ty2>
; 292  : 		_Ptr_base(_Ptr_base<_Ty2>&& _Right)
; 293  : 		: _Ptr(_Right._Ptr), _Rep(_Right._Rep)
; 294  : 		{	// construct _Ptr_base object that takes resource from _Right
; 295  : 		_Right._Ptr = 0;
; 296  : 		_Right._Rep = 0;
; 297  : 		}
; 298  : 
; 299  : 	_Myt& operator=(_Myt&& _Right)
; 300  : 		{	// construct _Ptr_base object that takes resource from _Right
; 301  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 302  : 		return (*this);
; 303  : 		}
; 304  : 
; 305  : 	void _Assign_rv(_Myt&& _Right)
; 306  : 		{	// assign by moving _Right
; 307  : 		if (this != &_Right)
; 308  : 			_Swap(_Right);
; 309  : 		}
; 310  : 
; 311  : 	long use_count() const _NOEXCEPT
; 312  : 		{	// return use count
; 313  : 		return (_Rep ? _Rep->_Use_count() : 0);
; 314  : 		}
; 315  : 
; 316  : 	void _Swap(_Ptr_base& _Right)
; 317  : 		{	// swap pointers
; 318  : 		_STD swap(_Rep, _Right._Rep);
; 319  : 		_STD swap(_Ptr, _Right._Ptr);
; 320  : 		}
; 321  : 
; 322  : 	template<class _Ty2>
; 323  : 		bool owner_before(const _Ptr_base<_Ty2>& _Right) const
; 324  : 		{	// compare addresses of manager objects
; 325  : 		return (_Rep < _Right._Rep);
; 326  : 		}
; 327  : 
; 328  : 	void *_Get_deleter(const _XSTD2 type_info& _Typeid) const
; 329  : 		{	// return pointer to deleter object if its type is _Typeid
; 330  : 		return (_Rep ? _Rep->_Get_deleter(_Typeid) : 0);
; 331  : 		}
; 332  : 
; 333  : 	_Ty *_Get() const
; 334  : 		{	// return pointer to resource
; 335  : 		return (_Ptr);
; 336  : 		}
; 337  : 
; 338  : 	bool _Expired() const
; 339  : 		{	// test if expired
; 340  : 		return (!_Rep || _Rep->_Expired());
; 341  : 		}
; 342  : 
; 343  : 	void _Decref()
; 344  : 		{	// decrement reference count
; 345  : 		if (_Rep != 0)
; 346  : 			_Rep->_Decref();
; 347  : 		}
; 348  : 
; 349  : 	void _Reset()
; 350  : 		{	// release resource
; 351  : 		_Reset(0, 0);
; 352  : 		}
; 353  : 
; 354  : 	template<class _Ty2>
; 355  : 		void _Reset(const _Ptr_base<_Ty2>& _Other)
; 356  : 		{	// release resource and take ownership of _Other._Ptr
; 357  : 		_Reset(_Other._Ptr, _Other._Rep);

  0005b	4c 8b 47 08	 mov	 r8, QWORD PTR [rdi+8]
  0005f	48 8b 17	 mov	 rdx, QWORD PTR [rdi]

; 358  : 		}
; 359  : 
; 360  : 	template<class _Ty2>
; 361  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, bool _Throw)
; 362  : 		{	// release resource and take ownership from weak_ptr _Other._Ptr
; 363  : 		_Reset(_Other._Ptr, _Other._Rep, _Throw);
; 364  : 		}
; 365  : 
; 366  : 	template<class _Ty2>
; 367  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Static_tag&)
; 368  : 		{	// release resource and take ownership of _Other._Ptr
; 369  : 		_Reset(static_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 370  : 		}
; 371  : 
; 372  : 	template<class _Ty2>
; 373  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Const_tag&)
; 374  : 		{	// release resource and take ownership of _Other._Ptr
; 375  : 		_Reset(const_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 376  : 		}
; 377  : 
; 378  : 	template<class _Ty2>
; 379  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Dynamic_tag&)
; 380  : 		{	// release resource and take ownership of _Other._Ptr
; 381  : 		_Elem *_Ptr = dynamic_cast<_Elem *>(_Other._Ptr);
; 382  : 		if (_Ptr)
; 383  : 			_Reset(_Ptr, _Other._Rep);
; 384  : 		else
; 385  : 			_Reset();
; 386  : 		}
; 387  : 
; 388  : 	template<class _Ty2>
; 389  : 		void _Reset(auto_ptr<_Ty2>&& _Other)
; 390  : 		{	// release resource and take _Other.get()
; 391  : 		_Ty2 *_Px = _Other.get();
; 392  : 		_Reset0(_Px, new _Ref_count<_Elem>(_Px));
; 393  : 		_Other.release();
; 394  : 		_Enable_shared(_Px, _Rep);
; 395  : 		}
; 396  : 
; 397  :  #if _HAS_CPP0X
; 398  : 	template<class _Ty2>
; 399  : 		void _Reset(_Ty *_Ptr, const _Ptr_base<_Ty2>& _Other)
; 400  : 		{	// release resource and alias _Ptr with _Other_rep
; 401  : 		_Reset(_Ptr, _Other._Rep);
; 402  : 		}
; 403  :  #endif /* _HAS_CPP0X */
; 404  : 
; 405  : 	void _Reset(_Ty *_Other_ptr, _Ref_count_base *_Other_rep)
; 406  : 		{	// release resource and take _Other_ptr through _Other_rep
; 407  : 		if (_Other_rep)

  00062	4d 85 c0	 test	 r8, r8
  00065	74 05		 je	 SHORT $LN73@push_back

; 108  : 		_MT_INCR(_Ignored, _Uses);

  00067	f0 41 ff 40 08	 lock inc DWORD PTR [r8+8]
$LN73@push_back:

; 408  : 			_Other_rep->_Incref();
; 409  : 		_Reset0(_Other_ptr, _Other_rep);

  0006c	e8 00 00 00 00	 call	 ?_Reset0@?$_Ptr_base@VChunkBase@@@std@@QEAAXPEAVChunkBase@@PEAV_Ref_count_base@2@@Z ; std::_Ptr_base<ChunkBase>::_Reset0
$LN60@push_back:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector

; 1202 : 			++this->_Mylast;

  00071	48 83 43 08 10	 add	 QWORD PTR [rbx+8], 16

; 1203 : 			}
; 1204 : 		}

  00076	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0007b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0007f	5f		 pop	 rdi
  00080	c3		 ret	 0
?push_back@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAAXAEBV?$shared_ptr@VChunkBase@@@2@@Z ENDP ; std::vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::push_back
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
;	COMDAT ??C?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QEBAPEBU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@XZ
_TEXT	SEGMENT
this$ = 8
??C?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QEBAPEBU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@XZ PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::operator->, COMDAT

; 254  : 
; 255  : 	_Myiter& operator++()
; 256  : 		{	// preincrement
; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);
; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);
; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  :  #if _HAS_CPP0X
; 520  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 521  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 522  : 
; 523  :  #else /* _HAS_CPP0X */
; 524  : 	typedef typename _Alloc::template rebind<_Ty>::other _Alty;
; 525  :  #endif /* _HAS_CPP0X */
; 526  : 
; 527  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 528  : 		_Voidptr;
; 529  : 	typedef _Tree_node<typename _Alty::value_type,
; 530  : 		_Voidptr> _Node;
; 531  : 
; 532  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 533  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 534  : 	typedef _Nodeptr& _Nodepref;
; 535  : 
; 536  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 537  : 		_Tree_simple_types<typename _Alty::value_type>,
; 538  : 		_Tree_iter_types<typename _Alty::value_type,
; 539  : 			typename _Alty::size_type,
; 540  : 			typename _Alty::difference_type,
; 541  : 			typename _Alty::pointer,
; 542  : 			typename _Alty::const_pointer,
; 543  : 			typename _Alty::reference,
; 544  : 			typename _Alty::const_reference,
; 545  : 			_Nodeptr> >::type
; 546  : 		_Val_types;
; 547  : 	};
; 548  : 
; 549  : 		// TEMPLATE CLASS _Tree_val
; 550  : template<class _Val_types>
; 551  : 	class _Tree_val
; 552  : 		: public _Container_base
; 553  : 	{	// base class for tree to hold data
; 554  : public:
; 555  : 	typedef _Tree_val<_Val_types> _Myt;
; 556  : 
; 557  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 558  : 	typedef _Nodeptr& _Nodepref;
; 559  : 
; 560  : 	typedef typename _Val_types::value_type value_type;
; 561  : 	typedef typename _Val_types::size_type size_type;
; 562  : 	typedef typename _Val_types::difference_type difference_type;
; 563  : 	typedef typename _Val_types::pointer pointer;
; 564  : 	typedef typename _Val_types::const_pointer const_pointer;
; 565  : 	typedef typename _Val_types::reference reference;
; 566  : 	typedef typename _Val_types::const_reference const_reference;
; 567  : 
; 568  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 569  : 	typedef _Tree_iterator<_Myt> iterator;
; 570  : 
; 571  : 	_Tree_val()
; 572  : 		{	// initialize data
; 573  : 		this->_Myhead = 0;
; 574  : 		this->_Mysize = 0;
; 575  : 		}
; 576  : 
; 577  : 	enum _Redbl
; 578  : 		{	// colors for link to parent
; 579  : 		_Red, _Black};
; 580  : 
; 581  : 	static char& _Color(_Nodeptr _Pnode)
; 582  : 		{	// return reference to color in node
; 583  : 		return ((char&)_Pnode->_Color);
; 584  : 		}
; 585  : 
; 586  : 	static char& _Isnil(_Nodeptr _Pnode)
; 587  : 		{	// return reference to nil flag in node
; 588  : 		return ((char&)_Pnode->_Isnil);
; 589  : 		}
; 590  : 
; 591  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 592  : 		{	// return reference to left pointer in node
; 593  : 		return ((_Nodepref)_Pnode->_Left);
; 594  : 		}
; 595  : 
; 596  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 597  : 		{	// return reference to parent pointer in node
; 598  : 		return ((_Nodepref)_Pnode->_Parent);
; 599  : 		}
; 600  : 
; 601  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 602  : 		{	// return reference to right pointer in node
; 603  : 		return ((_Nodepref)_Pnode->_Right);
; 604  : 		}
; 605  : 
; 606  : 	static reference _Myval(_Nodeptr _Pnode)
; 607  : 		{	// return reference to value in node
; 608  : 		return ((reference)_Pnode->_Myval);

  00000	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00003	48 83 c0 20	 add	 rax, 32			; 00000020H

; 252  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 253  : 		}

  00007	c3		 ret	 0
??C?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QEBAPEBU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@XZ ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::operator->
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
;	COMDAT ??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QEAAAEAV01@XZ
_TEXT	SEGMENT
this$ = 8
??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QEAAAEAV01@XZ PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::operator++, COMDAT

; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);
; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  :  #if _HAS_CPP0X
; 520  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 521  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 522  : 
; 523  :  #else /* _HAS_CPP0X */
; 524  : 	typedef typename _Alloc::template rebind<_Ty>::other _Alty;
; 525  :  #endif /* _HAS_CPP0X */
; 526  : 
; 527  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 528  : 		_Voidptr;
; 529  : 	typedef _Tree_node<typename _Alty::value_type,
; 530  : 		_Voidptr> _Node;
; 531  : 
; 532  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 533  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 534  : 	typedef _Nodeptr& _Nodepref;
; 535  : 
; 536  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 537  : 		_Tree_simple_types<typename _Alty::value_type>,
; 538  : 		_Tree_iter_types<typename _Alty::value_type,
; 539  : 			typename _Alty::size_type,
; 540  : 			typename _Alty::difference_type,
; 541  : 			typename _Alty::pointer,
; 542  : 			typename _Alty::const_pointer,
; 543  : 			typename _Alty::reference,
; 544  : 			typename _Alty::const_reference,
; 545  : 			_Nodeptr> >::type
; 546  : 		_Val_types;
; 547  : 	};
; 548  : 
; 549  : 		// TEMPLATE CLASS _Tree_val
; 550  : template<class _Val_types>
; 551  : 	class _Tree_val
; 552  : 		: public _Container_base
; 553  : 	{	// base class for tree to hold data
; 554  : public:
; 555  : 	typedef _Tree_val<_Val_types> _Myt;
; 556  : 
; 557  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 558  : 	typedef _Nodeptr& _Nodepref;
; 559  : 
; 560  : 	typedef typename _Val_types::value_type value_type;
; 561  : 	typedef typename _Val_types::size_type size_type;
; 562  : 	typedef typename _Val_types::difference_type difference_type;
; 563  : 	typedef typename _Val_types::pointer pointer;
; 564  : 	typedef typename _Val_types::const_pointer const_pointer;
; 565  : 	typedef typename _Val_types::reference reference;
; 566  : 	typedef typename _Val_types::const_reference const_reference;
; 567  : 
; 568  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 569  : 	typedef _Tree_iterator<_Myt> iterator;
; 570  : 
; 571  : 	_Tree_val()
; 572  : 		{	// initialize data
; 573  : 		this->_Myhead = 0;
; 574  : 		this->_Mysize = 0;
; 575  : 		}
; 576  : 
; 577  : 	enum _Redbl
; 578  : 		{	// colors for link to parent
; 579  : 		_Red, _Black};
; 580  : 
; 581  : 	static char& _Color(_Nodeptr _Pnode)
; 582  : 		{	// return reference to color in node
; 583  : 		return ((char&)_Pnode->_Color);
; 584  : 		}
; 585  : 
; 586  : 	static char& _Isnil(_Nodeptr _Pnode)
; 587  : 		{	// return reference to nil flag in node
; 588  : 		return ((char&)_Pnode->_Isnil);

  00000	48 8b 01	 mov	 rax, QWORD PTR [rcx]

; 256  : 		{	// preincrement

  00003	48 8b d1	 mov	 rdx, rcx

; 60   : 		if (_Mytree::_Isnil(_Ptr))

  00006	80 78 19 00	 cmp	 BYTE PTR [rax+25], 0
  0000a	75 4d		 jne	 SHORT $LN41@operator

; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);
; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  :  #if _HAS_CPP0X
; 520  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 521  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 522  : 
; 523  :  #else /* _HAS_CPP0X */
; 524  : 	typedef typename _Alloc::template rebind<_Ty>::other _Alty;
; 525  :  #endif /* _HAS_CPP0X */
; 526  : 
; 527  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 528  : 		_Voidptr;
; 529  : 	typedef _Tree_node<typename _Alty::value_type,
; 530  : 		_Voidptr> _Node;
; 531  : 
; 532  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 533  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 534  : 	typedef _Nodeptr& _Nodepref;
; 535  : 
; 536  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 537  : 		_Tree_simple_types<typename _Alty::value_type>,
; 538  : 		_Tree_iter_types<typename _Alty::value_type,
; 539  : 			typename _Alty::size_type,
; 540  : 			typename _Alty::difference_type,
; 541  : 			typename _Alty::pointer,
; 542  : 			typename _Alty::const_pointer,
; 543  : 			typename _Alty::reference,
; 544  : 			typename _Alty::const_reference,
; 545  : 			_Nodeptr> >::type
; 546  : 		_Val_types;
; 547  : 	};
; 548  : 
; 549  : 		// TEMPLATE CLASS _Tree_val
; 550  : template<class _Val_types>
; 551  : 	class _Tree_val
; 552  : 		: public _Container_base
; 553  : 	{	// base class for tree to hold data
; 554  : public:
; 555  : 	typedef _Tree_val<_Val_types> _Myt;
; 556  : 
; 557  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 558  : 	typedef _Nodeptr& _Nodepref;
; 559  : 
; 560  : 	typedef typename _Val_types::value_type value_type;
; 561  : 	typedef typename _Val_types::size_type size_type;
; 562  : 	typedef typename _Val_types::difference_type difference_type;
; 563  : 	typedef typename _Val_types::pointer pointer;
; 564  : 	typedef typename _Val_types::const_pointer const_pointer;
; 565  : 	typedef typename _Val_types::reference reference;
; 566  : 	typedef typename _Val_types::const_reference const_reference;
; 567  : 
; 568  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 569  : 	typedef _Tree_iterator<_Myt> iterator;
; 570  : 
; 571  : 	_Tree_val()
; 572  : 		{	// initialize data
; 573  : 		this->_Myhead = 0;
; 574  : 		this->_Mysize = 0;
; 575  : 		}
; 576  : 
; 577  : 	enum _Redbl
; 578  : 		{	// colors for link to parent
; 579  : 		_Red, _Black};
; 580  : 
; 581  : 	static char& _Color(_Nodeptr _Pnode)
; 582  : 		{	// return reference to color in node
; 583  : 		return ((char&)_Pnode->_Color);
; 584  : 		}
; 585  : 
; 586  : 	static char& _Isnil(_Nodeptr _Pnode)
; 587  : 		{	// return reference to nil flag in node
; 588  : 		return ((char&)_Pnode->_Isnil);

  0000c	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]

; 61   : 			;	// end() shouldn't be incremented, don't move
; 62   : 		else if (!_Mytree::_Isnil(_Mytree::_Right(_Ptr)))

  00010	80 79 19 00	 cmp	 BYTE PTR [rcx+25], 0
  00014	75 1d		 jne	 SHORT $LN36@operator

; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);
; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  :  #if _HAS_CPP0X
; 520  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 521  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 522  : 
; 523  :  #else /* _HAS_CPP0X */
; 524  : 	typedef typename _Alloc::template rebind<_Ty>::other _Alty;
; 525  :  #endif /* _HAS_CPP0X */
; 526  : 
; 527  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 528  : 		_Voidptr;
; 529  : 	typedef _Tree_node<typename _Alty::value_type,
; 530  : 		_Voidptr> _Node;
; 531  : 
; 532  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 533  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 534  : 	typedef _Nodeptr& _Nodepref;
; 535  : 
; 536  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 537  : 		_Tree_simple_types<typename _Alty::value_type>,
; 538  : 		_Tree_iter_types<typename _Alty::value_type,
; 539  : 			typename _Alty::size_type,
; 540  : 			typename _Alty::difference_type,
; 541  : 			typename _Alty::pointer,
; 542  : 			typename _Alty::const_pointer,
; 543  : 			typename _Alty::reference,
; 544  : 			typename _Alty::const_reference,
; 545  : 			_Nodeptr> >::type
; 546  : 		_Val_types;
; 547  : 	};
; 548  : 
; 549  : 		// TEMPLATE CLASS _Tree_val
; 550  : template<class _Val_types>
; 551  : 	class _Tree_val
; 552  : 		: public _Container_base
; 553  : 	{	// base class for tree to hold data
; 554  : public:
; 555  : 	typedef _Tree_val<_Val_types> _Myt;
; 556  : 
; 557  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 558  : 	typedef _Nodeptr& _Nodepref;
; 559  : 
; 560  : 	typedef typename _Val_types::value_type value_type;
; 561  : 	typedef typename _Val_types::size_type size_type;
; 562  : 	typedef typename _Val_types::difference_type difference_type;
; 563  : 	typedef typename _Val_types::pointer pointer;
; 564  : 	typedef typename _Val_types::const_pointer const_pointer;
; 565  : 	typedef typename _Val_types::reference reference;
; 566  : 	typedef typename _Val_types::const_reference const_reference;
; 567  : 
; 568  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 569  : 	typedef _Tree_iterator<_Myt> iterator;
; 570  : 
; 571  : 	_Tree_val()
; 572  : 		{	// initialize data
; 573  : 		this->_Myhead = 0;
; 574  : 		this->_Mysize = 0;
; 575  : 		}
; 576  : 
; 577  : 	enum _Redbl
; 578  : 		{	// colors for link to parent
; 579  : 		_Red, _Black};
; 580  : 
; 581  : 	static char& _Color(_Nodeptr _Pnode)
; 582  : 		{	// return reference to color in node
; 583  : 		return ((char&)_Pnode->_Color);
; 584  : 		}
; 585  : 
; 586  : 	static char& _Isnil(_Nodeptr _Pnode)
; 587  : 		{	// return reference to nil flag in node
; 588  : 		return ((char&)_Pnode->_Isnil);

  00016	48 8b 01	 mov	 rax, QWORD PTR [rcx]

; 589  : 		}
; 590  : 
; 591  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 592  : 		{	// return reference to left pointer in node
; 593  : 		return ((_Nodepref)_Pnode->_Left);
; 594  : 		}
; 595  : 
; 596  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 597  : 		{	// return reference to parent pointer in node
; 598  : 		return ((_Nodepref)_Pnode->_Parent);
; 599  : 		}
; 600  : 
; 601  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 602  : 		{	// return reference to right pointer in node
; 603  : 		return ((_Nodepref)_Pnode->_Right);
; 604  : 		}
; 605  : 
; 606  : 	static reference _Myval(_Nodeptr _Pnode)
; 607  : 		{	// return reference to value in node
; 608  : 		return ((reference)_Pnode->_Myval);
; 609  : 		}
; 610  : 
; 611  : 	static _Nodeptr _Max(_Nodeptr _Pnode)
; 612  : 		{	// return rightmost node in subtree at _Pnode
; 613  : 		while (!_Isnil(_Right(_Pnode)))
; 614  : 			_Pnode = _Right(_Pnode);
; 615  : 		return (_Pnode);
; 616  : 		}
; 617  : 
; 618  : 	static _Nodeptr _Min(_Nodeptr _Pnode)
; 619  : 		{	// return leftmost node in subtree at _Pnode
; 620  : 		while (!_Isnil(_Left(_Pnode)))

  00019	80 78 19 00	 cmp	 BYTE PTR [rax+25], 0
  0001d	75 0d		 jne	 SHORT $LN19@operator
  0001f	90		 npad	 1
$LL20@operator:

; 621  : 			_Pnode = _Left(_Pnode);

  00020	48 8b c8	 mov	 rcx, rax

; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);
; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  :  #if _HAS_CPP0X
; 520  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 521  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 522  : 
; 523  :  #else /* _HAS_CPP0X */
; 524  : 	typedef typename _Alloc::template rebind<_Ty>::other _Alty;
; 525  :  #endif /* _HAS_CPP0X */
; 526  : 
; 527  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 528  : 		_Voidptr;
; 529  : 	typedef _Tree_node<typename _Alty::value_type,
; 530  : 		_Voidptr> _Node;
; 531  : 
; 532  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 533  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 534  : 	typedef _Nodeptr& _Nodepref;
; 535  : 
; 536  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 537  : 		_Tree_simple_types<typename _Alty::value_type>,
; 538  : 		_Tree_iter_types<typename _Alty::value_type,
; 539  : 			typename _Alty::size_type,
; 540  : 			typename _Alty::difference_type,
; 541  : 			typename _Alty::pointer,
; 542  : 			typename _Alty::const_pointer,
; 543  : 			typename _Alty::reference,
; 544  : 			typename _Alty::const_reference,
; 545  : 			_Nodeptr> >::type
; 546  : 		_Val_types;
; 547  : 	};
; 548  : 
; 549  : 		// TEMPLATE CLASS _Tree_val
; 550  : template<class _Val_types>
; 551  : 	class _Tree_val
; 552  : 		: public _Container_base
; 553  : 	{	// base class for tree to hold data
; 554  : public:
; 555  : 	typedef _Tree_val<_Val_types> _Myt;
; 556  : 
; 557  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 558  : 	typedef _Nodeptr& _Nodepref;
; 559  : 
; 560  : 	typedef typename _Val_types::value_type value_type;
; 561  : 	typedef typename _Val_types::size_type size_type;
; 562  : 	typedef typename _Val_types::difference_type difference_type;
; 563  : 	typedef typename _Val_types::pointer pointer;
; 564  : 	typedef typename _Val_types::const_pointer const_pointer;
; 565  : 	typedef typename _Val_types::reference reference;
; 566  : 	typedef typename _Val_types::const_reference const_reference;
; 567  : 
; 568  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 569  : 	typedef _Tree_iterator<_Myt> iterator;
; 570  : 
; 571  : 	_Tree_val()
; 572  : 		{	// initialize data
; 573  : 		this->_Myhead = 0;
; 574  : 		this->_Mysize = 0;
; 575  : 		}
; 576  : 
; 577  : 	enum _Redbl
; 578  : 		{	// colors for link to parent
; 579  : 		_Red, _Black};
; 580  : 
; 581  : 	static char& _Color(_Nodeptr _Pnode)
; 582  : 		{	// return reference to color in node
; 583  : 		return ((char&)_Pnode->_Color);
; 584  : 		}
; 585  : 
; 586  : 	static char& _Isnil(_Nodeptr _Pnode)
; 587  : 		{	// return reference to nil flag in node
; 588  : 		return ((char&)_Pnode->_Isnil);

  00023	48 8b 00	 mov	 rax, QWORD PTR [rax]

; 589  : 		}
; 590  : 
; 591  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 592  : 		{	// return reference to left pointer in node
; 593  : 		return ((_Nodepref)_Pnode->_Left);
; 594  : 		}
; 595  : 
; 596  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 597  : 		{	// return reference to parent pointer in node
; 598  : 		return ((_Nodepref)_Pnode->_Parent);
; 599  : 		}
; 600  : 
; 601  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 602  : 		{	// return reference to right pointer in node
; 603  : 		return ((_Nodepref)_Pnode->_Right);
; 604  : 		}
; 605  : 
; 606  : 	static reference _Myval(_Nodeptr _Pnode)
; 607  : 		{	// return reference to value in node
; 608  : 		return ((reference)_Pnode->_Myval);
; 609  : 		}
; 610  : 
; 611  : 	static _Nodeptr _Max(_Nodeptr _Pnode)
; 612  : 		{	// return rightmost node in subtree at _Pnode
; 613  : 		while (!_Isnil(_Right(_Pnode)))
; 614  : 			_Pnode = _Right(_Pnode);
; 615  : 		return (_Pnode);
; 616  : 		}
; 617  : 
; 618  : 	static _Nodeptr _Min(_Nodeptr _Pnode)
; 619  : 		{	// return leftmost node in subtree at _Pnode
; 620  : 		while (!_Isnil(_Left(_Pnode)))

  00026	80 78 19 00	 cmp	 BYTE PTR [rax+25], 0
  0002a	74 f4		 je	 SHORT $LL20@operator
$LN19@operator:

; 63   : 			_Ptr = _Mytree::_Min(
; 64   : 				_Mytree::_Right(_Ptr));	// ==> smallest of right subtree

  0002c	48 89 0a	 mov	 QWORD PTR [rdx], rcx

; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);
; 272  : 		return (*this);

  0002f	48 8b c2	 mov	 rax, rdx

; 273  : 		}

  00032	c3		 ret	 0
$LN36@operator:

; 65   : 		else
; 66   : 			{	// climb looking for right subtree
; 67   : 			_Nodeptr _Pnode;
; 68   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 69   : 				&& _Ptr == _Mytree::_Right(_Pnode))

  00033	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00037	80 78 19 00	 cmp	 BYTE PTR [rax+25], 0
  0003b	75 19		 jne	 SHORT $LN3@operator
  0003d	0f 1f 00	 npad	 3
$LL4@operator:
  00040	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  00044	48 39 0a	 cmp	 QWORD PTR [rdx], rcx
  00047	75 0d		 jne	 SHORT $LN3@operator

; 70   : 				_Ptr = _Pnode;	// ==> parent while right subtree

  00049	48 89 02	 mov	 QWORD PTR [rdx], rax
  0004c	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00050	80 78 19 00	 cmp	 BYTE PTR [rax+25], 0
  00054	74 ea		 je	 SHORT $LL4@operator
$LN3@operator:

; 71   : 			_Ptr = _Pnode;	// ==> parent (head if end())

  00056	48 89 02	 mov	 QWORD PTR [rdx], rax
$LN41@operator:

; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);
; 272  : 		return (*this);

  00059	48 8b c2	 mov	 rax, rdx

; 273  : 		}

  0005c	c3		 ret	 0
??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QEAAAEAV01@XZ ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
;	COMDAT ??9?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
??9?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::operator!=, COMDAT

; 336  : 		return (this->_Ptr == _Right._Ptr);

  00000	48 8b 12	 mov	 rdx, QWORD PTR [rdx]
  00003	48 39 11	 cmp	 QWORD PTR [rcx], rdx

; 341  : 		return (!(*this == _Right));

  00006	0f 95 c0	 setne	 al

; 342  : 		}

  00009	c3		 ret	 0
??9?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::operator!=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@PEB_W@Z
_TEXT	SEGMENT
this$ = 8
_Ptr$ = 16
?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@PEB_W@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append, COMDAT
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd

; 306  : 			: _CSTD wcslen(_First));

  00000	66 83 3a 00	 cmp	 WORD PTR [rdx], 0
  00004	75 08		 jne	 SHORT $LN5@append
  00006	45 33 c0	 xor	 r8d, r8d
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 1062 : 		return (append(_Ptr, _Traits::length(_Ptr)));

  00009	e9 00 00 00 00	 jmp	 ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@PEB_W_K@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append
$LN5@append:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd

; 306  : 			: _CSTD wcslen(_First));

  0000e	49 83 c8 ff	 or	 r8, -1
$LL7@append:
  00012	49 ff c0	 inc	 r8
  00015	66 42 83 3c 42
	00		 cmp	 WORD PTR [rdx+r8*2], 0
  0001b	75 f5		 jne	 SHORT $LL7@append
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 1062 : 		return (append(_Ptr, _Traits::length(_Ptr)));

  0001d	e9 00 00 00 00	 jmp	 ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@PEB_W_K@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append
?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@PEB_W@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@AEBV12@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@AEBV12@@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign, COMDAT

; 1099 : 		return (assign(_Right, 0, npos));

  00000	49 83 c9 ff	 or	 r9, -1
  00004	45 33 c0	 xor	 r8d, r8d
  00007	e9 00 00 00 00	 jmp	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@AEBV12@_K1@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@AEBV12@@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Change_alloc@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QEAAXAEBU?$_Wrap_alloc@V?$allocator@_W@std@@@2@@Z
_TEXT	SEGMENT
this$ = 8
__formal$ = 16
?_Change_alloc@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QEAAXAEBU?$_Wrap_alloc@V?$allocator@_W@std@@@2@@Z PROC ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Change_alloc, COMDAT

; 641  : 		}

  00000	c2 00 00	 ret	 0
?_Change_alloc@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QEAAXAEBU?$_Wrap_alloc@V?$allocator@_W@std@@@2@@Z ENDP ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Change_alloc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ?_Get@?$_Ptr_base@VVertexStream@gfxu@@@std@@QEBAPEAVVertexStream@gfxu@@XZ
_TEXT	SEGMENT
this$ = 8
?_Get@?$_Ptr_base@VVertexStream@gfxu@@@std@@QEBAPEAVVertexStream@gfxu@@XZ PROC ; std::_Ptr_base<gfxu::VertexStream>::_Get, COMDAT

; 335  : 		return (_Ptr);

  00000	48 8b 01	 mov	 rax, QWORD PTR [rcx]

; 336  : 		}

  00003	c3		 ret	 0
?_Get@?$_Ptr_base@VVertexStream@gfxu@@@std@@QEBAPEAVVertexStream@gfxu@@XZ ENDP ; std::_Ptr_base<gfxu::VertexStream>::_Get
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
;	COMDAT ?_Lmost@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEBAAEAPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Lmost@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEBAAEAPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@XZ PROC ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Lmost, COMDAT

; 2109 : 		return (this->_Left(this->_Myhead));

  00000	48 8b 01	 mov	 rax, QWORD PTR [rcx]

; 2110 : 		}

  00003	c3		 ret	 0
?_Lmost@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEBAAEAPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Lmost
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\list.h
;	COMDAT ??A?$List@PEAVTask@Tasks@@$0BAA@@@QEAAAEAPEAVTask@Tasks@@H@Z
_TEXT	SEGMENT
this$ = 8
index$ = 16
??A?$List@PEAVTask@Tasks@@$0BAA@@@QEAAAEAPEAVTask@Tasks@@H@Z PROC ; List<Tasks::Task * __ptr64,256>::operator[], COMDAT

; 19   : 		return content[index];

  00000	48 63 c2	 movsxd	 rax, edx
  00003	48 8d 04 c1	 lea	 rax, QWORD PTR [rcx+rax*8]

; 20   : 	}

  00007	c3		 ret	 0
??A?$List@PEAVTask@Tasks@@$0BAA@@@QEAAAEAPEAVTask@Tasks@@H@Z ENDP ; List<Tasks::Task * __ptr64,256>::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\list.h
;	COMDAT ?getSize@?$List@PEAVTask@Tasks@@$0BAA@@@QEAAHXZ
_TEXT	SEGMENT
this$ = 8
?getSize@?$List@PEAVTask@Tasks@@$0BAA@@@QEAAHXZ PROC	; List<Tasks::Task * __ptr64,256>::getSize, COMDAT

; 32   : 		return count;

  00000	8b 81 00 08 00
	00		 mov	 eax, DWORD PTR [rcx+2048]

; 33   : 	}

  00006	c3		 ret	 0
?getSize@?$List@PEAVTask@Tasks@@$0BAA@@@QEAAHXZ ENDP	; List<Tasks::Task * __ptr64,256>::getSize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\list.h
;	COMDAT ?clear@?$List@PEAVTask@Tasks@@$0BAA@@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?clear@?$List@PEAVTask@Tasks@@$0BAA@@@QEAAXXZ PROC	; List<Tasks::Task * __ptr64,256>::clear, COMDAT

; 37   : 		count = 0;

  00000	c7 81 00 08 00
	00 00 00 00 00	 mov	 DWORD PTR [rcx+2048], 0

; 38   : 	}

  0000a	c3		 ret	 0
?clear@?$List@PEAVTask@Tasks@@$0BAA@@@QEAAXXZ ENDP	; List<Tasks::Task * __ptr64,256>::clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?_Inside@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEBA_NPEBV?$shared_ptr@VChunkBase@@@2@@Z
_TEXT	SEGMENT
this$ = 8
_Ptr$ = 16
?_Inside@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEBA_NPEBV?$shared_ptr@VChunkBase@@@2@@Z PROC ; std::vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::_Inside, COMDAT

; 1496 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

  00000	48 3b 51 08	 cmp	 rdx, QWORD PTR [rcx+8]
  00004	73 08		 jae	 SHORT $LN3@Inside
  00006	48 39 11	 cmp	 QWORD PTR [rcx], rdx
  00009	77 03		 ja	 SHORT $LN3@Inside
  0000b	b0 01		 mov	 al, 1

; 1497 : 		}

  0000d	c3		 ret	 0
$LN3@Inside:

; 1496 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

  0000e	32 c0		 xor	 al, al

; 1497 : 		}

  00010	c3		 ret	 0
?_Inside@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEBA_NPEBV?$shared_ptr@VChunkBase@@@2@@Z ENDP ; std::vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::_Inside
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?_Reserve@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAX_K@Z
_TEXT	SEGMENT
this$ = 48
_Count$dead$ = 56
?_Reserve@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAX_K@Z PROC ; std::vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::_Reserve, COMDAT

; 1525 : 		{	// ensure room for _Count new elements, grow exponentially

$LN44:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 968  : 		}
; 969  : 
; 970  : 	size_type _Unused_capacity() const _NOEXCEPT
; 971  : 		{	// micro-optimization for capacity() - size()
; 972  : 		return (this->_Myend - this->_Mylast);

  00004	48 8b 51 10	 mov	 rdx, QWORD PTR [rcx+16]
  00008	4c 8b 41 08	 mov	 r8, QWORD PTR [rcx+8]
  0000c	48 8b c2	 mov	 rax, rdx
  0000f	49 2b c0	 sub	 rax, r8
  00012	48 c1 f8 04	 sar	 rax, 4

; 1526 : 		if (_Unused_capacity() < _Count)

  00016	48 83 f8 01	 cmp	 rax, 1
  0001a	73 5d		 jae	 SHORT $LN2@Reserve

; 973  : 		}
; 974  : 
; 975  : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 976  : 		{	// micro-optimization for capacity() != size()
; 977  : 		return (this->_Myend != this->_Mylast);
; 978  : 		}
; 979  : 
; 980  : 	iterator begin() _NOEXCEPT
; 981  : 		{	// return iterator for beginning of mutable sequence
; 982  : 		return (iterator(this->_Myfirst, this));
; 983  : 		}
; 984  : 
; 985  : 	const_iterator begin() const _NOEXCEPT
; 986  : 		{	// return iterator for beginning of nonmutable sequence
; 987  : 		return (const_iterator(this->_Myfirst, this));
; 988  : 		}
; 989  : 
; 990  : 	iterator end() _NOEXCEPT
; 991  : 		{	// return iterator for end of mutable sequence
; 992  : 		return (iterator(this->_Mylast, this));
; 993  : 		}
; 994  : 
; 995  : 	const_iterator end() const _NOEXCEPT
; 996  : 		{	// return iterator for end of nonmutable sequence
; 997  : 		return (const_iterator(this->_Mylast, this));
; 998  : 		}
; 999  : 
; 1000 : 	iterator _Make_iter(const_iterator _Where) const
; 1001 : 		{	// make iterator from const_iterator
; 1002 : 		return (iterator(_Where._Ptr, this));
; 1003 : 		}
; 1004 : 
; 1005 : 	reverse_iterator rbegin() _NOEXCEPT
; 1006 : 		{	// return iterator for beginning of reversed mutable sequence
; 1007 : 		return (reverse_iterator(end()));
; 1008 : 		}
; 1009 : 
; 1010 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1011 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1012 : 		return (const_reverse_iterator(end()));
; 1013 : 		}
; 1014 : 
; 1015 : 	reverse_iterator rend() _NOEXCEPT
; 1016 : 		{	// return iterator for end of reversed mutable sequence
; 1017 : 		return (reverse_iterator(begin()));
; 1018 : 		}
; 1019 : 
; 1020 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1021 : 		{	// return iterator for end of reversed nonmutable sequence
; 1022 : 		return (const_reverse_iterator(begin()));
; 1023 : 		}
; 1024 : 
; 1025 :  #if _HAS_CPP0X
; 1026 : 	const_iterator cbegin() const _NOEXCEPT
; 1027 : 		{	// return iterator for beginning of nonmutable sequence
; 1028 : 		return (((const _Myt *)this)->begin());
; 1029 : 		}
; 1030 : 
; 1031 : 	const_iterator cend() const _NOEXCEPT
; 1032 : 		{	// return iterator for end of nonmutable sequence
; 1033 : 		return (((const _Myt *)this)->end());
; 1034 : 		}
; 1035 : 
; 1036 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1037 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1038 : 		return (((const _Myt *)this)->rbegin());
; 1039 : 		}
; 1040 : 
; 1041 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1042 : 		{	// return iterator for end of reversed nonmutable sequence
; 1043 : 		return (((const _Myt *)this)->rend());
; 1044 : 		}
; 1045 : 
; 1046 : 	void shrink_to_fit()
; 1047 : 		{	// reduce capacity
; 1048 : 		if (_Has_unused_capacity())
; 1049 : 			{	// worth shrinking, do it
; 1050 : 			if (empty())
; 1051 : 				_Tidy();
; 1052 : 			else
; 1053 : 				_Reallocate(size());
; 1054 : 			}
; 1055 : 		}
; 1056 :  #endif /* _HAS_CPP0X */
; 1057 : 
; 1058 : 	void resize(size_type _Newsize)
; 1059 : 		{	// determine new length, padding as needed
; 1060 : 		if (_Newsize < size())
; 1061 : 			erase(begin() + _Newsize, end());
; 1062 : 		else if (size() < _Newsize)
; 1063 : 			{	// pad as needed
; 1064 : 			_Alty _Alval(this->_Getal());
; 1065 : 			_Reserve(_Newsize - size());
; 1066 : 			_TRY_BEGIN
; 1067 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1068 : 				_Alval);
; 1069 : 			_CATCH_ALL
; 1070 : 			_Tidy();
; 1071 : 			_RERAISE;
; 1072 : 			_CATCH_END
; 1073 : 			this->_Mylast += _Newsize - size();
; 1074 : 			}
; 1075 : 		}
; 1076 : 
; 1077 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1078 : 		{	// determine new length, padding with _Val elements as needed
; 1079 : 		if (_Newsize < size())
; 1080 : 			erase(begin() + _Newsize, end());
; 1081 : 		else if (size() < _Newsize)
; 1082 : 			_Insert_n(end(), _Newsize - size(), _Val);
; 1083 : 		}
; 1084 : 
; 1085 : 	size_type size() const _NOEXCEPT
; 1086 : 		{	// return length of sequence
; 1087 : 		return (this->_Mylast - this->_Myfirst);

  0001c	4c 8b 11	 mov	 r10, QWORD PTR [rcx]

; 1527 : 			{	// need more room, try to get it
; 1528 : 			if (max_size() - size() < _Count)

  0001f	49 b9 ff ff ff
	ff ff ff ff 0f	 mov	 r9, 1152921504606846975	; 0fffffffffffffffH

; 973  : 		}
; 974  : 
; 975  : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 976  : 		{	// micro-optimization for capacity() != size()
; 977  : 		return (this->_Myend != this->_Mylast);
; 978  : 		}
; 979  : 
; 980  : 	iterator begin() _NOEXCEPT
; 981  : 		{	// return iterator for beginning of mutable sequence
; 982  : 		return (iterator(this->_Myfirst, this));
; 983  : 		}
; 984  : 
; 985  : 	const_iterator begin() const _NOEXCEPT
; 986  : 		{	// return iterator for beginning of nonmutable sequence
; 987  : 		return (const_iterator(this->_Myfirst, this));
; 988  : 		}
; 989  : 
; 990  : 	iterator end() _NOEXCEPT
; 991  : 		{	// return iterator for end of mutable sequence
; 992  : 		return (iterator(this->_Mylast, this));
; 993  : 		}
; 994  : 
; 995  : 	const_iterator end() const _NOEXCEPT
; 996  : 		{	// return iterator for end of nonmutable sequence
; 997  : 		return (const_iterator(this->_Mylast, this));
; 998  : 		}
; 999  : 
; 1000 : 	iterator _Make_iter(const_iterator _Where) const
; 1001 : 		{	// make iterator from const_iterator
; 1002 : 		return (iterator(_Where._Ptr, this));
; 1003 : 		}
; 1004 : 
; 1005 : 	reverse_iterator rbegin() _NOEXCEPT
; 1006 : 		{	// return iterator for beginning of reversed mutable sequence
; 1007 : 		return (reverse_iterator(end()));
; 1008 : 		}
; 1009 : 
; 1010 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1011 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1012 : 		return (const_reverse_iterator(end()));
; 1013 : 		}
; 1014 : 
; 1015 : 	reverse_iterator rend() _NOEXCEPT
; 1016 : 		{	// return iterator for end of reversed mutable sequence
; 1017 : 		return (reverse_iterator(begin()));
; 1018 : 		}
; 1019 : 
; 1020 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1021 : 		{	// return iterator for end of reversed nonmutable sequence
; 1022 : 		return (const_reverse_iterator(begin()));
; 1023 : 		}
; 1024 : 
; 1025 :  #if _HAS_CPP0X
; 1026 : 	const_iterator cbegin() const _NOEXCEPT
; 1027 : 		{	// return iterator for beginning of nonmutable sequence
; 1028 : 		return (((const _Myt *)this)->begin());
; 1029 : 		}
; 1030 : 
; 1031 : 	const_iterator cend() const _NOEXCEPT
; 1032 : 		{	// return iterator for end of nonmutable sequence
; 1033 : 		return (((const _Myt *)this)->end());
; 1034 : 		}
; 1035 : 
; 1036 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1037 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1038 : 		return (((const _Myt *)this)->rbegin());
; 1039 : 		}
; 1040 : 
; 1041 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1042 : 		{	// return iterator for end of reversed nonmutable sequence
; 1043 : 		return (((const _Myt *)this)->rend());
; 1044 : 		}
; 1045 : 
; 1046 : 	void shrink_to_fit()
; 1047 : 		{	// reduce capacity
; 1048 : 		if (_Has_unused_capacity())
; 1049 : 			{	// worth shrinking, do it
; 1050 : 			if (empty())
; 1051 : 				_Tidy();
; 1052 : 			else
; 1053 : 				_Reallocate(size());
; 1054 : 			}
; 1055 : 		}
; 1056 :  #endif /* _HAS_CPP0X */
; 1057 : 
; 1058 : 	void resize(size_type _Newsize)
; 1059 : 		{	// determine new length, padding as needed
; 1060 : 		if (_Newsize < size())
; 1061 : 			erase(begin() + _Newsize, end());
; 1062 : 		else if (size() < _Newsize)
; 1063 : 			{	// pad as needed
; 1064 : 			_Alty _Alval(this->_Getal());
; 1065 : 			_Reserve(_Newsize - size());
; 1066 : 			_TRY_BEGIN
; 1067 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1068 : 				_Alval);
; 1069 : 			_CATCH_ALL
; 1070 : 			_Tidy();
; 1071 : 			_RERAISE;
; 1072 : 			_CATCH_END
; 1073 : 			this->_Mylast += _Newsize - size();
; 1074 : 			}
; 1075 : 		}
; 1076 : 
; 1077 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1078 : 		{	// determine new length, padding with _Val elements as needed
; 1079 : 		if (_Newsize < size())
; 1080 : 			erase(begin() + _Newsize, end());
; 1081 : 		else if (size() < _Newsize)
; 1082 : 			_Insert_n(end(), _Newsize - size(), _Val);
; 1083 : 		}
; 1084 : 
; 1085 : 	size_type size() const _NOEXCEPT
; 1086 : 		{	// return length of sequence
; 1087 : 		return (this->_Mylast - this->_Myfirst);

  00029	4d 2b c2	 sub	 r8, r10

; 1527 : 			{	// need more room, try to get it
; 1528 : 			if (max_size() - size() < _Count)

  0002c	49 8b c1	 mov	 rax, r9

; 973  : 		}
; 974  : 
; 975  : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 976  : 		{	// micro-optimization for capacity() != size()
; 977  : 		return (this->_Myend != this->_Mylast);
; 978  : 		}
; 979  : 
; 980  : 	iterator begin() _NOEXCEPT
; 981  : 		{	// return iterator for beginning of mutable sequence
; 982  : 		return (iterator(this->_Myfirst, this));
; 983  : 		}
; 984  : 
; 985  : 	const_iterator begin() const _NOEXCEPT
; 986  : 		{	// return iterator for beginning of nonmutable sequence
; 987  : 		return (const_iterator(this->_Myfirst, this));
; 988  : 		}
; 989  : 
; 990  : 	iterator end() _NOEXCEPT
; 991  : 		{	// return iterator for end of mutable sequence
; 992  : 		return (iterator(this->_Mylast, this));
; 993  : 		}
; 994  : 
; 995  : 	const_iterator end() const _NOEXCEPT
; 996  : 		{	// return iterator for end of nonmutable sequence
; 997  : 		return (const_iterator(this->_Mylast, this));
; 998  : 		}
; 999  : 
; 1000 : 	iterator _Make_iter(const_iterator _Where) const
; 1001 : 		{	// make iterator from const_iterator
; 1002 : 		return (iterator(_Where._Ptr, this));
; 1003 : 		}
; 1004 : 
; 1005 : 	reverse_iterator rbegin() _NOEXCEPT
; 1006 : 		{	// return iterator for beginning of reversed mutable sequence
; 1007 : 		return (reverse_iterator(end()));
; 1008 : 		}
; 1009 : 
; 1010 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1011 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1012 : 		return (const_reverse_iterator(end()));
; 1013 : 		}
; 1014 : 
; 1015 : 	reverse_iterator rend() _NOEXCEPT
; 1016 : 		{	// return iterator for end of reversed mutable sequence
; 1017 : 		return (reverse_iterator(begin()));
; 1018 : 		}
; 1019 : 
; 1020 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1021 : 		{	// return iterator for end of reversed nonmutable sequence
; 1022 : 		return (const_reverse_iterator(begin()));
; 1023 : 		}
; 1024 : 
; 1025 :  #if _HAS_CPP0X
; 1026 : 	const_iterator cbegin() const _NOEXCEPT
; 1027 : 		{	// return iterator for beginning of nonmutable sequence
; 1028 : 		return (((const _Myt *)this)->begin());
; 1029 : 		}
; 1030 : 
; 1031 : 	const_iterator cend() const _NOEXCEPT
; 1032 : 		{	// return iterator for end of nonmutable sequence
; 1033 : 		return (((const _Myt *)this)->end());
; 1034 : 		}
; 1035 : 
; 1036 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1037 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1038 : 		return (((const _Myt *)this)->rbegin());
; 1039 : 		}
; 1040 : 
; 1041 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1042 : 		{	// return iterator for end of reversed nonmutable sequence
; 1043 : 		return (((const _Myt *)this)->rend());
; 1044 : 		}
; 1045 : 
; 1046 : 	void shrink_to_fit()
; 1047 : 		{	// reduce capacity
; 1048 : 		if (_Has_unused_capacity())
; 1049 : 			{	// worth shrinking, do it
; 1050 : 			if (empty())
; 1051 : 				_Tidy();
; 1052 : 			else
; 1053 : 				_Reallocate(size());
; 1054 : 			}
; 1055 : 		}
; 1056 :  #endif /* _HAS_CPP0X */
; 1057 : 
; 1058 : 	void resize(size_type _Newsize)
; 1059 : 		{	// determine new length, padding as needed
; 1060 : 		if (_Newsize < size())
; 1061 : 			erase(begin() + _Newsize, end());
; 1062 : 		else if (size() < _Newsize)
; 1063 : 			{	// pad as needed
; 1064 : 			_Alty _Alval(this->_Getal());
; 1065 : 			_Reserve(_Newsize - size());
; 1066 : 			_TRY_BEGIN
; 1067 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1068 : 				_Alval);
; 1069 : 			_CATCH_ALL
; 1070 : 			_Tidy();
; 1071 : 			_RERAISE;
; 1072 : 			_CATCH_END
; 1073 : 			this->_Mylast += _Newsize - size();
; 1074 : 			}
; 1075 : 		}
; 1076 : 
; 1077 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1078 : 		{	// determine new length, padding with _Val elements as needed
; 1079 : 		if (_Newsize < size())
; 1080 : 			erase(begin() + _Newsize, end());
; 1081 : 		else if (size() < _Newsize)
; 1082 : 			_Insert_n(end(), _Newsize - size(), _Val);
; 1083 : 		}
; 1084 : 
; 1085 : 	size_type size() const _NOEXCEPT
; 1086 : 		{	// return length of sequence
; 1087 : 		return (this->_Mylast - this->_Myfirst);

  0002f	49 c1 f8 04	 sar	 r8, 4

; 1527 : 			{	// need more room, try to get it
; 1528 : 			if (max_size() - size() < _Count)

  00033	49 2b c0	 sub	 rax, r8
  00036	48 83 f8 01	 cmp	 rax, 1
  0003a	72 42		 jb	 SHORT $LN42@Reserve

; 967  : 		return (this->_Myend - this->_Myfirst);

  0003c	49 2b d2	 sub	 rdx, r10

; 1529 : 				_Xlen();
; 1530 : 			_Reallocate(_Grow_to(size() + _Count));

  0003f	49 ff c0	 inc	 r8

; 967  : 		return (this->_Myend - this->_Myfirst);

  00042	48 c1 fa 04	 sar	 rdx, 4

; 1088 : 		}
; 1089 : 
; 1090 : 	size_type max_size() const _NOEXCEPT
; 1091 : 		{	// return maximum possible length of sequence
; 1092 : 		return (this->_Getal().max_size());
; 1093 : 		}
; 1094 : 
; 1095 : 	bool empty() const _NOEXCEPT
; 1096 : 		{	// test if sequence is empty
; 1097 : 		return (this->_Myfirst == this->_Mylast);
; 1098 : 		}
; 1099 : 
; 1100 : 	_Alloc get_allocator() const _NOEXCEPT
; 1101 : 		{	// return allocator object for values
; 1102 : 		return (this->_Getal());
; 1103 : 		}
; 1104 : 
; 1105 : 	const_reference at(size_type _Pos) const
; 1106 : 		{	// subscript nonmutable sequence with checking
; 1107 : 		if (size() <= _Pos)
; 1108 : 			_Xran();
; 1109 : 		return (*(this->_Myfirst + _Pos));
; 1110 : 		}
; 1111 : 
; 1112 : 	reference at(size_type _Pos)
; 1113 : 		{	// subscript mutable sequence with checking
; 1114 : 		if (size() <= _Pos)
; 1115 : 			_Xran();
; 1116 : 		return (*(this->_Myfirst + _Pos));
; 1117 : 		}
; 1118 : 
; 1119 : 	const_reference operator[](size_type _Pos) const
; 1120 : 		{	// subscript nonmutable sequence
; 1121 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1122 : 		if (size() <= _Pos)
; 1123 : 			{	// report error
; 1124 : 			_DEBUG_ERROR("vector subscript out of range");
; 1125 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1126 : 			}
; 1127 : 
; 1128 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1129 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1130 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1131 : 
; 1132 : 		return (*(this->_Myfirst + _Pos));
; 1133 : 		}
; 1134 : 
; 1135 : 	reference operator[](size_type _Pos)
; 1136 : 		{	// subscript mutable sequence
; 1137 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1138 : 		if (size() <= _Pos)
; 1139 : 			{	// report error
; 1140 : 			_DEBUG_ERROR("vector subscript out of range");
; 1141 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1142 : 			}
; 1143 : 
; 1144 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1145 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1146 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1147 : 
; 1148 : 		return (*(this->_Myfirst + _Pos));
; 1149 : 		}
; 1150 : 
; 1151 :  #if _HAS_CPP0X
; 1152 : 	pointer data() _NOEXCEPT
; 1153 : 		{	// return address of first element
; 1154 : 		return (this->_Myfirst);
; 1155 : 		}
; 1156 : 
; 1157 : 	const_pointer data() const _NOEXCEPT
; 1158 : 		{	// return address of first element
; 1159 : 		return (this->_Myfirst);
; 1160 : 		}
; 1161 :  #endif /* _HAS_CPP0X */
; 1162 : 
; 1163 : 	reference front()
; 1164 : 		{	// return first element of mutable sequence
; 1165 : 		return (*begin());
; 1166 : 		}
; 1167 : 
; 1168 : 	const_reference front() const
; 1169 : 		{	// return first element of nonmutable sequence
; 1170 : 		return (*begin());
; 1171 : 		}
; 1172 : 
; 1173 : 	reference back()
; 1174 : 		{	// return last element of mutable sequence
; 1175 : 		return (*(end() - 1));
; 1176 : 		}
; 1177 : 
; 1178 : 	const_reference back() const
; 1179 : 		{	// return last element of nonmutable sequence
; 1180 : 		return (*(end() - 1));
; 1181 : 		}
; 1182 : 
; 1183 : 	void push_back(const value_type& _Val)
; 1184 : 		{	// insert element at end
; 1185 : 		if (_Inside(_STD addressof(_Val)))
; 1186 : 			{	// push back an element
; 1187 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 1188 : 			if (this->_Mylast == this->_Myend)
; 1189 : 				_Reserve(1);
; 1190 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1191 : 			this->_Getal().construct(this->_Mylast,
; 1192 : 				this->_Myfirst[_Idx]);
; 1193 : 			++this->_Mylast;
; 1194 : 			}
; 1195 : 		else
; 1196 : 			{	// push back a non-element
; 1197 : 			if (this->_Mylast == this->_Myend)
; 1198 : 				_Reserve(1);
; 1199 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1200 : 			this->_Getal().construct(this->_Mylast,
; 1201 : 				_Val);
; 1202 : 			++this->_Mylast;
; 1203 : 			}
; 1204 : 		}
; 1205 : 
; 1206 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1207 : 	void pop_back()
; 1208 : 		{	// erase element at end
; 1209 : 		if (empty())
; 1210 : 			_DEBUG_ERROR("vector empty before pop");
; 1211 : 		else
; 1212 : 			{	// erase last element
; 1213 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1214 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1215 : 			--this->_Mylast;
; 1216 : 			}
; 1217 : 		}
; 1218 : 
; 1219 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1220 : 	void pop_back()
; 1221 : 		{	// erase element at end
; 1222 : 		if (!empty())
; 1223 : 			{	// erase last element
; 1224 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1225 : 			--this->_Mylast;
; 1226 : 			}
; 1227 : 		}
; 1228 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1229 : 
; 1230 : 	template<class _Iter>
; 1231 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1232 : 			void>::type
; 1233 : 		assign(_Iter _First, _Iter _Last)
; 1234 : 		{	// assign [_First, _Last), input iterators
; 1235 : 		erase(begin(), end());
; 1236 : 		insert(begin(), _First, _Last);
; 1237 : 		}
; 1238 : 
; 1239 : 	void assign(size_type _Count, const value_type& _Val)
; 1240 : 		{	// assign _Count * _Val
; 1241 : 		_Assign_n(_Count, _Val);
; 1242 : 		}
; 1243 : 
; 1244 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1245 : 		{	// insert _Val at _Where
; 1246 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1247 : 		}
; 1248 : 
; 1249 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1250 : 		const _Ty& _Val)
; 1251 : 		{	// insert _Count * _Val at _Where
; 1252 : 		return (_Insert_n(_Where, _Count, _Val));
; 1253 : 		}
; 1254 : 
; 1255 : 	template<class _Iter>
; 1256 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1257 : 			iterator>::type
; 1258 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1259 : 		{	// insert [_First, _Last) at _Where
; 1260 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1261 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1262 : 		return (begin() + _Off);
; 1263 : 		}
; 1264 : 
; 1265 : 	template<class _Iter>
; 1266 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1267 : 			input_iterator_tag)
; 1268 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1269 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1270 : 
; 1271 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1272 : 		if (size() < _Off)
; 1273 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1274 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1275 : 
; 1276 : 		if (_First != _Last)
; 1277 : 			{	// worth doing, gather at end and rotate into place
; 1278 : 			size_type _Oldsize = size();
; 1279 : 
; 1280 : 			_TRY_BEGIN
; 1281 : 			for (; _First != _Last; ++_First)
; 1282 : 				push_back(*_First);	// append
; 1283 : 
; 1284 : 			_CATCH_ALL
; 1285 : 			erase(begin() + _Oldsize, end());
; 1286 : 			_RERAISE;
; 1287 : 			_CATCH_END
; 1288 : 
; 1289 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1290 : 			}
; 1291 : 		}
; 1292 : 
; 1293 : 	template<class _Iter>
; 1294 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1295 : 			forward_iterator_tag)
; 1296 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1297 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1298 : 		if (_VICONT(_Where) != this
; 1299 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1300 : 			|| this->_Mylast < _VIPTR(_Where))
; 1301 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1302 : 		_DEBUG_RANGE(_First, _Last);
; 1303 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1304 : 
; 1305 : 		size_type _Count = 0;
; 1306 : 		_Distance(_First, _Last, _Count);
; 1307 : 
; 1308 : 		if (_Count == 0)
; 1309 : 			;
; 1310 : 		else if (_Unused_capacity() < _Count)
; 1311 : 			{	// not enough room, reallocate
; 1312 : 			if (max_size() - size() < _Count)
; 1313 : 				_Xlen();	// result too long
; 1314 : 
; 1315 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1316 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1317 : 			pointer _Ptr = _Newvec;
; 1318 : 
; 1319 : 			_TRY_BEGIN
; 1320 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1321 : 				_Newvec);	// copy prefix
; 1322 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1323 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1324 : 				_Ptr);	// copy suffix
; 1325 : 			_CATCH_ALL
; 1326 : 			_Destroy(_Newvec, _Ptr);
; 1327 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1328 : 			_RERAISE;
; 1329 : 			_CATCH_END
; 1330 : 
; 1331 : 			_Count += size();
; 1332 : 			if (this->_Myfirst != pointer())
; 1333 : 				{	// destroy and deallocate old array
; 1334 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1335 : 				this->_Getal().deallocate(this->_Myfirst,
; 1336 : 					this->_Myend - this->_Myfirst);
; 1337 : 				}
; 1338 : 
; 1339 : 			this->_Orphan_all();
; 1340 : 			this->_Myend = _Newvec + _Capacity;
; 1341 : 			this->_Mylast = _Newvec + _Count;
; 1342 : 			this->_Myfirst = _Newvec;
; 1343 : 			}
; 1344 : 		else
; 1345 : 			{	// new stuff fits, append and rotate into place
; 1346 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1347 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1348 : 				this->_Mylast + _Count);
; 1349 : 			this->_Mylast += _Count;
; 1350 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1351 : 			}
; 1352 : 		}
; 1353 : 
; 1354 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1355 : 	iterator erase(const_iterator _Where)
; 1356 : 		{	// erase element at where
; 1357 : 		if (_VICONT(_Where) != this
; 1358 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1359 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1360 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1361 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1362 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1363 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1364 : 		--this->_Mylast;
; 1365 : 		return (_Make_iter(_Where));
; 1366 : 		}
; 1367 : 
; 1368 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1369 : 	iterator erase(const_iterator _Where)
; 1370 : 		{	// erase element at where
; 1371 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1372 : 			_VIPTR(_Where));
; 1373 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1374 : 		--this->_Mylast;
; 1375 : 		return (_Make_iter(_Where));
; 1376 : 		}
; 1377 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1378 : 
; 1379 : 	iterator erase(const_iterator _First_arg,
; 1380 : 		const_iterator _Last_arg)
; 1381 : 		{	// erase [_First, _Last)
; 1382 : 		if (_First_arg == begin() && _Last_arg == end())
; 1383 : 			clear();
; 1384 : 		else if (_First_arg != _Last_arg)
; 1385 : 			{	// clear partial
; 1386 : 			iterator _First = _Make_iter(_First_arg);
; 1387 : 			iterator _Last = _Make_iter(_Last_arg);
; 1388 : 
; 1389 : 			if (_First != _Last)
; 1390 : 				{	// worth doing, copy down over hole
; 1391 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1392 : 				if (_Last < _First || _VICONT(_First) != this
; 1393 : 					|| _VIPTR(_First) < this->_Myfirst
; 1394 : 					|| this->_Mylast < _VIPTR(_Last))
; 1395 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1396 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1397 : 					_VIPTR(_First));
; 1398 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1399 : 
; 1400 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1401 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1402 : 					_VIPTR(_First));
; 1403 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1404 : 
; 1405 : 				_Destroy(_Ptr, this->_Mylast);
; 1406 : 				this->_Mylast = _Ptr;
; 1407 : 				}
; 1408 : 			}
; 1409 : 		return (_Make_iter(_First_arg));
; 1410 : 		}
; 1411 : 
; 1412 : 	void clear() _NOEXCEPT
; 1413 : 		{	// erase all
; 1414 : 		this->_Orphan_all();
; 1415 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1416 : 		this->_Mylast = this->_Myfirst;
; 1417 : 		}
; 1418 : 
; 1419 : 	void swap(_Myt& _Right)
; 1420 : 		{	// exchange contents with _Right
; 1421 : 		if (this == &_Right)
; 1422 : 			;	// same object, do nothing
; 1423 : 		else if (this->_Getal() == _Right._Getal())
; 1424 : 			{	// same allocator, swap control information
; 1425 : 			this->_Swap_all(_Right);
; 1426 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1427 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1428 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1429 : 			}
; 1430 : 
; 1431 :  #if _HAS_CPP0X
; 1432 : 		else if (_Alty::propagate_on_container_swap::value)
; 1433 : 			{	// swap allocators and control information
; 1434 : 			this->_Swap_alloc(_Right);
; 1435 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1436 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1437 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1438 : 			}
; 1439 :  #endif /* _HAS_CPP0X */
; 1440 : 
; 1441 : 		else
; 1442 : 			{	// different allocator, do multiple moves
; 1443 : 			_Myt _Ts = _Move(*this);
; 1444 : 
; 1445 : 			*this = _Move(_Right);
; 1446 : 			_Right = _Move(_Ts);
; 1447 : 			}
; 1448 : 		}
; 1449 : 
; 1450 : protected:
; 1451 : 	void _Assign_n(size_type _Count, const value_type& _Val)
; 1452 : 		{	// assign _Count * _Val
; 1453 : 		value_type _Tmp = _Val;	// in case _Val is in sequence
; 1454 : 		erase(begin(), end());
; 1455 : 		insert(begin(), _Count, _Tmp);
; 1456 : 		}
; 1457 : 
; 1458 : 	bool _Buy(size_type _Capacity)
; 1459 : 		{	// allocate array with _Capacity elements
; 1460 : 		this->_Myfirst = pointer();
; 1461 : 		this->_Mylast = pointer();
; 1462 : 		this->_Myend = pointer();
; 1463 : 
; 1464 : 		if (_Capacity == 0)
; 1465 : 			return (false);
; 1466 : 		else if (max_size() < _Capacity)
; 1467 : 			_Xlen();	// result too long
; 1468 : 		else
; 1469 : 			{	// nonempty array, allocate storage
; 1470 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1471 : 			this->_Mylast = this->_Myfirst;
; 1472 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1473 : 			}
; 1474 : 		return (true);
; 1475 : 		}
; 1476 : 
; 1477 : 	void _Destroy(pointer _First, pointer _Last)
; 1478 : 		{	// destroy [_First, _Last) using allocator
; 1479 : 		_Alty _Alval(this->_Getal());
; 1480 : 		_Destroy_range(_First, _Last, _Alval);
; 1481 : 		}
; 1482 : 
; 1483 : 	size_type _Grow_to(size_type _Count) const
; 1484 : 		{	// grow by 50% or at least to _Count
; 1485 : 		size_type _Capacity = capacity();
; 1486 : 
; 1487 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1488 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00046	48 8b c2	 mov	 rax, rdx
  00049	48 d1 e8	 shr	 rax, 1
  0004c	4c 2b c8	 sub	 r9, rax
  0004f	4c 3b ca	 cmp	 r9, rdx
  00052	73 12		 jae	 SHORT $LN27@Reserve
  00054	33 d2		 xor	 edx, edx

; 1489 : 		if (_Capacity < _Count)

  00056	49 3b d0	 cmp	 rdx, r8
  00059	49 0f 42 d0	 cmovb	 rdx, r8

; 1531 : 			}
; 1532 : 		}

  0005d	48 83 c4 28	 add	 rsp, 40			; 00000028H

; 1529 : 				_Xlen();
; 1530 : 			_Reallocate(_Grow_to(size() + _Count));

  00061	e9 00 00 00 00	 jmp	 ?_Reallocate@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAX_K@Z ; std::vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::_Reallocate
$LN27@Reserve:

; 1088 : 		}
; 1089 : 
; 1090 : 	size_type max_size() const _NOEXCEPT
; 1091 : 		{	// return maximum possible length of sequence
; 1092 : 		return (this->_Getal().max_size());
; 1093 : 		}
; 1094 : 
; 1095 : 	bool empty() const _NOEXCEPT
; 1096 : 		{	// test if sequence is empty
; 1097 : 		return (this->_Myfirst == this->_Mylast);
; 1098 : 		}
; 1099 : 
; 1100 : 	_Alloc get_allocator() const _NOEXCEPT
; 1101 : 		{	// return allocator object for values
; 1102 : 		return (this->_Getal());
; 1103 : 		}
; 1104 : 
; 1105 : 	const_reference at(size_type _Pos) const
; 1106 : 		{	// subscript nonmutable sequence with checking
; 1107 : 		if (size() <= _Pos)
; 1108 : 			_Xran();
; 1109 : 		return (*(this->_Myfirst + _Pos));
; 1110 : 		}
; 1111 : 
; 1112 : 	reference at(size_type _Pos)
; 1113 : 		{	// subscript mutable sequence with checking
; 1114 : 		if (size() <= _Pos)
; 1115 : 			_Xran();
; 1116 : 		return (*(this->_Myfirst + _Pos));
; 1117 : 		}
; 1118 : 
; 1119 : 	const_reference operator[](size_type _Pos) const
; 1120 : 		{	// subscript nonmutable sequence
; 1121 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1122 : 		if (size() <= _Pos)
; 1123 : 			{	// report error
; 1124 : 			_DEBUG_ERROR("vector subscript out of range");
; 1125 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1126 : 			}
; 1127 : 
; 1128 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1129 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1130 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1131 : 
; 1132 : 		return (*(this->_Myfirst + _Pos));
; 1133 : 		}
; 1134 : 
; 1135 : 	reference operator[](size_type _Pos)
; 1136 : 		{	// subscript mutable sequence
; 1137 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1138 : 		if (size() <= _Pos)
; 1139 : 			{	// report error
; 1140 : 			_DEBUG_ERROR("vector subscript out of range");
; 1141 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1142 : 			}
; 1143 : 
; 1144 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1145 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1146 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1147 : 
; 1148 : 		return (*(this->_Myfirst + _Pos));
; 1149 : 		}
; 1150 : 
; 1151 :  #if _HAS_CPP0X
; 1152 : 	pointer data() _NOEXCEPT
; 1153 : 		{	// return address of first element
; 1154 : 		return (this->_Myfirst);
; 1155 : 		}
; 1156 : 
; 1157 : 	const_pointer data() const _NOEXCEPT
; 1158 : 		{	// return address of first element
; 1159 : 		return (this->_Myfirst);
; 1160 : 		}
; 1161 :  #endif /* _HAS_CPP0X */
; 1162 : 
; 1163 : 	reference front()
; 1164 : 		{	// return first element of mutable sequence
; 1165 : 		return (*begin());
; 1166 : 		}
; 1167 : 
; 1168 : 	const_reference front() const
; 1169 : 		{	// return first element of nonmutable sequence
; 1170 : 		return (*begin());
; 1171 : 		}
; 1172 : 
; 1173 : 	reference back()
; 1174 : 		{	// return last element of mutable sequence
; 1175 : 		return (*(end() - 1));
; 1176 : 		}
; 1177 : 
; 1178 : 	const_reference back() const
; 1179 : 		{	// return last element of nonmutable sequence
; 1180 : 		return (*(end() - 1));
; 1181 : 		}
; 1182 : 
; 1183 : 	void push_back(const value_type& _Val)
; 1184 : 		{	// insert element at end
; 1185 : 		if (_Inside(_STD addressof(_Val)))
; 1186 : 			{	// push back an element
; 1187 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 1188 : 			if (this->_Mylast == this->_Myend)
; 1189 : 				_Reserve(1);
; 1190 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1191 : 			this->_Getal().construct(this->_Mylast,
; 1192 : 				this->_Myfirst[_Idx]);
; 1193 : 			++this->_Mylast;
; 1194 : 			}
; 1195 : 		else
; 1196 : 			{	// push back a non-element
; 1197 : 			if (this->_Mylast == this->_Myend)
; 1198 : 				_Reserve(1);
; 1199 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1200 : 			this->_Getal().construct(this->_Mylast,
; 1201 : 				_Val);
; 1202 : 			++this->_Mylast;
; 1203 : 			}
; 1204 : 		}
; 1205 : 
; 1206 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1207 : 	void pop_back()
; 1208 : 		{	// erase element at end
; 1209 : 		if (empty())
; 1210 : 			_DEBUG_ERROR("vector empty before pop");
; 1211 : 		else
; 1212 : 			{	// erase last element
; 1213 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1214 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1215 : 			--this->_Mylast;
; 1216 : 			}
; 1217 : 		}
; 1218 : 
; 1219 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1220 : 	void pop_back()
; 1221 : 		{	// erase element at end
; 1222 : 		if (!empty())
; 1223 : 			{	// erase last element
; 1224 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1225 : 			--this->_Mylast;
; 1226 : 			}
; 1227 : 		}
; 1228 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1229 : 
; 1230 : 	template<class _Iter>
; 1231 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1232 : 			void>::type
; 1233 : 		assign(_Iter _First, _Iter _Last)
; 1234 : 		{	// assign [_First, _Last), input iterators
; 1235 : 		erase(begin(), end());
; 1236 : 		insert(begin(), _First, _Last);
; 1237 : 		}
; 1238 : 
; 1239 : 	void assign(size_type _Count, const value_type& _Val)
; 1240 : 		{	// assign _Count * _Val
; 1241 : 		_Assign_n(_Count, _Val);
; 1242 : 		}
; 1243 : 
; 1244 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1245 : 		{	// insert _Val at _Where
; 1246 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1247 : 		}
; 1248 : 
; 1249 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1250 : 		const _Ty& _Val)
; 1251 : 		{	// insert _Count * _Val at _Where
; 1252 : 		return (_Insert_n(_Where, _Count, _Val));
; 1253 : 		}
; 1254 : 
; 1255 : 	template<class _Iter>
; 1256 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1257 : 			iterator>::type
; 1258 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1259 : 		{	// insert [_First, _Last) at _Where
; 1260 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1261 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1262 : 		return (begin() + _Off);
; 1263 : 		}
; 1264 : 
; 1265 : 	template<class _Iter>
; 1266 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1267 : 			input_iterator_tag)
; 1268 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1269 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1270 : 
; 1271 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1272 : 		if (size() < _Off)
; 1273 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1274 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1275 : 
; 1276 : 		if (_First != _Last)
; 1277 : 			{	// worth doing, gather at end and rotate into place
; 1278 : 			size_type _Oldsize = size();
; 1279 : 
; 1280 : 			_TRY_BEGIN
; 1281 : 			for (; _First != _Last; ++_First)
; 1282 : 				push_back(*_First);	// append
; 1283 : 
; 1284 : 			_CATCH_ALL
; 1285 : 			erase(begin() + _Oldsize, end());
; 1286 : 			_RERAISE;
; 1287 : 			_CATCH_END
; 1288 : 
; 1289 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1290 : 			}
; 1291 : 		}
; 1292 : 
; 1293 : 	template<class _Iter>
; 1294 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1295 : 			forward_iterator_tag)
; 1296 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1297 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1298 : 		if (_VICONT(_Where) != this
; 1299 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1300 : 			|| this->_Mylast < _VIPTR(_Where))
; 1301 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1302 : 		_DEBUG_RANGE(_First, _Last);
; 1303 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1304 : 
; 1305 : 		size_type _Count = 0;
; 1306 : 		_Distance(_First, _Last, _Count);
; 1307 : 
; 1308 : 		if (_Count == 0)
; 1309 : 			;
; 1310 : 		else if (_Unused_capacity() < _Count)
; 1311 : 			{	// not enough room, reallocate
; 1312 : 			if (max_size() - size() < _Count)
; 1313 : 				_Xlen();	// result too long
; 1314 : 
; 1315 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1316 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1317 : 			pointer _Ptr = _Newvec;
; 1318 : 
; 1319 : 			_TRY_BEGIN
; 1320 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1321 : 				_Newvec);	// copy prefix
; 1322 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1323 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1324 : 				_Ptr);	// copy suffix
; 1325 : 			_CATCH_ALL
; 1326 : 			_Destroy(_Newvec, _Ptr);
; 1327 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1328 : 			_RERAISE;
; 1329 : 			_CATCH_END
; 1330 : 
; 1331 : 			_Count += size();
; 1332 : 			if (this->_Myfirst != pointer())
; 1333 : 				{	// destroy and deallocate old array
; 1334 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1335 : 				this->_Getal().deallocate(this->_Myfirst,
; 1336 : 					this->_Myend - this->_Myfirst);
; 1337 : 				}
; 1338 : 
; 1339 : 			this->_Orphan_all();
; 1340 : 			this->_Myend = _Newvec + _Capacity;
; 1341 : 			this->_Mylast = _Newvec + _Count;
; 1342 : 			this->_Myfirst = _Newvec;
; 1343 : 			}
; 1344 : 		else
; 1345 : 			{	// new stuff fits, append and rotate into place
; 1346 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1347 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1348 : 				this->_Mylast + _Count);
; 1349 : 			this->_Mylast += _Count;
; 1350 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1351 : 			}
; 1352 : 		}
; 1353 : 
; 1354 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1355 : 	iterator erase(const_iterator _Where)
; 1356 : 		{	// erase element at where
; 1357 : 		if (_VICONT(_Where) != this
; 1358 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1359 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1360 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1361 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1362 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1363 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1364 : 		--this->_Mylast;
; 1365 : 		return (_Make_iter(_Where));
; 1366 : 		}
; 1367 : 
; 1368 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1369 : 	iterator erase(const_iterator _Where)
; 1370 : 		{	// erase element at where
; 1371 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1372 : 			_VIPTR(_Where));
; 1373 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1374 : 		--this->_Mylast;
; 1375 : 		return (_Make_iter(_Where));
; 1376 : 		}
; 1377 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1378 : 
; 1379 : 	iterator erase(const_iterator _First_arg,
; 1380 : 		const_iterator _Last_arg)
; 1381 : 		{	// erase [_First, _Last)
; 1382 : 		if (_First_arg == begin() && _Last_arg == end())
; 1383 : 			clear();
; 1384 : 		else if (_First_arg != _Last_arg)
; 1385 : 			{	// clear partial
; 1386 : 			iterator _First = _Make_iter(_First_arg);
; 1387 : 			iterator _Last = _Make_iter(_Last_arg);
; 1388 : 
; 1389 : 			if (_First != _Last)
; 1390 : 				{	// worth doing, copy down over hole
; 1391 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1392 : 				if (_Last < _First || _VICONT(_First) != this
; 1393 : 					|| _VIPTR(_First) < this->_Myfirst
; 1394 : 					|| this->_Mylast < _VIPTR(_Last))
; 1395 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1396 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1397 : 					_VIPTR(_First));
; 1398 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1399 : 
; 1400 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1401 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1402 : 					_VIPTR(_First));
; 1403 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1404 : 
; 1405 : 				_Destroy(_Ptr, this->_Mylast);
; 1406 : 				this->_Mylast = _Ptr;
; 1407 : 				}
; 1408 : 			}
; 1409 : 		return (_Make_iter(_First_arg));
; 1410 : 		}
; 1411 : 
; 1412 : 	void clear() _NOEXCEPT
; 1413 : 		{	// erase all
; 1414 : 		this->_Orphan_all();
; 1415 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1416 : 		this->_Mylast = this->_Myfirst;
; 1417 : 		}
; 1418 : 
; 1419 : 	void swap(_Myt& _Right)
; 1420 : 		{	// exchange contents with _Right
; 1421 : 		if (this == &_Right)
; 1422 : 			;	// same object, do nothing
; 1423 : 		else if (this->_Getal() == _Right._Getal())
; 1424 : 			{	// same allocator, swap control information
; 1425 : 			this->_Swap_all(_Right);
; 1426 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1427 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1428 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1429 : 			}
; 1430 : 
; 1431 :  #if _HAS_CPP0X
; 1432 : 		else if (_Alty::propagate_on_container_swap::value)
; 1433 : 			{	// swap allocators and control information
; 1434 : 			this->_Swap_alloc(_Right);
; 1435 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1436 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1437 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1438 : 			}
; 1439 :  #endif /* _HAS_CPP0X */
; 1440 : 
; 1441 : 		else
; 1442 : 			{	// different allocator, do multiple moves
; 1443 : 			_Myt _Ts = _Move(*this);
; 1444 : 
; 1445 : 			*this = _Move(_Right);
; 1446 : 			_Right = _Move(_Ts);
; 1447 : 			}
; 1448 : 		}
; 1449 : 
; 1450 : protected:
; 1451 : 	void _Assign_n(size_type _Count, const value_type& _Val)
; 1452 : 		{	// assign _Count * _Val
; 1453 : 		value_type _Tmp = _Val;	// in case _Val is in sequence
; 1454 : 		erase(begin(), end());
; 1455 : 		insert(begin(), _Count, _Tmp);
; 1456 : 		}
; 1457 : 
; 1458 : 	bool _Buy(size_type _Capacity)
; 1459 : 		{	// allocate array with _Capacity elements
; 1460 : 		this->_Myfirst = pointer();
; 1461 : 		this->_Mylast = pointer();
; 1462 : 		this->_Myend = pointer();
; 1463 : 
; 1464 : 		if (_Capacity == 0)
; 1465 : 			return (false);
; 1466 : 		else if (max_size() < _Capacity)
; 1467 : 			_Xlen();	// result too long
; 1468 : 		else
; 1469 : 			{	// nonempty array, allocate storage
; 1470 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1471 : 			this->_Mylast = this->_Myfirst;
; 1472 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1473 : 			}
; 1474 : 		return (true);
; 1475 : 		}
; 1476 : 
; 1477 : 	void _Destroy(pointer _First, pointer _Last)
; 1478 : 		{	// destroy [_First, _Last) using allocator
; 1479 : 		_Alty _Alval(this->_Getal());
; 1480 : 		_Destroy_range(_First, _Last, _Alval);
; 1481 : 		}
; 1482 : 
; 1483 : 	size_type _Grow_to(size_type _Count) const
; 1484 : 		{	// grow by 50% or at least to _Count
; 1485 : 		size_type _Capacity = capacity();
; 1486 : 
; 1487 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1488 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00066	48 03 d0	 add	 rdx, rax

; 1489 : 		if (_Capacity < _Count)

  00069	49 3b d0	 cmp	 rdx, r8
  0006c	49 0f 42 d0	 cmovb	 rdx, r8

; 1531 : 			}
; 1532 : 		}

  00070	48 83 c4 28	 add	 rsp, 40			; 00000028H

; 1529 : 				_Xlen();
; 1530 : 			_Reallocate(_Grow_to(size() + _Count));

  00074	e9 00 00 00 00	 jmp	 ?_Reallocate@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAX_K@Z ; std::vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::_Reallocate
$LN2@Reserve:

; 1531 : 			}
; 1532 : 		}

  00079	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0007d	c3		 ret	 0
$LN42@Reserve:

; 1533 : 
; 1534 : 	void _Tidy()
; 1535 : 		{	// free all storage
; 1536 : 		if (this->_Myfirst != pointer())
; 1537 : 			{	// something to free, destroy and deallocate it
; 1538 : 			this->_Orphan_all();
; 1539 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1540 : 			this->_Getal().deallocate(this->_Myfirst,
; 1541 : 				this->_Myend - this->_Myfirst);
; 1542 : 			this->_Myfirst = pointer();
; 1543 : 			this->_Mylast = pointer();
; 1544 : 			this->_Myend = pointer();
; 1545 : 			}
; 1546 : 		}
; 1547 : 
; 1548 : 	template<class _Iter>
; 1549 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)
; 1550 : 		{	// copy initializing [_First, _Last), using allocator
; 1551 : 		_Alty _Alval(this->_Getal());
; 1552 : 		return (_Uninitialized_copy(_First, _Last,
; 1553 : 			_Ptr, _Alval));
; 1554 : 		}
; 1555 : 
; 1556 : 	template<class _Iter>
; 1557 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)
; 1558 : 		{	// move initializing [_First, _Last), using allocator
; 1559 : 		_Alty _Alval(this->_Getal());
; 1560 : 		return (_Uninitialized_move(_First, _Last,
; 1561 : 			_Ptr, _Alval));
; 1562 : 		}
; 1563 : 
; 1564 : 	iterator _Insert_n(const_iterator _Where,
; 1565 : 		size_type _Count, const value_type& _Val)
; 1566 : 		{	// insert _Count * _Val at _Where
; 1567 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1568 : 		if (_VICONT(_Where) != this
; 1569 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1570 : 			|| this->_Mylast < _VIPTR(_Where))
; 1571 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1572 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1573 : 
; 1574 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1575 : 		if (_Count == 0)
; 1576 : 			;
; 1577 : 		else if (_Unused_capacity() < _Count)
; 1578 : 			{	// not enough room, reallocate
; 1579 : 			if (max_size() - size() < _Count)
; 1580 : 				_Xlen();	// result too long
; 1581 : 
; 1582 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1583 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1584 : 			size_type _Whereoff = _VIPTR(_Where) - this->_Myfirst;
; 1585 : 			int _Ncopied = 0;
; 1586 : 
; 1587 : 			_TRY_BEGIN
; 1588 : 			_Ufill(_Newvec + _Whereoff, _Count,
; 1589 : 				_STD addressof(_Val));	// add new stuff
; 1590 : 			++_Ncopied;
; 1591 : 			_Umove(this->_Myfirst, _VIPTR(_Where),
; 1592 : 				_Newvec);	// copy prefix
; 1593 : 			++_Ncopied;
; 1594 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1595 : 				_Newvec + (_Whereoff + _Count));	// copy suffix
; 1596 : 			_CATCH_ALL
; 1597 : 			if (1 < _Ncopied)
; 1598 : 				_Destroy(_Newvec, _Newvec + _Whereoff);
; 1599 : 			if (0 < _Ncopied)
; 1600 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);
; 1601 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1602 : 			_RERAISE;
; 1603 : 			_CATCH_END
; 1604 : 
; 1605 : 			_Count += size();
; 1606 : 			if (this->_Myfirst != pointer())
; 1607 : 				{	// destroy and deallocate old array
; 1608 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1609 : 				this->_Getal().deallocate(this->_Myfirst,
; 1610 : 					this->_Myend - this->_Myfirst);
; 1611 : 				}
; 1612 : 
; 1613 : 			this->_Orphan_all();
; 1614 : 			this->_Myend = _Newvec + _Capacity;
; 1615 : 			this->_Mylast = _Newvec + _Count;
; 1616 : 			this->_Myfirst = _Newvec;
; 1617 : 			}
; 1618 : 		else if ((size_type)(this->_Mylast - _VIPTR(_Where))
; 1619 : 			< _Count)
; 1620 : 			{	// new stuff spills off end
; 1621 : 			value_type _Tmp = _Val;	// in case _Val is in sequence
; 1622 : 
; 1623 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1624 : 				_VIPTR(_Where) + _Count);	// copy suffix
; 1625 : 
; 1626 : 			_TRY_BEGIN
; 1627 : 			_Ufill(this->_Mylast,
; 1628 : 				_Count - (this->_Mylast - _VIPTR(_Where)),
; 1629 : 				_STD addressof(_Tmp));	// insert new stuff off end
; 1630 : 			_CATCH_ALL
; 1631 : 			_Destroy(_VIPTR(_Where) + _Count,
; 1632 : 				this->_Mylast + _Count);
; 1633 : 			_RERAISE;
; 1634 : 			_CATCH_END
; 1635 : 
; 1636 : 			this->_Mylast += _Count;
; 1637 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1638 : 			_STD fill(_VIPTR(_Where), this->_Mylast - _Count,
; 1639 : 				_Tmp);	// insert up to old end
; 1640 : 			}
; 1641 : 		else
; 1642 : 			{	// new stuff can all be assigned
; 1643 : 			value_type _Tmp = _Val;	// in case _Val is in sequence
; 1644 : 
; 1645 : 			pointer _Oldend = this->_Mylast;
; 1646 : 			this->_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1647 : 				this->_Mylast);	// copy suffix
; 1648 : 
; 1649 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1650 : 			_Copy_backward(_VIPTR(_Where), _Oldend - _Count,
; 1651 : 				_Oldend);	// copy hole
; 1652 : 			_STD fill(_VIPTR(_Where),
; 1653 : 				_VIPTR(_Where) + _Count, _Tmp);	// insert into hole
; 1654 : 			}
; 1655 : 		return (begin() + _Off);
; 1656 : 		}
; 1657 : 
; 1658 : 	pointer _Ufill(pointer _Ptr, size_type _Count, const value_type *_Pval)
; 1659 : 		{	// copy initializing _Count * _Val, using allocator
; 1660 : 		_Alty _Alval(this->_Getal());
; 1661 : 		_Uninitialized_fill_n(_Ptr, _Count, _Pval, _Alval);
; 1662 : 		return (_Ptr + _Count);
; 1663 : 		}
; 1664 : 
; 1665 : 	__declspec(noreturn) void _Xlen() const
; 1666 : 		{	// report a length_error
; 1667 : 		_Xlength_error("vector<T> too long");

  0007e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00085	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPEBD@Z ; std::_Xlength_error
  0008a	cc		 int	 3
$LN41@Reserve:
?_Reserve@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAX_K@Z ENDP ; std::vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::_Reserve
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?_Tidy@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAXXZ
_TEXT	SEGMENT
this$ = 48
?_Tidy@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAXXZ PROC ; std::vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::_Tidy, COMDAT

; 1535 : 		{	// free all storage

$LN47:
  00000	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1536 : 		if (this->_Myfirst != pointer())

  0000a	48 8b 39	 mov	 rdi, QWORD PTR [rcx]
  0000d	48 8b f1	 mov	 rsi, rcx
  00010	48 85 ff	 test	 rdi, rdi
  00013	74 69		 je	 SHORT $LN1@Tidy

; 1537 : 			{	// something to free, destroy and deallocate it
; 1538 : 			this->_Orphan_all();
; 1539 : 			_Destroy(this->_Myfirst, this->_Mylast);

  00015	48 89 6c 24 38	 mov	 QWORD PTR [rsp+56], rbp
  0001a	48 8b 69 08	 mov	 rbp, QWORD PTR [rcx+8]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 88   : 	for (; _First != _Last; ++_First)

  0001e	48 3b fd	 cmp	 rdi, rbp
  00021	74 41		 je	 SHORT $LN12@Tidy
  00023	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx
  00028	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL14@Tidy:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  00030	48 8b 5f 08	 mov	 rbx, QWORD PTR [rdi+8]
  00034	48 85 db	 test	 rbx, rbx
  00037	74 1d		 je	 SHORT $LN34@Tidy

; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  00039	f0 ff 4b 08	 lock dec DWORD PTR [rbx+8]
  0003d	75 17		 jne	 SHORT $LN34@Tidy

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  0003f	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00042	48 8b cb	 mov	 rcx, rbx
  00045	ff 10		 call	 QWORD PTR [rax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  00047	f0 ff 4b 0c	 lock dec DWORD PTR [rbx+12]
  0004b	75 09		 jne	 SHORT $LN34@Tidy

; 128  : 			_Delete_this();

  0004d	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00050	48 8b cb	 mov	 rcx, rbx
  00053	ff 50 08	 call	 QWORD PTR [rax+8]
$LN34@Tidy:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 88   : 	for (; _First != _Last; ++_First)

  00056	48 83 c7 10	 add	 rdi, 16
  0005a	48 3b fd	 cmp	 rdi, rbp
  0005d	75 d1		 jne	 SHORT $LL14@Tidy
  0005f	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
$LN12@Tidy:

; 89   : 		_Al.destroy(_First);
; 90   : 	}
; 91   : 
; 92   : template<class _Alloc> inline
; 93   : 	void _Destroy_range(typename _Alloc::pointer _First,
; 94   : 		typename _Alloc::pointer _Last, _Alloc& _Al,
; 95   : 		_Scalar_ptr_iterator_tag)
; 96   : 	{	// destroy [_First, _Last), scalar type (do nothing)
; 97   : 	}
; 98   : 
; 99   : 		// TEMPLATE CLASS _Is_simple_alloc
; 100  : template<class _Alty>
; 101  : 	struct _Is_simple_alloc
; 102  : 		: _Cat_base<is_same<typename _Alty::size_type, size_t>::value
; 103  : 		&& is_same<typename _Alty::difference_type, ptrdiff_t>::value
; 104  : 		&& is_same<typename _Alty::pointer,
; 105  : 			typename _Alty::value_type *>::value
; 106  : 		&& is_same<typename _Alty::const_pointer,
; 107  : 			const typename _Alty::value_type *>::value
; 108  : 		&& is_same<typename _Alty::reference,
; 109  : 			typename _Alty::value_type&>::value
; 110  : 		&& is_same<typename _Alty::const_reference,
; 111  : 			const typename _Alty::value_type&>::value>
; 112  : 	{	// tests if allocator has simple addressing
; 113  : 	};
; 114  : 
; 115  : 		// TEMPLATE CLASS _Simple_types
; 116  : template<class _Value_type>
; 117  : 	struct _Simple_types
; 118  : 	{	// wraps types needed by iterators
; 119  : 	typedef _Value_type value_type;
; 120  : 	typedef size_t size_type;
; 121  : 	typedef ptrdiff_t difference_type;
; 122  : 	typedef value_type *pointer;
; 123  : 	typedef const value_type *const_pointer;
; 124  : 	typedef value_type& reference;
; 125  : 	typedef const value_type& const_reference;
; 126  : 	};
; 127  : 
; 128  :  #if _HAS_CPP0X
; 129  : 		// TEMPLATE CLASS _Get_voidptr
; 130  : template<class _Alty,
; 131  : 	class _Pointer>
; 132  : 	struct _Get_voidptr
; 133  : 	{	// get void pointer for allocator
; 134  : 	typedef typename _Alty::template rebind<void>::other _Alvoid;
; 135  : 	typedef typename _Alvoid::pointer type;
; 136  : 	};
; 137  : 
; 138  : template<class _Alty,
; 139  : 	class _Ty>
; 140  : 	struct _Get_voidptr<_Alty, _Ty *>
; 141  : 	{	// get raw void pointer for allocator
; 142  : 	typedef void *type;
; 143  : 	};
; 144  : 
; 145  : 		// TEMPLATE CLASS _Is_iterator
; 146  : template<class _Iter>
; 147  : 	struct _Is_iterator
; 148  : 	: public integral_constant<bool, !is_integral<_Iter>::value>
; 149  : 	{	// tests for reasonable iterator candidate
; 150  : 	};
; 151  : 
; 152  : 		// TEMPLATE CLASS pointer_traits
; 153  : template<class _Ty>
; 154  : 	struct pointer_traits;
; 155  : 
; 156  : template<class _Ty>
; 157  : 	struct _Get_first_parameter
; 158  : 	{	// get _Ty::element_type
; 159  : 	typedef typename _Ty::element_type type;
; 160  : 	};
; 161  : 
; 162  : 		// TEMPLATE STRUCT _Replace_first_parameter
; 163  : template<class _Newfirst,
; 164  : 	class _Ty>
; 165  : 	struct _Replace_first_parameter
; 166  : 	{	// get _Ty::element_type
; 167  : 	typedef typename _Ty::template rebind<_Newfirst>::other type;
; 168  : 	};
; 169  : 
; 170  : 		// TEMPLATE STRUCT _Get_element_type
; 171  : template<class _Ty>
; 172  : 	struct _Get_element_type
; 173  : 	_GET_TYPE_OR_DEFAULT(element_type,
; 174  : 		typename _Get_first_parameter<_Ty>::type);
; 175  : 
; 176  : 		// TEMPLATE STRUCT _Get_ptr_difference_type
; 177  : template<class _Ty>
; 178  : 	struct _Get_ptr_difference_type
; 179  : 	_GET_TYPE_OR_DEFAULT(difference_type,
; 180  : 		ptrdiff_t);
; 181  : 
; 182  : 		// TEMPLATE STRUCT _Get_rebind_type
; 183  : template<class _Ty,
; 184  : 	class _Other>
; 185  : 	struct _Get_rebind_type
; 186  : 	_GET_TYPE_OR_DEFAULT(template rebind<_Other>::other,
; 187  : 		typename _Replace_first_parameter<_Other _COMMA _Uty>::type);
; 188  : 
; 189  : 		// TEMPLATE CLASS pointer_traits
; 190  : template<class _Ty>
; 191  : 	struct pointer_traits
; 192  : 	{	// defines traits for arbitrary pointers
; 193  : 	typedef pointer_traits<_Ty> other;
; 194  : 
; 195  : 	typedef typename _Get_element_type<_Ty>::type element_type;
; 196  : 	typedef _Ty pointer;
; 197  : 	typedef typename _Get_ptr_difference_type<_Ty>::type difference_type;
; 198  : 
; 199  : 	template<class _Other>
; 200  : 		struct rebind
; 201  : 		{	// converts X<element_type> to X<_Other>
; 202  : 		typedef typename _Get_rebind_type<_Ty, _Other>::type other;
; 203  : 		};
; 204  : 
; 205  : 	static pointer pointer_to(element_type& _Val)
; 206  : 		{	// convert raw reference to pointer
; 207  : 		return (_Ty::pointer_to(_Val));
; 208  : 		}
; 209  : 	};
; 210  : 
; 211  : 		// TEMPLATE CLASS pointer_traits<_Ty *>
; 212  : template<class _Ty>
; 213  : 	struct pointer_traits<_Ty *>
; 214  : 	{	// defines traits for raw pointers
; 215  : 	typedef pointer_traits<_Ty *> other;
; 216  : 
; 217  : 	typedef _Ty element_type;
; 218  : 	typedef _Ty *pointer;
; 219  : 	typedef ptrdiff_t difference_type;
; 220  : 
; 221  : 	template<class _Other>
; 222  : 		struct rebind
; 223  : 		{	// converts to a pointer to _Other
; 224  : 		typedef _Other *other;
; 225  : 		};
; 226  : 
; 227  : 	typedef typename _If<is_void<_Ty>::value,
; 228  : 		char&,
; 229  : 		typename add_reference<_Ty>::type>::type _Reftype;
; 230  : 
; 231  : 	static pointer pointer_to(_Reftype _Val)
; 232  : 		{	// convert raw reference to pointer
; 233  : 		return (_STD addressof(_Val));
; 234  : 		}
; 235  : 	};
; 236  : 
; 237  : 		// TEMPLATE STRUCT _Get_pointer_type
; 238  : template<class _Ty>
; 239  : 	struct _Get_pointer_type
; 240  : 	_GET_TYPE_OR_DEFAULT(pointer,
; 241  : 		typename _Ty::value_type *);
; 242  : 
; 243  : 		// TEMPLATE STRUCT _Get_const_pointer_type
; 244  : template<class _Ty>
; 245  : 	struct _Get_const_pointer_type
; 246  : 	_GET_TYPE_OR_DEFAULT(const_pointer,
; 247  : 		typename pointer_traits<typename _Get_pointer_type<_Ty>::type>
; 248  : 			::template rebind<const typename _Ty::value_type>::other);
; 249  : 
; 250  : 		// TEMPLATE STRUCT _Get_void_pointer_type
; 251  : template<class _Ty>
; 252  : 	struct _Get_void_pointer_type
; 253  : 	_GET_TYPE_OR_DEFAULT(void_pointer,
; 254  : 		typename pointer_traits<typename _Get_pointer_type<_Ty>::type>
; 255  : 			::template rebind<void>::other);
; 256  : 
; 257  : 		// TEMPLATE STRUCT _Get_const_void_pointer_type
; 258  : template<class _Ty>
; 259  : 	struct _Get_const_void_pointer_type
; 260  : 	_GET_TYPE_OR_DEFAULT(const_void_pointer,
; 261  : 		typename pointer_traits<typename _Get_pointer_type<_Ty>::type>
; 262  : 			::template rebind<const void>::other);
; 263  : 
; 264  : 		// TEMPLATE STRUCT _Get_difference_type
; 265  : template<class _Ty>
; 266  : 	struct _Get_difference_type
; 267  : 	_GET_TYPE_OR_DEFAULT(difference_type,
; 268  : 		typename _Get_ptr_difference_type<
; 269  : 			typename _Get_pointer_type<_Ty>::type>::type);
; 270  : 
; 271  : 		// TEMPLATE STRUCT _Get_size_type
; 272  : template<class _Ty>
; 273  : 	struct _Get_size_type
; 274  : 	_GET_TYPE_OR_DEFAULT(size_type,
; 275  : 		typename make_unsigned<
; 276  : 			typename _Get_difference_type<_Ty>::type>::type);
; 277  : 
; 278  : 		// TEMPLATE STRUCT _Get_propagate_on_container_copy
; 279  : template<class _Ty>
; 280  : 	struct _Get_propagate_on_container_copy
; 281  : 	_GET_TYPE_OR_DEFAULT(propagate_on_container_copy_assignment,
; 282  : 		false_type);
; 283  : 
; 284  : 		// TEMPLATE STRUCT _Get_propagate_on_container_move
; 285  : template<class _Ty>
; 286  : 	struct _Get_propagate_on_container_move
; 287  : 	_GET_TYPE_OR_DEFAULT(propagate_on_container_move_assignment,
; 288  : 		false_type);
; 289  : 
; 290  : 		// TEMPLATE STRUCT _Get_propagate_on_container_swap
; 291  : template<class _Ty>
; 292  : 	struct _Get_propagate_on_container_swap
; 293  : 	_GET_TYPE_OR_DEFAULT(propagate_on_container_swap,
; 294  : 		false_type);
; 295  : 
; 296  : 		// STRUCT _Alloc_allocate
; 297  : struct _Alloc_allocate
; 298  : 	{	// determines allocator_traits<_Alloc>
; 299  : 		// ::allocate(size_type, const_void_pointer)
; 300  : 
; 301  : 	template<class _Alloc,
; 302  : 		class _Size_type,
; 303  : 		class _Const_void_pointer>
; 304  : 		static auto _Fn(int, _Alloc& _Al,
; 305  : 			_Size_type _Count,
; 306  : 			_Const_void_pointer _Hint)
; 307  : 			-> decltype(_Al.allocate(_Count, _Hint))
; 308  : 		{	// call allocator supplied version
; 309  : 		return (_Al.allocate(_Count, _Hint));
; 310  : 		}
; 311  : 
; 312  : 	template<class _Alloc,
; 313  : 		class _Size_type,
; 314  : 		class _Const_void_pointer>
; 315  : 		static auto _Fn(_Wrap_int, _Alloc& _Al,
; 316  : 			_Size_type _Count,
; 317  : 			_Const_void_pointer)
; 318  : 			-> decltype(_Al.allocate(_Count))
; 319  : 		{	// call default version
; 320  : 		return (_Al.allocate(_Count));
; 321  : 		}
; 322  : 	};
; 323  : 
; 324  : 		// STRUCT _Alloc_construct
; 325  : struct _Alloc_construct
; 326  : 	{	// determines allocator_traits<_Ty>
; 327  : 		// ::construct(_Ty&, _Objty *, _Types...)
; 328  : 
; 329  : #define _ALLOC_CONSTRUCT( \
; 330  : 	TEMPLATE_LIST, PADDING_LIST, LIST, COMMA, CALL_OPT, X2, X3, X4) \
; 331  : 	template<class _Ty, \
; 332  : 		class _Objty COMMA LIST(_CLASS_TYPE)> \
; 333  : 		static auto _Fn(int, _Ty& _Al, _Objty *_Ptr \
; 334  : 			COMMA LIST(_TYPE_REFREF_ARG)) \
; 335  : 			-> decltype( \
; 336  : 				_Al.construct(_Ptr COMMA LIST(_FORWARD_ARG))) \
; 337  : 		{	/* call allocator supplied version */ \
; 338  : 		_Al.construct(_Ptr COMMA LIST(_FORWARD_ARG)); \
; 339  : 		} \
; 340  : 	template<class _Ty, \
; 341  : 		class _Objty COMMA LIST(_CLASS_TYPE)> \
; 342  : 		static auto _Fn(_Wrap_int, _Ty&, _Objty *_Ptr \
; 343  : 			COMMA LIST(_TYPE_REFREF_ARG)) \
; 344  : 			-> void \
; 345  : 		{	/* call default version */ \
; 346  : 		::new (static_cast<void *>(_Ptr)) \
; 347  : 			_Objty(LIST(_FORWARD_ARG)); \
; 348  : 		}
; 349  : 
; 350  : _VARIADIC_EXPAND_0X(_ALLOC_CONSTRUCT, , , , )
; 351  : #undef _ALLOC_CONSTRUCT
; 352  : 	};
; 353  : 
; 354  : 		// STRUCT _Alloc_destroy
; 355  : struct _Alloc_destroy
; 356  : 	{	// determines allocator_traits<_Ty>::destroy(_Ty&, _Objty *)
; 357  : 	template<class _Ty,
; 358  : 		class _Objty>
; 359  : 		static auto _Fn(int, _Ty& _Al, _Objty *_Ptr)
; 360  : 			-> decltype(_Al.destroy(_Ptr))
; 361  : 		{	// call allocator supplied version
; 362  : 		_Al.destroy(_Ptr);
; 363  : 		}
; 364  : 
; 365  : 	template<class _Ty,
; 366  : 		class _Objty>
; 367  : 		static auto _Fn(_Wrap_int, _Ty&, _Objty *_Ptr)
; 368  : 			-> void
; 369  : 		{	// call default version
; 370  : 		_Ptr->~_Objty();
; 371  : 		}
; 372  : 	};
; 373  : 
; 374  : 		// STRUCT _Alloc_max_size
; 375  : struct _Alloc_max_size
; 376  : 	{	// determines allocator_traits<_Ty>::max_size(const _Ty&)
; 377  : 	template<class _Ty>
; 378  : 		static auto _Fn(int, const _Ty& _Al)
; 379  : 			-> decltype(_Al.max_size())
; 380  : 		{	// call allocator supplied version
; 381  : 		return (_Al.max_size());
; 382  : 		}
; 383  : 
; 384  : 	template<class _Ty>
; 385  : 		static auto _Fn(_Wrap_int, const _Ty&)
; 386  : 			-> typename _Get_size_type<_Ty>::type
; 387  : 		{	// call default version
; 388  : 		return ((numeric_limits<typename _Get_size_type<_Ty>::type>::max)());
; 389  : 		}
; 390  : 	};
; 391  : 
; 392  : 		// STRUCT _Alloc_select
; 393  : struct _Alloc_select
; 394  : 	{	// determines allocator_traits<_Ty>
; 395  : 		// ::select_on_container_copy_construction(const _Alloc&)
; 396  : 
; 397  : 	template<class _Ty>
; 398  : 		static auto _Fn(int, const _Ty& _Al)
; 399  : 			-> decltype((_Ty)_Al.select_on_container_copy_construction())
; 400  : 		{	// call allocator supplied version
; 401  : 		return (_Al.select_on_container_copy_construction());
; 402  : 		}
; 403  : 
; 404  : 	template<class _Ty>
; 405  : 		static auto _Fn(_Wrap_int, const _Ty& _Al)
; 406  : 			-> _Ty
; 407  : 		{	// call default version
; 408  : 		return (_Al);
; 409  : 		}
; 410  : 	};
; 411  : 
; 412  : 		// TEMPLATE CLASS allocator_traits
; 413  : template<class _Alloc>
; 414  : 	struct allocator_traits
; 415  : 	{	// defines traits for allocators
; 416  : 	typedef allocator_traits<_Alloc> other;
; 417  : 
; 418  : 	typedef _Alloc allocator_type;
; 419  : 	typedef typename _Alloc::value_type value_type;
; 420  : 
; 421  : 	typedef typename _Get_pointer_type<_Alloc>::type
; 422  : 		pointer;
; 423  : 	typedef typename _Get_const_pointer_type<_Alloc>::type
; 424  : 		const_pointer;
; 425  : 	typedef typename _Get_void_pointer_type<_Alloc>::type
; 426  : 		void_pointer;
; 427  : 	typedef typename _Get_const_void_pointer_type<_Alloc>::type
; 428  : 		const_void_pointer;
; 429  : 
; 430  : 	typedef typename _Get_size_type<_Alloc>::type size_type;
; 431  : 	typedef typename _Get_difference_type<_Alloc>::type difference_type;
; 432  : 
; 433  : 	typedef typename _Get_propagate_on_container_copy<_Alloc>::type
; 434  : 		propagate_on_container_copy_assignment;
; 435  : 	typedef typename _Get_propagate_on_container_move<_Alloc>::type
; 436  : 		propagate_on_container_move_assignment;
; 437  : 	typedef typename _Get_propagate_on_container_swap<_Alloc>::type
; 438  : 		propagate_on_container_swap;
; 439  : 
; 440  : 	template<class _Other>
; 441  : 		struct rebind_alloc
; 442  : 		{	// converts allocator<element_type> to allocator<_Other>
; 443  : 		typedef typename _Get_rebind_type<_Alloc, _Other>::type other;
; 444  : 		};
; 445  : 
; 446  : 	template<class _Other>
; 447  : 		struct rebind_traits
; 448  : 		{	// converts allocator_traits<X<element_type>>
; 449  : 			// to allocator_traits<X<_Other>>
; 450  : 		typedef typename rebind_alloc<_Other>::other _Other_alloc;
; 451  : 		typedef allocator_traits<_Other_alloc> other;
; 452  : 		};
; 453  : 
; 454  : 	static pointer allocate(_Alloc& _Al, size_type _Count)
; 455  : 		{	// allocate array of _Count elements
; 456  : 		return (_Al.allocate(_Count));
; 457  : 		}
; 458  : 
; 459  : 	static pointer allocate(_Alloc& _Al, size_type _Count,
; 460  : 		const_void_pointer _Hint)
; 461  : 		{	// allocate array of _Count elements, with hint
; 462  : 		return (_Alloc_allocate::_Fn(0, _Al, _Count, _Hint));
; 463  : 		}
; 464  : 
; 465  : 	static void deallocate(_Alloc& _Al,
; 466  : 		pointer _Ptr, size_type _Count)
; 467  : 		{	// deallocate _Count elements at _Ptr
; 468  : 		_Al.deallocate(_Ptr, _Count);
; 469  : 		}
; 470  : 
; 471  : #define _ALLOC_TRAITS_CONSTRUCT( \
; 472  : 	TEMPLATE_LIST, PADDING_LIST, LIST, COMMA, CALL_OPT, X2, X3, X4) \
; 473  : 	template<class _Ty COMMA LIST(_CLASS_TYPE)> \
; 474  : 		static void construct(_Alloc& _Al, _Ty *_Ptr \
; 475  : 			COMMA LIST(_TYPE_REFREF_ARG)) \
; 476  : 		{	/* construct _Ty(_Types...) at _Ptr */ \
; 477  : 		_Alloc_construct::_Fn(0, _Al, _Ptr COMMA LIST(_FORWARD_ARG)); \
; 478  : 		}
; 479  : 
; 480  : _VARIADIC_EXPAND_0X(_ALLOC_TRAITS_CONSTRUCT, , , , )
; 481  : #undef _ALLOC_TRAITS_CONSTRUCT
; 482  : 
; 483  : 	template<class _Ty>
; 484  : 		static void destroy(_Alloc& _Al, _Ty *_Ptr)
; 485  : 		{	// destroy object at _Ptr
; 486  : 		_Alloc_destroy::_Fn(0, _Al, _Ptr);
; 487  : 		}
; 488  : 
; 489  : 	static size_type max_size(const _Alloc& _Al)
; 490  : 		{	// get maximum size
; 491  : 		return (_Alloc_max_size::_Fn(0, _Al));
; 492  : 		}
; 493  : 
; 494  : 	static _Alloc select_on_container_copy_construction(
; 495  : 		const _Alloc& _Al)
; 496  : 		{	// get allocator to use
; 497  : 		return (_Alloc_select::_Fn(0, _Al));
; 498  : 		}
; 499  : 	};
; 500  :  #endif /* _HAS_CPP0X */
; 501  : 
; 502  : 		// TEMPLATE CLASS _Allocator_base
; 503  : template<class _Ty>
; 504  : 	struct _Allocator_base
; 505  : 	{	// base class for generic allocators
; 506  : 	typedef _Ty value_type;
; 507  : 	};
; 508  : 
; 509  : 		// TEMPLATE CLASS _Allocator_base<const _Ty>
; 510  : template<class _Ty>
; 511  : 	struct _Allocator_base<const _Ty>
; 512  : 	{	// base class for generic allocators for const _Ty
; 513  : 	typedef _Ty value_type;
; 514  : 	};
; 515  : 
; 516  : 		// TEMPLATE CLASS allocator
; 517  : template<class _Ty>
; 518  : 	class allocator
; 519  : 		: public _Allocator_base<_Ty>
; 520  : 	{	// generic allocator for objects of class _Ty
; 521  : public:
; 522  : 	typedef allocator<_Ty> other;
; 523  : 
; 524  : 	typedef _Allocator_base<_Ty> _Mybase;
; 525  : 	typedef typename _Mybase::value_type value_type;
; 526  : 
; 527  : 	typedef value_type *pointer;
; 528  : 	typedef const value_type *const_pointer;
; 529  : 	typedef void *void_pointer;
; 530  : 	typedef const void *const_void_pointer;
; 531  : 
; 532  : 	typedef value_type& reference;
; 533  : 	typedef const value_type& const_reference;
; 534  : 
; 535  : 	typedef size_t size_type;
; 536  : 	typedef ptrdiff_t difference_type;
; 537  : 
; 538  :  #if _HAS_CPP0X
; 539  : 	typedef false_type propagate_on_container_copy_assignment;
; 540  : 	typedef false_type propagate_on_container_move_assignment;
; 541  : 	typedef false_type propagate_on_container_swap;
; 542  : 
; 543  : 	allocator<_Ty> select_on_container_copy_construction() const
; 544  : 		{	// return this allocator
; 545  : 		return (*this);
; 546  : 		}
; 547  :  #endif /* _HAS_CPP0X */
; 548  : 
; 549  : 	template<class _Other>
; 550  : 		struct rebind
; 551  : 		{	// convert this type to allocator<_Other>
; 552  : 		typedef allocator<_Other> other;
; 553  : 		};
; 554  : 
; 555  : 	pointer address(reference _Val) const _NOEXCEPT
; 556  : 		{	// return address of mutable _Val
; 557  : 		return (_STD addressof(_Val));
; 558  : 		}
; 559  : 
; 560  : 	const_pointer address(const_reference _Val) const _NOEXCEPT
; 561  : 		{	// return address of nonmutable _Val
; 562  : 		return (_STD addressof(_Val));
; 563  : 		}
; 564  : 
; 565  : 	allocator() _THROW0()
; 566  : 		{	// construct default allocator (do nothing)
; 567  : 		}
; 568  : 
; 569  : 	allocator(const allocator<_Ty>&) _THROW0()
; 570  : 		{	// construct by copying (do nothing)
; 571  : 		}
; 572  : 
; 573  : 	template<class _Other>
; 574  : 		allocator(const allocator<_Other>&) _THROW0()
; 575  : 		{	// construct from a related allocator (do nothing)
; 576  : 		}
; 577  : 
; 578  : 	template<class _Other>
; 579  : 		allocator<_Ty>& operator=(const allocator<_Other>&)
; 580  : 		{	// assign from a related allocator (do nothing)
; 581  : 		return (*this);
; 582  : 		}
; 583  : 
; 584  : 	void deallocate(pointer _Ptr, size_type)
; 585  : 		{	// deallocate object at _Ptr, ignore size
; 586  : 		::operator delete(_Ptr);

  00064	48 8b 0e	 mov	 rcx, QWORD PTR [rsi]
  00067	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
  0006c	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector

; 1542 : 			this->_Myfirst = pointer();

  00071	33 c0		 xor	 eax, eax
  00073	48 89 06	 mov	 QWORD PTR [rsi], rax

; 1543 : 			this->_Mylast = pointer();

  00076	48 89 46 08	 mov	 QWORD PTR [rsi+8], rax

; 1544 : 			this->_Myend = pointer();

  0007a	48 89 46 10	 mov	 QWORD PTR [rsi+16], rax
$LN1@Tidy:

; 1545 : 			}
; 1546 : 		}

  0007e	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  00083	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00087	5f		 pop	 rdi
  00088	c3		 ret	 0
?_Tidy@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAXXZ ENDP ; std::vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?_Orphan_range@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEBAXPEAV?$shared_ptr@VChunkBase@@@2@0@Z
_TEXT	SEGMENT
this$dead$ = 8
__formal$dead$ = 16
__formal$dead$ = 24
?_Orphan_range@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEBAXPEAV?$shared_ptr@VChunkBase@@@2@0@Z PROC ; std::vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::_Orphan_range, COMDAT

; 1694 : 		}

  00000	c2 00 00	 ret	 0
?_Orphan_range@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEBAXPEAV?$shared_ptr@VChunkBase@@@2@0@Z ENDP ; std::vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@@std@@QEAA@AEBV?$allocator@V?$shared_ptr@VChunkBase@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
??0?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@@std@@QEAA@AEBV?$allocator@V?$shared_ptr@VChunkBase@@@std@@@1@@Z PROC ; std::_Vector_alloc<0,std::_Vec_base_types<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > > >::_Vector_alloc<0,std::_Vec_base_types<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > > >, COMDAT

; 486  : 		_Myfirst = pointer();

  00000	33 c0		 xor	 eax, eax
  00002	48 89 01	 mov	 QWORD PTR [rcx], rax

; 487  : 		_Mylast = pointer();

  00005	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 488  : 		_Myend = pointer();

  00009	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 594  : 		{	// construct allocator from _Al
; 595  : 		}

  0000d	48 8b c1	 mov	 rax, rcx
  00010	c3		 ret	 0
??0?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@@std@@QEAA@AEBV?$allocator@V?$shared_ptr@VChunkBase@@@std@@@1@@Z ENDP ; std::_Vector_alloc<0,std::_Vec_base_types<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > > >::_Vector_alloc<0,std::_Vec_base_types<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@@std@@QEBA?AU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$dead$ = 8
__$ReturnUdt$ = 16
?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@@std@@QEBA?AU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@XZ PROC ; std::_Vector_alloc<0,std::_Vec_base_types<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > > >::_Getal, COMDAT

; 647  : 		return (_Alty());

  00000	48 8b c2	 mov	 rax, rdx

; 648  : 		}

  00003	c3		 ret	 0
?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@@std@@QEBA?AU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@XZ ENDP ; std::_Vector_alloc<0,std::_Vec_base_types<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
;	COMDAT ??D?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QEBAAEBU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@XZ
_TEXT	SEGMENT
this$ = 8
??D?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QEBAAEBU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@XZ PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::operator*, COMDAT

; 249  : 
; 250  : 	pointer operator->() const
; 251  : 		{	// return pointer to class object
; 252  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 253  : 		}
; 254  : 
; 255  : 	_Myiter& operator++()
; 256  : 		{	// preincrement
; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);
; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);
; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  :  #if _HAS_CPP0X
; 520  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 521  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 522  : 
; 523  :  #else /* _HAS_CPP0X */
; 524  : 	typedef typename _Alloc::template rebind<_Ty>::other _Alty;
; 525  :  #endif /* _HAS_CPP0X */
; 526  : 
; 527  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 528  : 		_Voidptr;
; 529  : 	typedef _Tree_node<typename _Alty::value_type,
; 530  : 		_Voidptr> _Node;
; 531  : 
; 532  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 533  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 534  : 	typedef _Nodeptr& _Nodepref;
; 535  : 
; 536  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 537  : 		_Tree_simple_types<typename _Alty::value_type>,
; 538  : 		_Tree_iter_types<typename _Alty::value_type,
; 539  : 			typename _Alty::size_type,
; 540  : 			typename _Alty::difference_type,
; 541  : 			typename _Alty::pointer,
; 542  : 			typename _Alty::const_pointer,
; 543  : 			typename _Alty::reference,
; 544  : 			typename _Alty::const_reference,
; 545  : 			_Nodeptr> >::type
; 546  : 		_Val_types;
; 547  : 	};
; 548  : 
; 549  : 		// TEMPLATE CLASS _Tree_val
; 550  : template<class _Val_types>
; 551  : 	class _Tree_val
; 552  : 		: public _Container_base
; 553  : 	{	// base class for tree to hold data
; 554  : public:
; 555  : 	typedef _Tree_val<_Val_types> _Myt;
; 556  : 
; 557  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 558  : 	typedef _Nodeptr& _Nodepref;
; 559  : 
; 560  : 	typedef typename _Val_types::value_type value_type;
; 561  : 	typedef typename _Val_types::size_type size_type;
; 562  : 	typedef typename _Val_types::difference_type difference_type;
; 563  : 	typedef typename _Val_types::pointer pointer;
; 564  : 	typedef typename _Val_types::const_pointer const_pointer;
; 565  : 	typedef typename _Val_types::reference reference;
; 566  : 	typedef typename _Val_types::const_reference const_reference;
; 567  : 
; 568  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 569  : 	typedef _Tree_iterator<_Myt> iterator;
; 570  : 
; 571  : 	_Tree_val()
; 572  : 		{	// initialize data
; 573  : 		this->_Myhead = 0;
; 574  : 		this->_Mysize = 0;
; 575  : 		}
; 576  : 
; 577  : 	enum _Redbl
; 578  : 		{	// colors for link to parent
; 579  : 		_Red, _Black};
; 580  : 
; 581  : 	static char& _Color(_Nodeptr _Pnode)
; 582  : 		{	// return reference to color in node
; 583  : 		return ((char&)_Pnode->_Color);
; 584  : 		}
; 585  : 
; 586  : 	static char& _Isnil(_Nodeptr _Pnode)
; 587  : 		{	// return reference to nil flag in node
; 588  : 		return ((char&)_Pnode->_Isnil);
; 589  : 		}
; 590  : 
; 591  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 592  : 		{	// return reference to left pointer in node
; 593  : 		return ((_Nodepref)_Pnode->_Left);
; 594  : 		}
; 595  : 
; 596  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 597  : 		{	// return reference to parent pointer in node
; 598  : 		return ((_Nodepref)_Pnode->_Parent);
; 599  : 		}
; 600  : 
; 601  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 602  : 		{	// return reference to right pointer in node
; 603  : 		return ((_Nodepref)_Pnode->_Right);
; 604  : 		}
; 605  : 
; 606  : 	static reference _Myval(_Nodeptr _Pnode)
; 607  : 		{	// return reference to value in node
; 608  : 		return ((reference)_Pnode->_Myval);

  00000	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00003	48 83 c0 20	 add	 rax, 32			; 00000020H

; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		if (this->_Getcont() == 0
; 234  : 			|| this->_Ptr == 0
; 235  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 236  : 			{	// report error
; 237  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 238  : 			_SCL_SECURE_OUT_OF_RANGE;
; 239  : 			}
; 240  : 
; 241  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 242  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 243  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 244  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 245  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 246  : 
; 247  : 		return (_Mytree::_Myval(this->_Ptr));
; 248  : 		}

  00007	c3		 ret	 0
??D?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QEBAAEBU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@XZ ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
;	COMDAT ??8?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
??8?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::operator==, COMDAT

; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);

  00000	48 8b 12	 mov	 rdx, QWORD PTR [rdx]
  00003	48 39 11	 cmp	 QWORD PTR [rcx], rdx
  00006	0f 94 c0	 sete	 al

; 337  : 		}

  00009	c3		 ret	 0
??8?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::operator==
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
;	COMDAT ??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ
_TEXT	SEGMENT
this$ = 8
??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >,std::_Iterator_base0>::operator++, COMDAT

; 75   : 
; 76   : 	_Myiter operator++(int)
; 77   : 		{	// postincrement
; 78   : 		_Myiter _Tmp = *this;
; 79   : 		++*this;
; 80   : 		return (_Tmp);
; 81   : 		}
; 82   : 
; 83   : 	_Myiter& operator--()
; 84   : 		{	// predecrement
; 85   : 		if (_Mytree::_Isnil(_Ptr))
; 86   : 			_Ptr = _Mytree::_Right(_Ptr);	// end() ==> rightmost
; 87   : 		else if (!_Mytree::_Isnil(_Mytree::_Left(_Ptr)))
; 88   : 			_Ptr = _Mytree::_Max(
; 89   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree
; 90   : 		else
; 91   : 			{	// climb looking for left subtree
; 92   : 			_Nodeptr _Pnode;
; 93   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 94   : 				&& _Ptr == _Mytree::_Left(_Pnode))
; 95   : 				_Ptr = _Pnode;	// ==> parent while left subtree
; 96   : 			if (_Mytree::_Isnil(_Ptr))
; 97   : 				;	// begin() shouldn't be decremented, don't move
; 98   : 			else
; 99   : 				_Ptr = _Pnode;	// ==> parent if not head
; 100  : 			}
; 101  : 		return (*this);
; 102  : 		}
; 103  : 
; 104  : 	_Myiter operator--(int)
; 105  : 		{	// postdecrement
; 106  : 		_Myiter _Tmp = *this;
; 107  : 		--*this;
; 108  : 		return (_Tmp);
; 109  : 		}
; 110  : 
; 111  : 	bool operator==(const _Myiter& _Right) const
; 112  : 		{	// test for iterator equality
; 113  : 		return (_Ptr == _Right._Ptr);
; 114  : 		}
; 115  : 
; 116  : 	bool operator!=(const _Myiter& _Right) const
; 117  : 		{	// test for iterator inequality
; 118  : 		return (!(*this == _Right));
; 119  : 		}
; 120  : 
; 121  : 	_Nodeptr _Mynode() const
; 122  : 		{	// return node pointer
; 123  : 		return (_Ptr);
; 124  : 		}
; 125  : 
; 126  : 	_Nodeptr _Ptr;	// pointer to node
; 127  : 	};
; 128  : 
; 129  : 	// TEMPLATE CLASS _Tree_unchecked_iterator
; 130  : template<class _Mytree>
; 131  : 	class _Tree_unchecked_iterator
; 132  : 		: public _Tree_unchecked_const_iterator<_Mytree>
; 133  : 	{	// unchecked iterator for mutable tree
; 134  : public:
; 135  : 	typedef _Tree_unchecked_iterator<_Mytree> _Myiter;
; 136  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Mybase;
; 137  : 	typedef bidirectional_iterator_tag iterator_category;
; 138  : 
; 139  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 140  : 	typedef typename _Mytree::value_type value_type;
; 141  : 	typedef typename _Mytree::difference_type difference_type;
; 142  : 	typedef typename _Mytree::pointer pointer;
; 143  : 	typedef typename _Mytree::reference reference;
; 144  : 
; 145  : 	_Tree_unchecked_iterator()
; 146  : 		{	// construct with null node
; 147  : 		}
; 148  : 
; 149  : 	_Tree_unchecked_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 150  : 		: _Mybase(_Pnode, _Plist)
; 151  : 		{	// construct with node pointer _Pnode
; 152  : 		}
; 153  : 
; 154  : 	reference operator*() const
; 155  : 		{	// return designated value
; 156  : 		return ((reference)**(_Mybase *)this);
; 157  : 		}
; 158  : 
; 159  : 	pointer operator->() const
; 160  : 		{	// return pointer to class object
; 161  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 162  : 		}
; 163  : 
; 164  : 	_Myiter& operator++()
; 165  : 		{	// preincrement
; 166  : 		++(*(_Mybase *)this);
; 167  : 		return (*this);
; 168  : 		}
; 169  : 
; 170  : 	_Myiter operator++(int)
; 171  : 		{	// postincrement
; 172  : 		_Myiter _Tmp = *this;
; 173  : 		++*this;
; 174  : 		return (_Tmp);
; 175  : 		}
; 176  : 
; 177  : 	_Myiter& operator--()
; 178  : 		{	// predecrement
; 179  : 		--(*(_Mybase *)this);
; 180  : 		return (*this);
; 181  : 		}
; 182  : 
; 183  : 	_Myiter operator--(int)
; 184  : 		{	// postdecrement
; 185  : 		_Myiter _Tmp = *this;
; 186  : 		--*this;
; 187  : 		return (_Tmp);
; 188  : 		}
; 189  : 	};
; 190  : 
; 191  : 	// TEMPLATE CLASS _Tree_const_iterator
; 192  : template<class _Mytree>
; 193  : 	class _Tree_const_iterator
; 194  : 		: public _Tree_unchecked_const_iterator<_Mytree, _Iterator_base>
; 195  : 	{	// iterator for nonmutable tree
; 196  : public:
; 197  : 	typedef _Tree_const_iterator<_Mytree> _Myiter;
; 198  : 	typedef _Tree_unchecked_const_iterator<_Mytree, _Iterator_base> _Mybase;
; 199  : 	typedef bidirectional_iterator_tag iterator_category;
; 200  : 
; 201  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 202  : 	typedef typename _Mytree::value_type value_type;
; 203  : 	typedef typename _Mytree::difference_type difference_type;
; 204  : 	typedef typename _Mytree::const_pointer pointer;
; 205  : 	typedef typename _Mytree::const_reference reference;
; 206  : 
; 207  : 	_Tree_const_iterator()
; 208  : 		: _Mybase()
; 209  : 		{	// construct with null node pointer
; 210  : 		}
; 211  : 
; 212  : 	_Tree_const_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 213  : 		: _Mybase(_Pnode, _Plist)
; 214  : 		{	// construct with node pointer _Pnode
; 215  : 		}
; 216  : 
; 217  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Unchecked_type;
; 218  : 
; 219  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 220  : 		{	// reset from unchecked iterator
; 221  : 		this->_Ptr = _Right._Ptr;
; 222  : 		return (*this);
; 223  : 		}
; 224  : 
; 225  : 	_Unchecked_type _Unchecked() const
; 226  : 		{	// make an unchecked iterator
; 227  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 228  : 		}
; 229  : 
; 230  : 	reference operator*() const
; 231  : 		{	// return designated value
; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		if (this->_Getcont() == 0
; 234  : 			|| this->_Ptr == 0
; 235  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 236  : 			{	// report error
; 237  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 238  : 			_SCL_SECURE_OUT_OF_RANGE;
; 239  : 			}
; 240  : 
; 241  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 242  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 243  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 244  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 245  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 246  : 
; 247  : 		return (_Mytree::_Myval(this->_Ptr));
; 248  : 		}
; 249  : 
; 250  : 	pointer operator->() const
; 251  : 		{	// return pointer to class object
; 252  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 253  : 		}
; 254  : 
; 255  : 	_Myiter& operator++()
; 256  : 		{	// preincrement
; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);
; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);
; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  :  #if _HAS_CPP0X
; 520  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 521  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 522  : 
; 523  :  #else /* _HAS_CPP0X */
; 524  : 	typedef typename _Alloc::template rebind<_Ty>::other _Alty;
; 525  :  #endif /* _HAS_CPP0X */
; 526  : 
; 527  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 528  : 		_Voidptr;
; 529  : 	typedef _Tree_node<typename _Alty::value_type,
; 530  : 		_Voidptr> _Node;
; 531  : 
; 532  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 533  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 534  : 	typedef _Nodeptr& _Nodepref;
; 535  : 
; 536  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 537  : 		_Tree_simple_types<typename _Alty::value_type>,
; 538  : 		_Tree_iter_types<typename _Alty::value_type,
; 539  : 			typename _Alty::size_type,
; 540  : 			typename _Alty::difference_type,
; 541  : 			typename _Alty::pointer,
; 542  : 			typename _Alty::const_pointer,
; 543  : 			typename _Alty::reference,
; 544  : 			typename _Alty::const_reference,
; 545  : 			_Nodeptr> >::type
; 546  : 		_Val_types;
; 547  : 	};
; 548  : 
; 549  : 		// TEMPLATE CLASS _Tree_val
; 550  : template<class _Val_types>
; 551  : 	class _Tree_val
; 552  : 		: public _Container_base
; 553  : 	{	// base class for tree to hold data
; 554  : public:
; 555  : 	typedef _Tree_val<_Val_types> _Myt;
; 556  : 
; 557  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 558  : 	typedef _Nodeptr& _Nodepref;
; 559  : 
; 560  : 	typedef typename _Val_types::value_type value_type;
; 561  : 	typedef typename _Val_types::size_type size_type;
; 562  : 	typedef typename _Val_types::difference_type difference_type;
; 563  : 	typedef typename _Val_types::pointer pointer;
; 564  : 	typedef typename _Val_types::const_pointer const_pointer;
; 565  : 	typedef typename _Val_types::reference reference;
; 566  : 	typedef typename _Val_types::const_reference const_reference;
; 567  : 
; 568  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 569  : 	typedef _Tree_iterator<_Myt> iterator;
; 570  : 
; 571  : 	_Tree_val()
; 572  : 		{	// initialize data
; 573  : 		this->_Myhead = 0;
; 574  : 		this->_Mysize = 0;
; 575  : 		}
; 576  : 
; 577  : 	enum _Redbl
; 578  : 		{	// colors for link to parent
; 579  : 		_Red, _Black};
; 580  : 
; 581  : 	static char& _Color(_Nodeptr _Pnode)
; 582  : 		{	// return reference to color in node
; 583  : 		return ((char&)_Pnode->_Color);
; 584  : 		}
; 585  : 
; 586  : 	static char& _Isnil(_Nodeptr _Pnode)
; 587  : 		{	// return reference to nil flag in node
; 588  : 		return ((char&)_Pnode->_Isnil);

  00000	48 8b 01	 mov	 rax, QWORD PTR [rcx]

; 59   : 		{	// preincrement

  00003	48 8b d1	 mov	 rdx, rcx

; 60   : 		if (_Mytree::_Isnil(_Ptr))

  00006	80 78 19 00	 cmp	 BYTE PTR [rax+25], 0
  0000a	75 4d		 jne	 SHORT $LN39@operator

; 75   : 
; 76   : 	_Myiter operator++(int)
; 77   : 		{	// postincrement
; 78   : 		_Myiter _Tmp = *this;
; 79   : 		++*this;
; 80   : 		return (_Tmp);
; 81   : 		}
; 82   : 
; 83   : 	_Myiter& operator--()
; 84   : 		{	// predecrement
; 85   : 		if (_Mytree::_Isnil(_Ptr))
; 86   : 			_Ptr = _Mytree::_Right(_Ptr);	// end() ==> rightmost
; 87   : 		else if (!_Mytree::_Isnil(_Mytree::_Left(_Ptr)))
; 88   : 			_Ptr = _Mytree::_Max(
; 89   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree
; 90   : 		else
; 91   : 			{	// climb looking for left subtree
; 92   : 			_Nodeptr _Pnode;
; 93   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 94   : 				&& _Ptr == _Mytree::_Left(_Pnode))
; 95   : 				_Ptr = _Pnode;	// ==> parent while left subtree
; 96   : 			if (_Mytree::_Isnil(_Ptr))
; 97   : 				;	// begin() shouldn't be decremented, don't move
; 98   : 			else
; 99   : 				_Ptr = _Pnode;	// ==> parent if not head
; 100  : 			}
; 101  : 		return (*this);
; 102  : 		}
; 103  : 
; 104  : 	_Myiter operator--(int)
; 105  : 		{	// postdecrement
; 106  : 		_Myiter _Tmp = *this;
; 107  : 		--*this;
; 108  : 		return (_Tmp);
; 109  : 		}
; 110  : 
; 111  : 	bool operator==(const _Myiter& _Right) const
; 112  : 		{	// test for iterator equality
; 113  : 		return (_Ptr == _Right._Ptr);
; 114  : 		}
; 115  : 
; 116  : 	bool operator!=(const _Myiter& _Right) const
; 117  : 		{	// test for iterator inequality
; 118  : 		return (!(*this == _Right));
; 119  : 		}
; 120  : 
; 121  : 	_Nodeptr _Mynode() const
; 122  : 		{	// return node pointer
; 123  : 		return (_Ptr);
; 124  : 		}
; 125  : 
; 126  : 	_Nodeptr _Ptr;	// pointer to node
; 127  : 	};
; 128  : 
; 129  : 	// TEMPLATE CLASS _Tree_unchecked_iterator
; 130  : template<class _Mytree>
; 131  : 	class _Tree_unchecked_iterator
; 132  : 		: public _Tree_unchecked_const_iterator<_Mytree>
; 133  : 	{	// unchecked iterator for mutable tree
; 134  : public:
; 135  : 	typedef _Tree_unchecked_iterator<_Mytree> _Myiter;
; 136  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Mybase;
; 137  : 	typedef bidirectional_iterator_tag iterator_category;
; 138  : 
; 139  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 140  : 	typedef typename _Mytree::value_type value_type;
; 141  : 	typedef typename _Mytree::difference_type difference_type;
; 142  : 	typedef typename _Mytree::pointer pointer;
; 143  : 	typedef typename _Mytree::reference reference;
; 144  : 
; 145  : 	_Tree_unchecked_iterator()
; 146  : 		{	// construct with null node
; 147  : 		}
; 148  : 
; 149  : 	_Tree_unchecked_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 150  : 		: _Mybase(_Pnode, _Plist)
; 151  : 		{	// construct with node pointer _Pnode
; 152  : 		}
; 153  : 
; 154  : 	reference operator*() const
; 155  : 		{	// return designated value
; 156  : 		return ((reference)**(_Mybase *)this);
; 157  : 		}
; 158  : 
; 159  : 	pointer operator->() const
; 160  : 		{	// return pointer to class object
; 161  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 162  : 		}
; 163  : 
; 164  : 	_Myiter& operator++()
; 165  : 		{	// preincrement
; 166  : 		++(*(_Mybase *)this);
; 167  : 		return (*this);
; 168  : 		}
; 169  : 
; 170  : 	_Myiter operator++(int)
; 171  : 		{	// postincrement
; 172  : 		_Myiter _Tmp = *this;
; 173  : 		++*this;
; 174  : 		return (_Tmp);
; 175  : 		}
; 176  : 
; 177  : 	_Myiter& operator--()
; 178  : 		{	// predecrement
; 179  : 		--(*(_Mybase *)this);
; 180  : 		return (*this);
; 181  : 		}
; 182  : 
; 183  : 	_Myiter operator--(int)
; 184  : 		{	// postdecrement
; 185  : 		_Myiter _Tmp = *this;
; 186  : 		--*this;
; 187  : 		return (_Tmp);
; 188  : 		}
; 189  : 	};
; 190  : 
; 191  : 	// TEMPLATE CLASS _Tree_const_iterator
; 192  : template<class _Mytree>
; 193  : 	class _Tree_const_iterator
; 194  : 		: public _Tree_unchecked_const_iterator<_Mytree, _Iterator_base>
; 195  : 	{	// iterator for nonmutable tree
; 196  : public:
; 197  : 	typedef _Tree_const_iterator<_Mytree> _Myiter;
; 198  : 	typedef _Tree_unchecked_const_iterator<_Mytree, _Iterator_base> _Mybase;
; 199  : 	typedef bidirectional_iterator_tag iterator_category;
; 200  : 
; 201  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 202  : 	typedef typename _Mytree::value_type value_type;
; 203  : 	typedef typename _Mytree::difference_type difference_type;
; 204  : 	typedef typename _Mytree::const_pointer pointer;
; 205  : 	typedef typename _Mytree::const_reference reference;
; 206  : 
; 207  : 	_Tree_const_iterator()
; 208  : 		: _Mybase()
; 209  : 		{	// construct with null node pointer
; 210  : 		}
; 211  : 
; 212  : 	_Tree_const_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 213  : 		: _Mybase(_Pnode, _Plist)
; 214  : 		{	// construct with node pointer _Pnode
; 215  : 		}
; 216  : 
; 217  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Unchecked_type;
; 218  : 
; 219  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 220  : 		{	// reset from unchecked iterator
; 221  : 		this->_Ptr = _Right._Ptr;
; 222  : 		return (*this);
; 223  : 		}
; 224  : 
; 225  : 	_Unchecked_type _Unchecked() const
; 226  : 		{	// make an unchecked iterator
; 227  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 228  : 		}
; 229  : 
; 230  : 	reference operator*() const
; 231  : 		{	// return designated value
; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		if (this->_Getcont() == 0
; 234  : 			|| this->_Ptr == 0
; 235  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 236  : 			{	// report error
; 237  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 238  : 			_SCL_SECURE_OUT_OF_RANGE;
; 239  : 			}
; 240  : 
; 241  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 242  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 243  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 244  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 245  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 246  : 
; 247  : 		return (_Mytree::_Myval(this->_Ptr));
; 248  : 		}
; 249  : 
; 250  : 	pointer operator->() const
; 251  : 		{	// return pointer to class object
; 252  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 253  : 		}
; 254  : 
; 255  : 	_Myiter& operator++()
; 256  : 		{	// preincrement
; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);
; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);
; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  :  #if _HAS_CPP0X
; 520  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 521  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 522  : 
; 523  :  #else /* _HAS_CPP0X */
; 524  : 	typedef typename _Alloc::template rebind<_Ty>::other _Alty;
; 525  :  #endif /* _HAS_CPP0X */
; 526  : 
; 527  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 528  : 		_Voidptr;
; 529  : 	typedef _Tree_node<typename _Alty::value_type,
; 530  : 		_Voidptr> _Node;
; 531  : 
; 532  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 533  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 534  : 	typedef _Nodeptr& _Nodepref;
; 535  : 
; 536  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 537  : 		_Tree_simple_types<typename _Alty::value_type>,
; 538  : 		_Tree_iter_types<typename _Alty::value_type,
; 539  : 			typename _Alty::size_type,
; 540  : 			typename _Alty::difference_type,
; 541  : 			typename _Alty::pointer,
; 542  : 			typename _Alty::const_pointer,
; 543  : 			typename _Alty::reference,
; 544  : 			typename _Alty::const_reference,
; 545  : 			_Nodeptr> >::type
; 546  : 		_Val_types;
; 547  : 	};
; 548  : 
; 549  : 		// TEMPLATE CLASS _Tree_val
; 550  : template<class _Val_types>
; 551  : 	class _Tree_val
; 552  : 		: public _Container_base
; 553  : 	{	// base class for tree to hold data
; 554  : public:
; 555  : 	typedef _Tree_val<_Val_types> _Myt;
; 556  : 
; 557  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 558  : 	typedef _Nodeptr& _Nodepref;
; 559  : 
; 560  : 	typedef typename _Val_types::value_type value_type;
; 561  : 	typedef typename _Val_types::size_type size_type;
; 562  : 	typedef typename _Val_types::difference_type difference_type;
; 563  : 	typedef typename _Val_types::pointer pointer;
; 564  : 	typedef typename _Val_types::const_pointer const_pointer;
; 565  : 	typedef typename _Val_types::reference reference;
; 566  : 	typedef typename _Val_types::const_reference const_reference;
; 567  : 
; 568  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 569  : 	typedef _Tree_iterator<_Myt> iterator;
; 570  : 
; 571  : 	_Tree_val()
; 572  : 		{	// initialize data
; 573  : 		this->_Myhead = 0;
; 574  : 		this->_Mysize = 0;
; 575  : 		}
; 576  : 
; 577  : 	enum _Redbl
; 578  : 		{	// colors for link to parent
; 579  : 		_Red, _Black};
; 580  : 
; 581  : 	static char& _Color(_Nodeptr _Pnode)
; 582  : 		{	// return reference to color in node
; 583  : 		return ((char&)_Pnode->_Color);
; 584  : 		}
; 585  : 
; 586  : 	static char& _Isnil(_Nodeptr _Pnode)
; 587  : 		{	// return reference to nil flag in node
; 588  : 		return ((char&)_Pnode->_Isnil);

  0000c	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]

; 61   : 			;	// end() shouldn't be incremented, don't move
; 62   : 		else if (!_Mytree::_Isnil(_Mytree::_Right(_Ptr)))

  00010	80 79 19 00	 cmp	 BYTE PTR [rcx+25], 0
  00014	75 1d		 jne	 SHORT $LN34@operator

; 75   : 
; 76   : 	_Myiter operator++(int)
; 77   : 		{	// postincrement
; 78   : 		_Myiter _Tmp = *this;
; 79   : 		++*this;
; 80   : 		return (_Tmp);
; 81   : 		}
; 82   : 
; 83   : 	_Myiter& operator--()
; 84   : 		{	// predecrement
; 85   : 		if (_Mytree::_Isnil(_Ptr))
; 86   : 			_Ptr = _Mytree::_Right(_Ptr);	// end() ==> rightmost
; 87   : 		else if (!_Mytree::_Isnil(_Mytree::_Left(_Ptr)))
; 88   : 			_Ptr = _Mytree::_Max(
; 89   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree
; 90   : 		else
; 91   : 			{	// climb looking for left subtree
; 92   : 			_Nodeptr _Pnode;
; 93   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 94   : 				&& _Ptr == _Mytree::_Left(_Pnode))
; 95   : 				_Ptr = _Pnode;	// ==> parent while left subtree
; 96   : 			if (_Mytree::_Isnil(_Ptr))
; 97   : 				;	// begin() shouldn't be decremented, don't move
; 98   : 			else
; 99   : 				_Ptr = _Pnode;	// ==> parent if not head
; 100  : 			}
; 101  : 		return (*this);
; 102  : 		}
; 103  : 
; 104  : 	_Myiter operator--(int)
; 105  : 		{	// postdecrement
; 106  : 		_Myiter _Tmp = *this;
; 107  : 		--*this;
; 108  : 		return (_Tmp);
; 109  : 		}
; 110  : 
; 111  : 	bool operator==(const _Myiter& _Right) const
; 112  : 		{	// test for iterator equality
; 113  : 		return (_Ptr == _Right._Ptr);
; 114  : 		}
; 115  : 
; 116  : 	bool operator!=(const _Myiter& _Right) const
; 117  : 		{	// test for iterator inequality
; 118  : 		return (!(*this == _Right));
; 119  : 		}
; 120  : 
; 121  : 	_Nodeptr _Mynode() const
; 122  : 		{	// return node pointer
; 123  : 		return (_Ptr);
; 124  : 		}
; 125  : 
; 126  : 	_Nodeptr _Ptr;	// pointer to node
; 127  : 	};
; 128  : 
; 129  : 	// TEMPLATE CLASS _Tree_unchecked_iterator
; 130  : template<class _Mytree>
; 131  : 	class _Tree_unchecked_iterator
; 132  : 		: public _Tree_unchecked_const_iterator<_Mytree>
; 133  : 	{	// unchecked iterator for mutable tree
; 134  : public:
; 135  : 	typedef _Tree_unchecked_iterator<_Mytree> _Myiter;
; 136  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Mybase;
; 137  : 	typedef bidirectional_iterator_tag iterator_category;
; 138  : 
; 139  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 140  : 	typedef typename _Mytree::value_type value_type;
; 141  : 	typedef typename _Mytree::difference_type difference_type;
; 142  : 	typedef typename _Mytree::pointer pointer;
; 143  : 	typedef typename _Mytree::reference reference;
; 144  : 
; 145  : 	_Tree_unchecked_iterator()
; 146  : 		{	// construct with null node
; 147  : 		}
; 148  : 
; 149  : 	_Tree_unchecked_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 150  : 		: _Mybase(_Pnode, _Plist)
; 151  : 		{	// construct with node pointer _Pnode
; 152  : 		}
; 153  : 
; 154  : 	reference operator*() const
; 155  : 		{	// return designated value
; 156  : 		return ((reference)**(_Mybase *)this);
; 157  : 		}
; 158  : 
; 159  : 	pointer operator->() const
; 160  : 		{	// return pointer to class object
; 161  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 162  : 		}
; 163  : 
; 164  : 	_Myiter& operator++()
; 165  : 		{	// preincrement
; 166  : 		++(*(_Mybase *)this);
; 167  : 		return (*this);
; 168  : 		}
; 169  : 
; 170  : 	_Myiter operator++(int)
; 171  : 		{	// postincrement
; 172  : 		_Myiter _Tmp = *this;
; 173  : 		++*this;
; 174  : 		return (_Tmp);
; 175  : 		}
; 176  : 
; 177  : 	_Myiter& operator--()
; 178  : 		{	// predecrement
; 179  : 		--(*(_Mybase *)this);
; 180  : 		return (*this);
; 181  : 		}
; 182  : 
; 183  : 	_Myiter operator--(int)
; 184  : 		{	// postdecrement
; 185  : 		_Myiter _Tmp = *this;
; 186  : 		--*this;
; 187  : 		return (_Tmp);
; 188  : 		}
; 189  : 	};
; 190  : 
; 191  : 	// TEMPLATE CLASS _Tree_const_iterator
; 192  : template<class _Mytree>
; 193  : 	class _Tree_const_iterator
; 194  : 		: public _Tree_unchecked_const_iterator<_Mytree, _Iterator_base>
; 195  : 	{	// iterator for nonmutable tree
; 196  : public:
; 197  : 	typedef _Tree_const_iterator<_Mytree> _Myiter;
; 198  : 	typedef _Tree_unchecked_const_iterator<_Mytree, _Iterator_base> _Mybase;
; 199  : 	typedef bidirectional_iterator_tag iterator_category;
; 200  : 
; 201  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 202  : 	typedef typename _Mytree::value_type value_type;
; 203  : 	typedef typename _Mytree::difference_type difference_type;
; 204  : 	typedef typename _Mytree::const_pointer pointer;
; 205  : 	typedef typename _Mytree::const_reference reference;
; 206  : 
; 207  : 	_Tree_const_iterator()
; 208  : 		: _Mybase()
; 209  : 		{	// construct with null node pointer
; 210  : 		}
; 211  : 
; 212  : 	_Tree_const_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 213  : 		: _Mybase(_Pnode, _Plist)
; 214  : 		{	// construct with node pointer _Pnode
; 215  : 		}
; 216  : 
; 217  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Unchecked_type;
; 218  : 
; 219  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 220  : 		{	// reset from unchecked iterator
; 221  : 		this->_Ptr = _Right._Ptr;
; 222  : 		return (*this);
; 223  : 		}
; 224  : 
; 225  : 	_Unchecked_type _Unchecked() const
; 226  : 		{	// make an unchecked iterator
; 227  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 228  : 		}
; 229  : 
; 230  : 	reference operator*() const
; 231  : 		{	// return designated value
; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		if (this->_Getcont() == 0
; 234  : 			|| this->_Ptr == 0
; 235  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 236  : 			{	// report error
; 237  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 238  : 			_SCL_SECURE_OUT_OF_RANGE;
; 239  : 			}
; 240  : 
; 241  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 242  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 243  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 244  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 245  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 246  : 
; 247  : 		return (_Mytree::_Myval(this->_Ptr));
; 248  : 		}
; 249  : 
; 250  : 	pointer operator->() const
; 251  : 		{	// return pointer to class object
; 252  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 253  : 		}
; 254  : 
; 255  : 	_Myiter& operator++()
; 256  : 		{	// preincrement
; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);
; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);
; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  :  #if _HAS_CPP0X
; 520  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 521  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 522  : 
; 523  :  #else /* _HAS_CPP0X */
; 524  : 	typedef typename _Alloc::template rebind<_Ty>::other _Alty;
; 525  :  #endif /* _HAS_CPP0X */
; 526  : 
; 527  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 528  : 		_Voidptr;
; 529  : 	typedef _Tree_node<typename _Alty::value_type,
; 530  : 		_Voidptr> _Node;
; 531  : 
; 532  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 533  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 534  : 	typedef _Nodeptr& _Nodepref;
; 535  : 
; 536  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 537  : 		_Tree_simple_types<typename _Alty::value_type>,
; 538  : 		_Tree_iter_types<typename _Alty::value_type,
; 539  : 			typename _Alty::size_type,
; 540  : 			typename _Alty::difference_type,
; 541  : 			typename _Alty::pointer,
; 542  : 			typename _Alty::const_pointer,
; 543  : 			typename _Alty::reference,
; 544  : 			typename _Alty::const_reference,
; 545  : 			_Nodeptr> >::type
; 546  : 		_Val_types;
; 547  : 	};
; 548  : 
; 549  : 		// TEMPLATE CLASS _Tree_val
; 550  : template<class _Val_types>
; 551  : 	class _Tree_val
; 552  : 		: public _Container_base
; 553  : 	{	// base class for tree to hold data
; 554  : public:
; 555  : 	typedef _Tree_val<_Val_types> _Myt;
; 556  : 
; 557  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 558  : 	typedef _Nodeptr& _Nodepref;
; 559  : 
; 560  : 	typedef typename _Val_types::value_type value_type;
; 561  : 	typedef typename _Val_types::size_type size_type;
; 562  : 	typedef typename _Val_types::difference_type difference_type;
; 563  : 	typedef typename _Val_types::pointer pointer;
; 564  : 	typedef typename _Val_types::const_pointer const_pointer;
; 565  : 	typedef typename _Val_types::reference reference;
; 566  : 	typedef typename _Val_types::const_reference const_reference;
; 567  : 
; 568  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 569  : 	typedef _Tree_iterator<_Myt> iterator;
; 570  : 
; 571  : 	_Tree_val()
; 572  : 		{	// initialize data
; 573  : 		this->_Myhead = 0;
; 574  : 		this->_Mysize = 0;
; 575  : 		}
; 576  : 
; 577  : 	enum _Redbl
; 578  : 		{	// colors for link to parent
; 579  : 		_Red, _Black};
; 580  : 
; 581  : 	static char& _Color(_Nodeptr _Pnode)
; 582  : 		{	// return reference to color in node
; 583  : 		return ((char&)_Pnode->_Color);
; 584  : 		}
; 585  : 
; 586  : 	static char& _Isnil(_Nodeptr _Pnode)
; 587  : 		{	// return reference to nil flag in node
; 588  : 		return ((char&)_Pnode->_Isnil);

  00016	48 8b 01	 mov	 rax, QWORD PTR [rcx]

; 589  : 		}
; 590  : 
; 591  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 592  : 		{	// return reference to left pointer in node
; 593  : 		return ((_Nodepref)_Pnode->_Left);
; 594  : 		}
; 595  : 
; 596  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 597  : 		{	// return reference to parent pointer in node
; 598  : 		return ((_Nodepref)_Pnode->_Parent);
; 599  : 		}
; 600  : 
; 601  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 602  : 		{	// return reference to right pointer in node
; 603  : 		return ((_Nodepref)_Pnode->_Right);
; 604  : 		}
; 605  : 
; 606  : 	static reference _Myval(_Nodeptr _Pnode)
; 607  : 		{	// return reference to value in node
; 608  : 		return ((reference)_Pnode->_Myval);
; 609  : 		}
; 610  : 
; 611  : 	static _Nodeptr _Max(_Nodeptr _Pnode)
; 612  : 		{	// return rightmost node in subtree at _Pnode
; 613  : 		while (!_Isnil(_Right(_Pnode)))
; 614  : 			_Pnode = _Right(_Pnode);
; 615  : 		return (_Pnode);
; 616  : 		}
; 617  : 
; 618  : 	static _Nodeptr _Min(_Nodeptr _Pnode)
; 619  : 		{	// return leftmost node in subtree at _Pnode
; 620  : 		while (!_Isnil(_Left(_Pnode)))

  00019	80 78 19 00	 cmp	 BYTE PTR [rax+25], 0
  0001d	75 0d		 jne	 SHORT $LN17@operator
  0001f	90		 npad	 1
$LL18@operator:

; 621  : 			_Pnode = _Left(_Pnode);

  00020	48 8b c8	 mov	 rcx, rax

; 75   : 
; 76   : 	_Myiter operator++(int)
; 77   : 		{	// postincrement
; 78   : 		_Myiter _Tmp = *this;
; 79   : 		++*this;
; 80   : 		return (_Tmp);
; 81   : 		}
; 82   : 
; 83   : 	_Myiter& operator--()
; 84   : 		{	// predecrement
; 85   : 		if (_Mytree::_Isnil(_Ptr))
; 86   : 			_Ptr = _Mytree::_Right(_Ptr);	// end() ==> rightmost
; 87   : 		else if (!_Mytree::_Isnil(_Mytree::_Left(_Ptr)))
; 88   : 			_Ptr = _Mytree::_Max(
; 89   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree
; 90   : 		else
; 91   : 			{	// climb looking for left subtree
; 92   : 			_Nodeptr _Pnode;
; 93   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 94   : 				&& _Ptr == _Mytree::_Left(_Pnode))
; 95   : 				_Ptr = _Pnode;	// ==> parent while left subtree
; 96   : 			if (_Mytree::_Isnil(_Ptr))
; 97   : 				;	// begin() shouldn't be decremented, don't move
; 98   : 			else
; 99   : 				_Ptr = _Pnode;	// ==> parent if not head
; 100  : 			}
; 101  : 		return (*this);
; 102  : 		}
; 103  : 
; 104  : 	_Myiter operator--(int)
; 105  : 		{	// postdecrement
; 106  : 		_Myiter _Tmp = *this;
; 107  : 		--*this;
; 108  : 		return (_Tmp);
; 109  : 		}
; 110  : 
; 111  : 	bool operator==(const _Myiter& _Right) const
; 112  : 		{	// test for iterator equality
; 113  : 		return (_Ptr == _Right._Ptr);
; 114  : 		}
; 115  : 
; 116  : 	bool operator!=(const _Myiter& _Right) const
; 117  : 		{	// test for iterator inequality
; 118  : 		return (!(*this == _Right));
; 119  : 		}
; 120  : 
; 121  : 	_Nodeptr _Mynode() const
; 122  : 		{	// return node pointer
; 123  : 		return (_Ptr);
; 124  : 		}
; 125  : 
; 126  : 	_Nodeptr _Ptr;	// pointer to node
; 127  : 	};
; 128  : 
; 129  : 	// TEMPLATE CLASS _Tree_unchecked_iterator
; 130  : template<class _Mytree>
; 131  : 	class _Tree_unchecked_iterator
; 132  : 		: public _Tree_unchecked_const_iterator<_Mytree>
; 133  : 	{	// unchecked iterator for mutable tree
; 134  : public:
; 135  : 	typedef _Tree_unchecked_iterator<_Mytree> _Myiter;
; 136  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Mybase;
; 137  : 	typedef bidirectional_iterator_tag iterator_category;
; 138  : 
; 139  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 140  : 	typedef typename _Mytree::value_type value_type;
; 141  : 	typedef typename _Mytree::difference_type difference_type;
; 142  : 	typedef typename _Mytree::pointer pointer;
; 143  : 	typedef typename _Mytree::reference reference;
; 144  : 
; 145  : 	_Tree_unchecked_iterator()
; 146  : 		{	// construct with null node
; 147  : 		}
; 148  : 
; 149  : 	_Tree_unchecked_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 150  : 		: _Mybase(_Pnode, _Plist)
; 151  : 		{	// construct with node pointer _Pnode
; 152  : 		}
; 153  : 
; 154  : 	reference operator*() const
; 155  : 		{	// return designated value
; 156  : 		return ((reference)**(_Mybase *)this);
; 157  : 		}
; 158  : 
; 159  : 	pointer operator->() const
; 160  : 		{	// return pointer to class object
; 161  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 162  : 		}
; 163  : 
; 164  : 	_Myiter& operator++()
; 165  : 		{	// preincrement
; 166  : 		++(*(_Mybase *)this);
; 167  : 		return (*this);
; 168  : 		}
; 169  : 
; 170  : 	_Myiter operator++(int)
; 171  : 		{	// postincrement
; 172  : 		_Myiter _Tmp = *this;
; 173  : 		++*this;
; 174  : 		return (_Tmp);
; 175  : 		}
; 176  : 
; 177  : 	_Myiter& operator--()
; 178  : 		{	// predecrement
; 179  : 		--(*(_Mybase *)this);
; 180  : 		return (*this);
; 181  : 		}
; 182  : 
; 183  : 	_Myiter operator--(int)
; 184  : 		{	// postdecrement
; 185  : 		_Myiter _Tmp = *this;
; 186  : 		--*this;
; 187  : 		return (_Tmp);
; 188  : 		}
; 189  : 	};
; 190  : 
; 191  : 	// TEMPLATE CLASS _Tree_const_iterator
; 192  : template<class _Mytree>
; 193  : 	class _Tree_const_iterator
; 194  : 		: public _Tree_unchecked_const_iterator<_Mytree, _Iterator_base>
; 195  : 	{	// iterator for nonmutable tree
; 196  : public:
; 197  : 	typedef _Tree_const_iterator<_Mytree> _Myiter;
; 198  : 	typedef _Tree_unchecked_const_iterator<_Mytree, _Iterator_base> _Mybase;
; 199  : 	typedef bidirectional_iterator_tag iterator_category;
; 200  : 
; 201  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 202  : 	typedef typename _Mytree::value_type value_type;
; 203  : 	typedef typename _Mytree::difference_type difference_type;
; 204  : 	typedef typename _Mytree::const_pointer pointer;
; 205  : 	typedef typename _Mytree::const_reference reference;
; 206  : 
; 207  : 	_Tree_const_iterator()
; 208  : 		: _Mybase()
; 209  : 		{	// construct with null node pointer
; 210  : 		}
; 211  : 
; 212  : 	_Tree_const_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 213  : 		: _Mybase(_Pnode, _Plist)
; 214  : 		{	// construct with node pointer _Pnode
; 215  : 		}
; 216  : 
; 217  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Unchecked_type;
; 218  : 
; 219  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 220  : 		{	// reset from unchecked iterator
; 221  : 		this->_Ptr = _Right._Ptr;
; 222  : 		return (*this);
; 223  : 		}
; 224  : 
; 225  : 	_Unchecked_type _Unchecked() const
; 226  : 		{	// make an unchecked iterator
; 227  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 228  : 		}
; 229  : 
; 230  : 	reference operator*() const
; 231  : 		{	// return designated value
; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		if (this->_Getcont() == 0
; 234  : 			|| this->_Ptr == 0
; 235  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 236  : 			{	// report error
; 237  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 238  : 			_SCL_SECURE_OUT_OF_RANGE;
; 239  : 			}
; 240  : 
; 241  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 242  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 243  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 244  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 245  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 246  : 
; 247  : 		return (_Mytree::_Myval(this->_Ptr));
; 248  : 		}
; 249  : 
; 250  : 	pointer operator->() const
; 251  : 		{	// return pointer to class object
; 252  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 253  : 		}
; 254  : 
; 255  : 	_Myiter& operator++()
; 256  : 		{	// preincrement
; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);
; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);
; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  :  #if _HAS_CPP0X
; 520  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 521  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 522  : 
; 523  :  #else /* _HAS_CPP0X */
; 524  : 	typedef typename _Alloc::template rebind<_Ty>::other _Alty;
; 525  :  #endif /* _HAS_CPP0X */
; 526  : 
; 527  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 528  : 		_Voidptr;
; 529  : 	typedef _Tree_node<typename _Alty::value_type,
; 530  : 		_Voidptr> _Node;
; 531  : 
; 532  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 533  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 534  : 	typedef _Nodeptr& _Nodepref;
; 535  : 
; 536  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 537  : 		_Tree_simple_types<typename _Alty::value_type>,
; 538  : 		_Tree_iter_types<typename _Alty::value_type,
; 539  : 			typename _Alty::size_type,
; 540  : 			typename _Alty::difference_type,
; 541  : 			typename _Alty::pointer,
; 542  : 			typename _Alty::const_pointer,
; 543  : 			typename _Alty::reference,
; 544  : 			typename _Alty::const_reference,
; 545  : 			_Nodeptr> >::type
; 546  : 		_Val_types;
; 547  : 	};
; 548  : 
; 549  : 		// TEMPLATE CLASS _Tree_val
; 550  : template<class _Val_types>
; 551  : 	class _Tree_val
; 552  : 		: public _Container_base
; 553  : 	{	// base class for tree to hold data
; 554  : public:
; 555  : 	typedef _Tree_val<_Val_types> _Myt;
; 556  : 
; 557  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 558  : 	typedef _Nodeptr& _Nodepref;
; 559  : 
; 560  : 	typedef typename _Val_types::value_type value_type;
; 561  : 	typedef typename _Val_types::size_type size_type;
; 562  : 	typedef typename _Val_types::difference_type difference_type;
; 563  : 	typedef typename _Val_types::pointer pointer;
; 564  : 	typedef typename _Val_types::const_pointer const_pointer;
; 565  : 	typedef typename _Val_types::reference reference;
; 566  : 	typedef typename _Val_types::const_reference const_reference;
; 567  : 
; 568  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 569  : 	typedef _Tree_iterator<_Myt> iterator;
; 570  : 
; 571  : 	_Tree_val()
; 572  : 		{	// initialize data
; 573  : 		this->_Myhead = 0;
; 574  : 		this->_Mysize = 0;
; 575  : 		}
; 576  : 
; 577  : 	enum _Redbl
; 578  : 		{	// colors for link to parent
; 579  : 		_Red, _Black};
; 580  : 
; 581  : 	static char& _Color(_Nodeptr _Pnode)
; 582  : 		{	// return reference to color in node
; 583  : 		return ((char&)_Pnode->_Color);
; 584  : 		}
; 585  : 
; 586  : 	static char& _Isnil(_Nodeptr _Pnode)
; 587  : 		{	// return reference to nil flag in node
; 588  : 		return ((char&)_Pnode->_Isnil);

  00023	48 8b 00	 mov	 rax, QWORD PTR [rax]

; 589  : 		}
; 590  : 
; 591  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 592  : 		{	// return reference to left pointer in node
; 593  : 		return ((_Nodepref)_Pnode->_Left);
; 594  : 		}
; 595  : 
; 596  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 597  : 		{	// return reference to parent pointer in node
; 598  : 		return ((_Nodepref)_Pnode->_Parent);
; 599  : 		}
; 600  : 
; 601  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 602  : 		{	// return reference to right pointer in node
; 603  : 		return ((_Nodepref)_Pnode->_Right);
; 604  : 		}
; 605  : 
; 606  : 	static reference _Myval(_Nodeptr _Pnode)
; 607  : 		{	// return reference to value in node
; 608  : 		return ((reference)_Pnode->_Myval);
; 609  : 		}
; 610  : 
; 611  : 	static _Nodeptr _Max(_Nodeptr _Pnode)
; 612  : 		{	// return rightmost node in subtree at _Pnode
; 613  : 		while (!_Isnil(_Right(_Pnode)))
; 614  : 			_Pnode = _Right(_Pnode);
; 615  : 		return (_Pnode);
; 616  : 		}
; 617  : 
; 618  : 	static _Nodeptr _Min(_Nodeptr _Pnode)
; 619  : 		{	// return leftmost node in subtree at _Pnode
; 620  : 		while (!_Isnil(_Left(_Pnode)))

  00026	80 78 19 00	 cmp	 BYTE PTR [rax+25], 0
  0002a	74 f4		 je	 SHORT $LL18@operator
$LN17@operator:

; 63   : 			_Ptr = _Mytree::_Min(
; 64   : 				_Mytree::_Right(_Ptr));	// ==> smallest of right subtree

  0002c	48 89 0a	 mov	 QWORD PTR [rdx], rcx

; 72   : 			}
; 73   : 		return (*this);

  0002f	48 8b c2	 mov	 rax, rdx

; 74   : 		}

  00032	c3		 ret	 0
$LN34@operator:

; 65   : 		else
; 66   : 			{	// climb looking for right subtree
; 67   : 			_Nodeptr _Pnode;
; 68   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 69   : 				&& _Ptr == _Mytree::_Right(_Pnode))

  00033	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00037	80 78 19 00	 cmp	 BYTE PTR [rax+25], 0
  0003b	75 19		 jne	 SHORT $LN1@operator
  0003d	0f 1f 00	 npad	 3
$LL2@operator:
  00040	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  00044	48 39 0a	 cmp	 QWORD PTR [rdx], rcx
  00047	75 0d		 jne	 SHORT $LN1@operator

; 70   : 				_Ptr = _Pnode;	// ==> parent while right subtree

  00049	48 89 02	 mov	 QWORD PTR [rdx], rax
  0004c	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00050	80 78 19 00	 cmp	 BYTE PTR [rax+25], 0
  00054	74 ea		 je	 SHORT $LL2@operator
$LN1@operator:

; 71   : 			_Ptr = _Pnode;	// ==> parent (head if end())

  00056	48 89 02	 mov	 QWORD PTR [rdx], rax
$LN39@operator:

; 72   : 			}
; 73   : 		return (*this);

  00059	48 8b c2	 mov	 rax, rdx

; 74   : 		}

  0005c	c3		 ret	 0
??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >,std::_Iterator_base0>::operator++
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
;	COMDAT ??0?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@PEBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 8
_Pnode$ = 16
_Plist$dead$ = 24
??0?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@PEBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@1@@Z PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >, COMDAT

; 44   : 		{	// construct with node pointer _Pnode

  00000	48 89 11	 mov	 QWORD PTR [rcx], rdx

; 385  : 		}

  00003	48 8b c1	 mov	 rax, rcx
  00006	c3		 ret	 0
??0?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@PEBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@1@@Z ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?pointer_to@?$pointer_traits@PEBU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@SAPEBU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@2@AEBU32@@Z
_TEXT	SEGMENT
_Val$ = 8
?pointer_to@?$pointer_traits@PEBU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@SAPEBU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@2@AEBU32@@Z PROC ; std::pointer_traits<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > const * __ptr64>::pointer_to, COMDAT

; 233  : 		return (_STD addressof(_Val));

  00000	48 8b c1	 mov	 rax, rcx

; 234  : 		}

  00003	c3		 ret	 0
?pointer_to@?$pointer_traits@PEBU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@SAPEBU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@2@AEBU32@@Z ENDP ; std::pointer_traits<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > const * __ptr64>::pointer_to
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\wchar.h
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\wchar.h
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@PEB_W_K@Z
_TEXT	SEGMENT
this$ = 48
_Ptr$ = 56
_Count$ = 64
?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@PEB_W_K@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append, COMDAT

; 1038 : 		{	// append [_Ptr, _Ptr + _Count)

$LN129:
  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000a	41 56		 push	 r14
  0000c	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00010	4d 8b f0	 mov	 r14, r8
  00013	48 8b f2	 mov	 rsi, rdx
  00016	48 8b d9	 mov	 rbx, rcx

; 2239 : 			|| this->_Myptr() + this->_Mysize <= _Ptr)

  00019	48 85 d2	 test	 rdx, rdx
  0001c	74 62		 je	 SHORT $LN3@append

; 517  : 			: this->_Bx._Buf);

  0001e	48 8b 51 18	 mov	 rdx, QWORD PTR [rcx+24]
  00022	48 83 fa 08	 cmp	 rdx, 8
  00026	72 05		 jb	 SHORT $LN13@append
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstddef

; 88   : 		reinterpret_cast<const volatile char&>(_Val)))));

  00028	48 8b 01	 mov	 rax, QWORD PTR [rcx]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 517  : 			: this->_Bx._Buf);

  0002b	eb 03		 jmp	 SHORT $LN14@append
$LN13@append:
  0002d	48 8b c1	 mov	 rax, rcx
$LN14@append:

; 2239 : 			|| this->_Myptr() + this->_Mysize <= _Ptr)

  00030	48 3b f0	 cmp	 rsi, rax
  00033	72 4b		 jb	 SHORT $LN3@append

; 517  : 			: this->_Bx._Buf);

  00035	48 83 fa 08	 cmp	 rdx, 8
  00039	72 03		 jb	 SHORT $LN20@append
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstddef

; 88   : 		reinterpret_cast<const volatile char&>(_Val)))));

  0003b	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
$LN20@append:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 2239 : 			|| this->_Myptr() + this->_Mysize <= _Ptr)

  0003e	48 8b 43 10	 mov	 rax, QWORD PTR [rbx+16]
  00042	48 8d 0c 41	 lea	 rcx, QWORD PTR [rcx+rax*2]
  00046	48 3b ce	 cmp	 rcx, rsi
  00049	76 35		 jbe	 SHORT $LN3@append

; 517  : 			: this->_Bx._Buf);

  0004b	48 83 fa 08	 cmp	 rdx, 8
  0004f	72 05		 jb	 SHORT $LN25@append
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstddef

; 88   : 		reinterpret_cast<const volatile char&>(_Val)))));

  00051	48 8b 03	 mov	 rax, QWORD PTR [rbx]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 517  : 			: this->_Bx._Buf);

  00054	eb 03		 jmp	 SHORT $LN26@append
$LN25@append:
  00056	48 8b c3	 mov	 rax, rbx
$LN26@append:

; 1039 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1040 : 		if (_Count != 0)
; 1041 : 			_DEBUG_POINTER(_Ptr);
; 1042 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1043 : 
; 1044 : 		if (_Inside(_Ptr))
; 1045 : 			return (append(*this,
; 1046 : 				_Ptr - this->_Myptr(), _Count));	// substring

  00059	48 2b f0	 sub	 rsi, rax
  0005c	4d 8b c8	 mov	 r9, r8
  0005f	48 8b d3	 mov	 rdx, rbx
  00062	48 d1 fe	 sar	 rsi, 1
  00065	48 8b cb	 mov	 rcx, rbx
  00068	4c 8b c6	 mov	 r8, rsi

; 1057 : 		}

  0006b	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  00070	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  00075	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00079	41 5e		 pop	 r14

; 1039 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1040 : 		if (_Count != 0)
; 1041 : 			_DEBUG_POINTER(_Ptr);
; 1042 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1043 : 
; 1044 : 		if (_Inside(_Ptr))
; 1045 : 			return (append(*this,
; 1046 : 				_Ptr - this->_Myptr(), _Count));	// substring

  0007b	e9 00 00 00 00	 jmp	 ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@AEBV12@_K1@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append
$LN3@append:

; 1047 : 		if (npos - this->_Mysize <= _Count)

  00080	4c 8b 43 10	 mov	 r8, QWORD PTR [rbx+16]
  00084	48 83 c8 ff	 or	 rax, -1
  00088	49 2b c0	 sub	 rax, r8
  0008b	49 3b c6	 cmp	 rax, r14
  0008e	0f 86 b9 00 00
	00		 jbe	 $LN126@append

; 1048 : 			_Xlen();	// result too long
; 1049 : 
; 1050 : 		size_type _Num;
; 1051 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))

  00094	48 89 7c 24 30	 mov	 QWORD PTR [rsp+48], rdi
  00099	4d 85 f6	 test	 r14, r14
  0009c	0f 84 92 00 00
	00		 je	 $LN119@append
  000a2	4b 8d 3c 30	 lea	 rdi, QWORD PTR [r8+r14]

; 2219 : 		}
; 2220 : 
; 2221 : 	bool _Grow(size_type _Newsize,
; 2222 : 		bool _Trim = false)
; 2223 : 		{	// ensure buffer is big enough, trim to size if _Trim is true
; 2224 : 		if (max_size() < _Newsize)

  000a6	48 b8 fe ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775806 ; 7ffffffffffffffeH
  000b0	48 3b f8	 cmp	 rdi, rax
  000b3	0f 87 a1 00 00
	00		 ja	 $LN128@append

; 2225 : 			_Xlen();	// result too long
; 2226 : 		if (this->_Myres < _Newsize)

  000b9	48 8b 4b 18	 mov	 rcx, QWORD PTR [rbx+24]
  000bd	48 3b cf	 cmp	 rcx, rdi
  000c0	73 1c		 jae	 SHORT $LN36@append

; 2227 : 			_Copy(_Newsize, this->_Mysize);	// reallocate to grow

  000c2	48 8b d7	 mov	 rdx, rdi
  000c5	48 8b cb	 mov	 rcx, rbx
  000c8	e8 00 00 00 00	 call	 ?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAX_K0@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Copy

; 2233 : 		return (0 < _Newsize);	// return true only if more work to do

  000cd	48 85 ff	 test	 rdi, rdi

; 1048 : 			_Xlen();	// result too long
; 1049 : 
; 1050 : 		size_type _Num;
; 1051 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))

  000d0	74 62		 je	 SHORT $LN119@append
$LN125@append:

; 517  : 			: this->_Bx._Buf);

  000d2	48 83 7b 18 08	 cmp	 QWORD PTR [rbx+24], 8
  000d7	72 26		 jb	 SHORT $LN101@append
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstddef

; 88   : 		reinterpret_cast<const volatile char&>(_Val)))));

  000d9	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 517  : 			: this->_Bx._Buf);

  000dc	eb 24		 jmp	 SHORT $LN102@append
$LN36@append:

; 2228 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)
; 2229 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 2230 : 				_Newsize < this->_Mysize ? _Newsize : this->_Mysize);
; 2231 : 		else if (_Newsize == 0)

  000de	48 85 ff	 test	 rdi, rdi
  000e1	75 ef		 jne	 SHORT $LN125@append

; 1058 : 
; 1059 : 	_Myt& append(const _Elem *_Ptr)
; 1060 : 		{	// append [_Ptr, <null>)
; 1061 : 		_DEBUG_POINTER(_Ptr);
; 1062 : 		return (append(_Ptr, _Traits::length(_Ptr)));
; 1063 : 		}
; 1064 : 
; 1065 : 	_Myt& append(size_type _Count, _Elem _Ch)
; 1066 : 		{	// append _Count * _Ch
; 1067 : 		if (npos - this->_Mysize <= _Count)
; 1068 : 			_Xlen();	// result too long
; 1069 : 
; 1070 : 		size_type _Num;
; 1071 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1072 : 			{	// make room and append new stuff using assign
; 1073 : 			_Chassign(this->_Mysize, _Count, _Ch);
; 1074 : 			_Eos(_Num);
; 1075 : 			}
; 1076 : 		return (*this);
; 1077 : 		}
; 1078 : 
; 1079 : 	template<class _Iter>
; 1080 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1081 : 			_Myt&>::type
; 1082 : 		append(_Iter _First, _Iter _Last)
; 1083 : 		{	// append [_First, _Last), input iterators
; 1084 : 		return (replace(end(), end(), _First, _Last));
; 1085 : 		}
; 1086 : 
; 1087 : 	_Myt& append(const_pointer _First, const_pointer _Last)
; 1088 : 		{	// append [_First, _Last), const pointers
; 1089 : 		return (replace(end(), end(), _First, _Last));
; 1090 : 		}
; 1091 : 
; 1092 : 	_Myt& append(const_iterator _First, const_iterator _Last)
; 1093 : 		{	// append [_First, _Last), const_iterators
; 1094 : 		return (replace(end(), end(), _First, _Last));
; 1095 : 		}
; 1096 : 
; 1097 : 	_Myt& assign(const _Myt& _Right)
; 1098 : 		{	// assign _Right
; 1099 : 		return (assign(_Right, 0, npos));
; 1100 : 		}
; 1101 : 
; 1102 : 	_Myt& assign(const _Myt& _Right,
; 1103 : 		size_type _Roff, size_type _Count)
; 1104 : 		{	// assign _Right [_Roff, _Roff + _Count)
; 1105 : 		if (_Right.size() < _Roff)
; 1106 : 			_Xran();	// _Roff off end
; 1107 : 		size_type _Num = _Right.size() - _Roff;
; 1108 : 		if (_Count < _Num)
; 1109 : 			_Num = _Count;	// trim _Num to size
; 1110 : 
; 1111 : 		if (this == &_Right)
; 1112 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring
; 1113 : 		else if (_Grow(_Num))
; 1114 : 			{	// make room and assign new stuff
; 1115 : 			_Traits::copy(this->_Myptr(),
; 1116 : 				_Right._Myptr() + _Roff, _Num);
; 1117 : 			_Eos(_Num);
; 1118 : 			}
; 1119 : 		return (*this);
; 1120 : 		}
; 1121 : 
; 1122 : 	_Myt& assign(const _Elem *_Ptr, size_type _Count)
; 1123 : 		{	// assign [_Ptr, _Ptr + _Count)
; 1124 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1125 : 		if (_Count != 0)
; 1126 : 			_DEBUG_POINTER(_Ptr);
; 1127 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1128 : 
; 1129 : 		if (_Inside(_Ptr))
; 1130 : 			return (assign(*this,
; 1131 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1132 : 
; 1133 : 		if (_Grow(_Count))
; 1134 : 			{	// make room and assign new stuff
; 1135 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);
; 1136 : 			_Eos(_Count);
; 1137 : 			}
; 1138 : 		return (*this);
; 1139 : 		}
; 1140 : 
; 1141 : 	_Myt& assign(const _Elem *_Ptr)
; 1142 : 		{	// assign [_Ptr, <null>)
; 1143 : 		_DEBUG_POINTER(_Ptr);
; 1144 : 		return (assign(_Ptr, _Traits::length(_Ptr)));
; 1145 : 		}
; 1146 : 
; 1147 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1148 : 		{	// assign _Count * _Ch
; 1149 : 		if (_Count == npos)
; 1150 : 			_Xlen();	// result too long
; 1151 : 
; 1152 : 		if (_Grow(_Count))
; 1153 : 			{	// make room and assign new stuff
; 1154 : 			_Chassign(0, _Count, _Ch);
; 1155 : 			_Eos(_Count);
; 1156 : 			}
; 1157 : 		return (*this);
; 1158 : 		}
; 1159 : 
; 1160 : 	template<class _Iter>
; 1161 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1162 : 			_Myt&>::type
; 1163 : 		assign(_Iter _First, _Iter _Last)
; 1164 : 		{	// assign [First, _Last), input iterators
; 1165 : 		return (replace(begin(), end(), _First, _Last));
; 1166 : 		}
; 1167 : 
; 1168 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1169 : 		{	// assign [First, _Last), const pointers
; 1170 : 		return (replace(begin(), end(), _First, _Last));
; 1171 : 		}
; 1172 : 
; 1173 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1174 : 		{	// assign [First, _Last), const_iterators
; 1175 : 		return (replace(begin(), end(), _First, _Last));
; 1176 : 		}
; 1177 : 
; 1178 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1179 : 		{	// insert _Right at _Off
; 1180 : 		return (insert(_Off, _Right, 0, npos));
; 1181 : 		}
; 1182 : 
; 1183 : 	_Myt& insert(size_type _Off,
; 1184 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1185 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1186 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1187 : 			_Xran();	// _Off or _Roff off end
; 1188 : 		size_type _Num = _Right.size() - _Roff;
; 1189 : 		if (_Num < _Count)
; 1190 : 			_Count = _Num;	// trim _Count to size
; 1191 : 		if (npos - this->_Mysize <= _Count)
; 1192 : 			_Xlen();	// result too long
; 1193 : 
; 1194 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1195 : 			{	// make room and insert new stuff
; 1196 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1197 : 				this->_Myptr() + _Off,
; 1198 : 				this->_Mysize - _Off);	// empty out hole
; 1199 : 			if (this == &_Right)
; 1200 : 				_Traits::move(this->_Myptr() + _Off,
; 1201 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1202 : 						_Count);	// substring
; 1203 : 			else
; 1204 : 				_Traits::copy(this->_Myptr() + _Off,
; 1205 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1206 : 			_Eos(_Num);
; 1207 : 			}
; 1208 : 		return (*this);
; 1209 : 		}
; 1210 : 
; 1211 : 	_Myt& insert(size_type _Off,
; 1212 : 		const _Elem *_Ptr, size_type _Count)
; 1213 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1214 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1215 : 		if (_Count != 0)
; 1216 : 			_DEBUG_POINTER(_Ptr);
; 1217 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1218 : 
; 1219 : 		if (_Inside(_Ptr))
; 1220 : 			return (insert(_Off, *this,
; 1221 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1222 : 		if (this->_Mysize < _Off)
; 1223 : 			_Xran();	// _Off off end
; 1224 : 		if (npos - this->_Mysize <= _Count)
; 1225 : 			_Xlen();	// result too long
; 1226 : 		size_type _Num;
; 1227 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1228 : 			{	// make room and insert new stuff
; 1229 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1230 : 				this->_Myptr() + _Off,
; 1231 : 				this->_Mysize - _Off);	// empty out hole
; 1232 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1233 : 			_Eos(_Num);
; 1234 : 			}
; 1235 : 		return (*this);
; 1236 : 		}
; 1237 : 
; 1238 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1239 : 		{	// insert [_Ptr, <null>) at _Off
; 1240 : 		_DEBUG_POINTER(_Ptr);
; 1241 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1242 : 		}
; 1243 : 
; 1244 : 	_Myt& insert(size_type _Off,
; 1245 : 		size_type _Count, _Elem _Ch)
; 1246 : 		{	// insert _Count * _Ch at _Off
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	iterator insert(const_iterator _Where)
; 1264 : 		{	// insert <null> at _Where
; 1265 : 		return (insert(_Where, _Elem()));
; 1266 : 		}
; 1267 : 
; 1268 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1269 : 		{	// insert _Ch at _Where
; 1270 : 		size_type _Off = _Pdif(_Where, begin());
; 1271 : 		insert(_Off, 1, _Ch);
; 1272 : 		return (begin() + _Off);
; 1273 : 		}
; 1274 : 
; 1275 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1276 : 		{	// insert _Count * _Elem at _Where
; 1277 : 		size_type _Off = _Pdif(_Where, begin());
; 1278 : 		insert(_Off, _Count, _Ch);
; 1279 : 		return (begin() + _Off);
; 1280 : 		}
; 1281 : 
; 1282 : 	template<class _Iter>
; 1283 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1284 : 			iterator>::type
; 1285 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1286 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1287 : 		size_type _Off = _Pdif(_Where, begin());
; 1288 : 		replace(_Where, _Where, _First, _Last);
; 1289 : 		return (begin() + _Off);
; 1290 : 		}
; 1291 : 
; 1292 : 	iterator insert(const_iterator _Where,
; 1293 : 		const_pointer _First, const_pointer _Last)
; 1294 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		replace(_Where, _Where, _First, _Last);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where,
; 1301 : 		const_iterator _First, const_iterator _Last)
; 1302 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1303 : 		size_type _Off = _Pdif(_Where, begin());
; 1304 : 		replace(_Where, _Where, _First, _Last);
; 1305 : 		return (begin() + _Off);
; 1306 : 		}
; 1307 : 
; 1308 : 	_Myt& erase(size_type _Off = 0)
; 1309 : 		{	// erase elements [_Off, ...)
; 1310 : 		if (this->_Mysize < _Off)
; 1311 : 			_Xran();	// _Off off end
; 1312 : 		_Eos(_Off);
; 1313 : 		return (*this);
; 1314 : 		}
; 1315 : 
; 1316 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1317 : 		{	// erase elements [_Off, _Off + _Count)
; 1318 : 		if (this->_Mysize < _Off)
; 1319 : 			_Xran();	// _Off off end
; 1320 : 		if (this->_Mysize - _Off <= _Count)
; 1321 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1322 : 		else if (0 < _Count)
; 1323 : 			{	// move elements down
; 1324 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1325 : 			size_type _Newsize = this->_Mysize - _Count;
; 1326 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1327 : 			_Eos(_Newsize);
; 1328 : 			}
; 1329 : 		return (*this);
; 1330 : 		}
; 1331 : 
; 1332 : 	iterator erase(const_iterator _Where)
; 1333 : 		{	// erase element at _Where
; 1334 : 		size_type _Count = _Pdif(_Where, begin());
; 1335 : 		erase(_Count, 1);
; 1336 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1337 : 		}
; 1338 : 
; 1339 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1340 : 		{	// erase substring [_First, _Last)
; 1341 : 		_DEBUG_RANGE(_First, _Last);
; 1342 : 		size_type _Count = _Pdif(_First, begin());
; 1343 : 		erase(_Count, _Pdif(_Last, _First));
; 1344 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1345 : 		}
; 1346 : 
; 1347 : 	void clear() _NOEXCEPT
; 1348 : 		{	// erase all
; 1349 : 		_Eos(0);
; 1350 : 		}
; 1351 : 
; 1352 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1353 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1354 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1355 : 		}
; 1356 : 
; 1357 : 	_Myt& replace(size_type _Off,
; 1358 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1359 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1360 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1361 : 			_Xran();	// _Off or _Roff off end
; 1362 : 		if (this->_Mysize - _Off < _N0)
; 1363 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1364 : 		size_type _Num = _Right.size() - _Roff;
; 1365 : 		if (_Num < _Count)
; 1366 : 			_Count = _Num;	// trim _Count to size
; 1367 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1368 : 			_Xlen();	// result too long
; 1369 : 
; 1370 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1371 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1372 : 		if (this->_Mysize < _Newsize)
; 1373 : 			_Grow(_Newsize);
; 1374 : 
; 1375 : 		if (this != &_Right)
; 1376 : 			{	// no overlap, just move down and copy in new stuff
; 1377 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1378 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1379 : 			_Traits::copy(this->_Myptr() + _Off,
; 1380 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1381 : 			}
; 1382 : 		else if (_Count <= _N0)
; 1383 : 			{	// hole doesn't get larger, just copy in substring
; 1384 : 			_Traits::move(this->_Myptr() + _Off,
; 1385 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1386 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1387 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1388 : 			}
; 1389 : 		else if (_Roff <= _Off)
; 1390 : 			{	// hole gets larger, substring begins before hole
; 1391 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1392 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1393 : 			_Traits::move(this->_Myptr() + _Off,
; 1394 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1395 : 			}
; 1396 : 		else if (_Off + _N0 <= _Roff)
; 1397 : 			{	// hole gets larger, substring begins after hole
; 1398 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1399 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1400 : 			_Traits::move(this->_Myptr() + _Off,
; 1401 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1402 : 				_Count);	// fill hole
; 1403 : 			}
; 1404 : 		else
; 1405 : 			{	// hole gets larger, substring begins in hole
; 1406 : 			_Traits::move(this->_Myptr() + _Off,
; 1407 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1408 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1409 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1410 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1411 : 				this->_Myptr() + _Roff + _Count,
; 1412 : 				_Count - _N0);	// fill rest of new hole
; 1413 : 			}
; 1414 : 
; 1415 : 		_Eos(_Newsize);
; 1416 : 		return (*this);
; 1417 : 		}
; 1418 : 
; 1419 : 	_Myt& replace(size_type _Off,
; 1420 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1421 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1422 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1423 : 		if (_Count != 0)
; 1424 : 			_DEBUG_POINTER(_Ptr);
; 1425 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1426 : 
; 1427 : 		if (_Inside(_Ptr))
; 1428 : 			return (replace(_Off, _N0, *this,
; 1429 : 				_Ptr - this->_Myptr(),
; 1430 : 				_Count));	// substring, replace carefully
; 1431 : 		if (this->_Mysize < _Off)
; 1432 : 			_Xran();	// _Off off end
; 1433 : 		if (this->_Mysize - _Off < _N0)
; 1434 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1435 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1436 : 			_Xlen();	// result too long
; 1437 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1438 : 
; 1439 : 		if (_Count < _N0)
; 1440 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1441 : 				this->_Myptr() + _Off + _N0,
; 1442 : 				_Nm);	// smaller hole, move tail up
; 1443 : 		size_type _Num;
; 1444 : 		if ((0 < _Count || 0 < _N0)
; 1445 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1446 : 			{	// make room and rearrange
; 1447 : 			if (_N0 < _Count)
; 1448 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1449 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1450 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1451 : 			_Eos(_Num);
; 1452 : 			}
; 1453 : 		return (*this);
; 1454 : 		}
; 1455 : 
; 1456 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1457 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1458 : 		_DEBUG_POINTER(_Ptr);
; 1459 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1460 : 		}
; 1461 : 
; 1462 : 	_Myt& replace(size_type _Off,
; 1463 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1464 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1465 : 		if (this->_Mysize < _Off)
; 1466 : 			_Xran();	// _Off off end
; 1467 : 		if (this->_Mysize - _Off < _N0)
; 1468 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1469 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1470 : 			_Xlen();	// result too long
; 1471 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1472 : 
; 1473 : 		if (_Count < _N0)
; 1474 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1475 : 				this->_Myptr() + _Off + _N0,
; 1476 : 				_Nm);	// smaller hole, move tail up
; 1477 : 		size_type _Num;
; 1478 : 		if ((0 < _Count || 0 < _N0)
; 1479 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1480 : 			{	// make room and rearrange
; 1481 : 			if (_N0 < _Count)
; 1482 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1483 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1484 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1485 : 			_Eos(_Num);
; 1486 : 			}
; 1487 : 		return (*this);
; 1488 : 		}
; 1489 : 
; 1490 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1491 : 		const _Myt& _Right)
; 1492 : 		{	// replace [_First, _Last) with _Right
; 1493 : 		return (replace(
; 1494 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1495 : 		}
; 1496 : 
; 1497 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1498 : 		const _Elem *_Ptr, size_type _Count)
; 1499 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1500 : 		return (replace(
; 1501 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1502 : 		}
; 1503 : 
; 1504 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1505 : 		const _Elem *_Ptr)
; 1506 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1507 : 		return (replace(
; 1508 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1509 : 		}
; 1510 : 
; 1511 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1512 : 		size_type _Count, _Elem _Ch)
; 1513 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1514 : 		return (replace(
; 1515 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1516 : 		}
; 1517 : 
; 1518 : 	template<class _Iter>
; 1519 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1520 : 			_Myt&>::type
; 1521 : 		replace(const_iterator _First, const_iterator _Last,
; 1522 : 			_Iter _First2, _Iter _Last2)
; 1523 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1524 : 		_Myt _Right(_First2, _Last2);
; 1525 : 		replace(_First, _Last, _Right);
; 1526 : 		return (*this);
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const_pointer _First2, const_pointer _Last2)
; 1531 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1532 : 		if (_First2 == _Last2)
; 1533 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1534 : 		else
; 1535 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1536 : 				&*_First2, _Last2 - _First2);
; 1537 : 		return (*this);
; 1538 : 		}
; 1539 : 
; 1540 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1541 : 		pointer _First2, pointer _Last2)
; 1542 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1543 : 		if (_First2 == _Last2)
; 1544 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1545 : 		else
; 1546 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1547 : 				&*_First2, _Last2 - _First2);
; 1548 : 		return (*this);
; 1549 : 		}
; 1550 : 
; 1551 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1552 : 		const_iterator _First2, const_iterator _Last2)
; 1553 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1554 : 		if (_First2 == _Last2)
; 1555 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1556 : 		else
; 1557 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1558 : 				&*_First2, _Last2 - _First2);
; 1559 : 		return (*this);
; 1560 : 		}
; 1561 : 
; 1562 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1563 : 		iterator _First2, iterator _Last2)
; 1564 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1565 : 		if (_First2 == _Last2)
; 1566 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1567 : 		else
; 1568 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1569 : 				&*_First2, _Last2 - _First2);
; 1570 : 		return (*this);
; 1571 : 		}
; 1572 : 
; 1573 : 	iterator begin() _NOEXCEPT
; 1574 : 		{	// return iterator for beginning of mutable sequence
; 1575 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1576 : 		}
; 1577 : 
; 1578 : 	const_iterator begin() const _NOEXCEPT
; 1579 : 		{	// return iterator for beginning of nonmutable sequence
; 1580 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1581 : 		}
; 1582 : 
; 1583 : 	iterator end() _NOEXCEPT
; 1584 : 		{	// return iterator for end of mutable sequence
; 1585 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1586 : 		}
; 1587 : 
; 1588 : 	const_iterator end() const _NOEXCEPT
; 1589 : 		{	// return iterator for end of nonmutable sequence
; 1590 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1591 : 		}
; 1592 : 
; 1593 : 	reverse_iterator rbegin() _NOEXCEPT
; 1594 : 		{	// return iterator for beginning of reversed mutable sequence
; 1595 : 		return (reverse_iterator(end()));
; 1596 : 		}
; 1597 : 
; 1598 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1600 : 		return (const_reverse_iterator(end()));
; 1601 : 		}
; 1602 : 
; 1603 : 	reverse_iterator rend() _NOEXCEPT
; 1604 : 		{	// return iterator for end of reversed mutable sequence
; 1605 : 		return (reverse_iterator(begin()));
; 1606 : 		}
; 1607 : 
; 1608 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1609 : 		{	// return iterator for end of reversed nonmutable sequence
; 1610 : 		return (const_reverse_iterator(begin()));
; 1611 : 		}
; 1612 : 
; 1613 :  #if _HAS_CPP0X
; 1614 : 	const_iterator cbegin() const _NOEXCEPT
; 1615 : 		{	// return iterator for beginning of nonmutable sequence
; 1616 : 		return (((const _Myt *)this)->begin());
; 1617 : 		}
; 1618 : 
; 1619 : 	const_iterator cend() const _NOEXCEPT
; 1620 : 		{	// return iterator for end of nonmutable sequence
; 1621 : 		return (((const _Myt *)this)->end());
; 1622 : 		}
; 1623 : 
; 1624 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1625 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1626 : 		return (((const _Myt *)this)->rbegin());
; 1627 : 		}
; 1628 : 
; 1629 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1630 : 		{	// return iterator for end of reversed nonmutable sequence
; 1631 : 		return (((const _Myt *)this)->rend());
; 1632 : 		}
; 1633 : 
; 1634 : 	void shrink_to_fit()
; 1635 : 		{	// reduce capacity
; 1636 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1637 : 			{	// worth shrinking, do it
; 1638 : 			_Myt _Tmp(*this);
; 1639 : 			swap(_Tmp);
; 1640 : 			}
; 1641 : 		}
; 1642 :  #endif /* _HAS_CPP0X */
; 1643 : 
; 1644 : 	reference at(size_type _Off)
; 1645 : 		{	// subscript mutable sequence with checking
; 1646 : 		if (this->_Mysize <= _Off)
; 1647 : 			_Xran();	// _Off off end
; 1648 : 		return (this->_Myptr()[_Off]);
; 1649 : 		}
; 1650 : 
; 1651 : 	const_reference at(size_type _Off) const
; 1652 : 		{	// subscript nonmutable sequence with checking
; 1653 : 		if (this->_Mysize <= _Off)
; 1654 : 			_Xran();	// _Off off end
; 1655 : 		return (this->_Myptr()[_Off]);
; 1656 : 		}
; 1657 : 
; 1658 : 	reference operator[](size_type _Off)
; 1659 : 		{	// subscript mutable sequence
; 1660 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1661 : 		if (this->_Mysize < _Off)	// sic
; 1662 : 			_DEBUG_ERROR("string subscript out of range");
; 1663 : 
; 1664 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1665 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1666 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1667 : 
; 1668 : 		return (this->_Myptr()[_Off]);
; 1669 : 		}
; 1670 : 
; 1671 : 	const_reference operator[](size_type _Off) const
; 1672 : 		{	// subscript nonmutable sequence
; 1673 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1674 : 		if (this->_Mysize < _Off)	// sic
; 1675 : 			_DEBUG_ERROR("string subscript out of range");
; 1676 : 
; 1677 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1678 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1679 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1680 : 
; 1681 : 		return (this->_Myptr()[_Off]);
; 1682 : 		}
; 1683 : 
; 1684 : 	void push_back(_Elem _Ch)
; 1685 : 		{	// insert element at end
; 1686 : 		insert(end(), _Ch);
; 1687 : 		}
; 1688 : 
; 1689 :  #if _HAS_CPP0X
; 1690 : 	void pop_back()
; 1691 : 		{	// erase element at end
; 1692 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1693 : 		}
; 1694 : 
; 1695 : 	reference front()
; 1696 : 		{	// return first element of mutable sequence
; 1697 : 		return (*begin());
; 1698 : 		}
; 1699 : 
; 1700 : 	const_reference front() const
; 1701 : 		{	// return first element of nonmutable sequence
; 1702 : 		return (*begin());
; 1703 : 		}
; 1704 : 
; 1705 : 	reference back()
; 1706 : 		{	// return last element of mutable sequence
; 1707 : 		return (*(end() - 1));
; 1708 : 		}
; 1709 : 
; 1710 : 	const_reference back() const
; 1711 : 		{	// return last element of nonmutable sequence
; 1712 : 		return (*(end() - 1));
; 1713 : 		}
; 1714 :  #endif /* _HAS_CPP0X */
; 1715 : 
; 1716 : 	const _Elem *c_str() const _NOEXCEPT
; 1717 : 		{	// return pointer to null-terminated nonmutable array
; 1718 : 		return (this->_Myptr());
; 1719 : 		}
; 1720 : 
; 1721 : 	const _Elem *data() const _NOEXCEPT
; 1722 : 		{	// return pointer to nonmutable array
; 1723 : 		return (c_str());
; 1724 : 		}
; 1725 : 
; 1726 : 	size_type length() const _NOEXCEPT
; 1727 : 		{	// return length of sequence
; 1728 : 		return (this->_Mysize);
; 1729 : 		}
; 1730 : 
; 1731 : 	size_type size() const _NOEXCEPT
; 1732 : 		{	// return length of sequence
; 1733 : 		return (this->_Mysize);
; 1734 : 		}
; 1735 : 
; 1736 : 	size_type max_size() const _NOEXCEPT
; 1737 : 		{	// return maximum possible length of sequence
; 1738 : 		size_type _Num = this->_Getal().max_size();
; 1739 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1740 : 		}
; 1741 : 
; 1742 : 	void resize(size_type _Newsize)
; 1743 : 		{	// determine new length, padding with null elements as needed
; 1744 : 		resize(_Newsize, _Elem());
; 1745 : 		}
; 1746 : 
; 1747 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1748 : 		{	// determine new length, padding with _Ch elements as needed
; 1749 : 		if (_Newsize <= this->_Mysize)
; 1750 : 			_Eos(_Newsize);
; 1751 : 		else
; 1752 : 			append(_Newsize - this->_Mysize, _Ch);
; 1753 : 		}
; 1754 : 
; 1755 : 	size_type capacity() const _NOEXCEPT
; 1756 : 		{	// return current length of allocated storage
; 1757 : 		return (this->_Myres);
; 1758 : 		}
; 1759 : 
; 1760 : 	void reserve(size_type _Newcap = 0)
; 1761 : 		{	// determine new minimum length of allocated storage
; 1762 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1763 : 			{	// change reservation
; 1764 : 			size_type _Size = this->_Mysize;
; 1765 : 			if (_Grow(_Newcap, true))
; 1766 : 				_Eos(_Size);
; 1767 : 			}
; 1768 : 		}
; 1769 : 
; 1770 : 	bool empty() const _NOEXCEPT
; 1771 : 		{	// test if sequence is empty
; 1772 : 		return (this->_Mysize == 0);
; 1773 : 		}
; 1774 : 
; 1775 : 	_SCL_INSECURE_DEPRECATE
; 1776 : 
; 1777 : 	size_type copy(_Elem *_Ptr,
; 1778 : 		size_type _Count, size_type _Off = 0) const
; 1779 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1780 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1781 : 		if (_Count != 0)
; 1782 : 			_DEBUG_POINTER(_Ptr);
; 1783 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1784 : 
; 1785 : 		if (this->_Mysize < _Off)
; 1786 : 			_Xran();	// _Off off end
; 1787 : 		if (this->_Mysize - _Off < _Count)
; 1788 : 			_Count = this->_Mysize - _Off;
; 1789 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1790 : 		return (_Count);
; 1791 : 		}
; 1792 : 
; 1793 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1794 : 		size_type _Count, size_type _Off = 0) const
; 1795 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1796 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1797 : 		if (_Count != 0)
; 1798 : 			_DEBUG_POINTER(_Dest);
; 1799 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1800 : 
; 1801 : 		if (this->_Mysize < _Off)
; 1802 : 			_Xran();	// _Off off end
; 1803 : 		if (this->_Mysize - _Off < _Count)
; 1804 : 			_Count = this->_Mysize - _Off;
; 1805 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1806 : 		return (_Count);
; 1807 : 		}
; 1808 : 
; 1809 : 	void _Swap_bx(_Myt& _Right)
; 1810 : 		{	// exchange _Bx with _Right._Bx
; 1811 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1812 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1813 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1814 : 			else
; 1815 : 				{	// swap large with small
; 1816 : 				pointer _Ptr = this->_Bx._Ptr;
; 1817 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1818 : 				_Traits::copy(this->_Bx._Buf,
; 1819 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1820 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1821 : 				}
; 1822 : 		else
; 1823 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1824 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1825 : 			else
; 1826 : 				{	// swap small with large
; 1827 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1828 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1829 : 				_Traits::copy(_Right._Bx._Buf,
; 1830 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1831 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1832 : 				}
; 1833 : 		}
; 1834 : 
; 1835 : 	void swap(_Myt& _Right)
; 1836 : 		{	// exchange contents with _Right
; 1837 : 		if (this == &_Right)
; 1838 : 			;	// same object, do nothing
; 1839 : 		else if (this->_Getal() == _Right._Getal())
; 1840 : 			{	// same allocator, swap control information
; 1841 : 			this->_Swap_all(_Right);
; 1842 : 			_Swap_bx(_Right);
; 1843 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1844 : 			_STD swap(this->_Myres, _Right._Myres);
; 1845 : 			}
; 1846 : 
; 1847 :  #if _HAS_CPP0X
; 1848 : 		else if (_Alty::propagate_on_container_swap::value)
; 1849 : 			{	// swap allocators and control information
; 1850 : 			this->_Swap_alloc(_Right);
; 1851 : 			_Swap_bx(_Right);
; 1852 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1853 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1854 : 			_STD swap(this->_Myres, _Right._Myres);
; 1855 : 			}
; 1856 :  #endif /* _HAS_CPP0X */
; 1857 : 
; 1858 : 		else
; 1859 : 			{	// different allocator, do multiple assigns
; 1860 : 			_Myt _Tmp = *this;
; 1861 : 
; 1862 : 			*this = _Right;
; 1863 : 			_Right = _Tmp;
; 1864 : 			}
; 1865 : 		}
; 1866 : 
; 1867 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1868 : 		{	// look for _Right beginning at or after _Off
; 1869 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1870 : 		}
; 1871 : 
; 1872 : 	size_type find(const _Elem *_Ptr,
; 1873 : 		size_type _Off, size_type _Count) const
; 1874 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1875 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1876 : 		if (_Count != 0)
; 1877 : 			_DEBUG_POINTER(_Ptr);
; 1878 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1879 : 
; 1880 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1881 : 			return (_Off);	// null string always matches (if inside string)
; 1882 : 
; 1883 : 		size_type _Nm;
; 1884 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1885 : 			{	// room for match, look for it
; 1886 : 			const _Elem *_Uptr, *_Vptr;
; 1887 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1888 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1889 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1890 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1891 : 					return (_Uptr - this->_Myptr());	// found a match
; 1892 : 			}
; 1893 : 
; 1894 : 		return (npos);	// no match
; 1895 : 		}
; 1896 : 
; 1897 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1898 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1899 : 		_DEBUG_POINTER(_Ptr);
; 1900 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1901 : 		}
; 1902 : 
; 1903 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1904 : 		{	// look for _Ch at or after _Off
; 1905 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1906 : 		}
; 1907 : 
; 1908 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1909 : 		{	// look for _Right beginning before _Off
; 1910 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1911 : 		}
; 1912 : 
; 1913 : 	size_type rfind(const _Elem *_Ptr,
; 1914 : 		size_type _Off, size_type _Count) const
; 1915 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1916 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1917 : 		if (_Count != 0)
; 1918 : 			_DEBUG_POINTER(_Ptr);
; 1919 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1920 : 
; 1921 : 		if (_Count == 0)
; 1922 : 			return (_Off < this->_Mysize ? _Off
; 1923 : 				: this->_Mysize);	// null always matches
; 1924 : 		if (_Count <= this->_Mysize)
; 1925 : 			{	// room for match, look for it
; 1926 : 			const _Elem *_Uptr = this->_Myptr() +
; 1927 : 				(_Off < this->_Mysize - _Count ? _Off
; 1928 : 					: this->_Mysize - _Count);
; 1929 : 			for (; ; --_Uptr)
; 1930 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1931 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1932 : 					return (_Uptr - this->_Myptr());	// found a match
; 1933 : 				else if (_Uptr == this->_Myptr())
; 1934 : 					break;	// at beginning, no more chance for match
; 1935 : 			}
; 1936 : 
; 1937 : 		return (npos);	// no match
; 1938 : 		}
; 1939 : 
; 1940 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1941 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1942 : 		_DEBUG_POINTER(_Ptr);
; 1943 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1944 : 		}
; 1945 : 
; 1946 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1947 : 		{	// look for _Ch before _Off
; 1948 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1949 : 		}
; 1950 : 
; 1951 : 	size_type find_first_of(const _Myt& _Right,
; 1952 : 		size_type _Off = 0) const _NOEXCEPT
; 1953 : 		{	// look for one of _Right at or after _Off
; 1954 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1955 : 		}
; 1956 : 
; 1957 : 	size_type find_first_of(const _Elem *_Ptr,
; 1958 : 		size_type _Off, size_type _Count) const
; 1959 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1960 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1961 : 		if (_Count != 0)
; 1962 : 			_DEBUG_POINTER(_Ptr);
; 1963 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1964 : 
; 1965 : 		if (0 < _Count && _Off < this->_Mysize)
; 1966 : 			{	// room for match, look for it
; 1967 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1968 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1969 : 				_Uptr < _Vptr; ++_Uptr)
; 1970 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1971 : 					return (_Uptr - this->_Myptr());	// found a match
; 1972 : 			}
; 1973 : 
; 1974 : 		return (npos);	// no match
; 1975 : 		}
; 1976 : 
; 1977 : 	size_type find_first_of(const _Elem *_Ptr,
; 1978 : 		size_type _Off = 0) const
; 1979 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1980 : 		_DEBUG_POINTER(_Ptr);
; 1981 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 1982 : 		}
; 1983 : 
; 1984 : 	size_type find_first_of(_Elem _Ch,
; 1985 : 		size_type _Off = 0) const
; 1986 : 		{	// look for _Ch at or after _Off
; 1987 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1988 : 		}
; 1989 : 
; 1990 : 	size_type find_last_of(const _Myt& _Right,
; 1991 : 		size_type _Off = npos) const _NOEXCEPT
; 1992 : 		{	// look for one of _Right before _Off
; 1993 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_last_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off, size_type _Count) const
; 1998 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 1999 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2000 : 		if (_Count != 0)
; 2001 : 			_DEBUG_POINTER(_Ptr);
; 2002 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2003 : 
; 2004 : 		if (0 < _Count && 0 < this->_Mysize)
; 2005 : 			{	// worth searching, do it
; 2006 : 			const _Elem *_Uptr = this->_Myptr()
; 2007 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2008 : 			for (; ; --_Uptr)
; 2009 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2010 : 					return (_Uptr - this->_Myptr());	// found a match
; 2011 : 				else if (_Uptr == this->_Myptr())
; 2012 : 					break;	// at beginning, no more chance for match
; 2013 : 			}
; 2014 : 
; 2015 : 		return (npos);	// no match
; 2016 : 		}
; 2017 : 
; 2018 : 	size_type find_last_of(const _Elem *_Ptr,
; 2019 : 		size_type _Off = npos) const
; 2020 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2021 : 		_DEBUG_POINTER(_Ptr);
; 2022 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2023 : 		}
; 2024 : 
; 2025 : 	size_type find_last_of(_Elem _Ch,
; 2026 : 		size_type _Off = npos) const
; 2027 : 		{	// look for _Ch before _Off
; 2028 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2029 : 		}
; 2030 : 
; 2031 : 	size_type find_first_not_of(const _Myt& _Right,
; 2032 : 		size_type _Off = 0) const _NOEXCEPT
; 2033 : 		{	// look for none of _Right at or after _Off
; 2034 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2035 : 			_Right.size()));
; 2036 : 		}
; 2037 : 
; 2038 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2039 : 		size_type _Off, size_type _Count) const
; 2040 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2041 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2042 : 		if (_Count != 0)
; 2043 : 			_DEBUG_POINTER(_Ptr);
; 2044 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2045 : 
; 2046 : 		if (_Off < this->_Mysize)
; 2047 : 			{	// room for match, look for it
; 2048 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2049 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2050 : 				_Uptr < _Vptr; ++_Uptr)
; 2051 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2052 : 					return (_Uptr - this->_Myptr());
; 2053 : 			}
; 2054 : 		return (npos);
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off = 0) const
; 2059 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2060 : 		_DEBUG_POINTER(_Ptr);
; 2061 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2062 : 		}
; 2063 : 
; 2064 : 	size_type find_first_not_of(_Elem _Ch,
; 2065 : 		size_type _Off = 0) const
; 2066 : 		{	// look for non _Ch at or after _Off
; 2067 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2068 : 		}
; 2069 : 
; 2070 : 	size_type find_last_not_of(const _Myt& _Right,
; 2071 : 		size_type _Off = npos) const _NOEXCEPT
; 2072 : 		{	// look for none of _Right before _Off
; 2073 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off, size_type _Count) const
; 2078 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2079 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2080 : 		if (_Count != 0)
; 2081 : 			_DEBUG_POINTER(_Ptr);
; 2082 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2083 : 
; 2084 : 		if (0 < this->_Mysize)
; 2085 : 			{	// worth searching, do it
; 2086 : 			const _Elem *_Uptr = this->_Myptr()
; 2087 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2088 : 			for (; ; --_Uptr)
; 2089 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2090 : 					return (_Uptr - this->_Myptr());
; 2091 : 				else if (_Uptr == this->_Myptr())
; 2092 : 					break;
; 2093 : 			}
; 2094 : 		return (npos);
; 2095 : 		}
; 2096 : 
; 2097 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2098 : 		size_type _Off = npos) const
; 2099 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2100 : 		_DEBUG_POINTER(_Ptr);
; 2101 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2102 : 		}
; 2103 : 
; 2104 : 	size_type find_last_not_of(_Elem _Ch,
; 2105 : 		size_type _Off = npos) const
; 2106 : 		{	// look for non _Ch before _Off
; 2107 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2108 : 		}
; 2109 : 
; 2110 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2111 : 		{	// return [_Off, _Off + _Count) as new string
; 2112 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2113 : 		}
; 2114 : 
; 2115 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2116 : 		{	// compare [0, _Mysize) with _Right
; 2117 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2118 : 		}
; 2119 : 
; 2120 : 	int compare(size_type _Off, size_type _N0,
; 2121 : 		const _Myt& _Right) const
; 2122 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2123 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2124 : 		}
; 2125 : 
; 2126 : 	int compare(size_type _Off,
; 2127 : 		size_type _N0, const _Myt& _Right,
; 2128 : 		size_type _Roff, size_type _Count) const
; 2129 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2130 : 		if (_Right.size() < _Roff)
; 2131 : 			_Xran();	// _Off off end
; 2132 : 		if (_Right._Mysize - _Roff < _Count)
; 2133 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2134 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2135 : 		}
; 2136 : 
; 2137 : 	int compare(const _Elem *_Ptr) const
; 2138 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2139 : 		_DEBUG_POINTER(_Ptr);
; 2140 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2141 : 		}
; 2142 : 
; 2143 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2144 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2145 : 		_DEBUG_POINTER(_Ptr);
; 2146 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2147 : 		}
; 2148 : 
; 2149 : 	int compare(size_type _Off,
; 2150 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2151 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2152 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2153 : 		if (_Count != 0)
; 2154 : 			_DEBUG_POINTER(_Ptr);
; 2155 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2156 : 
; 2157 : 		if (this->_Mysize < _Off)
; 2158 : 			_Xran();	// _Off off end
; 2159 : 		if (this->_Mysize - _Off < _N0)
; 2160 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2161 : 
; 2162 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2163 : 			_N0 < _Count ? _N0 : _Count);
; 2164 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2165 : 			: _N0 == _Count ? 0 : +1);
; 2166 : 		}
; 2167 : 
; 2168 : 	allocator_type get_allocator() const _NOEXCEPT
; 2169 : 		{	// return allocator object for values
; 2170 : 		return (this->_Getal());
; 2171 : 		}
; 2172 : 
; 2173 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2174 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2175 : 		if (_Count == 1)
; 2176 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2177 : 		else
; 2178 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2179 : 		}
; 2180 : 
; 2181 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2182 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2183 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2184 : 		if (max_size() < _Newres)
; 2185 : 			_Newres = _Newsize;	// undo roundup if too big
; 2186 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2187 : 			;
; 2188 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2189 : 			_Newres = this->_Myres
; 2190 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2191 : 		else
; 2192 : 			_Newres = max_size();	// settle for max_size()
; 2193 : 
; 2194 : 		_Elem *_Ptr;
; 2195 : 		_TRY_BEGIN
; 2196 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2197 : 		_CATCH_ALL
; 2198 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2199 : 			_TRY_BEGIN
; 2200 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2201 : 			_CATCH_ALL
; 2202 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2203 : 			_RERAISE;
; 2204 : 			_CATCH_END
; 2205 : 		_CATCH_END
; 2206 : 
; 2207 : 		if (0 < _Oldlen)
; 2208 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2209 : 				_Oldlen);	// copy existing elements
; 2210 : 		_Tidy(true);
; 2211 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2212 : 		this->_Myres = _Newres;
; 2213 : 		_Eos(_Oldlen);
; 2214 : 		}
; 2215 : 
; 2216 : 	void _Eos(size_type _Newsize)
; 2217 : 		{	// set new length and null terminator
; 2218 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  000e3	33 c0		 xor	 eax, eax
  000e5	48 89 43 10	 mov	 QWORD PTR [rbx+16], rax

; 517  : 			: this->_Bx._Buf);

  000e9	48 83 f9 08	 cmp	 rcx, 8
  000ed	72 08		 jb	 SHORT $LN93@append
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstddef

; 88   : 		reinterpret_cast<const volatile char&>(_Val)))));

  000ef	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd

; 347  : 		_Left = _Right;

  000f2	66 89 01	 mov	 WORD PTR [rcx], ax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 2233 : 		return (0 < _Newsize);	// return true only if more work to do

  000f5	eb 3d		 jmp	 SHORT $LN119@append
$LN93@append:

; 517  : 			: this->_Bx._Buf);

  000f7	48 8b cb	 mov	 rcx, rbx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd

; 347  : 		_Left = _Right;

  000fa	66 89 03	 mov	 WORD PTR [rbx], ax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 2233 : 		return (0 < _Newsize);	// return true only if more work to do

  000fd	eb 35		 jmp	 SHORT $LN119@append
$LN101@append:

; 517  : 			: this->_Bx._Buf);

  000ff	48 8b cb	 mov	 rcx, rbx
$LN102@append:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd

; 313  : 			: (_Elem *)_CSTD wmemcpy(_First1, _First2, _Count));

  00102	4d 85 f6	 test	 r14, r14
  00105	74 14		 je	 SHORT $LN108@append
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 1053 : 			_Traits::copy(this->_Myptr() + this->_Mysize, _Ptr, _Count);

  00107	48 8b 43 10	 mov	 rax, QWORD PTR [rbx+16]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\wchar.h

; 1257 :             return (wchar_t *)memcpy(_S1, _S2, _N*sizeof(wchar_t));

  0010b	4f 8d 04 36	 lea	 r8, QWORD PTR [r14+r14]
  0010f	48 8b d6	 mov	 rdx, rsi
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 1053 : 			_Traits::copy(this->_Myptr() + this->_Mysize, _Ptr, _Count);

  00112	48 8d 0c 41	 lea	 rcx, QWORD PTR [rcx+rax*2]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\wchar.h

; 1257 :             return (wchar_t *)memcpy(_S1, _S2, _N*sizeof(wchar_t));

  00116	e8 00 00 00 00	 call	 memcpy
$LN108@append:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 517  : 			: this->_Bx._Buf);

  0011b	48 83 7b 18 08	 cmp	 QWORD PTR [rbx+24], 8

; 1058 : 
; 1059 : 	_Myt& append(const _Elem *_Ptr)
; 1060 : 		{	// append [_Ptr, <null>)
; 1061 : 		_DEBUG_POINTER(_Ptr);
; 1062 : 		return (append(_Ptr, _Traits::length(_Ptr)));
; 1063 : 		}
; 1064 : 
; 1065 : 	_Myt& append(size_type _Count, _Elem _Ch)
; 1066 : 		{	// append _Count * _Ch
; 1067 : 		if (npos - this->_Mysize <= _Count)
; 1068 : 			_Xlen();	// result too long
; 1069 : 
; 1070 : 		size_type _Num;
; 1071 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1072 : 			{	// make room and append new stuff using assign
; 1073 : 			_Chassign(this->_Mysize, _Count, _Ch);
; 1074 : 			_Eos(_Num);
; 1075 : 			}
; 1076 : 		return (*this);
; 1077 : 		}
; 1078 : 
; 1079 : 	template<class _Iter>
; 1080 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1081 : 			_Myt&>::type
; 1082 : 		append(_Iter _First, _Iter _Last)
; 1083 : 		{	// append [_First, _Last), input iterators
; 1084 : 		return (replace(end(), end(), _First, _Last));
; 1085 : 		}
; 1086 : 
; 1087 : 	_Myt& append(const_pointer _First, const_pointer _Last)
; 1088 : 		{	// append [_First, _Last), const pointers
; 1089 : 		return (replace(end(), end(), _First, _Last));
; 1090 : 		}
; 1091 : 
; 1092 : 	_Myt& append(const_iterator _First, const_iterator _Last)
; 1093 : 		{	// append [_First, _Last), const_iterators
; 1094 : 		return (replace(end(), end(), _First, _Last));
; 1095 : 		}
; 1096 : 
; 1097 : 	_Myt& assign(const _Myt& _Right)
; 1098 : 		{	// assign _Right
; 1099 : 		return (assign(_Right, 0, npos));
; 1100 : 		}
; 1101 : 
; 1102 : 	_Myt& assign(const _Myt& _Right,
; 1103 : 		size_type _Roff, size_type _Count)
; 1104 : 		{	// assign _Right [_Roff, _Roff + _Count)
; 1105 : 		if (_Right.size() < _Roff)
; 1106 : 			_Xran();	// _Roff off end
; 1107 : 		size_type _Num = _Right.size() - _Roff;
; 1108 : 		if (_Count < _Num)
; 1109 : 			_Num = _Count;	// trim _Num to size
; 1110 : 
; 1111 : 		if (this == &_Right)
; 1112 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring
; 1113 : 		else if (_Grow(_Num))
; 1114 : 			{	// make room and assign new stuff
; 1115 : 			_Traits::copy(this->_Myptr(),
; 1116 : 				_Right._Myptr() + _Roff, _Num);
; 1117 : 			_Eos(_Num);
; 1118 : 			}
; 1119 : 		return (*this);
; 1120 : 		}
; 1121 : 
; 1122 : 	_Myt& assign(const _Elem *_Ptr, size_type _Count)
; 1123 : 		{	// assign [_Ptr, _Ptr + _Count)
; 1124 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1125 : 		if (_Count != 0)
; 1126 : 			_DEBUG_POINTER(_Ptr);
; 1127 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1128 : 
; 1129 : 		if (_Inside(_Ptr))
; 1130 : 			return (assign(*this,
; 1131 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1132 : 
; 1133 : 		if (_Grow(_Count))
; 1134 : 			{	// make room and assign new stuff
; 1135 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);
; 1136 : 			_Eos(_Count);
; 1137 : 			}
; 1138 : 		return (*this);
; 1139 : 		}
; 1140 : 
; 1141 : 	_Myt& assign(const _Elem *_Ptr)
; 1142 : 		{	// assign [_Ptr, <null>)
; 1143 : 		_DEBUG_POINTER(_Ptr);
; 1144 : 		return (assign(_Ptr, _Traits::length(_Ptr)));
; 1145 : 		}
; 1146 : 
; 1147 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1148 : 		{	// assign _Count * _Ch
; 1149 : 		if (_Count == npos)
; 1150 : 			_Xlen();	// result too long
; 1151 : 
; 1152 : 		if (_Grow(_Count))
; 1153 : 			{	// make room and assign new stuff
; 1154 : 			_Chassign(0, _Count, _Ch);
; 1155 : 			_Eos(_Count);
; 1156 : 			}
; 1157 : 		return (*this);
; 1158 : 		}
; 1159 : 
; 1160 : 	template<class _Iter>
; 1161 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1162 : 			_Myt&>::type
; 1163 : 		assign(_Iter _First, _Iter _Last)
; 1164 : 		{	// assign [First, _Last), input iterators
; 1165 : 		return (replace(begin(), end(), _First, _Last));
; 1166 : 		}
; 1167 : 
; 1168 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1169 : 		{	// assign [First, _Last), const pointers
; 1170 : 		return (replace(begin(), end(), _First, _Last));
; 1171 : 		}
; 1172 : 
; 1173 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1174 : 		{	// assign [First, _Last), const_iterators
; 1175 : 		return (replace(begin(), end(), _First, _Last));
; 1176 : 		}
; 1177 : 
; 1178 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1179 : 		{	// insert _Right at _Off
; 1180 : 		return (insert(_Off, _Right, 0, npos));
; 1181 : 		}
; 1182 : 
; 1183 : 	_Myt& insert(size_type _Off,
; 1184 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1185 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1186 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1187 : 			_Xran();	// _Off or _Roff off end
; 1188 : 		size_type _Num = _Right.size() - _Roff;
; 1189 : 		if (_Num < _Count)
; 1190 : 			_Count = _Num;	// trim _Count to size
; 1191 : 		if (npos - this->_Mysize <= _Count)
; 1192 : 			_Xlen();	// result too long
; 1193 : 
; 1194 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1195 : 			{	// make room and insert new stuff
; 1196 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1197 : 				this->_Myptr() + _Off,
; 1198 : 				this->_Mysize - _Off);	// empty out hole
; 1199 : 			if (this == &_Right)
; 1200 : 				_Traits::move(this->_Myptr() + _Off,
; 1201 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1202 : 						_Count);	// substring
; 1203 : 			else
; 1204 : 				_Traits::copy(this->_Myptr() + _Off,
; 1205 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1206 : 			_Eos(_Num);
; 1207 : 			}
; 1208 : 		return (*this);
; 1209 : 		}
; 1210 : 
; 1211 : 	_Myt& insert(size_type _Off,
; 1212 : 		const _Elem *_Ptr, size_type _Count)
; 1213 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1214 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1215 : 		if (_Count != 0)
; 1216 : 			_DEBUG_POINTER(_Ptr);
; 1217 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1218 : 
; 1219 : 		if (_Inside(_Ptr))
; 1220 : 			return (insert(_Off, *this,
; 1221 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1222 : 		if (this->_Mysize < _Off)
; 1223 : 			_Xran();	// _Off off end
; 1224 : 		if (npos - this->_Mysize <= _Count)
; 1225 : 			_Xlen();	// result too long
; 1226 : 		size_type _Num;
; 1227 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1228 : 			{	// make room and insert new stuff
; 1229 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1230 : 				this->_Myptr() + _Off,
; 1231 : 				this->_Mysize - _Off);	// empty out hole
; 1232 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1233 : 			_Eos(_Num);
; 1234 : 			}
; 1235 : 		return (*this);
; 1236 : 		}
; 1237 : 
; 1238 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1239 : 		{	// insert [_Ptr, <null>) at _Off
; 1240 : 		_DEBUG_POINTER(_Ptr);
; 1241 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1242 : 		}
; 1243 : 
; 1244 : 	_Myt& insert(size_type _Off,
; 1245 : 		size_type _Count, _Elem _Ch)
; 1246 : 		{	// insert _Count * _Ch at _Off
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	iterator insert(const_iterator _Where)
; 1264 : 		{	// insert <null> at _Where
; 1265 : 		return (insert(_Where, _Elem()));
; 1266 : 		}
; 1267 : 
; 1268 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1269 : 		{	// insert _Ch at _Where
; 1270 : 		size_type _Off = _Pdif(_Where, begin());
; 1271 : 		insert(_Off, 1, _Ch);
; 1272 : 		return (begin() + _Off);
; 1273 : 		}
; 1274 : 
; 1275 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1276 : 		{	// insert _Count * _Elem at _Where
; 1277 : 		size_type _Off = _Pdif(_Where, begin());
; 1278 : 		insert(_Off, _Count, _Ch);
; 1279 : 		return (begin() + _Off);
; 1280 : 		}
; 1281 : 
; 1282 : 	template<class _Iter>
; 1283 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1284 : 			iterator>::type
; 1285 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1286 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1287 : 		size_type _Off = _Pdif(_Where, begin());
; 1288 : 		replace(_Where, _Where, _First, _Last);
; 1289 : 		return (begin() + _Off);
; 1290 : 		}
; 1291 : 
; 1292 : 	iterator insert(const_iterator _Where,
; 1293 : 		const_pointer _First, const_pointer _Last)
; 1294 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		replace(_Where, _Where, _First, _Last);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where,
; 1301 : 		const_iterator _First, const_iterator _Last)
; 1302 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1303 : 		size_type _Off = _Pdif(_Where, begin());
; 1304 : 		replace(_Where, _Where, _First, _Last);
; 1305 : 		return (begin() + _Off);
; 1306 : 		}
; 1307 : 
; 1308 : 	_Myt& erase(size_type _Off = 0)
; 1309 : 		{	// erase elements [_Off, ...)
; 1310 : 		if (this->_Mysize < _Off)
; 1311 : 			_Xran();	// _Off off end
; 1312 : 		_Eos(_Off);
; 1313 : 		return (*this);
; 1314 : 		}
; 1315 : 
; 1316 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1317 : 		{	// erase elements [_Off, _Off + _Count)
; 1318 : 		if (this->_Mysize < _Off)
; 1319 : 			_Xran();	// _Off off end
; 1320 : 		if (this->_Mysize - _Off <= _Count)
; 1321 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1322 : 		else if (0 < _Count)
; 1323 : 			{	// move elements down
; 1324 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1325 : 			size_type _Newsize = this->_Mysize - _Count;
; 1326 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1327 : 			_Eos(_Newsize);
; 1328 : 			}
; 1329 : 		return (*this);
; 1330 : 		}
; 1331 : 
; 1332 : 	iterator erase(const_iterator _Where)
; 1333 : 		{	// erase element at _Where
; 1334 : 		size_type _Count = _Pdif(_Where, begin());
; 1335 : 		erase(_Count, 1);
; 1336 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1337 : 		}
; 1338 : 
; 1339 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1340 : 		{	// erase substring [_First, _Last)
; 1341 : 		_DEBUG_RANGE(_First, _Last);
; 1342 : 		size_type _Count = _Pdif(_First, begin());
; 1343 : 		erase(_Count, _Pdif(_Last, _First));
; 1344 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1345 : 		}
; 1346 : 
; 1347 : 	void clear() _NOEXCEPT
; 1348 : 		{	// erase all
; 1349 : 		_Eos(0);
; 1350 : 		}
; 1351 : 
; 1352 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1353 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1354 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1355 : 		}
; 1356 : 
; 1357 : 	_Myt& replace(size_type _Off,
; 1358 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1359 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1360 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1361 : 			_Xran();	// _Off or _Roff off end
; 1362 : 		if (this->_Mysize - _Off < _N0)
; 1363 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1364 : 		size_type _Num = _Right.size() - _Roff;
; 1365 : 		if (_Num < _Count)
; 1366 : 			_Count = _Num;	// trim _Count to size
; 1367 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1368 : 			_Xlen();	// result too long
; 1369 : 
; 1370 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1371 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1372 : 		if (this->_Mysize < _Newsize)
; 1373 : 			_Grow(_Newsize);
; 1374 : 
; 1375 : 		if (this != &_Right)
; 1376 : 			{	// no overlap, just move down and copy in new stuff
; 1377 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1378 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1379 : 			_Traits::copy(this->_Myptr() + _Off,
; 1380 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1381 : 			}
; 1382 : 		else if (_Count <= _N0)
; 1383 : 			{	// hole doesn't get larger, just copy in substring
; 1384 : 			_Traits::move(this->_Myptr() + _Off,
; 1385 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1386 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1387 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1388 : 			}
; 1389 : 		else if (_Roff <= _Off)
; 1390 : 			{	// hole gets larger, substring begins before hole
; 1391 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1392 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1393 : 			_Traits::move(this->_Myptr() + _Off,
; 1394 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1395 : 			}
; 1396 : 		else if (_Off + _N0 <= _Roff)
; 1397 : 			{	// hole gets larger, substring begins after hole
; 1398 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1399 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1400 : 			_Traits::move(this->_Myptr() + _Off,
; 1401 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1402 : 				_Count);	// fill hole
; 1403 : 			}
; 1404 : 		else
; 1405 : 			{	// hole gets larger, substring begins in hole
; 1406 : 			_Traits::move(this->_Myptr() + _Off,
; 1407 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1408 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1409 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1410 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1411 : 				this->_Myptr() + _Roff + _Count,
; 1412 : 				_Count - _N0);	// fill rest of new hole
; 1413 : 			}
; 1414 : 
; 1415 : 		_Eos(_Newsize);
; 1416 : 		return (*this);
; 1417 : 		}
; 1418 : 
; 1419 : 	_Myt& replace(size_type _Off,
; 1420 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1421 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1422 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1423 : 		if (_Count != 0)
; 1424 : 			_DEBUG_POINTER(_Ptr);
; 1425 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1426 : 
; 1427 : 		if (_Inside(_Ptr))
; 1428 : 			return (replace(_Off, _N0, *this,
; 1429 : 				_Ptr - this->_Myptr(),
; 1430 : 				_Count));	// substring, replace carefully
; 1431 : 		if (this->_Mysize < _Off)
; 1432 : 			_Xran();	// _Off off end
; 1433 : 		if (this->_Mysize - _Off < _N0)
; 1434 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1435 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1436 : 			_Xlen();	// result too long
; 1437 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1438 : 
; 1439 : 		if (_Count < _N0)
; 1440 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1441 : 				this->_Myptr() + _Off + _N0,
; 1442 : 				_Nm);	// smaller hole, move tail up
; 1443 : 		size_type _Num;
; 1444 : 		if ((0 < _Count || 0 < _N0)
; 1445 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1446 : 			{	// make room and rearrange
; 1447 : 			if (_N0 < _Count)
; 1448 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1449 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1450 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1451 : 			_Eos(_Num);
; 1452 : 			}
; 1453 : 		return (*this);
; 1454 : 		}
; 1455 : 
; 1456 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1457 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1458 : 		_DEBUG_POINTER(_Ptr);
; 1459 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1460 : 		}
; 1461 : 
; 1462 : 	_Myt& replace(size_type _Off,
; 1463 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1464 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1465 : 		if (this->_Mysize < _Off)
; 1466 : 			_Xran();	// _Off off end
; 1467 : 		if (this->_Mysize - _Off < _N0)
; 1468 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1469 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1470 : 			_Xlen();	// result too long
; 1471 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1472 : 
; 1473 : 		if (_Count < _N0)
; 1474 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1475 : 				this->_Myptr() + _Off + _N0,
; 1476 : 				_Nm);	// smaller hole, move tail up
; 1477 : 		size_type _Num;
; 1478 : 		if ((0 < _Count || 0 < _N0)
; 1479 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1480 : 			{	// make room and rearrange
; 1481 : 			if (_N0 < _Count)
; 1482 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1483 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1484 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1485 : 			_Eos(_Num);
; 1486 : 			}
; 1487 : 		return (*this);
; 1488 : 		}
; 1489 : 
; 1490 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1491 : 		const _Myt& _Right)
; 1492 : 		{	// replace [_First, _Last) with _Right
; 1493 : 		return (replace(
; 1494 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1495 : 		}
; 1496 : 
; 1497 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1498 : 		const _Elem *_Ptr, size_type _Count)
; 1499 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1500 : 		return (replace(
; 1501 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1502 : 		}
; 1503 : 
; 1504 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1505 : 		const _Elem *_Ptr)
; 1506 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1507 : 		return (replace(
; 1508 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1509 : 		}
; 1510 : 
; 1511 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1512 : 		size_type _Count, _Elem _Ch)
; 1513 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1514 : 		return (replace(
; 1515 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1516 : 		}
; 1517 : 
; 1518 : 	template<class _Iter>
; 1519 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1520 : 			_Myt&>::type
; 1521 : 		replace(const_iterator _First, const_iterator _Last,
; 1522 : 			_Iter _First2, _Iter _Last2)
; 1523 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1524 : 		_Myt _Right(_First2, _Last2);
; 1525 : 		replace(_First, _Last, _Right);
; 1526 : 		return (*this);
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const_pointer _First2, const_pointer _Last2)
; 1531 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1532 : 		if (_First2 == _Last2)
; 1533 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1534 : 		else
; 1535 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1536 : 				&*_First2, _Last2 - _First2);
; 1537 : 		return (*this);
; 1538 : 		}
; 1539 : 
; 1540 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1541 : 		pointer _First2, pointer _Last2)
; 1542 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1543 : 		if (_First2 == _Last2)
; 1544 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1545 : 		else
; 1546 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1547 : 				&*_First2, _Last2 - _First2);
; 1548 : 		return (*this);
; 1549 : 		}
; 1550 : 
; 1551 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1552 : 		const_iterator _First2, const_iterator _Last2)
; 1553 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1554 : 		if (_First2 == _Last2)
; 1555 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1556 : 		else
; 1557 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1558 : 				&*_First2, _Last2 - _First2);
; 1559 : 		return (*this);
; 1560 : 		}
; 1561 : 
; 1562 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1563 : 		iterator _First2, iterator _Last2)
; 1564 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1565 : 		if (_First2 == _Last2)
; 1566 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1567 : 		else
; 1568 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1569 : 				&*_First2, _Last2 - _First2);
; 1570 : 		return (*this);
; 1571 : 		}
; 1572 : 
; 1573 : 	iterator begin() _NOEXCEPT
; 1574 : 		{	// return iterator for beginning of mutable sequence
; 1575 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1576 : 		}
; 1577 : 
; 1578 : 	const_iterator begin() const _NOEXCEPT
; 1579 : 		{	// return iterator for beginning of nonmutable sequence
; 1580 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1581 : 		}
; 1582 : 
; 1583 : 	iterator end() _NOEXCEPT
; 1584 : 		{	// return iterator for end of mutable sequence
; 1585 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1586 : 		}
; 1587 : 
; 1588 : 	const_iterator end() const _NOEXCEPT
; 1589 : 		{	// return iterator for end of nonmutable sequence
; 1590 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1591 : 		}
; 1592 : 
; 1593 : 	reverse_iterator rbegin() _NOEXCEPT
; 1594 : 		{	// return iterator for beginning of reversed mutable sequence
; 1595 : 		return (reverse_iterator(end()));
; 1596 : 		}
; 1597 : 
; 1598 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1600 : 		return (const_reverse_iterator(end()));
; 1601 : 		}
; 1602 : 
; 1603 : 	reverse_iterator rend() _NOEXCEPT
; 1604 : 		{	// return iterator for end of reversed mutable sequence
; 1605 : 		return (reverse_iterator(begin()));
; 1606 : 		}
; 1607 : 
; 1608 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1609 : 		{	// return iterator for end of reversed nonmutable sequence
; 1610 : 		return (const_reverse_iterator(begin()));
; 1611 : 		}
; 1612 : 
; 1613 :  #if _HAS_CPP0X
; 1614 : 	const_iterator cbegin() const _NOEXCEPT
; 1615 : 		{	// return iterator for beginning of nonmutable sequence
; 1616 : 		return (((const _Myt *)this)->begin());
; 1617 : 		}
; 1618 : 
; 1619 : 	const_iterator cend() const _NOEXCEPT
; 1620 : 		{	// return iterator for end of nonmutable sequence
; 1621 : 		return (((const _Myt *)this)->end());
; 1622 : 		}
; 1623 : 
; 1624 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1625 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1626 : 		return (((const _Myt *)this)->rbegin());
; 1627 : 		}
; 1628 : 
; 1629 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1630 : 		{	// return iterator for end of reversed nonmutable sequence
; 1631 : 		return (((const _Myt *)this)->rend());
; 1632 : 		}
; 1633 : 
; 1634 : 	void shrink_to_fit()
; 1635 : 		{	// reduce capacity
; 1636 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1637 : 			{	// worth shrinking, do it
; 1638 : 			_Myt _Tmp(*this);
; 1639 : 			swap(_Tmp);
; 1640 : 			}
; 1641 : 		}
; 1642 :  #endif /* _HAS_CPP0X */
; 1643 : 
; 1644 : 	reference at(size_type _Off)
; 1645 : 		{	// subscript mutable sequence with checking
; 1646 : 		if (this->_Mysize <= _Off)
; 1647 : 			_Xran();	// _Off off end
; 1648 : 		return (this->_Myptr()[_Off]);
; 1649 : 		}
; 1650 : 
; 1651 : 	const_reference at(size_type _Off) const
; 1652 : 		{	// subscript nonmutable sequence with checking
; 1653 : 		if (this->_Mysize <= _Off)
; 1654 : 			_Xran();	// _Off off end
; 1655 : 		return (this->_Myptr()[_Off]);
; 1656 : 		}
; 1657 : 
; 1658 : 	reference operator[](size_type _Off)
; 1659 : 		{	// subscript mutable sequence
; 1660 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1661 : 		if (this->_Mysize < _Off)	// sic
; 1662 : 			_DEBUG_ERROR("string subscript out of range");
; 1663 : 
; 1664 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1665 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1666 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1667 : 
; 1668 : 		return (this->_Myptr()[_Off]);
; 1669 : 		}
; 1670 : 
; 1671 : 	const_reference operator[](size_type _Off) const
; 1672 : 		{	// subscript nonmutable sequence
; 1673 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1674 : 		if (this->_Mysize < _Off)	// sic
; 1675 : 			_DEBUG_ERROR("string subscript out of range");
; 1676 : 
; 1677 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1678 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1679 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1680 : 
; 1681 : 		return (this->_Myptr()[_Off]);
; 1682 : 		}
; 1683 : 
; 1684 : 	void push_back(_Elem _Ch)
; 1685 : 		{	// insert element at end
; 1686 : 		insert(end(), _Ch);
; 1687 : 		}
; 1688 : 
; 1689 :  #if _HAS_CPP0X
; 1690 : 	void pop_back()
; 1691 : 		{	// erase element at end
; 1692 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1693 : 		}
; 1694 : 
; 1695 : 	reference front()
; 1696 : 		{	// return first element of mutable sequence
; 1697 : 		return (*begin());
; 1698 : 		}
; 1699 : 
; 1700 : 	const_reference front() const
; 1701 : 		{	// return first element of nonmutable sequence
; 1702 : 		return (*begin());
; 1703 : 		}
; 1704 : 
; 1705 : 	reference back()
; 1706 : 		{	// return last element of mutable sequence
; 1707 : 		return (*(end() - 1));
; 1708 : 		}
; 1709 : 
; 1710 : 	const_reference back() const
; 1711 : 		{	// return last element of nonmutable sequence
; 1712 : 		return (*(end() - 1));
; 1713 : 		}
; 1714 :  #endif /* _HAS_CPP0X */
; 1715 : 
; 1716 : 	const _Elem *c_str() const _NOEXCEPT
; 1717 : 		{	// return pointer to null-terminated nonmutable array
; 1718 : 		return (this->_Myptr());
; 1719 : 		}
; 1720 : 
; 1721 : 	const _Elem *data() const _NOEXCEPT
; 1722 : 		{	// return pointer to nonmutable array
; 1723 : 		return (c_str());
; 1724 : 		}
; 1725 : 
; 1726 : 	size_type length() const _NOEXCEPT
; 1727 : 		{	// return length of sequence
; 1728 : 		return (this->_Mysize);
; 1729 : 		}
; 1730 : 
; 1731 : 	size_type size() const _NOEXCEPT
; 1732 : 		{	// return length of sequence
; 1733 : 		return (this->_Mysize);
; 1734 : 		}
; 1735 : 
; 1736 : 	size_type max_size() const _NOEXCEPT
; 1737 : 		{	// return maximum possible length of sequence
; 1738 : 		size_type _Num = this->_Getal().max_size();
; 1739 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1740 : 		}
; 1741 : 
; 1742 : 	void resize(size_type _Newsize)
; 1743 : 		{	// determine new length, padding with null elements as needed
; 1744 : 		resize(_Newsize, _Elem());
; 1745 : 		}
; 1746 : 
; 1747 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1748 : 		{	// determine new length, padding with _Ch elements as needed
; 1749 : 		if (_Newsize <= this->_Mysize)
; 1750 : 			_Eos(_Newsize);
; 1751 : 		else
; 1752 : 			append(_Newsize - this->_Mysize, _Ch);
; 1753 : 		}
; 1754 : 
; 1755 : 	size_type capacity() const _NOEXCEPT
; 1756 : 		{	// return current length of allocated storage
; 1757 : 		return (this->_Myres);
; 1758 : 		}
; 1759 : 
; 1760 : 	void reserve(size_type _Newcap = 0)
; 1761 : 		{	// determine new minimum length of allocated storage
; 1762 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1763 : 			{	// change reservation
; 1764 : 			size_type _Size = this->_Mysize;
; 1765 : 			if (_Grow(_Newcap, true))
; 1766 : 				_Eos(_Size);
; 1767 : 			}
; 1768 : 		}
; 1769 : 
; 1770 : 	bool empty() const _NOEXCEPT
; 1771 : 		{	// test if sequence is empty
; 1772 : 		return (this->_Mysize == 0);
; 1773 : 		}
; 1774 : 
; 1775 : 	_SCL_INSECURE_DEPRECATE
; 1776 : 
; 1777 : 	size_type copy(_Elem *_Ptr,
; 1778 : 		size_type _Count, size_type _Off = 0) const
; 1779 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1780 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1781 : 		if (_Count != 0)
; 1782 : 			_DEBUG_POINTER(_Ptr);
; 1783 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1784 : 
; 1785 : 		if (this->_Mysize < _Off)
; 1786 : 			_Xran();	// _Off off end
; 1787 : 		if (this->_Mysize - _Off < _Count)
; 1788 : 			_Count = this->_Mysize - _Off;
; 1789 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1790 : 		return (_Count);
; 1791 : 		}
; 1792 : 
; 1793 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1794 : 		size_type _Count, size_type _Off = 0) const
; 1795 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1796 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1797 : 		if (_Count != 0)
; 1798 : 			_DEBUG_POINTER(_Dest);
; 1799 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1800 : 
; 1801 : 		if (this->_Mysize < _Off)
; 1802 : 			_Xran();	// _Off off end
; 1803 : 		if (this->_Mysize - _Off < _Count)
; 1804 : 			_Count = this->_Mysize - _Off;
; 1805 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1806 : 		return (_Count);
; 1807 : 		}
; 1808 : 
; 1809 : 	void _Swap_bx(_Myt& _Right)
; 1810 : 		{	// exchange _Bx with _Right._Bx
; 1811 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1812 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1813 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1814 : 			else
; 1815 : 				{	// swap large with small
; 1816 : 				pointer _Ptr = this->_Bx._Ptr;
; 1817 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1818 : 				_Traits::copy(this->_Bx._Buf,
; 1819 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1820 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1821 : 				}
; 1822 : 		else
; 1823 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1824 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1825 : 			else
; 1826 : 				{	// swap small with large
; 1827 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1828 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1829 : 				_Traits::copy(_Right._Bx._Buf,
; 1830 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1831 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1832 : 				}
; 1833 : 		}
; 1834 : 
; 1835 : 	void swap(_Myt& _Right)
; 1836 : 		{	// exchange contents with _Right
; 1837 : 		if (this == &_Right)
; 1838 : 			;	// same object, do nothing
; 1839 : 		else if (this->_Getal() == _Right._Getal())
; 1840 : 			{	// same allocator, swap control information
; 1841 : 			this->_Swap_all(_Right);
; 1842 : 			_Swap_bx(_Right);
; 1843 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1844 : 			_STD swap(this->_Myres, _Right._Myres);
; 1845 : 			}
; 1846 : 
; 1847 :  #if _HAS_CPP0X
; 1848 : 		else if (_Alty::propagate_on_container_swap::value)
; 1849 : 			{	// swap allocators and control information
; 1850 : 			this->_Swap_alloc(_Right);
; 1851 : 			_Swap_bx(_Right);
; 1852 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1853 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1854 : 			_STD swap(this->_Myres, _Right._Myres);
; 1855 : 			}
; 1856 :  #endif /* _HAS_CPP0X */
; 1857 : 
; 1858 : 		else
; 1859 : 			{	// different allocator, do multiple assigns
; 1860 : 			_Myt _Tmp = *this;
; 1861 : 
; 1862 : 			*this = _Right;
; 1863 : 			_Right = _Tmp;
; 1864 : 			}
; 1865 : 		}
; 1866 : 
; 1867 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1868 : 		{	// look for _Right beginning at or after _Off
; 1869 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1870 : 		}
; 1871 : 
; 1872 : 	size_type find(const _Elem *_Ptr,
; 1873 : 		size_type _Off, size_type _Count) const
; 1874 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1875 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1876 : 		if (_Count != 0)
; 1877 : 			_DEBUG_POINTER(_Ptr);
; 1878 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1879 : 
; 1880 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1881 : 			return (_Off);	// null string always matches (if inside string)
; 1882 : 
; 1883 : 		size_type _Nm;
; 1884 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1885 : 			{	// room for match, look for it
; 1886 : 			const _Elem *_Uptr, *_Vptr;
; 1887 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1888 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1889 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1890 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1891 : 					return (_Uptr - this->_Myptr());	// found a match
; 1892 : 			}
; 1893 : 
; 1894 : 		return (npos);	// no match
; 1895 : 		}
; 1896 : 
; 1897 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1898 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1899 : 		_DEBUG_POINTER(_Ptr);
; 1900 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1901 : 		}
; 1902 : 
; 1903 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1904 : 		{	// look for _Ch at or after _Off
; 1905 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1906 : 		}
; 1907 : 
; 1908 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1909 : 		{	// look for _Right beginning before _Off
; 1910 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1911 : 		}
; 1912 : 
; 1913 : 	size_type rfind(const _Elem *_Ptr,
; 1914 : 		size_type _Off, size_type _Count) const
; 1915 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1916 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1917 : 		if (_Count != 0)
; 1918 : 			_DEBUG_POINTER(_Ptr);
; 1919 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1920 : 
; 1921 : 		if (_Count == 0)
; 1922 : 			return (_Off < this->_Mysize ? _Off
; 1923 : 				: this->_Mysize);	// null always matches
; 1924 : 		if (_Count <= this->_Mysize)
; 1925 : 			{	// room for match, look for it
; 1926 : 			const _Elem *_Uptr = this->_Myptr() +
; 1927 : 				(_Off < this->_Mysize - _Count ? _Off
; 1928 : 					: this->_Mysize - _Count);
; 1929 : 			for (; ; --_Uptr)
; 1930 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1931 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1932 : 					return (_Uptr - this->_Myptr());	// found a match
; 1933 : 				else if (_Uptr == this->_Myptr())
; 1934 : 					break;	// at beginning, no more chance for match
; 1935 : 			}
; 1936 : 
; 1937 : 		return (npos);	// no match
; 1938 : 		}
; 1939 : 
; 1940 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1941 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1942 : 		_DEBUG_POINTER(_Ptr);
; 1943 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1944 : 		}
; 1945 : 
; 1946 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1947 : 		{	// look for _Ch before _Off
; 1948 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1949 : 		}
; 1950 : 
; 1951 : 	size_type find_first_of(const _Myt& _Right,
; 1952 : 		size_type _Off = 0) const _NOEXCEPT
; 1953 : 		{	// look for one of _Right at or after _Off
; 1954 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1955 : 		}
; 1956 : 
; 1957 : 	size_type find_first_of(const _Elem *_Ptr,
; 1958 : 		size_type _Off, size_type _Count) const
; 1959 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1960 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1961 : 		if (_Count != 0)
; 1962 : 			_DEBUG_POINTER(_Ptr);
; 1963 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1964 : 
; 1965 : 		if (0 < _Count && _Off < this->_Mysize)
; 1966 : 			{	// room for match, look for it
; 1967 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1968 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1969 : 				_Uptr < _Vptr; ++_Uptr)
; 1970 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1971 : 					return (_Uptr - this->_Myptr());	// found a match
; 1972 : 			}
; 1973 : 
; 1974 : 		return (npos);	// no match
; 1975 : 		}
; 1976 : 
; 1977 : 	size_type find_first_of(const _Elem *_Ptr,
; 1978 : 		size_type _Off = 0) const
; 1979 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1980 : 		_DEBUG_POINTER(_Ptr);
; 1981 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 1982 : 		}
; 1983 : 
; 1984 : 	size_type find_first_of(_Elem _Ch,
; 1985 : 		size_type _Off = 0) const
; 1986 : 		{	// look for _Ch at or after _Off
; 1987 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1988 : 		}
; 1989 : 
; 1990 : 	size_type find_last_of(const _Myt& _Right,
; 1991 : 		size_type _Off = npos) const _NOEXCEPT
; 1992 : 		{	// look for one of _Right before _Off
; 1993 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_last_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off, size_type _Count) const
; 1998 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 1999 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2000 : 		if (_Count != 0)
; 2001 : 			_DEBUG_POINTER(_Ptr);
; 2002 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2003 : 
; 2004 : 		if (0 < _Count && 0 < this->_Mysize)
; 2005 : 			{	// worth searching, do it
; 2006 : 			const _Elem *_Uptr = this->_Myptr()
; 2007 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2008 : 			for (; ; --_Uptr)
; 2009 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2010 : 					return (_Uptr - this->_Myptr());	// found a match
; 2011 : 				else if (_Uptr == this->_Myptr())
; 2012 : 					break;	// at beginning, no more chance for match
; 2013 : 			}
; 2014 : 
; 2015 : 		return (npos);	// no match
; 2016 : 		}
; 2017 : 
; 2018 : 	size_type find_last_of(const _Elem *_Ptr,
; 2019 : 		size_type _Off = npos) const
; 2020 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2021 : 		_DEBUG_POINTER(_Ptr);
; 2022 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2023 : 		}
; 2024 : 
; 2025 : 	size_type find_last_of(_Elem _Ch,
; 2026 : 		size_type _Off = npos) const
; 2027 : 		{	// look for _Ch before _Off
; 2028 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2029 : 		}
; 2030 : 
; 2031 : 	size_type find_first_not_of(const _Myt& _Right,
; 2032 : 		size_type _Off = 0) const _NOEXCEPT
; 2033 : 		{	// look for none of _Right at or after _Off
; 2034 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2035 : 			_Right.size()));
; 2036 : 		}
; 2037 : 
; 2038 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2039 : 		size_type _Off, size_type _Count) const
; 2040 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2041 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2042 : 		if (_Count != 0)
; 2043 : 			_DEBUG_POINTER(_Ptr);
; 2044 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2045 : 
; 2046 : 		if (_Off < this->_Mysize)
; 2047 : 			{	// room for match, look for it
; 2048 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2049 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2050 : 				_Uptr < _Vptr; ++_Uptr)
; 2051 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2052 : 					return (_Uptr - this->_Myptr());
; 2053 : 			}
; 2054 : 		return (npos);
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off = 0) const
; 2059 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2060 : 		_DEBUG_POINTER(_Ptr);
; 2061 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2062 : 		}
; 2063 : 
; 2064 : 	size_type find_first_not_of(_Elem _Ch,
; 2065 : 		size_type _Off = 0) const
; 2066 : 		{	// look for non _Ch at or after _Off
; 2067 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2068 : 		}
; 2069 : 
; 2070 : 	size_type find_last_not_of(const _Myt& _Right,
; 2071 : 		size_type _Off = npos) const _NOEXCEPT
; 2072 : 		{	// look for none of _Right before _Off
; 2073 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off, size_type _Count) const
; 2078 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2079 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2080 : 		if (_Count != 0)
; 2081 : 			_DEBUG_POINTER(_Ptr);
; 2082 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2083 : 
; 2084 : 		if (0 < this->_Mysize)
; 2085 : 			{	// worth searching, do it
; 2086 : 			const _Elem *_Uptr = this->_Myptr()
; 2087 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2088 : 			for (; ; --_Uptr)
; 2089 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2090 : 					return (_Uptr - this->_Myptr());
; 2091 : 				else if (_Uptr == this->_Myptr())
; 2092 : 					break;
; 2093 : 			}
; 2094 : 		return (npos);
; 2095 : 		}
; 2096 : 
; 2097 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2098 : 		size_type _Off = npos) const
; 2099 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2100 : 		_DEBUG_POINTER(_Ptr);
; 2101 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2102 : 		}
; 2103 : 
; 2104 : 	size_type find_last_not_of(_Elem _Ch,
; 2105 : 		size_type _Off = npos) const
; 2106 : 		{	// look for non _Ch before _Off
; 2107 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2108 : 		}
; 2109 : 
; 2110 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2111 : 		{	// return [_Off, _Off + _Count) as new string
; 2112 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2113 : 		}
; 2114 : 
; 2115 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2116 : 		{	// compare [0, _Mysize) with _Right
; 2117 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2118 : 		}
; 2119 : 
; 2120 : 	int compare(size_type _Off, size_type _N0,
; 2121 : 		const _Myt& _Right) const
; 2122 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2123 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2124 : 		}
; 2125 : 
; 2126 : 	int compare(size_type _Off,
; 2127 : 		size_type _N0, const _Myt& _Right,
; 2128 : 		size_type _Roff, size_type _Count) const
; 2129 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2130 : 		if (_Right.size() < _Roff)
; 2131 : 			_Xran();	// _Off off end
; 2132 : 		if (_Right._Mysize - _Roff < _Count)
; 2133 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2134 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2135 : 		}
; 2136 : 
; 2137 : 	int compare(const _Elem *_Ptr) const
; 2138 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2139 : 		_DEBUG_POINTER(_Ptr);
; 2140 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2141 : 		}
; 2142 : 
; 2143 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2144 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2145 : 		_DEBUG_POINTER(_Ptr);
; 2146 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2147 : 		}
; 2148 : 
; 2149 : 	int compare(size_type _Off,
; 2150 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2151 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2152 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2153 : 		if (_Count != 0)
; 2154 : 			_DEBUG_POINTER(_Ptr);
; 2155 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2156 : 
; 2157 : 		if (this->_Mysize < _Off)
; 2158 : 			_Xran();	// _Off off end
; 2159 : 		if (this->_Mysize - _Off < _N0)
; 2160 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2161 : 
; 2162 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2163 : 			_N0 < _Count ? _N0 : _Count);
; 2164 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2165 : 			: _N0 == _Count ? 0 : +1);
; 2166 : 		}
; 2167 : 
; 2168 : 	allocator_type get_allocator() const _NOEXCEPT
; 2169 : 		{	// return allocator object for values
; 2170 : 		return (this->_Getal());
; 2171 : 		}
; 2172 : 
; 2173 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2174 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2175 : 		if (_Count == 1)
; 2176 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2177 : 		else
; 2178 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2179 : 		}
; 2180 : 
; 2181 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2182 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2183 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2184 : 		if (max_size() < _Newres)
; 2185 : 			_Newres = _Newsize;	// undo roundup if too big
; 2186 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2187 : 			;
; 2188 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2189 : 			_Newres = this->_Myres
; 2190 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2191 : 		else
; 2192 : 			_Newres = max_size();	// settle for max_size()
; 2193 : 
; 2194 : 		_Elem *_Ptr;
; 2195 : 		_TRY_BEGIN
; 2196 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2197 : 		_CATCH_ALL
; 2198 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2199 : 			_TRY_BEGIN
; 2200 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2201 : 			_CATCH_ALL
; 2202 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2203 : 			_RERAISE;
; 2204 : 			_CATCH_END
; 2205 : 		_CATCH_END
; 2206 : 
; 2207 : 		if (0 < _Oldlen)
; 2208 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2209 : 				_Oldlen);	// copy existing elements
; 2210 : 		_Tidy(true);
; 2211 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2212 : 		this->_Myres = _Newres;
; 2213 : 		_Eos(_Oldlen);
; 2214 : 		}
; 2215 : 
; 2216 : 	void _Eos(size_type _Newsize)
; 2217 : 		{	// set new length and null terminator
; 2218 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  00120	48 89 7b 10	 mov	 QWORD PTR [rbx+16], rdi

; 517  : 			: this->_Bx._Buf);

  00124	72 05		 jb	 SHORT $LN115@append
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstddef

; 88   : 		reinterpret_cast<const volatile char&>(_Val)))));

  00126	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 517  : 			: this->_Bx._Buf);

  00129	eb 03		 jmp	 SHORT $LN116@append
$LN115@append:
  0012b	48 8b cb	 mov	 rcx, rbx
$LN116@append:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd

; 347  : 		_Left = _Right;

  0012e	33 c0		 xor	 eax, eax
  00130	66 89 04 79	 mov	 WORD PTR [rcx+rdi*2], ax
$LN119@append:
  00134	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 1057 : 		}

  00139	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  0013e	48 8b c3	 mov	 rax, rbx
  00141	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  00146	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0014a	41 5e		 pop	 r14
  0014c	c3		 ret	 0
$LN126@append:

; 2240 : 			return (false);	// don't ask
; 2241 : 		else
; 2242 : 			return (true);
; 2243 : 		}
; 2244 : 
; 2245 : 	static size_type _Pdif(const_iterator _P2,
; 2246 : 		const_iterator _P1)
; 2247 : 		{	// compute safe iterator difference
; 2248 : 		return (_STRING_ITER_BASE(_P2) == 0 ? 0 : _P2 - _P1);
; 2249 : 		}
; 2250 : 
; 2251 : 	void _Tidy(bool _Built = false,
; 2252 : 		size_type _Newsize = 0)
; 2253 : 		{	// initialize buffer, deallocating any storage
; 2254 : 		if (!_Built)
; 2255 : 			;
; 2256 : 		else if (this->_BUF_SIZE <= this->_Myres)
; 2257 : 			{	// copy any leftovers to small buffer and deallocate
; 2258 : 			pointer _Ptr = this->_Bx._Ptr;
; 2259 : 			this->_Getal().destroy(&this->_Bx._Ptr);
; 2260 : 			if (0 < _Newsize)
; 2261 : 				_Traits::copy(this->_Bx._Buf,
; 2262 : 					_STD addressof(*_Ptr), _Newsize);
; 2263 : 			this->_Getal().deallocate(_Ptr, this->_Myres + 1);
; 2264 : 			}
; 2265 : 		this->_Myres = this->_BUF_SIZE - 1;
; 2266 : 		_Eos(_Newsize);
; 2267 : 		}
; 2268 : 
; 2269 : 	__declspec(noreturn) void _Xlen() const
; 2270 : 		{	// report a length_error
; 2271 : 		_Xlength_error("string too long");

  0014d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  00154	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPEBD@Z ; std::_Xlength_error
  00159	cc		 int	 3
$LN128@append:
  0015a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  00161	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPEBD@Z ; std::_Xlength_error
  00166	cc		 int	 3
$LN123@append:
?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@PEB_W_K@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
;	COMDAT ?_Isnil@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@SAAEADPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@Z
_TEXT	SEGMENT
_Pnode$ = 8
?_Isnil@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@SAAEADPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::_Isnil, COMDAT

; 588  : 		return ((char&)_Pnode->_Isnil);

  00000	48 8d 41 19	 lea	 rax, QWORD PTR [rcx+25]

; 589  : 		}

  00004	c3		 ret	 0
?_Isnil@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@SAAEADPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::_Isnil
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
;	COMDAT ?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@SAAEAPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@PEAU32@@Z
_TEXT	SEGMENT
_Pnode$ = 8
?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@SAAEAPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@PEAU32@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::_Left, COMDAT

; 593  : 		return ((_Nodepref)_Pnode->_Left);

  00000	48 8b c1	 mov	 rax, rcx

; 594  : 		}

  00003	c3		 ret	 0
?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@SAAEAPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@PEAU32@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::_Left
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
;	COMDAT ?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@SAAEAPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@PEAU32@@Z
_TEXT	SEGMENT
_Pnode$ = 8
?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@SAAEAPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@PEAU32@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::_Parent, COMDAT

; 598  : 		return ((_Nodepref)_Pnode->_Parent);

  00000	48 8d 41 08	 lea	 rax, QWORD PTR [rcx+8]

; 599  : 		}

  00004	c3		 ret	 0
?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@SAAEAPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@PEAU32@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::_Parent
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
;	COMDAT ?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@SAAEAPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@PEAU32@@Z
_TEXT	SEGMENT
_Pnode$ = 8
?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@SAAEAPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@PEAU32@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::_Right, COMDAT

; 603  : 		return ((_Nodepref)_Pnode->_Right);

  00000	48 8d 41 10	 lea	 rax, QWORD PTR [rcx+16]

; 604  : 		}

  00004	c3		 ret	 0
?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@SAAEAPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@PEAU32@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::_Right
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
;	COMDAT ?_Myval@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@SAAEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@2@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@Z
_TEXT	SEGMENT
_Pnode$ = 8
?_Myval@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@SAAEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@2@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::_Myval, COMDAT

; 608  : 		return ((reference)_Pnode->_Myval);

  00000	48 8d 41 20	 lea	 rax, QWORD PTR [rcx+32]

; 609  : 		}

  00004	c3		 ret	 0
?_Myval@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@SAAEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@2@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::_Myval
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
;	COMDAT ?_Min@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@SAPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@PEAU32@@Z
_TEXT	SEGMENT
_Pnode$ = 8
?_Min@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@SAPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@PEAU32@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::_Min, COMDAT

; 588  : 		return ((char&)_Pnode->_Isnil);

  00000	48 8b 01	 mov	 rax, QWORD PTR [rcx]

; 620  : 		while (!_Isnil(_Left(_Pnode)))

  00003	80 78 19 00	 cmp	 BYTE PTR [rax+25], 0
  00007	75 13		 jne	 SHORT $LN14@Min
  00009	0f 1f 80 00 00
	00 00		 npad	 7
$LL2@Min:

; 621  : 			_Pnode = _Left(_Pnode);

  00010	48 8b c8	 mov	 rcx, rax

; 588  : 		return ((char&)_Pnode->_Isnil);

  00013	48 8b 00	 mov	 rax, QWORD PTR [rax]

; 620  : 		while (!_Isnil(_Left(_Pnode)))

  00016	80 78 19 00	 cmp	 BYTE PTR [rax+25], 0
  0001a	74 f4		 je	 SHORT $LL2@Min
$LN14@Min:

; 622  : 		return (_Pnode);

  0001c	48 8b c1	 mov	 rax, rcx

; 623  : 		}

  0001f	c3		 ret	 0
?_Min@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@SAPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@PEAU32@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::_Min
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QEAAXPEAV?$shared_ptr@VChunkBase@@@2@_K@Z
_TEXT	SEGMENT
this$dead$ = 8
_Ptr$ = 16
_Count$dead$ = 24
?deallocate@?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QEAAXPEAV?$shared_ptr@VChunkBase@@@2@_K@Z PROC ; std::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> > >::deallocate, COMDAT

; 586  : 		::operator delete(_Ptr);

  00000	48 8b ca	 mov	 rcx, rdx
  00003	e9 00 00 00 00	 jmp	 ??3@YAXPEAX@Z		; operator delete
?deallocate@?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QEAAXPEAV?$shared_ptr@VChunkBase@@@2@_K@Z ENDP ; std::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> > >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?_Unused_capacity@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?_Unused_capacity@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEBA_KXZ PROC ; std::vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::_Unused_capacity, COMDAT

; 972  : 		return (this->_Myend - this->_Mylast);

  00000	48 8b 41 10	 mov	 rax, QWORD PTR [rcx+16]
  00004	48 2b 41 08	 sub	 rax, QWORD PTR [rcx+8]
  00008	48 c1 f8 04	 sar	 rax, 4

; 973  : 		}

  0000c	c3		 ret	 0
?_Unused_capacity@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEBA_KXZ ENDP ; std::vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::_Unused_capacity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?max_size@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$dead$ = 8
?max_size@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEBA_KXZ PROC ; std::vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::max_size, COMDAT

; 1092 : 		return (this->_Getal().max_size());

  00000	48 b8 ff ff ff
	ff ff ff ff 0f	 mov	 rax, 1152921504606846975 ; 0fffffffffffffffH

; 1093 : 		}

  0000a	c3		 ret	 0
?max_size@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEBA_KXZ ENDP ; std::vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?_Destroy@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAXPEAV?$shared_ptr@VChunkBase@@@2@0@Z
_TEXT	SEGMENT
this$dead$ = 48
_First$ = 56
_Last$ = 64
?_Destroy@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAXPEAV?$shared_ptr@VChunkBase@@@2@0@Z PROC ; std::vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::_Destroy, COMDAT

; 1478 : 		{	// destroy [_First, _Last) using allocator

$LN37:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 88   : 	for (; _First != _Last; ++_First)

  00000	49 3b d0	 cmp	 rdx, r8
  00003	74 5c		 je	 SHORT $LN35@Destroy
  00005	56		 push	 rsi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx
  0000f	48 89 7c 24 38	 mov	 QWORD PTR [rsp+56], rdi
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector

; 1478 : 		{	// destroy [_First, _Last) using allocator

  00014	49 8b f0	 mov	 rsi, r8
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 80   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

  00017	48 8d 7a 08	 lea	 rdi, QWORD PTR [rdx+8]
  0001b	0f 1f 44 00 00	 npad	 5
$LL9@Destroy:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  00020	48 8b 1f	 mov	 rbx, QWORD PTR [rdi]
  00023	48 85 db	 test	 rbx, rbx
  00026	74 1d		 je	 SHORT $LN29@Destroy

; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  00028	f0 ff 4b 08	 lock dec DWORD PTR [rbx+8]
  0002c	75 17		 jne	 SHORT $LN29@Destroy

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  0002e	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00031	48 8b cb	 mov	 rcx, rbx
  00034	ff 10		 call	 QWORD PTR [rax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  00036	f0 ff 4b 0c	 lock dec DWORD PTR [rbx+12]
  0003a	75 09		 jne	 SHORT $LN29@Destroy

; 128  : 			_Delete_this();

  0003c	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  0003f	48 8b cb	 mov	 rcx, rbx
  00042	ff 50 08	 call	 QWORD PTR [rax+8]
$LN29@Destroy:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 88   : 	for (; _First != _Last; ++_First)

  00045	48 83 c7 10	 add	 rdi, 16
  00049	48 8d 47 f8	 lea	 rax, QWORD PTR [rdi-8]
  0004d	48 3b c6	 cmp	 rax, rsi
  00050	75 ce		 jne	 SHORT $LL9@Destroy
  00052	48 8b 7c 24 38	 mov	 rdi, QWORD PTR [rsp+56]
  00057	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector

; 1481 : 		}

  0005c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00060	5e		 pop	 rsi
$LN35@Destroy:
  00061	f3 c3		 fatret	 0
?_Destroy@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAXPEAV?$shared_ptr@VChunkBase@@@2@0@Z ENDP ; std::vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?_Grow_to@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEBA_K_K@Z
_TEXT	SEGMENT
this$ = 8
_Count$ = 16
?_Grow_to@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEBA_K_K@Z PROC ; std::vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::_Grow_to, COMDAT

; 967  : 		return (this->_Myend - this->_Myfirst);

  00000	4c 8b 41 10	 mov	 r8, QWORD PTR [rcx+16]

; 1485 : 		size_type _Capacity = capacity();
; 1486 : 
; 1487 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1488 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00004	48 b8 ff ff ff
	ff ff ff ff 0f	 mov	 rax, 1152921504606846975 ; 0fffffffffffffffH

; 967  : 		return (this->_Myend - this->_Myfirst);

  0000e	4c 2b 01	 sub	 r8, QWORD PTR [rcx]
  00011	49 c1 f8 04	 sar	 r8, 4

; 1485 : 		size_type _Capacity = capacity();
; 1486 : 
; 1487 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1488 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00015	49 8b c8	 mov	 rcx, r8
  00018	48 d1 e9	 shr	 rcx, 1
  0001b	48 2b c1	 sub	 rax, rcx
  0001e	49 3b c0	 cmp	 rax, r8
  00021	73 0e		 jae	 SHORT $LN4@Grow_to
  00023	45 33 c0	 xor	 r8d, r8d

; 1489 : 		if (_Capacity < _Count)

  00026	4c 3b c2	 cmp	 r8, rdx
  00029	4c 0f 42 c2	 cmovb	 r8, rdx

; 1490 : 			_Capacity = _Count;
; 1491 : 		return (_Capacity);

  0002d	49 8b c0	 mov	 rax, r8

; 1492 : 		}

  00030	c3		 ret	 0
$LN4@Grow_to:

; 1485 : 		size_type _Capacity = capacity();
; 1486 : 
; 1487 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1488 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00031	4c 03 c1	 add	 r8, rcx

; 1489 : 		if (_Capacity < _Count)

  00034	4c 3b c2	 cmp	 r8, rdx
  00037	4c 0f 42 c2	 cmovb	 r8, rdx

; 1490 : 			_Capacity = _Count;
; 1491 : 		return (_Capacity);

  0003b	49 8b c0	 mov	 rax, r8

; 1492 : 		}

  0003e	c3		 ret	 0
?_Grow_to@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEBA_K_K@Z ENDP ; std::vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::_Grow_to
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?_Reallocate@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAX_K@Z
_TEXT	SEGMENT
this$ = 80
_Count$ = 88
?_Reallocate@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAX_K@Z PROC ; std::vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::_Reallocate, COMDAT

; 1500 : 		{	// move to array of exactly _Count elements

$LN85:
  00000	40 56		 push	 rsi
  00002	41 56		 push	 r14
  00004	41 57		 push	 r15
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 23   : 	void *_Ptr = 0;

  0000a	45 33 ff	 xor	 r15d, r15d
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector

; 1500 : 		{	// move to array of exactly _Count elements

  0000d	48 8b f2	 mov	 rsi, rdx
  00010	4c 8b f1	 mov	 r14, rcx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 25   : 	if (_Count == 0)

  00013	48 85 d2	 test	 rdx, rdx
  00016	74 2b		 je	 SHORT $LN16@Reallocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  00018	48 b8 ff ff ff
	ff ff ff ff 0f	 mov	 rax, 1152921504606846975 ; 0fffffffffffffffH
  00022	48 3b d0	 cmp	 rdx, rax
  00025	0f 87 c3 00 00
	00		 ja	 $LN83@Reallocate
  0002b	48 8b ca	 mov	 rcx, rdx
  0002e	48 c1 e1 04	 shl	 rcx, 4
  00032	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  00037	4c 8b f8	 mov	 r15, rax
  0003a	48 85 c0	 test	 rax, rax
  0003d	0f 84 ab 00 00
	00		 je	 $LN83@Reallocate
$LN16@Reallocate:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory

; 473  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));

  00043	49 8b 56 08	 mov	 rdx, QWORD PTR [r14+8]
  00047	49 8b 0e	 mov	 rcx, QWORD PTR [r14]
  0004a	48 89 6c 24 58	 mov	 QWORD PTR [rsp+88], rbp
  0004f	4d 8b c7	 mov	 r8, r15
  00052	48 89 7c 24 60	 mov	 QWORD PTR [rsp+96], rdi
  00057	4c 89 64 24 68	 mov	 QWORD PTR [rsp+104], r12
  0005c	e8 00 00 00 00	 call	 ??$_Uninit_move@PEAV?$shared_ptr@VChunkBase@@@std@@PEAV12@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@V12@@std@@YAPEAV?$shared_ptr@VChunkBase@@@0@PEAV10@00AEAU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<std::shared_ptr<ChunkBase> * __ptr64,std::shared_ptr<ChunkBase> * __ptr64,std::allocator<std::shared_ptr<ChunkBase> >,std::shared_ptr<ChunkBase> >
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector

; 1087 : 		return (this->_Mylast - this->_Myfirst);

  00061	49 8b 3e	 mov	 rdi, QWORD PTR [r14]
  00064	4d 8b 66 08	 mov	 r12, QWORD PTR [r14+8]
  00068	49 8b ec	 mov	 rbp, r12
  0006b	48 2b ef	 sub	 rbp, rdi

; 1501 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1502 : 
; 1503 : 		_TRY_BEGIN
; 1504 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);
; 1505 : 		_CATCH_ALL
; 1506 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1507 : 		_RERAISE;
; 1508 : 		_CATCH_END
; 1509 : 
; 1510 : 		size_type _Size = size();
; 1511 : 		if (this->_Myfirst != pointer())

  0006e	48 85 ff	 test	 rdi, rdi
  00071	74 49		 je	 SHORT $LN75@Reallocate
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 88   : 	for (; _First != _Last; ++_First)

  00073	49 3b fc	 cmp	 rdi, r12
  00076	74 3c		 je	 SHORT $LN46@Reallocate
  00078	48 89 5c 24 50	 mov	 QWORD PTR [rsp+80], rbx
  0007d	0f 1f 00	 npad	 3
$LL48@Reallocate:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  00080	48 8b 5f 08	 mov	 rbx, QWORD PTR [rdi+8]
  00084	48 85 db	 test	 rbx, rbx
  00087	74 1d		 je	 SHORT $LN68@Reallocate

; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  00089	f0 ff 4b 08	 lock dec DWORD PTR [rbx+8]
  0008d	75 17		 jne	 SHORT $LN68@Reallocate

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  0008f	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00092	48 8b cb	 mov	 rcx, rbx
  00095	ff 10		 call	 QWORD PTR [rax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  00097	f0 ff 4b 0c	 lock dec DWORD PTR [rbx+12]
  0009b	75 09		 jne	 SHORT $LN68@Reallocate

; 128  : 			_Delete_this();

  0009d	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  000a0	48 8b cb	 mov	 rcx, rbx
  000a3	ff 50 08	 call	 QWORD PTR [rax+8]
$LN68@Reallocate:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 88   : 	for (; _First != _Last; ++_First)

  000a6	48 83 c7 10	 add	 rdi, 16
  000aa	49 3b fc	 cmp	 rdi, r12
  000ad	75 d1		 jne	 SHORT $LL48@Reallocate
  000af	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
$LN46@Reallocate:

; 89   : 		_Al.destroy(_First);
; 90   : 	}
; 91   : 
; 92   : template<class _Alloc> inline
; 93   : 	void _Destroy_range(typename _Alloc::pointer _First,
; 94   : 		typename _Alloc::pointer _Last, _Alloc& _Al,
; 95   : 		_Scalar_ptr_iterator_tag)
; 96   : 	{	// destroy [_First, _Last), scalar type (do nothing)
; 97   : 	}
; 98   : 
; 99   : 		// TEMPLATE CLASS _Is_simple_alloc
; 100  : template<class _Alty>
; 101  : 	struct _Is_simple_alloc
; 102  : 		: _Cat_base<is_same<typename _Alty::size_type, size_t>::value
; 103  : 		&& is_same<typename _Alty::difference_type, ptrdiff_t>::value
; 104  : 		&& is_same<typename _Alty::pointer,
; 105  : 			typename _Alty::value_type *>::value
; 106  : 		&& is_same<typename _Alty::const_pointer,
; 107  : 			const typename _Alty::value_type *>::value
; 108  : 		&& is_same<typename _Alty::reference,
; 109  : 			typename _Alty::value_type&>::value
; 110  : 		&& is_same<typename _Alty::const_reference,
; 111  : 			const typename _Alty::value_type&>::value>
; 112  : 	{	// tests if allocator has simple addressing
; 113  : 	};
; 114  : 
; 115  : 		// TEMPLATE CLASS _Simple_types
; 116  : template<class _Value_type>
; 117  : 	struct _Simple_types
; 118  : 	{	// wraps types needed by iterators
; 119  : 	typedef _Value_type value_type;
; 120  : 	typedef size_t size_type;
; 121  : 	typedef ptrdiff_t difference_type;
; 122  : 	typedef value_type *pointer;
; 123  : 	typedef const value_type *const_pointer;
; 124  : 	typedef value_type& reference;
; 125  : 	typedef const value_type& const_reference;
; 126  : 	};
; 127  : 
; 128  :  #if _HAS_CPP0X
; 129  : 		// TEMPLATE CLASS _Get_voidptr
; 130  : template<class _Alty,
; 131  : 	class _Pointer>
; 132  : 	struct _Get_voidptr
; 133  : 	{	// get void pointer for allocator
; 134  : 	typedef typename _Alty::template rebind<void>::other _Alvoid;
; 135  : 	typedef typename _Alvoid::pointer type;
; 136  : 	};
; 137  : 
; 138  : template<class _Alty,
; 139  : 	class _Ty>
; 140  : 	struct _Get_voidptr<_Alty, _Ty *>
; 141  : 	{	// get raw void pointer for allocator
; 142  : 	typedef void *type;
; 143  : 	};
; 144  : 
; 145  : 		// TEMPLATE CLASS _Is_iterator
; 146  : template<class _Iter>
; 147  : 	struct _Is_iterator
; 148  : 	: public integral_constant<bool, !is_integral<_Iter>::value>
; 149  : 	{	// tests for reasonable iterator candidate
; 150  : 	};
; 151  : 
; 152  : 		// TEMPLATE CLASS pointer_traits
; 153  : template<class _Ty>
; 154  : 	struct pointer_traits;
; 155  : 
; 156  : template<class _Ty>
; 157  : 	struct _Get_first_parameter
; 158  : 	{	// get _Ty::element_type
; 159  : 	typedef typename _Ty::element_type type;
; 160  : 	};
; 161  : 
; 162  : 		// TEMPLATE STRUCT _Replace_first_parameter
; 163  : template<class _Newfirst,
; 164  : 	class _Ty>
; 165  : 	struct _Replace_first_parameter
; 166  : 	{	// get _Ty::element_type
; 167  : 	typedef typename _Ty::template rebind<_Newfirst>::other type;
; 168  : 	};
; 169  : 
; 170  : 		// TEMPLATE STRUCT _Get_element_type
; 171  : template<class _Ty>
; 172  : 	struct _Get_element_type
; 173  : 	_GET_TYPE_OR_DEFAULT(element_type,
; 174  : 		typename _Get_first_parameter<_Ty>::type);
; 175  : 
; 176  : 		// TEMPLATE STRUCT _Get_ptr_difference_type
; 177  : template<class _Ty>
; 178  : 	struct _Get_ptr_difference_type
; 179  : 	_GET_TYPE_OR_DEFAULT(difference_type,
; 180  : 		ptrdiff_t);
; 181  : 
; 182  : 		// TEMPLATE STRUCT _Get_rebind_type
; 183  : template<class _Ty,
; 184  : 	class _Other>
; 185  : 	struct _Get_rebind_type
; 186  : 	_GET_TYPE_OR_DEFAULT(template rebind<_Other>::other,
; 187  : 		typename _Replace_first_parameter<_Other _COMMA _Uty>::type);
; 188  : 
; 189  : 		// TEMPLATE CLASS pointer_traits
; 190  : template<class _Ty>
; 191  : 	struct pointer_traits
; 192  : 	{	// defines traits for arbitrary pointers
; 193  : 	typedef pointer_traits<_Ty> other;
; 194  : 
; 195  : 	typedef typename _Get_element_type<_Ty>::type element_type;
; 196  : 	typedef _Ty pointer;
; 197  : 	typedef typename _Get_ptr_difference_type<_Ty>::type difference_type;
; 198  : 
; 199  : 	template<class _Other>
; 200  : 		struct rebind
; 201  : 		{	// converts X<element_type> to X<_Other>
; 202  : 		typedef typename _Get_rebind_type<_Ty, _Other>::type other;
; 203  : 		};
; 204  : 
; 205  : 	static pointer pointer_to(element_type& _Val)
; 206  : 		{	// convert raw reference to pointer
; 207  : 		return (_Ty::pointer_to(_Val));
; 208  : 		}
; 209  : 	};
; 210  : 
; 211  : 		// TEMPLATE CLASS pointer_traits<_Ty *>
; 212  : template<class _Ty>
; 213  : 	struct pointer_traits<_Ty *>
; 214  : 	{	// defines traits for raw pointers
; 215  : 	typedef pointer_traits<_Ty *> other;
; 216  : 
; 217  : 	typedef _Ty element_type;
; 218  : 	typedef _Ty *pointer;
; 219  : 	typedef ptrdiff_t difference_type;
; 220  : 
; 221  : 	template<class _Other>
; 222  : 		struct rebind
; 223  : 		{	// converts to a pointer to _Other
; 224  : 		typedef _Other *other;
; 225  : 		};
; 226  : 
; 227  : 	typedef typename _If<is_void<_Ty>::value,
; 228  : 		char&,
; 229  : 		typename add_reference<_Ty>::type>::type _Reftype;
; 230  : 
; 231  : 	static pointer pointer_to(_Reftype _Val)
; 232  : 		{	// convert raw reference to pointer
; 233  : 		return (_STD addressof(_Val));
; 234  : 		}
; 235  : 	};
; 236  : 
; 237  : 		// TEMPLATE STRUCT _Get_pointer_type
; 238  : template<class _Ty>
; 239  : 	struct _Get_pointer_type
; 240  : 	_GET_TYPE_OR_DEFAULT(pointer,
; 241  : 		typename _Ty::value_type *);
; 242  : 
; 243  : 		// TEMPLATE STRUCT _Get_const_pointer_type
; 244  : template<class _Ty>
; 245  : 	struct _Get_const_pointer_type
; 246  : 	_GET_TYPE_OR_DEFAULT(const_pointer,
; 247  : 		typename pointer_traits<typename _Get_pointer_type<_Ty>::type>
; 248  : 			::template rebind<const typename _Ty::value_type>::other);
; 249  : 
; 250  : 		// TEMPLATE STRUCT _Get_void_pointer_type
; 251  : template<class _Ty>
; 252  : 	struct _Get_void_pointer_type
; 253  : 	_GET_TYPE_OR_DEFAULT(void_pointer,
; 254  : 		typename pointer_traits<typename _Get_pointer_type<_Ty>::type>
; 255  : 			::template rebind<void>::other);
; 256  : 
; 257  : 		// TEMPLATE STRUCT _Get_const_void_pointer_type
; 258  : template<class _Ty>
; 259  : 	struct _Get_const_void_pointer_type
; 260  : 	_GET_TYPE_OR_DEFAULT(const_void_pointer,
; 261  : 		typename pointer_traits<typename _Get_pointer_type<_Ty>::type>
; 262  : 			::template rebind<const void>::other);
; 263  : 
; 264  : 		// TEMPLATE STRUCT _Get_difference_type
; 265  : template<class _Ty>
; 266  : 	struct _Get_difference_type
; 267  : 	_GET_TYPE_OR_DEFAULT(difference_type,
; 268  : 		typename _Get_ptr_difference_type<
; 269  : 			typename _Get_pointer_type<_Ty>::type>::type);
; 270  : 
; 271  : 		// TEMPLATE STRUCT _Get_size_type
; 272  : template<class _Ty>
; 273  : 	struct _Get_size_type
; 274  : 	_GET_TYPE_OR_DEFAULT(size_type,
; 275  : 		typename make_unsigned<
; 276  : 			typename _Get_difference_type<_Ty>::type>::type);
; 277  : 
; 278  : 		// TEMPLATE STRUCT _Get_propagate_on_container_copy
; 279  : template<class _Ty>
; 280  : 	struct _Get_propagate_on_container_copy
; 281  : 	_GET_TYPE_OR_DEFAULT(propagate_on_container_copy_assignment,
; 282  : 		false_type);
; 283  : 
; 284  : 		// TEMPLATE STRUCT _Get_propagate_on_container_move
; 285  : template<class _Ty>
; 286  : 	struct _Get_propagate_on_container_move
; 287  : 	_GET_TYPE_OR_DEFAULT(propagate_on_container_move_assignment,
; 288  : 		false_type);
; 289  : 
; 290  : 		// TEMPLATE STRUCT _Get_propagate_on_container_swap
; 291  : template<class _Ty>
; 292  : 	struct _Get_propagate_on_container_swap
; 293  : 	_GET_TYPE_OR_DEFAULT(propagate_on_container_swap,
; 294  : 		false_type);
; 295  : 
; 296  : 		// STRUCT _Alloc_allocate
; 297  : struct _Alloc_allocate
; 298  : 	{	// determines allocator_traits<_Alloc>
; 299  : 		// ::allocate(size_type, const_void_pointer)
; 300  : 
; 301  : 	template<class _Alloc,
; 302  : 		class _Size_type,
; 303  : 		class _Const_void_pointer>
; 304  : 		static auto _Fn(int, _Alloc& _Al,
; 305  : 			_Size_type _Count,
; 306  : 			_Const_void_pointer _Hint)
; 307  : 			-> decltype(_Al.allocate(_Count, _Hint))
; 308  : 		{	// call allocator supplied version
; 309  : 		return (_Al.allocate(_Count, _Hint));
; 310  : 		}
; 311  : 
; 312  : 	template<class _Alloc,
; 313  : 		class _Size_type,
; 314  : 		class _Const_void_pointer>
; 315  : 		static auto _Fn(_Wrap_int, _Alloc& _Al,
; 316  : 			_Size_type _Count,
; 317  : 			_Const_void_pointer)
; 318  : 			-> decltype(_Al.allocate(_Count))
; 319  : 		{	// call default version
; 320  : 		return (_Al.allocate(_Count));
; 321  : 		}
; 322  : 	};
; 323  : 
; 324  : 		// STRUCT _Alloc_construct
; 325  : struct _Alloc_construct
; 326  : 	{	// determines allocator_traits<_Ty>
; 327  : 		// ::construct(_Ty&, _Objty *, _Types...)
; 328  : 
; 329  : #define _ALLOC_CONSTRUCT( \
; 330  : 	TEMPLATE_LIST, PADDING_LIST, LIST, COMMA, CALL_OPT, X2, X3, X4) \
; 331  : 	template<class _Ty, \
; 332  : 		class _Objty COMMA LIST(_CLASS_TYPE)> \
; 333  : 		static auto _Fn(int, _Ty& _Al, _Objty *_Ptr \
; 334  : 			COMMA LIST(_TYPE_REFREF_ARG)) \
; 335  : 			-> decltype( \
; 336  : 				_Al.construct(_Ptr COMMA LIST(_FORWARD_ARG))) \
; 337  : 		{	/* call allocator supplied version */ \
; 338  : 		_Al.construct(_Ptr COMMA LIST(_FORWARD_ARG)); \
; 339  : 		} \
; 340  : 	template<class _Ty, \
; 341  : 		class _Objty COMMA LIST(_CLASS_TYPE)> \
; 342  : 		static auto _Fn(_Wrap_int, _Ty&, _Objty *_Ptr \
; 343  : 			COMMA LIST(_TYPE_REFREF_ARG)) \
; 344  : 			-> void \
; 345  : 		{	/* call default version */ \
; 346  : 		::new (static_cast<void *>(_Ptr)) \
; 347  : 			_Objty(LIST(_FORWARD_ARG)); \
; 348  : 		}
; 349  : 
; 350  : _VARIADIC_EXPAND_0X(_ALLOC_CONSTRUCT, , , , )
; 351  : #undef _ALLOC_CONSTRUCT
; 352  : 	};
; 353  : 
; 354  : 		// STRUCT _Alloc_destroy
; 355  : struct _Alloc_destroy
; 356  : 	{	// determines allocator_traits<_Ty>::destroy(_Ty&, _Objty *)
; 357  : 	template<class _Ty,
; 358  : 		class _Objty>
; 359  : 		static auto _Fn(int, _Ty& _Al, _Objty *_Ptr)
; 360  : 			-> decltype(_Al.destroy(_Ptr))
; 361  : 		{	// call allocator supplied version
; 362  : 		_Al.destroy(_Ptr);
; 363  : 		}
; 364  : 
; 365  : 	template<class _Ty,
; 366  : 		class _Objty>
; 367  : 		static auto _Fn(_Wrap_int, _Ty&, _Objty *_Ptr)
; 368  : 			-> void
; 369  : 		{	// call default version
; 370  : 		_Ptr->~_Objty();
; 371  : 		}
; 372  : 	};
; 373  : 
; 374  : 		// STRUCT _Alloc_max_size
; 375  : struct _Alloc_max_size
; 376  : 	{	// determines allocator_traits<_Ty>::max_size(const _Ty&)
; 377  : 	template<class _Ty>
; 378  : 		static auto _Fn(int, const _Ty& _Al)
; 379  : 			-> decltype(_Al.max_size())
; 380  : 		{	// call allocator supplied version
; 381  : 		return (_Al.max_size());
; 382  : 		}
; 383  : 
; 384  : 	template<class _Ty>
; 385  : 		static auto _Fn(_Wrap_int, const _Ty&)
; 386  : 			-> typename _Get_size_type<_Ty>::type
; 387  : 		{	// call default version
; 388  : 		return ((numeric_limits<typename _Get_size_type<_Ty>::type>::max)());
; 389  : 		}
; 390  : 	};
; 391  : 
; 392  : 		// STRUCT _Alloc_select
; 393  : struct _Alloc_select
; 394  : 	{	// determines allocator_traits<_Ty>
; 395  : 		// ::select_on_container_copy_construction(const _Alloc&)
; 396  : 
; 397  : 	template<class _Ty>
; 398  : 		static auto _Fn(int, const _Ty& _Al)
; 399  : 			-> decltype((_Ty)_Al.select_on_container_copy_construction())
; 400  : 		{	// call allocator supplied version
; 401  : 		return (_Al.select_on_container_copy_construction());
; 402  : 		}
; 403  : 
; 404  : 	template<class _Ty>
; 405  : 		static auto _Fn(_Wrap_int, const _Ty& _Al)
; 406  : 			-> _Ty
; 407  : 		{	// call default version
; 408  : 		return (_Al);
; 409  : 		}
; 410  : 	};
; 411  : 
; 412  : 		// TEMPLATE CLASS allocator_traits
; 413  : template<class _Alloc>
; 414  : 	struct allocator_traits
; 415  : 	{	// defines traits for allocators
; 416  : 	typedef allocator_traits<_Alloc> other;
; 417  : 
; 418  : 	typedef _Alloc allocator_type;
; 419  : 	typedef typename _Alloc::value_type value_type;
; 420  : 
; 421  : 	typedef typename _Get_pointer_type<_Alloc>::type
; 422  : 		pointer;
; 423  : 	typedef typename _Get_const_pointer_type<_Alloc>::type
; 424  : 		const_pointer;
; 425  : 	typedef typename _Get_void_pointer_type<_Alloc>::type
; 426  : 		void_pointer;
; 427  : 	typedef typename _Get_const_void_pointer_type<_Alloc>::type
; 428  : 		const_void_pointer;
; 429  : 
; 430  : 	typedef typename _Get_size_type<_Alloc>::type size_type;
; 431  : 	typedef typename _Get_difference_type<_Alloc>::type difference_type;
; 432  : 
; 433  : 	typedef typename _Get_propagate_on_container_copy<_Alloc>::type
; 434  : 		propagate_on_container_copy_assignment;
; 435  : 	typedef typename _Get_propagate_on_container_move<_Alloc>::type
; 436  : 		propagate_on_container_move_assignment;
; 437  : 	typedef typename _Get_propagate_on_container_swap<_Alloc>::type
; 438  : 		propagate_on_container_swap;
; 439  : 
; 440  : 	template<class _Other>
; 441  : 		struct rebind_alloc
; 442  : 		{	// converts allocator<element_type> to allocator<_Other>
; 443  : 		typedef typename _Get_rebind_type<_Alloc, _Other>::type other;
; 444  : 		};
; 445  : 
; 446  : 	template<class _Other>
; 447  : 		struct rebind_traits
; 448  : 		{	// converts allocator_traits<X<element_type>>
; 449  : 			// to allocator_traits<X<_Other>>
; 450  : 		typedef typename rebind_alloc<_Other>::other _Other_alloc;
; 451  : 		typedef allocator_traits<_Other_alloc> other;
; 452  : 		};
; 453  : 
; 454  : 	static pointer allocate(_Alloc& _Al, size_type _Count)
; 455  : 		{	// allocate array of _Count elements
; 456  : 		return (_Al.allocate(_Count));
; 457  : 		}
; 458  : 
; 459  : 	static pointer allocate(_Alloc& _Al, size_type _Count,
; 460  : 		const_void_pointer _Hint)
; 461  : 		{	// allocate array of _Count elements, with hint
; 462  : 		return (_Alloc_allocate::_Fn(0, _Al, _Count, _Hint));
; 463  : 		}
; 464  : 
; 465  : 	static void deallocate(_Alloc& _Al,
; 466  : 		pointer _Ptr, size_type _Count)
; 467  : 		{	// deallocate _Count elements at _Ptr
; 468  : 		_Al.deallocate(_Ptr, _Count);
; 469  : 		}
; 470  : 
; 471  : #define _ALLOC_TRAITS_CONSTRUCT( \
; 472  : 	TEMPLATE_LIST, PADDING_LIST, LIST, COMMA, CALL_OPT, X2, X3, X4) \
; 473  : 	template<class _Ty COMMA LIST(_CLASS_TYPE)> \
; 474  : 		static void construct(_Alloc& _Al, _Ty *_Ptr \
; 475  : 			COMMA LIST(_TYPE_REFREF_ARG)) \
; 476  : 		{	/* construct _Ty(_Types...) at _Ptr */ \
; 477  : 		_Alloc_construct::_Fn(0, _Al, _Ptr COMMA LIST(_FORWARD_ARG)); \
; 478  : 		}
; 479  : 
; 480  : _VARIADIC_EXPAND_0X(_ALLOC_TRAITS_CONSTRUCT, , , , )
; 481  : #undef _ALLOC_TRAITS_CONSTRUCT
; 482  : 
; 483  : 	template<class _Ty>
; 484  : 		static void destroy(_Alloc& _Al, _Ty *_Ptr)
; 485  : 		{	// destroy object at _Ptr
; 486  : 		_Alloc_destroy::_Fn(0, _Al, _Ptr);
; 487  : 		}
; 488  : 
; 489  : 	static size_type max_size(const _Alloc& _Al)
; 490  : 		{	// get maximum size
; 491  : 		return (_Alloc_max_size::_Fn(0, _Al));
; 492  : 		}
; 493  : 
; 494  : 	static _Alloc select_on_container_copy_construction(
; 495  : 		const _Alloc& _Al)
; 496  : 		{	// get allocator to use
; 497  : 		return (_Alloc_select::_Fn(0, _Al));
; 498  : 		}
; 499  : 	};
; 500  :  #endif /* _HAS_CPP0X */
; 501  : 
; 502  : 		// TEMPLATE CLASS _Allocator_base
; 503  : template<class _Ty>
; 504  : 	struct _Allocator_base
; 505  : 	{	// base class for generic allocators
; 506  : 	typedef _Ty value_type;
; 507  : 	};
; 508  : 
; 509  : 		// TEMPLATE CLASS _Allocator_base<const _Ty>
; 510  : template<class _Ty>
; 511  : 	struct _Allocator_base<const _Ty>
; 512  : 	{	// base class for generic allocators for const _Ty
; 513  : 	typedef _Ty value_type;
; 514  : 	};
; 515  : 
; 516  : 		// TEMPLATE CLASS allocator
; 517  : template<class _Ty>
; 518  : 	class allocator
; 519  : 		: public _Allocator_base<_Ty>
; 520  : 	{	// generic allocator for objects of class _Ty
; 521  : public:
; 522  : 	typedef allocator<_Ty> other;
; 523  : 
; 524  : 	typedef _Allocator_base<_Ty> _Mybase;
; 525  : 	typedef typename _Mybase::value_type value_type;
; 526  : 
; 527  : 	typedef value_type *pointer;
; 528  : 	typedef const value_type *const_pointer;
; 529  : 	typedef void *void_pointer;
; 530  : 	typedef const void *const_void_pointer;
; 531  : 
; 532  : 	typedef value_type& reference;
; 533  : 	typedef const value_type& const_reference;
; 534  : 
; 535  : 	typedef size_t size_type;
; 536  : 	typedef ptrdiff_t difference_type;
; 537  : 
; 538  :  #if _HAS_CPP0X
; 539  : 	typedef false_type propagate_on_container_copy_assignment;
; 540  : 	typedef false_type propagate_on_container_move_assignment;
; 541  : 	typedef false_type propagate_on_container_swap;
; 542  : 
; 543  : 	allocator<_Ty> select_on_container_copy_construction() const
; 544  : 		{	// return this allocator
; 545  : 		return (*this);
; 546  : 		}
; 547  :  #endif /* _HAS_CPP0X */
; 548  : 
; 549  : 	template<class _Other>
; 550  : 		struct rebind
; 551  : 		{	// convert this type to allocator<_Other>
; 552  : 		typedef allocator<_Other> other;
; 553  : 		};
; 554  : 
; 555  : 	pointer address(reference _Val) const _NOEXCEPT
; 556  : 		{	// return address of mutable _Val
; 557  : 		return (_STD addressof(_Val));
; 558  : 		}
; 559  : 
; 560  : 	const_pointer address(const_reference _Val) const _NOEXCEPT
; 561  : 		{	// return address of nonmutable _Val
; 562  : 		return (_STD addressof(_Val));
; 563  : 		}
; 564  : 
; 565  : 	allocator() _THROW0()
; 566  : 		{	// construct default allocator (do nothing)
; 567  : 		}
; 568  : 
; 569  : 	allocator(const allocator<_Ty>&) _THROW0()
; 570  : 		{	// construct by copying (do nothing)
; 571  : 		}
; 572  : 
; 573  : 	template<class _Other>
; 574  : 		allocator(const allocator<_Other>&) _THROW0()
; 575  : 		{	// construct from a related allocator (do nothing)
; 576  : 		}
; 577  : 
; 578  : 	template<class _Other>
; 579  : 		allocator<_Ty>& operator=(const allocator<_Other>&)
; 580  : 		{	// assign from a related allocator (do nothing)
; 581  : 		return (*this);
; 582  : 		}
; 583  : 
; 584  : 	void deallocate(pointer _Ptr, size_type)
; 585  : 		{	// deallocate object at _Ptr, ignore size
; 586  : 		::operator delete(_Ptr);

  000b4	49 8b 0e	 mov	 rcx, QWORD PTR [r14]
  000b7	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
$LN75@Reallocate:
  000bc	4c 8b 64 24 68	 mov	 r12, QWORD PTR [rsp+104]
  000c1	48 8b 7c 24 60	 mov	 rdi, QWORD PTR [rsp+96]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector

; 1519 : 		this->_Myend = _Ptr + _Count;

  000c6	48 c1 e6 04	 shl	 rsi, 4

; 1520 : 		this->_Mylast = _Ptr + _Size;

  000ca	48 83 e5 f0	 and	 rbp, -16
  000ce	49 03 f7	 add	 rsi, r15

; 1521 : 		this->_Myfirst = _Ptr;

  000d1	4d 89 3e	 mov	 QWORD PTR [r14], r15
  000d4	49 03 ef	 add	 rbp, r15
  000d7	49 89 76 10	 mov	 QWORD PTR [r14+16], rsi
  000db	49 89 6e 08	 mov	 QWORD PTR [r14+8], rbp
  000df	48 8b 6c 24 58	 mov	 rbp, QWORD PTR [rsp+88]

; 1522 : 		}

  000e4	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000e8	41 5f		 pop	 r15
  000ea	41 5e		 pop	 r14
  000ec	5e		 pop	 rsi
  000ed	c3		 ret	 0
$LN83@Reallocate:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 29   : 		_Xbad_alloc();	// report no memory

  000ee	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
  000f3	cc		 int	 3
$LN82@Reallocate:
?_Reallocate@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAX_K@Z ENDP ; std::vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::_Reallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?_Xlen@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEBAXXZ
_TEXT	SEGMENT
this$dead$ = 48
?_Xlen@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEBAXXZ PROC ; std::vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::_Xlen, COMDAT

; 1666 : 		{	// report a length_error

$LN4:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1667 : 		_Xlength_error("vector<T> too long");

  00004	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  0000b	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPEBD@Z ; std::_Xlength_error
  00010	cc		 int	 3
$LN3@Xlen:
?_Xlen@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEBAXXZ ENDP ; std::vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::_Xlen
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_Vector_val@U?$_Simple_types@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QEAA@XZ PROC ; std::_Vector_val<std::_Simple_types<std::shared_ptr<ChunkBase> > >::_Vector_val<std::_Simple_types<std::shared_ptr<ChunkBase> > >, COMDAT

; 485  : 		{	// initialize values
; 486  : 		_Myfirst = pointer();

  00000	33 c0		 xor	 eax, eax
  00002	48 89 01	 mov	 QWORD PTR [rcx], rax

; 487  : 		_Mylast = pointer();

  00005	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 488  : 		_Myend = pointer();

  00009	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 489  : 		}

  0000d	48 8b c1	 mov	 rax, rcx
  00010	c3		 ret	 0
??0?$_Vector_val@U?$_Simple_types@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QEAA@XZ ENDP ; std::_Vector_val<std::_Simple_types<std::shared_ptr<ChunkBase> > >::_Vector_val<std::_Simple_types<std::shared_ptr<ChunkBase> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
;	COMDAT ??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@PEBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 8
_Pnode$ = 16
_Plist$dead$ = 24
??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@PEBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@1@@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >, COMDAT

; 44   : 		{	// construct with node pointer _Pnode

  00000	48 89 11	 mov	 QWORD PTR [rcx], rdx

; 215  : 		}

  00003	48 8b c1	 mov	 rax, rcx
  00006	c3		 ret	 0
??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@PEBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@1@@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\wchar.h
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\wchar.h
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@AEBV12@_K1@Z
_TEXT	SEGMENT
this$ = 48
_Right$ = 56
_Roff$ = 64
_Count$ = 72
?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@AEBV12@_K1@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append, COMDAT

; 1019 : 		{	// append _Right [_Roff, _Roff + _Count)

$LN119:
  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 6c 24 18	 mov	 QWORD PTR [rsp+24], rbp
  0000a	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi
  0000f	41 56		 push	 r14
  00011	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1020 : 		if (_Right.size() < _Roff)

  00015	48 8b 42 10	 mov	 rax, QWORD PTR [rdx+16]
  00019	49 8b f1	 mov	 rsi, r9
  0001c	49 8b e8	 mov	 rbp, r8
  0001f	4c 8b f2	 mov	 r14, rdx
  00022	48 8b d9	 mov	 rbx, rcx
  00025	49 3b c0	 cmp	 rax, r8
  00028	0f 82 e7 00 00
	00		 jb	 $LN115@append

; 1021 : 			_Xran();	// _Roff off end
; 1022 : 		size_type _Num = _Right.size() - _Roff;

  0002e	49 2b c0	 sub	 rax, r8

; 1023 : 		if (_Num < _Count)
; 1024 : 			_Count = _Num;	// trim _Count to size
; 1025 : 		if (npos - this->_Mysize <= _Count)

  00031	4c 8b 41 10	 mov	 r8, QWORD PTR [rcx+16]
  00035	49 3b c1	 cmp	 rax, r9
  00038	48 0f 42 f0	 cmovb	 rsi, rax
  0003c	48 83 c8 ff	 or	 rax, -1
  00040	49 2b c0	 sub	 rax, r8
  00043	48 3b c6	 cmp	 rax, rsi
  00046	0f 86 d6 00 00
	00		 jbe	 $LN117@append

; 1026 : 			_Xlen();	// result too long
; 1027 : 
; 1028 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))

  0004c	48 89 7c 24 30	 mov	 QWORD PTR [rsp+48], rdi
  00051	48 85 f6	 test	 rsi, rsi
  00054	0f 84 9d 00 00
	00		 je	 $LN109@append
  0005a	49 8d 3c 30	 lea	 rdi, QWORD PTR [r8+rsi]

; 2219 : 		}
; 2220 : 
; 2221 : 	bool _Grow(size_type _Newsize,
; 2222 : 		bool _Trim = false)
; 2223 : 		{	// ensure buffer is big enough, trim to size if _Trim is true
; 2224 : 		if (max_size() < _Newsize)

  0005e	48 b8 fe ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775806 ; 7ffffffffffffffeH
  00068	48 3b f8	 cmp	 rdi, rax
  0006b	0f 87 be 00 00
	00		 ja	 $LN118@append

; 2225 : 			_Xlen();	// result too long
; 2226 : 		if (this->_Myres < _Newsize)

  00071	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  00075	48 3b cf	 cmp	 rcx, rdi
  00078	73 26		 jae	 SHORT $LN20@append

; 2227 : 			_Copy(_Newsize, this->_Mysize);	// reallocate to grow

  0007a	48 8b d7	 mov	 rdx, rdi
  0007d	48 8b cb	 mov	 rcx, rbx
  00080	e8 00 00 00 00	 call	 ?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAX_K0@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Copy

; 2233 : 		return (0 < _Newsize);	// return true only if more work to do

  00085	48 85 ff	 test	 rdi, rdi

; 1026 : 			_Xlen();	// result too long
; 1027 : 
; 1028 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))

  00088	74 6d		 je	 SHORT $LN109@append
$LN114@append:

; 518  : 		}
; 519  : 
; 520  : 	const value_type *_Myptr() const
; 521  : 		{	// determine current pointer to buffer for nonmutable string
; 522  : 		return (this->_BUF_SIZE <= this->_Myres
; 523  : 			? _STD addressof(*this->_Bx._Ptr)
; 524  : 			: this->_Bx._Buf);

  0008a	49 83 7e 18 08	 cmp	 QWORD PTR [r14+24], 8
  0008f	72 03		 jb	 SHORT $LN85@append
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstddef

; 88   : 		reinterpret_cast<const volatile char&>(_Val)))));

  00091	4d 8b 36	 mov	 r14, QWORD PTR [r14]
$LN85@append:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 517  : 			: this->_Bx._Buf);

  00094	48 83 7b 18 08	 cmp	 QWORD PTR [rbx+24], 8
  00099	72 26		 jb	 SHORT $LN91@append
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstddef

; 88   : 		reinterpret_cast<const volatile char&>(_Val)))));

  0009b	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 517  : 			: this->_Bx._Buf);

  0009e	eb 24		 jmp	 SHORT $LN92@append
$LN20@append:

; 2228 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)
; 2229 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 2230 : 				_Newsize < this->_Mysize ? _Newsize : this->_Mysize);
; 2231 : 		else if (_Newsize == 0)

  000a0	48 85 ff	 test	 rdi, rdi
  000a3	75 e5		 jne	 SHORT $LN114@append

; 1036 : 
; 1037 : 	_Myt& append(const _Elem *_Ptr, size_type _Count)
; 1038 : 		{	// append [_Ptr, _Ptr + _Count)
; 1039 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1040 : 		if (_Count != 0)
; 1041 : 			_DEBUG_POINTER(_Ptr);
; 1042 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1043 : 
; 1044 : 		if (_Inside(_Ptr))
; 1045 : 			return (append(*this,
; 1046 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1047 : 		if (npos - this->_Mysize <= _Count)
; 1048 : 			_Xlen();	// result too long
; 1049 : 
; 1050 : 		size_type _Num;
; 1051 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1052 : 			{	// make room and append new stuff
; 1053 : 			_Traits::copy(this->_Myptr() + this->_Mysize, _Ptr, _Count);
; 1054 : 			_Eos(_Num);
; 1055 : 			}
; 1056 : 		return (*this);
; 1057 : 		}
; 1058 : 
; 1059 : 	_Myt& append(const _Elem *_Ptr)
; 1060 : 		{	// append [_Ptr, <null>)
; 1061 : 		_DEBUG_POINTER(_Ptr);
; 1062 : 		return (append(_Ptr, _Traits::length(_Ptr)));
; 1063 : 		}
; 1064 : 
; 1065 : 	_Myt& append(size_type _Count, _Elem _Ch)
; 1066 : 		{	// append _Count * _Ch
; 1067 : 		if (npos - this->_Mysize <= _Count)
; 1068 : 			_Xlen();	// result too long
; 1069 : 
; 1070 : 		size_type _Num;
; 1071 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1072 : 			{	// make room and append new stuff using assign
; 1073 : 			_Chassign(this->_Mysize, _Count, _Ch);
; 1074 : 			_Eos(_Num);
; 1075 : 			}
; 1076 : 		return (*this);
; 1077 : 		}
; 1078 : 
; 1079 : 	template<class _Iter>
; 1080 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1081 : 			_Myt&>::type
; 1082 : 		append(_Iter _First, _Iter _Last)
; 1083 : 		{	// append [_First, _Last), input iterators
; 1084 : 		return (replace(end(), end(), _First, _Last));
; 1085 : 		}
; 1086 : 
; 1087 : 	_Myt& append(const_pointer _First, const_pointer _Last)
; 1088 : 		{	// append [_First, _Last), const pointers
; 1089 : 		return (replace(end(), end(), _First, _Last));
; 1090 : 		}
; 1091 : 
; 1092 : 	_Myt& append(const_iterator _First, const_iterator _Last)
; 1093 : 		{	// append [_First, _Last), const_iterators
; 1094 : 		return (replace(end(), end(), _First, _Last));
; 1095 : 		}
; 1096 : 
; 1097 : 	_Myt& assign(const _Myt& _Right)
; 1098 : 		{	// assign _Right
; 1099 : 		return (assign(_Right, 0, npos));
; 1100 : 		}
; 1101 : 
; 1102 : 	_Myt& assign(const _Myt& _Right,
; 1103 : 		size_type _Roff, size_type _Count)
; 1104 : 		{	// assign _Right [_Roff, _Roff + _Count)
; 1105 : 		if (_Right.size() < _Roff)
; 1106 : 			_Xran();	// _Roff off end
; 1107 : 		size_type _Num = _Right.size() - _Roff;
; 1108 : 		if (_Count < _Num)
; 1109 : 			_Num = _Count;	// trim _Num to size
; 1110 : 
; 1111 : 		if (this == &_Right)
; 1112 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring
; 1113 : 		else if (_Grow(_Num))
; 1114 : 			{	// make room and assign new stuff
; 1115 : 			_Traits::copy(this->_Myptr(),
; 1116 : 				_Right._Myptr() + _Roff, _Num);
; 1117 : 			_Eos(_Num);
; 1118 : 			}
; 1119 : 		return (*this);
; 1120 : 		}
; 1121 : 
; 1122 : 	_Myt& assign(const _Elem *_Ptr, size_type _Count)
; 1123 : 		{	// assign [_Ptr, _Ptr + _Count)
; 1124 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1125 : 		if (_Count != 0)
; 1126 : 			_DEBUG_POINTER(_Ptr);
; 1127 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1128 : 
; 1129 : 		if (_Inside(_Ptr))
; 1130 : 			return (assign(*this,
; 1131 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1132 : 
; 1133 : 		if (_Grow(_Count))
; 1134 : 			{	// make room and assign new stuff
; 1135 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);
; 1136 : 			_Eos(_Count);
; 1137 : 			}
; 1138 : 		return (*this);
; 1139 : 		}
; 1140 : 
; 1141 : 	_Myt& assign(const _Elem *_Ptr)
; 1142 : 		{	// assign [_Ptr, <null>)
; 1143 : 		_DEBUG_POINTER(_Ptr);
; 1144 : 		return (assign(_Ptr, _Traits::length(_Ptr)));
; 1145 : 		}
; 1146 : 
; 1147 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1148 : 		{	// assign _Count * _Ch
; 1149 : 		if (_Count == npos)
; 1150 : 			_Xlen();	// result too long
; 1151 : 
; 1152 : 		if (_Grow(_Count))
; 1153 : 			{	// make room and assign new stuff
; 1154 : 			_Chassign(0, _Count, _Ch);
; 1155 : 			_Eos(_Count);
; 1156 : 			}
; 1157 : 		return (*this);
; 1158 : 		}
; 1159 : 
; 1160 : 	template<class _Iter>
; 1161 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1162 : 			_Myt&>::type
; 1163 : 		assign(_Iter _First, _Iter _Last)
; 1164 : 		{	// assign [First, _Last), input iterators
; 1165 : 		return (replace(begin(), end(), _First, _Last));
; 1166 : 		}
; 1167 : 
; 1168 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1169 : 		{	// assign [First, _Last), const pointers
; 1170 : 		return (replace(begin(), end(), _First, _Last));
; 1171 : 		}
; 1172 : 
; 1173 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1174 : 		{	// assign [First, _Last), const_iterators
; 1175 : 		return (replace(begin(), end(), _First, _Last));
; 1176 : 		}
; 1177 : 
; 1178 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1179 : 		{	// insert _Right at _Off
; 1180 : 		return (insert(_Off, _Right, 0, npos));
; 1181 : 		}
; 1182 : 
; 1183 : 	_Myt& insert(size_type _Off,
; 1184 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1185 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1186 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1187 : 			_Xran();	// _Off or _Roff off end
; 1188 : 		size_type _Num = _Right.size() - _Roff;
; 1189 : 		if (_Num < _Count)
; 1190 : 			_Count = _Num;	// trim _Count to size
; 1191 : 		if (npos - this->_Mysize <= _Count)
; 1192 : 			_Xlen();	// result too long
; 1193 : 
; 1194 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1195 : 			{	// make room and insert new stuff
; 1196 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1197 : 				this->_Myptr() + _Off,
; 1198 : 				this->_Mysize - _Off);	// empty out hole
; 1199 : 			if (this == &_Right)
; 1200 : 				_Traits::move(this->_Myptr() + _Off,
; 1201 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1202 : 						_Count);	// substring
; 1203 : 			else
; 1204 : 				_Traits::copy(this->_Myptr() + _Off,
; 1205 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1206 : 			_Eos(_Num);
; 1207 : 			}
; 1208 : 		return (*this);
; 1209 : 		}
; 1210 : 
; 1211 : 	_Myt& insert(size_type _Off,
; 1212 : 		const _Elem *_Ptr, size_type _Count)
; 1213 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1214 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1215 : 		if (_Count != 0)
; 1216 : 			_DEBUG_POINTER(_Ptr);
; 1217 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1218 : 
; 1219 : 		if (_Inside(_Ptr))
; 1220 : 			return (insert(_Off, *this,
; 1221 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1222 : 		if (this->_Mysize < _Off)
; 1223 : 			_Xran();	// _Off off end
; 1224 : 		if (npos - this->_Mysize <= _Count)
; 1225 : 			_Xlen();	// result too long
; 1226 : 		size_type _Num;
; 1227 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1228 : 			{	// make room and insert new stuff
; 1229 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1230 : 				this->_Myptr() + _Off,
; 1231 : 				this->_Mysize - _Off);	// empty out hole
; 1232 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1233 : 			_Eos(_Num);
; 1234 : 			}
; 1235 : 		return (*this);
; 1236 : 		}
; 1237 : 
; 1238 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1239 : 		{	// insert [_Ptr, <null>) at _Off
; 1240 : 		_DEBUG_POINTER(_Ptr);
; 1241 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1242 : 		}
; 1243 : 
; 1244 : 	_Myt& insert(size_type _Off,
; 1245 : 		size_type _Count, _Elem _Ch)
; 1246 : 		{	// insert _Count * _Ch at _Off
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	iterator insert(const_iterator _Where)
; 1264 : 		{	// insert <null> at _Where
; 1265 : 		return (insert(_Where, _Elem()));
; 1266 : 		}
; 1267 : 
; 1268 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1269 : 		{	// insert _Ch at _Where
; 1270 : 		size_type _Off = _Pdif(_Where, begin());
; 1271 : 		insert(_Off, 1, _Ch);
; 1272 : 		return (begin() + _Off);
; 1273 : 		}
; 1274 : 
; 1275 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1276 : 		{	// insert _Count * _Elem at _Where
; 1277 : 		size_type _Off = _Pdif(_Where, begin());
; 1278 : 		insert(_Off, _Count, _Ch);
; 1279 : 		return (begin() + _Off);
; 1280 : 		}
; 1281 : 
; 1282 : 	template<class _Iter>
; 1283 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1284 : 			iterator>::type
; 1285 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1286 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1287 : 		size_type _Off = _Pdif(_Where, begin());
; 1288 : 		replace(_Where, _Where, _First, _Last);
; 1289 : 		return (begin() + _Off);
; 1290 : 		}
; 1291 : 
; 1292 : 	iterator insert(const_iterator _Where,
; 1293 : 		const_pointer _First, const_pointer _Last)
; 1294 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		replace(_Where, _Where, _First, _Last);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where,
; 1301 : 		const_iterator _First, const_iterator _Last)
; 1302 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1303 : 		size_type _Off = _Pdif(_Where, begin());
; 1304 : 		replace(_Where, _Where, _First, _Last);
; 1305 : 		return (begin() + _Off);
; 1306 : 		}
; 1307 : 
; 1308 : 	_Myt& erase(size_type _Off = 0)
; 1309 : 		{	// erase elements [_Off, ...)
; 1310 : 		if (this->_Mysize < _Off)
; 1311 : 			_Xran();	// _Off off end
; 1312 : 		_Eos(_Off);
; 1313 : 		return (*this);
; 1314 : 		}
; 1315 : 
; 1316 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1317 : 		{	// erase elements [_Off, _Off + _Count)
; 1318 : 		if (this->_Mysize < _Off)
; 1319 : 			_Xran();	// _Off off end
; 1320 : 		if (this->_Mysize - _Off <= _Count)
; 1321 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1322 : 		else if (0 < _Count)
; 1323 : 			{	// move elements down
; 1324 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1325 : 			size_type _Newsize = this->_Mysize - _Count;
; 1326 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1327 : 			_Eos(_Newsize);
; 1328 : 			}
; 1329 : 		return (*this);
; 1330 : 		}
; 1331 : 
; 1332 : 	iterator erase(const_iterator _Where)
; 1333 : 		{	// erase element at _Where
; 1334 : 		size_type _Count = _Pdif(_Where, begin());
; 1335 : 		erase(_Count, 1);
; 1336 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1337 : 		}
; 1338 : 
; 1339 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1340 : 		{	// erase substring [_First, _Last)
; 1341 : 		_DEBUG_RANGE(_First, _Last);
; 1342 : 		size_type _Count = _Pdif(_First, begin());
; 1343 : 		erase(_Count, _Pdif(_Last, _First));
; 1344 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1345 : 		}
; 1346 : 
; 1347 : 	void clear() _NOEXCEPT
; 1348 : 		{	// erase all
; 1349 : 		_Eos(0);
; 1350 : 		}
; 1351 : 
; 1352 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1353 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1354 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1355 : 		}
; 1356 : 
; 1357 : 	_Myt& replace(size_type _Off,
; 1358 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1359 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1360 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1361 : 			_Xran();	// _Off or _Roff off end
; 1362 : 		if (this->_Mysize - _Off < _N0)
; 1363 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1364 : 		size_type _Num = _Right.size() - _Roff;
; 1365 : 		if (_Num < _Count)
; 1366 : 			_Count = _Num;	// trim _Count to size
; 1367 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1368 : 			_Xlen();	// result too long
; 1369 : 
; 1370 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1371 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1372 : 		if (this->_Mysize < _Newsize)
; 1373 : 			_Grow(_Newsize);
; 1374 : 
; 1375 : 		if (this != &_Right)
; 1376 : 			{	// no overlap, just move down and copy in new stuff
; 1377 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1378 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1379 : 			_Traits::copy(this->_Myptr() + _Off,
; 1380 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1381 : 			}
; 1382 : 		else if (_Count <= _N0)
; 1383 : 			{	// hole doesn't get larger, just copy in substring
; 1384 : 			_Traits::move(this->_Myptr() + _Off,
; 1385 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1386 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1387 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1388 : 			}
; 1389 : 		else if (_Roff <= _Off)
; 1390 : 			{	// hole gets larger, substring begins before hole
; 1391 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1392 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1393 : 			_Traits::move(this->_Myptr() + _Off,
; 1394 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1395 : 			}
; 1396 : 		else if (_Off + _N0 <= _Roff)
; 1397 : 			{	// hole gets larger, substring begins after hole
; 1398 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1399 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1400 : 			_Traits::move(this->_Myptr() + _Off,
; 1401 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1402 : 				_Count);	// fill hole
; 1403 : 			}
; 1404 : 		else
; 1405 : 			{	// hole gets larger, substring begins in hole
; 1406 : 			_Traits::move(this->_Myptr() + _Off,
; 1407 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1408 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1409 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1410 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1411 : 				this->_Myptr() + _Roff + _Count,
; 1412 : 				_Count - _N0);	// fill rest of new hole
; 1413 : 			}
; 1414 : 
; 1415 : 		_Eos(_Newsize);
; 1416 : 		return (*this);
; 1417 : 		}
; 1418 : 
; 1419 : 	_Myt& replace(size_type _Off,
; 1420 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1421 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1422 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1423 : 		if (_Count != 0)
; 1424 : 			_DEBUG_POINTER(_Ptr);
; 1425 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1426 : 
; 1427 : 		if (_Inside(_Ptr))
; 1428 : 			return (replace(_Off, _N0, *this,
; 1429 : 				_Ptr - this->_Myptr(),
; 1430 : 				_Count));	// substring, replace carefully
; 1431 : 		if (this->_Mysize < _Off)
; 1432 : 			_Xran();	// _Off off end
; 1433 : 		if (this->_Mysize - _Off < _N0)
; 1434 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1435 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1436 : 			_Xlen();	// result too long
; 1437 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1438 : 
; 1439 : 		if (_Count < _N0)
; 1440 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1441 : 				this->_Myptr() + _Off + _N0,
; 1442 : 				_Nm);	// smaller hole, move tail up
; 1443 : 		size_type _Num;
; 1444 : 		if ((0 < _Count || 0 < _N0)
; 1445 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1446 : 			{	// make room and rearrange
; 1447 : 			if (_N0 < _Count)
; 1448 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1449 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1450 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1451 : 			_Eos(_Num);
; 1452 : 			}
; 1453 : 		return (*this);
; 1454 : 		}
; 1455 : 
; 1456 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1457 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1458 : 		_DEBUG_POINTER(_Ptr);
; 1459 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1460 : 		}
; 1461 : 
; 1462 : 	_Myt& replace(size_type _Off,
; 1463 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1464 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1465 : 		if (this->_Mysize < _Off)
; 1466 : 			_Xran();	// _Off off end
; 1467 : 		if (this->_Mysize - _Off < _N0)
; 1468 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1469 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1470 : 			_Xlen();	// result too long
; 1471 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1472 : 
; 1473 : 		if (_Count < _N0)
; 1474 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1475 : 				this->_Myptr() + _Off + _N0,
; 1476 : 				_Nm);	// smaller hole, move tail up
; 1477 : 		size_type _Num;
; 1478 : 		if ((0 < _Count || 0 < _N0)
; 1479 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1480 : 			{	// make room and rearrange
; 1481 : 			if (_N0 < _Count)
; 1482 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1483 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1484 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1485 : 			_Eos(_Num);
; 1486 : 			}
; 1487 : 		return (*this);
; 1488 : 		}
; 1489 : 
; 1490 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1491 : 		const _Myt& _Right)
; 1492 : 		{	// replace [_First, _Last) with _Right
; 1493 : 		return (replace(
; 1494 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1495 : 		}
; 1496 : 
; 1497 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1498 : 		const _Elem *_Ptr, size_type _Count)
; 1499 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1500 : 		return (replace(
; 1501 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1502 : 		}
; 1503 : 
; 1504 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1505 : 		const _Elem *_Ptr)
; 1506 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1507 : 		return (replace(
; 1508 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1509 : 		}
; 1510 : 
; 1511 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1512 : 		size_type _Count, _Elem _Ch)
; 1513 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1514 : 		return (replace(
; 1515 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1516 : 		}
; 1517 : 
; 1518 : 	template<class _Iter>
; 1519 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1520 : 			_Myt&>::type
; 1521 : 		replace(const_iterator _First, const_iterator _Last,
; 1522 : 			_Iter _First2, _Iter _Last2)
; 1523 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1524 : 		_Myt _Right(_First2, _Last2);
; 1525 : 		replace(_First, _Last, _Right);
; 1526 : 		return (*this);
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const_pointer _First2, const_pointer _Last2)
; 1531 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1532 : 		if (_First2 == _Last2)
; 1533 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1534 : 		else
; 1535 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1536 : 				&*_First2, _Last2 - _First2);
; 1537 : 		return (*this);
; 1538 : 		}
; 1539 : 
; 1540 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1541 : 		pointer _First2, pointer _Last2)
; 1542 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1543 : 		if (_First2 == _Last2)
; 1544 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1545 : 		else
; 1546 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1547 : 				&*_First2, _Last2 - _First2);
; 1548 : 		return (*this);
; 1549 : 		}
; 1550 : 
; 1551 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1552 : 		const_iterator _First2, const_iterator _Last2)
; 1553 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1554 : 		if (_First2 == _Last2)
; 1555 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1556 : 		else
; 1557 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1558 : 				&*_First2, _Last2 - _First2);
; 1559 : 		return (*this);
; 1560 : 		}
; 1561 : 
; 1562 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1563 : 		iterator _First2, iterator _Last2)
; 1564 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1565 : 		if (_First2 == _Last2)
; 1566 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1567 : 		else
; 1568 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1569 : 				&*_First2, _Last2 - _First2);
; 1570 : 		return (*this);
; 1571 : 		}
; 1572 : 
; 1573 : 	iterator begin() _NOEXCEPT
; 1574 : 		{	// return iterator for beginning of mutable sequence
; 1575 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1576 : 		}
; 1577 : 
; 1578 : 	const_iterator begin() const _NOEXCEPT
; 1579 : 		{	// return iterator for beginning of nonmutable sequence
; 1580 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1581 : 		}
; 1582 : 
; 1583 : 	iterator end() _NOEXCEPT
; 1584 : 		{	// return iterator for end of mutable sequence
; 1585 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1586 : 		}
; 1587 : 
; 1588 : 	const_iterator end() const _NOEXCEPT
; 1589 : 		{	// return iterator for end of nonmutable sequence
; 1590 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1591 : 		}
; 1592 : 
; 1593 : 	reverse_iterator rbegin() _NOEXCEPT
; 1594 : 		{	// return iterator for beginning of reversed mutable sequence
; 1595 : 		return (reverse_iterator(end()));
; 1596 : 		}
; 1597 : 
; 1598 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1600 : 		return (const_reverse_iterator(end()));
; 1601 : 		}
; 1602 : 
; 1603 : 	reverse_iterator rend() _NOEXCEPT
; 1604 : 		{	// return iterator for end of reversed mutable sequence
; 1605 : 		return (reverse_iterator(begin()));
; 1606 : 		}
; 1607 : 
; 1608 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1609 : 		{	// return iterator for end of reversed nonmutable sequence
; 1610 : 		return (const_reverse_iterator(begin()));
; 1611 : 		}
; 1612 : 
; 1613 :  #if _HAS_CPP0X
; 1614 : 	const_iterator cbegin() const _NOEXCEPT
; 1615 : 		{	// return iterator for beginning of nonmutable sequence
; 1616 : 		return (((const _Myt *)this)->begin());
; 1617 : 		}
; 1618 : 
; 1619 : 	const_iterator cend() const _NOEXCEPT
; 1620 : 		{	// return iterator for end of nonmutable sequence
; 1621 : 		return (((const _Myt *)this)->end());
; 1622 : 		}
; 1623 : 
; 1624 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1625 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1626 : 		return (((const _Myt *)this)->rbegin());
; 1627 : 		}
; 1628 : 
; 1629 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1630 : 		{	// return iterator for end of reversed nonmutable sequence
; 1631 : 		return (((const _Myt *)this)->rend());
; 1632 : 		}
; 1633 : 
; 1634 : 	void shrink_to_fit()
; 1635 : 		{	// reduce capacity
; 1636 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1637 : 			{	// worth shrinking, do it
; 1638 : 			_Myt _Tmp(*this);
; 1639 : 			swap(_Tmp);
; 1640 : 			}
; 1641 : 		}
; 1642 :  #endif /* _HAS_CPP0X */
; 1643 : 
; 1644 : 	reference at(size_type _Off)
; 1645 : 		{	// subscript mutable sequence with checking
; 1646 : 		if (this->_Mysize <= _Off)
; 1647 : 			_Xran();	// _Off off end
; 1648 : 		return (this->_Myptr()[_Off]);
; 1649 : 		}
; 1650 : 
; 1651 : 	const_reference at(size_type _Off) const
; 1652 : 		{	// subscript nonmutable sequence with checking
; 1653 : 		if (this->_Mysize <= _Off)
; 1654 : 			_Xran();	// _Off off end
; 1655 : 		return (this->_Myptr()[_Off]);
; 1656 : 		}
; 1657 : 
; 1658 : 	reference operator[](size_type _Off)
; 1659 : 		{	// subscript mutable sequence
; 1660 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1661 : 		if (this->_Mysize < _Off)	// sic
; 1662 : 			_DEBUG_ERROR("string subscript out of range");
; 1663 : 
; 1664 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1665 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1666 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1667 : 
; 1668 : 		return (this->_Myptr()[_Off]);
; 1669 : 		}
; 1670 : 
; 1671 : 	const_reference operator[](size_type _Off) const
; 1672 : 		{	// subscript nonmutable sequence
; 1673 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1674 : 		if (this->_Mysize < _Off)	// sic
; 1675 : 			_DEBUG_ERROR("string subscript out of range");
; 1676 : 
; 1677 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1678 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1679 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1680 : 
; 1681 : 		return (this->_Myptr()[_Off]);
; 1682 : 		}
; 1683 : 
; 1684 : 	void push_back(_Elem _Ch)
; 1685 : 		{	// insert element at end
; 1686 : 		insert(end(), _Ch);
; 1687 : 		}
; 1688 : 
; 1689 :  #if _HAS_CPP0X
; 1690 : 	void pop_back()
; 1691 : 		{	// erase element at end
; 1692 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1693 : 		}
; 1694 : 
; 1695 : 	reference front()
; 1696 : 		{	// return first element of mutable sequence
; 1697 : 		return (*begin());
; 1698 : 		}
; 1699 : 
; 1700 : 	const_reference front() const
; 1701 : 		{	// return first element of nonmutable sequence
; 1702 : 		return (*begin());
; 1703 : 		}
; 1704 : 
; 1705 : 	reference back()
; 1706 : 		{	// return last element of mutable sequence
; 1707 : 		return (*(end() - 1));
; 1708 : 		}
; 1709 : 
; 1710 : 	const_reference back() const
; 1711 : 		{	// return last element of nonmutable sequence
; 1712 : 		return (*(end() - 1));
; 1713 : 		}
; 1714 :  #endif /* _HAS_CPP0X */
; 1715 : 
; 1716 : 	const _Elem *c_str() const _NOEXCEPT
; 1717 : 		{	// return pointer to null-terminated nonmutable array
; 1718 : 		return (this->_Myptr());
; 1719 : 		}
; 1720 : 
; 1721 : 	const _Elem *data() const _NOEXCEPT
; 1722 : 		{	// return pointer to nonmutable array
; 1723 : 		return (c_str());
; 1724 : 		}
; 1725 : 
; 1726 : 	size_type length() const _NOEXCEPT
; 1727 : 		{	// return length of sequence
; 1728 : 		return (this->_Mysize);
; 1729 : 		}
; 1730 : 
; 1731 : 	size_type size() const _NOEXCEPT
; 1732 : 		{	// return length of sequence
; 1733 : 		return (this->_Mysize);
; 1734 : 		}
; 1735 : 
; 1736 : 	size_type max_size() const _NOEXCEPT
; 1737 : 		{	// return maximum possible length of sequence
; 1738 : 		size_type _Num = this->_Getal().max_size();
; 1739 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1740 : 		}
; 1741 : 
; 1742 : 	void resize(size_type _Newsize)
; 1743 : 		{	// determine new length, padding with null elements as needed
; 1744 : 		resize(_Newsize, _Elem());
; 1745 : 		}
; 1746 : 
; 1747 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1748 : 		{	// determine new length, padding with _Ch elements as needed
; 1749 : 		if (_Newsize <= this->_Mysize)
; 1750 : 			_Eos(_Newsize);
; 1751 : 		else
; 1752 : 			append(_Newsize - this->_Mysize, _Ch);
; 1753 : 		}
; 1754 : 
; 1755 : 	size_type capacity() const _NOEXCEPT
; 1756 : 		{	// return current length of allocated storage
; 1757 : 		return (this->_Myres);
; 1758 : 		}
; 1759 : 
; 1760 : 	void reserve(size_type _Newcap = 0)
; 1761 : 		{	// determine new minimum length of allocated storage
; 1762 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1763 : 			{	// change reservation
; 1764 : 			size_type _Size = this->_Mysize;
; 1765 : 			if (_Grow(_Newcap, true))
; 1766 : 				_Eos(_Size);
; 1767 : 			}
; 1768 : 		}
; 1769 : 
; 1770 : 	bool empty() const _NOEXCEPT
; 1771 : 		{	// test if sequence is empty
; 1772 : 		return (this->_Mysize == 0);
; 1773 : 		}
; 1774 : 
; 1775 : 	_SCL_INSECURE_DEPRECATE
; 1776 : 
; 1777 : 	size_type copy(_Elem *_Ptr,
; 1778 : 		size_type _Count, size_type _Off = 0) const
; 1779 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1780 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1781 : 		if (_Count != 0)
; 1782 : 			_DEBUG_POINTER(_Ptr);
; 1783 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1784 : 
; 1785 : 		if (this->_Mysize < _Off)
; 1786 : 			_Xran();	// _Off off end
; 1787 : 		if (this->_Mysize - _Off < _Count)
; 1788 : 			_Count = this->_Mysize - _Off;
; 1789 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1790 : 		return (_Count);
; 1791 : 		}
; 1792 : 
; 1793 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1794 : 		size_type _Count, size_type _Off = 0) const
; 1795 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1796 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1797 : 		if (_Count != 0)
; 1798 : 			_DEBUG_POINTER(_Dest);
; 1799 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1800 : 
; 1801 : 		if (this->_Mysize < _Off)
; 1802 : 			_Xran();	// _Off off end
; 1803 : 		if (this->_Mysize - _Off < _Count)
; 1804 : 			_Count = this->_Mysize - _Off;
; 1805 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1806 : 		return (_Count);
; 1807 : 		}
; 1808 : 
; 1809 : 	void _Swap_bx(_Myt& _Right)
; 1810 : 		{	// exchange _Bx with _Right._Bx
; 1811 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1812 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1813 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1814 : 			else
; 1815 : 				{	// swap large with small
; 1816 : 				pointer _Ptr = this->_Bx._Ptr;
; 1817 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1818 : 				_Traits::copy(this->_Bx._Buf,
; 1819 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1820 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1821 : 				}
; 1822 : 		else
; 1823 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1824 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1825 : 			else
; 1826 : 				{	// swap small with large
; 1827 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1828 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1829 : 				_Traits::copy(_Right._Bx._Buf,
; 1830 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1831 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1832 : 				}
; 1833 : 		}
; 1834 : 
; 1835 : 	void swap(_Myt& _Right)
; 1836 : 		{	// exchange contents with _Right
; 1837 : 		if (this == &_Right)
; 1838 : 			;	// same object, do nothing
; 1839 : 		else if (this->_Getal() == _Right._Getal())
; 1840 : 			{	// same allocator, swap control information
; 1841 : 			this->_Swap_all(_Right);
; 1842 : 			_Swap_bx(_Right);
; 1843 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1844 : 			_STD swap(this->_Myres, _Right._Myres);
; 1845 : 			}
; 1846 : 
; 1847 :  #if _HAS_CPP0X
; 1848 : 		else if (_Alty::propagate_on_container_swap::value)
; 1849 : 			{	// swap allocators and control information
; 1850 : 			this->_Swap_alloc(_Right);
; 1851 : 			_Swap_bx(_Right);
; 1852 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1853 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1854 : 			_STD swap(this->_Myres, _Right._Myres);
; 1855 : 			}
; 1856 :  #endif /* _HAS_CPP0X */
; 1857 : 
; 1858 : 		else
; 1859 : 			{	// different allocator, do multiple assigns
; 1860 : 			_Myt _Tmp = *this;
; 1861 : 
; 1862 : 			*this = _Right;
; 1863 : 			_Right = _Tmp;
; 1864 : 			}
; 1865 : 		}
; 1866 : 
; 1867 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1868 : 		{	// look for _Right beginning at or after _Off
; 1869 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1870 : 		}
; 1871 : 
; 1872 : 	size_type find(const _Elem *_Ptr,
; 1873 : 		size_type _Off, size_type _Count) const
; 1874 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1875 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1876 : 		if (_Count != 0)
; 1877 : 			_DEBUG_POINTER(_Ptr);
; 1878 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1879 : 
; 1880 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1881 : 			return (_Off);	// null string always matches (if inside string)
; 1882 : 
; 1883 : 		size_type _Nm;
; 1884 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1885 : 			{	// room for match, look for it
; 1886 : 			const _Elem *_Uptr, *_Vptr;
; 1887 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1888 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1889 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1890 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1891 : 					return (_Uptr - this->_Myptr());	// found a match
; 1892 : 			}
; 1893 : 
; 1894 : 		return (npos);	// no match
; 1895 : 		}
; 1896 : 
; 1897 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1898 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1899 : 		_DEBUG_POINTER(_Ptr);
; 1900 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1901 : 		}
; 1902 : 
; 1903 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1904 : 		{	// look for _Ch at or after _Off
; 1905 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1906 : 		}
; 1907 : 
; 1908 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1909 : 		{	// look for _Right beginning before _Off
; 1910 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1911 : 		}
; 1912 : 
; 1913 : 	size_type rfind(const _Elem *_Ptr,
; 1914 : 		size_type _Off, size_type _Count) const
; 1915 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1916 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1917 : 		if (_Count != 0)
; 1918 : 			_DEBUG_POINTER(_Ptr);
; 1919 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1920 : 
; 1921 : 		if (_Count == 0)
; 1922 : 			return (_Off < this->_Mysize ? _Off
; 1923 : 				: this->_Mysize);	// null always matches
; 1924 : 		if (_Count <= this->_Mysize)
; 1925 : 			{	// room for match, look for it
; 1926 : 			const _Elem *_Uptr = this->_Myptr() +
; 1927 : 				(_Off < this->_Mysize - _Count ? _Off
; 1928 : 					: this->_Mysize - _Count);
; 1929 : 			for (; ; --_Uptr)
; 1930 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1931 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1932 : 					return (_Uptr - this->_Myptr());	// found a match
; 1933 : 				else if (_Uptr == this->_Myptr())
; 1934 : 					break;	// at beginning, no more chance for match
; 1935 : 			}
; 1936 : 
; 1937 : 		return (npos);	// no match
; 1938 : 		}
; 1939 : 
; 1940 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1941 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1942 : 		_DEBUG_POINTER(_Ptr);
; 1943 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1944 : 		}
; 1945 : 
; 1946 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1947 : 		{	// look for _Ch before _Off
; 1948 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1949 : 		}
; 1950 : 
; 1951 : 	size_type find_first_of(const _Myt& _Right,
; 1952 : 		size_type _Off = 0) const _NOEXCEPT
; 1953 : 		{	// look for one of _Right at or after _Off
; 1954 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1955 : 		}
; 1956 : 
; 1957 : 	size_type find_first_of(const _Elem *_Ptr,
; 1958 : 		size_type _Off, size_type _Count) const
; 1959 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1960 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1961 : 		if (_Count != 0)
; 1962 : 			_DEBUG_POINTER(_Ptr);
; 1963 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1964 : 
; 1965 : 		if (0 < _Count && _Off < this->_Mysize)
; 1966 : 			{	// room for match, look for it
; 1967 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1968 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1969 : 				_Uptr < _Vptr; ++_Uptr)
; 1970 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1971 : 					return (_Uptr - this->_Myptr());	// found a match
; 1972 : 			}
; 1973 : 
; 1974 : 		return (npos);	// no match
; 1975 : 		}
; 1976 : 
; 1977 : 	size_type find_first_of(const _Elem *_Ptr,
; 1978 : 		size_type _Off = 0) const
; 1979 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1980 : 		_DEBUG_POINTER(_Ptr);
; 1981 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 1982 : 		}
; 1983 : 
; 1984 : 	size_type find_first_of(_Elem _Ch,
; 1985 : 		size_type _Off = 0) const
; 1986 : 		{	// look for _Ch at or after _Off
; 1987 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1988 : 		}
; 1989 : 
; 1990 : 	size_type find_last_of(const _Myt& _Right,
; 1991 : 		size_type _Off = npos) const _NOEXCEPT
; 1992 : 		{	// look for one of _Right before _Off
; 1993 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_last_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off, size_type _Count) const
; 1998 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 1999 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2000 : 		if (_Count != 0)
; 2001 : 			_DEBUG_POINTER(_Ptr);
; 2002 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2003 : 
; 2004 : 		if (0 < _Count && 0 < this->_Mysize)
; 2005 : 			{	// worth searching, do it
; 2006 : 			const _Elem *_Uptr = this->_Myptr()
; 2007 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2008 : 			for (; ; --_Uptr)
; 2009 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2010 : 					return (_Uptr - this->_Myptr());	// found a match
; 2011 : 				else if (_Uptr == this->_Myptr())
; 2012 : 					break;	// at beginning, no more chance for match
; 2013 : 			}
; 2014 : 
; 2015 : 		return (npos);	// no match
; 2016 : 		}
; 2017 : 
; 2018 : 	size_type find_last_of(const _Elem *_Ptr,
; 2019 : 		size_type _Off = npos) const
; 2020 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2021 : 		_DEBUG_POINTER(_Ptr);
; 2022 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2023 : 		}
; 2024 : 
; 2025 : 	size_type find_last_of(_Elem _Ch,
; 2026 : 		size_type _Off = npos) const
; 2027 : 		{	// look for _Ch before _Off
; 2028 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2029 : 		}
; 2030 : 
; 2031 : 	size_type find_first_not_of(const _Myt& _Right,
; 2032 : 		size_type _Off = 0) const _NOEXCEPT
; 2033 : 		{	// look for none of _Right at or after _Off
; 2034 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2035 : 			_Right.size()));
; 2036 : 		}
; 2037 : 
; 2038 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2039 : 		size_type _Off, size_type _Count) const
; 2040 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2041 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2042 : 		if (_Count != 0)
; 2043 : 			_DEBUG_POINTER(_Ptr);
; 2044 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2045 : 
; 2046 : 		if (_Off < this->_Mysize)
; 2047 : 			{	// room for match, look for it
; 2048 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2049 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2050 : 				_Uptr < _Vptr; ++_Uptr)
; 2051 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2052 : 					return (_Uptr - this->_Myptr());
; 2053 : 			}
; 2054 : 		return (npos);
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off = 0) const
; 2059 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2060 : 		_DEBUG_POINTER(_Ptr);
; 2061 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2062 : 		}
; 2063 : 
; 2064 : 	size_type find_first_not_of(_Elem _Ch,
; 2065 : 		size_type _Off = 0) const
; 2066 : 		{	// look for non _Ch at or after _Off
; 2067 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2068 : 		}
; 2069 : 
; 2070 : 	size_type find_last_not_of(const _Myt& _Right,
; 2071 : 		size_type _Off = npos) const _NOEXCEPT
; 2072 : 		{	// look for none of _Right before _Off
; 2073 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off, size_type _Count) const
; 2078 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2079 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2080 : 		if (_Count != 0)
; 2081 : 			_DEBUG_POINTER(_Ptr);
; 2082 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2083 : 
; 2084 : 		if (0 < this->_Mysize)
; 2085 : 			{	// worth searching, do it
; 2086 : 			const _Elem *_Uptr = this->_Myptr()
; 2087 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2088 : 			for (; ; --_Uptr)
; 2089 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2090 : 					return (_Uptr - this->_Myptr());
; 2091 : 				else if (_Uptr == this->_Myptr())
; 2092 : 					break;
; 2093 : 			}
; 2094 : 		return (npos);
; 2095 : 		}
; 2096 : 
; 2097 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2098 : 		size_type _Off = npos) const
; 2099 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2100 : 		_DEBUG_POINTER(_Ptr);
; 2101 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2102 : 		}
; 2103 : 
; 2104 : 	size_type find_last_not_of(_Elem _Ch,
; 2105 : 		size_type _Off = npos) const
; 2106 : 		{	// look for non _Ch before _Off
; 2107 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2108 : 		}
; 2109 : 
; 2110 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2111 : 		{	// return [_Off, _Off + _Count) as new string
; 2112 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2113 : 		}
; 2114 : 
; 2115 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2116 : 		{	// compare [0, _Mysize) with _Right
; 2117 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2118 : 		}
; 2119 : 
; 2120 : 	int compare(size_type _Off, size_type _N0,
; 2121 : 		const _Myt& _Right) const
; 2122 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2123 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2124 : 		}
; 2125 : 
; 2126 : 	int compare(size_type _Off,
; 2127 : 		size_type _N0, const _Myt& _Right,
; 2128 : 		size_type _Roff, size_type _Count) const
; 2129 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2130 : 		if (_Right.size() < _Roff)
; 2131 : 			_Xran();	// _Off off end
; 2132 : 		if (_Right._Mysize - _Roff < _Count)
; 2133 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2134 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2135 : 		}
; 2136 : 
; 2137 : 	int compare(const _Elem *_Ptr) const
; 2138 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2139 : 		_DEBUG_POINTER(_Ptr);
; 2140 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2141 : 		}
; 2142 : 
; 2143 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2144 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2145 : 		_DEBUG_POINTER(_Ptr);
; 2146 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2147 : 		}
; 2148 : 
; 2149 : 	int compare(size_type _Off,
; 2150 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2151 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2152 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2153 : 		if (_Count != 0)
; 2154 : 			_DEBUG_POINTER(_Ptr);
; 2155 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2156 : 
; 2157 : 		if (this->_Mysize < _Off)
; 2158 : 			_Xran();	// _Off off end
; 2159 : 		if (this->_Mysize - _Off < _N0)
; 2160 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2161 : 
; 2162 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2163 : 			_N0 < _Count ? _N0 : _Count);
; 2164 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2165 : 			: _N0 == _Count ? 0 : +1);
; 2166 : 		}
; 2167 : 
; 2168 : 	allocator_type get_allocator() const _NOEXCEPT
; 2169 : 		{	// return allocator object for values
; 2170 : 		return (this->_Getal());
; 2171 : 		}
; 2172 : 
; 2173 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2174 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2175 : 		if (_Count == 1)
; 2176 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2177 : 		else
; 2178 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2179 : 		}
; 2180 : 
; 2181 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2182 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2183 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2184 : 		if (max_size() < _Newres)
; 2185 : 			_Newres = _Newsize;	// undo roundup if too big
; 2186 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2187 : 			;
; 2188 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2189 : 			_Newres = this->_Myres
; 2190 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2191 : 		else
; 2192 : 			_Newres = max_size();	// settle for max_size()
; 2193 : 
; 2194 : 		_Elem *_Ptr;
; 2195 : 		_TRY_BEGIN
; 2196 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2197 : 		_CATCH_ALL
; 2198 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2199 : 			_TRY_BEGIN
; 2200 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2201 : 			_CATCH_ALL
; 2202 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2203 : 			_RERAISE;
; 2204 : 			_CATCH_END
; 2205 : 		_CATCH_END
; 2206 : 
; 2207 : 		if (0 < _Oldlen)
; 2208 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2209 : 				_Oldlen);	// copy existing elements
; 2210 : 		_Tidy(true);
; 2211 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2212 : 		this->_Myres = _Newres;
; 2213 : 		_Eos(_Oldlen);
; 2214 : 		}
; 2215 : 
; 2216 : 	void _Eos(size_type _Newsize)
; 2217 : 		{	// set new length and null terminator
; 2218 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  000a5	33 c0		 xor	 eax, eax
  000a7	48 89 43 10	 mov	 QWORD PTR [rbx+16], rax

; 517  : 			: this->_Bx._Buf);

  000ab	48 83 f9 08	 cmp	 rcx, 8
  000af	72 08		 jb	 SHORT $LN77@append
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstddef

; 88   : 		reinterpret_cast<const volatile char&>(_Val)))));

  000b1	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd

; 347  : 		_Left = _Right;

  000b4	66 89 01	 mov	 WORD PTR [rcx], ax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 2233 : 		return (0 < _Newsize);	// return true only if more work to do

  000b7	eb 3e		 jmp	 SHORT $LN109@append
$LN77@append:

; 517  : 			: this->_Bx._Buf);

  000b9	48 8b cb	 mov	 rcx, rbx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd

; 347  : 		_Left = _Right;

  000bc	66 89 03	 mov	 WORD PTR [rbx], ax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 2233 : 		return (0 < _Newsize);	// return true only if more work to do

  000bf	eb 36		 jmp	 SHORT $LN109@append
$LN91@append:

; 517  : 			: this->_Bx._Buf);

  000c1	48 8b cb	 mov	 rcx, rbx
$LN92@append:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd

; 313  : 			: (_Elem *)_CSTD wmemcpy(_First1, _First2, _Count));

  000c4	48 85 f6	 test	 rsi, rsi
  000c7	74 15		 je	 SHORT $LN98@append
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 1031 : 				_Right._Myptr() + _Roff, _Count);

  000c9	48 8b 43 10	 mov	 rax, QWORD PTR [rbx+16]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\wchar.h

; 1257 :             return (wchar_t *)memcpy(_S1, _S2, _N*sizeof(wchar_t));

  000cd	4c 8d 04 36	 lea	 r8, QWORD PTR [rsi+rsi]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 1031 : 				_Right._Myptr() + _Roff, _Count);

  000d1	49 8d 14 6e	 lea	 rdx, QWORD PTR [r14+rbp*2]
  000d5	48 8d 0c 41	 lea	 rcx, QWORD PTR [rcx+rax*2]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\wchar.h

; 1257 :             return (wchar_t *)memcpy(_S1, _S2, _N*sizeof(wchar_t));

  000d9	e8 00 00 00 00	 call	 memcpy
$LN98@append:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 517  : 			: this->_Bx._Buf);

  000de	48 83 7b 18 08	 cmp	 QWORD PTR [rbx+24], 8

; 1036 : 
; 1037 : 	_Myt& append(const _Elem *_Ptr, size_type _Count)
; 1038 : 		{	// append [_Ptr, _Ptr + _Count)
; 1039 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1040 : 		if (_Count != 0)
; 1041 : 			_DEBUG_POINTER(_Ptr);
; 1042 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1043 : 
; 1044 : 		if (_Inside(_Ptr))
; 1045 : 			return (append(*this,
; 1046 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1047 : 		if (npos - this->_Mysize <= _Count)
; 1048 : 			_Xlen();	// result too long
; 1049 : 
; 1050 : 		size_type _Num;
; 1051 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1052 : 			{	// make room and append new stuff
; 1053 : 			_Traits::copy(this->_Myptr() + this->_Mysize, _Ptr, _Count);
; 1054 : 			_Eos(_Num);
; 1055 : 			}
; 1056 : 		return (*this);
; 1057 : 		}
; 1058 : 
; 1059 : 	_Myt& append(const _Elem *_Ptr)
; 1060 : 		{	// append [_Ptr, <null>)
; 1061 : 		_DEBUG_POINTER(_Ptr);
; 1062 : 		return (append(_Ptr, _Traits::length(_Ptr)));
; 1063 : 		}
; 1064 : 
; 1065 : 	_Myt& append(size_type _Count, _Elem _Ch)
; 1066 : 		{	// append _Count * _Ch
; 1067 : 		if (npos - this->_Mysize <= _Count)
; 1068 : 			_Xlen();	// result too long
; 1069 : 
; 1070 : 		size_type _Num;
; 1071 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1072 : 			{	// make room and append new stuff using assign
; 1073 : 			_Chassign(this->_Mysize, _Count, _Ch);
; 1074 : 			_Eos(_Num);
; 1075 : 			}
; 1076 : 		return (*this);
; 1077 : 		}
; 1078 : 
; 1079 : 	template<class _Iter>
; 1080 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1081 : 			_Myt&>::type
; 1082 : 		append(_Iter _First, _Iter _Last)
; 1083 : 		{	// append [_First, _Last), input iterators
; 1084 : 		return (replace(end(), end(), _First, _Last));
; 1085 : 		}
; 1086 : 
; 1087 : 	_Myt& append(const_pointer _First, const_pointer _Last)
; 1088 : 		{	// append [_First, _Last), const pointers
; 1089 : 		return (replace(end(), end(), _First, _Last));
; 1090 : 		}
; 1091 : 
; 1092 : 	_Myt& append(const_iterator _First, const_iterator _Last)
; 1093 : 		{	// append [_First, _Last), const_iterators
; 1094 : 		return (replace(end(), end(), _First, _Last));
; 1095 : 		}
; 1096 : 
; 1097 : 	_Myt& assign(const _Myt& _Right)
; 1098 : 		{	// assign _Right
; 1099 : 		return (assign(_Right, 0, npos));
; 1100 : 		}
; 1101 : 
; 1102 : 	_Myt& assign(const _Myt& _Right,
; 1103 : 		size_type _Roff, size_type _Count)
; 1104 : 		{	// assign _Right [_Roff, _Roff + _Count)
; 1105 : 		if (_Right.size() < _Roff)
; 1106 : 			_Xran();	// _Roff off end
; 1107 : 		size_type _Num = _Right.size() - _Roff;
; 1108 : 		if (_Count < _Num)
; 1109 : 			_Num = _Count;	// trim _Num to size
; 1110 : 
; 1111 : 		if (this == &_Right)
; 1112 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring
; 1113 : 		else if (_Grow(_Num))
; 1114 : 			{	// make room and assign new stuff
; 1115 : 			_Traits::copy(this->_Myptr(),
; 1116 : 				_Right._Myptr() + _Roff, _Num);
; 1117 : 			_Eos(_Num);
; 1118 : 			}
; 1119 : 		return (*this);
; 1120 : 		}
; 1121 : 
; 1122 : 	_Myt& assign(const _Elem *_Ptr, size_type _Count)
; 1123 : 		{	// assign [_Ptr, _Ptr + _Count)
; 1124 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1125 : 		if (_Count != 0)
; 1126 : 			_DEBUG_POINTER(_Ptr);
; 1127 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1128 : 
; 1129 : 		if (_Inside(_Ptr))
; 1130 : 			return (assign(*this,
; 1131 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1132 : 
; 1133 : 		if (_Grow(_Count))
; 1134 : 			{	// make room and assign new stuff
; 1135 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);
; 1136 : 			_Eos(_Count);
; 1137 : 			}
; 1138 : 		return (*this);
; 1139 : 		}
; 1140 : 
; 1141 : 	_Myt& assign(const _Elem *_Ptr)
; 1142 : 		{	// assign [_Ptr, <null>)
; 1143 : 		_DEBUG_POINTER(_Ptr);
; 1144 : 		return (assign(_Ptr, _Traits::length(_Ptr)));
; 1145 : 		}
; 1146 : 
; 1147 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1148 : 		{	// assign _Count * _Ch
; 1149 : 		if (_Count == npos)
; 1150 : 			_Xlen();	// result too long
; 1151 : 
; 1152 : 		if (_Grow(_Count))
; 1153 : 			{	// make room and assign new stuff
; 1154 : 			_Chassign(0, _Count, _Ch);
; 1155 : 			_Eos(_Count);
; 1156 : 			}
; 1157 : 		return (*this);
; 1158 : 		}
; 1159 : 
; 1160 : 	template<class _Iter>
; 1161 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1162 : 			_Myt&>::type
; 1163 : 		assign(_Iter _First, _Iter _Last)
; 1164 : 		{	// assign [First, _Last), input iterators
; 1165 : 		return (replace(begin(), end(), _First, _Last));
; 1166 : 		}
; 1167 : 
; 1168 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1169 : 		{	// assign [First, _Last), const pointers
; 1170 : 		return (replace(begin(), end(), _First, _Last));
; 1171 : 		}
; 1172 : 
; 1173 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1174 : 		{	// assign [First, _Last), const_iterators
; 1175 : 		return (replace(begin(), end(), _First, _Last));
; 1176 : 		}
; 1177 : 
; 1178 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1179 : 		{	// insert _Right at _Off
; 1180 : 		return (insert(_Off, _Right, 0, npos));
; 1181 : 		}
; 1182 : 
; 1183 : 	_Myt& insert(size_type _Off,
; 1184 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1185 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1186 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1187 : 			_Xran();	// _Off or _Roff off end
; 1188 : 		size_type _Num = _Right.size() - _Roff;
; 1189 : 		if (_Num < _Count)
; 1190 : 			_Count = _Num;	// trim _Count to size
; 1191 : 		if (npos - this->_Mysize <= _Count)
; 1192 : 			_Xlen();	// result too long
; 1193 : 
; 1194 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1195 : 			{	// make room and insert new stuff
; 1196 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1197 : 				this->_Myptr() + _Off,
; 1198 : 				this->_Mysize - _Off);	// empty out hole
; 1199 : 			if (this == &_Right)
; 1200 : 				_Traits::move(this->_Myptr() + _Off,
; 1201 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1202 : 						_Count);	// substring
; 1203 : 			else
; 1204 : 				_Traits::copy(this->_Myptr() + _Off,
; 1205 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1206 : 			_Eos(_Num);
; 1207 : 			}
; 1208 : 		return (*this);
; 1209 : 		}
; 1210 : 
; 1211 : 	_Myt& insert(size_type _Off,
; 1212 : 		const _Elem *_Ptr, size_type _Count)
; 1213 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1214 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1215 : 		if (_Count != 0)
; 1216 : 			_DEBUG_POINTER(_Ptr);
; 1217 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1218 : 
; 1219 : 		if (_Inside(_Ptr))
; 1220 : 			return (insert(_Off, *this,
; 1221 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1222 : 		if (this->_Mysize < _Off)
; 1223 : 			_Xran();	// _Off off end
; 1224 : 		if (npos - this->_Mysize <= _Count)
; 1225 : 			_Xlen();	// result too long
; 1226 : 		size_type _Num;
; 1227 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1228 : 			{	// make room and insert new stuff
; 1229 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1230 : 				this->_Myptr() + _Off,
; 1231 : 				this->_Mysize - _Off);	// empty out hole
; 1232 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1233 : 			_Eos(_Num);
; 1234 : 			}
; 1235 : 		return (*this);
; 1236 : 		}
; 1237 : 
; 1238 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1239 : 		{	// insert [_Ptr, <null>) at _Off
; 1240 : 		_DEBUG_POINTER(_Ptr);
; 1241 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1242 : 		}
; 1243 : 
; 1244 : 	_Myt& insert(size_type _Off,
; 1245 : 		size_type _Count, _Elem _Ch)
; 1246 : 		{	// insert _Count * _Ch at _Off
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	iterator insert(const_iterator _Where)
; 1264 : 		{	// insert <null> at _Where
; 1265 : 		return (insert(_Where, _Elem()));
; 1266 : 		}
; 1267 : 
; 1268 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1269 : 		{	// insert _Ch at _Where
; 1270 : 		size_type _Off = _Pdif(_Where, begin());
; 1271 : 		insert(_Off, 1, _Ch);
; 1272 : 		return (begin() + _Off);
; 1273 : 		}
; 1274 : 
; 1275 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1276 : 		{	// insert _Count * _Elem at _Where
; 1277 : 		size_type _Off = _Pdif(_Where, begin());
; 1278 : 		insert(_Off, _Count, _Ch);
; 1279 : 		return (begin() + _Off);
; 1280 : 		}
; 1281 : 
; 1282 : 	template<class _Iter>
; 1283 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1284 : 			iterator>::type
; 1285 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1286 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1287 : 		size_type _Off = _Pdif(_Where, begin());
; 1288 : 		replace(_Where, _Where, _First, _Last);
; 1289 : 		return (begin() + _Off);
; 1290 : 		}
; 1291 : 
; 1292 : 	iterator insert(const_iterator _Where,
; 1293 : 		const_pointer _First, const_pointer _Last)
; 1294 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		replace(_Where, _Where, _First, _Last);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where,
; 1301 : 		const_iterator _First, const_iterator _Last)
; 1302 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1303 : 		size_type _Off = _Pdif(_Where, begin());
; 1304 : 		replace(_Where, _Where, _First, _Last);
; 1305 : 		return (begin() + _Off);
; 1306 : 		}
; 1307 : 
; 1308 : 	_Myt& erase(size_type _Off = 0)
; 1309 : 		{	// erase elements [_Off, ...)
; 1310 : 		if (this->_Mysize < _Off)
; 1311 : 			_Xran();	// _Off off end
; 1312 : 		_Eos(_Off);
; 1313 : 		return (*this);
; 1314 : 		}
; 1315 : 
; 1316 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1317 : 		{	// erase elements [_Off, _Off + _Count)
; 1318 : 		if (this->_Mysize < _Off)
; 1319 : 			_Xran();	// _Off off end
; 1320 : 		if (this->_Mysize - _Off <= _Count)
; 1321 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1322 : 		else if (0 < _Count)
; 1323 : 			{	// move elements down
; 1324 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1325 : 			size_type _Newsize = this->_Mysize - _Count;
; 1326 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1327 : 			_Eos(_Newsize);
; 1328 : 			}
; 1329 : 		return (*this);
; 1330 : 		}
; 1331 : 
; 1332 : 	iterator erase(const_iterator _Where)
; 1333 : 		{	// erase element at _Where
; 1334 : 		size_type _Count = _Pdif(_Where, begin());
; 1335 : 		erase(_Count, 1);
; 1336 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1337 : 		}
; 1338 : 
; 1339 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1340 : 		{	// erase substring [_First, _Last)
; 1341 : 		_DEBUG_RANGE(_First, _Last);
; 1342 : 		size_type _Count = _Pdif(_First, begin());
; 1343 : 		erase(_Count, _Pdif(_Last, _First));
; 1344 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1345 : 		}
; 1346 : 
; 1347 : 	void clear() _NOEXCEPT
; 1348 : 		{	// erase all
; 1349 : 		_Eos(0);
; 1350 : 		}
; 1351 : 
; 1352 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1353 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1354 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1355 : 		}
; 1356 : 
; 1357 : 	_Myt& replace(size_type _Off,
; 1358 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1359 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1360 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1361 : 			_Xran();	// _Off or _Roff off end
; 1362 : 		if (this->_Mysize - _Off < _N0)
; 1363 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1364 : 		size_type _Num = _Right.size() - _Roff;
; 1365 : 		if (_Num < _Count)
; 1366 : 			_Count = _Num;	// trim _Count to size
; 1367 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1368 : 			_Xlen();	// result too long
; 1369 : 
; 1370 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1371 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1372 : 		if (this->_Mysize < _Newsize)
; 1373 : 			_Grow(_Newsize);
; 1374 : 
; 1375 : 		if (this != &_Right)
; 1376 : 			{	// no overlap, just move down and copy in new stuff
; 1377 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1378 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1379 : 			_Traits::copy(this->_Myptr() + _Off,
; 1380 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1381 : 			}
; 1382 : 		else if (_Count <= _N0)
; 1383 : 			{	// hole doesn't get larger, just copy in substring
; 1384 : 			_Traits::move(this->_Myptr() + _Off,
; 1385 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1386 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1387 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1388 : 			}
; 1389 : 		else if (_Roff <= _Off)
; 1390 : 			{	// hole gets larger, substring begins before hole
; 1391 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1392 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1393 : 			_Traits::move(this->_Myptr() + _Off,
; 1394 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1395 : 			}
; 1396 : 		else if (_Off + _N0 <= _Roff)
; 1397 : 			{	// hole gets larger, substring begins after hole
; 1398 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1399 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1400 : 			_Traits::move(this->_Myptr() + _Off,
; 1401 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1402 : 				_Count);	// fill hole
; 1403 : 			}
; 1404 : 		else
; 1405 : 			{	// hole gets larger, substring begins in hole
; 1406 : 			_Traits::move(this->_Myptr() + _Off,
; 1407 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1408 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1409 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1410 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1411 : 				this->_Myptr() + _Roff + _Count,
; 1412 : 				_Count - _N0);	// fill rest of new hole
; 1413 : 			}
; 1414 : 
; 1415 : 		_Eos(_Newsize);
; 1416 : 		return (*this);
; 1417 : 		}
; 1418 : 
; 1419 : 	_Myt& replace(size_type _Off,
; 1420 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1421 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1422 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1423 : 		if (_Count != 0)
; 1424 : 			_DEBUG_POINTER(_Ptr);
; 1425 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1426 : 
; 1427 : 		if (_Inside(_Ptr))
; 1428 : 			return (replace(_Off, _N0, *this,
; 1429 : 				_Ptr - this->_Myptr(),
; 1430 : 				_Count));	// substring, replace carefully
; 1431 : 		if (this->_Mysize < _Off)
; 1432 : 			_Xran();	// _Off off end
; 1433 : 		if (this->_Mysize - _Off < _N0)
; 1434 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1435 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1436 : 			_Xlen();	// result too long
; 1437 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1438 : 
; 1439 : 		if (_Count < _N0)
; 1440 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1441 : 				this->_Myptr() + _Off + _N0,
; 1442 : 				_Nm);	// smaller hole, move tail up
; 1443 : 		size_type _Num;
; 1444 : 		if ((0 < _Count || 0 < _N0)
; 1445 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1446 : 			{	// make room and rearrange
; 1447 : 			if (_N0 < _Count)
; 1448 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1449 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1450 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1451 : 			_Eos(_Num);
; 1452 : 			}
; 1453 : 		return (*this);
; 1454 : 		}
; 1455 : 
; 1456 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1457 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1458 : 		_DEBUG_POINTER(_Ptr);
; 1459 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1460 : 		}
; 1461 : 
; 1462 : 	_Myt& replace(size_type _Off,
; 1463 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1464 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1465 : 		if (this->_Mysize < _Off)
; 1466 : 			_Xran();	// _Off off end
; 1467 : 		if (this->_Mysize - _Off < _N0)
; 1468 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1469 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1470 : 			_Xlen();	// result too long
; 1471 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1472 : 
; 1473 : 		if (_Count < _N0)
; 1474 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1475 : 				this->_Myptr() + _Off + _N0,
; 1476 : 				_Nm);	// smaller hole, move tail up
; 1477 : 		size_type _Num;
; 1478 : 		if ((0 < _Count || 0 < _N0)
; 1479 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1480 : 			{	// make room and rearrange
; 1481 : 			if (_N0 < _Count)
; 1482 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1483 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1484 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1485 : 			_Eos(_Num);
; 1486 : 			}
; 1487 : 		return (*this);
; 1488 : 		}
; 1489 : 
; 1490 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1491 : 		const _Myt& _Right)
; 1492 : 		{	// replace [_First, _Last) with _Right
; 1493 : 		return (replace(
; 1494 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1495 : 		}
; 1496 : 
; 1497 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1498 : 		const _Elem *_Ptr, size_type _Count)
; 1499 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1500 : 		return (replace(
; 1501 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1502 : 		}
; 1503 : 
; 1504 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1505 : 		const _Elem *_Ptr)
; 1506 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1507 : 		return (replace(
; 1508 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1509 : 		}
; 1510 : 
; 1511 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1512 : 		size_type _Count, _Elem _Ch)
; 1513 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1514 : 		return (replace(
; 1515 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1516 : 		}
; 1517 : 
; 1518 : 	template<class _Iter>
; 1519 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1520 : 			_Myt&>::type
; 1521 : 		replace(const_iterator _First, const_iterator _Last,
; 1522 : 			_Iter _First2, _Iter _Last2)
; 1523 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1524 : 		_Myt _Right(_First2, _Last2);
; 1525 : 		replace(_First, _Last, _Right);
; 1526 : 		return (*this);
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const_pointer _First2, const_pointer _Last2)
; 1531 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1532 : 		if (_First2 == _Last2)
; 1533 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1534 : 		else
; 1535 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1536 : 				&*_First2, _Last2 - _First2);
; 1537 : 		return (*this);
; 1538 : 		}
; 1539 : 
; 1540 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1541 : 		pointer _First2, pointer _Last2)
; 1542 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1543 : 		if (_First2 == _Last2)
; 1544 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1545 : 		else
; 1546 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1547 : 				&*_First2, _Last2 - _First2);
; 1548 : 		return (*this);
; 1549 : 		}
; 1550 : 
; 1551 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1552 : 		const_iterator _First2, const_iterator _Last2)
; 1553 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1554 : 		if (_First2 == _Last2)
; 1555 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1556 : 		else
; 1557 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1558 : 				&*_First2, _Last2 - _First2);
; 1559 : 		return (*this);
; 1560 : 		}
; 1561 : 
; 1562 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1563 : 		iterator _First2, iterator _Last2)
; 1564 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1565 : 		if (_First2 == _Last2)
; 1566 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1567 : 		else
; 1568 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1569 : 				&*_First2, _Last2 - _First2);
; 1570 : 		return (*this);
; 1571 : 		}
; 1572 : 
; 1573 : 	iterator begin() _NOEXCEPT
; 1574 : 		{	// return iterator for beginning of mutable sequence
; 1575 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1576 : 		}
; 1577 : 
; 1578 : 	const_iterator begin() const _NOEXCEPT
; 1579 : 		{	// return iterator for beginning of nonmutable sequence
; 1580 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1581 : 		}
; 1582 : 
; 1583 : 	iterator end() _NOEXCEPT
; 1584 : 		{	// return iterator for end of mutable sequence
; 1585 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1586 : 		}
; 1587 : 
; 1588 : 	const_iterator end() const _NOEXCEPT
; 1589 : 		{	// return iterator for end of nonmutable sequence
; 1590 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1591 : 		}
; 1592 : 
; 1593 : 	reverse_iterator rbegin() _NOEXCEPT
; 1594 : 		{	// return iterator for beginning of reversed mutable sequence
; 1595 : 		return (reverse_iterator(end()));
; 1596 : 		}
; 1597 : 
; 1598 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1600 : 		return (const_reverse_iterator(end()));
; 1601 : 		}
; 1602 : 
; 1603 : 	reverse_iterator rend() _NOEXCEPT
; 1604 : 		{	// return iterator for end of reversed mutable sequence
; 1605 : 		return (reverse_iterator(begin()));
; 1606 : 		}
; 1607 : 
; 1608 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1609 : 		{	// return iterator for end of reversed nonmutable sequence
; 1610 : 		return (const_reverse_iterator(begin()));
; 1611 : 		}
; 1612 : 
; 1613 :  #if _HAS_CPP0X
; 1614 : 	const_iterator cbegin() const _NOEXCEPT
; 1615 : 		{	// return iterator for beginning of nonmutable sequence
; 1616 : 		return (((const _Myt *)this)->begin());
; 1617 : 		}
; 1618 : 
; 1619 : 	const_iterator cend() const _NOEXCEPT
; 1620 : 		{	// return iterator for end of nonmutable sequence
; 1621 : 		return (((const _Myt *)this)->end());
; 1622 : 		}
; 1623 : 
; 1624 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1625 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1626 : 		return (((const _Myt *)this)->rbegin());
; 1627 : 		}
; 1628 : 
; 1629 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1630 : 		{	// return iterator for end of reversed nonmutable sequence
; 1631 : 		return (((const _Myt *)this)->rend());
; 1632 : 		}
; 1633 : 
; 1634 : 	void shrink_to_fit()
; 1635 : 		{	// reduce capacity
; 1636 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1637 : 			{	// worth shrinking, do it
; 1638 : 			_Myt _Tmp(*this);
; 1639 : 			swap(_Tmp);
; 1640 : 			}
; 1641 : 		}
; 1642 :  #endif /* _HAS_CPP0X */
; 1643 : 
; 1644 : 	reference at(size_type _Off)
; 1645 : 		{	// subscript mutable sequence with checking
; 1646 : 		if (this->_Mysize <= _Off)
; 1647 : 			_Xran();	// _Off off end
; 1648 : 		return (this->_Myptr()[_Off]);
; 1649 : 		}
; 1650 : 
; 1651 : 	const_reference at(size_type _Off) const
; 1652 : 		{	// subscript nonmutable sequence with checking
; 1653 : 		if (this->_Mysize <= _Off)
; 1654 : 			_Xran();	// _Off off end
; 1655 : 		return (this->_Myptr()[_Off]);
; 1656 : 		}
; 1657 : 
; 1658 : 	reference operator[](size_type _Off)
; 1659 : 		{	// subscript mutable sequence
; 1660 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1661 : 		if (this->_Mysize < _Off)	// sic
; 1662 : 			_DEBUG_ERROR("string subscript out of range");
; 1663 : 
; 1664 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1665 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1666 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1667 : 
; 1668 : 		return (this->_Myptr()[_Off]);
; 1669 : 		}
; 1670 : 
; 1671 : 	const_reference operator[](size_type _Off) const
; 1672 : 		{	// subscript nonmutable sequence
; 1673 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1674 : 		if (this->_Mysize < _Off)	// sic
; 1675 : 			_DEBUG_ERROR("string subscript out of range");
; 1676 : 
; 1677 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1678 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1679 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1680 : 
; 1681 : 		return (this->_Myptr()[_Off]);
; 1682 : 		}
; 1683 : 
; 1684 : 	void push_back(_Elem _Ch)
; 1685 : 		{	// insert element at end
; 1686 : 		insert(end(), _Ch);
; 1687 : 		}
; 1688 : 
; 1689 :  #if _HAS_CPP0X
; 1690 : 	void pop_back()
; 1691 : 		{	// erase element at end
; 1692 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1693 : 		}
; 1694 : 
; 1695 : 	reference front()
; 1696 : 		{	// return first element of mutable sequence
; 1697 : 		return (*begin());
; 1698 : 		}
; 1699 : 
; 1700 : 	const_reference front() const
; 1701 : 		{	// return first element of nonmutable sequence
; 1702 : 		return (*begin());
; 1703 : 		}
; 1704 : 
; 1705 : 	reference back()
; 1706 : 		{	// return last element of mutable sequence
; 1707 : 		return (*(end() - 1));
; 1708 : 		}
; 1709 : 
; 1710 : 	const_reference back() const
; 1711 : 		{	// return last element of nonmutable sequence
; 1712 : 		return (*(end() - 1));
; 1713 : 		}
; 1714 :  #endif /* _HAS_CPP0X */
; 1715 : 
; 1716 : 	const _Elem *c_str() const _NOEXCEPT
; 1717 : 		{	// return pointer to null-terminated nonmutable array
; 1718 : 		return (this->_Myptr());
; 1719 : 		}
; 1720 : 
; 1721 : 	const _Elem *data() const _NOEXCEPT
; 1722 : 		{	// return pointer to nonmutable array
; 1723 : 		return (c_str());
; 1724 : 		}
; 1725 : 
; 1726 : 	size_type length() const _NOEXCEPT
; 1727 : 		{	// return length of sequence
; 1728 : 		return (this->_Mysize);
; 1729 : 		}
; 1730 : 
; 1731 : 	size_type size() const _NOEXCEPT
; 1732 : 		{	// return length of sequence
; 1733 : 		return (this->_Mysize);
; 1734 : 		}
; 1735 : 
; 1736 : 	size_type max_size() const _NOEXCEPT
; 1737 : 		{	// return maximum possible length of sequence
; 1738 : 		size_type _Num = this->_Getal().max_size();
; 1739 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1740 : 		}
; 1741 : 
; 1742 : 	void resize(size_type _Newsize)
; 1743 : 		{	// determine new length, padding with null elements as needed
; 1744 : 		resize(_Newsize, _Elem());
; 1745 : 		}
; 1746 : 
; 1747 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1748 : 		{	// determine new length, padding with _Ch elements as needed
; 1749 : 		if (_Newsize <= this->_Mysize)
; 1750 : 			_Eos(_Newsize);
; 1751 : 		else
; 1752 : 			append(_Newsize - this->_Mysize, _Ch);
; 1753 : 		}
; 1754 : 
; 1755 : 	size_type capacity() const _NOEXCEPT
; 1756 : 		{	// return current length of allocated storage
; 1757 : 		return (this->_Myres);
; 1758 : 		}
; 1759 : 
; 1760 : 	void reserve(size_type _Newcap = 0)
; 1761 : 		{	// determine new minimum length of allocated storage
; 1762 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1763 : 			{	// change reservation
; 1764 : 			size_type _Size = this->_Mysize;
; 1765 : 			if (_Grow(_Newcap, true))
; 1766 : 				_Eos(_Size);
; 1767 : 			}
; 1768 : 		}
; 1769 : 
; 1770 : 	bool empty() const _NOEXCEPT
; 1771 : 		{	// test if sequence is empty
; 1772 : 		return (this->_Mysize == 0);
; 1773 : 		}
; 1774 : 
; 1775 : 	_SCL_INSECURE_DEPRECATE
; 1776 : 
; 1777 : 	size_type copy(_Elem *_Ptr,
; 1778 : 		size_type _Count, size_type _Off = 0) const
; 1779 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1780 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1781 : 		if (_Count != 0)
; 1782 : 			_DEBUG_POINTER(_Ptr);
; 1783 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1784 : 
; 1785 : 		if (this->_Mysize < _Off)
; 1786 : 			_Xran();	// _Off off end
; 1787 : 		if (this->_Mysize - _Off < _Count)
; 1788 : 			_Count = this->_Mysize - _Off;
; 1789 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1790 : 		return (_Count);
; 1791 : 		}
; 1792 : 
; 1793 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1794 : 		size_type _Count, size_type _Off = 0) const
; 1795 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1796 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1797 : 		if (_Count != 0)
; 1798 : 			_DEBUG_POINTER(_Dest);
; 1799 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1800 : 
; 1801 : 		if (this->_Mysize < _Off)
; 1802 : 			_Xran();	// _Off off end
; 1803 : 		if (this->_Mysize - _Off < _Count)
; 1804 : 			_Count = this->_Mysize - _Off;
; 1805 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1806 : 		return (_Count);
; 1807 : 		}
; 1808 : 
; 1809 : 	void _Swap_bx(_Myt& _Right)
; 1810 : 		{	// exchange _Bx with _Right._Bx
; 1811 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1812 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1813 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1814 : 			else
; 1815 : 				{	// swap large with small
; 1816 : 				pointer _Ptr = this->_Bx._Ptr;
; 1817 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1818 : 				_Traits::copy(this->_Bx._Buf,
; 1819 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1820 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1821 : 				}
; 1822 : 		else
; 1823 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1824 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1825 : 			else
; 1826 : 				{	// swap small with large
; 1827 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1828 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1829 : 				_Traits::copy(_Right._Bx._Buf,
; 1830 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1831 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1832 : 				}
; 1833 : 		}
; 1834 : 
; 1835 : 	void swap(_Myt& _Right)
; 1836 : 		{	// exchange contents with _Right
; 1837 : 		if (this == &_Right)
; 1838 : 			;	// same object, do nothing
; 1839 : 		else if (this->_Getal() == _Right._Getal())
; 1840 : 			{	// same allocator, swap control information
; 1841 : 			this->_Swap_all(_Right);
; 1842 : 			_Swap_bx(_Right);
; 1843 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1844 : 			_STD swap(this->_Myres, _Right._Myres);
; 1845 : 			}
; 1846 : 
; 1847 :  #if _HAS_CPP0X
; 1848 : 		else if (_Alty::propagate_on_container_swap::value)
; 1849 : 			{	// swap allocators and control information
; 1850 : 			this->_Swap_alloc(_Right);
; 1851 : 			_Swap_bx(_Right);
; 1852 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1853 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1854 : 			_STD swap(this->_Myres, _Right._Myres);
; 1855 : 			}
; 1856 :  #endif /* _HAS_CPP0X */
; 1857 : 
; 1858 : 		else
; 1859 : 			{	// different allocator, do multiple assigns
; 1860 : 			_Myt _Tmp = *this;
; 1861 : 
; 1862 : 			*this = _Right;
; 1863 : 			_Right = _Tmp;
; 1864 : 			}
; 1865 : 		}
; 1866 : 
; 1867 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1868 : 		{	// look for _Right beginning at or after _Off
; 1869 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1870 : 		}
; 1871 : 
; 1872 : 	size_type find(const _Elem *_Ptr,
; 1873 : 		size_type _Off, size_type _Count) const
; 1874 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1875 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1876 : 		if (_Count != 0)
; 1877 : 			_DEBUG_POINTER(_Ptr);
; 1878 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1879 : 
; 1880 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1881 : 			return (_Off);	// null string always matches (if inside string)
; 1882 : 
; 1883 : 		size_type _Nm;
; 1884 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1885 : 			{	// room for match, look for it
; 1886 : 			const _Elem *_Uptr, *_Vptr;
; 1887 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1888 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1889 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1890 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1891 : 					return (_Uptr - this->_Myptr());	// found a match
; 1892 : 			}
; 1893 : 
; 1894 : 		return (npos);	// no match
; 1895 : 		}
; 1896 : 
; 1897 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1898 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1899 : 		_DEBUG_POINTER(_Ptr);
; 1900 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1901 : 		}
; 1902 : 
; 1903 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1904 : 		{	// look for _Ch at or after _Off
; 1905 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1906 : 		}
; 1907 : 
; 1908 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1909 : 		{	// look for _Right beginning before _Off
; 1910 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1911 : 		}
; 1912 : 
; 1913 : 	size_type rfind(const _Elem *_Ptr,
; 1914 : 		size_type _Off, size_type _Count) const
; 1915 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1916 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1917 : 		if (_Count != 0)
; 1918 : 			_DEBUG_POINTER(_Ptr);
; 1919 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1920 : 
; 1921 : 		if (_Count == 0)
; 1922 : 			return (_Off < this->_Mysize ? _Off
; 1923 : 				: this->_Mysize);	// null always matches
; 1924 : 		if (_Count <= this->_Mysize)
; 1925 : 			{	// room for match, look for it
; 1926 : 			const _Elem *_Uptr = this->_Myptr() +
; 1927 : 				(_Off < this->_Mysize - _Count ? _Off
; 1928 : 					: this->_Mysize - _Count);
; 1929 : 			for (; ; --_Uptr)
; 1930 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1931 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1932 : 					return (_Uptr - this->_Myptr());	// found a match
; 1933 : 				else if (_Uptr == this->_Myptr())
; 1934 : 					break;	// at beginning, no more chance for match
; 1935 : 			}
; 1936 : 
; 1937 : 		return (npos);	// no match
; 1938 : 		}
; 1939 : 
; 1940 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1941 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1942 : 		_DEBUG_POINTER(_Ptr);
; 1943 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1944 : 		}
; 1945 : 
; 1946 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1947 : 		{	// look for _Ch before _Off
; 1948 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1949 : 		}
; 1950 : 
; 1951 : 	size_type find_first_of(const _Myt& _Right,
; 1952 : 		size_type _Off = 0) const _NOEXCEPT
; 1953 : 		{	// look for one of _Right at or after _Off
; 1954 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1955 : 		}
; 1956 : 
; 1957 : 	size_type find_first_of(const _Elem *_Ptr,
; 1958 : 		size_type _Off, size_type _Count) const
; 1959 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1960 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1961 : 		if (_Count != 0)
; 1962 : 			_DEBUG_POINTER(_Ptr);
; 1963 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1964 : 
; 1965 : 		if (0 < _Count && _Off < this->_Mysize)
; 1966 : 			{	// room for match, look for it
; 1967 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1968 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1969 : 				_Uptr < _Vptr; ++_Uptr)
; 1970 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1971 : 					return (_Uptr - this->_Myptr());	// found a match
; 1972 : 			}
; 1973 : 
; 1974 : 		return (npos);	// no match
; 1975 : 		}
; 1976 : 
; 1977 : 	size_type find_first_of(const _Elem *_Ptr,
; 1978 : 		size_type _Off = 0) const
; 1979 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1980 : 		_DEBUG_POINTER(_Ptr);
; 1981 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 1982 : 		}
; 1983 : 
; 1984 : 	size_type find_first_of(_Elem _Ch,
; 1985 : 		size_type _Off = 0) const
; 1986 : 		{	// look for _Ch at or after _Off
; 1987 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1988 : 		}
; 1989 : 
; 1990 : 	size_type find_last_of(const _Myt& _Right,
; 1991 : 		size_type _Off = npos) const _NOEXCEPT
; 1992 : 		{	// look for one of _Right before _Off
; 1993 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_last_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off, size_type _Count) const
; 1998 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 1999 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2000 : 		if (_Count != 0)
; 2001 : 			_DEBUG_POINTER(_Ptr);
; 2002 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2003 : 
; 2004 : 		if (0 < _Count && 0 < this->_Mysize)
; 2005 : 			{	// worth searching, do it
; 2006 : 			const _Elem *_Uptr = this->_Myptr()
; 2007 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2008 : 			for (; ; --_Uptr)
; 2009 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2010 : 					return (_Uptr - this->_Myptr());	// found a match
; 2011 : 				else if (_Uptr == this->_Myptr())
; 2012 : 					break;	// at beginning, no more chance for match
; 2013 : 			}
; 2014 : 
; 2015 : 		return (npos);	// no match
; 2016 : 		}
; 2017 : 
; 2018 : 	size_type find_last_of(const _Elem *_Ptr,
; 2019 : 		size_type _Off = npos) const
; 2020 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2021 : 		_DEBUG_POINTER(_Ptr);
; 2022 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2023 : 		}
; 2024 : 
; 2025 : 	size_type find_last_of(_Elem _Ch,
; 2026 : 		size_type _Off = npos) const
; 2027 : 		{	// look for _Ch before _Off
; 2028 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2029 : 		}
; 2030 : 
; 2031 : 	size_type find_first_not_of(const _Myt& _Right,
; 2032 : 		size_type _Off = 0) const _NOEXCEPT
; 2033 : 		{	// look for none of _Right at or after _Off
; 2034 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2035 : 			_Right.size()));
; 2036 : 		}
; 2037 : 
; 2038 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2039 : 		size_type _Off, size_type _Count) const
; 2040 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2041 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2042 : 		if (_Count != 0)
; 2043 : 			_DEBUG_POINTER(_Ptr);
; 2044 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2045 : 
; 2046 : 		if (_Off < this->_Mysize)
; 2047 : 			{	// room for match, look for it
; 2048 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2049 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2050 : 				_Uptr < _Vptr; ++_Uptr)
; 2051 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2052 : 					return (_Uptr - this->_Myptr());
; 2053 : 			}
; 2054 : 		return (npos);
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off = 0) const
; 2059 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2060 : 		_DEBUG_POINTER(_Ptr);
; 2061 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2062 : 		}
; 2063 : 
; 2064 : 	size_type find_first_not_of(_Elem _Ch,
; 2065 : 		size_type _Off = 0) const
; 2066 : 		{	// look for non _Ch at or after _Off
; 2067 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2068 : 		}
; 2069 : 
; 2070 : 	size_type find_last_not_of(const _Myt& _Right,
; 2071 : 		size_type _Off = npos) const _NOEXCEPT
; 2072 : 		{	// look for none of _Right before _Off
; 2073 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off, size_type _Count) const
; 2078 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2079 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2080 : 		if (_Count != 0)
; 2081 : 			_DEBUG_POINTER(_Ptr);
; 2082 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2083 : 
; 2084 : 		if (0 < this->_Mysize)
; 2085 : 			{	// worth searching, do it
; 2086 : 			const _Elem *_Uptr = this->_Myptr()
; 2087 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2088 : 			for (; ; --_Uptr)
; 2089 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2090 : 					return (_Uptr - this->_Myptr());
; 2091 : 				else if (_Uptr == this->_Myptr())
; 2092 : 					break;
; 2093 : 			}
; 2094 : 		return (npos);
; 2095 : 		}
; 2096 : 
; 2097 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2098 : 		size_type _Off = npos) const
; 2099 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2100 : 		_DEBUG_POINTER(_Ptr);
; 2101 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2102 : 		}
; 2103 : 
; 2104 : 	size_type find_last_not_of(_Elem _Ch,
; 2105 : 		size_type _Off = npos) const
; 2106 : 		{	// look for non _Ch before _Off
; 2107 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2108 : 		}
; 2109 : 
; 2110 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2111 : 		{	// return [_Off, _Off + _Count) as new string
; 2112 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2113 : 		}
; 2114 : 
; 2115 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2116 : 		{	// compare [0, _Mysize) with _Right
; 2117 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2118 : 		}
; 2119 : 
; 2120 : 	int compare(size_type _Off, size_type _N0,
; 2121 : 		const _Myt& _Right) const
; 2122 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2123 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2124 : 		}
; 2125 : 
; 2126 : 	int compare(size_type _Off,
; 2127 : 		size_type _N0, const _Myt& _Right,
; 2128 : 		size_type _Roff, size_type _Count) const
; 2129 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2130 : 		if (_Right.size() < _Roff)
; 2131 : 			_Xran();	// _Off off end
; 2132 : 		if (_Right._Mysize - _Roff < _Count)
; 2133 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2134 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2135 : 		}
; 2136 : 
; 2137 : 	int compare(const _Elem *_Ptr) const
; 2138 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2139 : 		_DEBUG_POINTER(_Ptr);
; 2140 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2141 : 		}
; 2142 : 
; 2143 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2144 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2145 : 		_DEBUG_POINTER(_Ptr);
; 2146 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2147 : 		}
; 2148 : 
; 2149 : 	int compare(size_type _Off,
; 2150 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2151 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2152 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2153 : 		if (_Count != 0)
; 2154 : 			_DEBUG_POINTER(_Ptr);
; 2155 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2156 : 
; 2157 : 		if (this->_Mysize < _Off)
; 2158 : 			_Xran();	// _Off off end
; 2159 : 		if (this->_Mysize - _Off < _N0)
; 2160 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2161 : 
; 2162 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2163 : 			_N0 < _Count ? _N0 : _Count);
; 2164 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2165 : 			: _N0 == _Count ? 0 : +1);
; 2166 : 		}
; 2167 : 
; 2168 : 	allocator_type get_allocator() const _NOEXCEPT
; 2169 : 		{	// return allocator object for values
; 2170 : 		return (this->_Getal());
; 2171 : 		}
; 2172 : 
; 2173 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2174 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2175 : 		if (_Count == 1)
; 2176 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2177 : 		else
; 2178 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2179 : 		}
; 2180 : 
; 2181 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2182 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2183 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2184 : 		if (max_size() < _Newres)
; 2185 : 			_Newres = _Newsize;	// undo roundup if too big
; 2186 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2187 : 			;
; 2188 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2189 : 			_Newres = this->_Myres
; 2190 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2191 : 		else
; 2192 : 			_Newres = max_size();	// settle for max_size()
; 2193 : 
; 2194 : 		_Elem *_Ptr;
; 2195 : 		_TRY_BEGIN
; 2196 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2197 : 		_CATCH_ALL
; 2198 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2199 : 			_TRY_BEGIN
; 2200 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2201 : 			_CATCH_ALL
; 2202 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2203 : 			_RERAISE;
; 2204 : 			_CATCH_END
; 2205 : 		_CATCH_END
; 2206 : 
; 2207 : 		if (0 < _Oldlen)
; 2208 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2209 : 				_Oldlen);	// copy existing elements
; 2210 : 		_Tidy(true);
; 2211 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2212 : 		this->_Myres = _Newres;
; 2213 : 		_Eos(_Oldlen);
; 2214 : 		}
; 2215 : 
; 2216 : 	void _Eos(size_type _Newsize)
; 2217 : 		{	// set new length and null terminator
; 2218 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  000e3	48 89 7b 10	 mov	 QWORD PTR [rbx+16], rdi

; 517  : 			: this->_Bx._Buf);

  000e7	72 05		 jb	 SHORT $LN105@append
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstddef

; 88   : 		reinterpret_cast<const volatile char&>(_Val)))));

  000e9	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 517  : 			: this->_Bx._Buf);

  000ec	eb 03		 jmp	 SHORT $LN106@append
$LN105@append:
  000ee	48 8b cb	 mov	 rcx, rbx
$LN106@append:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd

; 347  : 		_Left = _Right;

  000f1	33 c0		 xor	 eax, eax
  000f3	66 89 04 79	 mov	 WORD PTR [rcx+rdi*2], ax
$LN109@append:
  000f7	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 1035 : 		}

  000fc	48 8b 6c 24 40	 mov	 rbp, QWORD PTR [rsp+64]
  00101	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  00106	48 8b c3	 mov	 rax, rbx
  00109	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  0010e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00112	41 5e		 pop	 r14
  00114	c3		 ret	 0
$LN115@append:

; 2272 : 		}
; 2273 : 
; 2274 : 	__declspec(noreturn) void _Xran() const
; 2275 : 		{	// report an out_of_range error
; 2276 : 		_Xout_of_range("invalid string position");

  00115	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
  0011c	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPEBD@Z ; std::_Xout_of_range
  00121	cc		 int	 3
$LN117@append:

; 2234 : 		}
; 2235 : 
; 2236 : 	bool _Inside(const _Elem *_Ptr)
; 2237 : 		{	// test if _Ptr points inside string
; 2238 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2239 : 			|| this->_Myptr() + this->_Mysize <= _Ptr)
; 2240 : 			return (false);	// don't ask
; 2241 : 		else
; 2242 : 			return (true);
; 2243 : 		}
; 2244 : 
; 2245 : 	static size_type _Pdif(const_iterator _P2,
; 2246 : 		const_iterator _P1)
; 2247 : 		{	// compute safe iterator difference
; 2248 : 		return (_STRING_ITER_BASE(_P2) == 0 ? 0 : _P2 - _P1);
; 2249 : 		}
; 2250 : 
; 2251 : 	void _Tidy(bool _Built = false,
; 2252 : 		size_type _Newsize = 0)
; 2253 : 		{	// initialize buffer, deallocating any storage
; 2254 : 		if (!_Built)
; 2255 : 			;
; 2256 : 		else if (this->_BUF_SIZE <= this->_Myres)
; 2257 : 			{	// copy any leftovers to small buffer and deallocate
; 2258 : 			pointer _Ptr = this->_Bx._Ptr;
; 2259 : 			this->_Getal().destroy(&this->_Bx._Ptr);
; 2260 : 			if (0 < _Newsize)
; 2261 : 				_Traits::copy(this->_Bx._Buf,
; 2262 : 					_STD addressof(*_Ptr), _Newsize);
; 2263 : 			this->_Getal().deallocate(_Ptr, this->_Myres + 1);
; 2264 : 			}
; 2265 : 		this->_Myres = this->_BUF_SIZE - 1;
; 2266 : 		_Eos(_Newsize);
; 2267 : 		}
; 2268 : 
; 2269 : 	__declspec(noreturn) void _Xlen() const
; 2270 : 		{	// report a length_error
; 2271 : 		_Xlength_error("string too long");

  00122	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  00129	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPEBD@Z ; std::_Xlength_error
  0012e	cc		 int	 3
$LN118@append:
  0012f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  00136	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPEBD@Z ; std::_Xlength_error
  0013b	cc		 int	 3
$LN112@append:
?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@AEBV12@_K1@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Inside@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA_NPEB_W@Z
_TEXT	SEGMENT
this$ = 8
_Ptr$ = 16
?_Inside@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA_NPEB_W@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Inside, COMDAT

; 2238 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2239 : 			|| this->_Myptr() + this->_Mysize <= _Ptr)

  00000	48 85 d2	 test	 rdx, rdx
  00003	74 35		 je	 SHORT $LN2@Inside

; 517  : 			: this->_Bx._Buf);

  00005	48 8b 41 18	 mov	 rax, QWORD PTR [rcx+24]
  00009	48 83 f8 08	 cmp	 rax, 8
  0000d	72 05		 jb	 SHORT $LN8@Inside
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstddef

; 88   : 		reinterpret_cast<const volatile char&>(_Val)))));

  0000f	4c 8b 01	 mov	 r8, QWORD PTR [rcx]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 517  : 			: this->_Bx._Buf);

  00012	eb 03		 jmp	 SHORT $LN9@Inside
$LN8@Inside:
  00014	4c 8b c1	 mov	 r8, rcx
$LN9@Inside:

; 2238 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2239 : 			|| this->_Myptr() + this->_Mysize <= _Ptr)

  00017	49 3b d0	 cmp	 rdx, r8
  0001a	72 1e		 jb	 SHORT $LN2@Inside

; 517  : 			: this->_Bx._Buf);

  0001c	48 83 f8 08	 cmp	 rax, 8
  00020	72 05		 jb	 SHORT $LN14@Inside
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstddef

; 88   : 		reinterpret_cast<const volatile char&>(_Val)))));

  00022	4c 8b 01	 mov	 r8, QWORD PTR [rcx]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 517  : 			: this->_Bx._Buf);

  00025	eb 03		 jmp	 SHORT $LN15@Inside
$LN14@Inside:
  00027	4c 8b c1	 mov	 r8, rcx
$LN15@Inside:

; 2238 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2239 : 			|| this->_Myptr() + this->_Mysize <= _Ptr)

  0002a	48 8b 41 10	 mov	 rax, QWORD PTR [rcx+16]
  0002e	49 8d 0c 40	 lea	 rcx, QWORD PTR [r8+rax*2]
  00032	48 3b ca	 cmp	 rcx, rdx
  00035	76 03		 jbe	 SHORT $LN2@Inside

; 2241 : 		else
; 2242 : 			return (true);

  00037	b0 01		 mov	 al, 1

; 2243 : 		}

  00039	c3		 ret	 0
$LN2@Inside:

; 2240 : 			return (false);	// don't ask

  0003a	32 c0		 xor	 al, al

; 2243 : 		}

  0003c	c3		 ret	 0
?_Inside@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA_NPEB_W@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Inside
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAAXPEAV?$shared_ptr@VChunkBase@@@2@_K@Z
_TEXT	SEGMENT
this$dead$ = 8
_Ptr$ = 16
__formal$dead$ = 24
?deallocate@?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAAXPEAV?$shared_ptr@VChunkBase@@@2@_K@Z PROC ; std::allocator<std::shared_ptr<ChunkBase> >::deallocate, COMDAT

; 586  : 		::operator delete(_Ptr);

  00000	48 8b ca	 mov	 rcx, rdx
  00003	e9 00 00 00 00	 jmp	 ??3@YAXPEAX@Z		; operator delete
?deallocate@?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAAXPEAV?$shared_ptr@VChunkBase@@@2@_K@Z ENDP ; std::allocator<std::shared_ptr<ChunkBase> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?capacity@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?capacity@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEBA_KXZ PROC ; std::vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::capacity, COMDAT

; 967  : 		return (this->_Myend - this->_Myfirst);

  00000	48 8b 41 10	 mov	 rax, QWORD PTR [rcx+16]
  00004	48 2b 01	 sub	 rax, QWORD PTR [rcx]
  00007	48 c1 f8 04	 sar	 rax, 4

; 968  : 		}

  0000b	c3		 ret	 0
?capacity@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEBA_KXZ ENDP ; std::vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::capacity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
;	COMDAT ??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@PEBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 8
_Pnode$ = 16
_Plist$dead$ = 24
??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@PEBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@1@@Z PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >,std::_Iterator_base0>, COMDAT

; 44   : 		{	// construct with node pointer _Pnode

  00000	48 89 11	 mov	 QWORD PTR [rcx], rdx

; 45   : 		this->_Adopt(_Plist);
; 46   : 		}

  00003	48 8b c1	 mov	 rax, rcx
  00006	c3		 ret	 0
??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@PEBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@1@@Z ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >,std::_Iterator_base0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$?9V?$allocator@_W@std@@V01@@std@@YA_NAEBU?$_Wrap_alloc@V?$allocator@_W@std@@@0@0@Z
_TEXT	SEGMENT
_Left$ = 8
_Right$ = 16
??$?9V?$allocator@_W@std@@V01@@std@@YA_NAEBU?$_Wrap_alloc@V?$allocator@_W@std@@@0@0@Z PROC ; std::operator!=<std::allocator<wchar_t>,std::allocator<wchar_t> >, COMDAT

; 931  : 	return (!(_Left == _Right));

  00000	32 c0		 xor	 al, al

; 932  : 	}

  00002	c3		 ret	 0
??$?9V?$allocator@_W@std@@V01@@std@@YA_NAEBU?$_Wrap_alloc@V?$allocator@_W@std@@@0@0@Z ENDP ; std::operator!=<std::allocator<wchar_t>,std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstddef
;	COMDAT ??$addressof@$$CBV?$shared_ptr@VChunkBase@@@std@@@std@@YAPEBV?$shared_ptr@VChunkBase@@@0@AEBV10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@$$CBV?$shared_ptr@VChunkBase@@@std@@@std@@YAPEBV?$shared_ptr@VChunkBase@@@0@AEBV10@@Z PROC ; std::addressof<std::shared_ptr<ChunkBase> const >, COMDAT

; 86   : 	return (reinterpret_cast<_Ty *>(
; 87   : 		(&const_cast<char&>(
; 88   : 		reinterpret_cast<const volatile char&>(_Val)))));

  00000	48 8b c1	 mov	 rax, rcx

; 89   : 	}

  00003	c3		 ret	 0
??$addressof@$$CBV?$shared_ptr@VChunkBase@@@std@@@std@@YAPEBV?$shared_ptr@VChunkBase@@@0@AEBV10@@Z ENDP ; std::addressof<std::shared_ptr<ChunkBase> const >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@V?$shared_ptr@VChunkBase@@@std@@AEAV12@@?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QEAAXPEAV?$shared_ptr@VChunkBase@@@1@AEAV21@@Z
_TEXT	SEGMENT
this$dead$ = 8
_Ptr$ = 16
_V0$ = 24
??$construct@V?$shared_ptr@VChunkBase@@@std@@AEAV12@@?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QEAAXPEAV?$shared_ptr@VChunkBase@@@1@AEAV21@@Z PROC ; std::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> > >::construct<std::shared_ptr<ChunkBase>,std::shared_ptr<ChunkBase> & __ptr64>, COMDAT

; 903  : _VARIADIC_EXPAND_0X(_WRAP_ALLOC_CONSTRUCT, , , , )

  00000	4d 8b c8	 mov	 r9, r8
  00003	48 8b c2	 mov	 rax, rdx

; 617  : _VARIADIC_EXPAND_0X(_ALLOC_MEMBER_CONSTRUCT, , , , )

  00006	48 85 d2	 test	 rdx, rdx
  00009	74 22		 je	 SHORT $LN11@construct
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 282  : 		{	// construct

  0000b	33 c9		 xor	 ecx, ecx
  0000d	48 89 0a	 mov	 QWORD PTR [rdx], rcx
  00010	48 89 4a 08	 mov	 QWORD PTR [rdx+8], rcx

; 283  : 		}
; 284  : 
; 285  : 	_Ptr_base(_Myt&& _Right)
; 286  : 		: _Ptr(0), _Rep(0)
; 287  : 		{	// construct _Ptr_base object that takes resource from _Right
; 288  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 289  : 		}
; 290  : 
; 291  : 	template<class _Ty2>
; 292  : 		_Ptr_base(_Ptr_base<_Ty2>&& _Right)
; 293  : 		: _Ptr(_Right._Ptr), _Rep(_Right._Rep)
; 294  : 		{	// construct _Ptr_base object that takes resource from _Right
; 295  : 		_Right._Ptr = 0;
; 296  : 		_Right._Rep = 0;
; 297  : 		}
; 298  : 
; 299  : 	_Myt& operator=(_Myt&& _Right)
; 300  : 		{	// construct _Ptr_base object that takes resource from _Right
; 301  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 302  : 		return (*this);
; 303  : 		}
; 304  : 
; 305  : 	void _Assign_rv(_Myt&& _Right)
; 306  : 		{	// assign by moving _Right
; 307  : 		if (this != &_Right)
; 308  : 			_Swap(_Right);
; 309  : 		}
; 310  : 
; 311  : 	long use_count() const _NOEXCEPT
; 312  : 		{	// return use count
; 313  : 		return (_Rep ? _Rep->_Use_count() : 0);
; 314  : 		}
; 315  : 
; 316  : 	void _Swap(_Ptr_base& _Right)
; 317  : 		{	// swap pointers
; 318  : 		_STD swap(_Rep, _Right._Rep);
; 319  : 		_STD swap(_Ptr, _Right._Ptr);
; 320  : 		}
; 321  : 
; 322  : 	template<class _Ty2>
; 323  : 		bool owner_before(const _Ptr_base<_Ty2>& _Right) const
; 324  : 		{	// compare addresses of manager objects
; 325  : 		return (_Rep < _Right._Rep);
; 326  : 		}
; 327  : 
; 328  : 	void *_Get_deleter(const _XSTD2 type_info& _Typeid) const
; 329  : 		{	// return pointer to deleter object if its type is _Typeid
; 330  : 		return (_Rep ? _Rep->_Get_deleter(_Typeid) : 0);
; 331  : 		}
; 332  : 
; 333  : 	_Ty *_Get() const
; 334  : 		{	// return pointer to resource
; 335  : 		return (_Ptr);
; 336  : 		}
; 337  : 
; 338  : 	bool _Expired() const
; 339  : 		{	// test if expired
; 340  : 		return (!_Rep || _Rep->_Expired());
; 341  : 		}
; 342  : 
; 343  : 	void _Decref()
; 344  : 		{	// decrement reference count
; 345  : 		if (_Rep != 0)
; 346  : 			_Rep->_Decref();
; 347  : 		}
; 348  : 
; 349  : 	void _Reset()
; 350  : 		{	// release resource
; 351  : 		_Reset(0, 0);
; 352  : 		}
; 353  : 
; 354  : 	template<class _Ty2>
; 355  : 		void _Reset(const _Ptr_base<_Ty2>& _Other)
; 356  : 		{	// release resource and take ownership of _Other._Ptr
; 357  : 		_Reset(_Other._Ptr, _Other._Rep);

  00014	4d 8b 40 08	 mov	 r8, QWORD PTR [r8+8]
  00018	49 8b 11	 mov	 rdx, QWORD PTR [r9]

; 358  : 		}
; 359  : 
; 360  : 	template<class _Ty2>
; 361  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, bool _Throw)
; 362  : 		{	// release resource and take ownership from weak_ptr _Other._Ptr
; 363  : 		_Reset(_Other._Ptr, _Other._Rep, _Throw);
; 364  : 		}
; 365  : 
; 366  : 	template<class _Ty2>
; 367  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Static_tag&)
; 368  : 		{	// release resource and take ownership of _Other._Ptr
; 369  : 		_Reset(static_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 370  : 		}
; 371  : 
; 372  : 	template<class _Ty2>
; 373  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Const_tag&)
; 374  : 		{	// release resource and take ownership of _Other._Ptr
; 375  : 		_Reset(const_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 376  : 		}
; 377  : 
; 378  : 	template<class _Ty2>
; 379  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Dynamic_tag&)
; 380  : 		{	// release resource and take ownership of _Other._Ptr
; 381  : 		_Elem *_Ptr = dynamic_cast<_Elem *>(_Other._Ptr);
; 382  : 		if (_Ptr)
; 383  : 			_Reset(_Ptr, _Other._Rep);
; 384  : 		else
; 385  : 			_Reset();
; 386  : 		}
; 387  : 
; 388  : 	template<class _Ty2>
; 389  : 		void _Reset(auto_ptr<_Ty2>&& _Other)
; 390  : 		{	// release resource and take _Other.get()
; 391  : 		_Ty2 *_Px = _Other.get();
; 392  : 		_Reset0(_Px, new _Ref_count<_Elem>(_Px));
; 393  : 		_Other.release();
; 394  : 		_Enable_shared(_Px, _Rep);
; 395  : 		}
; 396  : 
; 397  :  #if _HAS_CPP0X
; 398  : 	template<class _Ty2>
; 399  : 		void _Reset(_Ty *_Ptr, const _Ptr_base<_Ty2>& _Other)
; 400  : 		{	// release resource and alias _Ptr with _Other_rep
; 401  : 		_Reset(_Ptr, _Other._Rep);
; 402  : 		}
; 403  :  #endif /* _HAS_CPP0X */
; 404  : 
; 405  : 	void _Reset(_Ty *_Other_ptr, _Ref_count_base *_Other_rep)
; 406  : 		{	// release resource and take _Other_ptr through _Other_rep
; 407  : 		if (_Other_rep)

  0001b	4d 85 c0	 test	 r8, r8
  0001e	74 05		 je	 SHORT $LN26@construct

; 108  : 		_MT_INCR(_Ignored, _Uses);

  00020	f0 41 ff 40 08	 lock inc DWORD PTR [r8+8]
$LN26@construct:

; 408  : 			_Other_rep->_Incref();
; 409  : 		_Reset0(_Other_ptr, _Other_rep);

  00025	48 8b c8	 mov	 rcx, rax
  00028	e9 00 00 00 00	 jmp	 ?_Reset0@?$_Ptr_base@VChunkBase@@@std@@QEAAXPEAVChunkBase@@PEAV_Ref_count_base@2@@Z ; std::_Ptr_base<ChunkBase>::_Reset0
$LN11@construct:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 903  : _VARIADIC_EXPAND_0X(_WRAP_ALLOC_CONSTRUCT, , , , )

  0002d	f3 c3		 fatret	 0
??$construct@V?$shared_ptr@VChunkBase@@@std@@AEAV12@@?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QEAAXPEAV?$shared_ptr@VChunkBase@@@1@AEAV21@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> > >::construct<std::shared_ptr<ChunkBase>,std::shared_ptr<ChunkBase> & __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstddef
;	COMDAT ??$addressof@$$CBU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@YAPEBU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@0@AEBU10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@$$CBU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@YAPEBU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@0@AEBU10@@Z PROC ; std::addressof<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > const >, COMDAT

; 86   : 	return (reinterpret_cast<_Ty *>(
; 87   : 		(&const_cast<char&>(
; 88   : 		reinterpret_cast<const volatile char&>(_Val)))));

  00000	48 8b c1	 mov	 rax, rcx

; 89   : 	}

  00003	c3		 ret	 0
??$addressof@$$CBU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@YAPEBU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@0@AEBU10@@Z ENDP ; std::addressof<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > const >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@YAXPEAV?$shared_ptr@VChunkBase@@@0@0AEAU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
_First$ = 48
_Last$ = 56
_Al$dead$ = 64
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@YAXPEAV?$shared_ptr@VChunkBase@@@0@0AEAU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> > > >, COMDAT

; 79   : 	{	// destroy [_First, _Last)

$LN35:

; 88   : 	for (; _First != _Last; ++_First)

  00000	48 3b ca	 cmp	 rcx, rdx
  00003	74 5c		 je	 SHORT $LN33@Destroy_ra
  00005	56		 push	 rsi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx
  0000f	48 89 7c 24 38	 mov	 QWORD PTR [rsp+56], rdi

; 79   : 	{	// destroy [_First, _Last)

  00014	48 8b f2	 mov	 rsi, rdx

; 80   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

  00017	48 8d 79 08	 lea	 rdi, QWORD PTR [rcx+8]
  0001b	0f 1f 44 00 00	 npad	 5
$LL7@Destroy_ra:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  00020	48 8b 1f	 mov	 rbx, QWORD PTR [rdi]
  00023	48 85 db	 test	 rbx, rbx
  00026	74 1d		 je	 SHORT $LN27@Destroy_ra

; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  00028	f0 ff 4b 08	 lock dec DWORD PTR [rbx+8]
  0002c	75 17		 jne	 SHORT $LN27@Destroy_ra

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  0002e	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00031	48 8b cb	 mov	 rcx, rbx
  00034	ff 10		 call	 QWORD PTR [rax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  00036	f0 ff 4b 0c	 lock dec DWORD PTR [rbx+12]
  0003a	75 09		 jne	 SHORT $LN27@Destroy_ra

; 128  : 			_Delete_this();

  0003c	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  0003f	48 8b cb	 mov	 rcx, rbx
  00042	ff 50 08	 call	 QWORD PTR [rax+8]
$LN27@Destroy_ra:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 88   : 	for (; _First != _Last; ++_First)

  00045	48 83 c7 10	 add	 rdi, 16
  00049	48 8d 47 f8	 lea	 rax, QWORD PTR [rdi-8]
  0004d	48 3b c6	 cmp	 rax, rsi
  00050	75 ce		 jne	 SHORT $LL7@Destroy_ra
  00052	48 8b 7c 24 38	 mov	 rdi, QWORD PTR [rsp+56]
  00057	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]

; 81   : 	}

  0005c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00060	5e		 pop	 rsi
$LN33@Destroy_ra:
  00061	f3 c3		 fatret	 0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@YAXPEAV?$shared_ptr@VChunkBase@@@0@0AEAU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ??$_Umove@PEAV?$shared_ptr@VChunkBase@@@std@@@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAPEAV?$shared_ptr@VChunkBase@@@1@PEAV21@00@Z
_TEXT	SEGMENT
this$dead$ = 64
_First$ = 72
_Last$ = 80
_Ptr$ = 88
??$_Umove@PEAV?$shared_ptr@VChunkBase@@@std@@@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAPEAV?$shared_ptr@VChunkBase@@@1@PEAV21@00@Z PROC ; std::vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::_Umove<std::shared_ptr<ChunkBase> * __ptr64>, COMDAT

; 1557 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

$LN10:
  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H
  00004	49 8b c0	 mov	 rax, r8
  00007	48 8b ca	 mov	 rcx, rdx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory

; 473  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));

  0000a	4d 8b c1	 mov	 r8, r9
  0000d	48 8b d0	 mov	 rdx, rax
  00010	e8 00 00 00 00	 call	 ??$_Uninit_move@PEAV?$shared_ptr@VChunkBase@@@std@@PEAV12@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@V12@@std@@YAPEAV?$shared_ptr@VChunkBase@@@0@PEAV10@00AEAU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<std::shared_ptr<ChunkBase> * __ptr64,std::shared_ptr<ChunkBase> * __ptr64,std::allocator<std::shared_ptr<ChunkBase> >,std::shared_ptr<ChunkBase> >
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector

; 1562 : 		}

  00015	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00019	c3		 ret	 0
??$_Umove@PEAV?$shared_ptr@VChunkBase@@@std@@@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAPEAV?$shared_ptr@VChunkBase@@@1@PEAV21@00@Z ENDP ; std::vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::_Umove<std::shared_ptr<ChunkBase> * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$?8V?$allocator@_W@std@@V01@@std@@YA_NAEBU?$_Wrap_alloc@V?$allocator@_W@std@@@0@0@Z
_TEXT	SEGMENT
_Left$ = 8
_Right$ = 16
??$?8V?$allocator@_W@std@@V01@@std@@YA_NAEBU?$_Wrap_alloc@V?$allocator@_W@std@@@0@0@Z PROC ; std::operator==<std::allocator<wchar_t>,std::allocator<wchar_t> >, COMDAT

; 923  : 	return (static_cast<_Ty>(_Left) == static_cast<_Other>(_Right));

  00000	b0 01		 mov	 al, 1

; 924  : 	}

  00002	c3		 ret	 0
??$?8V?$allocator@_W@std@@V01@@std@@YA_NAEBU?$_Wrap_alloc@V?$allocator@_W@std@@@0@0@Z ENDP ; std::operator==<std::allocator<wchar_t>,std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\type_traits
;	COMDAT ??$forward@AEAV?$shared_ptr@VChunkBase@@@std@@@std@@YAAEAV?$shared_ptr@VChunkBase@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEAV?$shared_ptr@VChunkBase@@@std@@@std@@YAAEAV?$shared_ptr@VChunkBase@@@0@AEAV10@@Z PROC ; std::forward<std::shared_ptr<ChunkBase> & __ptr64>, COMDAT

; 1776 : 	return (static_cast<_Ty&&>(_Arg));

  00000	48 8b c1	 mov	 rax, rcx

; 1777 : 	}

  00003	c3		 ret	 0
??$forward@AEAV?$shared_ptr@VChunkBase@@@std@@@std@@YAAEAV?$shared_ptr@VChunkBase@@@0@AEAV10@@Z ENDP ; std::forward<std::shared_ptr<ChunkBase> & __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@V?$shared_ptr@VChunkBase@@@std@@AEAV12@@?$allocator_traits@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$shared_ptr@VChunkBase@@@std@@@1@PEAV?$shared_ptr@VChunkBase@@@1@AEAV31@@Z
_TEXT	SEGMENT
_Al$dead$ = 8
_Ptr$ = 16
_V0$ = 24
??$construct@V?$shared_ptr@VChunkBase@@@std@@AEAV12@@?$allocator_traits@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$shared_ptr@VChunkBase@@@std@@@1@PEAV?$shared_ptr@VChunkBase@@@1@AEAV31@@Z PROC ; std::allocator_traits<std::allocator<std::shared_ptr<ChunkBase> > >::construct<std::shared_ptr<ChunkBase>,std::shared_ptr<ChunkBase> & __ptr64>, COMDAT

; 751  : _VARIADIC_EXPAND_0X(_ALLOC_TRAITS_SPECIAL_CONSTRUCT, , , , )

  00000	4d 8b c8	 mov	 r9, r8
  00003	48 8b c2	 mov	 rax, rdx

; 617  : _VARIADIC_EXPAND_0X(_ALLOC_MEMBER_CONSTRUCT, , , , )

  00006	48 85 d2	 test	 rdx, rdx
  00009	74 22		 je	 SHORT $LN7@construct
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 282  : 		{	// construct

  0000b	33 c9		 xor	 ecx, ecx
  0000d	48 89 0a	 mov	 QWORD PTR [rdx], rcx
  00010	48 89 4a 08	 mov	 QWORD PTR [rdx+8], rcx

; 283  : 		}
; 284  : 
; 285  : 	_Ptr_base(_Myt&& _Right)
; 286  : 		: _Ptr(0), _Rep(0)
; 287  : 		{	// construct _Ptr_base object that takes resource from _Right
; 288  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 289  : 		}
; 290  : 
; 291  : 	template<class _Ty2>
; 292  : 		_Ptr_base(_Ptr_base<_Ty2>&& _Right)
; 293  : 		: _Ptr(_Right._Ptr), _Rep(_Right._Rep)
; 294  : 		{	// construct _Ptr_base object that takes resource from _Right
; 295  : 		_Right._Ptr = 0;
; 296  : 		_Right._Rep = 0;
; 297  : 		}
; 298  : 
; 299  : 	_Myt& operator=(_Myt&& _Right)
; 300  : 		{	// construct _Ptr_base object that takes resource from _Right
; 301  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 302  : 		return (*this);
; 303  : 		}
; 304  : 
; 305  : 	void _Assign_rv(_Myt&& _Right)
; 306  : 		{	// assign by moving _Right
; 307  : 		if (this != &_Right)
; 308  : 			_Swap(_Right);
; 309  : 		}
; 310  : 
; 311  : 	long use_count() const _NOEXCEPT
; 312  : 		{	// return use count
; 313  : 		return (_Rep ? _Rep->_Use_count() : 0);
; 314  : 		}
; 315  : 
; 316  : 	void _Swap(_Ptr_base& _Right)
; 317  : 		{	// swap pointers
; 318  : 		_STD swap(_Rep, _Right._Rep);
; 319  : 		_STD swap(_Ptr, _Right._Ptr);
; 320  : 		}
; 321  : 
; 322  : 	template<class _Ty2>
; 323  : 		bool owner_before(const _Ptr_base<_Ty2>& _Right) const
; 324  : 		{	// compare addresses of manager objects
; 325  : 		return (_Rep < _Right._Rep);
; 326  : 		}
; 327  : 
; 328  : 	void *_Get_deleter(const _XSTD2 type_info& _Typeid) const
; 329  : 		{	// return pointer to deleter object if its type is _Typeid
; 330  : 		return (_Rep ? _Rep->_Get_deleter(_Typeid) : 0);
; 331  : 		}
; 332  : 
; 333  : 	_Ty *_Get() const
; 334  : 		{	// return pointer to resource
; 335  : 		return (_Ptr);
; 336  : 		}
; 337  : 
; 338  : 	bool _Expired() const
; 339  : 		{	// test if expired
; 340  : 		return (!_Rep || _Rep->_Expired());
; 341  : 		}
; 342  : 
; 343  : 	void _Decref()
; 344  : 		{	// decrement reference count
; 345  : 		if (_Rep != 0)
; 346  : 			_Rep->_Decref();
; 347  : 		}
; 348  : 
; 349  : 	void _Reset()
; 350  : 		{	// release resource
; 351  : 		_Reset(0, 0);
; 352  : 		}
; 353  : 
; 354  : 	template<class _Ty2>
; 355  : 		void _Reset(const _Ptr_base<_Ty2>& _Other)
; 356  : 		{	// release resource and take ownership of _Other._Ptr
; 357  : 		_Reset(_Other._Ptr, _Other._Rep);

  00014	4d 8b 40 08	 mov	 r8, QWORD PTR [r8+8]
  00018	49 8b 11	 mov	 rdx, QWORD PTR [r9]

; 358  : 		}
; 359  : 
; 360  : 	template<class _Ty2>
; 361  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, bool _Throw)
; 362  : 		{	// release resource and take ownership from weak_ptr _Other._Ptr
; 363  : 		_Reset(_Other._Ptr, _Other._Rep, _Throw);
; 364  : 		}
; 365  : 
; 366  : 	template<class _Ty2>
; 367  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Static_tag&)
; 368  : 		{	// release resource and take ownership of _Other._Ptr
; 369  : 		_Reset(static_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 370  : 		}
; 371  : 
; 372  : 	template<class _Ty2>
; 373  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Const_tag&)
; 374  : 		{	// release resource and take ownership of _Other._Ptr
; 375  : 		_Reset(const_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 376  : 		}
; 377  : 
; 378  : 	template<class _Ty2>
; 379  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Dynamic_tag&)
; 380  : 		{	// release resource and take ownership of _Other._Ptr
; 381  : 		_Elem *_Ptr = dynamic_cast<_Elem *>(_Other._Ptr);
; 382  : 		if (_Ptr)
; 383  : 			_Reset(_Ptr, _Other._Rep);
; 384  : 		else
; 385  : 			_Reset();
; 386  : 		}
; 387  : 
; 388  : 	template<class _Ty2>
; 389  : 		void _Reset(auto_ptr<_Ty2>&& _Other)
; 390  : 		{	// release resource and take _Other.get()
; 391  : 		_Ty2 *_Px = _Other.get();
; 392  : 		_Reset0(_Px, new _Ref_count<_Elem>(_Px));
; 393  : 		_Other.release();
; 394  : 		_Enable_shared(_Px, _Rep);
; 395  : 		}
; 396  : 
; 397  :  #if _HAS_CPP0X
; 398  : 	template<class _Ty2>
; 399  : 		void _Reset(_Ty *_Ptr, const _Ptr_base<_Ty2>& _Other)
; 400  : 		{	// release resource and alias _Ptr with _Other_rep
; 401  : 		_Reset(_Ptr, _Other._Rep);
; 402  : 		}
; 403  :  #endif /* _HAS_CPP0X */
; 404  : 
; 405  : 	void _Reset(_Ty *_Other_ptr, _Ref_count_base *_Other_rep)
; 406  : 		{	// release resource and take _Other_ptr through _Other_rep
; 407  : 		if (_Other_rep)

  0001b	4d 85 c0	 test	 r8, r8
  0001e	74 05		 je	 SHORT $LN22@construct

; 108  : 		_MT_INCR(_Ignored, _Uses);

  00020	f0 41 ff 40 08	 lock inc DWORD PTR [r8+8]
$LN22@construct:

; 408  : 			_Other_rep->_Incref();
; 409  : 		_Reset0(_Other_ptr, _Other_rep);

  00025	48 8b c8	 mov	 rcx, rax
  00028	e9 00 00 00 00	 jmp	 ?_Reset0@?$_Ptr_base@VChunkBase@@@std@@QEAAXPEAVChunkBase@@PEAV_Ref_count_base@2@@Z ; std::_Ptr_base<ChunkBase>::_Reset0
$LN7@construct:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 751  : _VARIADIC_EXPAND_0X(_ALLOC_TRAITS_SPECIAL_CONSTRUCT, , , , )

  0002d	f3 c3		 fatret	 0
??$construct@V?$shared_ptr@VChunkBase@@@std@@AEAV12@@?$allocator_traits@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$shared_ptr@VChunkBase@@@std@@@1@PEAV?$shared_ptr@VChunkBase@@@1@AEAV31@@Z ENDP ; std::allocator_traits<std::allocator<std::shared_ptr<ChunkBase> > >::construct<std::shared_ptr<ChunkBase>,std::shared_ptr<ChunkBase> & __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$?8_W_W@std@@YA_NAEBV?$allocator@_W@0@0@Z
_TEXT	SEGMENT
__formal$ = 8
__formal$ = 16
??$?8_W_W@std@@YA_NAEBV?$allocator@_W@0@0@Z PROC	; std::operator==<wchar_t,wchar_t>, COMDAT

; 677  : 	return (true);

  00000	b0 01		 mov	 al, 1

; 678  : 	}

  00002	c3		 ret	 0
??$?8_W_W@std@@YA_NAEBV?$allocator@_W@0@0@Z ENDP	; std::operator==<wchar_t,wchar_t>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??$_Ptr_cat@V?$shared_ptr@VChunkBase@@@std@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PEAV?$shared_ptr@VChunkBase@@@0@0@Z
_TEXT	SEGMENT
__formal$dead$ = 8
__formal$dead$ = 16
_Cat$ = 16
??$_Ptr_cat@V?$shared_ptr@VChunkBase@@@std@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PEAV?$shared_ptr@VChunkBase@@@0@0@Z PROC ; std::_Ptr_cat<std::shared_ptr<ChunkBase>,std::shared_ptr<ChunkBase> >, COMDAT

; 437  : 	{	// return pointer category from pointers

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx

; 438  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::type _Cat;
; 439  : 	return (_Cat);

  00005	0f b6 44 24 10	 movzx	 eax, BYTE PTR _Cat$[rsp]

; 440  : 	}

  0000a	c3		 ret	 0
??$_Ptr_cat@V?$shared_ptr@VChunkBase@@@std@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PEAV?$shared_ptr@VChunkBase@@@0@0@Z ENDP ; std::_Ptr_cat<std::shared_ptr<ChunkBase>,std::shared_ptr<ChunkBase> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@YAXPEAV?$shared_ptr@VChunkBase@@@0@0AEAU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
_First$ = 48
_Last$ = 56
_Al$dead$ = 64
__formal$dead$ = 72
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@YAXPEAV?$shared_ptr@VChunkBase@@@0@0AEAU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> > > >, COMDAT

; 87   : 	{	// destroy [_First, _Last), arbitrary type

$LN31:

; 88   : 	for (; _First != _Last; ++_First)

  00000	48 3b ca	 cmp	 rcx, rdx
  00003	74 5c		 je	 SHORT $LN29@Destroy_ra
  00005	56		 push	 rsi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx
  0000f	48 89 7c 24 38	 mov	 QWORD PTR [rsp+56], rdi

; 87   : 	{	// destroy [_First, _Last), arbitrary type

  00014	48 8b f2	 mov	 rsi, rdx

; 88   : 	for (; _First != _Last; ++_First)

  00017	48 8d 79 08	 lea	 rdi, QWORD PTR [rcx+8]
  0001b	0f 1f 44 00 00	 npad	 5
$LL3@Destroy_ra:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  00020	48 8b 1f	 mov	 rbx, QWORD PTR [rdi]
  00023	48 85 db	 test	 rbx, rbx
  00026	74 1d		 je	 SHORT $LN23@Destroy_ra

; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  00028	f0 ff 4b 08	 lock dec DWORD PTR [rbx+8]
  0002c	75 17		 jne	 SHORT $LN23@Destroy_ra

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  0002e	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00031	48 8b cb	 mov	 rcx, rbx
  00034	ff 10		 call	 QWORD PTR [rax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  00036	f0 ff 4b 0c	 lock dec DWORD PTR [rbx+12]
  0003a	75 09		 jne	 SHORT $LN23@Destroy_ra

; 128  : 			_Delete_this();

  0003c	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  0003f	48 8b cb	 mov	 rcx, rbx
  00042	ff 50 08	 call	 QWORD PTR [rax+8]
$LN23@Destroy_ra:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 88   : 	for (; _First != _Last; ++_First)

  00045	48 83 c7 10	 add	 rdi, 16
  00049	48 8d 47 f8	 lea	 rax, QWORD PTR [rdi-8]
  0004d	48 3b c6	 cmp	 rax, rsi
  00050	75 ce		 jne	 SHORT $LL3@Destroy_ra
  00052	48 8b 7c 24 38	 mov	 rdi, QWORD PTR [rsp+56]
  00057	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]

; 89   : 		_Al.destroy(_First);
; 90   : 	}

  0005c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00060	5e		 pop	 rsi
$LN29@Destroy_ra:
  00061	f3 c3		 fatret	 0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@YAXPEAV?$shared_ptr@VChunkBase@@@0@0AEAU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_move@PEAV?$shared_ptr@VChunkBase@@@std@@PEAV12@U?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@YAPEAV?$shared_ptr@VChunkBase@@@0@PEAV10@00AEAU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
_First$ = 64
_Last$ = 72
_Dest$ = 80
_Al$dead$ = 88
??$_Uninitialized_move@PEAV?$shared_ptr@VChunkBase@@@std@@PEAV12@U?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@YAPEAV?$shared_ptr@VChunkBase@@@0@PEAV10@00AEAU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@0@@Z PROC ; std::_Uninitialized_move<std::shared_ptr<ChunkBase> * __ptr64,std::shared_ptr<ChunkBase> * __ptr64,std::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> > > >, COMDAT

; 471  : 	{	// move [_First, _Last) to raw _Dest, using _Al

$LN8:
  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 472  : 	return (_Uninit_move(_First, _Last, _Dest, _Al,
; 473  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));

  00004	e8 00 00 00 00	 call	 ??$_Uninit_move@PEAV?$shared_ptr@VChunkBase@@@std@@PEAV12@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@V12@@std@@YAPEAV?$shared_ptr@VChunkBase@@@0@PEAV10@00AEAU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<std::shared_ptr<ChunkBase> * __ptr64,std::shared_ptr<ChunkBase> * __ptr64,std::allocator<std::shared_ptr<ChunkBase> >,std::shared_ptr<ChunkBase> >

; 474  : 	}

  00009	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0000d	c3		 ret	 0
??$_Uninitialized_move@PEAV?$shared_ptr@VChunkBase@@@std@@PEAV12@U?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@YAPEAV?$shared_ptr@VChunkBase@@@0@PEAV10@00AEAU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@0@@Z ENDP ; std::_Uninitialized_move<std::shared_ptr<ChunkBase> * __ptr64,std::shared_ptr<ChunkBase> * __ptr64,std::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@V?$shared_ptr@VChunkBase@@@std@@AEAV12@@?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAAXPEAV?$shared_ptr@VChunkBase@@@1@AEAV21@@Z
_TEXT	SEGMENT
this$dead$ = 8
_Ptr$ = 16
_V0$ = 24
??$construct@V?$shared_ptr@VChunkBase@@@std@@AEAV12@@?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAAXPEAV?$shared_ptr@VChunkBase@@@1@AEAV21@@Z PROC ; std::allocator<std::shared_ptr<ChunkBase> >::construct<std::shared_ptr<ChunkBase>,std::shared_ptr<ChunkBase> & __ptr64>, COMDAT

; 617  : _VARIADIC_EXPAND_0X(_ALLOC_MEMBER_CONSTRUCT, , , , )

  00000	4d 8b c8	 mov	 r9, r8
  00003	48 8b c2	 mov	 rax, rdx
  00006	48 85 d2	 test	 rdx, rdx
  00009	74 22		 je	 SHORT $LN3@construct
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 282  : 		{	// construct

  0000b	33 c9		 xor	 ecx, ecx
  0000d	48 89 0a	 mov	 QWORD PTR [rdx], rcx
  00010	48 89 4a 08	 mov	 QWORD PTR [rdx+8], rcx

; 283  : 		}
; 284  : 
; 285  : 	_Ptr_base(_Myt&& _Right)
; 286  : 		: _Ptr(0), _Rep(0)
; 287  : 		{	// construct _Ptr_base object that takes resource from _Right
; 288  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 289  : 		}
; 290  : 
; 291  : 	template<class _Ty2>
; 292  : 		_Ptr_base(_Ptr_base<_Ty2>&& _Right)
; 293  : 		: _Ptr(_Right._Ptr), _Rep(_Right._Rep)
; 294  : 		{	// construct _Ptr_base object that takes resource from _Right
; 295  : 		_Right._Ptr = 0;
; 296  : 		_Right._Rep = 0;
; 297  : 		}
; 298  : 
; 299  : 	_Myt& operator=(_Myt&& _Right)
; 300  : 		{	// construct _Ptr_base object that takes resource from _Right
; 301  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 302  : 		return (*this);
; 303  : 		}
; 304  : 
; 305  : 	void _Assign_rv(_Myt&& _Right)
; 306  : 		{	// assign by moving _Right
; 307  : 		if (this != &_Right)
; 308  : 			_Swap(_Right);
; 309  : 		}
; 310  : 
; 311  : 	long use_count() const _NOEXCEPT
; 312  : 		{	// return use count
; 313  : 		return (_Rep ? _Rep->_Use_count() : 0);
; 314  : 		}
; 315  : 
; 316  : 	void _Swap(_Ptr_base& _Right)
; 317  : 		{	// swap pointers
; 318  : 		_STD swap(_Rep, _Right._Rep);
; 319  : 		_STD swap(_Ptr, _Right._Ptr);
; 320  : 		}
; 321  : 
; 322  : 	template<class _Ty2>
; 323  : 		bool owner_before(const _Ptr_base<_Ty2>& _Right) const
; 324  : 		{	// compare addresses of manager objects
; 325  : 		return (_Rep < _Right._Rep);
; 326  : 		}
; 327  : 
; 328  : 	void *_Get_deleter(const _XSTD2 type_info& _Typeid) const
; 329  : 		{	// return pointer to deleter object if its type is _Typeid
; 330  : 		return (_Rep ? _Rep->_Get_deleter(_Typeid) : 0);
; 331  : 		}
; 332  : 
; 333  : 	_Ty *_Get() const
; 334  : 		{	// return pointer to resource
; 335  : 		return (_Ptr);
; 336  : 		}
; 337  : 
; 338  : 	bool _Expired() const
; 339  : 		{	// test if expired
; 340  : 		return (!_Rep || _Rep->_Expired());
; 341  : 		}
; 342  : 
; 343  : 	void _Decref()
; 344  : 		{	// decrement reference count
; 345  : 		if (_Rep != 0)
; 346  : 			_Rep->_Decref();
; 347  : 		}
; 348  : 
; 349  : 	void _Reset()
; 350  : 		{	// release resource
; 351  : 		_Reset(0, 0);
; 352  : 		}
; 353  : 
; 354  : 	template<class _Ty2>
; 355  : 		void _Reset(const _Ptr_base<_Ty2>& _Other)
; 356  : 		{	// release resource and take ownership of _Other._Ptr
; 357  : 		_Reset(_Other._Ptr, _Other._Rep);

  00014	4d 8b 40 08	 mov	 r8, QWORD PTR [r8+8]
  00018	49 8b 11	 mov	 rdx, QWORD PTR [r9]

; 358  : 		}
; 359  : 
; 360  : 	template<class _Ty2>
; 361  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, bool _Throw)
; 362  : 		{	// release resource and take ownership from weak_ptr _Other._Ptr
; 363  : 		_Reset(_Other._Ptr, _Other._Rep, _Throw);
; 364  : 		}
; 365  : 
; 366  : 	template<class _Ty2>
; 367  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Static_tag&)
; 368  : 		{	// release resource and take ownership of _Other._Ptr
; 369  : 		_Reset(static_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 370  : 		}
; 371  : 
; 372  : 	template<class _Ty2>
; 373  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Const_tag&)
; 374  : 		{	// release resource and take ownership of _Other._Ptr
; 375  : 		_Reset(const_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 376  : 		}
; 377  : 
; 378  : 	template<class _Ty2>
; 379  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Dynamic_tag&)
; 380  : 		{	// release resource and take ownership of _Other._Ptr
; 381  : 		_Elem *_Ptr = dynamic_cast<_Elem *>(_Other._Ptr);
; 382  : 		if (_Ptr)
; 383  : 			_Reset(_Ptr, _Other._Rep);
; 384  : 		else
; 385  : 			_Reset();
; 386  : 		}
; 387  : 
; 388  : 	template<class _Ty2>
; 389  : 		void _Reset(auto_ptr<_Ty2>&& _Other)
; 390  : 		{	// release resource and take _Other.get()
; 391  : 		_Ty2 *_Px = _Other.get();
; 392  : 		_Reset0(_Px, new _Ref_count<_Elem>(_Px));
; 393  : 		_Other.release();
; 394  : 		_Enable_shared(_Px, _Rep);
; 395  : 		}
; 396  : 
; 397  :  #if _HAS_CPP0X
; 398  : 	template<class _Ty2>
; 399  : 		void _Reset(_Ty *_Ptr, const _Ptr_base<_Ty2>& _Other)
; 400  : 		{	// release resource and alias _Ptr with _Other_rep
; 401  : 		_Reset(_Ptr, _Other._Rep);
; 402  : 		}
; 403  :  #endif /* _HAS_CPP0X */
; 404  : 
; 405  : 	void _Reset(_Ty *_Other_ptr, _Ref_count_base *_Other_rep)
; 406  : 		{	// release resource and take _Other_ptr through _Other_rep
; 407  : 		if (_Other_rep)

  0001b	4d 85 c0	 test	 r8, r8
  0001e	74 05		 je	 SHORT $LN18@construct

; 108  : 		_MT_INCR(_Ignored, _Uses);

  00020	f0 41 ff 40 08	 lock inc DWORD PTR [r8+8]
$LN18@construct:

; 408  : 			_Other_rep->_Incref();
; 409  : 		_Reset0(_Other_ptr, _Other_rep);

  00025	48 8b c8	 mov	 rcx, rax
  00028	e9 00 00 00 00	 jmp	 ?_Reset0@?$_Ptr_base@VChunkBase@@@std@@QEAAXPEAVChunkBase@@PEAV_Ref_count_base@2@@Z ; std::_Ptr_base<ChunkBase>::_Reset0
$LN3@construct:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 617  : _VARIADIC_EXPAND_0X(_ALLOC_MEMBER_CONSTRUCT, , , , )

  0002d	f3 c3		 fatret	 0
??$construct@V?$shared_ptr@VChunkBase@@@std@@AEAV12@@?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAAXPEAV?$shared_ptr@VChunkBase@@@1@AEAV21@@Z ENDP ; std::allocator<std::shared_ptr<ChunkBase> >::construct<std::shared_ptr<ChunkBase>,std::shared_ptr<ChunkBase> & __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??$_Val_type@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@YAPEAV?$shared_ptr@VChunkBase@@@0@PEAV10@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
??$_Val_type@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@YAPEAV?$shared_ptr@VChunkBase@@@0@PEAV10@@Z PROC ; std::_Val_type<std::shared_ptr<ChunkBase> * __ptr64>, COMDAT

; 711  : 	return (0);

  00000	33 c0		 xor	 eax, eax

; 712  : 	}

  00002	c3		 ret	 0
??$_Val_type@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@YAPEAV?$shared_ptr@VChunkBase@@@0@PEAV10@@Z ENDP ; std::_Val_type<std::shared_ptr<ChunkBase> * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory
;	COMDAT ??$_Uninit_move@PEAV?$shared_ptr@VChunkBase@@@std@@PEAV12@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@V12@@std@@YAPEAV?$shared_ptr@VChunkBase@@@0@PEAV10@00AEAU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
_First$ = 8
_Last$ = 16
_Dest$ = 24
_Al$dead$ = 32
__formal$dead$ = 40
__formal$dead$ = 48
??$_Uninit_move@PEAV?$shared_ptr@VChunkBase@@@std@@PEAV12@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@V12@@std@@YAPEAV?$shared_ptr@VChunkBase@@@0@PEAV10@00AEAU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_move<std::shared_ptr<ChunkBase> * __ptr64,std::shared_ptr<ChunkBase> * __ptr64,std::allocator<std::shared_ptr<ChunkBase> >,std::shared_ptr<ChunkBase> >, COMDAT

; 426  : 	{	// move [_First, _Last) to raw _Dest, using _Al, arbitrary type

  00000	4c 8b c9	 mov	 r9, rcx

; 432  : 	for (; _First != _Last; ++_Dest, ++_First)

  00003	48 3b ca	 cmp	 rcx, rdx
  00006	74 3e		 je	 SHORT $LN4@Uninit_mov
  00008	45 33 d2	 xor	 r10d, r10d
  0000b	0f 1f 44 00 00	 npad	 5
$LL6@Uninit_mov:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 617  : _VARIADIC_EXPAND_0X(_ALLOC_MEMBER_CONSTRUCT, , , , )

  00010	4d 85 c0	 test	 r8, r8
  00013	74 24		 je	 SHORT $LN51@Uninit_mov
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 287  : 		{	// construct _Ptr_base object that takes resource from _Right

  00015	4d 89 10	 mov	 QWORD PTR [r8], r10
  00018	4d 89 50 08	 mov	 QWORD PTR [r8+8], r10

; 288  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 289  : 		}
; 290  : 
; 291  : 	template<class _Ty2>
; 292  : 		_Ptr_base(_Ptr_base<_Ty2>&& _Right)
; 293  : 		: _Ptr(_Right._Ptr), _Rep(_Right._Rep)
; 294  : 		{	// construct _Ptr_base object that takes resource from _Right
; 295  : 		_Right._Ptr = 0;
; 296  : 		_Right._Rep = 0;
; 297  : 		}
; 298  : 
; 299  : 	_Myt& operator=(_Myt&& _Right)
; 300  : 		{	// construct _Ptr_base object that takes resource from _Right
; 301  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 302  : 		return (*this);
; 303  : 		}
; 304  : 
; 305  : 	void _Assign_rv(_Myt&& _Right)
; 306  : 		{	// assign by moving _Right
; 307  : 		if (this != &_Right)

  0001c	4d 3b c1	 cmp	 r8, r9
  0001f	74 18		 je	 SHORT $LN51@Uninit_mov
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility

; 48   : 	_Left = _Move(_Right);

  00021	49 8b 41 08	 mov	 rax, QWORD PTR [r9+8]
  00025	49 89 40 08	 mov	 QWORD PTR [r8+8], rax

; 49   : 	_Right = _Move(_Tmp);

  00029	4d 89 51 08	 mov	 QWORD PTR [r9+8], r10

; 48   : 	_Left = _Move(_Right);

  0002d	49 8b 01	 mov	 rax, QWORD PTR [r9]
  00030	49 8b 08	 mov	 rcx, QWORD PTR [r8]
  00033	49 89 00	 mov	 QWORD PTR [r8], rax

; 49   : 	_Right = _Move(_Tmp);

  00036	49 89 09	 mov	 QWORD PTR [r9], rcx
$LN51@Uninit_mov:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory

; 432  : 	for (; _First != _Last; ++_Dest, ++_First)

  00039	49 83 c1 10	 add	 r9, 16
  0003d	49 83 c0 10	 add	 r8, 16
  00041	4c 3b ca	 cmp	 r9, rdx
  00044	75 ca		 jne	 SHORT $LL6@Uninit_mov
$LN4@Uninit_mov:

; 433  : 		_Al.construct(_Dest, (_Valty&&)*_First);
; 434  : 	_CATCH_ALL
; 435  : 	for (; _Next != _Dest; ++_Next)
; 436  : 		_Al.destroy(_Next);
; 437  : 	_RERAISE;
; 438  : 	_CATCH_END
; 439  : 	return (_Dest);

  00046	49 8b c0	 mov	 rax, r8

; 440  : 	}

  00049	c3		 ret	 0
??$_Uninit_move@PEAV?$shared_ptr@VChunkBase@@@std@@PEAV12@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@V12@@std@@YAPEAV?$shared_ptr@VChunkBase@@@0@PEAV10@00AEAU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_move<std::shared_ptr<ChunkBase> * __ptr64,std::shared_ptr<ChunkBase> * __ptr64,std::allocator<std::shared_ptr<ChunkBase> >,std::shared_ptr<ChunkBase> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@V?$shared_ptr@VChunkBase@@@std@@V12@@?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QEAAXPEAV?$shared_ptr@VChunkBase@@@1@$$QEAV21@@Z
_TEXT	SEGMENT
this$dead$ = 8
_Ptr$ = 16
_V0$ = 24
??$construct@V?$shared_ptr@VChunkBase@@@std@@V12@@?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QEAAXPEAV?$shared_ptr@VChunkBase@@@1@$$QEAV21@@Z PROC ; std::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> > >::construct<std::shared_ptr<ChunkBase>,std::shared_ptr<ChunkBase> >, COMDAT

; 617  : _VARIADIC_EXPAND_0X(_ALLOC_MEMBER_CONSTRUCT, , , , )

  00000	48 85 d2	 test	 rdx, rdx
  00003	74 26		 je	 SHORT $LN38@construct
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 287  : 		{	// construct _Ptr_base object that takes resource from _Right

  00005	33 c9		 xor	 ecx, ecx
  00007	48 89 0a	 mov	 QWORD PTR [rdx], rcx
  0000a	48 89 4a 08	 mov	 QWORD PTR [rdx+8], rcx

; 288  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 289  : 		}
; 290  : 
; 291  : 	template<class _Ty2>
; 292  : 		_Ptr_base(_Ptr_base<_Ty2>&& _Right)
; 293  : 		: _Ptr(_Right._Ptr), _Rep(_Right._Rep)
; 294  : 		{	// construct _Ptr_base object that takes resource from _Right
; 295  : 		_Right._Ptr = 0;
; 296  : 		_Right._Rep = 0;
; 297  : 		}
; 298  : 
; 299  : 	_Myt& operator=(_Myt&& _Right)
; 300  : 		{	// construct _Ptr_base object that takes resource from _Right
; 301  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 302  : 		return (*this);
; 303  : 		}
; 304  : 
; 305  : 	void _Assign_rv(_Myt&& _Right)
; 306  : 		{	// assign by moving _Right
; 307  : 		if (this != &_Right)

  0000e	49 3b d0	 cmp	 rdx, r8
  00011	74 18		 je	 SHORT $LN38@construct
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility

; 48   : 	_Left = _Move(_Right);

  00013	49 8b 40 08	 mov	 rax, QWORD PTR [r8+8]
  00017	48 89 42 08	 mov	 QWORD PTR [rdx+8], rax

; 49   : 	_Right = _Move(_Tmp);

  0001b	49 89 48 08	 mov	 QWORD PTR [r8+8], rcx

; 48   : 	_Left = _Move(_Right);

  0001f	49 8b 00	 mov	 rax, QWORD PTR [r8]
  00022	48 8b 0a	 mov	 rcx, QWORD PTR [rdx]
  00025	48 89 02	 mov	 QWORD PTR [rdx], rax

; 49   : 	_Right = _Move(_Tmp);

  00028	49 89 08	 mov	 QWORD PTR [r8], rcx
$LN38@construct:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 903  : _VARIADIC_EXPAND_0X(_WRAP_ALLOC_CONSTRUCT, , , , )

  0002b	f3 c3		 fatret	 0
??$construct@V?$shared_ptr@VChunkBase@@@std@@V12@@?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QEAAXPEAV?$shared_ptr@VChunkBase@@@1@$$QEAV21@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> > >::construct<std::shared_ptr<ChunkBase>,std::shared_ptr<ChunkBase> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\type_traits
;	COMDAT ??$forward@V?$shared_ptr@VChunkBase@@@std@@@std@@YA$$QEAV?$shared_ptr@VChunkBase@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@V?$shared_ptr@VChunkBase@@@std@@@std@@YA$$QEAV?$shared_ptr@VChunkBase@@@0@AEAV10@@Z PROC ; std::forward<std::shared_ptr<ChunkBase> >, COMDAT

; 1776 : 	return (static_cast<_Ty&&>(_Arg));

  00000	48 8b c1	 mov	 rax, rcx

; 1777 : 	}

  00003	c3		 ret	 0
??$forward@V?$shared_ptr@VChunkBase@@@std@@@std@@YA$$QEAV?$shared_ptr@VChunkBase@@@0@AEAV10@@Z ENDP ; std::forward<std::shared_ptr<ChunkBase> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@V?$shared_ptr@VChunkBase@@@std@@V12@@?$allocator_traits@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$shared_ptr@VChunkBase@@@std@@@1@PEAV?$shared_ptr@VChunkBase@@@1@$$QEAV31@@Z
_TEXT	SEGMENT
_Al$dead$ = 8
_Ptr$ = 16
_V0$ = 24
??$construct@V?$shared_ptr@VChunkBase@@@std@@V12@@?$allocator_traits@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$shared_ptr@VChunkBase@@@std@@@1@PEAV?$shared_ptr@VChunkBase@@@1@$$QEAV31@@Z PROC ; std::allocator_traits<std::allocator<std::shared_ptr<ChunkBase> > >::construct<std::shared_ptr<ChunkBase>,std::shared_ptr<ChunkBase> >, COMDAT

; 617  : _VARIADIC_EXPAND_0X(_ALLOC_MEMBER_CONSTRUCT, , , , )

  00000	48 85 d2	 test	 rdx, rdx
  00003	74 26		 je	 SHORT $LN34@construct
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 287  : 		{	// construct _Ptr_base object that takes resource from _Right

  00005	33 c9		 xor	 ecx, ecx
  00007	48 89 0a	 mov	 QWORD PTR [rdx], rcx
  0000a	48 89 4a 08	 mov	 QWORD PTR [rdx+8], rcx

; 288  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 289  : 		}
; 290  : 
; 291  : 	template<class _Ty2>
; 292  : 		_Ptr_base(_Ptr_base<_Ty2>&& _Right)
; 293  : 		: _Ptr(_Right._Ptr), _Rep(_Right._Rep)
; 294  : 		{	// construct _Ptr_base object that takes resource from _Right
; 295  : 		_Right._Ptr = 0;
; 296  : 		_Right._Rep = 0;
; 297  : 		}
; 298  : 
; 299  : 	_Myt& operator=(_Myt&& _Right)
; 300  : 		{	// construct _Ptr_base object that takes resource from _Right
; 301  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 302  : 		return (*this);
; 303  : 		}
; 304  : 
; 305  : 	void _Assign_rv(_Myt&& _Right)
; 306  : 		{	// assign by moving _Right
; 307  : 		if (this != &_Right)

  0000e	49 3b d0	 cmp	 rdx, r8
  00011	74 18		 je	 SHORT $LN34@construct
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility

; 48   : 	_Left = _Move(_Right);

  00013	49 8b 40 08	 mov	 rax, QWORD PTR [r8+8]
  00017	48 89 42 08	 mov	 QWORD PTR [rdx+8], rax

; 49   : 	_Right = _Move(_Tmp);

  0001b	49 89 48 08	 mov	 QWORD PTR [r8+8], rcx

; 48   : 	_Left = _Move(_Right);

  0001f	49 8b 00	 mov	 rax, QWORD PTR [r8]
  00022	48 8b 0a	 mov	 rcx, QWORD PTR [rdx]
  00025	48 89 02	 mov	 QWORD PTR [rdx], rax

; 49   : 	_Right = _Move(_Tmp);

  00028	49 89 08	 mov	 QWORD PTR [r8], rcx
$LN34@construct:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 751  : _VARIADIC_EXPAND_0X(_ALLOC_TRAITS_SPECIAL_CONSTRUCT, , , , )

  0002b	f3 c3		 fatret	 0
??$construct@V?$shared_ptr@VChunkBase@@@std@@V12@@?$allocator_traits@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$shared_ptr@VChunkBase@@@std@@@1@PEAV?$shared_ptr@VChunkBase@@@1@$$QEAV31@@Z ENDP ; std::allocator_traits<std::allocator<std::shared_ptr<ChunkBase> > >::construct<std::shared_ptr<ChunkBase>,std::shared_ptr<ChunkBase> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@V?$shared_ptr@VChunkBase@@@std@@V12@@?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAAXPEAV?$shared_ptr@VChunkBase@@@1@$$QEAV21@@Z
_TEXT	SEGMENT
this$dead$ = 8
_Ptr$ = 16
_V0$ = 24
??$construct@V?$shared_ptr@VChunkBase@@@std@@V12@@?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAAXPEAV?$shared_ptr@VChunkBase@@@1@$$QEAV21@@Z PROC ; std::allocator<std::shared_ptr<ChunkBase> >::construct<std::shared_ptr<ChunkBase>,std::shared_ptr<ChunkBase> >, COMDAT

; 617  : _VARIADIC_EXPAND_0X(_ALLOC_MEMBER_CONSTRUCT, , , , )

  00000	48 85 d2	 test	 rdx, rdx
  00003	74 26		 je	 SHORT $LN30@construct
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 287  : 		{	// construct _Ptr_base object that takes resource from _Right

  00005	33 c9		 xor	 ecx, ecx
  00007	48 89 0a	 mov	 QWORD PTR [rdx], rcx
  0000a	48 89 4a 08	 mov	 QWORD PTR [rdx+8], rcx

; 288  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 289  : 		}
; 290  : 
; 291  : 	template<class _Ty2>
; 292  : 		_Ptr_base(_Ptr_base<_Ty2>&& _Right)
; 293  : 		: _Ptr(_Right._Ptr), _Rep(_Right._Rep)
; 294  : 		{	// construct _Ptr_base object that takes resource from _Right
; 295  : 		_Right._Ptr = 0;
; 296  : 		_Right._Rep = 0;
; 297  : 		}
; 298  : 
; 299  : 	_Myt& operator=(_Myt&& _Right)
; 300  : 		{	// construct _Ptr_base object that takes resource from _Right
; 301  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 302  : 		return (*this);
; 303  : 		}
; 304  : 
; 305  : 	void _Assign_rv(_Myt&& _Right)
; 306  : 		{	// assign by moving _Right
; 307  : 		if (this != &_Right)

  0000e	49 3b d0	 cmp	 rdx, r8
  00011	74 18		 je	 SHORT $LN30@construct
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility

; 48   : 	_Left = _Move(_Right);

  00013	49 8b 40 08	 mov	 rax, QWORD PTR [r8+8]
  00017	48 89 42 08	 mov	 QWORD PTR [rdx+8], rax

; 49   : 	_Right = _Move(_Tmp);

  0001b	49 89 48 08	 mov	 QWORD PTR [r8+8], rcx

; 48   : 	_Left = _Move(_Right);

  0001f	49 8b 00	 mov	 rax, QWORD PTR [r8]
  00022	48 8b 0a	 mov	 rcx, QWORD PTR [rdx]
  00025	48 89 02	 mov	 QWORD PTR [rdx], rax

; 49   : 	_Right = _Move(_Tmp);

  00028	49 89 08	 mov	 QWORD PTR [r8], rcx
$LN30@construct:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 617  : _VARIADIC_EXPAND_0X(_ALLOC_MEMBER_CONSTRUCT, , , , )

  0002b	f3 c3		 fatret	 0
??$construct@V?$shared_ptr@VChunkBase@@@std@@V12@@?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAAXPEAV?$shared_ptr@VChunkBase@@@1@$$QEAV21@@Z ENDP ; std::allocator<std::shared_ptr<ChunkBase> >::construct<std::shared_ptr<ChunkBase>,std::shared_ptr<ChunkBase> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ??0?$shared_ptr@VChunkBase@@@std@@QEAA@$$QEAV01@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
??0?$shared_ptr@VChunkBase@@@std@@QEAA@$$QEAV01@@Z PROC	; std::shared_ptr<ChunkBase>::shared_ptr<ChunkBase>, COMDAT

; 287  : 		{	// construct _Ptr_base object that takes resource from _Right

  00000	45 33 c0	 xor	 r8d, r8d
  00003	4c 89 01	 mov	 QWORD PTR [rcx], r8
  00006	4c 89 41 08	 mov	 QWORD PTR [rcx+8], r8

; 288  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 289  : 		}
; 290  : 
; 291  : 	template<class _Ty2>
; 292  : 		_Ptr_base(_Ptr_base<_Ty2>&& _Right)
; 293  : 		: _Ptr(_Right._Ptr), _Rep(_Right._Rep)
; 294  : 		{	// construct _Ptr_base object that takes resource from _Right
; 295  : 		_Right._Ptr = 0;
; 296  : 		_Right._Rep = 0;
; 297  : 		}
; 298  : 
; 299  : 	_Myt& operator=(_Myt&& _Right)
; 300  : 		{	// construct _Ptr_base object that takes resource from _Right
; 301  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 302  : 		return (*this);
; 303  : 		}
; 304  : 
; 305  : 	void _Assign_rv(_Myt&& _Right)
; 306  : 		{	// assign by moving _Right
; 307  : 		if (this != &_Right)

  0000a	48 3b ca	 cmp	 rcx, rdx
  0000d	74 18		 je	 SHORT $LN30@shared_ptr
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility

; 48   : 	_Left = _Move(_Right);

  0000f	48 8b 42 08	 mov	 rax, QWORD PTR [rdx+8]
  00013	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 49   : 	_Right = _Move(_Tmp);

  00017	4c 89 42 08	 mov	 QWORD PTR [rdx+8], r8

; 48   : 	_Left = _Move(_Right);

  0001b	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  0001e	4c 8b 01	 mov	 r8, QWORD PTR [rcx]
  00021	48 89 01	 mov	 QWORD PTR [rcx], rax

; 49   : 	_Right = _Move(_Tmp);

  00024	4c 89 02	 mov	 QWORD PTR [rdx], r8
$LN30@shared_ptr:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 581  : 		}

  00027	48 8b c1	 mov	 rax, rcx
  0002a	c3		 ret	 0
??0?$shared_ptr@VChunkBase@@@std@@QEAA@$$QEAV01@@Z ENDP	; std::shared_ptr<ChunkBase>::shared_ptr<ChunkBase>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ??0?$_Ptr_base@VChunkBase@@@std@@QEAA@$$QEAV01@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
??0?$_Ptr_base@VChunkBase@@@std@@QEAA@$$QEAV01@@Z PROC	; std::_Ptr_base<ChunkBase>::_Ptr_base<ChunkBase>, COMDAT

; 287  : 		{	// construct _Ptr_base object that takes resource from _Right

  00000	45 33 c0	 xor	 r8d, r8d
  00003	4c 89 01	 mov	 QWORD PTR [rcx], r8
  00006	4c 89 41 08	 mov	 QWORD PTR [rcx+8], r8

; 290  : 
; 291  : 	template<class _Ty2>
; 292  : 		_Ptr_base(_Ptr_base<_Ty2>&& _Right)
; 293  : 		: _Ptr(_Right._Ptr), _Rep(_Right._Rep)
; 294  : 		{	// construct _Ptr_base object that takes resource from _Right
; 295  : 		_Right._Ptr = 0;
; 296  : 		_Right._Rep = 0;
; 297  : 		}
; 298  : 
; 299  : 	_Myt& operator=(_Myt&& _Right)
; 300  : 		{	// construct _Ptr_base object that takes resource from _Right
; 301  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 302  : 		return (*this);
; 303  : 		}
; 304  : 
; 305  : 	void _Assign_rv(_Myt&& _Right)
; 306  : 		{	// assign by moving _Right
; 307  : 		if (this != &_Right)

  0000a	48 3b ca	 cmp	 rcx, rdx
  0000d	74 18		 je	 SHORT $LN26@Ptr_base
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility

; 48   : 	_Left = _Move(_Right);

  0000f	48 8b 42 08	 mov	 rax, QWORD PTR [rdx+8]
  00013	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 49   : 	_Right = _Move(_Tmp);

  00017	4c 89 42 08	 mov	 QWORD PTR [rdx+8], r8

; 48   : 	_Left = _Move(_Right);

  0001b	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  0001e	4c 8b 01	 mov	 r8, QWORD PTR [rcx]
  00021	48 89 01	 mov	 QWORD PTR [rcx], rax

; 49   : 	_Right = _Move(_Tmp);

  00024	4c 89 02	 mov	 QWORD PTR [rdx], r8
$LN26@Ptr_base:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 289  : 		}

  00027	48 8b c1	 mov	 rax, rcx
  0002a	c3		 ret	 0
??0?$_Ptr_base@VChunkBase@@@std@@QEAA@$$QEAV01@@Z ENDP	; std::_Ptr_base<ChunkBase>::_Ptr_base<ChunkBase>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ?_Assign_rv@?$_Ptr_base@VChunkBase@@@std@@QEAAX$$QEAV12@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
?_Assign_rv@?$_Ptr_base@VChunkBase@@@std@@QEAAX$$QEAV12@@Z PROC ; std::_Ptr_base<ChunkBase>::_Assign_rv, COMDAT

; 307  : 		if (this != &_Right)

  00000	48 3b ca	 cmp	 rcx, rdx
  00003	74 1c		 je	 SHORT $LN14@Assign_rv
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility

; 48   : 	_Left = _Move(_Right);

  00005	48 8b 42 08	 mov	 rax, QWORD PTR [rdx+8]
  00009	4c 8b 41 08	 mov	 r8, QWORD PTR [rcx+8]
  0000d	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 49   : 	_Right = _Move(_Tmp);

  00011	4c 89 42 08	 mov	 QWORD PTR [rdx+8], r8

; 48   : 	_Left = _Move(_Right);

  00015	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  00018	4c 8b 01	 mov	 r8, QWORD PTR [rcx]
  0001b	48 89 01	 mov	 QWORD PTR [rcx], rax

; 49   : 	_Right = _Move(_Tmp);

  0001e	4c 89 02	 mov	 QWORD PTR [rdx], r8
$LN14@Assign_rv:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 309  : 		}

  00021	f3 c3		 fatret	 0
?_Assign_rv@?$_Ptr_base@VChunkBase@@@std@@QEAAX$$QEAV12@@Z ENDP ; std::_Ptr_base<ChunkBase>::_Assign_rv
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ?_Swap@?$_Ptr_base@VChunkBase@@@std@@QEAAXAEAV12@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
?_Swap@?$_Ptr_base@VChunkBase@@@std@@QEAAXAEAV12@@Z PROC ; std::_Ptr_base<ChunkBase>::_Swap, COMDAT
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility

; 48   : 	_Left = _Move(_Right);

  00000	48 8b 42 08	 mov	 rax, QWORD PTR [rdx+8]
  00004	4c 8b 41 08	 mov	 r8, QWORD PTR [rcx+8]
  00008	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 49   : 	_Right = _Move(_Tmp);

  0000c	4c 89 42 08	 mov	 QWORD PTR [rdx+8], r8

; 48   : 	_Left = _Move(_Right);

  00010	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  00013	4c 8b 01	 mov	 r8, QWORD PTR [rcx]
  00016	48 89 01	 mov	 QWORD PTR [rcx], rax

; 49   : 	_Right = _Move(_Tmp);

  00019	4c 89 02	 mov	 QWORD PTR [rdx], r8
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 320  : 		}

  0001c	c3		 ret	 0
?_Swap@?$_Ptr_base@VChunkBase@@@std@@QEAAXAEAV12@@Z ENDP ; std::_Ptr_base<ChunkBase>::_Swap
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\type_traits
;	COMDAT ??$forward@V?$_Ptr_base@VChunkBase@@@std@@@std@@YA$$QEAV?$_Ptr_base@VChunkBase@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@V?$_Ptr_base@VChunkBase@@@std@@@std@@YA$$QEAV?$_Ptr_base@VChunkBase@@@0@AEAV10@@Z PROC ; std::forward<std::_Ptr_base<ChunkBase> >, COMDAT

; 1776 : 	return (static_cast<_Ty&&>(_Arg));

  00000	48 8b c1	 mov	 rax, rcx

; 1777 : 	}

  00003	c3		 ret	 0
??$forward@V?$_Ptr_base@VChunkBase@@@std@@@std@@YA$$QEAV?$_Ptr_base@VChunkBase@@@0@AEAV10@@Z ENDP ; std::forward<std::_Ptr_base<ChunkBase> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
;	COMDAT ??$swap@PEAVChunkBase@@@std@@YAXAEAPEAVChunkBase@@0@Z
_TEXT	SEGMENT
_Left$ = 8
_Right$ = 16
??$swap@PEAVChunkBase@@@std@@YAXAEAPEAVChunkBase@@0@Z PROC ; std::swap<ChunkBase * __ptr64>, COMDAT

; 47   : 	_Ty _Tmp = _Move(_Left);
; 48   : 	_Left = _Move(_Right);

  00000	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  00003	4c 8b 01	 mov	 r8, QWORD PTR [rcx]
  00006	48 89 01	 mov	 QWORD PTR [rcx], rax

; 49   : 	_Right = _Move(_Tmp);

  00009	4c 89 02	 mov	 QWORD PTR [rdx], r8

; 50   : 	}

  0000c	c3		 ret	 0
??$swap@PEAVChunkBase@@@std@@YAXAEAPEAVChunkBase@@0@Z ENDP ; std::swap<ChunkBase * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\type_traits
;	COMDAT ??$_Move@AEAPEAVChunkBase@@@std@@YA$$QEAPEAVChunkBase@@AEAPEAV1@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$_Move@AEAPEAVChunkBase@@@std@@YA$$QEAPEAVChunkBase@@AEAPEAV1@@Z PROC ; std::_Move<ChunkBase * __ptr64 & __ptr64>, COMDAT

; 1799 : 	return ((typename remove_reference<_Ty>::type&&)_Arg);

  00000	48 8b c1	 mov	 rax, rcx

; 1800 : 	}

  00003	c3		 ret	 0
??$_Move@AEAPEAVChunkBase@@@std@@YA$$QEAPEAVChunkBase@@AEAPEAV1@@Z ENDP ; std::_Move<ChunkBase * __ptr64 & __ptr64>
_TEXT	ENDS
END
