; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.61030.0 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	?stop@GlobalThread@@3_NA			; GlobalThread::stop
PUBLIC	??_R4ChunkDrawThread@@6B@			; ChunkDrawThread::`RTTI Complete Object Locator'
PUBLIC	??_7Thread@@6B@					; Thread::`vftable'
PUBLIC	??_R2?$_LaunchPad@V?$_Bind@$00XQ6AXPEAVThread@@@ZV?$reference_wrapper@PEAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@std@@@std@@8 ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(Thread * __ptr64),std::reference_wrapper<Thread * __ptr64>,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil> >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@ChunkDrawThread@@8		; ChunkDrawThread::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3ChunkDrawThread@@8				; ChunkDrawThread::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2ChunkDrawThread@@8				; ChunkDrawThread::`RTTI Base Class Array'
PUBLIC	??_R0?AVChunkDrawThread@@@8			; ChunkDrawThread `RTTI Type Descriptor'
PUBLIC	??_R1A@?0A@EA@?$_LaunchPad@V?$_Bind@$00XQ6AXPEAVThread@@@ZV?$reference_wrapper@PEAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@std@@@std@@8 ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(Thread * __ptr64),std::reference_wrapper<Thread * __ptr64>,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@Thread@@8				; Thread::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@RenderThread@@8			; RenderThread::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVThread@@@8				; Thread `RTTI Type Descriptor'
PUBLIC	??_R0?AV?$_LaunchPad@V?$_Bind@$00XQ6AXPEAVThread@@@ZV?$reference_wrapper@PEAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@std@@@std@@@8 ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(Thread * __ptr64),std::reference_wrapper<Thread * __ptr64>,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil> > `RTTI Type Descriptor'
PUBLIC	??_R1A@?0A@EA@LimitedThread@@8			; LimitedThread::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_7ChunkLoadThread@@6B@			; ChunkLoadThread::`vftable'
PUBLIC	??_7ChunkDrawThread@@6B@			; ChunkDrawThread::`vftable'
PUBLIC	??_7RenderThread@@6B@				; RenderThread::`vftable'
PUBLIC	??_R2RenderThread@@8				; RenderThread::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@ChunkLoadThread@@8		; ChunkLoadThread::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVLimitedThread@@@8			; LimitedThread `RTTI Type Descriptor'
PUBLIC	??_R4ChunkLoadThread@@6B@			; ChunkLoadThread::`RTTI Complete Object Locator'
PUBLIC	??_R2ChunkLoadThread@@8				; ChunkLoadThread::`RTTI Base Class Array'
PUBLIC	??_R2Thread@@8					; Thread::`RTTI Base Class Array'
PUBLIC	??_R4Thread@@6B@				; Thread::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVChunkLoadThread@@@8			; ChunkLoadThread `RTTI Type Descriptor'
PUBLIC	??_R0?AVRenderThread@@@8			; RenderThread `RTTI Type Descriptor'
PUBLIC	??_7?$_LaunchPad@V?$_Bind@$00XQ6AXPEAVThread@@@ZV?$reference_wrapper@PEAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@std@@@std@@6B@ ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(Thread * __ptr64),std::reference_wrapper<Thread * __ptr64>,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil> >::`vftable'
PUBLIC	??_R3Thread@@8					; Thread::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R3LimitedThread@@8				; LimitedThread::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R3ChunkLoadThread@@8				; ChunkLoadThread::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R4LimitedThread@@6B@				; LimitedThread::`RTTI Complete Object Locator'
PUBLIC	??_R3?$_LaunchPad@V?$_Bind@$00XQ6AXPEAVThread@@@ZV?$reference_wrapper@PEAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@std@@@std@@8 ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(Thread * __ptr64),std::reference_wrapper<Thread * __ptr64>,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_7LimitedThread@@6B@				; LimitedThread::`vftable'
PUBLIC	??_R3RenderThread@@8				; RenderThread::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R4RenderThread@@6B@				; RenderThread::`RTTI Complete Object Locator'
PUBLIC	??_R4?$_LaunchPad@V?$_Bind@$00XQ6AXPEAVThread@@@ZV?$reference_wrapper@PEAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@std@@@std@@6B@ ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(Thread * __ptr64),std::reference_wrapper<Thread * __ptr64>,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil> >::`RTTI Complete Object Locator'
PUBLIC	??_R2LimitedThread@@8				; LimitedThread::`RTTI Base Class Array'
EXTRN	??_L@YAXPEAX_KHP6AX0@Z2@Z:PROC			; `eh vector constructor iterator'
EXTRN	_Thrd_current:PROC
EXTRN	_Thrd_join:PROC
EXTRN	??_M@YAXPEAX_KHP6AX0@Z@Z:PROC			; `eh vector destructor iterator'
EXTRN	_Xtime_get_ticks:PROC
EXTRN	?_Throw_Cpp_error@std@@YAXH@Z:PROC		; std::_Throw_Cpp_error
EXTRN	_Thrd_equal:PROC
?stop@GlobalThread@@3_NA DB 01H DUP (?)			; GlobalThread::stop
_BSS	ENDS
;	COMDAT ??_R2LimitedThread@@8
rdata$r	SEGMENT
??_R2LimitedThread@@8 DD imagerel ??_R1A@?0A@EA@LimitedThread@@8 ; LimitedThread::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@Thread@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R4?$_LaunchPad@V?$_Bind@$00XQ6AXPEAVThread@@@ZV?$reference_wrapper@PEAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@std@@@std@@6B@
rdata$r	SEGMENT
??_R4?$_LaunchPad@V?$_Bind@$00XQ6AXPEAVThread@@@ZV?$reference_wrapper@PEAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@std@@@std@@6B@ DD 01H ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(Thread * __ptr64),std::reference_wrapper<Thread * __ptr64>,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil> >::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AV?$_LaunchPad@V?$_Bind@$00XQ6AXPEAVThread@@@ZV?$reference_wrapper@PEAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@std@@@std@@@8
	DD	imagerel ??_R3?$_LaunchPad@V?$_Bind@$00XQ6AXPEAVThread@@@ZV?$reference_wrapper@PEAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@std@@@std@@8
	DD	imagerel ??_R4?$_LaunchPad@V?$_Bind@$00XQ6AXPEAVThread@@@ZV?$reference_wrapper@PEAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@std@@@std@@6B@
rdata$r	ENDS
;	COMDAT ??_R4RenderThread@@6B@
rdata$r	SEGMENT
??_R4RenderThread@@6B@ DD 01H				; RenderThread::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AVRenderThread@@@8
	DD	imagerel ??_R3RenderThread@@8
	DD	imagerel ??_R4RenderThread@@6B@
rdata$r	ENDS
;	COMDAT ??_R3RenderThread@@8
rdata$r	SEGMENT
??_R3RenderThread@@8 DD 00H				; RenderThread::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	imagerel ??_R2RenderThread@@8
rdata$r	ENDS
;	COMDAT ??_7LimitedThread@@6B@
CONST	SEGMENT
??_7LimitedThread@@6B@ DQ FLAT:??_R4LimitedThread@@6B@	; LimitedThread::`vftable'
	DQ	FLAT:?shouldTick@LimitedThread@@MEAA_NXZ
	DQ	FLAT:?preStart@Thread@@UEAAXXZ
	DQ	FLAT:?postStop@Thread@@UEAAXXZ
	DQ	FLAT:?start@Thread@@UEAA_NXZ
	DQ	FLAT:?stop@Thread@@UEAA_NXZ
	DQ	FLAT:_purecall
CONST	ENDS
;	COMDAT ??_R3?$_LaunchPad@V?$_Bind@$00XQ6AXPEAVThread@@@ZV?$reference_wrapper@PEAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@std@@@std@@8
rdata$r	SEGMENT
??_R3?$_LaunchPad@V?$_Bind@$00XQ6AXPEAVThread@@@ZV?$reference_wrapper@PEAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@std@@@std@@8 DD 00H ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(Thread * __ptr64),std::reference_wrapper<Thread * __ptr64>,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	imagerel ??_R2?$_LaunchPad@V?$_Bind@$00XQ6AXPEAVThread@@@ZV?$reference_wrapper@PEAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R4LimitedThread@@6B@
rdata$r	SEGMENT
??_R4LimitedThread@@6B@ DD 01H				; LimitedThread::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AVLimitedThread@@@8
	DD	imagerel ??_R3LimitedThread@@8
	DD	imagerel ??_R4LimitedThread@@6B@
rdata$r	ENDS
;	COMDAT ??_R3ChunkLoadThread@@8
rdata$r	SEGMENT
??_R3ChunkLoadThread@@8 DD 00H				; ChunkLoadThread::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	imagerel ??_R2ChunkLoadThread@@8
rdata$r	ENDS
;	COMDAT ??_R3LimitedThread@@8
rdata$r	SEGMENT
??_R3LimitedThread@@8 DD 00H				; LimitedThread::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	imagerel ??_R2LimitedThread@@8
rdata$r	ENDS
;	COMDAT ??_R3Thread@@8
rdata$r	SEGMENT
??_R3Thread@@8 DD 00H					; Thread::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	imagerel ??_R2Thread@@8
rdata$r	ENDS
;	COMDAT ??_7?$_LaunchPad@V?$_Bind@$00XQ6AXPEAVThread@@@ZV?$reference_wrapper@PEAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@std@@@std@@6B@
CONST	SEGMENT
??_7?$_LaunchPad@V?$_Bind@$00XQ6AXPEAVThread@@@ZV?$reference_wrapper@PEAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@std@@@std@@6B@ DQ FLAT:??_R4?$_LaunchPad@V?$_Bind@$00XQ6AXPEAVThread@@@ZV?$reference_wrapper@PEAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@std@@@std@@6B@ ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(Thread * __ptr64),std::reference_wrapper<Thread * __ptr64>,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil> >::`vftable'
	DQ	FLAT:?_Go@?$_LaunchPad@V?$_Bind@$00XQ6AXPEAVThread@@@ZV?$reference_wrapper@PEAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@std@@@std@@UEAAIXZ
CONST	ENDS
;	COMDAT ??_R0?AVRenderThread@@@8
_DATA	SEGMENT
??_R0?AVRenderThread@@@8 DQ FLAT:??_7type_info@@6B@	; RenderThread `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVRenderThread@@', 00H
_DATA	ENDS
;	COMDAT ??_R0?AVChunkLoadThread@@@8
_DATA	SEGMENT
??_R0?AVChunkLoadThread@@@8 DQ FLAT:??_7type_info@@6B@	; ChunkLoadThread `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVChunkLoadThread@@', 00H
_DATA	ENDS
;	COMDAT ??_R4Thread@@6B@
rdata$r	SEGMENT
??_R4Thread@@6B@ DD 01H					; Thread::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AVThread@@@8
	DD	imagerel ??_R3Thread@@8
	DD	imagerel ??_R4Thread@@6B@
rdata$r	ENDS
;	COMDAT ??_R2Thread@@8
rdata$r	SEGMENT
??_R2Thread@@8 DD imagerel ??_R1A@?0A@EA@Thread@@8	; Thread::`RTTI Base Class Array'
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R2ChunkLoadThread@@8
rdata$r	SEGMENT
??_R2ChunkLoadThread@@8 DD imagerel ??_R1A@?0A@EA@ChunkLoadThread@@8 ; ChunkLoadThread::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@Thread@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R4ChunkLoadThread@@6B@
rdata$r	SEGMENT
??_R4ChunkLoadThread@@6B@ DD 01H			; ChunkLoadThread::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AVChunkLoadThread@@@8
	DD	imagerel ??_R3ChunkLoadThread@@8
	DD	imagerel ??_R4ChunkLoadThread@@6B@
rdata$r	ENDS
;	COMDAT ??_R0?AVLimitedThread@@@8
_DATA	SEGMENT
??_R0?AVLimitedThread@@@8 DQ FLAT:??_7type_info@@6B@	; LimitedThread `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVLimitedThread@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@ChunkLoadThread@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@ChunkLoadThread@@8 DD imagerel ??_R0?AVChunkLoadThread@@@8 ; ChunkLoadThread::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3ChunkLoadThread@@8
rdata$r	ENDS
;	COMDAT ??_R2RenderThread@@8
rdata$r	SEGMENT
??_R2RenderThread@@8 DD imagerel ??_R1A@?0A@EA@RenderThread@@8 ; RenderThread::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@Thread@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_7RenderThread@@6B@
CONST	SEGMENT
??_7RenderThread@@6B@ DQ FLAT:??_R4RenderThread@@6B@	; RenderThread::`vftable'
	DQ	FLAT:?shouldTick@Thread@@MEAA_NXZ
	DQ	FLAT:?preStart@RenderThread@@UEAAXXZ
	DQ	FLAT:?postStop@RenderThread@@UEAAXXZ
	DQ	FLAT:?start@Thread@@UEAA_NXZ
	DQ	FLAT:?stop@Thread@@UEAA_NXZ
	DQ	FLAT:?tick@RenderThread@@EEAA_NXZ
CONST	ENDS
;	COMDAT ??_7ChunkDrawThread@@6B@
CONST	SEGMENT
??_7ChunkDrawThread@@6B@ DQ FLAT:??_R4ChunkDrawThread@@6B@ ; ChunkDrawThread::`vftable'
	DQ	FLAT:?shouldTick@Thread@@MEAA_NXZ
	DQ	FLAT:?preStart@Thread@@UEAAXXZ
	DQ	FLAT:?postStop@Thread@@UEAAXXZ
	DQ	FLAT:?start@Thread@@UEAA_NXZ
	DQ	FLAT:?stop@Thread@@UEAA_NXZ
	DQ	FLAT:?tick@ChunkDrawThread@@MEAA_NXZ
CONST	ENDS
;	COMDAT ??_7ChunkLoadThread@@6B@
CONST	SEGMENT
??_7ChunkLoadThread@@6B@ DQ FLAT:??_R4ChunkLoadThread@@6B@ ; ChunkLoadThread::`vftable'
	DQ	FLAT:?shouldTick@Thread@@MEAA_NXZ
	DQ	FLAT:?preStart@ChunkLoadThread@@MEAAXXZ
	DQ	FLAT:?postStop@Thread@@UEAAXXZ
	DQ	FLAT:?start@Thread@@UEAA_NXZ
	DQ	FLAT:?stop@Thread@@UEAA_NXZ
	DQ	FLAT:?tick@ChunkLoadThread@@MEAA_NXZ
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@LimitedThread@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@LimitedThread@@8 DD imagerel ??_R0?AVLimitedThread@@@8 ; LimitedThread::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3LimitedThread@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$_LaunchPad@V?$_Bind@$00XQ6AXPEAVThread@@@ZV?$reference_wrapper@PEAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@std@@@std@@@8
_DATA	SEGMENT
??_R0?AV?$_LaunchPad@V?$_Bind@$00XQ6AXPEAVThread@@@ZV?$reference_wrapper@PEAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@std@@@std@@@8 DQ FLAT:??_7type_info@@6B@ ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(Thread * __ptr64),std::reference_wrapper<Thread * __ptr64>,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil> > `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AV?$_LaunchPad@V?$_Bind@$00XQ6AXPEAVThread@@@ZV?$refer'
	DB	'ence_wrapper@PEAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@s'
	DB	'td@@@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R0?AVThread@@@8
_DATA	SEGMENT
??_R0?AVThread@@@8 DQ FLAT:??_7type_info@@6B@		; Thread `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVThread@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@RenderThread@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@RenderThread@@8 DD imagerel ??_R0?AVRenderThread@@@8 ; RenderThread::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3RenderThread@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@Thread@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@Thread@@8 DD imagerel ??_R0?AVThread@@@8	; Thread::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3Thread@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$_LaunchPad@V?$_Bind@$00XQ6AXPEAVThread@@@ZV?$reference_wrapper@PEAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$_LaunchPad@V?$_Bind@$00XQ6AXPEAVThread@@@ZV?$reference_wrapper@PEAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@std@@@std@@8 DD imagerel ??_R0?AV?$_LaunchPad@V?$_Bind@$00XQ6AXPEAVThread@@@ZV?$reference_wrapper@PEAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@std@@@std@@@8 ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(Thread * __ptr64),std::reference_wrapper<Thread * __ptr64>,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3?$_LaunchPad@V?$_Bind@$00XQ6AXPEAVThread@@@ZV?$reference_wrapper@PEAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVChunkDrawThread@@@8
_DATA	SEGMENT
??_R0?AVChunkDrawThread@@@8 DQ FLAT:??_7type_info@@6B@	; ChunkDrawThread `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVChunkDrawThread@@', 00H
_DATA	ENDS
;	COMDAT ??_R2ChunkDrawThread@@8
rdata$r	SEGMENT
??_R2ChunkDrawThread@@8 DD imagerel ??_R1A@?0A@EA@ChunkDrawThread@@8 ; ChunkDrawThread::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@Thread@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3ChunkDrawThread@@8
rdata$r	SEGMENT
??_R3ChunkDrawThread@@8 DD 00H				; ChunkDrawThread::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	imagerel ??_R2ChunkDrawThread@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@ChunkDrawThread@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@ChunkDrawThread@@8 DD imagerel ??_R0?AVChunkDrawThread@@@8 ; ChunkDrawThread::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3ChunkDrawThread@@8
rdata$r	ENDS
;	COMDAT ??_R2?$_LaunchPad@V?$_Bind@$00XQ6AXPEAVThread@@@ZV?$reference_wrapper@PEAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@std@@@std@@8
rdata$r	SEGMENT
??_R2?$_LaunchPad@V?$_Bind@$00XQ6AXPEAVThread@@@ZV?$reference_wrapper@PEAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@std@@@std@@8 DD imagerel ??_R1A@?0A@EA@?$_LaunchPad@V?$_Bind@$00XQ6AXPEAVThread@@@ZV?$reference_wrapper@PEAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@std@@@std@@8 ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(Thread * __ptr64),std::reference_wrapper<Thread * __ptr64>,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil> >::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@_Pad@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_7Thread@@6B@
CONST	SEGMENT
??_7Thread@@6B@ DQ FLAT:??_R4Thread@@6B@		; Thread::`vftable'
	DQ	FLAT:?shouldTick@Thread@@MEAA_NXZ
	DQ	FLAT:?preStart@Thread@@UEAAXXZ
	DQ	FLAT:?postStop@Thread@@UEAAXXZ
	DQ	FLAT:?start@Thread@@UEAA_NXZ
	DQ	FLAT:?stop@Thread@@UEAA_NXZ
	DQ	FLAT:_purecall
CONST	ENDS
;	COMDAT ??_R4ChunkDrawThread@@6B@
rdata$r	SEGMENT
??_R4ChunkDrawThread@@6B@ DD 01H			; ChunkDrawThread::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AVChunkDrawThread@@@8
	DD	imagerel ??_R3ChunkDrawThread@@8
	DD	imagerel ??_R4ChunkDrawThread@@6B@
PUBLIC	??$?0V?$reference_wrapper@PEAVThread@@@std@@@?$tuple@V?$reference_wrapper@PEAVThread@@@std@@U_Nil@2@U32@U32@U32@U32@U32@U32@@std@@QEAA@$$QEAV?$reference_wrapper@PEAVThread@@@1@PEAPEAX@Z ; std::tuple<std::reference_wrapper<Thread * __ptr64>,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::tuple<std::reference_wrapper<Thread * __ptr64>,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil><std::reference_wrapper<Thread * __ptr64> >
PUBLIC	??$forward@AEAP6AXPEAVThread@@@Z@std@@YAAEAP6AXPEAVThread@@@ZAEAP6AX0@Z@Z ; std::forward<void (__cdecl*& __ptr64)(Thread * __ptr64)>
PUBLIC	?get@?$reference_wrapper@PEAVThread@@@std@@QEBAAEAPEAVThread@@XZ ; std::reference_wrapper<Thread * __ptr64>::get
PUBLIC	??$?0V?$reference_wrapper@PEAVThread@@@std@@@?$_Tuple_val@V?$reference_wrapper@PEAVThread@@@std@@@std@@QEAA@$$QEAV?$reference_wrapper@PEAVThread@@@1@@Z ; std::_Tuple_val<std::reference_wrapper<Thread * __ptr64> >::_Tuple_val<std::reference_wrapper<Thread * __ptr64> ><std::reference_wrapper<Thread * __ptr64> >
PUBLIC	??$_Fixarg@AEAP6AXPEAVThread@@@ZV?$reference_wrapper@PEAVThread@@@std@@V?$tuple@V?$reference_wrapper@PEAVThread@@@std@@U_Nil@2@U32@U32@U32@U32@U32@U32@@3@V?$tuple@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@3@@std@@YAAEAPEAVThread@@AEAP6AXPEAV1@@ZAEAV?$tuple@V?$reference_wrapper@PEAVThread@@@std@@U_Nil@2@U32@U32@U32@U32@U32@U32@@0@AEAV?$tuple@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@0@AEAV?$reference_wrapper@PEAVThread@@@0@@Z ; std::_Fixarg<void (__cdecl*& __ptr64)(Thread * __ptr64),std::reference_wrapper<Thread * __ptr64>,std::tuple<std::reference_wrapper<Thread * __ptr64>,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>,std::tuple<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil> >
PUBLIC	??$get@$0A@V?$reference_wrapper@PEAVThread@@@std@@@std@@YAAEAV?$reference_wrapper@PEAVThread@@@0@AEAV?$tuple@V?$reference_wrapper@PEAVThread@@@std@@U_Nil@2@U32@U32@U32@U32@U32@U32@@0@@Z ; std::get<0,std::reference_wrapper<Thread * __ptr64> >
PUBLIC	??$forward@V?$tuple@V?$reference_wrapper@PEAVThread@@@std@@U_Nil@2@U32@U32@U32@U32@U32@U32@@std@@@std@@YA$$QEAV?$tuple@V?$reference_wrapper@PEAVThread@@@std@@U_Nil@2@U32@U32@U32@U32@U32@U32@@0@AEAV10@@Z ; std::forward<std::tuple<std::reference_wrapper<Thread * __ptr64>,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil> >
PUBLIC	??$addressof@PEAVThread@@@std@@YAPEAPEAVThread@@AEAPEAV1@@Z ; std::addressof<Thread * __ptr64>
PUBLIC	??$forward@AEAPEAVThread@@@std@@YAAEAPEAVThread@@AEAPEAV1@@Z ; std::forward<Thread * __ptr64 & __ptr64>
PUBLIC	??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QEAAXPEAU_Container_proxy@1@$$QEAU21@@Z ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>
PUBLIC	??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QEAAXPEAU_Container_proxy@1@@Z ; std::allocator<std::_Container_proxy>::destroy<std::_Container_proxy>
PUBLIC	??$destroy@PEAV?$shared_ptr@VChunkBase@@@std@@@?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAAXPEAPEAV?$shared_ptr@VChunkBase@@@1@@Z ; std::allocator<std::shared_ptr<ChunkBase> >::destroy<std::shared_ptr<ChunkBase> * __ptr64>
PUBLIC	??$?0V?$_Bind@$00XQ6AXPEAVThread@@@ZV?$reference_wrapper@PEAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@std@@@?$_LaunchPad@V?$_Bind@$00XQ6AXPEAVThread@@@ZV?$reference_wrapper@PEAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@std@@@std@@QEAA@$$QEAV?$_Bind@$00XQ6AXPEAVThread@@@ZV?$reference_wrapper@PEAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@1@@Z ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(Thread * __ptr64),std::reference_wrapper<Thread * __ptr64>,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil> >::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(Thread * __ptr64),std::reference_wrapper<Thread * __ptr64>,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil> ><std::_Bind<1,void,void (__cdecl*const)(Thread * __ptr64),std::reference_wrapper<Thread * __ptr64>,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil> >
PUBLIC	??$forward@V?$_Bind@$00XQ6AXPEAVThread@@@ZV?$reference_wrapper@PEAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@std@@@std@@YA$$QEAV?$_Bind@$00XQ6AXPEAVThread@@@ZV?$reference_wrapper@PEAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@0@AEAV10@@Z ; std::forward<std::_Bind<1,void,void (__cdecl*const)(Thread * __ptr64),std::reference_wrapper<Thread * __ptr64>,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil> >
PUBLIC	??$?0AEAP6AXPEAVThread@@@ZV?$reference_wrapper@PEAVThread@@@std@@@?$_Bind@$00XQ6AXPEAVThread@@@ZV?$reference_wrapper@PEAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@std@@QEAA@AEAP6AXPEAVThread@@@Z$$QEAV?$reference_wrapper@PEAVThread@@@1@@Z ; std::_Bind<1,void,void (__cdecl*const)(Thread * __ptr64),std::reference_wrapper<Thread * __ptr64>,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::_Bind<1,void,void (__cdecl*const)(Thread * __ptr64),std::reference_wrapper<Thread * __ptr64>,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil><void (__cdecl*& __ptr64)(Thread * __ptr64),std::reference_wrapper<Thread * __ptr64> >
PUBLIC	?_Get_rest@?$tuple@V?$reference_wrapper@PEAVThread@@@std@@U_Nil@2@U32@U32@U32@U32@U32@U32@@std@@QEAAAEAV?$tuple@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@2@XZ ; std::tuple<std::reference_wrapper<Thread * __ptr64>,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::_Get_rest
PUBLIC	??0?$tuple@V?$reference_wrapper@PEAVThread@@@std@@U_Nil@2@U32@U32@U32@U32@U32@U32@@std@@QEAA@$$QEAV01@@Z ; std::tuple<std::reference_wrapper<Thread * __ptr64>,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::tuple<std::reference_wrapper<Thread * __ptr64>,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>
PUBLIC	??R?$_Bind@$00XQ6AXPEAVThread@@@ZV?$reference_wrapper@PEAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@std@@QEAAXXZ ; std::_Bind<1,void,void (__cdecl*const)(Thread * __ptr64),std::reference_wrapper<Thread * __ptr64>,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::operator()
PUBLIC	??0?$_Bind@$00XQ6AXPEAVThread@@@ZV?$reference_wrapper@PEAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@std@@QEAA@$$QEAV01@@Z ; std::_Bind<1,void,void (__cdecl*const)(Thread * __ptr64),std::reference_wrapper<Thread * __ptr64>,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::_Bind<1,void,void (__cdecl*const)(Thread * __ptr64),std::reference_wrapper<Thread * __ptr64>,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>
PUBLIC	?_Run@?$_LaunchPad@V?$_Bind@$00XQ6AXPEAVThread@@@ZV?$reference_wrapper@PEAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@std@@@std@@CAIPEAV12@@Z ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(Thread * __ptr64),std::reference_wrapper<Thread * __ptr64>,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil> >::_Run
PUBLIC	?_Go@?$_LaunchPad@V?$_Bind@$00XQ6AXPEAVThread@@@ZV?$reference_wrapper@PEAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@std@@@std@@UEAAIXZ ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(Thread * __ptr64),std::reference_wrapper<Thread * __ptr64>,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil> >::_Go
PUBLIC	??0?$_Callable_base@PEAVThread@@$00@std@@QEAA@AEAPEAVThread@@@Z ; std::_Callable_base<Thread * __ptr64,1>::_Callable_base<Thread * __ptr64,1>
PUBLIC	??Z?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@chrono@std@@QEAAAEAV012@AEBV012@@Z ; std::chrono::duration<__int64,std::ratio<1,10000000> >::operator-=
PUBLIC	??1?$_LaunchPad@V?$_Bind@$00XQ6AXPEAVThread@@@ZV?$reference_wrapper@PEAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@std@@@std@@QEAA@XZ ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(Thread * __ptr64),std::reference_wrapper<Thread * __ptr64>,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil> >::~_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(Thread * __ptr64),std::reference_wrapper<Thread * __ptr64>,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil> >
PUBLIC	??$?0AEAPEAVThread@@@?$_Callable_obj@PEAVThread@@$00@std@@QEAA@AEAPEAVThread@@@Z ; std::_Callable_obj<Thread * __ptr64,1>::_Callable_obj<Thread * __ptr64,1><Thread * __ptr64 & __ptr64>
PUBLIC	??$construct@U_Container_proxy@std@@U12@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAEAV?$allocator@U_Container_proxy@std@@@1@PEAU_Container_proxy@1@$$QEAU31@@Z ; std::allocator_traits<std::allocator<std::_Container_proxy> >::construct<std::_Container_proxy,std::_Container_proxy>
PUBLIC	??$forward@U_Container_proxy@std@@@std@@YA$$QEAU_Container_proxy@0@AEAU10@@Z ; std::forward<std::_Container_proxy>
PUBLIC	??$destroy@U_Container_proxy@std@@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAEAV?$allocator@U_Container_proxy@std@@@1@PEAU_Container_proxy@1@@Z ; std::allocator_traits<std::allocator<std::_Container_proxy> >::destroy<std::_Container_proxy>
PUBLIC	??$destroy@PEAV?$shared_ptr@VChunkBase@@@std@@@?$allocator_traits@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$shared_ptr@VChunkBase@@@std@@@1@PEAPEAV?$shared_ptr@VChunkBase@@@1@@Z ; std::allocator_traits<std::allocator<std::shared_ptr<ChunkBase> > >::destroy<std::shared_ptr<ChunkBase> * __ptr64>
PUBLIC	??$?0_J@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEAA@AEB_JPEAPEAX@Z ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::duration<__int64,std::ratio<1,1000000000> ><__int64>
PUBLIC	??$?G_JU?$ratio@$00$0JIJGIA@@std@@_JU01@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@01@AEBV201@0@Z ; std::chrono::operator-<__int64,std::ratio<1,10000000>,__int64,std::ratio<1,10000000> >
PUBLIC	??$_Launch@V?$_Bind@$00XQ6AXPEAVThread@@@ZV?$reference_wrapper@PEAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@std@@@std@@YAXPEAU_Thrd_imp_t@@$$QEAV?$_Bind@$00XQ6AXPEAVThread@@@ZV?$reference_wrapper@PEAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@0@@Z ; std::_Launch<std::_Bind<1,void,void (__cdecl*const)(Thread * __ptr64),std::reference_wrapper<Thread * __ptr64>,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil> >
PUBLIC	??$bind@XPEAVThread@@V?$reference_wrapper@PEAVThread@@@std@@@std@@YA?AV?$_Bind@$00XQ6AXPEAVThread@@@ZV?$reference_wrapper@PEAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@0@P6AXPEAVThread@@@Z$$QEAV?$reference_wrapper@PEAVThread@@@0@@Z ; std::bind<void,Thread * __ptr64,std::reference_wrapper<Thread * __ptr64> >
PUBLIC	??$forward@V?$reference_wrapper@PEAVThread@@@std@@@std@@YA$$QEAV?$reference_wrapper@PEAVThread@@@0@AEAV10@@Z ; std::forward<std::reference_wrapper<Thread * __ptr64> >
PUBLIC	??$_Decay_copy@P6AXPEAVThread@@@Z@std@@YAP6AXPEAVThread@@@Z$$QEAP6AX0@Z@Z ; std::_Decay_copy<void (__cdecl*)(Thread * __ptr64)>
PUBLIC	??$forward@P6AXPEAVThread@@@Z@std@@YA$$QEAP6AXPEAVThread@@@ZAEAP6AX0@Z@Z ; std::forward<void (__cdecl*)(Thread * __ptr64)>
PUBLIC	??0?$_Call_wrapper_base@U?$_Callable_obj@PEAVThread@@$00@std@@@std@@QEAA@AEAPEAVThread@@@Z ; std::_Call_wrapper_base<std::_Callable_obj<Thread * __ptr64,1> >::_Call_wrapper_base<std::_Callable_obj<Thread * __ptr64,1> >
PUBLIC	?_Get@?$_Callable_base@PEAVThread@@$00@std@@QEBAAEAPEAVThread@@XZ ; std::_Callable_base<Thread * __ptr64,1>::_Get
PUBLIC	??0?$_Call_wrapper@U?$_Callable_obj@PEAVThread@@$00@std@@$0A@@std@@QEAA@AEAPEAVThread@@@Z ; std::_Call_wrapper<std::_Callable_obj<Thread * __ptr64,1>,0>::_Call_wrapper<std::_Callable_obj<Thread * __ptr64,1>,0>
PUBLIC	?_Get@?$_Call_wrapper_base@U?$_Callable_obj@PEAVThread@@$00@std@@@std@@QEBAAEAPEAVThread@@XZ ; std::_Call_wrapper_base<std::_Callable_obj<Thread * __ptr64,1> >::_Get
PUBLIC	??0?$_Refwrap_impl@PEAVThread@@@std@@QEAA@AEAPEAVThread@@@Z ; std::_Refwrap_impl<Thread * __ptr64>::_Refwrap_impl<Thread * __ptr64>
PUBLIC	??B?$reference_wrapper@PEAVThread@@@std@@QEBAAEAPEAVThread@@XZ ; std::reference_wrapper<Thread * __ptr64>::operator Thread * __ptr64 & __ptr64
PUBLIC	??0?$reference_wrapper@PEAVThread@@@std@@QEAA@AEAPEAVThread@@@Z ; std::reference_wrapper<Thread * __ptr64>::reference_wrapper<Thread * __ptr64>
PUBLIC	??$_Allocate@U_Container_proxy@std@@@std@@YAPEAU_Container_proxy@0@_KPEAU10@@Z ; std::_Allocate<std::_Container_proxy>
PUBLIC	??$construct@U_Container_proxy@std@@U12@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QEAAXPEAU_Container_proxy@1@$$QEAU21@@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::construct<std::_Container_proxy,std::_Container_proxy>
PUBLIC	??$destroy@U_Container_proxy@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QEAAXPEAU_Container_proxy@1@@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::destroy<std::_Container_proxy>
PUBLIC	??$destroy@PEAV?$shared_ptr@VChunkBase@@@std@@@?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QEAAXPEAPEAV?$shared_ptr@VChunkBase@@@1@@Z ; std::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> > >::destroy<std::shared_ptr<ChunkBase> * __ptr64>
PUBLIC	??$duration_cast@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@_JU?$ratio@$00$0JIJGIA@@3@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@AEBV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@01@@Z ; std::chrono::duration_cast<std::chrono::duration<__int64,std::ratio<1,1000000000> >,__int64,std::ratio<1,10000000> >
PUBLIC	??$?GUsystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@12@V312@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@01@AEBV?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@01@0@Z ; std::chrono::operator-<std::chrono::system_clock,std::chrono::duration<__int64,std::ratio<1,10000000> >,std::chrono::duration<__int64,std::ratio<1,10000000> > >
PUBLIC	??$?0P6AXPEAVThread@@@ZV?$reference_wrapper@PEAVThread@@@std@@@thread@std@@QEAA@P6AXPEAVThread@@@Z$$QEAV?$reference_wrapper@PEAVThread@@@1@@Z ; std::thread::thread<void (__cdecl*)(Thread * __ptr64),std::reference_wrapper<Thread * __ptr64> >
PUBLIC	??$ref@PEAVThread@@@std@@YA?AV?$reference_wrapper@PEAVThread@@@0@AEAPEAVThread@@@Z ; std::ref<Thread * __ptr64>
PUBLIC	??$?0_J@?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@chrono@std@@QEAA@AEB_JPEAPEAX@Z ; std::chrono::duration<__int64,std::ratio<1,10000000> >::duration<__int64,std::ratio<1,10000000> ><__int64>
PUBLIC	?allocate@?$allocator@U_Container_proxy@std@@@std@@QEAAPEAU_Container_proxy@2@_K@Z ; std::allocator<std::_Container_proxy>::allocate
PUBLIC	?deallocate@?$allocator@U_Container_proxy@std@@@std@@QEAAXPEAU_Container_proxy@2@_K@Z ; std::allocator<std::_Container_proxy>::deallocate
PUBLIC	??0?$allocator@U_Container_proxy@std@@@std@@QEAA@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QEAAPEAU_Container_proxy@2@_K@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::allocate
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QEAAXPEAU_Container_proxy@2@_K@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::deallocate
PUBLIC	??0?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QEAA@XZ ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::_Wrap_alloc<std::allocator<std::_Container_proxy> >
PUBLIC	??0?$_Deque_val@U?$_Deque_simple_types@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QEAA@XZ ; std::_Deque_val<std::_Deque_simple_types<std::shared_ptr<ChunkBase> > >::_Deque_val<std::_Deque_simple_types<std::shared_ptr<ChunkBase> > >
PUBLIC	?_Alloc_proxy@?$_Deque_alloc@$0A@U?$_Deque_base_types@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@@std@@QEAAXXZ ; std::_Deque_alloc<0,std::_Deque_base_types<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > > >::_Alloc_proxy
PUBLIC	?_Free_proxy@?$_Deque_alloc@$0A@U?$_Deque_base_types@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@@std@@QEAAXXZ ; std::_Deque_alloc<0,std::_Deque_base_types<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > > >::_Free_proxy
PUBLIC	??0?$_Deque_alloc@$0A@U?$_Deque_base_types@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@@std@@QEAA@AEBV?$allocator@V?$shared_ptr@VChunkBase@@@std@@@1@@Z ; std::_Deque_alloc<0,std::_Deque_base_types<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > > >::_Deque_alloc<0,std::_Deque_base_types<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > > >
PUBLIC	?pop_back@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAAXXZ ; std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::pop_back
PUBLIC	??1?$_Deque_val@U?$_Deque_simple_types@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QEAA@XZ ; std::_Deque_val<std::_Deque_simple_types<std::shared_ptr<ChunkBase> > >::~_Deque_val<std::_Deque_simple_types<std::shared_ptr<ChunkBase> > >
PUBLIC	??1?$_Deque_alloc@$0A@U?$_Deque_base_types@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@@std@@QEAA@XZ ; std::_Deque_alloc<0,std::_Deque_base_types<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > > >::~_Deque_alloc<0,std::_Deque_base_types<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > > >
PUBLIC	?_Tidy@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAXXZ ; std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::_Tidy
PUBLIC	??0?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAA@XZ ; std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >
PUBLIC	?count@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEBA_JXZ ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::count
PUBLIC	??1?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAA@XZ ; std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::~deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >
PUBLIC	??0?$queue@V?$shared_ptr@VChunkBase@@@std@@V?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@2@@std@@QEAA@XZ ; std::queue<std::shared_ptr<ChunkBase>,std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > > >::queue<std::shared_ptr<ChunkBase>,std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > > >
PUBLIC	?count@?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@chrono@std@@QEBA_JXZ ; std::chrono::duration<__int64,std::ratio<1,10000000> >::count
PUBLIC	?time_since_epoch@?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@chrono@std@@QEBA?AV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@XZ ; std::chrono::time_point<std::chrono::system_clock,std::chrono::duration<__int64,std::ratio<1,10000000> > >::time_since_epoch
PUBLIC	??0?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@chrono@std@@QEAA@AEBV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@12@@Z ; std::chrono::time_point<std::chrono::system_clock,std::chrono::duration<__int64,std::ratio<1,10000000> > >::time_point<std::chrono::system_clock,std::chrono::duration<__int64,std::ratio<1,10000000> > >
PUBLIC	?shouldTick@LimitedThread@@MEAA_NXZ		; LimitedThread::shouldTick
PUBLIC	?postStop@Thread@@UEAAXXZ			; Thread::postStop
PUBLIC	?preStart@Thread@@UEAAXXZ			; Thread::preStart
PUBLIC	?stop@Thread@@UEAA_NXZ				; Thread::stop
PUBLIC	?start@Thread@@UEAA_NXZ				; Thread::start
PUBLIC	?shouldTick@Thread@@MEAA_NXZ			; Thread::shouldTick
PUBLIC	?loop@Thread@@KAXPEAV1@@Z			; Thread::loop
PUBLIC	??1RenderThread@@QEAA@XZ			; RenderThread::~RenderThread
PUBLIC	??0RenderThread@@QEAA@XZ			; RenderThread::RenderThread
PUBLIC	??1ChunkLoadThread@@QEAA@XZ			; ChunkLoadThread::~ChunkLoadThread
PUBLIC	??0ChunkLoadThread@@QEAA@XZ			; ChunkLoadThread::ChunkLoadThread
PUBLIC	??1?$queue@V?$shared_ptr@VChunkBase@@@std@@V?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@2@@std@@QEAA@XZ ; std::queue<std::shared_ptr<ChunkBase>,std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > > >::~queue<std::shared_ptr<ChunkBase>,std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > > >
PUBLIC	??1Thread@@QEAA@XZ				; Thread::~Thread
PUBLIC	??0Thread@@QEAA@XZ				; Thread::Thread
PUBLIC	??1ChunkDrawThread@@QEAA@XZ			; ChunkDrawThread::~ChunkDrawThread
PUBLIC	??0ChunkDrawThread@@QEAA@XZ			; ChunkDrawThread::ChunkDrawThread
PUBLIC	??8std@@YA_NVid@thread@0@0@Z			; std::operator==
PUBLIC	?get_id@this_thread@std@@YA?AVid@thread@2@XZ	; std::this_thread::get_id
PUBLIC	?get_id@thread@std@@QEBA?AVid@12@XZ		; std::thread::get_id
PUBLIC	?join@thread@std@@QEAAXXZ			; std::thread::join
PUBLIC	??0id@thread@std@@AEAA@U_Thrd_imp_t@@@Z		; std::thread::id::id
PUBLIC	??0id@thread@std@@AEAA@AEBV12@@Z		; std::thread::id::id
PUBLIC	?now@system_clock@chrono@std@@SA?AV?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@23@XZ ; std::chrono::system_clock::now
PUBLIC	??1_Container_base12@std@@QEAA@XZ		; std::_Container_base12::~_Container_base12
PUBLIC	??0_Container_base12@std@@QEAA@XZ		; std::_Container_base12::_Container_base12
PUBLIC	??0_Container_proxy@std@@QEAA@XZ		; std::_Container_proxy::_Container_proxy
PUBLIC	?renderThread@@3VRenderThread@@A		; renderThread
PUBLIC	?chunkLoadThreads@@3PAVChunkLoadThread@@A	; chunkLoadThreads
PUBLIC	?chunkDrawThreads@@3PAVChunkDrawThread@@A	; chunkDrawThreads
PUBLIC	?world@GlobalThread@@3VWorld@@A			; GlobalThread::world
	ALIGN	4

_Tuple_alloc DB	01H DUP (?)
	ALIGN	4

ignore	DB	01H DUP (?)
	ALIGN	4

allocator_arg DB 01H DUP (?)
	ALIGN	4

piecewise_construct DB 01H DUP (?)
	ALIGN	4

?chunkLoadThreads@@3PAVChunkLoadThread@@A DB 0968H DUP (?) ; chunkLoadThreads
?chunkDrawThreads@@3PAVChunkDrawThread@@A DB 01170H DUP (?) ; chunkDrawThreads
?world@GlobalThread@@3VWorld@@A DB 0f0H DUP (?)		; GlobalThread::world
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0V?$_Bind@$00XQ6AXPEAVThread@@@ZV?$reference_wrapper@PEAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@std@@@?$_LaunchPad@V?$_Bind@$00XQ6AXPEAVThread@@@ZV?$reference_wrapper@PEAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@std@@@std@@QEAA@$$QEAV?$_Bind@$00XQ6AXPEAVThread@@@ZV?$reference_wrapper@PEAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@1@@Z DD imagerel $LN49
	DD	imagerel $LN49+60
	DD	imagerel $unwind$??$?0V?$_Bind@$00XQ6AXPEAVThread@@@ZV?$reference_wrapper@PEAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@std@@@?$_LaunchPad@V?$_Bind@$00XQ6AXPEAVThread@@@ZV?$reference_wrapper@PEAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@std@@@std@@QEAA@$$QEAV?$_Bind@$00XQ6AXPEAVThread@@@ZV?$reference_wrapper@PEAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Run@?$_LaunchPad@V?$_Bind@$00XQ6AXPEAVThread@@@ZV?$reference_wrapper@PEAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@std@@@std@@CAIPEAV12@@Z DD imagerel $LN60
	DD	imagerel $LN60+41
	DD	imagerel $unwind$?_Run@?$_LaunchPad@V?$_Bind@$00XQ6AXPEAVThread@@@ZV?$reference_wrapper@PEAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@std@@@std@@CAIPEAV12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Go@?$_LaunchPad@V?$_Bind@$00XQ6AXPEAVThread@@@ZV?$reference_wrapper@PEAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@std@@@std@@UEAAIXZ DD imagerel $LN62
	DD	imagerel $LN62+41
	DD	imagerel $unwind$?_Go@?$_LaunchPad@V?$_Bind@$00XQ6AXPEAVThread@@@ZV?$reference_wrapper@PEAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@std@@@std@@UEAAIXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Launch@V?$_Bind@$00XQ6AXPEAVThread@@@ZV?$reference_wrapper@PEAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@std@@@std@@YAXPEAU_Thrd_imp_t@@$$QEAV?$_Bind@$00XQ6AXPEAVThread@@@ZV?$reference_wrapper@PEAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@0@@Z DD imagerel $LN55
	DD	imagerel $LN55+100
	DD	imagerel $unwind$??$_Launch@V?$_Bind@$00XQ6AXPEAVThread@@@ZV?$reference_wrapper@PEAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@std@@@std@@YAXPEAU_Thrd_imp_t@@$$QEAV?$_Bind@$00XQ6AXPEAVThread@@@ZV?$reference_wrapper@PEAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Allocate@U_Container_proxy@std@@@std@@YAPEAU_Container_proxy@0@_KPEAU10@@Z DD imagerel $LN14
	DD	imagerel $LN14+44
	DD	imagerel $unwind$??$_Allocate@U_Container_proxy@std@@@std@@YAPEAU_Container_proxy@0@_KPEAU10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0P6AXPEAVThread@@@ZV?$reference_wrapper@PEAVThread@@@std@@@thread@std@@QEAA@P6AXPEAVThread@@@Z$$QEAV?$reference_wrapper@PEAVThread@@@1@@Z DD imagerel $LN107
	DD	imagerel $LN107+103
	DD	imagerel $unwind$??$?0P6AXPEAVThread@@@ZV?$reference_wrapper@PEAVThread@@@std@@@thread@std@@QEAA@P6AXPEAVThread@@@Z$$QEAV?$reference_wrapper@PEAVThread@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$allocator@U_Container_proxy@std@@@std@@QEAAPEAU_Container_proxy@2@_K@Z DD imagerel $LN14
	DD	imagerel $LN14+30
	DD	imagerel $unwind$?allocate@?$allocator@U_Container_proxy@std@@@std@@QEAAPEAU_Container_proxy@2@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QEAAPEAU_Container_proxy@2@_K@Z DD imagerel $LN17
	DD	imagerel $LN17+30
	DD	imagerel $unwind$?allocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QEAAPEAU_Container_proxy@2@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Alloc_proxy@?$_Deque_alloc@$0A@U?$_Deque_base_types@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@@std@@QEAAXXZ DD imagerel $LN37
	DD	imagerel $LN37+54
	DD	imagerel $unwind$?_Alloc_proxy@?$_Deque_alloc@$0A@U?$_Deque_base_types@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Free_proxy@?$_Deque_alloc@$0A@U?$_Deque_base_types@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@@std@@QEAAXXZ DD imagerel $LN10
	DD	imagerel $LN10+30
	DD	imagerel $unwind$?_Free_proxy@?$_Deque_alloc@$0A@U?$_Deque_base_types@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$_Deque_alloc@$0A@U?$_Deque_base_types@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@@std@@QEAA@AEBV?$allocator@V?$shared_ptr@VChunkBase@@@std@@@1@@Z DD imagerel $LN44
	DD	imagerel $LN44+83
	DD	imagerel $unwind$??0?$_Deque_alloc@$0A@U?$_Deque_base_types@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@@std@@QEAA@AEBV?$allocator@V?$shared_ptr@VChunkBase@@@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?pop_back@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAAXXZ DD imagerel $LN33
	DD	imagerel $LN33+36
	DD	imagerel $unwind$?pop_back@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?pop_back@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAAXXZ DD imagerel $LN33+36
	DD	imagerel $LN33+64
	DD	imagerel $chain$0$?pop_back@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?pop_back@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAAXXZ DD imagerel $LN33+64
	DD	imagerel $LN33+99
	DD	imagerel $chain$1$?pop_back@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?pop_back@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAAXXZ DD imagerel $LN33+99
	DD	imagerel $LN33+110
	DD	imagerel $chain$2$?pop_back@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?pop_back@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAAXXZ DD imagerel $LN33+110
	DD	imagerel $LN33+124
	DD	imagerel $chain$3$?pop_back@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_Deque_alloc@$0A@U?$_Deque_base_types@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@@std@@QEAA@XZ DD imagerel $LN12
	DD	imagerel $LN12+30
	DD	imagerel $unwind$??1?$_Deque_alloc@$0A@U?$_Deque_base_types@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAXXZ DD imagerel $LN65
	DD	imagerel $LN65+192
	DD	imagerel $unwind$?_Tidy@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAA@XZ DD imagerel $LN50
	DD	imagerel $LN50+83
	DD	imagerel $unwind$??0?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAA@XZ DD imagerel $LN14
	DD	imagerel $LN14+35
	DD	imagerel $unwind$??1?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$queue@V?$shared_ptr@VChunkBase@@@std@@V?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@2@@std@@QEAA@XZ DD imagerel $LN54
	DD	imagerel $LN54+83
	DD	imagerel $unwind$??0?$queue@V?$shared_ptr@VChunkBase@@@std@@V?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@2@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__Eworld@GlobalThread@@YAXXZ DD imagerel ??__Eworld@GlobalThread@@YAXXZ
	DD	imagerel ??__Eworld@GlobalThread@@YAXXZ+35
	DD	imagerel $unwind$??__Eworld@GlobalThread@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?shouldTick@LimitedThread@@MEAA_NXZ DD imagerel $LN47
	DD	imagerel $LN47+85
	DD	imagerel $unwind$?shouldTick@LimitedThread@@MEAA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?stop@Thread@@UEAA_NXZ DD imagerel $LN6
	DD	imagerel $LN6+30
	DD	imagerel $unwind$?stop@Thread@@UEAA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?start@Thread@@UEAA_NXZ DD imagerel $LN167
	DD	imagerel $LN167+149
	DD	imagerel $unwind$?start@Thread@@UEAA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?loop@Thread@@KAXPEAV1@@Z DD imagerel $LN30
	DD	imagerel $LN30+25
	DD	imagerel $unwind$?loop@Thread@@KAXPEAV1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?loop@Thread@@KAXPEAV1@@Z DD imagerel $LN30+25
	DD	imagerel $LN30+150
	DD	imagerel $chain$2$?loop@Thread@@KAXPEAV1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?loop@Thread@@KAXPEAV1@@Z DD imagerel $LN30+150
	DD	imagerel $LN30+165
	DD	imagerel $chain$3$?loop@Thread@@KAXPEAV1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1RenderThread@@QEAA@XZ DD imagerel $LN19
	DD	imagerel $LN19+36
	DD	imagerel $unwind$??1RenderThread@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0RenderThread@@QEAA@XZ DD imagerel $LN17
	DD	imagerel $LN17+105
	DD	imagerel $unwind$??0RenderThread@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__FrenderThread@@YAXXZ DD imagerel ??__FrenderThread@@YAXXZ
	DD	imagerel ??__FrenderThread@@YAXXZ+36
	DD	imagerel $unwind$??__FrenderThread@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__ErenderThread@@YAXXZ DD imagerel ??__ErenderThread@@YAXXZ
	DD	imagerel ??__ErenderThread@@YAXXZ+70
	DD	imagerel $unwind$??__ErenderThread@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1ChunkLoadThread@@QEAA@XZ DD imagerel $LN64
	DD	imagerel $LN64+294
	DD	imagerel $unwind$??1ChunkLoadThread@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0ChunkLoadThread@@QEAA@XZ DD imagerel $LN118
	DD	imagerel $LN118+284
	DD	imagerel $unwind$??0ChunkLoadThread@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__EchunkLoadThreads@@YAXXZ DD imagerel ??__EchunkLoadThreads@@YAXXZ
	DD	imagerel ??__EchunkLoadThreads@@YAXXZ+62
	DD	imagerel $unwind$??__EchunkLoadThreads@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$queue@V?$shared_ptr@VChunkBase@@@std@@V?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@2@@std@@QEAA@XZ DD imagerel $LN16
	DD	imagerel $LN16+35
	DD	imagerel $unwind$??1?$queue@V?$shared_ptr@VChunkBase@@@std@@V?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@2@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1Thread@@QEAA@XZ DD imagerel $LN16
	DD	imagerel $LN16+39
	DD	imagerel $unwind$??1Thread@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0Thread@@QEAA@XZ DD imagerel $LN14
	DD	imagerel $LN14+75
	DD	imagerel $unwind$??0Thread@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1ChunkDrawThread@@QEAA@XZ DD imagerel $LN65
	DD	imagerel $LN65+165
	DD	imagerel $unwind$??1ChunkDrawThread@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0ChunkDrawThread@@QEAA@XZ DD imagerel $LN182
	DD	imagerel $LN182+319
	DD	imagerel $unwind$??0ChunkDrawThread@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__EchunkDrawThreads@@YAXXZ DD imagerel ??__EchunkDrawThreads@@YAXXZ
	DD	imagerel ??__EchunkDrawThreads@@YAXXZ+62
	DD	imagerel $unwind$??__EchunkDrawThreads@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??8std@@YA_NVid@thread@0@0@Z DD imagerel $LN4
	DD	imagerel $LN4+45
	DD	imagerel $unwind$??8std@@YA_NVid@thread@0@0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?get_id@this_thread@std@@YA?AVid@thread@2@XZ DD imagerel $LN6
	DD	imagerel $LN6+42
	DD	imagerel $unwind$?get_id@this_thread@std@@YA?AVid@thread@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?join@thread@std@@QEAAXXZ DD imagerel $LN21
	DD	imagerel $LN21+143
	DD	imagerel $unwind$?join@thread@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?now@system_clock@chrono@std@@SA?AV?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@23@XZ DD imagerel $LN8
	DD	imagerel $LN8+26
	DD	imagerel $unwind$?now@system_clock@chrono@std@@SA?AV?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@23@XZ
?renderThread@@3VRenderThread@@A DQ FLAT:??_7Thread@@6B@ ; renderThread
	DB	8 DUP(00H)
	DD	00H
_DATA	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?now@system_clock@chrono@std@@SA?AV?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@23@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?join@thread@std@@QEAAXXZ DD 020601H
	DD	030027206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?get_id@this_thread@std@@YA?AVid@thread@2@XZ DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??8std@@YA_NVid@thread@0@0@Z DD 010401H
	DD	08204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__EchunkDrawThreads@@YAXXZ DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0ChunkDrawThread@@QEAA@XZ DD imagerel ??0ChunkDrawThread@@QEAA@XZ
	DD	0ffffffffH
	DD	imagerel ??0ChunkDrawThread@@QEAA@XZ+47
	DD	00H
	DD	imagerel ??0ChunkDrawThread@@QEAA@XZ+74
	DD	01H
	DD	imagerel ??0ChunkDrawThread@@QEAA@XZ+145
	DD	02H
	DD	imagerel ??0ChunkDrawThread@@QEAA@XZ+208
	DD	03H
	DD	imagerel ??0ChunkDrawThread@@QEAA@XZ+300
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0ChunkDrawThread@@QEAA@XZ DD 0ffffffffH
	DD	imagerel ?dtor$5@?0???0ChunkDrawThread@@QEAA@XZ@4HA
	DD	0ffffffffH
	DD	imagerel ?dtor$0@?0???0ChunkDrawThread@@QEAA@XZ@4HA
	DD	01H
	DD	imagerel ?dtor$1@?0???0ChunkDrawThread@@QEAA@XZ@4HA
	DD	02H
	DD	imagerel ?dtor$2@?0???0ChunkDrawThread@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??0ChunkDrawThread@@QEAA@XZ DD 019930522H
	DD	04H
	DD	imagerel $stateUnwindMap$??0ChunkDrawThread@@QEAA@XZ
	DD	00H
	DD	00H
	DD	06H
	DD	imagerel $ip2state$??0ChunkDrawThread@@QEAA@XZ
	DD	020H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0ChunkDrawThread@@QEAA@XZ DD 061d11H
	DD	0a641dH
	DD	093418H
	DD	07006520aH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??0ChunkDrawThread@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1ChunkDrawThread@@QEAA@XZ DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0Thread@@QEAA@XZ DD imagerel ??0Thread@@QEAA@XZ
	DD	0ffffffffH
	DD	imagerel ??0Thread@@QEAA@XZ+39
	DD	00H
	DD	imagerel ??0Thread@@QEAA@XZ+66
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0Thread@@QEAA@XZ DD 0ffffffffH
	DD	imagerel ?dtor$0@?0???0Thread@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??0Thread@@QEAA@XZ DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$??0Thread@@QEAA@XZ
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$??0Thread@@QEAA@XZ
	DD	020H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0Thread@@QEAA@XZ DD 021311H
	DD	03006520aH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??0Thread@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1Thread@@QEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$queue@V?$shared_ptr@VChunkBase@@@std@@V?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@2@@std@@QEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__EchunkLoadThreads@@YAXXZ DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0ChunkLoadThread@@QEAA@XZ DD imagerel ??0ChunkLoadThread@@QEAA@XZ
	DD	0ffffffffH
	DD	imagerel ??0ChunkLoadThread@@QEAA@XZ+47
	DD	00H
	DD	imagerel ??0ChunkLoadThread@@QEAA@XZ+74
	DD	01H
	DD	imagerel ??0ChunkLoadThread@@QEAA@XZ+112
	DD	02H
	DD	imagerel ??0ChunkLoadThread@@QEAA@XZ+119
	DD	03H
	DD	imagerel ??0ChunkLoadThread@@QEAA@XZ+126
	DD	04H
	DD	imagerel ??0ChunkLoadThread@@QEAA@XZ+133
	DD	05H
	DD	imagerel ??0ChunkLoadThread@@QEAA@XZ+140
	DD	06H
	DD	imagerel ??0ChunkLoadThread@@QEAA@XZ+147
	DD	07H
	DD	imagerel ??0ChunkLoadThread@@QEAA@XZ+154
	DD	08H
	DD	imagerel ??0ChunkLoadThread@@QEAA@XZ+161
	DD	09H
	DD	imagerel ??0ChunkLoadThread@@QEAA@XZ+168
	DD	0aH
	DD	imagerel ??0ChunkLoadThread@@QEAA@XZ+175
	DD	0bH
	DD	imagerel ??0ChunkLoadThread@@QEAA@XZ+265
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0ChunkLoadThread@@QEAA@XZ DD 0ffffffffH
	DD	imagerel ?dtor$13@?0???0ChunkLoadThread@@QEAA@XZ@4HA
	DD	0ffffffffH
	DD	imagerel ?dtor$0@?0???0ChunkLoadThread@@QEAA@XZ@4HA
	DD	01H
	DD	imagerel ?dtor$1@?0???0ChunkLoadThread@@QEAA@XZ@4HA
	DD	02H
	DD	imagerel ?dtor$2@?0???0ChunkLoadThread@@QEAA@XZ@4HA
	DD	03H
	DD	imagerel ?dtor$3@?0???0ChunkLoadThread@@QEAA@XZ@4HA
	DD	04H
	DD	imagerel ?dtor$4@?0???0ChunkLoadThread@@QEAA@XZ@4HA
	DD	05H
	DD	imagerel ?dtor$5@?0???0ChunkLoadThread@@QEAA@XZ@4HA
	DD	06H
	DD	imagerel ?dtor$6@?0???0ChunkLoadThread@@QEAA@XZ@4HA
	DD	07H
	DD	imagerel ?dtor$7@?0???0ChunkLoadThread@@QEAA@XZ@4HA
	DD	08H
	DD	imagerel ?dtor$8@?0???0ChunkLoadThread@@QEAA@XZ@4HA
	DD	09H
	DD	imagerel ?dtor$9@?0???0ChunkLoadThread@@QEAA@XZ@4HA
	DD	0aH
	DD	imagerel ?dtor$10@?0???0ChunkLoadThread@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??0ChunkLoadThread@@QEAA@XZ DD 019930522H
	DD	0cH
	DD	imagerel $stateUnwindMap$??0ChunkLoadThread@@QEAA@XZ
	DD	00H
	DD	00H
	DD	0eH
	DD	imagerel $ip2state$??0ChunkLoadThread@@QEAA@XZ
	DD	020H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0ChunkLoadThread@@QEAA@XZ DD 061d11H
	DD	0a641dH
	DD	093418H
	DD	07006520aH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??0ChunkLoadThread@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1ChunkLoadThread@@QEAA@XZ DD imagerel ??1ChunkLoadThread@@QEAA@XZ
	DD	0ffffffffH
	DD	imagerel ??1ChunkLoadThread@@QEAA@XZ+32
	DD	09H
	DD	imagerel ??1ChunkLoadThread@@QEAA@XZ+90
	DD	08H
	DD	imagerel ??1ChunkLoadThread@@QEAA@XZ+103
	DD	07H
	DD	imagerel ??1ChunkLoadThread@@QEAA@XZ+116
	DD	06H
	DD	imagerel ??1ChunkLoadThread@@QEAA@XZ+129
	DD	05H
	DD	imagerel ??1ChunkLoadThread@@QEAA@XZ+142
	DD	04H
	DD	imagerel ??1ChunkLoadThread@@QEAA@XZ+155
	DD	03H
	DD	imagerel ??1ChunkLoadThread@@QEAA@XZ+168
	DD	02H
	DD	imagerel ??1ChunkLoadThread@@QEAA@XZ+181
	DD	01H
	DD	imagerel ??1ChunkLoadThread@@QEAA@XZ+194
	DD	00H
	DD	imagerel ??1ChunkLoadThread@@QEAA@XZ+254
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??1ChunkLoadThread@@QEAA@XZ DD 0ffffffffH
	DD	imagerel ?dtor$0@?0???1ChunkLoadThread@@QEAA@XZ@4HA
	DD	00H
	DD	imagerel ?dtor$1@?0???1ChunkLoadThread@@QEAA@XZ@4HA
	DD	01H
	DD	imagerel ?dtor$2@?0???1ChunkLoadThread@@QEAA@XZ@4HA
	DD	02H
	DD	imagerel ?dtor$3@?0???1ChunkLoadThread@@QEAA@XZ@4HA
	DD	03H
	DD	imagerel ?dtor$4@?0???1ChunkLoadThread@@QEAA@XZ@4HA
	DD	04H
	DD	imagerel ?dtor$5@?0???1ChunkLoadThread@@QEAA@XZ@4HA
	DD	05H
	DD	imagerel ?dtor$6@?0???1ChunkLoadThread@@QEAA@XZ@4HA
	DD	06H
	DD	imagerel ?dtor$7@?0???1ChunkLoadThread@@QEAA@XZ@4HA
	DD	07H
	DD	imagerel ?dtor$8@?0???1ChunkLoadThread@@QEAA@XZ@4HA
	DD	08H
	DD	imagerel ?dtor$9@?0???1ChunkLoadThread@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??1ChunkLoadThread@@QEAA@XZ DD 019930522H
	DD	0aH
	DD	imagerel $stateUnwindMap$??1ChunkLoadThread@@QEAA@XZ
	DD	00H
	DD	00H
	DD	0cH
	DD	imagerel $ip2state$??1ChunkLoadThread@@QEAA@XZ
	DD	020H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1ChunkLoadThread@@QEAA@XZ DD 061d11H
	DD	0a641dH
	DD	093418H
	DD	07006520aH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??1ChunkLoadThread@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??__ErenderThread@@YAXXZ DD imagerel ??__ErenderThread@@YAXXZ
	DD	0ffffffffH
	DD	imagerel ??__ErenderThread@@YAXXZ+13
	DD	00H
	DD	imagerel ??__ErenderThread@@YAXXZ+40
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??__ErenderThread@@YAXXZ DD 0ffffffffH
	DD	imagerel ?dtor$1@?0???__ErenderThread@@YAXXZ@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??__ErenderThread@@YAXXZ DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$??__ErenderThread@@YAXXZ
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$??__ErenderThread@@YAXXZ
	DD	020H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__ErenderThread@@YAXXZ DD 010d11H
	DD	06204H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??__ErenderThread@@YAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__FrenderThread@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0RenderThread@@QEAA@XZ DD imagerel ??0RenderThread@@QEAA@XZ
	DD	0ffffffffH
	DD	imagerel ??0RenderThread@@QEAA@XZ+55
	DD	00H
	DD	imagerel ??0RenderThread@@QEAA@XZ+82
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0RenderThread@@QEAA@XZ DD 0ffffffffH
	DD	imagerel ?dtor$1@?0???0RenderThread@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??0RenderThread@@QEAA@XZ DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$??0RenderThread@@QEAA@XZ
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$??0RenderThread@@QEAA@XZ
	DD	020H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0RenderThread@@QEAA@XZ DD 021311H
	DD	03006520aH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??0RenderThread@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1RenderThread@@QEAA@XZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?loop@Thread@@KAXPEAV1@@Z DD 021H
	DD	imagerel $LN30
	DD	imagerel $LN30+25
	DD	imagerel $unwind$?loop@Thread@@KAXPEAV1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?loop@Thread@@KAXPEAV1@@Z DD 060f21H
	DD	08740fH
	DD	07640aH
	DD	065405H
	DD	imagerel $LN30
	DD	imagerel $LN30+25
	DD	imagerel $unwind$?loop@Thread@@KAXPEAV1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?loop@Thread@@KAXPEAV1@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?start@Thread@@UEAA_NXZ DD imagerel ?start@Thread@@UEAA_NXZ
	DD	0ffffffffH
	DD	imagerel ?start@Thread@@UEAA_NXZ+79
	DD	00H
	DD	imagerel ?start@Thread@@UEAA_NXZ+95
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?start@Thread@@UEAA_NXZ DD 0ffffffffH
	DD	imagerel ?dtor$1@?0??start@Thread@@UEAA_NXZ@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?start@Thread@@UEAA_NXZ DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$?start@Thread@@UEAA_NXZ
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$?start@Thread@@UEAA_NXZ
	DD	020H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?start@Thread@@UEAA_NXZ DD 020f11H
	DD	03002d206H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$?start@Thread@@UEAA_NXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?stop@Thread@@UEAA_NXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?shouldTick@LimitedThread@@MEAA_NXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__Eworld@GlobalThread@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$queue@V?$shared_ptr@VChunkBase@@@std@@V?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@2@@std@@QEAA@XZ DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAA@XZ DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAXXZ DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_Deque_alloc@$0A@U?$_Deque_base_types@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@@std@@QEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?pop_back@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAAXXZ DD 021H
	DD	imagerel $LN33
	DD	imagerel $LN33+36
	DD	imagerel $unwind$?pop_back@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?pop_back@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAAXXZ DD 021H
	DD	imagerel $LN33+36
	DD	imagerel $LN33+64
	DD	imagerel $chain$0$?pop_back@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?pop_back@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAAXXZ DD 020521H
	DD	076405H
	DD	imagerel $LN33+36
	DD	imagerel $LN33+64
	DD	imagerel $chain$0$?pop_back@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?pop_back@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAAXXZ DD 020521H
	DD	063405H
	DD	imagerel $LN33
	DD	imagerel $LN33+36
	DD	imagerel $unwind$?pop_back@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?pop_back@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAAXXZ DD 020601H
	DD	070023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$_Deque_alloc@$0A@U?$_Deque_base_types@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@@std@@QEAA@AEBV?$allocator@V?$shared_ptr@VChunkBase@@@std@@@1@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Free_proxy@?$_Deque_alloc@$0A@U?$_Deque_base_types@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@@std@@QEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Alloc_proxy@?$_Deque_alloc@$0A@U?$_Deque_base_types@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@@std@@QEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QEAAPEAU_Container_proxy@2@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$allocator@U_Container_proxy@std@@@std@@QEAAPEAU_Container_proxy@2@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$?0P6AXPEAVThread@@@ZV?$reference_wrapper@PEAVThread@@@std@@@thread@std@@QEAA@P6AXPEAVThread@@@Z$$QEAV?$reference_wrapper@PEAVThread@@@1@@Z DD imagerel ??$?0P6AXPEAVThread@@@ZV?$reference_wrapper@PEAVThread@@@std@@@thread@std@@QEAA@P6AXPEAVThread@@@Z$$QEAV?$reference_wrapper@PEAVThread@@@1@@Z
	DD	0ffffffffH
	DD	imagerel ??$?0P6AXPEAVThread@@@ZV?$reference_wrapper@PEAVThread@@@std@@@thread@std@@QEAA@P6AXPEAVThread@@@Z$$QEAV?$reference_wrapper@PEAVThread@@@1@@Z+65
	DD	00H
	DD	imagerel ??$?0P6AXPEAVThread@@@ZV?$reference_wrapper@PEAVThread@@@std@@@thread@std@@QEAA@P6AXPEAVThread@@@Z$$QEAV?$reference_wrapper@PEAVThread@@@1@@Z+79
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$?0P6AXPEAVThread@@@ZV?$reference_wrapper@PEAVThread@@@std@@@thread@std@@QEAA@P6AXPEAVThread@@@Z$$QEAV?$reference_wrapper@PEAVThread@@@1@@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0???$?0P6AXPEAVThread@@@ZV?$reference_wrapper@PEAVThread@@@std@@@thread@std@@QEAA@P6AXPEAVThread@@@Z$$QEAV?$reference_wrapper@PEAVThread@@@1@@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??$?0P6AXPEAVThread@@@ZV?$reference_wrapper@PEAVThread@@@std@@@thread@std@@QEAA@P6AXPEAVThread@@@Z$$QEAV?$reference_wrapper@PEAVThread@@@1@@Z DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$??$?0P6AXPEAVThread@@@ZV?$reference_wrapper@PEAVThread@@@std@@@thread@std@@QEAA@P6AXPEAVThread@@@Z$$QEAV?$reference_wrapper@PEAVThread@@@1@@Z
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$??$?0P6AXPEAVThread@@@ZV?$reference_wrapper@PEAVThread@@@std@@@thread@std@@QEAA@P6AXPEAVThread@@@Z$$QEAV?$reference_wrapper@PEAVThread@@@1@@Z
	DD	020H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0P6AXPEAVThread@@@ZV?$reference_wrapper@PEAVThread@@@std@@@thread@std@@QEAA@P6AXPEAVThread@@@Z$$QEAV?$reference_wrapper@PEAVThread@@@1@@Z DD 041411H
	DD	0e3414H
	DD	07002b206H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??$?0P6AXPEAVThread@@@ZV?$reference_wrapper@PEAVThread@@@std@@@thread@std@@QEAA@P6AXPEAVThread@@@Z$$QEAV?$reference_wrapper@PEAVThread@@@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Allocate@U_Container_proxy@std@@@std@@YAPEAU_Container_proxy@0@_KPEAU10@@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Launch@V?$_Bind@$00XQ6AXPEAVThread@@@ZV?$reference_wrapper@PEAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@std@@@std@@YAXPEAU_Thrd_imp_t@@$$QEAV?$_Bind@$00XQ6AXPEAVThread@@@ZV?$reference_wrapper@PEAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@0@@Z DD imagerel ??$_Launch@V?$_Bind@$00XQ6AXPEAVThread@@@ZV?$reference_wrapper@PEAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@std@@@std@@YAXPEAU_Thrd_imp_t@@$$QEAV?$_Bind@$00XQ6AXPEAVThread@@@ZV?$reference_wrapper@PEAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@0@@Z
	DD	0ffffffffH
	DD	imagerel ??$_Launch@V?$_Bind@$00XQ6AXPEAVThread@@@ZV?$reference_wrapper@PEAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@std@@@std@@YAXPEAU_Thrd_imp_t@@$$QEAV?$_Bind@$00XQ6AXPEAVThread@@@ZV?$reference_wrapper@PEAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@0@@Z+65
	DD	00H
	DD	imagerel ??$_Launch@V?$_Bind@$00XQ6AXPEAVThread@@@ZV?$reference_wrapper@PEAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@std@@@std@@YAXPEAU_Thrd_imp_t@@$$QEAV?$_Bind@$00XQ6AXPEAVThread@@@ZV?$reference_wrapper@PEAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@0@@Z+79
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Launch@V?$_Bind@$00XQ6AXPEAVThread@@@ZV?$reference_wrapper@PEAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@std@@@std@@YAXPEAU_Thrd_imp_t@@$$QEAV?$_Bind@$00XQ6AXPEAVThread@@@ZV?$reference_wrapper@PEAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@0@@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0???$_Launch@V?$_Bind@$00XQ6AXPEAVThread@@@ZV?$reference_wrapper@PEAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@std@@@std@@YAXPEAU_Thrd_imp_t@@$$QEAV?$_Bind@$00XQ6AXPEAVThread@@@ZV?$reference_wrapper@PEAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@0@@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??$_Launch@V?$_Bind@$00XQ6AXPEAVThread@@@ZV?$reference_wrapper@PEAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@std@@@std@@YAXPEAU_Thrd_imp_t@@$$QEAV?$_Bind@$00XQ6AXPEAVThread@@@ZV?$reference_wrapper@PEAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@0@@Z DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$??$_Launch@V?$_Bind@$00XQ6AXPEAVThread@@@ZV?$reference_wrapper@PEAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@std@@@std@@YAXPEAU_Thrd_imp_t@@$$QEAV?$_Bind@$00XQ6AXPEAVThread@@@ZV?$reference_wrapper@PEAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@0@@Z
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$??$_Launch@V?$_Bind@$00XQ6AXPEAVThread@@@ZV?$reference_wrapper@PEAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@std@@@std@@YAXPEAU_Thrd_imp_t@@$$QEAV?$_Bind@$00XQ6AXPEAVThread@@@ZV?$reference_wrapper@PEAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@0@@Z
	DD	020H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Launch@V?$_Bind@$00XQ6AXPEAVThread@@@ZV?$reference_wrapper@PEAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@std@@@std@@YAXPEAU_Thrd_imp_t@@$$QEAV?$_Bind@$00XQ6AXPEAVThread@@@ZV?$reference_wrapper@PEAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@0@@Z DD 041411H
	DD	0e3414H
	DD	07002b206H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??$_Launch@V?$_Bind@$00XQ6AXPEAVThread@@@ZV?$reference_wrapper@PEAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@std@@@std@@YAXPEAU_Thrd_imp_t@@$$QEAV?$_Bind@$00XQ6AXPEAVThread@@@ZV?$reference_wrapper@PEAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Go@?$_LaunchPad@V?$_Bind@$00XQ6AXPEAVThread@@@ZV?$reference_wrapper@PEAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@std@@@std@@UEAAIXZ DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Run@?$_LaunchPad@V?$_Bind@$00XQ6AXPEAVThread@@@ZV?$reference_wrapper@PEAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@std@@@std@@CAIPEAV12@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0V?$_Bind@$00XQ6AXPEAVThread@@@ZV?$reference_wrapper@PEAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@std@@@?$_LaunchPad@V?$_Bind@$00XQ6AXPEAVThread@@@ZV?$reference_wrapper@PEAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@std@@@std@@QEAA@$$QEAV?$_Bind@$00XQ6AXPEAVThread@@@ZV?$reference_wrapper@PEAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@1@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
chunkDrawThreads$initializer$ DQ FLAT:??__EchunkDrawThreads@@YAXXZ
chunkLoadThreads$initializer$ DQ FLAT:??__EchunkLoadThreads@@YAXXZ
renderThread$initializer$ DQ FLAT:??__ErenderThread@@YAXXZ
world$initializer$ DQ FLAT:??__Eworld@GlobalThread@@YAXXZ
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??0_Container_proxy@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0_Container_proxy@std@@QEAA@XZ PROC			; std::_Container_proxy::_Container_proxy, COMDAT

; 67   : 		{	// construct from pointers

  00000	33 c0		 xor	 eax, eax
  00002	48 89 01	 mov	 QWORD PTR [rcx], rax
  00005	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 68   : 		}

  00009	48 8b c1	 mov	 rax, rcx
  0000c	c3		 ret	 0
??0_Container_proxy@std@@QEAA@XZ ENDP			; std::_Container_proxy::_Container_proxy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??0_Container_base12@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0_Container_base12@std@@QEAA@XZ PROC			; std::_Container_base12::_Container_base12, COMDAT

; 79   : 		{	// construct childless container

  00000	48 c7 01 00 00
	00 00		 mov	 QWORD PTR [rcx], 0

; 80   : 		}

  00007	48 8b c1	 mov	 rax, rcx
  0000a	c3		 ret	 0
??0_Container_base12@std@@QEAA@XZ ENDP			; std::_Container_base12::_Container_base12
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??1_Container_base12@std@@QEAA@XZ
_TEXT	SEGMENT
this$dead$ = 8
??1_Container_base12@std@@QEAA@XZ PROC			; std::_Container_base12::~_Container_base12, COMDAT

; 94   : 		_Orphan_all();
; 95   : 		}

  00000	c2 00 00	 ret	 0
??1_Container_base12@std@@QEAA@XZ ENDP			; std::_Container_base12::~_Container_base12
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\time.inl
;	COMDAT time
_TEXT	SEGMENT
_Time$dead$ = 8
time	PROC						; COMDAT

; 133  :     return _time64(_Time);

  00000	33 c9		 xor	 ecx, ecx
  00002	e9 00 00 00 00	 jmp	 _time64
time	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\chrono
;	COMDAT ?now@system_clock@chrono@std@@SA?AV?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@23@XZ
_TEXT	SEGMENT
__$ReturnUdt$ = 48
?now@system_clock@chrono@std@@SA?AV?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@23@XZ PROC ; std::chrono::system_clock::now, COMDAT

; 705  : 		{	// get current time

$LN8:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 706  : 		return (time_point(duration(_Xtime_get_ticks())));

  00009	e8 00 00 00 00	 call	 _Xtime_get_ticks

; 259  : 		{	// construct from a duration

  0000e	48 89 03	 mov	 QWORD PTR [rbx], rax

; 706  : 		return (time_point(duration(_Xtime_get_ticks())));

  00011	48 8b c3	 mov	 rax, rbx

; 707  : 		}

  00014	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00018	5b		 pop	 rbx
  00019	c3		 ret	 0
?now@system_clock@chrono@std@@SA?AV?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@23@XZ ENDP ; std::chrono::system_clock::now
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thread
;	COMDAT ??0id@thread@std@@AEAA@AEBV12@@Z
_TEXT	SEGMENT
this$ = 8
_Thrd$ = 16
??0id@thread@std@@AEAA@AEBV12@@Z PROC			; std::thread::id::id, COMDAT

; 193  : 		{	// construct from thread object

  00000	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  00003	48 89 01	 mov	 QWORD PTR [rcx], rax
  00006	48 8b 42 08	 mov	 rax, QWORD PTR [rdx+8]
  0000a	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 194  : 		}

  0000e	48 8b c1	 mov	 rax, rcx
  00011	c3		 ret	 0
??0id@thread@std@@AEAA@AEBV12@@Z ENDP			; std::thread::id::id
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thread
;	COMDAT ??0id@thread@std@@AEAA@U_Thrd_imp_t@@@Z
_TEXT	SEGMENT
this$ = 8
_Thrd$ = 16
??0id@thread@std@@AEAA@U_Thrd_imp_t@@@Z PROC		; std::thread::id::id, COMDAT

; 198  : 		{	// construct from thread identifier

  00000	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  00003	48 89 01	 mov	 QWORD PTR [rcx], rax
  00006	48 8b 42 08	 mov	 rax, QWORD PTR [rdx+8]
  0000a	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 199  : 		}

  0000e	48 8b c1	 mov	 rax, rcx
  00011	c3		 ret	 0
??0id@thread@std@@AEAA@U_Thrd_imp_t@@@Z ENDP		; std::thread::id::id
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thread
;	COMDAT ?join@thread@std@@QEAAXXZ
_TEXT	SEGMENT
$T1 = 32
$T2 = 48
$T3 = 48
$T4 = 48
this$ = 80
?join@thread@std@@QEAAXXZ PROC				; std::thread::join, COMDAT

; 210  : 	{	// join thread

$LN21:
  00000	40 53		 push	 rbx
  00002	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 83   : 		return (!_Thr_is_null(_Thr));

  00006	83 79 08 00	 cmp	 DWORD PTR [rcx+8], 0

; 210  : 	{	// join thread

  0000a	48 8b d9	 mov	 rbx, rcx

; 211  : 	if (!joinable())

  0000d	75 0a		 jne	 SHORT $LN4@join

; 212  : 		_Throw_Cpp_error(_INVALID_ARGUMENT);

  0000f	b9 01 00 00 00	 mov	 ecx, 1
  00014	e8 00 00 00 00	 call	 ?_Throw_Cpp_error@std@@YAXH@Z ; std::_Throw_Cpp_error
$LN4@join:

; 213  : 	if (_Thr_is_null(_Thr))

  00019	83 7b 08 00	 cmp	 DWORD PTR [rbx+8], 0
  0001d	75 0a		 jne	 SHORT $LN3@join

; 214  : 		_Throw_Cpp_error(_INVALID_ARGUMENT);

  0001f	b9 01 00 00 00	 mov	 ecx, 1
  00024	e8 00 00 00 00	 call	 ?_Throw_Cpp_error@std@@YAXH@Z ; std::_Throw_Cpp_error
$LN3@join:

; 221  : 
; 222  : inline thread::id thread::get_id() const _NOEXCEPT
; 223  : 	{	// return id for this thread
; 224  : 	return (id(*this));
; 225  : 	}
; 226  : 
; 227  : inline thread::id this_thread::get_id() _NOEXCEPT
; 228  : 	{	// return id for current thread
; 229  : 	return (_Thrd_current());

  00029	48 8d 4c 24 30	 lea	 rcx, QWORD PTR $T3[rsp]
  0002e	e8 00 00 00 00	 call	 _Thrd_current

; 230  : 	}
; 231  : 
; 232  : inline void swap(thread& _Left, thread& _Right) _NOEXCEPT
; 233  : 	{	// swap _Left with _Right
; 234  : 	_Left.swap(_Right);
; 235  : 	}
; 236  : 
; 237  : inline bool operator==(thread::id _Left, thread::id _Right) _NOEXCEPT
; 238  : 	{	// return true if _Left and _Right identify the same thread
; 239  : 	return (_Thrd_equal(_Left._Thr, _Right._Thr));

  00033	48 8d 54 24 20	 lea	 rdx, QWORD PTR $T1[rsp]
  00038	48 8d 4c 24 30	 lea	 rcx, QWORD PTR $T2[rsp]
  0003d	0f 10 00	 movups	 xmm0, XMMWORD PTR [rax]
  00040	0f 29 44 24 20	 movaps	 XMMWORD PTR $T1[rsp], xmm0
  00045	0f 10 03	 movups	 xmm0, XMMWORD PTR [rbx]
  00048	0f 29 44 24 30	 movaps	 XMMWORD PTR $T2[rsp], xmm0
  0004d	e8 00 00 00 00	 call	 _Thrd_equal
  00052	85 c0		 test	 eax, eax

; 215  : 	if (get_id() == _STD this_thread::get_id())

  00054	74 0a		 je	 SHORT $LN2@join

; 216  : 		_Throw_Cpp_error(_RESOURCE_DEADLOCK_WOULD_OCCUR);

  00056	b9 05 00 00 00	 mov	 ecx, 5
  0005b	e8 00 00 00 00	 call	 ?_Throw_Cpp_error@std@@YAXH@Z ; std::_Throw_Cpp_error
$LN2@join:

; 217  : 	if (_Thrd_join(_Thr, 0) != _Thrd_success)

  00060	0f 10 03	 movups	 xmm0, XMMWORD PTR [rbx]
  00063	48 8d 4c 24 30	 lea	 rcx, QWORD PTR $T4[rsp]
  00068	33 d2		 xor	 edx, edx
  0006a	0f 29 44 24 30	 movaps	 XMMWORD PTR $T4[rsp], xmm0
  0006f	e8 00 00 00 00	 call	 _Thrd_join
  00074	85 c0		 test	 eax, eax
  00076	74 0a		 je	 SHORT $LN19@join

; 218  : 		_Throw_Cpp_error(_NO_SUCH_PROCESS);

  00078	b9 02 00 00 00	 mov	 ecx, 2
  0007d	e8 00 00 00 00	 call	 ?_Throw_Cpp_error@std@@YAXH@Z ; std::_Throw_Cpp_error
$LN19@join:

; 219  : 	_Thr_set_null(_Thr);

  00082	c7 43 08 00 00
	00 00		 mov	 DWORD PTR [rbx+8], 0

; 220  : 	}

  00089	48 83 c4 40	 add	 rsp, 64			; 00000040H
  0008d	5b		 pop	 rbx
  0008e	c3		 ret	 0
?join@thread@std@@QEAAXXZ ENDP				; std::thread::join
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thread
;	COMDAT ?get_id@thread@std@@QEBA?AVid@12@XZ
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
?get_id@thread@std@@QEBA?AVid@12@XZ PROC		; std::thread::get_id, COMDAT

; 193  : 		{	// construct from thread object

  00000	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00003	48 89 02	 mov	 QWORD PTR [rdx], rax
  00006	48 8b 41 08	 mov	 rax, QWORD PTR [rcx+8]
  0000a	48 89 42 08	 mov	 QWORD PTR [rdx+8], rax

; 224  : 	return (id(*this));

  0000e	48 8b c2	 mov	 rax, rdx

; 225  : 	}

  00011	c3		 ret	 0
?get_id@thread@std@@QEBA?AVid@12@XZ ENDP		; std::thread::get_id
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thread
;	COMDAT ?get_id@this_thread@std@@YA?AVid@thread@2@XZ
_TEXT	SEGMENT
$T1 = 32
__$ReturnUdt$ = 64
?get_id@this_thread@std@@YA?AVid@thread@2@XZ PROC	; std::this_thread::get_id, COMDAT

; 228  : 	{	// return id for current thread

$LN6:
  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 8b d9	 mov	 rbx, rcx

; 229  : 	return (_Thrd_current());

  00009	48 8d 4c 24 20	 lea	 rcx, QWORD PTR $T1[rsp]
  0000e	e8 00 00 00 00	 call	 _Thrd_current

; 198  : 		{	// construct from thread identifier

  00013	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  00016	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0001a	48 89 13	 mov	 QWORD PTR [rbx], rdx
  0001d	48 89 43 08	 mov	 QWORD PTR [rbx+8], rax

; 229  : 	return (_Thrd_current());

  00021	48 8b c3	 mov	 rax, rbx

; 230  : 	}

  00024	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00028	5b		 pop	 rbx
  00029	c3		 ret	 0
?get_id@this_thread@std@@YA?AVid@thread@2@XZ ENDP	; std::this_thread::get_id
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thread
;	COMDAT ??8std@@YA_NVid@thread@0@0@Z
_TEXT	SEGMENT
$T1 = 32
$T2 = 48
_Left$ = 80
_Right$ = 88
??8std@@YA_NVid@thread@0@0@Z PROC			; std::operator==, COMDAT

; 238  : 	{	// return true if _Left and _Right identify the same thread

$LN4:
  00000	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 239  : 	return (_Thrd_equal(_Left._Thr, _Right._Thr));

  00004	0f 10 02	 movups	 xmm0, XMMWORD PTR [rdx]
  00007	48 8d 54 24 20	 lea	 rdx, QWORD PTR $T1[rsp]
  0000c	0f 29 44 24 20	 movaps	 XMMWORD PTR $T1[rsp], xmm0
  00011	0f 10 01	 movups	 xmm0, XMMWORD PTR [rcx]
  00014	48 8d 4c 24 30	 lea	 rcx, QWORD PTR $T2[rsp]
  00019	0f 29 44 24 30	 movaps	 XMMWORD PTR $T2[rsp], xmm0
  0001e	e8 00 00 00 00	 call	 _Thrd_equal
  00023	85 c0		 test	 eax, eax
  00025	0f 95 c0	 setne	 al

; 240  : 	}

  00028	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0002c	c3		 ret	 0
??8std@@YA_NVid@thread@0@0@Z ENDP			; std::operator==
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\erlend\documents\github\wind\project\wind\wind\threads.cpp
;	COMDAT ??__EchunkDrawThreads@@YAXXZ
text$yc	SEGMENT
??__EchunkDrawThreads@@YAXXZ PROC			; `dynamic initializer for 'chunkDrawThreads'', COMDAT

; 3    : ChunkDrawThread chunkDrawThreads[DRAW_THREAD_AMOUNT];

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H
  00004	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??1ChunkDrawThread@@QEAA@XZ
  0000b	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:??0ChunkDrawThread@@QEAA@XZ
  00012	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?chunkDrawThreads@@3PAVChunkDrawThread@@A ; chunkDrawThreads
  00019	ba b8 08 00 00	 mov	 edx, 2232		; 000008b8H
  0001e	41 b8 02 00 00
	00		 mov	 r8d, 2
  00024	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00029	e8 00 00 00 00	 call	 ??_L@YAXPEAX_KHP6AX0@Z2@Z
  0002e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??__FchunkDrawThreads@@YAXXZ ; `dynamic atexit destructor for 'chunkDrawThreads''
  00035	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00039	e9 00 00 00 00	 jmp	 atexit
??__EchunkDrawThreads@@YAXXZ ENDP			; `dynamic initializer for 'chunkDrawThreads''
text$yc	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??__FchunkDrawThreads@@YAXXZ
text$yd	SEGMENT
??__FchunkDrawThreads@@YAXXZ PROC			; `dynamic atexit destructor for 'chunkDrawThreads'', COMDAT
  00000	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:??1ChunkDrawThread@@QEAA@XZ
  00007	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?chunkDrawThreads@@3PAVChunkDrawThread@@A ; chunkDrawThreads
  0000e	ba b8 08 00 00	 mov	 edx, 2232		; 000008b8H
  00013	41 b8 02 00 00
	00		 mov	 r8d, 2
  00019	e9 00 00 00 00	 jmp	 ??_M@YAXPEAX_KHP6AX0@Z@Z
??__FchunkDrawThreads@@YAXXZ ENDP			; `dynamic atexit destructor for 'chunkDrawThreads''
text$yd	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thread
; File c:\users\erlend\documents\github\wind\project\wind\wind\memutil.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
;	COMDAT ??0ChunkDrawThread@@QEAA@XZ
_TEXT	SEGMENT
$T1 = 32
this$ = 64
??0ChunkDrawThread@@QEAA@XZ PROC			; ChunkDrawThread::ChunkDrawThread, COMDAT
$LN182:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 c7 44 24 20
	fe ff ff ff	 mov	 QWORD PTR $T1[rsp], -2
  00013	48 89 5c 24 48	 mov	 QWORD PTR [rsp+72], rbx
  00018	48 89 74 24 50	 mov	 QWORD PTR [rsp+80], rsi
  0001d	48 8b d9	 mov	 rbx, rcx
  00020	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7Thread@@6B@
  00027	48 89 01	 mov	 QWORD PTR [rcx], rax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thread

; 39   : 		_Thr_set_null(_Thr);

  0002a	33 f6		 xor	 esi, esi
  0002c	89 71 10	 mov	 DWORD PTR [rcx+16], esi
; File c:\users\erlend\documents\github\wind\project\wind\wind\memutil.cpp

; 7    : {

  0002f	b9 02 10 00 00	 mov	 ecx, 4098		; 00001002H
  00034	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  00039	48 89 83 28 08
	00 00		 mov	 QWORD PTR [rbx+2088], rax
  00040	c7 83 30 08 00
	00 02 10 00 00	 mov	 DWORD PTR [rbx+2096], 4098 ; 00001002H
  0004a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7ChunkDrawThread@@6B@
  00051	48 89 03	 mov	 QWORD PTR [rbx], rax
  00054	48 8d bb 38 08
	00 00		 lea	 rdi, QWORD PTR [rbx+2104]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility

; 79   : 		{	// construct childless container

  0005b	48 89 37	 mov	 QWORD PTR [rdi], rsi
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 778  : 		_Map = _Mapptr();

  0005e	48 89 77 08	 mov	 QWORD PTR [rdi+8], rsi

; 779  : 		_Mapsize = 0;

  00062	48 89 77 10	 mov	 QWORD PTR [rdi+16], rsi

; 780  : 		_Myoff = 0;

  00066	48 89 77 18	 mov	 QWORD PTR [rdi+24], rsi

; 781  : 		_Mysize = 0;

  0006a	48 89 77 20	 mov	 QWORD PTR [rdi+32], rsi
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0006e	8d 4e 10	 lea	 ecx, QWORD PTR [rsi+16]
  00071	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  00076	48 85 c0	 test	 rax, rax
  00079	75 06		 jne	 SHORT $LN42@ChunkDrawT

; 29   : 		_Xbad_alloc();	// report no memory

  0007b	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
  00080	cc		 int	 3
$LN42@ChunkDrawT:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 900  : 		this->_Myproxy = _Alproxy.allocate(1);

  00081	48 89 07	 mov	 QWORD PTR [rdi], rax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 617  : _VARIADIC_EXPAND_0X(_ALLOC_MEMBER_CONSTRUCT, , , , )

  00084	48 89 30	 mov	 QWORD PTR [rax], rsi
  00087	48 89 70 08	 mov	 QWORD PTR [rax+8], rsi
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 902  : 		this->_Myproxy->_Mycont = this;

  0008b	48 8b 07	 mov	 rax, QWORD PTR [rdi]
  0008e	48 89 38	 mov	 QWORD PTR [rax], rdi
  00091	48 8d bb 60 08
	00 00		 lea	 rdi, QWORD PTR [rbx+2144]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility

; 79   : 		{	// construct childless container

  00098	48 89 37	 mov	 QWORD PTR [rdi], rsi
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 778  : 		_Map = _Mapptr();

  0009b	48 89 77 08	 mov	 QWORD PTR [rdi+8], rsi

; 779  : 		_Mapsize = 0;

  0009f	48 89 77 10	 mov	 QWORD PTR [rdi+16], rsi

; 780  : 		_Myoff = 0;

  000a3	48 89 77 18	 mov	 QWORD PTR [rdi+24], rsi

; 781  : 		_Mysize = 0;

  000a7	48 89 77 20	 mov	 QWORD PTR [rdi+32], rsi
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  000ab	b9 10 00 00 00	 mov	 ecx, 16
  000b0	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  000b5	48 85 c0	 test	 rax, rax
  000b8	75 06		 jne	 SHORT $LN93@ChunkDrawT

; 29   : 		_Xbad_alloc();	// report no memory

  000ba	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
  000bf	cc		 int	 3
$LN93@ChunkDrawT:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 900  : 		this->_Myproxy = _Alproxy.allocate(1);

  000c0	48 89 07	 mov	 QWORD PTR [rdi], rax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 617  : _VARIADIC_EXPAND_0X(_ALLOC_MEMBER_CONSTRUCT, , , , )

  000c3	48 89 30	 mov	 QWORD PTR [rax], rsi
  000c6	48 89 70 08	 mov	 QWORD PTR [rax+8], rsi
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 902  : 		this->_Myproxy->_Mycont = this;

  000ca	48 8b 07	 mov	 rax, QWORD PTR [rdi]
  000cd	48 89 38	 mov	 QWORD PTR [rax], rdi
  000d0	48 8d bb 88 08
	00 00		 lea	 rdi, QWORD PTR [rbx+2184]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility

; 79   : 		{	// construct childless container

  000d7	48 89 37	 mov	 QWORD PTR [rdi], rsi
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 778  : 		_Map = _Mapptr();

  000da	48 89 77 08	 mov	 QWORD PTR [rdi+8], rsi

; 779  : 		_Mapsize = 0;

  000de	48 89 77 10	 mov	 QWORD PTR [rdi+16], rsi

; 780  : 		_Myoff = 0;

  000e2	48 89 77 18	 mov	 QWORD PTR [rdi+24], rsi

; 781  : 		_Mysize = 0;

  000e6	48 89 77 20	 mov	 QWORD PTR [rdi+32], rsi
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  000ea	b9 10 00 00 00	 mov	 ecx, 16
  000ef	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  000f4	48 85 c0	 test	 rax, rax
  000f7	75 06		 jne	 SHORT $LN143@ChunkDrawT

; 29   : 		_Xbad_alloc();	// report no memory

  000f9	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
  000fe	cc		 int	 3
$LN143@ChunkDrawT:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 900  : 		this->_Myproxy = _Alproxy.allocate(1);

  000ff	48 89 07	 mov	 QWORD PTR [rdi], rax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 617  : _VARIADIC_EXPAND_0X(_ALLOC_MEMBER_CONSTRUCT, , , , )

  00102	48 89 30	 mov	 QWORD PTR [rax], rsi
  00105	48 89 70 08	 mov	 QWORD PTR [rax+8], rsi
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 902  : 		this->_Myproxy->_Mycont = this;

  00109	48 8b 07	 mov	 rax, QWORD PTR [rdi]
  0010c	48 89 38	 mov	 QWORD PTR [rax], rdi
  0010f	48 8d 8b b0 08
	00 00		 lea	 rcx, QWORD PTR [rbx+2224]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 63   : 	return (_Check_C_return(_Mtx_init(_Mtx, _Type)));

  00116	ba 02 00 00 00	 mov	 edx, 2
  0011b	e8 00 00 00 00	 call	 _Mtx_init

; 32   : 	if (_Res != _Thrd_success)

  00120	85 c0		 test	 eax, eax
  00122	74 08		 je	 SHORT $LN178@ChunkDrawT

; 33   : 		_Throw_C_error(_Res);

  00124	8b c8		 mov	 ecx, eax
  00126	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
  0012b	90		 npad	 1
$LN178@ChunkDrawT:
  0012c	48 8b c3	 mov	 rax, rbx
  0012f	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  00134	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  00139	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0013d	5f		 pop	 rdi
  0013e	c3		 ret	 0
$LN181@ChunkDrawT:
??0ChunkDrawThread@@QEAA@XZ ENDP			; ChunkDrawThread::ChunkDrawThread
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
?dtor$5@?0???0ChunkDrawThread@@QEAA@XZ@4HA PROC		; `ChunkDrawThread::ChunkDrawThread'::`1'::dtor$5
  00000	48 8b 8a 40 00
	00 00		 mov	 rcx, QWORD PTR this$[rdx]
  00007	48 83 c1 08	 add	 rcx, 8
  0000b	e9 00 00 00 00	 jmp	 ??1thread@std@@QEAA@XZ	; std::thread::~thread
?dtor$5@?0???0ChunkDrawThread@@QEAA@XZ@4HA ENDP		; `ChunkDrawThread::ChunkDrawThread'::`1'::dtor$5
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
?dtor$0@?0???0ChunkDrawThread@@QEAA@XZ@4HA PROC		; `ChunkDrawThread::ChunkDrawThread'::`1'::dtor$0
  00010	48 8b 8a 40 00
	00 00		 mov	 rcx, QWORD PTR this$[rdx]
  00017	e9 00 00 00 00	 jmp	 ??1Thread@@QEAA@XZ
?dtor$0@?0???0ChunkDrawThread@@QEAA@XZ@4HA ENDP		; `ChunkDrawThread::ChunkDrawThread'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
?dtor$1@?0???0ChunkDrawThread@@QEAA@XZ@4HA PROC		; `ChunkDrawThread::ChunkDrawThread'::`1'::dtor$1
  0001c	48 8b 8a 40 00
	00 00		 mov	 rcx, QWORD PTR this$[rdx]
  00023	48 81 c1 38 08
	00 00		 add	 rcx, 2104		; 00000838H
  0002a	e9 00 00 00 00	 jmp	 ??1?$queue@V?$shared_ptr@VChunkBase@@@std@@V?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@2@@std@@QEAA@XZ
?dtor$1@?0???0ChunkDrawThread@@QEAA@XZ@4HA ENDP		; `ChunkDrawThread::ChunkDrawThread'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
?dtor$2@?0???0ChunkDrawThread@@QEAA@XZ@4HA PROC		; `ChunkDrawThread::ChunkDrawThread'::`1'::dtor$2
  0002f	48 8b 8a 40 00
	00 00		 mov	 rcx, QWORD PTR this$[rdx]
  00036	48 81 c1 60 08
	00 00		 add	 rcx, 2144		; 00000860H
  0003d	e9 00 00 00 00	 jmp	 ??1?$queue@V?$shared_ptr@VChunkBase@@@std@@V?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@2@@std@@QEAA@XZ
?dtor$2@?0???0ChunkDrawThread@@QEAA@XZ@4HA ENDP		; `ChunkDrawThread::ChunkDrawThread'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\mutex
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\users\erlend\documents\github\wind\project\wind\wind\memutil.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thread
;	COMDAT ??1ChunkDrawThread@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1ChunkDrawThread@@QEAA@XZ PROC			; ChunkDrawThread::~ChunkDrawThread, COMDAT
$LN65:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b f9	 mov	 rdi, rcx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\mutex

; 33   : 		_Mtx_destroy(&_Mtx);

  0000d	48 81 c1 b0 08
	00 00		 add	 rcx, 2224		; 000008b0H
  00014	e8 00 00 00 00	 call	 _Mtx_destroy
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 1222 : 		_Tidy();

  00019	48 8d 8f 88 08
	00 00		 lea	 rcx, QWORD PTR [rdi+2184]
  00020	e8 00 00 00 00	 call	 ?_Tidy@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAXXZ ; std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::_Tidy
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 586  : 		::operator delete(_Ptr);

  00025	48 8b 8f 88 08
	00 00		 mov	 rcx, QWORD PTR [rdi+2184]
  0002c	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 1222 : 		_Tidy();

  00031	48 8d 8f 60 08
	00 00		 lea	 rcx, QWORD PTR [rdi+2144]

; 912  : 		this->_Myproxy = 0;

  00038	48 c7 87 88 08
	00 00 00 00 00
	00		 mov	 QWORD PTR [rdi+2184], 0

; 1222 : 		_Tidy();

  00043	e8 00 00 00 00	 call	 ?_Tidy@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAXXZ ; std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::_Tidy
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 586  : 		::operator delete(_Ptr);

  00048	48 8b 8f 60 08
	00 00		 mov	 rcx, QWORD PTR [rdi+2144]
  0004f	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 1222 : 		_Tidy();

  00054	48 8d 8f 38 08
	00 00		 lea	 rcx, QWORD PTR [rdi+2104]

; 912  : 		this->_Myproxy = 0;

  0005b	48 c7 87 60 08
	00 00 00 00 00
	00		 mov	 QWORD PTR [rdi+2144], 0

; 1222 : 		_Tidy();

  00066	e8 00 00 00 00	 call	 ?_Tidy@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAXXZ ; std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::_Tidy
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 586  : 		::operator delete(_Ptr);

  0006b	48 8b 8f 38 08
	00 00		 mov	 rcx, QWORD PTR [rdi+2104]
  00072	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 912  : 		this->_Myproxy = 0;

  00077	48 c7 87 38 08
	00 00 00 00 00
	00		 mov	 QWORD PTR [rdi+2104], 0
; File c:\users\erlend\documents\github\wind\project\wind\wind\memutil.cpp

; 13   : 	delete[] heap;

  00082	48 8b 8f 28 08
	00 00		 mov	 rcx, QWORD PTR [rdi+2088]
  00089	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thread

; 83   : 		return (!_Thr_is_null(_Thr));

  0008e	83 7f 10 00	 cmp	 DWORD PTR [rdi+16], 0

; 57   : 		if (joinable())

  00092	75 0b		 jne	 SHORT $LN63@ChunkDrawT
  00094	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00099	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0009d	5f		 pop	 rdi
  0009e	c3		 ret	 0
$LN63@ChunkDrawT:

; 58   : 			_XSTD terminate();

  0009f	e8 00 00 00 00	 call	 ?terminate@@YAXXZ	; terminate
  000a4	cc		 int	 3
$LN62@ChunkDrawT:
??1ChunkDrawThread@@QEAA@XZ ENDP			; ChunkDrawThread::~ChunkDrawThread
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thread
; File c:\users\erlend\documents\github\wind\project\wind\wind\memutil.cpp
;	COMDAT ??0Thread@@QEAA@XZ
_TEXT	SEGMENT
$T1 = 32
this$ = 64
??0Thread@@QEAA@XZ PROC					; Thread::Thread, COMDAT
$LN14:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	53		 push	 rbx
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 c7 44 24 20
	fe ff ff ff	 mov	 QWORD PTR $T1[rsp], -2
  00013	48 8b d9	 mov	 rbx, rcx
  00016	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7Thread@@6B@
  0001d	48 89 01	 mov	 QWORD PTR [rcx], rax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thread

; 39   : 		_Thr_set_null(_Thr);

  00020	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [rcx+16], 0
; File c:\users\erlend\documents\github\wind\project\wind\wind\memutil.cpp

; 7    : {

  00027	b9 02 10 00 00	 mov	 ecx, 4098		; 00001002H
  0002c	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  00031	48 89 83 28 08
	00 00		 mov	 QWORD PTR [rbx+2088], rax
  00038	c7 83 30 08 00
	00 02 10 00 00	 mov	 DWORD PTR [rbx+2096], 4098 ; 00001002H
  00042	48 8b c3	 mov	 rax, rbx
  00045	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00049	5b		 pop	 rbx
  0004a	c3		 ret	 0
??0Thread@@QEAA@XZ ENDP					; Thread::Thread
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
?dtor$0@?0???0Thread@@QEAA@XZ@4HA PROC			; `Thread::Thread'::`1'::dtor$0
  00000	48 8b 8a 40 00
	00 00		 mov	 rcx, QWORD PTR this$[rdx]
  00007	48 83 c1 08	 add	 rcx, 8
  0000b	e9 00 00 00 00	 jmp	 ??1thread@std@@QEAA@XZ	; std::thread::~thread
?dtor$0@?0???0Thread@@QEAA@XZ@4HA ENDP			; `Thread::Thread'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtp
; File c:\users\erlend\documents\github\wind\project\wind\wind\memutil.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thread
;	COMDAT ??1Thread@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1Thread@@QEAA@XZ PROC					; Thread::~Thread, COMDAT
$LN16:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx
; File c:\users\erlend\documents\github\wind\project\wind\wind\memutil.cpp

; 13   : 	delete[] heap;

  00009	48 8b 89 28 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2088]
  00010	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thread

; 83   : 		return (!_Thr_is_null(_Thr));

  00015	83 7b 10 00	 cmp	 DWORD PTR [rbx+16], 0

; 57   : 		if (joinable())

  00019	75 06		 jne	 SHORT $LN14@Thread
  0001b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001f	5b		 pop	 rbx
  00020	c3		 ret	 0
$LN14@Thread:

; 58   : 			_XSTD terminate();

  00021	e8 00 00 00 00	 call	 ?terminate@@YAXXZ	; terminate
  00026	cc		 int	 3
$LN13@Thread:
??1Thread@@QEAA@XZ ENDP					; Thread::~Thread
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
;	COMDAT ??1?$queue@V?$shared_ptr@VChunkBase@@@std@@V?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@2@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$queue@V?$shared_ptr@VChunkBase@@@std@@V?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@2@@std@@QEAA@XZ PROC ; std::queue<std::shared_ptr<ChunkBase>,std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > > >::~queue<std::shared_ptr<ChunkBase>,std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > > >, COMDAT
$LN16:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 1222 : 		_Tidy();

  00009	e8 00 00 00 00	 call	 ?_Tidy@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAXXZ ; std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::_Tidy
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 586  : 		::operator delete(_Ptr);

  0000e	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  00011	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 912  : 		this->_Myproxy = 0;

  00016	48 c7 03 00 00
	00 00		 mov	 QWORD PTR [rbx], 0
  0001d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00021	5b		 pop	 rbx
  00022	c3		 ret	 0
??1?$queue@V?$shared_ptr@VChunkBase@@@std@@V?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@2@@std@@QEAA@XZ ENDP ; std::queue<std::shared_ptr<ChunkBase>,std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > > >::~queue<std::shared_ptr<ChunkBase>,std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\erlend\documents\github\wind\project\wind\wind\threads.cpp
;	COMDAT ??__EchunkLoadThreads@@YAXXZ
text$yc	SEGMENT
??__EchunkLoadThreads@@YAXXZ PROC			; `dynamic initializer for 'chunkLoadThreads'', COMDAT

; 4    : ChunkLoadThread chunkLoadThreads[LOAD_THREAD_AMOUNT];

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H
  00004	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??1ChunkLoadThread@@QEAA@XZ
  0000b	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:??0ChunkLoadThread@@QEAA@XZ
  00012	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?chunkLoadThreads@@3PAVChunkLoadThread@@A ; chunkLoadThreads
  00019	ba 68 09 00 00	 mov	 edx, 2408		; 00000968H
  0001e	41 b8 01 00 00
	00		 mov	 r8d, 1
  00024	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00029	e8 00 00 00 00	 call	 ??_L@YAXPEAX_KHP6AX0@Z2@Z
  0002e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??__FchunkLoadThreads@@YAXXZ ; `dynamic atexit destructor for 'chunkLoadThreads''
  00035	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00039	e9 00 00 00 00	 jmp	 atexit
??__EchunkLoadThreads@@YAXXZ ENDP			; `dynamic initializer for 'chunkLoadThreads''
text$yc	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??__FchunkLoadThreads@@YAXXZ
text$yd	SEGMENT
??__FchunkLoadThreads@@YAXXZ PROC			; `dynamic atexit destructor for 'chunkLoadThreads'', COMDAT
  00000	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:??1ChunkLoadThread@@QEAA@XZ
  00007	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?chunkLoadThreads@@3PAVChunkLoadThread@@A ; chunkLoadThreads
  0000e	ba 68 09 00 00	 mov	 edx, 2408		; 00000968H
  00013	41 b8 01 00 00
	00		 mov	 r8d, 1
  00019	e9 00 00 00 00	 jmp	 ??_M@YAXPEAX_KHP6AX0@Z@Z
??__FchunkLoadThreads@@YAXXZ ENDP			; `dynamic atexit destructor for 'chunkLoadThreads''
text$yd	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thread
; File c:\users\erlend\documents\github\wind\project\wind\wind\memutil.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
; File c:\users\erlend\documents\github\wind\project\wind\wind\opencl.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
;	COMDAT ??0ChunkLoadThread@@QEAA@XZ
_TEXT	SEGMENT
$T1 = 32
this$ = 64
??0ChunkLoadThread@@QEAA@XZ PROC			; ChunkLoadThread::ChunkLoadThread, COMDAT
$LN118:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 c7 44 24 20
	fe ff ff ff	 mov	 QWORD PTR $T1[rsp], -2
  00013	48 89 5c 24 48	 mov	 QWORD PTR [rsp+72], rbx
  00018	48 89 74 24 50	 mov	 QWORD PTR [rsp+80], rsi
  0001d	48 8b d9	 mov	 rbx, rcx
  00020	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7Thread@@6B@
  00027	48 89 01	 mov	 QWORD PTR [rcx], rax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thread

; 39   : 		_Thr_set_null(_Thr);

  0002a	33 f6		 xor	 esi, esi
  0002c	89 71 10	 mov	 DWORD PTR [rcx+16], esi
; File c:\users\erlend\documents\github\wind\project\wind\wind\memutil.cpp

; 7    : {

  0002f	b9 02 10 00 00	 mov	 ecx, 4098		; 00001002H
  00034	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  00039	48 89 83 28 08
	00 00		 mov	 QWORD PTR [rbx+2088], rax
  00040	c7 83 30 08 00
	00 02 10 00 00	 mov	 DWORD PTR [rbx+2096], 4098 ; 00001002H
  0004a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7ChunkLoadThread@@6B@
  00051	48 89 03	 mov	 QWORD PTR [rbx], rax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector

; 486  : 		_Myfirst = pointer();

  00054	48 89 b3 40 08
	00 00		 mov	 QWORD PTR [rbx+2112], rsi

; 487  : 		_Mylast = pointer();

  0005b	48 89 b3 48 08
	00 00		 mov	 QWORD PTR [rbx+2120], rsi

; 488  : 		_Myend = pointer();

  00062	48 89 b3 50 08
	00 00		 mov	 QWORD PTR [rbx+2128], rsi
; File c:\users\erlend\documents\github\wind\project\wind\wind\opencl.cpp

; 43   : {

  00069	40 88 b3 58 08
	00 00		 mov	 BYTE PTR [rbx+2136], sil

; 44   : 
; 45   : }
; 46   : 
; 47   : cl::CommandQueue::~CommandQueue()
; 48   : {
; 49   : 	if(okay) clReleaseCommandQueue(queue);
; 50   : }
; 51   : 
; 52   : bool cl::CommandQueue::create()
; 53   : {
; 54   : 	cl_int error = 0;
; 55   : 	queue = clCreateCommandQueue(cl::context, cl::device, 0, &error);
; 56   : 	if(error != CL_SUCCESS)
; 57   : 	{
; 58   : 		GLWindow::instance->postError("Could not create command queue: " + to_string(error), "Command queue creation error");
; 59   : 		return false;
; 60   : 	}
; 61   : 
; 62   : 	okay = true;
; 63   : 	return true;
; 64   : }
; 65   : 
; 66   : bool cl::CommandQueue::sync()
; 67   : {
; 68   : 	cl_int error = clWaitForEvents((cl_uint)lastEvents.size(), &lastEvents[0]);
; 69   : 	if(error != CL_SUCCESS)
; 70   : 	{
; 71   : 		GLWindow::instance->postError("Failed to wait for events to finish: " + to_string(error), "OpenCL sync error");
; 72   : 		return false;
; 73   : 	}
; 74   : 
; 75   : 	for(auto iter = lastEvents.begin(); iter != lastEvents.end(); ++iter)
; 76   : 	{
; 77   : 		error = clReleaseEvent(*iter);
; 78   : 		if(error != CL_SUCCESS)
; 79   : 		{
; 80   : 			GLWindow::instance->postError("Failed to release event: " + to_string(error), "OpenCL sync error");
; 81   : 			return false;
; 82   : 		}
; 83   : 	}
; 84   : 
; 85   : 	lastEvents.clear();
; 86   : 
; 87   : 	return true;
; 88   : }
; 89   : 
; 90   : void cl::CommandQueue::addSyncEvent(cl_event event)
; 91   : {
; 92   : 	lastEvents.push_back(event);
; 93   : }
; 94   : 
; 95   : cl::Program::Program()
; 96   : 	: okay(false)
; 97   : {
; 98   : 
; 99   : }
; 100  : 
; 101  : cl::Program::Program(std::wstring fileName)
; 102  : 	: okay(false), preparedKernel(0), argIndex(0)
; 103  : {
; 104  : 	create(fileName);
; 105  : }
; 106  : 
; 107  : bool cl::Program::create(std::wstring fileName)
; 108  : {
; 109  : 	cl_int error = 0;
; 110  : 
; 111  : 	std::ifstream file(fileName);
; 112  : 
; 113  : 	if(!file.good())
; 114  : 	{
; 115  : 		GLWindow::instance->postError("Invalid/missing file", "OpenCL program creation error");
; 116  : 		file.close();
; 117  : 		return false;
; 118  : 	}
; 119  : 
; 120  : 	std::string source_str = std::string((std::istreambuf_iterator<char>(file)), std::istreambuf_iterator<char>());
; 121  : 	file.close();
; 122  : 	const char* source = source_str.c_str();
; 123  : 
; 124  : 	program = clCreateProgramWithSource(context, 1, &source, NULL, &error);
; 125  : 	if(error != CL_SUCCESS)
; 126  : 	{
; 127  : 		GLWindow::instance->postError("Could not create program: " + to_string(error), "OpenCL program creation error");
; 128  : 		return false;
; 129  : 	}
; 130  : 
; 131  : 	error = clBuildProgram(program, 1, &device, NULL, NULL, NULL);
; 132  : 	if(error != CL_SUCCESS)
; 133  : 	{
; 134  : 		size_t log_size;
; 135  : 		clGetProgramBuildInfo(program, device, CL_PROGRAM_BUILD_LOG, 0, NULL, &log_size);
; 136  : 		char* log_msg = new char[log_size + 1];
; 137  : 		clGetProgramBuildInfo(program, device, CL_PROGRAM_BUILD_LOG, log_size, log_msg, NULL);
; 138  : 
; 139  : 		GLWindow::instance->postError(log_msg, "OpenCL program compilation error");
; 140  : 
; 141  : 		delete[] log_msg;
; 142  : 		return false;
; 143  : 	}
; 144  : 
; 145  : 	okay = true;
; 146  : 	return true;
; 147  : }
; 148  : 
; 149  : cl::Program::~Program()
; 150  : {
; 151  : 	if(okay)
; 152  : 	{
; 153  : 		cl_int error;
; 154  : 
; 155  : 		for(map<std::string, cl_kernel>::const_iterator iter = kernels.begin(); iter != kernels.end(); ++iter)
; 156  : 		{
; 157  : 			error = clReleaseKernel(iter->second);
; 158  : 			if(error != CL_SUCCESS)
; 159  : 			{
; 160  : 				GLWindow::instance->postError("Could not release kernel: " + to_string(error), "OpenCL program deletion error");
; 161  : 				return;
; 162  : 			}
; 163  : 		}
; 164  : 		error = clReleaseProgram(program);
; 165  : 		if(error != CL_SUCCESS)
; 166  : 		{
; 167  : 			GLWindow::instance->postError("Could not release program: " + to_string(error), "OpenCL program deletion error");
; 168  : 		}
; 169  : 	}
; 170  : }
; 171  : 
; 172  : cl_kernel cl::Program::getKernel(std::string kernel)
; 173  : {
; 174  : 	if(!okay) return 0;
; 175  : 	map<std::string, cl_kernel>::iterator it = kernels.find(kernel);
; 176  : 	if(it != kernels.end())
; 177  : 	{
; 178  : 		return it->second;
; 179  : 	}
; 180  : 
; 181  : 	cl_int error = 0;
; 182  : 	cl_kernel k = clCreateKernel(program, kernel.c_str(), &error);
; 183  : 
; 184  : 	if(error == CL_SUCCESS)
; 185  : 	{
; 186  : 		kernels[kernel] = k;
; 187  : 		return k;
; 188  : 	}
; 189  : 
; 190  : 	GLWindow::instance->postError("Tried to use nonexistant kernel: " + to_string(error), "OpenCL kernel error");
; 191  : 	return 0;
; 192  : }
; 193  : 
; 194  : bool cl::Program::prepare(std::string kernel)
; 195  : {
; 196  : 	cl_kernel k = getKernel(kernel);
; 197  : 
; 198  : 	if(k)
; 199  : 	{
; 200  : 		mut.lock();
; 201  : 		preparedKernel = k;
; 202  : 		argIndex = 0;
; 203  : 		return true;
; 204  : 	}
; 205  : 	else
; 206  : 	{
; 207  : 		GLWindow::instance->postError("Could not prepare kernel for execution", "OpenCL kernel error");
; 208  : 		return false;
; 209  : 	}
; 210  : }
; 211  : 
; 212  : bool cl::Program::setArgument(size_t size, const void* value)
; 213  : {
; 214  : 	if(!preparedKernel)
; 215  : 	{
; 216  : 		GLWindow::instance->postError("Tried to set argument for unprepared kernel", "OpenCL kernel argument error");
; 217  : 		return false;
; 218  : 	}
; 219  : 	cl_int error = clSetKernelArg(preparedKernel, argIndex++, size, value);
; 220  : 	if(error != CL_SUCCESS)
; 221  : 	{
; 222  : 		GLWindow::instance->postError("Failed to set kernel argument: " + to_string(error), "OpenCL kernel argument error");
; 223  : 		return false;
; 224  : 	}
; 225  : 	return true;
; 226  : }
; 227  : 
; 228  : bool cl::Program::setArgument(size_t size, Buffer* value)
; 229  : {
; 230  : 	return setArgument(size, &value->mem);
; 231  : }
; 232  : 
; 233  : bool cl::Program::invoke(CommandQueue& queue, cl_uint dimensions, const size_t* globalWorkSize, const size_t* localWorkSize)
; 234  : {
; 235  : 	if(!preparedKernel)
; 236  : 	{
; 237  : 		GLWindow::instance->postError("Tried to execute unprepared kernel", "OpenCL program execution error");
; 238  : 		return false;
; 239  : 	}
; 240  : 
; 241  : 	cl_int error;
; 242  : 	cl_event event = 0;
; 243  : 
; 244  : 	error = clEnqueueNDRangeKernel(queue.queue, preparedKernel, dimensions, NULL, globalWorkSize, localWorkSize, 0, NULL, &event);
; 245  : 	if(error != CL_SUCCESS)
; 246  : 	{
; 247  : 		GLWindow::instance->postError("Failed to exectue kernel: " + to_string(error), "OpenCL program execution error");
; 248  : 		return false;
; 249  : 	}
; 250  : 
; 251  : 	queue.addSyncEvent(event);
; 252  : 
; 253  : 	preparedKernel = 0;
; 254  : 	mut.unlock();
; 255  : 
; 256  : 	return true;
; 257  : }
; 258  : 
; 259  : cl::Buffer::Buffer()
; 260  : 	: okay(false)
; 261  : {

  00070	40 88 b3 60 08
	00 00		 mov	 BYTE PTR [rbx+2144], sil
  00077	40 88 b3 78 08
	00 00		 mov	 BYTE PTR [rbx+2168], sil
  0007e	40 88 b3 90 08
	00 00		 mov	 BYTE PTR [rbx+2192], sil
  00085	40 88 b3 a8 08
	00 00		 mov	 BYTE PTR [rbx+2216], sil
  0008c	40 88 b3 c0 08
	00 00		 mov	 BYTE PTR [rbx+2240], sil
  00093	40 88 b3 d8 08
	00 00		 mov	 BYTE PTR [rbx+2264], sil
  0009a	40 88 b3 f0 08
	00 00		 mov	 BYTE PTR [rbx+2288], sil
  000a1	40 88 b3 08 09
	00 00		 mov	 BYTE PTR [rbx+2312], sil
  000a8	40 88 b3 20 09
	00 00		 mov	 BYTE PTR [rbx+2336], sil
  000af	48 8d bb 38 09
	00 00		 lea	 rdi, QWORD PTR [rbx+2360]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility

; 79   : 		{	// construct childless container

  000b6	48 89 37	 mov	 QWORD PTR [rdi], rsi
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 778  : 		_Map = _Mapptr();

  000b9	48 89 77 08	 mov	 QWORD PTR [rdi+8], rsi

; 779  : 		_Mapsize = 0;

  000bd	48 89 77 10	 mov	 QWORD PTR [rdi+16], rsi

; 780  : 		_Myoff = 0;

  000c1	48 89 77 18	 mov	 QWORD PTR [rdi+24], rsi

; 781  : 		_Mysize = 0;

  000c5	48 89 77 20	 mov	 QWORD PTR [rdi+32], rsi
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  000c9	8d 4e 10	 lea	 ecx, QWORD PTR [rsi+16]
  000cc	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  000d1	48 85 c0	 test	 rax, rax
  000d4	75 06		 jne	 SHORT $LN78@ChunkLoadT

; 29   : 		_Xbad_alloc();	// report no memory

  000d6	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
  000db	cc		 int	 3
$LN78@ChunkLoadT:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 900  : 		this->_Myproxy = _Alproxy.allocate(1);

  000dc	48 89 07	 mov	 QWORD PTR [rdi], rax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 617  : _VARIADIC_EXPAND_0X(_ALLOC_MEMBER_CONSTRUCT, , , , )

  000df	48 89 30	 mov	 QWORD PTR [rax], rsi
  000e2	48 89 70 08	 mov	 QWORD PTR [rax+8], rsi
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 902  : 		this->_Myproxy->_Mycont = this;

  000e6	48 8b 07	 mov	 rax, QWORD PTR [rdi]
  000e9	48 89 38	 mov	 QWORD PTR [rax], rdi
  000ec	48 8d 8b 60 09
	00 00		 lea	 rcx, QWORD PTR [rbx+2400]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 63   : 	return (_Check_C_return(_Mtx_init(_Mtx, _Type)));

  000f3	ba 02 00 00 00	 mov	 edx, 2
  000f8	e8 00 00 00 00	 call	 _Mtx_init

; 32   : 	if (_Res != _Thrd_success)

  000fd	85 c0		 test	 eax, eax
  000ff	74 08		 je	 SHORT $LN114@ChunkLoadT

; 33   : 		_Throw_C_error(_Res);

  00101	8b c8		 mov	 ecx, eax
  00103	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
  00108	90		 npad	 1
$LN114@ChunkLoadT:
  00109	48 8b c3	 mov	 rax, rbx
  0010c	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  00111	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  00116	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0011a	5f		 pop	 rdi
  0011b	c3		 ret	 0
$LN117@ChunkLoadT:
??0ChunkLoadThread@@QEAA@XZ ENDP			; ChunkLoadThread::ChunkLoadThread
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
?dtor$13@?0???0ChunkLoadThread@@QEAA@XZ@4HA PROC	; `ChunkLoadThread::ChunkLoadThread'::`1'::dtor$13
  00000	48 8b 8a 40 00
	00 00		 mov	 rcx, QWORD PTR this$[rdx]
  00007	48 83 c1 08	 add	 rcx, 8
  0000b	e9 00 00 00 00	 jmp	 ??1thread@std@@QEAA@XZ	; std::thread::~thread
?dtor$13@?0???0ChunkLoadThread@@QEAA@XZ@4HA ENDP	; `ChunkLoadThread::ChunkLoadThread'::`1'::dtor$13
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
?dtor$0@?0???0ChunkLoadThread@@QEAA@XZ@4HA PROC		; `ChunkLoadThread::ChunkLoadThread'::`1'::dtor$0
  00010	48 8b 8a 40 00
	00 00		 mov	 rcx, QWORD PTR this$[rdx]
  00017	e9 00 00 00 00	 jmp	 ??1Thread@@QEAA@XZ
?dtor$0@?0???0ChunkLoadThread@@QEAA@XZ@4HA ENDP		; `ChunkLoadThread::ChunkLoadThread'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
?dtor$1@?0???0ChunkLoadThread@@QEAA@XZ@4HA PROC		; `ChunkLoadThread::ChunkLoadThread'::`1'::dtor$1
  0001c	48 8b 8a 40 00
	00 00		 mov	 rcx, QWORD PTR this$[rdx]
  00023	48 81 c1 38 08
	00 00		 add	 rcx, 2104		; 00000838H
  0002a	e9 00 00 00 00	 jmp	 ??1CommandQueue@cl@@QEAA@XZ ; cl::CommandQueue::~CommandQueue
?dtor$1@?0???0ChunkLoadThread@@QEAA@XZ@4HA ENDP		; `ChunkLoadThread::ChunkLoadThread'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
?dtor$2@?0???0ChunkLoadThread@@QEAA@XZ@4HA PROC		; `ChunkLoadThread::ChunkLoadThread'::`1'::dtor$2
  0002f	48 8b 8a 40 00
	00 00		 mov	 rcx, QWORD PTR this$[rdx]
  00036	48 81 c1 60 08
	00 00		 add	 rcx, 2144		; 00000860H
  0003d	e9 00 00 00 00	 jmp	 ??1Buffer@cl@@QEAA@XZ	; cl::Buffer::~Buffer
?dtor$2@?0???0ChunkLoadThread@@QEAA@XZ@4HA ENDP		; `ChunkLoadThread::ChunkLoadThread'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
?dtor$3@?0???0ChunkLoadThread@@QEAA@XZ@4HA PROC		; `ChunkLoadThread::ChunkLoadThread'::`1'::dtor$3
  00042	48 8b 8a 40 00
	00 00		 mov	 rcx, QWORD PTR this$[rdx]
  00049	48 81 c1 78 08
	00 00		 add	 rcx, 2168		; 00000878H
  00050	e9 00 00 00 00	 jmp	 ??1Buffer@cl@@QEAA@XZ	; cl::Buffer::~Buffer
?dtor$3@?0???0ChunkLoadThread@@QEAA@XZ@4HA ENDP		; `ChunkLoadThread::ChunkLoadThread'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
?dtor$4@?0???0ChunkLoadThread@@QEAA@XZ@4HA PROC		; `ChunkLoadThread::ChunkLoadThread'::`1'::dtor$4
  00055	48 8b 8a 40 00
	00 00		 mov	 rcx, QWORD PTR this$[rdx]
  0005c	48 81 c1 90 08
	00 00		 add	 rcx, 2192		; 00000890H
  00063	e9 00 00 00 00	 jmp	 ??1Buffer@cl@@QEAA@XZ	; cl::Buffer::~Buffer
?dtor$4@?0???0ChunkLoadThread@@QEAA@XZ@4HA ENDP		; `ChunkLoadThread::ChunkLoadThread'::`1'::dtor$4
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
?dtor$5@?0???0ChunkLoadThread@@QEAA@XZ@4HA PROC		; `ChunkLoadThread::ChunkLoadThread'::`1'::dtor$5
  00068	48 8b 8a 40 00
	00 00		 mov	 rcx, QWORD PTR this$[rdx]
  0006f	48 81 c1 a8 08
	00 00		 add	 rcx, 2216		; 000008a8H
  00076	e9 00 00 00 00	 jmp	 ??1Buffer@cl@@QEAA@XZ	; cl::Buffer::~Buffer
?dtor$5@?0???0ChunkLoadThread@@QEAA@XZ@4HA ENDP		; `ChunkLoadThread::ChunkLoadThread'::`1'::dtor$5
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
?dtor$6@?0???0ChunkLoadThread@@QEAA@XZ@4HA PROC		; `ChunkLoadThread::ChunkLoadThread'::`1'::dtor$6
  0007b	48 8b 8a 40 00
	00 00		 mov	 rcx, QWORD PTR this$[rdx]
  00082	48 81 c1 c0 08
	00 00		 add	 rcx, 2240		; 000008c0H
  00089	e9 00 00 00 00	 jmp	 ??1Buffer@cl@@QEAA@XZ	; cl::Buffer::~Buffer
?dtor$6@?0???0ChunkLoadThread@@QEAA@XZ@4HA ENDP		; `ChunkLoadThread::ChunkLoadThread'::`1'::dtor$6
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
?dtor$7@?0???0ChunkLoadThread@@QEAA@XZ@4HA PROC		; `ChunkLoadThread::ChunkLoadThread'::`1'::dtor$7
  0008e	48 8b 8a 40 00
	00 00		 mov	 rcx, QWORD PTR this$[rdx]
  00095	48 81 c1 d8 08
	00 00		 add	 rcx, 2264		; 000008d8H
  0009c	e9 00 00 00 00	 jmp	 ??1Buffer@cl@@QEAA@XZ	; cl::Buffer::~Buffer
?dtor$7@?0???0ChunkLoadThread@@QEAA@XZ@4HA ENDP		; `ChunkLoadThread::ChunkLoadThread'::`1'::dtor$7
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
?dtor$8@?0???0ChunkLoadThread@@QEAA@XZ@4HA PROC		; `ChunkLoadThread::ChunkLoadThread'::`1'::dtor$8
  000a1	48 8b 8a 40 00
	00 00		 mov	 rcx, QWORD PTR this$[rdx]
  000a8	48 81 c1 f0 08
	00 00		 add	 rcx, 2288		; 000008f0H
  000af	e9 00 00 00 00	 jmp	 ??1Buffer@cl@@QEAA@XZ	; cl::Buffer::~Buffer
?dtor$8@?0???0ChunkLoadThread@@QEAA@XZ@4HA ENDP		; `ChunkLoadThread::ChunkLoadThread'::`1'::dtor$8
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
?dtor$9@?0???0ChunkLoadThread@@QEAA@XZ@4HA PROC		; `ChunkLoadThread::ChunkLoadThread'::`1'::dtor$9
  000b4	48 8b 8a 40 00
	00 00		 mov	 rcx, QWORD PTR this$[rdx]
  000bb	48 81 c1 08 09
	00 00		 add	 rcx, 2312		; 00000908H
  000c2	e9 00 00 00 00	 jmp	 ??1Buffer@cl@@QEAA@XZ	; cl::Buffer::~Buffer
?dtor$9@?0???0ChunkLoadThread@@QEAA@XZ@4HA ENDP		; `ChunkLoadThread::ChunkLoadThread'::`1'::dtor$9
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
?dtor$10@?0???0ChunkLoadThread@@QEAA@XZ@4HA PROC	; `ChunkLoadThread::ChunkLoadThread'::`1'::dtor$10
  000c7	48 8b 8a 40 00
	00 00		 mov	 rcx, QWORD PTR this$[rdx]
  000ce	48 81 c1 20 09
	00 00		 add	 rcx, 2336		; 00000920H
  000d5	e9 00 00 00 00	 jmp	 ??1Buffer@cl@@QEAA@XZ	; cl::Buffer::~Buffer
?dtor$10@?0???0ChunkLoadThread@@QEAA@XZ@4HA ENDP	; `ChunkLoadThread::ChunkLoadThread'::`1'::dtor$10
text$x	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\mutex
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\users\erlend\documents\github\wind\project\wind\wind\opencl.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
; File c:\users\erlend\documents\github\wind\project\wind\wind\memutil.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thread
;	COMDAT ??1ChunkLoadThread@@QEAA@XZ
_TEXT	SEGMENT
$T1 = 32
this$ = 64
??1ChunkLoadThread@@QEAA@XZ PROC			; ChunkLoadThread::~ChunkLoadThread, COMDAT
$LN64:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 c7 44 24 20
	fe ff ff ff	 mov	 QWORD PTR $T1[rsp], -2
  00013	48 89 5c 24 48	 mov	 QWORD PTR [rsp+72], rbx
  00018	48 89 74 24 50	 mov	 QWORD PTR [rsp+80], rsi
  0001d	48 8b f9	 mov	 rdi, rcx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\mutex

; 33   : 		_Mtx_destroy(&_Mtx);

  00020	48 81 c1 60 09
	00 00		 add	 rcx, 2400		; 00000960H
  00027	e8 00 00 00 00	 call	 _Mtx_destroy
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 1222 : 		_Tidy();

  0002c	48 8d 8f 38 09
	00 00		 lea	 rcx, QWORD PTR [rdi+2360]
  00033	e8 00 00 00 00	 call	 ?_Tidy@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAXXZ ; std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::_Tidy
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 586  : 		::operator delete(_Ptr);

  00038	48 8b 8f 38 09
	00 00		 mov	 rcx, QWORD PTR [rdi+2360]
  0003f	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 912  : 		this->_Myproxy = 0;

  00044	33 f6		 xor	 esi, esi
  00046	48 89 b7 38 09
	00 00		 mov	 QWORD PTR [rdi+2360], rsi
  0004d	48 8d 8f 20 09
	00 00		 lea	 rcx, QWORD PTR [rdi+2336]
  00054	e8 00 00 00 00	 call	 ??1Buffer@cl@@QEAA@XZ	; cl::Buffer::~Buffer
  00059	90		 npad	 1
  0005a	48 8d 8f 08 09
	00 00		 lea	 rcx, QWORD PTR [rdi+2312]
  00061	e8 00 00 00 00	 call	 ??1Buffer@cl@@QEAA@XZ	; cl::Buffer::~Buffer
  00066	90		 npad	 1
  00067	48 8d 8f f0 08
	00 00		 lea	 rcx, QWORD PTR [rdi+2288]
  0006e	e8 00 00 00 00	 call	 ??1Buffer@cl@@QEAA@XZ	; cl::Buffer::~Buffer
  00073	90		 npad	 1
  00074	48 8d 8f d8 08
	00 00		 lea	 rcx, QWORD PTR [rdi+2264]
  0007b	e8 00 00 00 00	 call	 ??1Buffer@cl@@QEAA@XZ	; cl::Buffer::~Buffer
  00080	90		 npad	 1
  00081	48 8d 8f c0 08
	00 00		 lea	 rcx, QWORD PTR [rdi+2240]
  00088	e8 00 00 00 00	 call	 ??1Buffer@cl@@QEAA@XZ	; cl::Buffer::~Buffer
  0008d	90		 npad	 1
  0008e	48 8d 8f a8 08
	00 00		 lea	 rcx, QWORD PTR [rdi+2216]
  00095	e8 00 00 00 00	 call	 ??1Buffer@cl@@QEAA@XZ	; cl::Buffer::~Buffer
  0009a	90		 npad	 1
  0009b	48 8d 8f 90 08
	00 00		 lea	 rcx, QWORD PTR [rdi+2192]
  000a2	e8 00 00 00 00	 call	 ??1Buffer@cl@@QEAA@XZ	; cl::Buffer::~Buffer
  000a7	90		 npad	 1
  000a8	48 8d 8f 78 08
	00 00		 lea	 rcx, QWORD PTR [rdi+2168]
  000af	e8 00 00 00 00	 call	 ??1Buffer@cl@@QEAA@XZ	; cl::Buffer::~Buffer
  000b4	90		 npad	 1
  000b5	48 8d 8f 60 08
	00 00		 lea	 rcx, QWORD PTR [rdi+2144]
  000bc	e8 00 00 00 00	 call	 ??1Buffer@cl@@QEAA@XZ	; cl::Buffer::~Buffer
  000c1	90		 npad	 1
; File c:\users\erlend\documents\github\wind\project\wind\wind\opencl.cpp

; 49   : 	if(okay) clReleaseCommandQueue(queue);

  000c2	40 38 b7 58 08
	00 00		 cmp	 BYTE PTR [rdi+2136], sil
  000c9	74 0d		 je	 SHORT $LN34@ChunkLoadT
  000cb	48 8b 8f 38 08
	00 00		 mov	 rcx, QWORD PTR [rdi+2104]
  000d2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_clReleaseCommandQueue
$LN34@ChunkLoadT:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector

; 1536 : 		if (this->_Myfirst != pointer())

  000d8	48 8b 8f 40 08
	00 00		 mov	 rcx, QWORD PTR [rdi+2112]
  000df	48 85 c9	 test	 rcx, rcx
  000e2	74 1a		 je	 SHORT $LN39@ChunkLoadT
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 586  : 		::operator delete(_Ptr);

  000e4	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector

; 1542 : 			this->_Myfirst = pointer();

  000e9	48 89 b7 40 08
	00 00		 mov	 QWORD PTR [rdi+2112], rsi

; 1543 : 			this->_Mylast = pointer();

  000f0	48 89 b7 48 08
	00 00		 mov	 QWORD PTR [rdi+2120], rsi

; 1544 : 			this->_Myend = pointer();

  000f7	48 89 b7 50 08
	00 00		 mov	 QWORD PTR [rdi+2128], rsi
$LN39@ChunkLoadT:
; File c:\users\erlend\documents\github\wind\project\wind\wind\memutil.cpp

; 13   : 	delete[] heap;

  000fe	48 8b 8f 28 08
	00 00		 mov	 rcx, QWORD PTR [rdi+2088]
  00105	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thread

; 83   : 		return (!_Thr_is_null(_Thr));

  0010a	83 7f 10 00	 cmp	 DWORD PTR [rdi+16], 0

; 57   : 		if (joinable())

  0010e	74 06		 je	 SHORT $LN56@ChunkLoadT

; 58   : 			_XSTD terminate();

  00110	e8 00 00 00 00	 call	 ?terminate@@YAXXZ	; terminate
  00115	cc		 int	 3
$LN56@ChunkLoadT:
  00116	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  0011b	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  00120	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00124	5f		 pop	 rdi
  00125	c3		 ret	 0
$LN63@ChunkLoadT:
??1ChunkLoadThread@@QEAA@XZ ENDP			; ChunkLoadThread::~ChunkLoadThread
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
?dtor$0@?0???1ChunkLoadThread@@QEAA@XZ@4HA PROC		; `ChunkLoadThread::~ChunkLoadThread'::`1'::dtor$0
  00000	48 8b 8a 40 00
	00 00		 mov	 rcx, QWORD PTR this$[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1Thread@@QEAA@XZ
?dtor$0@?0???1ChunkLoadThread@@QEAA@XZ@4HA ENDP		; `ChunkLoadThread::~ChunkLoadThread'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
?dtor$1@?0???1ChunkLoadThread@@QEAA@XZ@4HA PROC		; `ChunkLoadThread::~ChunkLoadThread'::`1'::dtor$1
  0000c	48 8b 8a 40 00
	00 00		 mov	 rcx, QWORD PTR this$[rdx]
  00013	48 81 c1 38 08
	00 00		 add	 rcx, 2104		; 00000838H
  0001a	e9 00 00 00 00	 jmp	 ??1CommandQueue@cl@@QEAA@XZ ; cl::CommandQueue::~CommandQueue
?dtor$1@?0???1ChunkLoadThread@@QEAA@XZ@4HA ENDP		; `ChunkLoadThread::~ChunkLoadThread'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
?dtor$2@?0???1ChunkLoadThread@@QEAA@XZ@4HA PROC		; `ChunkLoadThread::~ChunkLoadThread'::`1'::dtor$2
  0001f	48 8b 8a 40 00
	00 00		 mov	 rcx, QWORD PTR this$[rdx]
  00026	48 81 c1 60 08
	00 00		 add	 rcx, 2144		; 00000860H
  0002d	e9 00 00 00 00	 jmp	 ??1Buffer@cl@@QEAA@XZ	; cl::Buffer::~Buffer
?dtor$2@?0???1ChunkLoadThread@@QEAA@XZ@4HA ENDP		; `ChunkLoadThread::~ChunkLoadThread'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
?dtor$3@?0???1ChunkLoadThread@@QEAA@XZ@4HA PROC		; `ChunkLoadThread::~ChunkLoadThread'::`1'::dtor$3
  00032	48 8b 8a 40 00
	00 00		 mov	 rcx, QWORD PTR this$[rdx]
  00039	48 81 c1 78 08
	00 00		 add	 rcx, 2168		; 00000878H
  00040	e9 00 00 00 00	 jmp	 ??1Buffer@cl@@QEAA@XZ	; cl::Buffer::~Buffer
?dtor$3@?0???1ChunkLoadThread@@QEAA@XZ@4HA ENDP		; `ChunkLoadThread::~ChunkLoadThread'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
?dtor$4@?0???1ChunkLoadThread@@QEAA@XZ@4HA PROC		; `ChunkLoadThread::~ChunkLoadThread'::`1'::dtor$4
  00045	48 8b 8a 40 00
	00 00		 mov	 rcx, QWORD PTR this$[rdx]
  0004c	48 81 c1 90 08
	00 00		 add	 rcx, 2192		; 00000890H
  00053	e9 00 00 00 00	 jmp	 ??1Buffer@cl@@QEAA@XZ	; cl::Buffer::~Buffer
?dtor$4@?0???1ChunkLoadThread@@QEAA@XZ@4HA ENDP		; `ChunkLoadThread::~ChunkLoadThread'::`1'::dtor$4
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
?dtor$5@?0???1ChunkLoadThread@@QEAA@XZ@4HA PROC		; `ChunkLoadThread::~ChunkLoadThread'::`1'::dtor$5
  00058	48 8b 8a 40 00
	00 00		 mov	 rcx, QWORD PTR this$[rdx]
  0005f	48 81 c1 a8 08
	00 00		 add	 rcx, 2216		; 000008a8H
  00066	e9 00 00 00 00	 jmp	 ??1Buffer@cl@@QEAA@XZ	; cl::Buffer::~Buffer
?dtor$5@?0???1ChunkLoadThread@@QEAA@XZ@4HA ENDP		; `ChunkLoadThread::~ChunkLoadThread'::`1'::dtor$5
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
?dtor$6@?0???1ChunkLoadThread@@QEAA@XZ@4HA PROC		; `ChunkLoadThread::~ChunkLoadThread'::`1'::dtor$6
  0006b	48 8b 8a 40 00
	00 00		 mov	 rcx, QWORD PTR this$[rdx]
  00072	48 81 c1 c0 08
	00 00		 add	 rcx, 2240		; 000008c0H
  00079	e9 00 00 00 00	 jmp	 ??1Buffer@cl@@QEAA@XZ	; cl::Buffer::~Buffer
?dtor$6@?0???1ChunkLoadThread@@QEAA@XZ@4HA ENDP		; `ChunkLoadThread::~ChunkLoadThread'::`1'::dtor$6
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
?dtor$7@?0???1ChunkLoadThread@@QEAA@XZ@4HA PROC		; `ChunkLoadThread::~ChunkLoadThread'::`1'::dtor$7
  0007e	48 8b 8a 40 00
	00 00		 mov	 rcx, QWORD PTR this$[rdx]
  00085	48 81 c1 d8 08
	00 00		 add	 rcx, 2264		; 000008d8H
  0008c	e9 00 00 00 00	 jmp	 ??1Buffer@cl@@QEAA@XZ	; cl::Buffer::~Buffer
?dtor$7@?0???1ChunkLoadThread@@QEAA@XZ@4HA ENDP		; `ChunkLoadThread::~ChunkLoadThread'::`1'::dtor$7
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
?dtor$8@?0???1ChunkLoadThread@@QEAA@XZ@4HA PROC		; `ChunkLoadThread::~ChunkLoadThread'::`1'::dtor$8
  00091	48 8b 8a 40 00
	00 00		 mov	 rcx, QWORD PTR this$[rdx]
  00098	48 81 c1 f0 08
	00 00		 add	 rcx, 2288		; 000008f0H
  0009f	e9 00 00 00 00	 jmp	 ??1Buffer@cl@@QEAA@XZ	; cl::Buffer::~Buffer
?dtor$8@?0???1ChunkLoadThread@@QEAA@XZ@4HA ENDP		; `ChunkLoadThread::~ChunkLoadThread'::`1'::dtor$8
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
?dtor$9@?0???1ChunkLoadThread@@QEAA@XZ@4HA PROC		; `ChunkLoadThread::~ChunkLoadThread'::`1'::dtor$9
  000a4	48 8b 8a 40 00
	00 00		 mov	 rcx, QWORD PTR this$[rdx]
  000ab	48 81 c1 08 09
	00 00		 add	 rcx, 2312		; 00000908H
  000b2	e9 00 00 00 00	 jmp	 ??1Buffer@cl@@QEAA@XZ	; cl::Buffer::~Buffer
?dtor$9@?0???1ChunkLoadThread@@QEAA@XZ@4HA ENDP		; `ChunkLoadThread::~ChunkLoadThread'::`1'::dtor$9
text$x	ENDS
; Function compile flags: /Ogtp
; File c:\users\erlend\documents\github\wind\project\wind\wind\threads.cpp
; File c:\users\erlend\documents\github\wind\project\wind\wind\memutil.cpp
; File c:\users\erlend\documents\github\wind\project\wind\wind\threads.cpp
;	COMDAT ??__ErenderThread@@YAXXZ
text$yc	SEGMENT
$T1 = 32
??__ErenderThread@@YAXXZ PROC				; `dynamic initializer for 'renderThread'', COMDAT

; 5    : RenderThread renderThread;

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H
  00004	48 c7 44 24 20
	fe ff ff ff	 mov	 QWORD PTR $T1[rsp], -2
; File c:\users\erlend\documents\github\wind\project\wind\wind\memutil.cpp

; 7    : {

  0000d	b9 02 10 00 00	 mov	 ecx, 4098		; 00001002H
  00012	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  00017	48 89 05 28 08
	00 00		 mov	 QWORD PTR ?renderThread@@3VRenderThread@@A+2088, rax
  0001e	c7 05 30 08 00
	00 02 10 00 00	 mov	 DWORD PTR ?renderThread@@3VRenderThread@@A+2096, 4098 ; 00001002H
  00028	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7RenderThread@@6B@
  0002f	48 89 05 00 00
	00 00		 mov	 QWORD PTR ?renderThread@@3VRenderThread@@A, rax
; File c:\users\erlend\documents\github\wind\project\wind\wind\threads.cpp

; 5    : RenderThread renderThread;

  00036	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??__FrenderThread@@YAXXZ ; `dynamic atexit destructor for 'renderThread''
  0003d	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00041	e9 00 00 00 00	 jmp	 atexit
??__ErenderThread@@YAXXZ ENDP				; `dynamic initializer for 'renderThread''
text$yc	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
?dtor$1@?0???__ErenderThread@@YAXXZ@4HA PROC		; ``dynamic initializer for 'renderThread'''::`1'::dtor$1
  00000	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?renderThread@@3VRenderThread@@A ; renderThread
  00007	48 83 c1 08	 add	 rcx, 8
  0000b	e9 00 00 00 00	 jmp	 ??1thread@std@@QEAA@XZ	; std::thread::~thread
?dtor$1@?0???__ErenderThread@@YAXXZ@4HA ENDP		; ``dynamic initializer for 'renderThread'''::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtp
; File c:\users\erlend\documents\github\wind\project\wind\wind\memutil.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thread
;	COMDAT ??__FrenderThread@@YAXXZ
text$yd	SEGMENT
??__FrenderThread@@YAXXZ PROC				; `dynamic atexit destructor for 'renderThread'', COMDAT
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H
; File c:\users\erlend\documents\github\wind\project\wind\wind\memutil.cpp

; 13   : 	delete[] heap;

  00004	48 8b 0d 28 08
	00 00		 mov	 rcx, QWORD PTR ?renderThread@@3VRenderThread@@A+2088
  0000b	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thread

; 83   : 		return (!_Thr_is_null(_Thr));

  00010	83 3d 10 00 00
	00 00		 cmp	 DWORD PTR ?renderThread@@3VRenderThread@@A+16, 0

; 57   : 		if (joinable())

  00017	75 05		 jne	 SHORT $LN20@dynamic
  00019	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001d	c3		 ret	 0
$LN20@dynamic:

; 58   : 			_XSTD terminate();

  0001e	e8 00 00 00 00	 call	 ?terminate@@YAXXZ	; terminate
  00023	cc		 int	 3
$LN19@dynamic:
??__FrenderThread@@YAXXZ ENDP				; `dynamic atexit destructor for 'renderThread''
text$yd	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thread
; File c:\users\erlend\documents\github\wind\project\wind\wind\memutil.cpp
;	COMDAT ??0RenderThread@@QEAA@XZ
_TEXT	SEGMENT
$T1 = 32
this$dead$ = 64
this$ = 64
??0RenderThread@@QEAA@XZ PROC				; RenderThread::RenderThread, COMDAT
$LN17:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	53		 push	 rbx
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 c7 44 24 20
	fe ff ff ff	 mov	 QWORD PTR $T1[rsp], -2
  00013	48 8d 1d 00 00
	00 00		 lea	 rbx, OFFSET FLAT:?renderThread@@3VRenderThread@@A ; renderThread
  0001a	48 89 5c 24 40	 mov	 QWORD PTR this$[rsp], rbx
  0001f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_7Thread@@6B@
  00026	48 89 0d 00 00
	00 00		 mov	 QWORD PTR ?renderThread@@3VRenderThread@@A, rcx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thread

; 39   : 		_Thr_set_null(_Thr);

  0002d	c7 05 10 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?renderThread@@3VRenderThread@@A+16, 0
; File c:\users\erlend\documents\github\wind\project\wind\wind\memutil.cpp

; 7    : {

  00037	b9 02 10 00 00	 mov	 ecx, 4098		; 00001002H
  0003c	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  00041	48 89 05 28 08
	00 00		 mov	 QWORD PTR ?renderThread@@3VRenderThread@@A+2088, rax
  00048	c7 05 30 08 00
	00 02 10 00 00	 mov	 DWORD PTR ?renderThread@@3VRenderThread@@A+2096, 4098 ; 00001002H
  00052	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_7RenderThread@@6B@
  00059	48 89 0d 00 00
	00 00		 mov	 QWORD PTR ?renderThread@@3VRenderThread@@A, rcx
  00060	48 8b c3	 mov	 rax, rbx
  00063	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00067	5b		 pop	 rbx
  00068	c3		 ret	 0
??0RenderThread@@QEAA@XZ ENDP				; RenderThread::RenderThread
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$dead$ = 64
this$ = 64
?dtor$1@?0???0RenderThread@@QEAA@XZ@4HA PROC		; `RenderThread::RenderThread'::`1'::dtor$1
  00000	48 8b 8a 40 00
	00 00		 mov	 rcx, QWORD PTR this$[rdx]
  00007	48 83 c1 08	 add	 rcx, 8
  0000b	e9 00 00 00 00	 jmp	 ??1thread@std@@QEAA@XZ	; std::thread::~thread
?dtor$1@?0???0RenderThread@@QEAA@XZ@4HA ENDP		; `RenderThread::RenderThread'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtp
; File c:\users\erlend\documents\github\wind\project\wind\wind\memutil.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thread
;	COMDAT ??1RenderThread@@QEAA@XZ
_TEXT	SEGMENT
this$dead$ = 48
??1RenderThread@@QEAA@XZ PROC				; RenderThread::~RenderThread, COMDAT
$LN19:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H
; File c:\users\erlend\documents\github\wind\project\wind\wind\memutil.cpp

; 13   : 	delete[] heap;

  00004	48 8b 0d 28 08
	00 00		 mov	 rcx, QWORD PTR ?renderThread@@3VRenderThread@@A+2088
  0000b	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thread

; 83   : 		return (!_Thr_is_null(_Thr));

  00010	83 3d 10 00 00
	00 00		 cmp	 DWORD PTR ?renderThread@@3VRenderThread@@A+16, 0

; 57   : 		if (joinable())

  00017	75 05		 jne	 SHORT $LN17@RenderThre
  00019	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001d	c3		 ret	 0
$LN17@RenderThre:

; 58   : 			_XSTD terminate();

  0001e	e8 00 00 00 00	 call	 ?terminate@@YAXXZ	; terminate
  00023	cc		 int	 3
$LN16@RenderThre:
??1RenderThread@@QEAA@XZ ENDP				; RenderThread::~RenderThread
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\erlend\documents\github\wind\project\wind\wind\threads.cpp
; File c:\users\erlend\documents\github\wind\project\wind\wind\list.h
; File c:\users\erlend\documents\github\wind\project\wind\wind\threads.cpp
;	COMDAT ?loop@Thread@@KAXPEAV1@@Z
_TEXT	SEGMENT
theThread$ = 48
?loop@Thread@@KAXPEAV1@@Z PROC				; Thread::loop, COMDAT

; 8    : {

$LN30:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 9    : 	theThread->preStart();

  00006	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00009	48 8b d9	 mov	 rbx, rcx
  0000c	ff 50 08	 call	 QWORD PTR [rax+8]

; 10   : 	while(!theThread->quit)

  0000f	80 7b 19 00	 cmp	 BYTE PTR [rbx+25], 0
  00013	0f 85 7d 00 00
	00		 jne	 $LN25@loop
  00019	48 89 6c 24 30	 mov	 QWORD PTR [rsp+48], rbp
  0001e	48 89 74 24 38	 mov	 QWORD PTR [rsp+56], rsi
  00023	48 89 7c 24 40	 mov	 QWORD PTR [rsp+64], rdi
  00028	bd 01 00 00 00	 mov	 ebp, 1
  0002d	0f 1f 00	 npad	 3
$LL8@loop:

; 11   : 	{
; 12   : 		for(int i = 0; i < theThread->taskList.getSize(); i++)

  00030	33 ff		 xor	 edi, edi
  00032	39 bb 20 08 00
	00		 cmp	 DWORD PTR [rbx+2080], edi
  00038	7e 2e		 jle	 SHORT $LN4@loop
  0003a	48 8d 73 20	 lea	 rsi, QWORD PTR [rbx+32]
  0003e	66 90		 npad	 2
$LL6@loop:
; File c:\users\erlend\documents\github\wind\project\wind\wind\list.h

; 53   : 		return List::operator[](index);

  00040	48 8b 0e	 mov	 rcx, QWORD PTR [rsi]
; File c:\users\erlend\documents\github\wind\project\wind\wind\threads.cpp

; 14   : 			if(!theThread->taskList[i]->invoke())

  00043	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00046	ff 10		 call	 QWORD PTR [rax]
  00048	0f b6 0d 00 00
	00 00		 movzx	 ecx, BYTE PTR ?stop@GlobalThread@@3_NA ; GlobalThread::stop
  0004f	48 8d 76 08	 lea	 rsi, QWORD PTR [rsi+8]
  00053	84 c0		 test	 al, al
  00055	0f 44 cd	 cmove	 ecx, ebp
  00058	ff c7		 inc	 edi
  0005a	88 0d 00 00 00
	00		 mov	 BYTE PTR ?stop@GlobalThread@@3_NA, cl ; GlobalThread::stop
  00060	3b bb 20 08 00
	00		 cmp	 edi, DWORD PTR [rbx+2080]
  00066	7c d8		 jl	 SHORT $LL6@loop
$LN4@loop:

; 15   : 			{
; 16   : 				GlobalThread::stop = true;
; 17   : 			}
; 18   : 		}
; 19   : 
; 20   : 		if(theThread->shouldTick())

  00068	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  0006b	48 8b cb	 mov	 rcx, rbx
  0006e	ff 10		 call	 QWORD PTR [rax]
  00070	84 c0		 test	 al, al
  00072	74 0d		 je	 SHORT $LN1@loop

; 21   : 		{
; 22   : 			if(!theThread->tick()) break;

  00074	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00077	48 8b cb	 mov	 rcx, rbx
  0007a	ff 50 28	 call	 QWORD PTR [rax+40]
  0007d	84 c0		 test	 al, al
  0007f	74 06		 je	 SHORT $LN28@loop
$LN1@loop:

; 10   : 	while(!theThread->quit)

  00081	80 7b 19 00	 cmp	 BYTE PTR [rbx+25], 0
  00085	74 a9		 je	 SHORT $LL8@loop
$LN28@loop:
  00087	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  0008c	48 8b 6c 24 30	 mov	 rbp, QWORD PTR [rsp+48]
  00091	48 8b 7c 24 40	 mov	 rdi, QWORD PTR [rsp+64]
$LN25@loop:

; 23   : 		}
; 24   : 	}
; 25   : 	theThread->postStop();

  00096	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00099	48 8b cb	 mov	 rcx, rbx

; 26   : }

  0009c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000a0	5b		 pop	 rbx

; 23   : 		}
; 24   : 	}
; 25   : 	theThread->postStop();

  000a1	48 ff 60 10	 rex_jmp QWORD PTR [rax+16]
?loop@Thread@@KAXPEAV1@@Z ENDP				; Thread::loop
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\erlend\documents\github\wind\project\wind\wind\threads.cpp
;	COMDAT ?shouldTick@Thread@@MEAA_NXZ
_TEXT	SEGMENT
this$ = 8
?shouldTick@Thread@@MEAA_NXZ PROC			; Thread::shouldTick, COMDAT

; 30   : 	return true;

  00000	b0 01		 mov	 al, 1

; 31   : }

  00002	c3		 ret	 0
?shouldTick@Thread@@MEAA_NXZ ENDP			; Thread::shouldTick
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\erlend\documents\github\wind\project\wind\wind\threads.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\functional
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xrefwrap
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thread
; File c:\users\erlend\documents\github\wind\project\wind\wind\threads.cpp
;	COMDAT ?start@Thread@@UEAA_NXZ
_TEXT	SEGMENT
$T1 = 32
$T2 = 40
_Launcher$3 = 56
theThread$ = 128
this$ = 128
?start@Thread@@UEAA_NXZ PROC				; Thread::start, COMDAT

; 34   : {

$LN167:
  00000	40 53		 push	 rbx
  00002	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  00006	48 c7 44 24 20
	fe ff ff ff	 mov	 QWORD PTR $T1[rsp], -2
  0000f	48 8b d9	 mov	 rbx, rcx

; 35   : 	started = true;

  00012	66 c7 41 18 01
	00		 mov	 WORD PTR [rcx+24], 1

; 36   : 	quit = false;
; 37   : 	Thread* theThread = this;

  00018	48 89 8c 24 80
	00 00 00	 mov	 QWORD PTR theThread$[rsp], rcx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 182  : 		{	// construct from target

  00020	48 8d 4c 24 38	 lea	 rcx, QWORD PTR _Launcher$3[rsp]
  00025	e8 00 00 00 00	 call	 ??0_Pad@std@@QEAA@XZ	; std::_Pad::_Pad
  0002a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7?$_LaunchPad@V?$_Bind@$00XQ6AXPEAVThread@@@ZV?$reference_wrapper@PEAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@std@@@std@@6B@
  00031	48 89 44 24 38	 mov	 QWORD PTR _Launcher$3[rsp], rax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\functional

; 1152 : _VARIADIC_EXPAND_0X(_CLASS_BIND, , , , )

  00036	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?loop@Thread@@KAXPEAV1@@Z ; Thread::loop
  0003d	48 89 44 24 58	 mov	 QWORD PTR _Launcher$3[rsp+32], rax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xrefwrap

; 346  : 		{	// construct

  00042	48 8d 84 24 80
	00 00 00	 lea	 rax, QWORD PTR theThread$[rsp]
  0004a	48 89 44 24 60	 mov	 QWORD PTR _Launcher$3[rsp+40], rax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 206  : 	_Launcher._Launch(_Thr);

  0004f	48 8d 54 24 28	 lea	 rdx, QWORD PTR $T2[rsp]
  00054	48 8d 4c 24 38	 lea	 rcx, QWORD PTR _Launcher$3[rsp]
  00059	e8 00 00 00 00	 call	 ?_Launch@_Pad@std@@QEAAXPEAU_Thrd_imp_t@@@Z ; std::_Pad::_Launch
  0005e	90		 npad	 1
  0005f	48 8d 4c 24 38	 lea	 rcx, QWORD PTR _Launcher$3[rsp]
  00064	e8 00 00 00 00	 call	 ??1_Pad@std@@QEAA@XZ	; std::_Pad::~_Pad
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thread

; 83   : 		return (!_Thr_is_null(_Thr));

  00069	83 7b 10 00	 cmp	 DWORD PTR [rbx+16], 0

; 84   : 		}
; 85   : 
; 86   : 	void join();
; 87   : 
; 88   : 	void detach()
; 89   : 		{	// detach thread
; 90   : 		if (!joinable())
; 91   : 			_Throw_Cpp_error(_INVALID_ARGUMENT);
; 92   : 		_Thrd_detachX(_Thr);
; 93   : 		_Thr_set_null(_Thr);
; 94   : 		}
; 95   : 
; 96   : 	id get_id() const _NOEXCEPT;
; 97   : 
; 98   : 	static unsigned int hardware_concurrency() _NOEXCEPT
; 99   : 		{	// return number of hardware thread contexts
; 100  : 		return (::Concurrency::details::_GetConcurrency());
; 101  : 		}
; 102  : 
; 103  : 	native_handle_type native_handle()
; 104  : 		{	// return Win32 HANDLE as void *
; 105  : 		return (_Thr._Hnd);
; 106  : 		}
; 107  : 
; 108  : private:
; 109  : 	thread& _Move_thread(thread& _Other)
; 110  : 		{	// move from _Other
; 111  : 		if (joinable())

  0006d	74 06		 je	 SHORT $LN152@start

; 112  : 			_XSTD terminate();

  0006f	e8 00 00 00 00	 call	 ?terminate@@YAXXZ	; terminate
  00074	cc		 int	 3
$LN152@start:

; 113  : 		_Thr = _Other._Thr;

  00075	48 8b 44 24 28	 mov	 rax, QWORD PTR $T2[rsp]
  0007a	48 89 43 08	 mov	 QWORD PTR [rbx+8], rax
  0007e	48 8b 44 24 30	 mov	 rax, QWORD PTR $T2[rsp+8]
  00083	48 89 43 10	 mov	 QWORD PTR [rbx+16], rax

; 83   : 		return (!_Thr_is_null(_Thr));

  00087	33 c0		 xor	 eax, eax
  00089	39 43 10	 cmp	 DWORD PTR [rbx+16], eax
  0008c	0f 95 c0	 setne	 al
; File c:\users\erlend\documents\github\wind\project\wind\wind\threads.cpp

; 40   : }

  0008f	48 83 c4 70	 add	 rsp, 112		; 00000070H
  00093	5b		 pop	 rbx
  00094	c3		 ret	 0
$LN166@start:
?start@Thread@@UEAA_NXZ ENDP				; Thread::start
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 40
_Launcher$3 = 56
theThread$ = 128
this$ = 128
?dtor$1@?0??start@Thread@@UEAA_NXZ@4HA PROC		; `Thread::start'::`1'::dtor$1
  00000	48 8d 8a 38 00
	00 00		 lea	 rcx, QWORD PTR _Launcher$3[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1?$_LaunchPad@V?$_Bind@$00XQ6AXPEAVThread@@@ZV?$reference_wrapper@PEAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@std@@@std@@QEAA@XZ
?dtor$1@?0??start@Thread@@UEAA_NXZ@4HA ENDP		; `Thread::start'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtp
; File c:\users\erlend\documents\github\wind\project\wind\wind\threads.cpp
;	COMDAT ?stop@Thread@@UEAA_NXZ
_TEXT	SEGMENT
this$ = 48
?stop@Thread@@UEAA_NXZ PROC				; Thread::stop, COMDAT

; 43   : {

$LN6:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 44   : 	quit = true;
; 45   : 	if(started) thread.join();

  00004	80 79 18 00	 cmp	 BYTE PTR [rcx+24], 0
  00008	c6 41 19 01	 mov	 BYTE PTR [rcx+25], 1
  0000c	74 09		 je	 SHORT $LN4@stop
  0000e	48 83 c1 08	 add	 rcx, 8
  00012	e8 00 00 00 00	 call	 ?join@thread@std@@QEAAXXZ ; std::thread::join
$LN4@stop:

; 46   : 	return true;

  00017	b0 01		 mov	 al, 1

; 47   : }

  00019	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001d	c3		 ret	 0
?stop@Thread@@UEAA_NXZ ENDP				; Thread::stop
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\erlend\documents\github\wind\project\wind\wind\threads.cpp
;	COMDAT ?preStart@Thread@@UEAAXXZ
_TEXT	SEGMENT
this$ = 8
?preStart@Thread@@UEAAXXZ PROC				; Thread::preStart, COMDAT

; 51   : 
; 52   : }

  00000	c2 00 00	 ret	 0
?preStart@Thread@@UEAAXXZ ENDP				; Thread::preStart
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\erlend\documents\github\wind\project\wind\wind\threads.cpp
;	COMDAT ?postStop@Thread@@UEAAXXZ
_TEXT	SEGMENT
this$ = 8
?postStop@Thread@@UEAAXXZ PROC				; Thread::postStop, COMDAT

; 56   : 
; 57   : }

  00000	c2 00 00	 ret	 0
?postStop@Thread@@UEAAXXZ ENDP				; Thread::postStop
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\erlend\documents\github\wind\project\wind\wind\threads.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\chrono
; File c:\users\erlend\documents\github\wind\project\wind\wind\threads.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\chrono
; File c:\users\erlend\documents\github\wind\project\wind\wind\threads.cpp
;	COMDAT ?shouldTick@LimitedThread@@MEAA_NXZ
_TEXT	SEGMENT
this$ = 48
?shouldTick@LimitedThread@@MEAA_NXZ PROC		; LimitedThread::shouldTick, COMDAT

; 66   : {

$LN47:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\chrono

; 706  : 		return (time_point(duration(_Xtime_get_ticks())));

  00009	e8 00 00 00 00	 call	 _Xtime_get_ticks
; File c:\users\erlend\documents\github\wind\project\wind\wind\threads.cpp

; 70   : 	__int64 tick = difference / tickTime;

  0000e	4c 63 83 48 08
	00 00		 movsxd	 r8, DWORD PTR [rbx+2120]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\chrono

; 105  : 		{	// construct from representation

  00015	48 2b 83 38 08
	00 00		 sub	 rax, QWORD PTR [rbx+2104]

; 106  : 		static_assert(_Is_ratio<_Period>::value,
; 107  : 			"period not an instance of std::ratio");
; 108  : 		static_assert(0 < _Period::num,
; 109  : 			"duration negative or zero");
; 110  : 		}
; 111  : 
; 112  : 	template<class _Rep2,
; 113  : 		class _Period2>
; 114  : 		duration(const duration<_Rep2, _Period2>& _Dur,
; 115  : 			typename enable_if<treat_as_floating_point<_Rep>::value
; 116  : 				|| ratio_divide<_Period2, _Period>::type::den == 1
; 117  : 					&& !treat_as_floating_point<_Rep2>::value,
; 118  : 				void>::type ** = 0)
; 119  : 		: _MyRep(duration_cast<_Myt>(_Dur).count())
; 120  : 		{	// construct from a duration
; 121  : 		typedef typename ratio_divide<_Period2, _Period>::type _Checked_type;
; 122  : 
; 123  : 		static_assert(_Is_ratio<_Period>::value,
; 124  : 			"period not an instance of std::ratio");
; 125  : 		static_assert(0 < _Period::num,
; 126  : 			"duration negative or zero");
; 127  : 		}
; 128  : 
; 129  : 	_Rep count() const
; 130  : 		{	// get stored rep
; 131  : 		return (_MyRep);
; 132  : 		}
; 133  : 
; 134  : 	_Myt operator+() const
; 135  : 		{	// get value
; 136  : 		return (*this);
; 137  : 		}
; 138  : 
; 139  : 	_Myt operator-() const
; 140  : 		{	// get negated value
; 141  : 		return (_Myt(0 - _MyRep));
; 142  : 		}
; 143  : 
; 144  : 	_Myt& operator++()
; 145  : 		{	// increment rep
; 146  : 		++_MyRep;
; 147  : 		return (*this);
; 148  : 		}
; 149  : 
; 150  : 	_Myt operator++(int)
; 151  : 		{	// postincrement rep
; 152  : 		return (_Myt(_MyRep++));
; 153  : 		}
; 154  : 
; 155  : 	_Myt& operator--()
; 156  : 		{	// decrement rep
; 157  : 		--_MyRep;
; 158  : 		return (*this);
; 159  : 		}
; 160  : 
; 161  : 	_Myt operator--(int)
; 162  : 		{	// postdecrement rep
; 163  : 		return (_Myt(_MyRep--));
; 164  : 		}
; 165  : 
; 166  : 	_Myt& operator+=(const _Myt& _Right)
; 167  : 		{	// add _Right to rep
; 168  : 		_MyRep += _Right._MyRep;
; 169  : 		return (*this);
; 170  : 		}
; 171  : 
; 172  : 	_Myt& operator-=(const _Myt& _Right)
; 173  : 		{	// subtract _Right from rep
; 174  : 		_MyRep -= _Right._MyRep;
; 175  : 		return (*this);
; 176  : 		}
; 177  : 
; 178  : 	_Myt& operator*=(const _Rep& _Right)
; 179  : 		{	// multiply rep by _Right
; 180  : 		_MyRep *= _Right;
; 181  : 		return (*this);
; 182  : 		}
; 183  : 
; 184  : 	_Myt& operator/=(const _Rep& _Right)
; 185  : 		{	// divide rep by _Right
; 186  : 		_MyRep /= _Right;
; 187  : 		return (*this);
; 188  : 		}
; 189  : 
; 190  : 	_Myt& operator%=(const _Rep& _Right)
; 191  : 		{	// modulus rep by _Right
; 192  : 		_MyRep %= _Right;
; 193  : 		return (*this);
; 194  : 		}
; 195  : 
; 196  : 	_Myt& operator%=(const _Myt& _Right)
; 197  : 		{	// modulus rep by _Right
; 198  : 		_MyRep %= _Right.count();
; 199  : 		return (*this);
; 200  : 		}
; 201  : 
; 202  : 	static _Myt zero()
; 203  : 		{	// get zero value
; 204  : 		return (_Myt(duration_values<_Rep>::zero()));
; 205  : 		}
; 206  : 
; 207  : 	static _Myt (min)()
; 208  : 		{	// get minimum value
; 209  : 		return (_Myt((duration_values<_Rep>::min)()));
; 210  : 		}
; 211  : 	static _Myt (max)()
; 212  : 		{	// get maximum value
; 213  : 		return (_Myt((duration_values<_Rep>::max)()));
; 214  : 		}
; 215  : 
; 216  : private:
; 217  : 	_Rep _MyRep;	// the stored rep
; 218  : 	};
; 219  : 
; 220  : template<class _Rep1,
; 221  : 	class _Period1,
; 222  : 	class _Period2>
; 223  : 	class duration<duration<_Rep1, _Period1>, _Period2>
; 224  : 	{	// undefined: duration type as first template argument
; 225  : 	duration()
; 226  : 		{	// check asserts
; 227  : 		static_assert(_Always_false<_Rep1>::value,
; 228  : 			"duration can't have duration as first template argument");
; 229  : 		}
; 230  : 	};
; 231  : 
; 232  : 	// CLASS TEMPLATE _Is_duration
; 233  : template<class _Rep,
; 234  : 	class _Period>
; 235  : 	struct _Is_duration<duration<_Rep, _Period> >
; 236  : 	{	// tests for duration
; 237  : 	static const bool value = true;
; 238  : 	};
; 239  : 
; 240  : template<class _Clock,
; 241  : 	class _Duration = typename _Clock::duration>
; 242  : 	class time_point
; 243  : 	{	// represents a point in time
; 244  : public:
; 245  : 	typedef _Clock clock;
; 246  : 	typedef _Duration duration;
; 247  : 	typedef typename _Duration::rep rep;
; 248  : 	typedef typename _Duration::period period;
; 249  : 
; 250  : 	time_point()
; 251  : 		: _MyDur(_Duration::zero())
; 252  : 		{	// check asserts
; 253  : 		static_assert(_Is_duration<_Duration>::value,
; 254  : 			"duration must be an instance of std::duration");
; 255  : 		}
; 256  : 
; 257  : 	explicit time_point(const _Duration& _Other)
; 258  : 		: _MyDur(_Other)
; 259  : 		{	// construct from a duration
; 260  : 		}
; 261  : 
; 262  : 	template<class _Duration2>
; 263  : 		time_point(const time_point<_Clock, _Duration2>& _Tp,
; 264  : 			typename enable_if<is_convertible<_Duration2, _Duration>::value,
; 265  : 			void>::type ** = 0)
; 266  : 		: _MyDur(_Tp.time_since_epoch())
; 267  : 		{	// construct from another duration
; 268  : 		}
; 269  : 
; 270  : 	_Duration time_since_epoch() const
; 271  : 		{	// get duration from epoch
; 272  : 		return (_MyDur);
; 273  : 		}
; 274  : 
; 275  : 	time_point& operator+=(const _Duration& _Dur)
; 276  : 		{	// increment by duration
; 277  : 		_MyDur += _Dur;
; 278  : 		return (*this);
; 279  : 		}
; 280  : 
; 281  : 	time_point& operator-=(const _Duration& _Dur)
; 282  : 		{	// decrement by duration
; 283  : 		_MyDur -= _Dur;
; 284  : 		return (*this);
; 285  : 		}
; 286  : 
; 287  : 	static time_point (min)()
; 288  : 		{	// get minimum time point
; 289  : 		return (time_point((_Duration::min)()));
; 290  : 		}
; 291  : 	static time_point (max)()
; 292  : 		{	// get maximum time point
; 293  : 		return (time_point((_Duration::max)()));
; 294  : 		}
; 295  : 
; 296  : private:
; 297  : 	_Duration _MyDur;	// duration since the epoch
; 298  : 	};
; 299  : }	// namespace chrono
; 300  : 
; 301  : 	// CLASS TEMPLATE _Lcm (LEAST COMMON MULTIPLE)
; 302  : template<intmax_t _Ax,
; 303  : 	intmax_t _Bx>
; 304  : 	struct _Lcm
; 305  : 	{   /* compute least common multiple of _Ax and _Bx */
; 306  : 	static const intmax_t _Gx = _Gcd<_Ax, _Bx>::value;
; 307  : 	static const intmax_t value = (_Ax / _Gx) * _Bx;
; 308  : 	};
; 309  : 
; 310  : 	// CLASS TEMPLATE common_type SPECIALIZATIONS
; 311  : template<class _Rep1,
; 312  : 	class _Period1,
; 313  : 	class _Rep2,
; 314  : 	class _Period2>
; 315  : 	struct common_type<
; 316  : 		chrono::duration<_Rep1, _Period1>,
; 317  : 		chrono::duration<_Rep2, _Period2> >
; 318  : 	{	// common type of two durations
; 319  : 	typedef chrono::duration<typename common_type<_Rep1, _Rep2>::type,
; 320  : 		ratio<_Gcd<_Period1::num, _Period2::num>::value,
; 321  : 			_Lcm<_Period1::den, _Period2::den>::value> > type;
; 322  : 	};
; 323  : 
; 324  : template<class _Clock,
; 325  : 	class _Duration1,
; 326  : 	class _Duration2>
; 327  : 	struct common_type<
; 328  : 		chrono::time_point<_Clock, _Duration1>,
; 329  : 		chrono::time_point<_Clock, _Duration2> >
; 330  : 	{	// common type of two time points
; 331  : 	typedef chrono::time_point<
; 332  : 		_Clock, typename common_type<_Duration1, _Duration2>::type> type;
; 333  : 	};
; 334  : 
; 335  : namespace chrono {
; 336  : 	// duration ARITHMETIC
; 337  : template<class _Rep1,
; 338  : 	class _Period1,
; 339  : 	class _Rep2,
; 340  : 	class _Period2> inline
; 341  : 	typename common_type<
; 342  : 		duration<_Rep1, _Period1>,
; 343  : 		duration<_Rep2, _Period2> >::type
; 344  : 		operator+(
; 345  : 			const duration<_Rep1, _Period1>& _Left,
; 346  : 			const duration<_Rep2, _Period2>& _Right)
; 347  : 	{	// add two durations
; 348  : 	typedef typename common_type<
; 349  : 		duration<_Rep1, _Period1>,
; 350  : 		duration<_Rep2, _Period2> >::type _CD;
; 351  : 		return (_CD(_Left) += _Right);
; 352  : 		}
; 353  : 
; 354  : template<class _Rep1,
; 355  : 	class _Period1,
; 356  : 	class _Rep2,
; 357  : 	class _Period2> inline
; 358  : 	typename common_type<
; 359  : 		duration<_Rep1, _Period1>,
; 360  : 		duration<_Rep2, _Period2> >::type
; 361  : 		operator-(
; 362  : 			const duration<_Rep1, _Period1>& _Left,
; 363  : 			const duration<_Rep2, _Period2>& _Right)
; 364  : 	{	// subtract two durations
; 365  : 	typedef typename common_type<
; 366  : 		duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _CD;
; 367  : 	return (_CD(_Left) -= _Right);
; 368  : 	}
; 369  : 
; 370  : template<class _Rep1,
; 371  : 	class _Period1,
; 372  : 	class _Rep2> inline
; 373  : 	typename enable_if<is_convertible<_Rep2,
; 374  : 		typename common_type<_Rep1, _Rep2>::type>::value,
; 375  : 		duration<typename common_type<_Rep1, _Rep2>::type, _Period1> >::type
; 376  : 		operator*(
; 377  : 			const duration<_Rep1, _Period1>& _Left,
; 378  : 			const _Rep2& _Right)
; 379  : 	{	// multiply duration by rep
; 380  : 	typedef typename common_type<_Rep1, _Rep2>::type _CR;
; 381  : 	return (duration<_CR, _Period1>(_Left) *= _Right);
; 382  : 	}
; 383  : 
; 384  : template<class _Rep1,
; 385  : 	class _Rep2,
; 386  : 	class _Period2> inline
; 387  : 	typename enable_if<is_convertible<_Rep1,
; 388  : 		typename common_type<_Rep1, _Rep2>::type>::value,
; 389  : 		duration<typename common_type<_Rep1, _Rep2>::type, _Period2> >::type
; 390  : 		operator*(
; 391  : 			const _Rep1& _Left,
; 392  : 			const duration<_Rep2, _Period2>& _Right)
; 393  : 	{	// multiply rep by duration
; 394  : 	return (_Right * _Left);
; 395  : 	}
; 396  : 
; 397  : template<class _Rep1,
; 398  : 	class _Period1,
; 399  : 	class _Rep2> inline
; 400  : 	typename enable_if<is_convertible<_Rep2,
; 401  : 		typename common_type<_Rep1, _Rep2>::type>::value
; 402  : 		&& !_Is_duration<_Rep2>::value,
; 403  : 		duration<typename common_type<_Rep1, _Rep2>::type, _Period1> >::type
; 404  : 		operator/(
; 405  : 			const duration<_Rep1, _Period1>& _Left,
; 406  : 			const _Rep2& _Right)
; 407  : 	{	// divide duration by rep
; 408  : 	typedef typename common_type<_Rep1, _Rep2>::type _CR;
; 409  : 	return (duration<_CR, _Period1>(_Left) /= _Right);
; 410  : 	}
; 411  : 
; 412  : template<class _Rep1,
; 413  : 	class _Period1,
; 414  : 	class _Rep2,
; 415  : 	class _Period2> inline
; 416  : 	typename common_type<_Rep1, _Rep2>::type
; 417  : 		operator/(
; 418  : 			const duration<_Rep1, _Period1>& _Left,
; 419  : 			const duration<_Rep2, _Period2>& _Right)
; 420  : 	{	// divide duration by duration
; 421  : 	typedef typename common_type<
; 422  : 		duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _CD;
; 423  : 	return (_CD(_Left).count() / _CD(_Right).count());
; 424  : 	}
; 425  : 
; 426  : template<class _Rep1,
; 427  : 	class _Period1,
; 428  : 	class _Rep2> inline
; 429  : 	typename enable_if<is_convertible<_Rep2,
; 430  : 		typename common_type<_Rep1, _Rep2>::type>::value
; 431  : 		&& !_Is_duration<_Rep2>::value,
; 432  : 		duration<typename common_type<_Rep1, _Rep2>::type, _Period1> >::type
; 433  : 		operator%(
; 434  : 			const duration<_Rep1, _Period1>& _Left,
; 435  : 			const _Rep2& _Right)
; 436  : 	{	// divide duration by rep
; 437  : 	typedef typename common_type<_Rep1, _Rep2>::type _CR;
; 438  : 	return (duration<_CR, _Period1>(_Left) %= _Right);
; 439  : 	}
; 440  : 
; 441  : template<class _Rep1,
; 442  : 	class _Period1,
; 443  : 	class _Rep2,
; 444  : 	class _Period2> inline
; 445  : 	typename common_type<_Rep1, _Rep2>::type
; 446  : 		operator%(
; 447  : 			const duration<_Rep1, _Period1>& _Left,
; 448  : 			const duration<_Rep2, _Period2>& _Right)
; 449  : 	{	// divide duration by duration
; 450  : 	typedef typename common_type<
; 451  : 		duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _CD;
; 452  : 	return (_CD(_Left).count() % _CD(_Right).count());
; 453  : 	}
; 454  : 
; 455  : 	// duration COMPARISONS
; 456  : template<class _Rep1,
; 457  : 	class _Period1,
; 458  : 	class _Rep2,
; 459  : 	class _Period2> inline
; 460  : 	bool operator==(
; 461  : 		const duration<_Rep1, _Period1>& _Left,
; 462  : 		const duration<_Rep2, _Period2>& _Right)
; 463  : 	{	// test if duration == duration
; 464  : 	typedef typename common_type<
; 465  : 		duration<_Rep1, _Period1>,
; 466  : 		duration<_Rep2, _Period2> >::type _CT;
; 467  : 	return (_CT(_Left).count() == _CT(_Right).count());
; 468  : 	}
; 469  : 
; 470  : template<class _Rep1,
; 471  : 	class _Period1,
; 472  : 	class _Rep2,
; 473  : 	class _Period2> inline
; 474  : 	bool operator!=(
; 475  : 		const duration<_Rep1, _Period1>& _Left,
; 476  : 		const duration<_Rep2, _Period2>& _Right)
; 477  : 	{	// test if duration != duration
; 478  : 	return (!(_Left == _Right));
; 479  : 	}
; 480  : 
; 481  : template<class _Rep1,
; 482  : 	class _Period1,
; 483  : 	class _Rep2,
; 484  : 	class _Period2> inline
; 485  : 	bool operator<(
; 486  : 		const duration<_Rep1, _Period1>& _Left,
; 487  : 		const duration<_Rep2, _Period2>& _Right)
; 488  : 	{	// test if duration < duration
; 489  : 	typedef typename common_type<
; 490  : 		duration<_Rep1, _Period1>,
; 491  : 		duration<_Rep2, _Period2> >::type _CT;
; 492  : 	return (_CT(_Left).count() < _CT(_Right).count());
; 493  : 	}
; 494  : 
; 495  : template<class _Rep1,
; 496  : 	class _Period1,
; 497  : 	class _Rep2,
; 498  : 	class _Period2> inline
; 499  : 	bool operator<=(
; 500  : 		const duration<_Rep1, _Period1>& _Left,
; 501  : 		const duration<_Rep2, _Period2>& _Right)
; 502  : 	{	// test if duration <= duration
; 503  : 	return (!(_Right < _Left));
; 504  : 	}
; 505  : 
; 506  : template<class _Rep1,
; 507  : 	class _Period1,
; 508  : 	class _Rep2,
; 509  : 	class _Period2> inline
; 510  : 	bool operator>(
; 511  : 		const duration<_Rep1, _Period1>& _Left,
; 512  : 		const duration<_Rep2, _Period2>& _Right)
; 513  : 	{	// test if duration > duration
; 514  : 	return (_Right < _Left);
; 515  : 	}
; 516  : 
; 517  : template<class _Rep1,
; 518  : 	class _Period1,
; 519  : 	class _Rep2,
; 520  : 	class _Period2> inline
; 521  : 	bool operator>=(
; 522  : 		const duration<_Rep1, _Period1>& _Left,
; 523  : 		const duration<_Rep2, _Period2>& _Right)
; 524  : 	{	// test if duration >= duration
; 525  : 	return (!(_Left < _Right));
; 526  : 	}
; 527  : 
; 528  : 	// duration_cast
; 529  : template<class _To,
; 530  : 	class _Rep,
; 531  : 	class _Period> inline
; 532  : 	typename enable_if<_Is_duration<_To>::value,
; 533  : 		_To>::type
; 534  : 		duration_cast(const duration<_Rep, _Period>& _Dur)
; 535  : 	{	// convert duration to another duration
; 536  : 	typedef typename ratio_divide<_Period, typename _To::period>::type _CF;
; 537  : 	typedef typename common_type<
; 538  : 		typename common_type<typename _To::rep, _Rep>::type,
; 539  : 			intmax_t>::type _CR;
; 540  : 	if (_CF::num == 1 && _CF::den == 1)
; 541  : 		return (_To(static_cast<typename _To::rep>(_Dur.count())));
; 542  : 	else if (_CF::num != 1 && _CF::den == 1)
; 543  : 		return (_To(static_cast<typename _To::rep>(

  0001c	48 6b c0 64	 imul	 rax, 100		; 00000064H
; File c:\users\erlend\documents\github\wind\project\wind\wind\threads.cpp

; 70   : 	__int64 tick = difference / tickTime;

  00020	48 99		 cdq
  00022	49 f7 f8	 idiv	 r8

; 71   : 	__int64 ticksToProcess = tick - lastTick;

  00025	48 8b c8	 mov	 rcx, rax
  00028	48 2b 8b 40 08
	00 00		 sub	 rcx, QWORD PTR [rbx+2112]

; 72   : 	lastTick = tick;

  0002f	48 89 83 40 08
	00 00		 mov	 QWORD PTR [rbx+2112], rax

; 73   : 
; 74   : 	if(ticksToProcess > 0)

  00036	48 85 c9	 test	 rcx, rcx
  00039	7e 12		 jle	 SHORT $LN1@shouldTick

; 75   : 	{
; 76   : 		lastTick++;

  0003b	48 ff c0	 inc	 rax
  0003e	48 89 83 40 08
	00 00		 mov	 QWORD PTR [rbx+2112], rax

; 77   : 		return true;

  00045	b0 01		 mov	 al, 1

; 80   : }

  00047	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0004b	5b		 pop	 rbx
  0004c	c3		 ret	 0
$LN1@shouldTick:

; 78   : 	}
; 79   : 	return false;

  0004d	32 c0		 xor	 al, al

; 80   : }

  0004f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00053	5b		 pop	 rbx
  00054	c3		 ret	 0
?shouldTick@LimitedThread@@MEAA_NXZ ENDP		; LimitedThread::shouldTick
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\erlend\documents\github\wind\project\wind\wind\threads.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\time.inl
; File c:\users\erlend\documents\github\wind\project\wind\wind\threads.cpp
;	COMDAT ??__Eworld@GlobalThread@@YAXXZ
text$yc	SEGMENT
??__Eworld@GlobalThread@@YAXXZ PROC			; GlobalThread::`dynamic initializer for 'world'', COMDAT

; 85   : World GlobalThread::world(time(0));

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\time.inl

; 133  :     return _time64(_Time);

  00004	33 c9		 xor	 ecx, ecx
  00006	e8 00 00 00 00	 call	 _time64
  0000b	48 8b d0	 mov	 rdx, rax
; File c:\users\erlend\documents\github\wind\project\wind\wind\threads.cpp

  0000e	e8 00 00 00 00	 call	 ??0World@@QEAA@I@Z	; World::World
  00013	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??__Fworld@GlobalThread@@YAXXZ ; GlobalThread::`dynamic atexit destructor for 'world''
  0001a	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001e	e9 00 00 00 00	 jmp	 atexit
??__Eworld@GlobalThread@@YAXXZ ENDP			; GlobalThread::`dynamic initializer for 'world''
text$yc	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??__Fworld@GlobalThread@@YAXXZ
text$yd	SEGMENT
??__Fworld@GlobalThread@@YAXXZ PROC			; GlobalThread::`dynamic atexit destructor for 'world'', COMDAT
  00000	e9 00 00 00 00	 jmp	 ??1World@@QEAA@XZ	; World::~World
??__Fworld@GlobalThread@@YAXXZ ENDP			; GlobalThread::`dynamic atexit destructor for 'world''
text$yd	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\chrono
;	COMDAT ??0?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@chrono@std@@QEAA@AEBV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@12@@Z
_TEXT	SEGMENT
this$ = 8
_Other$ = 16
??0?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@chrono@std@@QEAA@AEBV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@12@@Z PROC ; std::chrono::time_point<std::chrono::system_clock,std::chrono::duration<__int64,std::ratio<1,10000000> > >::time_point<std::chrono::system_clock,std::chrono::duration<__int64,std::ratio<1,10000000> > >, COMDAT

; 259  : 		{	// construct from a duration

  00000	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  00003	48 89 01	 mov	 QWORD PTR [rcx], rax

; 260  : 		}

  00006	48 8b c1	 mov	 rax, rcx
  00009	c3		 ret	 0
??0?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@chrono@std@@QEAA@AEBV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@12@@Z ENDP ; std::chrono::time_point<std::chrono::system_clock,std::chrono::duration<__int64,std::ratio<1,10000000> > >::time_point<std::chrono::system_clock,std::chrono::duration<__int64,std::ratio<1,10000000> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\chrono
;	COMDAT ?time_since_epoch@?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@chrono@std@@QEBA?AV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@XZ
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
?time_since_epoch@?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@chrono@std@@QEBA?AV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@XZ PROC ; std::chrono::time_point<std::chrono::system_clock,std::chrono::duration<__int64,std::ratio<1,10000000> > >::time_since_epoch, COMDAT

; 272  : 		return (_MyDur);

  00000	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00003	48 89 02	 mov	 QWORD PTR [rdx], rax
  00006	48 8b c2	 mov	 rax, rdx

; 273  : 		}

  00009	c3		 ret	 0
?time_since_epoch@?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@chrono@std@@QEBA?AV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@XZ ENDP ; std::chrono::time_point<std::chrono::system_clock,std::chrono::duration<__int64,std::ratio<1,10000000> > >::time_since_epoch
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\chrono
;	COMDAT ?count@?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@chrono@std@@QEBA_JXZ
_TEXT	SEGMENT
this$ = 8
?count@?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@chrono@std@@QEBA_JXZ PROC ; std::chrono::duration<__int64,std::ratio<1,10000000> >::count, COMDAT

; 131  : 		return (_MyRep);

  00000	48 8b 01	 mov	 rax, QWORD PTR [rcx]

; 132  : 		}

  00003	c3		 ret	 0
?count@?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@chrono@std@@QEBA_JXZ ENDP ; std::chrono::duration<__int64,std::ratio<1,10000000> >::count
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\queue
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\queue
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\queue
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\queue
;	COMDAT ??0?$queue@V?$shared_ptr@VChunkBase@@@std@@V?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@2@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??0?$queue@V?$shared_ptr@VChunkBase@@@std@@V?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@2@@std@@QEAA@XZ PROC ; std::queue<std::shared_ptr<ChunkBase>,std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > > >::queue<std::shared_ptr<ChunkBase>,std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > > >, COMDAT

; 30   : 		{	// construct with empty container

$LN54:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility

; 79   : 		{	// construct childless container

  0000a	33 ff		 xor	 edi, edi
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\queue

; 30   : 		{	// construct with empty container

  0000c	48 8b d9	 mov	 rbx, rcx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility

; 79   : 		{	// construct childless container

  0000f	48 89 39	 mov	 QWORD PTR [rcx], rdi
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 778  : 		_Map = _Mapptr();

  00012	48 89 79 08	 mov	 QWORD PTR [rcx+8], rdi

; 779  : 		_Mapsize = 0;

  00016	48 89 79 10	 mov	 QWORD PTR [rcx+16], rdi

; 780  : 		_Myoff = 0;

  0001a	48 89 79 18	 mov	 QWORD PTR [rcx+24], rdi

; 781  : 		_Mysize = 0;

  0001e	48 89 79 20	 mov	 QWORD PTR [rcx+32], rdi
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  00022	8d 4f 10	 lea	 ecx, QWORD PTR [rdi+16]
  00025	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  0002a	48 85 c0	 test	 rax, rax
  0002d	74 1e		 je	 SHORT $LN52@queue
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 900  : 		this->_Myproxy = _Alproxy.allocate(1);

  0002f	48 89 03	 mov	 QWORD PTR [rbx], rax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 617  : _VARIADIC_EXPAND_0X(_ALLOC_MEMBER_CONSTRUCT, , , , )

  00032	48 89 38	 mov	 QWORD PTR [rax], rdi
  00035	48 89 78 08	 mov	 QWORD PTR [rax+8], rdi
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 902  : 		this->_Myproxy->_Mycont = this;

  00039	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  0003c	48 89 18	 mov	 QWORD PTR [rax], rbx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\queue

; 31   : 		}

  0003f	48 8b c3	 mov	 rax, rbx
  00042	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00047	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0004b	5f		 pop	 rdi
  0004c	c3		 ret	 0
$LN52@queue:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 29   : 		_Xbad_alloc();	// report no memory

  0004d	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
  00052	cc		 int	 3
$LN51@queue:
??0?$queue@V?$shared_ptr@VChunkBase@@@std@@V?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@2@@std@@QEAA@XZ ENDP ; std::queue<std::shared_ptr<ChunkBase>,std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > > >::queue<std::shared_ptr<ChunkBase>,std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
;	COMDAT ??1?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAA@XZ PROC ; std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::~deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >, COMDAT

; 1221 : 		{	// destroy the deque

$LN14:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 1222 : 		_Tidy();

  00009	e8 00 00 00 00	 call	 ?_Tidy@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAXXZ ; std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::_Tidy
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 586  : 		::operator delete(_Ptr);

  0000e	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  00011	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 912  : 		this->_Myproxy = 0;

  00016	48 c7 03 00 00
	00 00		 mov	 QWORD PTR [rbx], 0

; 1223 : 		}

  0001d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00021	5b		 pop	 rbx
  00022	c3		 ret	 0
??1?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAA@XZ ENDP ; std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::~deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\chrono
;	COMDAT ?count@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEBA_JXZ
_TEXT	SEGMENT
this$ = 8
?count@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEBA_JXZ PROC ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::count, COMDAT

; 131  : 		return (_MyRep);

  00000	48 8b 01	 mov	 rax, QWORD PTR [rcx]

; 132  : 		}

  00003	c3		 ret	 0
?count@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEBA_JXZ ENDP ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::count
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
;	COMDAT ??0?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??0?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAA@XZ PROC ; std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >, COMDAT

; 956  : 		{	// construct empty deque

$LN50:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility

; 79   : 		{	// construct childless container

  0000a	33 ff		 xor	 edi, edi
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 956  : 		{	// construct empty deque

  0000c	48 8b d9	 mov	 rbx, rcx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility

; 79   : 		{	// construct childless container

  0000f	48 89 39	 mov	 QWORD PTR [rcx], rdi
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 778  : 		_Map = _Mapptr();

  00012	48 89 79 08	 mov	 QWORD PTR [rcx+8], rdi

; 779  : 		_Mapsize = 0;

  00016	48 89 79 10	 mov	 QWORD PTR [rcx+16], rdi

; 780  : 		_Myoff = 0;

  0001a	48 89 79 18	 mov	 QWORD PTR [rcx+24], rdi

; 781  : 		_Mysize = 0;

  0001e	48 89 79 20	 mov	 QWORD PTR [rcx+32], rdi
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  00022	8d 4f 10	 lea	 ecx, QWORD PTR [rdi+16]
  00025	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  0002a	48 85 c0	 test	 rax, rax
  0002d	74 1e		 je	 SHORT $LN48@deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 900  : 		this->_Myproxy = _Alproxy.allocate(1);

  0002f	48 89 03	 mov	 QWORD PTR [rbx], rax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 617  : _VARIADIC_EXPAND_0X(_ALLOC_MEMBER_CONSTRUCT, , , , )

  00032	48 89 38	 mov	 QWORD PTR [rax], rdi
  00035	48 89 78 08	 mov	 QWORD PTR [rax+8], rdi
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 902  : 		this->_Myproxy->_Mycont = this;

  00039	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  0003c	48 89 18	 mov	 QWORD PTR [rax], rbx

; 957  : 		}

  0003f	48 8b c3	 mov	 rax, rbx
  00042	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00047	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0004b	5f		 pop	 rdi
  0004c	c3		 ret	 0
$LN48@deque:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 29   : 		_Xbad_alloc();	// report no memory

  0004d	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
  00052	cc		 int	 3
$LN47@deque:
??0?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAA@XZ ENDP ; std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
;	COMDAT ?_Tidy@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAXXZ
_TEXT	SEGMENT
this$ = 48
?_Tidy@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAXXZ PROC ; std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::_Tidy, COMDAT

; 1857 : 		{	// free all storage

$LN65:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	48 8b d9	 mov	 rbx, rcx

; 788  : 		}
; 789  : 
; 790  : 	_Mapptr _Map;		// pointer to array of pointers to blocks
; 791  : 	size_type _Mapsize;	// size of map array, zero or 2^N
; 792  : 	size_type _Myoff;	// offset of initial element
; 793  : 	size_type _Mysize;	// current length of sequence
; 794  : 	};
; 795  : 
; 796  : 		// TEMPLATE CLASS _Deque_alloc
; 797  : template<bool _Al_has_storage,
; 798  : 	class _Alloc_types>
; 799  : 	class _Deque_alloc
; 800  : 		: public _Deque_val<typename _Alloc_types::_Val_types>
; 801  : 	{	// base class for deque to hold allocator with storage
; 802  : public:
; 803  : 	typedef _Deque_alloc<_Al_has_storage, _Alloc_types> _Myt;
; 804  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 805  : 	typedef typename _Alloc_types::_Alty _Alty;
; 806  : 
; 807  : 	typedef typename _Alloc_types::_Alpty _Alpty;
; 808  : 
; 809  : 	_Deque_alloc(const _Alloc& _Al = _Alloc())
; 810  : 		: _Alval(_Al)
; 811  : 		{	// construct allocators from _Al
; 812  : 		_Alloc_proxy();
; 813  : 		}
; 814  : 
; 815  : 	~_Deque_alloc() _NOEXCEPT
; 816  : 		{	// destroy proxy
; 817  : 		_Free_proxy();
; 818  : 		}
; 819  : 
; 820  : 	void _Change_alloc(const _Alty& _Al)
; 821  : 		{	// replace old allocator
; 822  : 		_Free_proxy();
; 823  : 		_Alval = _Al;
; 824  : 		_Alloc_proxy();
; 825  : 		}
; 826  : 
; 827  : 	void _Swap_alloc(_Myt& _Right)
; 828  : 		{	// swap allocators
; 829  : 		_Swap_adl(_Alval, _Right._Alval);
; 830  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 831  : 		}
; 832  : 
; 833  : 	void _Alloc_proxy()
; 834  : 		{	// construct proxy from _Alval
; 835  : 		typename _Alty::template rebind<_Container_proxy>::other
; 836  : 			_Alproxy(_Alval);
; 837  : 		this->_Myproxy = _Alproxy.allocate(1);
; 838  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 839  : 		this->_Myproxy->_Mycont = this;
; 840  : 		}
; 841  : 
; 842  : 	void _Free_proxy()
; 843  : 		{	// destroy proxy
; 844  : 		typename _Alty::template rebind<_Container_proxy>::other
; 845  : 			_Alproxy(_Alval);
; 846  : 		this->_Orphan_all();
; 847  : 		_Alproxy.destroy(this->_Myproxy);
; 848  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 849  : 		this->_Myproxy = 0;
; 850  : 		}
; 851  : 
; 852  : 	_Alty& _Getal()
; 853  : 		{	// get reference to allocator
; 854  : 		return (_Alval);
; 855  : 		}
; 856  : 
; 857  : 	const _Alty& _Getal() const
; 858  : 		{	// get reference to allocator
; 859  : 		return (_Alval);
; 860  : 		}
; 861  : 
; 862  : 	_Alty _Alval;	// allocator object for stored elements
; 863  : 	};
; 864  : 
; 865  : template<class _Alloc_types>
; 866  : 	class _Deque_alloc<false, _Alloc_types>
; 867  : 		: public _Deque_val<typename _Alloc_types::_Val_types>
; 868  : 	{	// base class for deque to hold allocator with no storage
; 869  : public:
; 870  : 	typedef _Deque_alloc<false, _Alloc_types> _Myt;
; 871  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 872  : 
; 873  : 	typedef typename _Alloc_types::_Alty _Alty;
; 874  : 
; 875  : 	typedef typename _Alloc_types::_Alpty _Alpty;
; 876  : 
; 877  : 	_Deque_alloc(const _Alloc& = _Alloc())
; 878  : 		{	// construct allocators from _Al
; 879  : 		_Alloc_proxy();
; 880  : 		}
; 881  : 
; 882  : 	~_Deque_alloc() _NOEXCEPT
; 883  : 		{	// destroy proxy
; 884  : 		_Free_proxy();
; 885  : 		}
; 886  : 
; 887  : 	void _Change_alloc(const _Alty&)
; 888  : 		{	// replace old allocator
; 889  : 		}
; 890  : 
; 891  : 	void _Swap_alloc(_Myt& _Right)
; 892  : 		{	// swap allocators
; 893  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 894  : 		}
; 895  : 
; 896  : 	void _Alloc_proxy()
; 897  : 		{	// construct proxy from _Alval
; 898  : 		typename _Alty::template rebind<_Container_proxy>::other
; 899  : 			_Alproxy;
; 900  : 		this->_Myproxy = _Alproxy.allocate(1);
; 901  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 902  : 		this->_Myproxy->_Mycont = this;
; 903  : 		}
; 904  : 
; 905  : 	void _Free_proxy()
; 906  : 		{	// destroy proxy
; 907  : 		typename _Alty::template rebind<_Container_proxy>::other
; 908  : 			_Alproxy;
; 909  : 		this->_Orphan_all();
; 910  : 		_Alproxy.destroy(this->_Myproxy);
; 911  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 912  : 		this->_Myproxy = 0;
; 913  : 		}
; 914  : 
; 915  : 	_Alty _Getal() const
; 916  : 		{	// get reference to allocator
; 917  : 		return (_Alty());
; 918  : 		}
; 919  : 	};
; 920  : 
; 921  : 		// TEMPLATE CLASS deque
; 922  : template<class _Ty,
; 923  : 	class _Alloc = allocator<_Ty> >
; 924  : 	class deque
; 925  : 		: public _Deque_alloc<!is_empty<_Alloc>::value,
; 926  : 			_Deque_base_types<_Ty, _Alloc> >
; 927  : 	{	// circular queue of pointers to blocks
; 928  : public:
; 929  : 	typedef deque<_Ty, _Alloc> _Myt;
; 930  : 	typedef _Deque_alloc<!is_empty<_Alloc>::value,
; 931  : 		_Deque_base_types<_Ty, _Alloc> > _Mybase;
; 932  : 	typedef _Alloc allocator_type;
; 933  : 
; 934  : 	typedef typename _Mybase::_Alty _Alty;
; 935  : 	typedef typename _Mybase::_Alpty _Alpty;
; 936  : 	typedef typename _Mybase::_Mapptr _Mapptr;
; 937  : 
; 938  : 	typedef typename _Mybase::value_type value_type;
; 939  : 	typedef typename _Mybase::size_type size_type;
; 940  : 	typedef typename _Mybase::difference_type difference_type;
; 941  : 	typedef typename _Mybase::pointer pointer;
; 942  : 	typedef typename _Mybase::const_pointer const_pointer;
; 943  : 	typedef typename _Mybase::reference reference;
; 944  : 	typedef typename _Mybase::const_reference const_reference;
; 945  : 
; 946  : 	typedef typename _Mybase::iterator iterator;
; 947  : 	typedef typename _Mybase::const_iterator const_iterator;
; 948  : 
; 949  : 	typedef _STD reverse_iterator<iterator> reverse_iterator;
; 950  : 	typedef _STD reverse_iterator<const_iterator> const_reverse_iterator;
; 951  : 
; 952  : 	static const int _EEM_DS = _DEQUESIZ;
; 953  : 	enum {_EEN_DS = _DEQUESIZ};	// helper for expression evaluator
; 954  : 	deque()
; 955  : 		: _Mybase()
; 956  : 		{	// construct empty deque
; 957  : 		}
; 958  : 
; 959  : 	explicit deque(const _Alloc& _Al)
; 960  : 		: _Mybase(_Al)
; 961  : 		{	// construct empty deque with allocator
; 962  : 		}
; 963  : 
; 964  : 	explicit deque(size_type _Count)
; 965  : 		: _Mybase()
; 966  : 		{	// construct from _Count * value_type()
; 967  : 		resize(_Count);
; 968  : 		}
; 969  : 
; 970  : 	deque(size_type _Count, const value_type& _Val)
; 971  : 		: _Mybase()
; 972  : 		{	// construct from _Count * _Val
; 973  : 		_Construct_n(_Count, _Val);
; 974  : 		}
; 975  : 
; 976  : 	deque(size_type _Count, const value_type& _Val, const _Alloc& _Al)
; 977  : 		: _Mybase(_Al)
; 978  : 		{	// construct from _Count * _Val with allocator
; 979  : 		_Construct_n(_Count, _Val);
; 980  : 		}
; 981  : 
; 982  : 	deque(const _Myt& _Right)
; 983  : 
; 984  :  #if _HAS_CPP0X
; 985  : 		: _Mybase(_Right._Getal().select_on_container_copy_construction())
; 986  : 
; 987  :  #else /* _HAS_CPP0X */
; 988  : 		: _Mybase(_Right._Getal())
; 989  :  #endif /* _HAS_CPP0X */
; 990  : 
; 991  : 		{	// construct by copying _Right
; 992  : 		_TRY_BEGIN
; 993  : 		insert(begin(), _Right.begin(), _Right.end());
; 994  : 		_CATCH_ALL
; 995  : 		_Tidy();
; 996  : 		_RERAISE;
; 997  : 		_CATCH_END
; 998  : 		}
; 999  : 
; 1000 : 	deque(const _Myt& _Right, const _Alloc& _Al)
; 1001 : 		: _Mybase(_Al)
; 1002 : 		{	// construct by copying _Right
; 1003 : 		_TRY_BEGIN
; 1004 : 		insert(begin(), _Right.begin(), _Right.end());
; 1005 : 		_CATCH_ALL
; 1006 : 		_Tidy();
; 1007 : 		_RERAISE;
; 1008 : 		_CATCH_END
; 1009 : 		}
; 1010 : 
; 1011 : 	template<class _Iter>
; 1012 : 		deque(_Iter _First, _Iter _Last,
; 1013 : 			typename enable_if<_Is_iterator<_Iter>::value,
; 1014 : 				void>::type ** = 0)
; 1015 : 		: _Mybase()
; 1016 : 		{	// construct from [_First, _Last)
; 1017 : 		_Construct(_First, _Last);
; 1018 : 		}
; 1019 : 
; 1020 : 	template<class _Iter>
; 1021 : 		deque(_Iter _First, _Iter _Last, const _Alloc& _Al,
; 1022 : 			typename enable_if<_Is_iterator<_Iter>::value,
; 1023 : 				void>::type ** = 0)
; 1024 : 		: _Mybase(_Al)
; 1025 : 		{	// construct from [_First, _Last) with allocator
; 1026 : 		_Construct(_First, _Last);
; 1027 : 		}
; 1028 : 
; 1029 : 	template<class _Iter>
; 1030 : 		void _Construct(_Iter _First, _Iter _Last)
; 1031 : 		{	// initialize from [_First, _Last), input iterators
; 1032 : 		_TRY_BEGIN
; 1033 : 		insert(begin(), _First, _Last);
; 1034 : 		_CATCH_ALL
; 1035 : 		_Tidy();
; 1036 : 		_RERAISE;
; 1037 : 		_CATCH_END
; 1038 : 		}
; 1039 : 
; 1040 : 	void _Construct_n(size_type _Count, const value_type& _Val)
; 1041 : 		{	// construct from _Count * _Val
; 1042 : 		_TRY_BEGIN
; 1043 : 		_Insert_n(begin(), _Count, _Val);
; 1044 : 		_CATCH_ALL
; 1045 : 		_Tidy();
; 1046 : 		_RERAISE;
; 1047 : 		_CATCH_END
; 1048 : 		}
; 1049 : 
; 1050 : #define _PUSH_FRONT_BEGIN \
; 1051 : 	if (this->_Myoff % _DEQUESIZ == 0 \
; 1052 : 		&& this->_Mapsize <= (this->_Mysize + _DEQUESIZ) / _DEQUESIZ) \
; 1053 : 		_Growmap(1); \
; 1054 : 	this->_Myoff &= this->_Mapsize * _DEQUESIZ - 1; \
; 1055 : 	size_type _Newoff = this->_Myoff != 0 ? this->_Myoff \
; 1056 : 		: this->_Mapsize * _DEQUESIZ; \
; 1057 : 	size_type _Block = this->_Getblock(--_Newoff); \
; 1058 : 	if (this->_Map[_Block] == pointer()) \
; 1059 : 		this->_Map[_Block] = this->_Getal().allocate(_DEQUESIZ)
; 1060 : 
; 1061 : #define _PUSH_FRONT_END \
; 1062 : 	this->_Myoff = _Newoff; \
; 1063 : 	++this->_Mysize
; 1064 : 
; 1065 : #define _PUSH_BACK_BEGIN \
; 1066 : 	if ((this->_Myoff + this->_Mysize) % _DEQUESIZ == 0 \
; 1067 : 		&& this->_Mapsize <= (this->_Mysize + _DEQUESIZ) / _DEQUESIZ) \
; 1068 : 		_Growmap(1); \
; 1069 : 	this->_Myoff &= this->_Mapsize * _DEQUESIZ - 1; \
; 1070 : 	size_type _Newoff = this->_Myoff + this->_Mysize; \
; 1071 : 	size_type _Block = this->_Getblock(_Newoff); \
; 1072 : 	if (this->_Map[_Block] == pointer()) \
; 1073 : 		this->_Map[_Block] = this->_Getal().allocate(_DEQUESIZ)
; 1074 : 
; 1075 : #define _PUSH_BACK_END \
; 1076 : 	++this->_Mysize
; 1077 : 
; 1078 : 	deque(_Myt&& _Right)
; 1079 : 		: _Mybase(_Right._Getal())
; 1080 : 		{	// construct by moving _Right
; 1081 : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 1082 : 		}
; 1083 : 
; 1084 : 	deque(_Myt&& _Right, const _Alloc& _Al)
; 1085 : 		: _Mybase(_Al)
; 1086 : 		{	// construct by moving _Right
; 1087 : 		if (this->_Getal() != _Right._Getal())
; 1088 : 			assign(_STD make_move_iterator(_Right.begin()),
; 1089 : 				_STD make_move_iterator(_Right.end()));
; 1090 : 		else
; 1091 : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 1092 : 		}
; 1093 : 
; 1094 : 	_Myt& operator=(_Myt&& _Right)
; 1095 : 		{	// assign by moving _Right
; 1096 : 		if (this != &_Right)
; 1097 : 			{	// different, assign it
; 1098 : 			_Tidy();
; 1099 : 
; 1100 :  #if _HAS_CPP0X
; 1101 : 			if (this->_Getal() != _Right._Getal()
; 1102 : 				&& _Alty::propagate_on_container_move_assignment::value)
; 1103 : 				this->_Change_alloc(_Right._Getal());
; 1104 :  #endif /* _HAS_CPP0X */
; 1105 : 
; 1106 : 			if (this->_Getal() != _Right._Getal())
; 1107 : 				assign(_STD make_move_iterator(_Right.begin()),
; 1108 : 					_STD make_move_iterator(_Right.end()));
; 1109 : 			else
; 1110 : 				_Assign_rv(_STD forward<_Myt>(_Right));
; 1111 : 			}
; 1112 : 		return (*this);
; 1113 : 		}
; 1114 : 
; 1115 : 	void _Assign_rv(_Myt&& _Right)
; 1116 : 		{	// assign by moving _Right
; 1117 : 		if (this == &_Right)
; 1118 : 			;
; 1119 : 		else if (get_allocator() != _Right.get_allocator())
; 1120 : 			{	// move construct a copy
; 1121 : 			clear();
; 1122 : 			for (iterator _Next = _Right.begin(); _Next != _Right.end();
; 1123 : 				++_Next)
; 1124 : 				push_back(_STD forward<value_type>(*_Next));
; 1125 : 			}
; 1126 : 		else
; 1127 : 			{	// clear this and steal from _Right
; 1128 : 			this->_Swap_all((_Myt&)_Right);
; 1129 : 			this->_Map = _Right._Map;
; 1130 : 			this->_Mapsize = _Right._Mapsize;
; 1131 : 			this->_Myoff = _Right._Myoff;
; 1132 : 			this->_Mysize = _Right._Mysize;
; 1133 : 
; 1134 : 			_Right._Map = _Mapptr();
; 1135 : 			_Right._Mapsize = 0;
; 1136 : 			_Right._Myoff = 0;
; 1137 : 			_Right._Mysize = 0;
; 1138 : 			}
; 1139 : 		}
; 1140 : 
; 1141 : 	void push_front(value_type&& _Val)
; 1142 : 		{	// insert element at beginning
; 1143 : 		this->_Orphan_all();
; 1144 : 		_PUSH_FRONT_BEGIN;
; 1145 : 		this->_Getal().construct(
; 1146 : 			this->_Map[_Block] + _Newoff % _DEQUESIZ,
; 1147 : 			_STD forward<value_type>(_Val));
; 1148 : 		_PUSH_FRONT_END;
; 1149 : 		}
; 1150 : 
; 1151 : 	void push_back(value_type&& _Val)
; 1152 : 		{	// insert element at end
; 1153 : 		this->_Orphan_all();
; 1154 : 		_PUSH_BACK_BEGIN;
; 1155 : 		this->_Getal().construct(
; 1156 : 			this->_Map[_Block] + _Newoff % _DEQUESIZ,
; 1157 : 			_STD forward<value_type>(_Val));
; 1158 : 		_PUSH_BACK_END;
; 1159 : 		}
; 1160 : 
; 1161 : 	iterator insert(const_iterator _Where, _Ty&& _Val)
; 1162 : 		{	// insert _Val at _Where
; 1163 : 		return (emplace(_Where, _STD move(_Val)));
; 1164 : 		}
; 1165 : 
; 1166 : #define _DEQUE_EMPLACE( \
; 1167 : 	TEMPLATE_LIST, PADDING_LIST, LIST, COMMA, X1, X2, X3, X4) \
; 1168 : 	TEMPLATE_LIST(_CLASS_TYPE) \
; 1169 : 		void emplace_front(LIST(_TYPE_REFREF_ARG)) \
; 1170 : 		{	/* insert element at beginning */ \
; 1171 : 		this->_Orphan_all(); \
; 1172 : 		_PUSH_FRONT_BEGIN; \
; 1173 : 		this->_Getal().construct( \
; 1174 : 			this->_Map[_Block] + _Newoff % _DEQUESIZ \
; 1175 : 				COMMA LIST(_FORWARD_ARG)); \
; 1176 : 		_PUSH_FRONT_END; \
; 1177 : 	} \
; 1178 : 	TEMPLATE_LIST(_CLASS_TYPE) \
; 1179 : 		void emplace_back(LIST(_TYPE_REFREF_ARG)) \
; 1180 : 		{	/* insert element at end */ \
; 1181 : 		this->_Orphan_all(); \
; 1182 : 		_PUSH_BACK_BEGIN; \
; 1183 : 		this->_Getal().construct( \
; 1184 : 			this->_Map[_Block] + _Newoff % _DEQUESIZ \
; 1185 : 				COMMA LIST(_FORWARD_ARG)); \
; 1186 : 		_PUSH_BACK_END; \
; 1187 : 		} \
; 1188 : 	TEMPLATE_LIST(_CLASS_TYPE) \
; 1189 : 		iterator emplace(const_iterator _Where \
; 1190 : 			COMMA LIST(_TYPE_REFREF_ARG)) \
; 1191 : 		{	/* insert element at _Where */ \
; 1192 : 		size_type _Off = _Where - begin(); \
; 1193 : 		_DEQUE_EMPLACE_CHECK \
; 1194 : 		if (_Off <= this->_Mysize / 2) \
; 1195 : 			{	/* closer to front, push to front then rotate */ \
; 1196 : 			emplace_front(LIST(_FORWARD_ARG)); \
; 1197 : 			_STD rotate(begin(), begin() + 1, begin() + 1 + _Off); \
; 1198 : 			} \
; 1199 : 		else \
; 1200 : 			{	/* closer to back, push to back then rotate */ \
; 1201 : 			emplace_back(LIST(_FORWARD_ARG)); \
; 1202 : 			_STD rotate(begin() + _Off, end() - 1, end()); \
; 1203 : 			} \
; 1204 : 		return (begin() + _Off); \
; 1205 : 			}
; 1206 : 
; 1207 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1208 : #define _DEQUE_EMPLACE_CHECK \
; 1209 : 		if (this->_Mysize < _Off) \
; 1210 : 			_DEBUG_ERROR("deque emplace iterator outside range");
; 1211 : 
; 1212 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1213 : #define _DEQUE_EMPLACE_CHECK
; 1214 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1215 : 
; 1216 : _VARIADIC_EXPAND_0X(_DEQUE_EMPLACE, , , , )
; 1217 : #undef _DEQUE_EMPLACE_CHECK
; 1218 : #undef _DEQUE_EMPLACE
; 1219 : 
; 1220 : 	~deque() _NOEXCEPT
; 1221 : 		{	// destroy the deque
; 1222 : 		_Tidy();
; 1223 : 		}
; 1224 : 
; 1225 : 	_Myt& operator=(const _Myt& _Right)
; 1226 : 		{	// assign _Right
; 1227 : 		if (this != &_Right)
; 1228 : 			{	// different, assign it
; 1229 :  #if _HAS_CPP0X
; 1230 : 			if (this->_Getal() != _Right._Getal()
; 1231 : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 1232 : 				{	// change allocator before copying
; 1233 : 				_Tidy();
; 1234 : 				this->_Change_alloc(_Right._Getal());
; 1235 : 				}
; 1236 :  #endif /* _HAS_CPP0X */
; 1237 : 
; 1238 : 			this->_Orphan_all();
; 1239 : 
; 1240 : 			if (_Right._Mysize == 0)
; 1241 : 				clear();
; 1242 : 			else if (_Right._Mysize <= this->_Mysize)
; 1243 : 				{	// enough elements, copy new and destroy old
; 1244 : 				iterator _Mid = _STD copy(_Right.begin(), _Right.end(),
; 1245 : 					begin());
; 1246 : 				erase(_Mid, end());
; 1247 : 				}
; 1248 : 			else
; 1249 : 				{	// new sequence longer, copy and construct new
; 1250 : 				const_iterator _Mid = _Right.begin() + this->_Mysize;
; 1251 : 				_STD copy(_Right.begin(), _Mid, begin());
; 1252 : 				insert(end(), _Mid, _Right.end());
; 1253 : 				}
; 1254 : 			}
; 1255 : 		return (*this);
; 1256 : 		}
; 1257 : 
; 1258 : 	iterator begin() _NOEXCEPT
; 1259 : 		{	// return iterator for beginning of mutable sequence
; 1260 : 		return (iterator(this->_Myoff, this));
; 1261 : 		}
; 1262 : 
; 1263 : 	const_iterator begin() const _NOEXCEPT
; 1264 : 		{	// return iterator for beginning of nonmutable sequence
; 1265 : 		return (const_iterator(this->_Myoff, this));
; 1266 : 		}
; 1267 : 
; 1268 : 	iterator end() _NOEXCEPT
; 1269 : 		{	// return iterator for end of mutable sequence
; 1270 : 		return (iterator(this->_Myoff + this->_Mysize, this));
; 1271 : 		}
; 1272 : 
; 1273 : 	const_iterator end() const _NOEXCEPT
; 1274 : 		{	// return iterator for end of nonmutable sequence
; 1275 : 		return (const_iterator(this->_Myoff + this->_Mysize, this));
; 1276 : 		}
; 1277 : 
; 1278 : 	iterator _Make_iter(const_iterator _Where) const
; 1279 : 		{	// make iterator from const_iterator
; 1280 : 		return (iterator(_Where._Myoff, this));
; 1281 : 		}
; 1282 : 
; 1283 : 	reverse_iterator rbegin() _NOEXCEPT
; 1284 : 		{	// return iterator for beginning of reversed mutable sequence
; 1285 : 		return (reverse_iterator(end()));
; 1286 : 		}
; 1287 : 
; 1288 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1289 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1290 : 		return (const_reverse_iterator(end()));
; 1291 : 		}
; 1292 : 
; 1293 : 	reverse_iterator rend() _NOEXCEPT
; 1294 : 		{	// return iterator for end of reversed mutable sequence
; 1295 : 		return (reverse_iterator(begin()));
; 1296 : 		}
; 1297 : 
; 1298 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1299 : 		{	// return iterator for end of reversed nonmutable sequence
; 1300 : 		return (const_reverse_iterator(begin()));
; 1301 : 		}
; 1302 : 
; 1303 :  #if _HAS_CPP0X
; 1304 : 	const_iterator cbegin() const _NOEXCEPT
; 1305 : 		{	// return iterator for beginning of nonmutable sequence
; 1306 : 		return (((const _Myt *)this)->begin());
; 1307 : 		}
; 1308 : 
; 1309 : 	const_iterator cend() const _NOEXCEPT
; 1310 : 		{	// return iterator for end of nonmutable sequence
; 1311 : 		return (((const _Myt *)this)->end());
; 1312 : 		}
; 1313 : 
; 1314 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1315 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1316 : 		return (((const _Myt *)this)->rbegin());
; 1317 : 		}
; 1318 : 
; 1319 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1320 : 		{	// return iterator for end of reversed nonmutable sequence
; 1321 : 		return (((const _Myt *)this)->rend());
; 1322 : 		}
; 1323 : 
; 1324 : 	void shrink_to_fit()
; 1325 : 		{	// reduce capacity
; 1326 : 		size_type _Oldcapacity = _DEQUESIZ * this->_Mapsize;
; 1327 : 		size_type _Newcapacity = _Oldcapacity / 2;
; 1328 : 
; 1329 : 		if (_Newcapacity < _DEQUESIZ * _DEQUEMAPSIZ)
; 1330 : 			_Newcapacity = _DEQUESIZ * _DEQUEMAPSIZ;
; 1331 : 
; 1332 : 		if ((empty() && 0 < this->_Mapsize)
; 1333 : 			|| (!empty()
; 1334 : 				&& size() <= _Newcapacity
; 1335 : 				&& _Newcapacity < _Oldcapacity))
; 1336 : 			{	// worth shrinking, do it
; 1337 : 			_Myt _Tmp(_STD make_move_iterator(begin()),
; 1338 : 				_STD make_move_iterator(end()));
; 1339 : 			swap(_Tmp);
; 1340 : 			}
; 1341 : 		}
; 1342 :  #endif /* _HAS_CPP0X */
; 1343 : 
; 1344 : 	void resize(size_type _Newsize)
; 1345 : 		{	// determine new length, padding as needed
; 1346 : 		if (_Newsize < this->_Mysize)
; 1347 : 			erase(begin() + _Newsize, end());
; 1348 : 		else if (this->_Mysize < _Newsize)
; 1349 : 			{	// append default-constructed elements
; 1350 : 			_Alty _Alval(this->_Getal());
; 1351 : 			this->_Orphan_all();
; 1352 : 			while (this->_Mysize < _Newsize)
; 1353 : 				{	// push_back default-constructed element
; 1354 : 				_PUSH_BACK_BEGIN;
; 1355 : 				_Uninitialized_default_fill_n(
; 1356 : 					this->_Map[_Block] + _Newoff % _DEQUESIZ, 1, _Alval);
; 1357 : 				_PUSH_BACK_END;
; 1358 : 				}
; 1359 : 			}
; 1360 : 		}
; 1361 : 
; 1362 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1363 : 		{	// determine new length, padding with _Val elements as needed
; 1364 : 		if (this->_Mysize < _Newsize)
; 1365 : 			_Insert_n(end(), _Newsize - this->_Mysize, _Val);
; 1366 : 		else if (_Newsize < this->_Mysize)
; 1367 : 			erase(begin() + _Newsize, end());
; 1368 : 		}
; 1369 : 
; 1370 : 	size_type size() const _NOEXCEPT
; 1371 : 		{	// return length of sequence
; 1372 : 		return (this->_Mysize);
; 1373 : 		}
; 1374 : 
; 1375 : 	size_type max_size() const _NOEXCEPT
; 1376 : 		{	// return maximum possible length of sequence
; 1377 : 		return (this->_Getal().max_size());
; 1378 : 		}
; 1379 : 
; 1380 : 	bool empty() const _NOEXCEPT
; 1381 : 		{	// test if sequence is empty
; 1382 : 		return (this->_Mysize == 0);

  00012	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  00016	33 f6		 xor	 esi, esi
  00018	48 85 c9	 test	 rcx, rcx

; 1858 : 		_Alpty _Almap(this->_Getal());
; 1859 : 		while (!empty())

  0001b	74 55		 je	 SHORT $LN61@Tidy
$LN63@Tidy:

; 1383 : 		}
; 1384 : 
; 1385 : 	allocator_type get_allocator() const _NOEXCEPT
; 1386 : 		{	// return allocator object for values
; 1387 : 		return (this->_Getal());
; 1388 : 		}
; 1389 : 
; 1390 : 	const_reference at(size_type _Pos) const
; 1391 : 		{	// subscript nonmutable sequence with checking
; 1392 : 		if (this->_Mysize <= _Pos)
; 1393 : 			_Xran();
; 1394 : 		return (*(begin() + _Pos));
; 1395 : 		}
; 1396 : 
; 1397 : 	reference at(size_type _Pos)
; 1398 : 		{	// subscript mutable sequence with checking
; 1399 : 		if (this->_Mysize <= _Pos)
; 1400 : 			_Xran();
; 1401 : 		return (*(begin() + _Pos));
; 1402 : 		}
; 1403 : 
; 1404 : 	const_reference operator[](size_type _Pos) const
; 1405 : 		{	// subscript nonmutable sequence
; 1406 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1407 : 		if (this->_Mysize <= _Pos)
; 1408 : 			_DEBUG_ERROR("deque subscript out of range");
; 1409 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1410 : 
; 1411 : 		return (*(begin() + _Pos));
; 1412 : 		}
; 1413 : 
; 1414 : 	reference operator[](size_type _Pos)
; 1415 : 		{	// subscript mutable sequence
; 1416 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1417 : 		if (this->_Mysize <= _Pos)
; 1418 : 			_DEBUG_ERROR("deque subscript out of range");
; 1419 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1420 : 
; 1421 : 		return (*(begin() + _Pos));
; 1422 : 		}
; 1423 : 
; 1424 : 	reference front()
; 1425 : 		{	// return first element of mutable sequence
; 1426 : 		return (*begin());
; 1427 : 		}
; 1428 : 
; 1429 : 	const_reference front() const
; 1430 : 		{	// return first element of nonmutable sequence
; 1431 : 		return (*begin());
; 1432 : 		}
; 1433 : 
; 1434 : 	reference back()
; 1435 : 		{	// return last element of mutable sequence
; 1436 : 		return (*(end() - 1));
; 1437 : 		}
; 1438 : 
; 1439 : 	const_reference back() const
; 1440 : 		{	// return last element of nonmutable sequence
; 1441 : 		return (*(end() - 1));
; 1442 : 		}
; 1443 : 
; 1444 : 	void push_front(const value_type& _Val)
; 1445 : 		{	// insert element at beginning
; 1446 : 		this->_Orphan_all();
; 1447 : 		_PUSH_FRONT_BEGIN;
; 1448 : 		this->_Getal().construct(
; 1449 : 			this->_Map[_Block] + _Newoff % _DEQUESIZ, _Val);
; 1450 : 		_PUSH_FRONT_END;
; 1451 : 		}
; 1452 : 
; 1453 : 	void pop_front()
; 1454 : 		{	// erase element at beginning
; 1455 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1456 : 		if (empty())
; 1457 : 			_DEBUG_ERROR("deque empty before pop");
; 1458 : 		else
; 1459 : 			{	// something to erase, do it
; 1460 : 			_Orphan_off(this->_Myoff);
; 1461 : 			size_type _Block = this->_Getblock(this->_Myoff);
; 1462 : 			this->_Getal().destroy(
; 1463 : 				this->_Map[_Block] + this->_Myoff % _DEQUESIZ);
; 1464 : 			if (--this->_Mysize == 0)
; 1465 : 				this->_Myoff = 0;
; 1466 : 			else
; 1467 : 				++this->_Myoff;
; 1468 : 			}
; 1469 : 
; 1470 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1471 : 		if (!empty())
; 1472 : 			{	// something to erase, do it
; 1473 : 			size_type _Block = this->_Getblock(this->_Myoff);
; 1474 : 			this->_Getal().destroy(
; 1475 : 				this->_Map[_Block] + this->_Myoff % _DEQUESIZ);
; 1476 : 			if (--this->_Mysize == 0)
; 1477 : 				this->_Myoff = 0;
; 1478 : 			else
; 1479 : 				++this->_Myoff;
; 1480 : 			}
; 1481 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1482 : 		}
; 1483 : 
; 1484 : 	void push_back(const value_type& _Val)
; 1485 : 		{	// insert element at end
; 1486 : 		this->_Orphan_all();
; 1487 : 		_PUSH_BACK_BEGIN;
; 1488 : 		this->_Getal().construct(
; 1489 : 			this->_Map[_Block] + _Newoff % _DEQUESIZ, _Val);
; 1490 : 		_PUSH_BACK_END;
; 1491 : 		}
; 1492 : 
; 1493 : 	void pop_back()
; 1494 : 		{	// erase element at end
; 1495 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1496 : 		if (empty())
; 1497 : 			_DEBUG_ERROR("deque empty before pop");
; 1498 : 		else
; 1499 : 			{	// something to erase, do it
; 1500 : 			size_type _Newoff = this->_Myoff + this->_Mysize - 1;
; 1501 : 			_Orphan_off(_Newoff);
; 1502 : 			size_type _Block = this->_Getblock(_Newoff);
; 1503 : 			this->_Getal().destroy(
; 1504 : 				this->_Map[_Block] + _Newoff % _DEQUESIZ);
; 1505 : 			if (--this->_Mysize == 0)
; 1506 : 				this->_Myoff = 0;
; 1507 : 			}
; 1508 : 
; 1509 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1510 : 		if (!empty())
; 1511 : 			{	// something to erase, do it
; 1512 : 			size_type _Newoff = this->_Myoff + this->_Mysize - 1;

  0001d	48 8b 43 18	 mov	 rax, QWORD PTR [rbx+24]

; 787  : 		return ((_Off / _DEQUESIZ) & (this->_Mapsize - 1));

  00021	48 8b 53 10	 mov	 rdx, QWORD PTR [rbx+16]

; 1383 : 		}
; 1384 : 
; 1385 : 	allocator_type get_allocator() const _NOEXCEPT
; 1386 : 		{	// return allocator object for values
; 1387 : 		return (this->_Getal());
; 1388 : 		}
; 1389 : 
; 1390 : 	const_reference at(size_type _Pos) const
; 1391 : 		{	// subscript nonmutable sequence with checking
; 1392 : 		if (this->_Mysize <= _Pos)
; 1393 : 			_Xran();
; 1394 : 		return (*(begin() + _Pos));
; 1395 : 		}
; 1396 : 
; 1397 : 	reference at(size_type _Pos)
; 1398 : 		{	// subscript mutable sequence with checking
; 1399 : 		if (this->_Mysize <= _Pos)
; 1400 : 			_Xran();
; 1401 : 		return (*(begin() + _Pos));
; 1402 : 		}
; 1403 : 
; 1404 : 	const_reference operator[](size_type _Pos) const
; 1405 : 		{	// subscript nonmutable sequence
; 1406 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1407 : 		if (this->_Mysize <= _Pos)
; 1408 : 			_DEBUG_ERROR("deque subscript out of range");
; 1409 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1410 : 
; 1411 : 		return (*(begin() + _Pos));
; 1412 : 		}
; 1413 : 
; 1414 : 	reference operator[](size_type _Pos)
; 1415 : 		{	// subscript mutable sequence
; 1416 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1417 : 		if (this->_Mysize <= _Pos)
; 1418 : 			_DEBUG_ERROR("deque subscript out of range");
; 1419 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1420 : 
; 1421 : 		return (*(begin() + _Pos));
; 1422 : 		}
; 1423 : 
; 1424 : 	reference front()
; 1425 : 		{	// return first element of mutable sequence
; 1426 : 		return (*begin());
; 1427 : 		}
; 1428 : 
; 1429 : 	const_reference front() const
; 1430 : 		{	// return first element of nonmutable sequence
; 1431 : 		return (*begin());
; 1432 : 		}
; 1433 : 
; 1434 : 	reference back()
; 1435 : 		{	// return last element of mutable sequence
; 1436 : 		return (*(end() - 1));
; 1437 : 		}
; 1438 : 
; 1439 : 	const_reference back() const
; 1440 : 		{	// return last element of nonmutable sequence
; 1441 : 		return (*(end() - 1));
; 1442 : 		}
; 1443 : 
; 1444 : 	void push_front(const value_type& _Val)
; 1445 : 		{	// insert element at beginning
; 1446 : 		this->_Orphan_all();
; 1447 : 		_PUSH_FRONT_BEGIN;
; 1448 : 		this->_Getal().construct(
; 1449 : 			this->_Map[_Block] + _Newoff % _DEQUESIZ, _Val);
; 1450 : 		_PUSH_FRONT_END;
; 1451 : 		}
; 1452 : 
; 1453 : 	void pop_front()
; 1454 : 		{	// erase element at beginning
; 1455 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1456 : 		if (empty())
; 1457 : 			_DEBUG_ERROR("deque empty before pop");
; 1458 : 		else
; 1459 : 			{	// something to erase, do it
; 1460 : 			_Orphan_off(this->_Myoff);
; 1461 : 			size_type _Block = this->_Getblock(this->_Myoff);
; 1462 : 			this->_Getal().destroy(
; 1463 : 				this->_Map[_Block] + this->_Myoff % _DEQUESIZ);
; 1464 : 			if (--this->_Mysize == 0)
; 1465 : 				this->_Myoff = 0;
; 1466 : 			else
; 1467 : 				++this->_Myoff;
; 1468 : 			}
; 1469 : 
; 1470 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1471 : 		if (!empty())
; 1472 : 			{	// something to erase, do it
; 1473 : 			size_type _Block = this->_Getblock(this->_Myoff);
; 1474 : 			this->_Getal().destroy(
; 1475 : 				this->_Map[_Block] + this->_Myoff % _DEQUESIZ);
; 1476 : 			if (--this->_Mysize == 0)
; 1477 : 				this->_Myoff = 0;
; 1478 : 			else
; 1479 : 				++this->_Myoff;
; 1480 : 			}
; 1481 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1482 : 		}
; 1483 : 
; 1484 : 	void push_back(const value_type& _Val)
; 1485 : 		{	// insert element at end
; 1486 : 		this->_Orphan_all();
; 1487 : 		_PUSH_BACK_BEGIN;
; 1488 : 		this->_Getal().construct(
; 1489 : 			this->_Map[_Block] + _Newoff % _DEQUESIZ, _Val);
; 1490 : 		_PUSH_BACK_END;
; 1491 : 		}
; 1492 : 
; 1493 : 	void pop_back()
; 1494 : 		{	// erase element at end
; 1495 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1496 : 		if (empty())
; 1497 : 			_DEBUG_ERROR("deque empty before pop");
; 1498 : 		else
; 1499 : 			{	// something to erase, do it
; 1500 : 			size_type _Newoff = this->_Myoff + this->_Mysize - 1;
; 1501 : 			_Orphan_off(_Newoff);
; 1502 : 			size_type _Block = this->_Getblock(_Newoff);
; 1503 : 			this->_Getal().destroy(
; 1504 : 				this->_Map[_Block] + _Newoff % _DEQUESIZ);
; 1505 : 			if (--this->_Mysize == 0)
; 1506 : 				this->_Myoff = 0;
; 1507 : 			}
; 1508 : 
; 1509 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1510 : 		if (!empty())
; 1511 : 			{	// something to erase, do it
; 1512 : 			size_type _Newoff = this->_Myoff + this->_Mysize - 1;

  00025	48 ff c8	 dec	 rax

; 787  : 		return ((_Off / _DEQUESIZ) & (this->_Mapsize - 1));

  00028	48 ff ca	 dec	 rdx

; 1383 : 		}
; 1384 : 
; 1385 : 	allocator_type get_allocator() const _NOEXCEPT
; 1386 : 		{	// return allocator object for values
; 1387 : 		return (this->_Getal());
; 1388 : 		}
; 1389 : 
; 1390 : 	const_reference at(size_type _Pos) const
; 1391 : 		{	// subscript nonmutable sequence with checking
; 1392 : 		if (this->_Mysize <= _Pos)
; 1393 : 			_Xran();
; 1394 : 		return (*(begin() + _Pos));
; 1395 : 		}
; 1396 : 
; 1397 : 	reference at(size_type _Pos)
; 1398 : 		{	// subscript mutable sequence with checking
; 1399 : 		if (this->_Mysize <= _Pos)
; 1400 : 			_Xran();
; 1401 : 		return (*(begin() + _Pos));
; 1402 : 		}
; 1403 : 
; 1404 : 	const_reference operator[](size_type _Pos) const
; 1405 : 		{	// subscript nonmutable sequence
; 1406 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1407 : 		if (this->_Mysize <= _Pos)
; 1408 : 			_DEBUG_ERROR("deque subscript out of range");
; 1409 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1410 : 
; 1411 : 		return (*(begin() + _Pos));
; 1412 : 		}
; 1413 : 
; 1414 : 	reference operator[](size_type _Pos)
; 1415 : 		{	// subscript mutable sequence
; 1416 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1417 : 		if (this->_Mysize <= _Pos)
; 1418 : 			_DEBUG_ERROR("deque subscript out of range");
; 1419 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1420 : 
; 1421 : 		return (*(begin() + _Pos));
; 1422 : 		}
; 1423 : 
; 1424 : 	reference front()
; 1425 : 		{	// return first element of mutable sequence
; 1426 : 		return (*begin());
; 1427 : 		}
; 1428 : 
; 1429 : 	const_reference front() const
; 1430 : 		{	// return first element of nonmutable sequence
; 1431 : 		return (*begin());
; 1432 : 		}
; 1433 : 
; 1434 : 	reference back()
; 1435 : 		{	// return last element of mutable sequence
; 1436 : 		return (*(end() - 1));
; 1437 : 		}
; 1438 : 
; 1439 : 	const_reference back() const
; 1440 : 		{	// return last element of nonmutable sequence
; 1441 : 		return (*(end() - 1));
; 1442 : 		}
; 1443 : 
; 1444 : 	void push_front(const value_type& _Val)
; 1445 : 		{	// insert element at beginning
; 1446 : 		this->_Orphan_all();
; 1447 : 		_PUSH_FRONT_BEGIN;
; 1448 : 		this->_Getal().construct(
; 1449 : 			this->_Map[_Block] + _Newoff % _DEQUESIZ, _Val);
; 1450 : 		_PUSH_FRONT_END;
; 1451 : 		}
; 1452 : 
; 1453 : 	void pop_front()
; 1454 : 		{	// erase element at beginning
; 1455 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1456 : 		if (empty())
; 1457 : 			_DEBUG_ERROR("deque empty before pop");
; 1458 : 		else
; 1459 : 			{	// something to erase, do it
; 1460 : 			_Orphan_off(this->_Myoff);
; 1461 : 			size_type _Block = this->_Getblock(this->_Myoff);
; 1462 : 			this->_Getal().destroy(
; 1463 : 				this->_Map[_Block] + this->_Myoff % _DEQUESIZ);
; 1464 : 			if (--this->_Mysize == 0)
; 1465 : 				this->_Myoff = 0;
; 1466 : 			else
; 1467 : 				++this->_Myoff;
; 1468 : 			}
; 1469 : 
; 1470 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1471 : 		if (!empty())
; 1472 : 			{	// something to erase, do it
; 1473 : 			size_type _Block = this->_Getblock(this->_Myoff);
; 1474 : 			this->_Getal().destroy(
; 1475 : 				this->_Map[_Block] + this->_Myoff % _DEQUESIZ);
; 1476 : 			if (--this->_Mysize == 0)
; 1477 : 				this->_Myoff = 0;
; 1478 : 			else
; 1479 : 				++this->_Myoff;
; 1480 : 			}
; 1481 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1482 : 		}
; 1483 : 
; 1484 : 	void push_back(const value_type& _Val)
; 1485 : 		{	// insert element at end
; 1486 : 		this->_Orphan_all();
; 1487 : 		_PUSH_BACK_BEGIN;
; 1488 : 		this->_Getal().construct(
; 1489 : 			this->_Map[_Block] + _Newoff % _DEQUESIZ, _Val);
; 1490 : 		_PUSH_BACK_END;
; 1491 : 		}
; 1492 : 
; 1493 : 	void pop_back()
; 1494 : 		{	// erase element at end
; 1495 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1496 : 		if (empty())
; 1497 : 			_DEBUG_ERROR("deque empty before pop");
; 1498 : 		else
; 1499 : 			{	// something to erase, do it
; 1500 : 			size_type _Newoff = this->_Myoff + this->_Mysize - 1;
; 1501 : 			_Orphan_off(_Newoff);
; 1502 : 			size_type _Block = this->_Getblock(_Newoff);
; 1503 : 			this->_Getal().destroy(
; 1504 : 				this->_Map[_Block] + _Newoff % _DEQUESIZ);
; 1505 : 			if (--this->_Mysize == 0)
; 1506 : 				this->_Myoff = 0;
; 1507 : 			}
; 1508 : 
; 1509 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1510 : 		if (!empty())
; 1511 : 			{	// something to erase, do it
; 1512 : 			size_type _Newoff = this->_Myoff + this->_Mysize - 1;

  0002b	48 03 c8	 add	 rcx, rax

; 1513 : 			size_type _Block = this->_Getblock(_Newoff);
; 1514 : 			this->_Getal().destroy(
; 1515 : 				this->_Map[_Block] + _Newoff % _DEQUESIZ);

  0002e	48 8b 43 08	 mov	 rax, QWORD PTR [rbx+8]

; 787  : 		return ((_Off / _DEQUESIZ) & (this->_Mapsize - 1));

  00032	48 23 d1	 and	 rdx, rcx

; 1513 : 			size_type _Block = this->_Getblock(_Newoff);
; 1514 : 			this->_Getal().destroy(
; 1515 : 				this->_Map[_Block] + _Newoff % _DEQUESIZ);

  00035	48 8b 0c d0	 mov	 rcx, QWORD PTR [rax+rdx*8]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  00039	48 8b 79 08	 mov	 rdi, QWORD PTR [rcx+8]
  0003d	48 85 ff	 test	 rdi, rdi
  00040	74 1d		 je	 SHORT $LN40@Tidy

; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  00042	f0 ff 4f 08	 lock dec DWORD PTR [rdi+8]
  00046	75 17		 jne	 SHORT $LN40@Tidy

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  00048	48 8b 07	 mov	 rax, QWORD PTR [rdi]
  0004b	48 8b cf	 mov	 rcx, rdi
  0004e	ff 10		 call	 QWORD PTR [rax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  00050	f0 ff 4f 0c	 lock dec DWORD PTR [rdi+12]
  00054	75 09		 jne	 SHORT $LN40@Tidy

; 128  : 			_Delete_this();

  00056	48 8b 07	 mov	 rax, QWORD PTR [rdi]
  00059	48 8b cf	 mov	 rcx, rdi
  0005c	ff 50 08	 call	 QWORD PTR [rax+8]
$LN40@Tidy:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 1516 : 			if (--this->_Mysize == 0)

  0005f	48 ff 4b 20	 dec	 QWORD PTR [rbx+32]
  00063	48 8b 4b 20	 mov	 rcx, QWORD PTR [rbx+32]
  00067	75 04		 jne	 SHORT $LN13@Tidy

; 1517 : 				this->_Myoff = 0;

  00069	48 89 73 18	 mov	 QWORD PTR [rbx+24], rsi
$LN13@Tidy:

; 788  : 		}
; 789  : 
; 790  : 	_Mapptr _Map;		// pointer to array of pointers to blocks
; 791  : 	size_type _Mapsize;	// size of map array, zero or 2^N
; 792  : 	size_type _Myoff;	// offset of initial element
; 793  : 	size_type _Mysize;	// current length of sequence
; 794  : 	};
; 795  : 
; 796  : 		// TEMPLATE CLASS _Deque_alloc
; 797  : template<bool _Al_has_storage,
; 798  : 	class _Alloc_types>
; 799  : 	class _Deque_alloc
; 800  : 		: public _Deque_val<typename _Alloc_types::_Val_types>
; 801  : 	{	// base class for deque to hold allocator with storage
; 802  : public:
; 803  : 	typedef _Deque_alloc<_Al_has_storage, _Alloc_types> _Myt;
; 804  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 805  : 	typedef typename _Alloc_types::_Alty _Alty;
; 806  : 
; 807  : 	typedef typename _Alloc_types::_Alpty _Alpty;
; 808  : 
; 809  : 	_Deque_alloc(const _Alloc& _Al = _Alloc())
; 810  : 		: _Alval(_Al)
; 811  : 		{	// construct allocators from _Al
; 812  : 		_Alloc_proxy();
; 813  : 		}
; 814  : 
; 815  : 	~_Deque_alloc() _NOEXCEPT
; 816  : 		{	// destroy proxy
; 817  : 		_Free_proxy();
; 818  : 		}
; 819  : 
; 820  : 	void _Change_alloc(const _Alty& _Al)
; 821  : 		{	// replace old allocator
; 822  : 		_Free_proxy();
; 823  : 		_Alval = _Al;
; 824  : 		_Alloc_proxy();
; 825  : 		}
; 826  : 
; 827  : 	void _Swap_alloc(_Myt& _Right)
; 828  : 		{	// swap allocators
; 829  : 		_Swap_adl(_Alval, _Right._Alval);
; 830  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 831  : 		}
; 832  : 
; 833  : 	void _Alloc_proxy()
; 834  : 		{	// construct proxy from _Alval
; 835  : 		typename _Alty::template rebind<_Container_proxy>::other
; 836  : 			_Alproxy(_Alval);
; 837  : 		this->_Myproxy = _Alproxy.allocate(1);
; 838  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 839  : 		this->_Myproxy->_Mycont = this;
; 840  : 		}
; 841  : 
; 842  : 	void _Free_proxy()
; 843  : 		{	// destroy proxy
; 844  : 		typename _Alty::template rebind<_Container_proxy>::other
; 845  : 			_Alproxy(_Alval);
; 846  : 		this->_Orphan_all();
; 847  : 		_Alproxy.destroy(this->_Myproxy);
; 848  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 849  : 		this->_Myproxy = 0;
; 850  : 		}
; 851  : 
; 852  : 	_Alty& _Getal()
; 853  : 		{	// get reference to allocator
; 854  : 		return (_Alval);
; 855  : 		}
; 856  : 
; 857  : 	const _Alty& _Getal() const
; 858  : 		{	// get reference to allocator
; 859  : 		return (_Alval);
; 860  : 		}
; 861  : 
; 862  : 	_Alty _Alval;	// allocator object for stored elements
; 863  : 	};
; 864  : 
; 865  : template<class _Alloc_types>
; 866  : 	class _Deque_alloc<false, _Alloc_types>
; 867  : 		: public _Deque_val<typename _Alloc_types::_Val_types>
; 868  : 	{	// base class for deque to hold allocator with no storage
; 869  : public:
; 870  : 	typedef _Deque_alloc<false, _Alloc_types> _Myt;
; 871  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 872  : 
; 873  : 	typedef typename _Alloc_types::_Alty _Alty;
; 874  : 
; 875  : 	typedef typename _Alloc_types::_Alpty _Alpty;
; 876  : 
; 877  : 	_Deque_alloc(const _Alloc& = _Alloc())
; 878  : 		{	// construct allocators from _Al
; 879  : 		_Alloc_proxy();
; 880  : 		}
; 881  : 
; 882  : 	~_Deque_alloc() _NOEXCEPT
; 883  : 		{	// destroy proxy
; 884  : 		_Free_proxy();
; 885  : 		}
; 886  : 
; 887  : 	void _Change_alloc(const _Alty&)
; 888  : 		{	// replace old allocator
; 889  : 		}
; 890  : 
; 891  : 	void _Swap_alloc(_Myt& _Right)
; 892  : 		{	// swap allocators
; 893  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 894  : 		}
; 895  : 
; 896  : 	void _Alloc_proxy()
; 897  : 		{	// construct proxy from _Alval
; 898  : 		typename _Alty::template rebind<_Container_proxy>::other
; 899  : 			_Alproxy;
; 900  : 		this->_Myproxy = _Alproxy.allocate(1);
; 901  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 902  : 		this->_Myproxy->_Mycont = this;
; 903  : 		}
; 904  : 
; 905  : 	void _Free_proxy()
; 906  : 		{	// destroy proxy
; 907  : 		typename _Alty::template rebind<_Container_proxy>::other
; 908  : 			_Alproxy;
; 909  : 		this->_Orphan_all();
; 910  : 		_Alproxy.destroy(this->_Myproxy);
; 911  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 912  : 		this->_Myproxy = 0;
; 913  : 		}
; 914  : 
; 915  : 	_Alty _Getal() const
; 916  : 		{	// get reference to allocator
; 917  : 		return (_Alty());
; 918  : 		}
; 919  : 	};
; 920  : 
; 921  : 		// TEMPLATE CLASS deque
; 922  : template<class _Ty,
; 923  : 	class _Alloc = allocator<_Ty> >
; 924  : 	class deque
; 925  : 		: public _Deque_alloc<!is_empty<_Alloc>::value,
; 926  : 			_Deque_base_types<_Ty, _Alloc> >
; 927  : 	{	// circular queue of pointers to blocks
; 928  : public:
; 929  : 	typedef deque<_Ty, _Alloc> _Myt;
; 930  : 	typedef _Deque_alloc<!is_empty<_Alloc>::value,
; 931  : 		_Deque_base_types<_Ty, _Alloc> > _Mybase;
; 932  : 	typedef _Alloc allocator_type;
; 933  : 
; 934  : 	typedef typename _Mybase::_Alty _Alty;
; 935  : 	typedef typename _Mybase::_Alpty _Alpty;
; 936  : 	typedef typename _Mybase::_Mapptr _Mapptr;
; 937  : 
; 938  : 	typedef typename _Mybase::value_type value_type;
; 939  : 	typedef typename _Mybase::size_type size_type;
; 940  : 	typedef typename _Mybase::difference_type difference_type;
; 941  : 	typedef typename _Mybase::pointer pointer;
; 942  : 	typedef typename _Mybase::const_pointer const_pointer;
; 943  : 	typedef typename _Mybase::reference reference;
; 944  : 	typedef typename _Mybase::const_reference const_reference;
; 945  : 
; 946  : 	typedef typename _Mybase::iterator iterator;
; 947  : 	typedef typename _Mybase::const_iterator const_iterator;
; 948  : 
; 949  : 	typedef _STD reverse_iterator<iterator> reverse_iterator;
; 950  : 	typedef _STD reverse_iterator<const_iterator> const_reverse_iterator;
; 951  : 
; 952  : 	static const int _EEM_DS = _DEQUESIZ;
; 953  : 	enum {_EEN_DS = _DEQUESIZ};	// helper for expression evaluator
; 954  : 	deque()
; 955  : 		: _Mybase()
; 956  : 		{	// construct empty deque
; 957  : 		}
; 958  : 
; 959  : 	explicit deque(const _Alloc& _Al)
; 960  : 		: _Mybase(_Al)
; 961  : 		{	// construct empty deque with allocator
; 962  : 		}
; 963  : 
; 964  : 	explicit deque(size_type _Count)
; 965  : 		: _Mybase()
; 966  : 		{	// construct from _Count * value_type()
; 967  : 		resize(_Count);
; 968  : 		}
; 969  : 
; 970  : 	deque(size_type _Count, const value_type& _Val)
; 971  : 		: _Mybase()
; 972  : 		{	// construct from _Count * _Val
; 973  : 		_Construct_n(_Count, _Val);
; 974  : 		}
; 975  : 
; 976  : 	deque(size_type _Count, const value_type& _Val, const _Alloc& _Al)
; 977  : 		: _Mybase(_Al)
; 978  : 		{	// construct from _Count * _Val with allocator
; 979  : 		_Construct_n(_Count, _Val);
; 980  : 		}
; 981  : 
; 982  : 	deque(const _Myt& _Right)
; 983  : 
; 984  :  #if _HAS_CPP0X
; 985  : 		: _Mybase(_Right._Getal().select_on_container_copy_construction())
; 986  : 
; 987  :  #else /* _HAS_CPP0X */
; 988  : 		: _Mybase(_Right._Getal())
; 989  :  #endif /* _HAS_CPP0X */
; 990  : 
; 991  : 		{	// construct by copying _Right
; 992  : 		_TRY_BEGIN
; 993  : 		insert(begin(), _Right.begin(), _Right.end());
; 994  : 		_CATCH_ALL
; 995  : 		_Tidy();
; 996  : 		_RERAISE;
; 997  : 		_CATCH_END
; 998  : 		}
; 999  : 
; 1000 : 	deque(const _Myt& _Right, const _Alloc& _Al)
; 1001 : 		: _Mybase(_Al)
; 1002 : 		{	// construct by copying _Right
; 1003 : 		_TRY_BEGIN
; 1004 : 		insert(begin(), _Right.begin(), _Right.end());
; 1005 : 		_CATCH_ALL
; 1006 : 		_Tidy();
; 1007 : 		_RERAISE;
; 1008 : 		_CATCH_END
; 1009 : 		}
; 1010 : 
; 1011 : 	template<class _Iter>
; 1012 : 		deque(_Iter _First, _Iter _Last,
; 1013 : 			typename enable_if<_Is_iterator<_Iter>::value,
; 1014 : 				void>::type ** = 0)
; 1015 : 		: _Mybase()
; 1016 : 		{	// construct from [_First, _Last)
; 1017 : 		_Construct(_First, _Last);
; 1018 : 		}
; 1019 : 
; 1020 : 	template<class _Iter>
; 1021 : 		deque(_Iter _First, _Iter _Last, const _Alloc& _Al,
; 1022 : 			typename enable_if<_Is_iterator<_Iter>::value,
; 1023 : 				void>::type ** = 0)
; 1024 : 		: _Mybase(_Al)
; 1025 : 		{	// construct from [_First, _Last) with allocator
; 1026 : 		_Construct(_First, _Last);
; 1027 : 		}
; 1028 : 
; 1029 : 	template<class _Iter>
; 1030 : 		void _Construct(_Iter _First, _Iter _Last)
; 1031 : 		{	// initialize from [_First, _Last), input iterators
; 1032 : 		_TRY_BEGIN
; 1033 : 		insert(begin(), _First, _Last);
; 1034 : 		_CATCH_ALL
; 1035 : 		_Tidy();
; 1036 : 		_RERAISE;
; 1037 : 		_CATCH_END
; 1038 : 		}
; 1039 : 
; 1040 : 	void _Construct_n(size_type _Count, const value_type& _Val)
; 1041 : 		{	// construct from _Count * _Val
; 1042 : 		_TRY_BEGIN
; 1043 : 		_Insert_n(begin(), _Count, _Val);
; 1044 : 		_CATCH_ALL
; 1045 : 		_Tidy();
; 1046 : 		_RERAISE;
; 1047 : 		_CATCH_END
; 1048 : 		}
; 1049 : 
; 1050 : #define _PUSH_FRONT_BEGIN \
; 1051 : 	if (this->_Myoff % _DEQUESIZ == 0 \
; 1052 : 		&& this->_Mapsize <= (this->_Mysize + _DEQUESIZ) / _DEQUESIZ) \
; 1053 : 		_Growmap(1); \
; 1054 : 	this->_Myoff &= this->_Mapsize * _DEQUESIZ - 1; \
; 1055 : 	size_type _Newoff = this->_Myoff != 0 ? this->_Myoff \
; 1056 : 		: this->_Mapsize * _DEQUESIZ; \
; 1057 : 	size_type _Block = this->_Getblock(--_Newoff); \
; 1058 : 	if (this->_Map[_Block] == pointer()) \
; 1059 : 		this->_Map[_Block] = this->_Getal().allocate(_DEQUESIZ)
; 1060 : 
; 1061 : #define _PUSH_FRONT_END \
; 1062 : 	this->_Myoff = _Newoff; \
; 1063 : 	++this->_Mysize
; 1064 : 
; 1065 : #define _PUSH_BACK_BEGIN \
; 1066 : 	if ((this->_Myoff + this->_Mysize) % _DEQUESIZ == 0 \
; 1067 : 		&& this->_Mapsize <= (this->_Mysize + _DEQUESIZ) / _DEQUESIZ) \
; 1068 : 		_Growmap(1); \
; 1069 : 	this->_Myoff &= this->_Mapsize * _DEQUESIZ - 1; \
; 1070 : 	size_type _Newoff = this->_Myoff + this->_Mysize; \
; 1071 : 	size_type _Block = this->_Getblock(_Newoff); \
; 1072 : 	if (this->_Map[_Block] == pointer()) \
; 1073 : 		this->_Map[_Block] = this->_Getal().allocate(_DEQUESIZ)
; 1074 : 
; 1075 : #define _PUSH_BACK_END \
; 1076 : 	++this->_Mysize
; 1077 : 
; 1078 : 	deque(_Myt&& _Right)
; 1079 : 		: _Mybase(_Right._Getal())
; 1080 : 		{	// construct by moving _Right
; 1081 : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 1082 : 		}
; 1083 : 
; 1084 : 	deque(_Myt&& _Right, const _Alloc& _Al)
; 1085 : 		: _Mybase(_Al)
; 1086 : 		{	// construct by moving _Right
; 1087 : 		if (this->_Getal() != _Right._Getal())
; 1088 : 			assign(_STD make_move_iterator(_Right.begin()),
; 1089 : 				_STD make_move_iterator(_Right.end()));
; 1090 : 		else
; 1091 : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 1092 : 		}
; 1093 : 
; 1094 : 	_Myt& operator=(_Myt&& _Right)
; 1095 : 		{	// assign by moving _Right
; 1096 : 		if (this != &_Right)
; 1097 : 			{	// different, assign it
; 1098 : 			_Tidy();
; 1099 : 
; 1100 :  #if _HAS_CPP0X
; 1101 : 			if (this->_Getal() != _Right._Getal()
; 1102 : 				&& _Alty::propagate_on_container_move_assignment::value)
; 1103 : 				this->_Change_alloc(_Right._Getal());
; 1104 :  #endif /* _HAS_CPP0X */
; 1105 : 
; 1106 : 			if (this->_Getal() != _Right._Getal())
; 1107 : 				assign(_STD make_move_iterator(_Right.begin()),
; 1108 : 					_STD make_move_iterator(_Right.end()));
; 1109 : 			else
; 1110 : 				_Assign_rv(_STD forward<_Myt>(_Right));
; 1111 : 			}
; 1112 : 		return (*this);
; 1113 : 		}
; 1114 : 
; 1115 : 	void _Assign_rv(_Myt&& _Right)
; 1116 : 		{	// assign by moving _Right
; 1117 : 		if (this == &_Right)
; 1118 : 			;
; 1119 : 		else if (get_allocator() != _Right.get_allocator())
; 1120 : 			{	// move construct a copy
; 1121 : 			clear();
; 1122 : 			for (iterator _Next = _Right.begin(); _Next != _Right.end();
; 1123 : 				++_Next)
; 1124 : 				push_back(_STD forward<value_type>(*_Next));
; 1125 : 			}
; 1126 : 		else
; 1127 : 			{	// clear this and steal from _Right
; 1128 : 			this->_Swap_all((_Myt&)_Right);
; 1129 : 			this->_Map = _Right._Map;
; 1130 : 			this->_Mapsize = _Right._Mapsize;
; 1131 : 			this->_Myoff = _Right._Myoff;
; 1132 : 			this->_Mysize = _Right._Mysize;
; 1133 : 
; 1134 : 			_Right._Map = _Mapptr();
; 1135 : 			_Right._Mapsize = 0;
; 1136 : 			_Right._Myoff = 0;
; 1137 : 			_Right._Mysize = 0;
; 1138 : 			}
; 1139 : 		}
; 1140 : 
; 1141 : 	void push_front(value_type&& _Val)
; 1142 : 		{	// insert element at beginning
; 1143 : 		this->_Orphan_all();
; 1144 : 		_PUSH_FRONT_BEGIN;
; 1145 : 		this->_Getal().construct(
; 1146 : 			this->_Map[_Block] + _Newoff % _DEQUESIZ,
; 1147 : 			_STD forward<value_type>(_Val));
; 1148 : 		_PUSH_FRONT_END;
; 1149 : 		}
; 1150 : 
; 1151 : 	void push_back(value_type&& _Val)
; 1152 : 		{	// insert element at end
; 1153 : 		this->_Orphan_all();
; 1154 : 		_PUSH_BACK_BEGIN;
; 1155 : 		this->_Getal().construct(
; 1156 : 			this->_Map[_Block] + _Newoff % _DEQUESIZ,
; 1157 : 			_STD forward<value_type>(_Val));
; 1158 : 		_PUSH_BACK_END;
; 1159 : 		}
; 1160 : 
; 1161 : 	iterator insert(const_iterator _Where, _Ty&& _Val)
; 1162 : 		{	// insert _Val at _Where
; 1163 : 		return (emplace(_Where, _STD move(_Val)));
; 1164 : 		}
; 1165 : 
; 1166 : #define _DEQUE_EMPLACE( \
; 1167 : 	TEMPLATE_LIST, PADDING_LIST, LIST, COMMA, X1, X2, X3, X4) \
; 1168 : 	TEMPLATE_LIST(_CLASS_TYPE) \
; 1169 : 		void emplace_front(LIST(_TYPE_REFREF_ARG)) \
; 1170 : 		{	/* insert element at beginning */ \
; 1171 : 		this->_Orphan_all(); \
; 1172 : 		_PUSH_FRONT_BEGIN; \
; 1173 : 		this->_Getal().construct( \
; 1174 : 			this->_Map[_Block] + _Newoff % _DEQUESIZ \
; 1175 : 				COMMA LIST(_FORWARD_ARG)); \
; 1176 : 		_PUSH_FRONT_END; \
; 1177 : 	} \
; 1178 : 	TEMPLATE_LIST(_CLASS_TYPE) \
; 1179 : 		void emplace_back(LIST(_TYPE_REFREF_ARG)) \
; 1180 : 		{	/* insert element at end */ \
; 1181 : 		this->_Orphan_all(); \
; 1182 : 		_PUSH_BACK_BEGIN; \
; 1183 : 		this->_Getal().construct( \
; 1184 : 			this->_Map[_Block] + _Newoff % _DEQUESIZ \
; 1185 : 				COMMA LIST(_FORWARD_ARG)); \
; 1186 : 		_PUSH_BACK_END; \
; 1187 : 		} \
; 1188 : 	TEMPLATE_LIST(_CLASS_TYPE) \
; 1189 : 		iterator emplace(const_iterator _Where \
; 1190 : 			COMMA LIST(_TYPE_REFREF_ARG)) \
; 1191 : 		{	/* insert element at _Where */ \
; 1192 : 		size_type _Off = _Where - begin(); \
; 1193 : 		_DEQUE_EMPLACE_CHECK \
; 1194 : 		if (_Off <= this->_Mysize / 2) \
; 1195 : 			{	/* closer to front, push to front then rotate */ \
; 1196 : 			emplace_front(LIST(_FORWARD_ARG)); \
; 1197 : 			_STD rotate(begin(), begin() + 1, begin() + 1 + _Off); \
; 1198 : 			} \
; 1199 : 		else \
; 1200 : 			{	/* closer to back, push to back then rotate */ \
; 1201 : 			emplace_back(LIST(_FORWARD_ARG)); \
; 1202 : 			_STD rotate(begin() + _Off, end() - 1, end()); \
; 1203 : 			} \
; 1204 : 		return (begin() + _Off); \
; 1205 : 			}
; 1206 : 
; 1207 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1208 : #define _DEQUE_EMPLACE_CHECK \
; 1209 : 		if (this->_Mysize < _Off) \
; 1210 : 			_DEBUG_ERROR("deque emplace iterator outside range");
; 1211 : 
; 1212 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1213 : #define _DEQUE_EMPLACE_CHECK
; 1214 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1215 : 
; 1216 : _VARIADIC_EXPAND_0X(_DEQUE_EMPLACE, , , , )
; 1217 : #undef _DEQUE_EMPLACE_CHECK
; 1218 : #undef _DEQUE_EMPLACE
; 1219 : 
; 1220 : 	~deque() _NOEXCEPT
; 1221 : 		{	// destroy the deque
; 1222 : 		_Tidy();
; 1223 : 		}
; 1224 : 
; 1225 : 	_Myt& operator=(const _Myt& _Right)
; 1226 : 		{	// assign _Right
; 1227 : 		if (this != &_Right)
; 1228 : 			{	// different, assign it
; 1229 :  #if _HAS_CPP0X
; 1230 : 			if (this->_Getal() != _Right._Getal()
; 1231 : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 1232 : 				{	// change allocator before copying
; 1233 : 				_Tidy();
; 1234 : 				this->_Change_alloc(_Right._Getal());
; 1235 : 				}
; 1236 :  #endif /* _HAS_CPP0X */
; 1237 : 
; 1238 : 			this->_Orphan_all();
; 1239 : 
; 1240 : 			if (_Right._Mysize == 0)
; 1241 : 				clear();
; 1242 : 			else if (_Right._Mysize <= this->_Mysize)
; 1243 : 				{	// enough elements, copy new and destroy old
; 1244 : 				iterator _Mid = _STD copy(_Right.begin(), _Right.end(),
; 1245 : 					begin());
; 1246 : 				erase(_Mid, end());
; 1247 : 				}
; 1248 : 			else
; 1249 : 				{	// new sequence longer, copy and construct new
; 1250 : 				const_iterator _Mid = _Right.begin() + this->_Mysize;
; 1251 : 				_STD copy(_Right.begin(), _Mid, begin());
; 1252 : 				insert(end(), _Mid, _Right.end());
; 1253 : 				}
; 1254 : 			}
; 1255 : 		return (*this);
; 1256 : 		}
; 1257 : 
; 1258 : 	iterator begin() _NOEXCEPT
; 1259 : 		{	// return iterator for beginning of mutable sequence
; 1260 : 		return (iterator(this->_Myoff, this));
; 1261 : 		}
; 1262 : 
; 1263 : 	const_iterator begin() const _NOEXCEPT
; 1264 : 		{	// return iterator for beginning of nonmutable sequence
; 1265 : 		return (const_iterator(this->_Myoff, this));
; 1266 : 		}
; 1267 : 
; 1268 : 	iterator end() _NOEXCEPT
; 1269 : 		{	// return iterator for end of mutable sequence
; 1270 : 		return (iterator(this->_Myoff + this->_Mysize, this));
; 1271 : 		}
; 1272 : 
; 1273 : 	const_iterator end() const _NOEXCEPT
; 1274 : 		{	// return iterator for end of nonmutable sequence
; 1275 : 		return (const_iterator(this->_Myoff + this->_Mysize, this));
; 1276 : 		}
; 1277 : 
; 1278 : 	iterator _Make_iter(const_iterator _Where) const
; 1279 : 		{	// make iterator from const_iterator
; 1280 : 		return (iterator(_Where._Myoff, this));
; 1281 : 		}
; 1282 : 
; 1283 : 	reverse_iterator rbegin() _NOEXCEPT
; 1284 : 		{	// return iterator for beginning of reversed mutable sequence
; 1285 : 		return (reverse_iterator(end()));
; 1286 : 		}
; 1287 : 
; 1288 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1289 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1290 : 		return (const_reverse_iterator(end()));
; 1291 : 		}
; 1292 : 
; 1293 : 	reverse_iterator rend() _NOEXCEPT
; 1294 : 		{	// return iterator for end of reversed mutable sequence
; 1295 : 		return (reverse_iterator(begin()));
; 1296 : 		}
; 1297 : 
; 1298 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1299 : 		{	// return iterator for end of reversed nonmutable sequence
; 1300 : 		return (const_reverse_iterator(begin()));
; 1301 : 		}
; 1302 : 
; 1303 :  #if _HAS_CPP0X
; 1304 : 	const_iterator cbegin() const _NOEXCEPT
; 1305 : 		{	// return iterator for beginning of nonmutable sequence
; 1306 : 		return (((const _Myt *)this)->begin());
; 1307 : 		}
; 1308 : 
; 1309 : 	const_iterator cend() const _NOEXCEPT
; 1310 : 		{	// return iterator for end of nonmutable sequence
; 1311 : 		return (((const _Myt *)this)->end());
; 1312 : 		}
; 1313 : 
; 1314 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1315 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1316 : 		return (((const _Myt *)this)->rbegin());
; 1317 : 		}
; 1318 : 
; 1319 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1320 : 		{	// return iterator for end of reversed nonmutable sequence
; 1321 : 		return (((const _Myt *)this)->rend());
; 1322 : 		}
; 1323 : 
; 1324 : 	void shrink_to_fit()
; 1325 : 		{	// reduce capacity
; 1326 : 		size_type _Oldcapacity = _DEQUESIZ * this->_Mapsize;
; 1327 : 		size_type _Newcapacity = _Oldcapacity / 2;
; 1328 : 
; 1329 : 		if (_Newcapacity < _DEQUESIZ * _DEQUEMAPSIZ)
; 1330 : 			_Newcapacity = _DEQUESIZ * _DEQUEMAPSIZ;
; 1331 : 
; 1332 : 		if ((empty() && 0 < this->_Mapsize)
; 1333 : 			|| (!empty()
; 1334 : 				&& size() <= _Newcapacity
; 1335 : 				&& _Newcapacity < _Oldcapacity))
; 1336 : 			{	// worth shrinking, do it
; 1337 : 			_Myt _Tmp(_STD make_move_iterator(begin()),
; 1338 : 				_STD make_move_iterator(end()));
; 1339 : 			swap(_Tmp);
; 1340 : 			}
; 1341 : 		}
; 1342 :  #endif /* _HAS_CPP0X */
; 1343 : 
; 1344 : 	void resize(size_type _Newsize)
; 1345 : 		{	// determine new length, padding as needed
; 1346 : 		if (_Newsize < this->_Mysize)
; 1347 : 			erase(begin() + _Newsize, end());
; 1348 : 		else if (this->_Mysize < _Newsize)
; 1349 : 			{	// append default-constructed elements
; 1350 : 			_Alty _Alval(this->_Getal());
; 1351 : 			this->_Orphan_all();
; 1352 : 			while (this->_Mysize < _Newsize)
; 1353 : 				{	// push_back default-constructed element
; 1354 : 				_PUSH_BACK_BEGIN;
; 1355 : 				_Uninitialized_default_fill_n(
; 1356 : 					this->_Map[_Block] + _Newoff % _DEQUESIZ, 1, _Alval);
; 1357 : 				_PUSH_BACK_END;
; 1358 : 				}
; 1359 : 			}
; 1360 : 		}
; 1361 : 
; 1362 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1363 : 		{	// determine new length, padding with _Val elements as needed
; 1364 : 		if (this->_Mysize < _Newsize)
; 1365 : 			_Insert_n(end(), _Newsize - this->_Mysize, _Val);
; 1366 : 		else if (_Newsize < this->_Mysize)
; 1367 : 			erase(begin() + _Newsize, end());
; 1368 : 		}
; 1369 : 
; 1370 : 	size_type size() const _NOEXCEPT
; 1371 : 		{	// return length of sequence
; 1372 : 		return (this->_Mysize);
; 1373 : 		}
; 1374 : 
; 1375 : 	size_type max_size() const _NOEXCEPT
; 1376 : 		{	// return maximum possible length of sequence
; 1377 : 		return (this->_Getal().max_size());
; 1378 : 		}
; 1379 : 
; 1380 : 	bool empty() const _NOEXCEPT
; 1381 : 		{	// test if sequence is empty
; 1382 : 		return (this->_Mysize == 0);

  0006d	48 85 c9	 test	 rcx, rcx

; 1858 : 		_Alpty _Almap(this->_Getal());
; 1859 : 		while (!empty())

  00070	75 ab		 jne	 SHORT $LN63@Tidy
$LN61@Tidy:

; 1861 : 		for (size_type _Block = this->_Mapsize; 0 < _Block; )

  00072	48 8b 7b 10	 mov	 rdi, QWORD PTR [rbx+16]
  00076	48 85 ff	 test	 rdi, rdi
  00079	74 1f		 je	 SHORT $LN3@Tidy
  0007b	0f 1f 44 00 00	 npad	 5
$LL4@Tidy:

; 1862 : 			{	// free storage for a block and destroy pointer
; 1863 : 			if (this->_Map[--_Block] != pointer())

  00080	48 8b 43 08	 mov	 rax, QWORD PTR [rbx+8]
  00084	48 ff cf	 dec	 rdi
  00087	48 8b 0c f8	 mov	 rcx, QWORD PTR [rax+rdi*8]
  0008b	48 85 c9	 test	 rcx, rcx
  0008e	74 05		 je	 SHORT $LN2@Tidy
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 586  : 		::operator delete(_Ptr);

  00090	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
$LN2@Tidy:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 1861 : 		for (size_type _Block = this->_Mapsize; 0 < _Block; )

  00095	48 85 ff	 test	 rdi, rdi
  00098	75 e6		 jne	 SHORT $LL4@Tidy
$LN3@Tidy:

; 1864 : 				{	// free block and destroy its pointer
; 1865 : 				this->_Getal().deallocate(this->_Map[_Block], _DEQUESIZ);
; 1866 : 				this->_Getal().destroy(&this->_Map[_Block]);
; 1867 : 				}
; 1868 : 			}
; 1869 : 
; 1870 : 		if (this->_Map != _Mapptr())

  0009a	48 8b 4b 08	 mov	 rcx, QWORD PTR [rbx+8]
  0009e	48 85 c9	 test	 rcx, rcx
  000a1	74 05		 je	 SHORT $LN60@Tidy
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 586  : 		::operator delete(_Ptr);

  000a3	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
$LN60@Tidy:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 1874 : 		this->_Map = _Mapptr();

  000a8	48 89 73 08	 mov	 QWORD PTR [rbx+8], rsi
  000ac	48 89 73 10	 mov	 QWORD PTR [rbx+16], rsi

; 1875 : 		}

  000b0	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000b5	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  000ba	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000be	5f		 pop	 rdi
  000bf	c3		 ret	 0
?_Tidy@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAXXZ ENDP ; std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
;	COMDAT ??1?$_Deque_alloc@$0A@U?$_Deque_base_types@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$_Deque_alloc@$0A@U?$_Deque_base_types@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@@std@@QEAA@XZ PROC ; std::_Deque_alloc<0,std::_Deque_base_types<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > > >::~_Deque_alloc<0,std::_Deque_base_types<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > > >, COMDAT

; 883  : 		{	// destroy proxy

$LN12:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 586  : 		::operator delete(_Ptr);

  00009	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0000c	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 912  : 		this->_Myproxy = 0;

  00011	48 c7 03 00 00
	00 00		 mov	 QWORD PTR [rbx], 0

; 884  : 		_Free_proxy();
; 885  : 		}

  00018	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001c	5b		 pop	 rbx
  0001d	c3		 ret	 0
??1?$_Deque_alloc@$0A@U?$_Deque_base_types@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@@std@@QEAA@XZ ENDP ; std::_Deque_alloc<0,std::_Deque_base_types<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > > >::~_Deque_alloc<0,std::_Deque_base_types<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1?$_Deque_val@U?$_Deque_simple_types@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$dead$ = 8
??1?$_Deque_val@U?$_Deque_simple_types@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QEAA@XZ PROC ; std::_Deque_val<std::_Deque_simple_types<std::shared_ptr<ChunkBase> > >::~_Deque_val<std::_Deque_simple_types<std::shared_ptr<ChunkBase> > >, COMDAT
  00000	c2 00 00	 ret	 0
??1?$_Deque_val@U?$_Deque_simple_types@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QEAA@XZ ENDP ; std::_Deque_val<std::_Deque_simple_types<std::shared_ptr<ChunkBase> > >::~_Deque_val<std::_Deque_simple_types<std::shared_ptr<ChunkBase> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
;	COMDAT ?pop_back@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
?pop_back@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAAXXZ PROC ; std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::pop_back, COMDAT

; 1494 : 		{	// erase element at end

$LN33:
  00000	40 57		 push	 rdi
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b f9	 mov	 rdi, rcx

; 788  : 		}
; 789  : 
; 790  : 	_Mapptr _Map;		// pointer to array of pointers to blocks
; 791  : 	size_type _Mapsize;	// size of map array, zero or 2^N
; 792  : 	size_type _Myoff;	// offset of initial element
; 793  : 	size_type _Mysize;	// current length of sequence
; 794  : 	};
; 795  : 
; 796  : 		// TEMPLATE CLASS _Deque_alloc
; 797  : template<bool _Al_has_storage,
; 798  : 	class _Alloc_types>
; 799  : 	class _Deque_alloc
; 800  : 		: public _Deque_val<typename _Alloc_types::_Val_types>
; 801  : 	{	// base class for deque to hold allocator with storage
; 802  : public:
; 803  : 	typedef _Deque_alloc<_Al_has_storage, _Alloc_types> _Myt;
; 804  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 805  : 	typedef typename _Alloc_types::_Alty _Alty;
; 806  : 
; 807  : 	typedef typename _Alloc_types::_Alpty _Alpty;
; 808  : 
; 809  : 	_Deque_alloc(const _Alloc& _Al = _Alloc())
; 810  : 		: _Alval(_Al)
; 811  : 		{	// construct allocators from _Al
; 812  : 		_Alloc_proxy();
; 813  : 		}
; 814  : 
; 815  : 	~_Deque_alloc() _NOEXCEPT
; 816  : 		{	// destroy proxy
; 817  : 		_Free_proxy();
; 818  : 		}
; 819  : 
; 820  : 	void _Change_alloc(const _Alty& _Al)
; 821  : 		{	// replace old allocator
; 822  : 		_Free_proxy();
; 823  : 		_Alval = _Al;
; 824  : 		_Alloc_proxy();
; 825  : 		}
; 826  : 
; 827  : 	void _Swap_alloc(_Myt& _Right)
; 828  : 		{	// swap allocators
; 829  : 		_Swap_adl(_Alval, _Right._Alval);
; 830  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 831  : 		}
; 832  : 
; 833  : 	void _Alloc_proxy()
; 834  : 		{	// construct proxy from _Alval
; 835  : 		typename _Alty::template rebind<_Container_proxy>::other
; 836  : 			_Alproxy(_Alval);
; 837  : 		this->_Myproxy = _Alproxy.allocate(1);
; 838  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 839  : 		this->_Myproxy->_Mycont = this;
; 840  : 		}
; 841  : 
; 842  : 	void _Free_proxy()
; 843  : 		{	// destroy proxy
; 844  : 		typename _Alty::template rebind<_Container_proxy>::other
; 845  : 			_Alproxy(_Alval);
; 846  : 		this->_Orphan_all();
; 847  : 		_Alproxy.destroy(this->_Myproxy);
; 848  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 849  : 		this->_Myproxy = 0;
; 850  : 		}
; 851  : 
; 852  : 	_Alty& _Getal()
; 853  : 		{	// get reference to allocator
; 854  : 		return (_Alval);
; 855  : 		}
; 856  : 
; 857  : 	const _Alty& _Getal() const
; 858  : 		{	// get reference to allocator
; 859  : 		return (_Alval);
; 860  : 		}
; 861  : 
; 862  : 	_Alty _Alval;	// allocator object for stored elements
; 863  : 	};
; 864  : 
; 865  : template<class _Alloc_types>
; 866  : 	class _Deque_alloc<false, _Alloc_types>
; 867  : 		: public _Deque_val<typename _Alloc_types::_Val_types>
; 868  : 	{	// base class for deque to hold allocator with no storage
; 869  : public:
; 870  : 	typedef _Deque_alloc<false, _Alloc_types> _Myt;
; 871  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 872  : 
; 873  : 	typedef typename _Alloc_types::_Alty _Alty;
; 874  : 
; 875  : 	typedef typename _Alloc_types::_Alpty _Alpty;
; 876  : 
; 877  : 	_Deque_alloc(const _Alloc& = _Alloc())
; 878  : 		{	// construct allocators from _Al
; 879  : 		_Alloc_proxy();
; 880  : 		}
; 881  : 
; 882  : 	~_Deque_alloc() _NOEXCEPT
; 883  : 		{	// destroy proxy
; 884  : 		_Free_proxy();
; 885  : 		}
; 886  : 
; 887  : 	void _Change_alloc(const _Alty&)
; 888  : 		{	// replace old allocator
; 889  : 		}
; 890  : 
; 891  : 	void _Swap_alloc(_Myt& _Right)
; 892  : 		{	// swap allocators
; 893  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 894  : 		}
; 895  : 
; 896  : 	void _Alloc_proxy()
; 897  : 		{	// construct proxy from _Alval
; 898  : 		typename _Alty::template rebind<_Container_proxy>::other
; 899  : 			_Alproxy;
; 900  : 		this->_Myproxy = _Alproxy.allocate(1);
; 901  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 902  : 		this->_Myproxy->_Mycont = this;
; 903  : 		}
; 904  : 
; 905  : 	void _Free_proxy()
; 906  : 		{	// destroy proxy
; 907  : 		typename _Alty::template rebind<_Container_proxy>::other
; 908  : 			_Alproxy;
; 909  : 		this->_Orphan_all();
; 910  : 		_Alproxy.destroy(this->_Myproxy);
; 911  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 912  : 		this->_Myproxy = 0;
; 913  : 		}
; 914  : 
; 915  : 	_Alty _Getal() const
; 916  : 		{	// get reference to allocator
; 917  : 		return (_Alty());
; 918  : 		}
; 919  : 	};
; 920  : 
; 921  : 		// TEMPLATE CLASS deque
; 922  : template<class _Ty,
; 923  : 	class _Alloc = allocator<_Ty> >
; 924  : 	class deque
; 925  : 		: public _Deque_alloc<!is_empty<_Alloc>::value,
; 926  : 			_Deque_base_types<_Ty, _Alloc> >
; 927  : 	{	// circular queue of pointers to blocks
; 928  : public:
; 929  : 	typedef deque<_Ty, _Alloc> _Myt;
; 930  : 	typedef _Deque_alloc<!is_empty<_Alloc>::value,
; 931  : 		_Deque_base_types<_Ty, _Alloc> > _Mybase;
; 932  : 	typedef _Alloc allocator_type;
; 933  : 
; 934  : 	typedef typename _Mybase::_Alty _Alty;
; 935  : 	typedef typename _Mybase::_Alpty _Alpty;
; 936  : 	typedef typename _Mybase::_Mapptr _Mapptr;
; 937  : 
; 938  : 	typedef typename _Mybase::value_type value_type;
; 939  : 	typedef typename _Mybase::size_type size_type;
; 940  : 	typedef typename _Mybase::difference_type difference_type;
; 941  : 	typedef typename _Mybase::pointer pointer;
; 942  : 	typedef typename _Mybase::const_pointer const_pointer;
; 943  : 	typedef typename _Mybase::reference reference;
; 944  : 	typedef typename _Mybase::const_reference const_reference;
; 945  : 
; 946  : 	typedef typename _Mybase::iterator iterator;
; 947  : 	typedef typename _Mybase::const_iterator const_iterator;
; 948  : 
; 949  : 	typedef _STD reverse_iterator<iterator> reverse_iterator;
; 950  : 	typedef _STD reverse_iterator<const_iterator> const_reverse_iterator;
; 951  : 
; 952  : 	static const int _EEM_DS = _DEQUESIZ;
; 953  : 	enum {_EEN_DS = _DEQUESIZ};	// helper for expression evaluator
; 954  : 	deque()
; 955  : 		: _Mybase()
; 956  : 		{	// construct empty deque
; 957  : 		}
; 958  : 
; 959  : 	explicit deque(const _Alloc& _Al)
; 960  : 		: _Mybase(_Al)
; 961  : 		{	// construct empty deque with allocator
; 962  : 		}
; 963  : 
; 964  : 	explicit deque(size_type _Count)
; 965  : 		: _Mybase()
; 966  : 		{	// construct from _Count * value_type()
; 967  : 		resize(_Count);
; 968  : 		}
; 969  : 
; 970  : 	deque(size_type _Count, const value_type& _Val)
; 971  : 		: _Mybase()
; 972  : 		{	// construct from _Count * _Val
; 973  : 		_Construct_n(_Count, _Val);
; 974  : 		}
; 975  : 
; 976  : 	deque(size_type _Count, const value_type& _Val, const _Alloc& _Al)
; 977  : 		: _Mybase(_Al)
; 978  : 		{	// construct from _Count * _Val with allocator
; 979  : 		_Construct_n(_Count, _Val);
; 980  : 		}
; 981  : 
; 982  : 	deque(const _Myt& _Right)
; 983  : 
; 984  :  #if _HAS_CPP0X
; 985  : 		: _Mybase(_Right._Getal().select_on_container_copy_construction())
; 986  : 
; 987  :  #else /* _HAS_CPP0X */
; 988  : 		: _Mybase(_Right._Getal())
; 989  :  #endif /* _HAS_CPP0X */
; 990  : 
; 991  : 		{	// construct by copying _Right
; 992  : 		_TRY_BEGIN
; 993  : 		insert(begin(), _Right.begin(), _Right.end());
; 994  : 		_CATCH_ALL
; 995  : 		_Tidy();
; 996  : 		_RERAISE;
; 997  : 		_CATCH_END
; 998  : 		}
; 999  : 
; 1000 : 	deque(const _Myt& _Right, const _Alloc& _Al)
; 1001 : 		: _Mybase(_Al)
; 1002 : 		{	// construct by copying _Right
; 1003 : 		_TRY_BEGIN
; 1004 : 		insert(begin(), _Right.begin(), _Right.end());
; 1005 : 		_CATCH_ALL
; 1006 : 		_Tidy();
; 1007 : 		_RERAISE;
; 1008 : 		_CATCH_END
; 1009 : 		}
; 1010 : 
; 1011 : 	template<class _Iter>
; 1012 : 		deque(_Iter _First, _Iter _Last,
; 1013 : 			typename enable_if<_Is_iterator<_Iter>::value,
; 1014 : 				void>::type ** = 0)
; 1015 : 		: _Mybase()
; 1016 : 		{	// construct from [_First, _Last)
; 1017 : 		_Construct(_First, _Last);
; 1018 : 		}
; 1019 : 
; 1020 : 	template<class _Iter>
; 1021 : 		deque(_Iter _First, _Iter _Last, const _Alloc& _Al,
; 1022 : 			typename enable_if<_Is_iterator<_Iter>::value,
; 1023 : 				void>::type ** = 0)
; 1024 : 		: _Mybase(_Al)
; 1025 : 		{	// construct from [_First, _Last) with allocator
; 1026 : 		_Construct(_First, _Last);
; 1027 : 		}
; 1028 : 
; 1029 : 	template<class _Iter>
; 1030 : 		void _Construct(_Iter _First, _Iter _Last)
; 1031 : 		{	// initialize from [_First, _Last), input iterators
; 1032 : 		_TRY_BEGIN
; 1033 : 		insert(begin(), _First, _Last);
; 1034 : 		_CATCH_ALL
; 1035 : 		_Tidy();
; 1036 : 		_RERAISE;
; 1037 : 		_CATCH_END
; 1038 : 		}
; 1039 : 
; 1040 : 	void _Construct_n(size_type _Count, const value_type& _Val)
; 1041 : 		{	// construct from _Count * _Val
; 1042 : 		_TRY_BEGIN
; 1043 : 		_Insert_n(begin(), _Count, _Val);
; 1044 : 		_CATCH_ALL
; 1045 : 		_Tidy();
; 1046 : 		_RERAISE;
; 1047 : 		_CATCH_END
; 1048 : 		}
; 1049 : 
; 1050 : #define _PUSH_FRONT_BEGIN \
; 1051 : 	if (this->_Myoff % _DEQUESIZ == 0 \
; 1052 : 		&& this->_Mapsize <= (this->_Mysize + _DEQUESIZ) / _DEQUESIZ) \
; 1053 : 		_Growmap(1); \
; 1054 : 	this->_Myoff &= this->_Mapsize * _DEQUESIZ - 1; \
; 1055 : 	size_type _Newoff = this->_Myoff != 0 ? this->_Myoff \
; 1056 : 		: this->_Mapsize * _DEQUESIZ; \
; 1057 : 	size_type _Block = this->_Getblock(--_Newoff); \
; 1058 : 	if (this->_Map[_Block] == pointer()) \
; 1059 : 		this->_Map[_Block] = this->_Getal().allocate(_DEQUESIZ)
; 1060 : 
; 1061 : #define _PUSH_FRONT_END \
; 1062 : 	this->_Myoff = _Newoff; \
; 1063 : 	++this->_Mysize
; 1064 : 
; 1065 : #define _PUSH_BACK_BEGIN \
; 1066 : 	if ((this->_Myoff + this->_Mysize) % _DEQUESIZ == 0 \
; 1067 : 		&& this->_Mapsize <= (this->_Mysize + _DEQUESIZ) / _DEQUESIZ) \
; 1068 : 		_Growmap(1); \
; 1069 : 	this->_Myoff &= this->_Mapsize * _DEQUESIZ - 1; \
; 1070 : 	size_type _Newoff = this->_Myoff + this->_Mysize; \
; 1071 : 	size_type _Block = this->_Getblock(_Newoff); \
; 1072 : 	if (this->_Map[_Block] == pointer()) \
; 1073 : 		this->_Map[_Block] = this->_Getal().allocate(_DEQUESIZ)
; 1074 : 
; 1075 : #define _PUSH_BACK_END \
; 1076 : 	++this->_Mysize
; 1077 : 
; 1078 : 	deque(_Myt&& _Right)
; 1079 : 		: _Mybase(_Right._Getal())
; 1080 : 		{	// construct by moving _Right
; 1081 : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 1082 : 		}
; 1083 : 
; 1084 : 	deque(_Myt&& _Right, const _Alloc& _Al)
; 1085 : 		: _Mybase(_Al)
; 1086 : 		{	// construct by moving _Right
; 1087 : 		if (this->_Getal() != _Right._Getal())
; 1088 : 			assign(_STD make_move_iterator(_Right.begin()),
; 1089 : 				_STD make_move_iterator(_Right.end()));
; 1090 : 		else
; 1091 : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 1092 : 		}
; 1093 : 
; 1094 : 	_Myt& operator=(_Myt&& _Right)
; 1095 : 		{	// assign by moving _Right
; 1096 : 		if (this != &_Right)
; 1097 : 			{	// different, assign it
; 1098 : 			_Tidy();
; 1099 : 
; 1100 :  #if _HAS_CPP0X
; 1101 : 			if (this->_Getal() != _Right._Getal()
; 1102 : 				&& _Alty::propagate_on_container_move_assignment::value)
; 1103 : 				this->_Change_alloc(_Right._Getal());
; 1104 :  #endif /* _HAS_CPP0X */
; 1105 : 
; 1106 : 			if (this->_Getal() != _Right._Getal())
; 1107 : 				assign(_STD make_move_iterator(_Right.begin()),
; 1108 : 					_STD make_move_iterator(_Right.end()));
; 1109 : 			else
; 1110 : 				_Assign_rv(_STD forward<_Myt>(_Right));
; 1111 : 			}
; 1112 : 		return (*this);
; 1113 : 		}
; 1114 : 
; 1115 : 	void _Assign_rv(_Myt&& _Right)
; 1116 : 		{	// assign by moving _Right
; 1117 : 		if (this == &_Right)
; 1118 : 			;
; 1119 : 		else if (get_allocator() != _Right.get_allocator())
; 1120 : 			{	// move construct a copy
; 1121 : 			clear();
; 1122 : 			for (iterator _Next = _Right.begin(); _Next != _Right.end();
; 1123 : 				++_Next)
; 1124 : 				push_back(_STD forward<value_type>(*_Next));
; 1125 : 			}
; 1126 : 		else
; 1127 : 			{	// clear this and steal from _Right
; 1128 : 			this->_Swap_all((_Myt&)_Right);
; 1129 : 			this->_Map = _Right._Map;
; 1130 : 			this->_Mapsize = _Right._Mapsize;
; 1131 : 			this->_Myoff = _Right._Myoff;
; 1132 : 			this->_Mysize = _Right._Mysize;
; 1133 : 
; 1134 : 			_Right._Map = _Mapptr();
; 1135 : 			_Right._Mapsize = 0;
; 1136 : 			_Right._Myoff = 0;
; 1137 : 			_Right._Mysize = 0;
; 1138 : 			}
; 1139 : 		}
; 1140 : 
; 1141 : 	void push_front(value_type&& _Val)
; 1142 : 		{	// insert element at beginning
; 1143 : 		this->_Orphan_all();
; 1144 : 		_PUSH_FRONT_BEGIN;
; 1145 : 		this->_Getal().construct(
; 1146 : 			this->_Map[_Block] + _Newoff % _DEQUESIZ,
; 1147 : 			_STD forward<value_type>(_Val));
; 1148 : 		_PUSH_FRONT_END;
; 1149 : 		}
; 1150 : 
; 1151 : 	void push_back(value_type&& _Val)
; 1152 : 		{	// insert element at end
; 1153 : 		this->_Orphan_all();
; 1154 : 		_PUSH_BACK_BEGIN;
; 1155 : 		this->_Getal().construct(
; 1156 : 			this->_Map[_Block] + _Newoff % _DEQUESIZ,
; 1157 : 			_STD forward<value_type>(_Val));
; 1158 : 		_PUSH_BACK_END;
; 1159 : 		}
; 1160 : 
; 1161 : 	iterator insert(const_iterator _Where, _Ty&& _Val)
; 1162 : 		{	// insert _Val at _Where
; 1163 : 		return (emplace(_Where, _STD move(_Val)));
; 1164 : 		}
; 1165 : 
; 1166 : #define _DEQUE_EMPLACE( \
; 1167 : 	TEMPLATE_LIST, PADDING_LIST, LIST, COMMA, X1, X2, X3, X4) \
; 1168 : 	TEMPLATE_LIST(_CLASS_TYPE) \
; 1169 : 		void emplace_front(LIST(_TYPE_REFREF_ARG)) \
; 1170 : 		{	/* insert element at beginning */ \
; 1171 : 		this->_Orphan_all(); \
; 1172 : 		_PUSH_FRONT_BEGIN; \
; 1173 : 		this->_Getal().construct( \
; 1174 : 			this->_Map[_Block] + _Newoff % _DEQUESIZ \
; 1175 : 				COMMA LIST(_FORWARD_ARG)); \
; 1176 : 		_PUSH_FRONT_END; \
; 1177 : 	} \
; 1178 : 	TEMPLATE_LIST(_CLASS_TYPE) \
; 1179 : 		void emplace_back(LIST(_TYPE_REFREF_ARG)) \
; 1180 : 		{	/* insert element at end */ \
; 1181 : 		this->_Orphan_all(); \
; 1182 : 		_PUSH_BACK_BEGIN; \
; 1183 : 		this->_Getal().construct( \
; 1184 : 			this->_Map[_Block] + _Newoff % _DEQUESIZ \
; 1185 : 				COMMA LIST(_FORWARD_ARG)); \
; 1186 : 		_PUSH_BACK_END; \
; 1187 : 		} \
; 1188 : 	TEMPLATE_LIST(_CLASS_TYPE) \
; 1189 : 		iterator emplace(const_iterator _Where \
; 1190 : 			COMMA LIST(_TYPE_REFREF_ARG)) \
; 1191 : 		{	/* insert element at _Where */ \
; 1192 : 		size_type _Off = _Where - begin(); \
; 1193 : 		_DEQUE_EMPLACE_CHECK \
; 1194 : 		if (_Off <= this->_Mysize / 2) \
; 1195 : 			{	/* closer to front, push to front then rotate */ \
; 1196 : 			emplace_front(LIST(_FORWARD_ARG)); \
; 1197 : 			_STD rotate(begin(), begin() + 1, begin() + 1 + _Off); \
; 1198 : 			} \
; 1199 : 		else \
; 1200 : 			{	/* closer to back, push to back then rotate */ \
; 1201 : 			emplace_back(LIST(_FORWARD_ARG)); \
; 1202 : 			_STD rotate(begin() + _Off, end() - 1, end()); \
; 1203 : 			} \
; 1204 : 		return (begin() + _Off); \
; 1205 : 			}
; 1206 : 
; 1207 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1208 : #define _DEQUE_EMPLACE_CHECK \
; 1209 : 		if (this->_Mysize < _Off) \
; 1210 : 			_DEBUG_ERROR("deque emplace iterator outside range");
; 1211 : 
; 1212 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1213 : #define _DEQUE_EMPLACE_CHECK
; 1214 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1215 : 
; 1216 : _VARIADIC_EXPAND_0X(_DEQUE_EMPLACE, , , , )
; 1217 : #undef _DEQUE_EMPLACE_CHECK
; 1218 : #undef _DEQUE_EMPLACE
; 1219 : 
; 1220 : 	~deque() _NOEXCEPT
; 1221 : 		{	// destroy the deque
; 1222 : 		_Tidy();
; 1223 : 		}
; 1224 : 
; 1225 : 	_Myt& operator=(const _Myt& _Right)
; 1226 : 		{	// assign _Right
; 1227 : 		if (this != &_Right)
; 1228 : 			{	// different, assign it
; 1229 :  #if _HAS_CPP0X
; 1230 : 			if (this->_Getal() != _Right._Getal()
; 1231 : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 1232 : 				{	// change allocator before copying
; 1233 : 				_Tidy();
; 1234 : 				this->_Change_alloc(_Right._Getal());
; 1235 : 				}
; 1236 :  #endif /* _HAS_CPP0X */
; 1237 : 
; 1238 : 			this->_Orphan_all();
; 1239 : 
; 1240 : 			if (_Right._Mysize == 0)
; 1241 : 				clear();
; 1242 : 			else if (_Right._Mysize <= this->_Mysize)
; 1243 : 				{	// enough elements, copy new and destroy old
; 1244 : 				iterator _Mid = _STD copy(_Right.begin(), _Right.end(),
; 1245 : 					begin());
; 1246 : 				erase(_Mid, end());
; 1247 : 				}
; 1248 : 			else
; 1249 : 				{	// new sequence longer, copy and construct new
; 1250 : 				const_iterator _Mid = _Right.begin() + this->_Mysize;
; 1251 : 				_STD copy(_Right.begin(), _Mid, begin());
; 1252 : 				insert(end(), _Mid, _Right.end());
; 1253 : 				}
; 1254 : 			}
; 1255 : 		return (*this);
; 1256 : 		}
; 1257 : 
; 1258 : 	iterator begin() _NOEXCEPT
; 1259 : 		{	// return iterator for beginning of mutable sequence
; 1260 : 		return (iterator(this->_Myoff, this));
; 1261 : 		}
; 1262 : 
; 1263 : 	const_iterator begin() const _NOEXCEPT
; 1264 : 		{	// return iterator for beginning of nonmutable sequence
; 1265 : 		return (const_iterator(this->_Myoff, this));
; 1266 : 		}
; 1267 : 
; 1268 : 	iterator end() _NOEXCEPT
; 1269 : 		{	// return iterator for end of mutable sequence
; 1270 : 		return (iterator(this->_Myoff + this->_Mysize, this));
; 1271 : 		}
; 1272 : 
; 1273 : 	const_iterator end() const _NOEXCEPT
; 1274 : 		{	// return iterator for end of nonmutable sequence
; 1275 : 		return (const_iterator(this->_Myoff + this->_Mysize, this));
; 1276 : 		}
; 1277 : 
; 1278 : 	iterator _Make_iter(const_iterator _Where) const
; 1279 : 		{	// make iterator from const_iterator
; 1280 : 		return (iterator(_Where._Myoff, this));
; 1281 : 		}
; 1282 : 
; 1283 : 	reverse_iterator rbegin() _NOEXCEPT
; 1284 : 		{	// return iterator for beginning of reversed mutable sequence
; 1285 : 		return (reverse_iterator(end()));
; 1286 : 		}
; 1287 : 
; 1288 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1289 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1290 : 		return (const_reverse_iterator(end()));
; 1291 : 		}
; 1292 : 
; 1293 : 	reverse_iterator rend() _NOEXCEPT
; 1294 : 		{	// return iterator for end of reversed mutable sequence
; 1295 : 		return (reverse_iterator(begin()));
; 1296 : 		}
; 1297 : 
; 1298 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1299 : 		{	// return iterator for end of reversed nonmutable sequence
; 1300 : 		return (const_reverse_iterator(begin()));
; 1301 : 		}
; 1302 : 
; 1303 :  #if _HAS_CPP0X
; 1304 : 	const_iterator cbegin() const _NOEXCEPT
; 1305 : 		{	// return iterator for beginning of nonmutable sequence
; 1306 : 		return (((const _Myt *)this)->begin());
; 1307 : 		}
; 1308 : 
; 1309 : 	const_iterator cend() const _NOEXCEPT
; 1310 : 		{	// return iterator for end of nonmutable sequence
; 1311 : 		return (((const _Myt *)this)->end());
; 1312 : 		}
; 1313 : 
; 1314 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1315 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1316 : 		return (((const _Myt *)this)->rbegin());
; 1317 : 		}
; 1318 : 
; 1319 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1320 : 		{	// return iterator for end of reversed nonmutable sequence
; 1321 : 		return (((const _Myt *)this)->rend());
; 1322 : 		}
; 1323 : 
; 1324 : 	void shrink_to_fit()
; 1325 : 		{	// reduce capacity
; 1326 : 		size_type _Oldcapacity = _DEQUESIZ * this->_Mapsize;
; 1327 : 		size_type _Newcapacity = _Oldcapacity / 2;
; 1328 : 
; 1329 : 		if (_Newcapacity < _DEQUESIZ * _DEQUEMAPSIZ)
; 1330 : 			_Newcapacity = _DEQUESIZ * _DEQUEMAPSIZ;
; 1331 : 
; 1332 : 		if ((empty() && 0 < this->_Mapsize)
; 1333 : 			|| (!empty()
; 1334 : 				&& size() <= _Newcapacity
; 1335 : 				&& _Newcapacity < _Oldcapacity))
; 1336 : 			{	// worth shrinking, do it
; 1337 : 			_Myt _Tmp(_STD make_move_iterator(begin()),
; 1338 : 				_STD make_move_iterator(end()));
; 1339 : 			swap(_Tmp);
; 1340 : 			}
; 1341 : 		}
; 1342 :  #endif /* _HAS_CPP0X */
; 1343 : 
; 1344 : 	void resize(size_type _Newsize)
; 1345 : 		{	// determine new length, padding as needed
; 1346 : 		if (_Newsize < this->_Mysize)
; 1347 : 			erase(begin() + _Newsize, end());
; 1348 : 		else if (this->_Mysize < _Newsize)
; 1349 : 			{	// append default-constructed elements
; 1350 : 			_Alty _Alval(this->_Getal());
; 1351 : 			this->_Orphan_all();
; 1352 : 			while (this->_Mysize < _Newsize)
; 1353 : 				{	// push_back default-constructed element
; 1354 : 				_PUSH_BACK_BEGIN;
; 1355 : 				_Uninitialized_default_fill_n(
; 1356 : 					this->_Map[_Block] + _Newoff % _DEQUESIZ, 1, _Alval);
; 1357 : 				_PUSH_BACK_END;
; 1358 : 				}
; 1359 : 			}
; 1360 : 		}
; 1361 : 
; 1362 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1363 : 		{	// determine new length, padding with _Val elements as needed
; 1364 : 		if (this->_Mysize < _Newsize)
; 1365 : 			_Insert_n(end(), _Newsize - this->_Mysize, _Val);
; 1366 : 		else if (_Newsize < this->_Mysize)
; 1367 : 			erase(begin() + _Newsize, end());
; 1368 : 		}
; 1369 : 
; 1370 : 	size_type size() const _NOEXCEPT
; 1371 : 		{	// return length of sequence
; 1372 : 		return (this->_Mysize);
; 1373 : 		}
; 1374 : 
; 1375 : 	size_type max_size() const _NOEXCEPT
; 1376 : 		{	// return maximum possible length of sequence
; 1377 : 		return (this->_Getal().max_size());
; 1378 : 		}
; 1379 : 
; 1380 : 	bool empty() const _NOEXCEPT
; 1381 : 		{	// test if sequence is empty
; 1382 : 		return (this->_Mysize == 0);

  00009	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  0000d	48 85 c9	 test	 rcx, rcx

; 1495 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1496 : 		if (empty())
; 1497 : 			_DEBUG_ERROR("deque empty before pop");
; 1498 : 		else
; 1499 : 			{	// something to erase, do it
; 1500 : 			size_type _Newoff = this->_Myoff + this->_Mysize - 1;
; 1501 : 			_Orphan_off(_Newoff);
; 1502 : 			size_type _Block = this->_Getblock(_Newoff);
; 1503 : 			this->_Getal().destroy(
; 1504 : 				this->_Map[_Block] + _Newoff % _DEQUESIZ);
; 1505 : 			if (--this->_Mysize == 0)
; 1506 : 				this->_Myoff = 0;
; 1507 : 			}
; 1508 : 
; 1509 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1510 : 		if (!empty())

  00010	74 64		 je	 SHORT $LN1@pop_back

; 1511 : 			{	// something to erase, do it
; 1512 : 			size_type _Newoff = this->_Myoff + this->_Mysize - 1;

  00012	48 8b 57 18	 mov	 rdx, QWORD PTR [rdi+24]

; 1513 : 			size_type _Block = this->_Getblock(_Newoff);
; 1514 : 			this->_Getal().destroy(
; 1515 : 				this->_Map[_Block] + _Newoff % _DEQUESIZ);

  00016	48 8b 47 08	 mov	 rax, QWORD PTR [rdi+8]
  0001a	48 ff c9	 dec	 rcx
  0001d	48 03 d1	 add	 rdx, rcx

; 787  : 		return ((_Off / _DEQUESIZ) & (this->_Mapsize - 1));

  00020	48 8b 4f 10	 mov	 rcx, QWORD PTR [rdi+16]
  00024	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx
  00029	48 ff c9	 dec	 rcx
  0002c	48 23 ca	 and	 rcx, rdx

; 1513 : 			size_type _Block = this->_Getblock(_Newoff);
; 1514 : 			this->_Getal().destroy(
; 1515 : 				this->_Map[_Block] + _Newoff % _DEQUESIZ);

  0002f	48 8b 0c c8	 mov	 rcx, QWORD PTR [rax+rcx*8]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  00033	48 8b 59 08	 mov	 rbx, QWORD PTR [rcx+8]
  00037	48 85 db	 test	 rbx, rbx
  0003a	74 27		 je	 SHORT $LN28@pop_back

; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  0003c	f0 ff 4b 08	 lock dec DWORD PTR [rbx+8]
  00040	48 89 74 24 38	 mov	 QWORD PTR [rsp+56], rsi
  00045	75 17		 jne	 SHORT $LN31@pop_back

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  00047	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  0004a	48 8b cb	 mov	 rcx, rbx
  0004d	ff 10		 call	 QWORD PTR [rax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  0004f	f0 ff 4b 0c	 lock dec DWORD PTR [rbx+12]
  00053	75 09		 jne	 SHORT $LN31@pop_back

; 128  : 			_Delete_this();

  00055	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00058	48 8b cb	 mov	 rcx, rbx
  0005b	ff 50 08	 call	 QWORD PTR [rax+8]
$LN31@pop_back:
  0005e	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
$LN28@pop_back:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 1516 : 			if (--this->_Mysize == 0)

  00063	48 ff 4f 20	 dec	 QWORD PTR [rdi+32]
  00067	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0006c	75 08		 jne	 SHORT $LN1@pop_back

; 1517 : 				this->_Myoff = 0;

  0006e	48 c7 47 18 00
	00 00 00	 mov	 QWORD PTR [rdi+24], 0
$LN1@pop_back:

; 1518 : 			}
; 1519 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1520 : 		}

  00076	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0007a	5f		 pop	 rdi
  0007b	c3		 ret	 0
?pop_back@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAAXXZ ENDP ; std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::pop_back
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
;	COMDAT ??0?$_Deque_alloc@$0A@U?$_Deque_base_types@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@@std@@QEAA@AEBV?$allocator@V?$shared_ptr@VChunkBase@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 48
__formal$dead$ = 56
??0?$_Deque_alloc@$0A@U?$_Deque_base_types@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@@std@@QEAA@AEBV?$allocator@V?$shared_ptr@VChunkBase@@@std@@@1@@Z PROC ; std::_Deque_alloc<0,std::_Deque_base_types<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > > >::_Deque_alloc<0,std::_Deque_base_types<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > > >, COMDAT

; 877  : 	_Deque_alloc(const _Alloc& = _Alloc())

$LN44:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility

; 79   : 		{	// construct childless container

  0000a	33 ff		 xor	 edi, edi
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 877  : 	_Deque_alloc(const _Alloc& = _Alloc())

  0000c	48 8b d9	 mov	 rbx, rcx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility

; 79   : 		{	// construct childless container

  0000f	48 89 39	 mov	 QWORD PTR [rcx], rdi
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 778  : 		_Map = _Mapptr();

  00012	48 89 79 08	 mov	 QWORD PTR [rcx+8], rdi

; 779  : 		_Mapsize = 0;

  00016	48 89 79 10	 mov	 QWORD PTR [rcx+16], rdi

; 780  : 		_Myoff = 0;

  0001a	48 89 79 18	 mov	 QWORD PTR [rcx+24], rdi

; 781  : 		_Mysize = 0;

  0001e	48 89 79 20	 mov	 QWORD PTR [rcx+32], rdi
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  00022	8d 4f 10	 lea	 ecx, QWORD PTR [rdi+16]
  00025	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  0002a	48 85 c0	 test	 rax, rax
  0002d	74 1e		 je	 SHORT $LN42@Deque_allo
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 900  : 		this->_Myproxy = _Alproxy.allocate(1);

  0002f	48 89 03	 mov	 QWORD PTR [rbx], rax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 617  : _VARIADIC_EXPAND_0X(_ALLOC_MEMBER_CONSTRUCT, , , , )

  00032	48 89 38	 mov	 QWORD PTR [rax], rdi
  00035	48 89 78 08	 mov	 QWORD PTR [rax+8], rdi
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 902  : 		this->_Myproxy->_Mycont = this;

  00039	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  0003c	48 89 18	 mov	 QWORD PTR [rax], rbx

; 880  : 		}

  0003f	48 8b c3	 mov	 rax, rbx
  00042	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00047	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0004b	5f		 pop	 rdi
  0004c	c3		 ret	 0
$LN42@Deque_allo:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 29   : 		_Xbad_alloc();	// report no memory

  0004d	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
  00052	cc		 int	 3
$LN41@Deque_allo:
??0?$_Deque_alloc@$0A@U?$_Deque_base_types@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@@std@@QEAA@AEBV?$allocator@V?$shared_ptr@VChunkBase@@@std@@@1@@Z ENDP ; std::_Deque_alloc<0,std::_Deque_base_types<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > > >::_Deque_alloc<0,std::_Deque_base_types<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
;	COMDAT ?_Free_proxy@?$_Deque_alloc@$0A@U?$_Deque_base_types@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
?_Free_proxy@?$_Deque_alloc@$0A@U?$_Deque_base_types@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@@std@@QEAAXXZ PROC ; std::_Deque_alloc<0,std::_Deque_base_types<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > > >::_Free_proxy, COMDAT

; 906  : 		{	// destroy proxy

$LN10:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 586  : 		::operator delete(_Ptr);

  00009	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0000c	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 912  : 		this->_Myproxy = 0;

  00011	48 c7 03 00 00
	00 00		 mov	 QWORD PTR [rbx], 0

; 913  : 		}

  00018	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001c	5b		 pop	 rbx
  0001d	c3		 ret	 0
?_Free_proxy@?$_Deque_alloc@$0A@U?$_Deque_base_types@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@@std@@QEAAXXZ ENDP ; std::_Deque_alloc<0,std::_Deque_base_types<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > > >::_Free_proxy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
;	COMDAT ?_Alloc_proxy@?$_Deque_alloc@$0A@U?$_Deque_base_types@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
?_Alloc_proxy@?$_Deque_alloc@$0A@U?$_Deque_base_types@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@@std@@QEAAXXZ PROC ; std::_Deque_alloc<0,std::_Deque_base_types<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > > >::_Alloc_proxy, COMDAT

; 897  : 		{	// construct proxy from _Alval

$LN37:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  00009	b9 10 00 00 00	 mov	 ecx, 16
  0000e	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  00013	48 85 c0	 test	 rax, rax
  00016	74 18		 je	 SHORT $LN35@Alloc_prox
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 900  : 		this->_Myproxy = _Alproxy.allocate(1);

  00018	48 89 03	 mov	 QWORD PTR [rbx], rax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility

; 67   : 		{	// construct from pointers

  0001b	33 d2		 xor	 edx, edx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 617  : _VARIADIC_EXPAND_0X(_ALLOC_MEMBER_CONSTRUCT, , , , )

  0001d	48 89 10	 mov	 QWORD PTR [rax], rdx
  00020	48 89 50 08	 mov	 QWORD PTR [rax+8], rdx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 902  : 		this->_Myproxy->_Mycont = this;

  00024	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00027	48 89 18	 mov	 QWORD PTR [rax], rbx

; 903  : 		}

  0002a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002e	5b		 pop	 rbx
  0002f	c3		 ret	 0
$LN35@Alloc_prox:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 29   : 		_Xbad_alloc();	// report no memory

  00030	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
  00035	cc		 int	 3
$LN34@Alloc_prox:
?_Alloc_proxy@?$_Deque_alloc@$0A@U?$_Deque_base_types@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@@std@@QEAAXXZ ENDP ; std::_Deque_alloc<0,std::_Deque_base_types<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > > >::_Alloc_proxy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
;	COMDAT ??0?$_Deque_val@U?$_Deque_simple_types@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_Deque_val@U?$_Deque_simple_types@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QEAA@XZ PROC ; std::_Deque_val<std::_Deque_simple_types<std::shared_ptr<ChunkBase> > >::_Deque_val<std::_Deque_simple_types<std::shared_ptr<ChunkBase> > >, COMDAT
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility

; 79   : 		{	// construct childless container

  00000	33 c0		 xor	 eax, eax
  00002	48 89 01	 mov	 QWORD PTR [rcx], rax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 778  : 		_Map = _Mapptr();

  00005	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 779  : 		_Mapsize = 0;

  00009	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 780  : 		_Myoff = 0;

  0000d	48 89 41 18	 mov	 QWORD PTR [rcx+24], rax

; 781  : 		_Mysize = 0;

  00011	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax

; 782  : 		}

  00015	48 8b c1	 mov	 rax, rcx
  00018	c3		 ret	 0
??0?$_Deque_val@U?$_Deque_simple_types@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QEAA@XZ ENDP ; std::_Deque_val<std::_Deque_simple_types<std::shared_ptr<ChunkBase> > >::_Deque_val<std::_Deque_simple_types<std::shared_ptr<ChunkBase> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QEAA@XZ PROC ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::_Wrap_alloc<std::allocator<std::_Container_proxy> >, COMDAT

; 831  : 		}

  00000	48 8b c1	 mov	 rax, rcx
  00003	c3		 ret	 0
??0?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QEAA@XZ ENDP ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::_Wrap_alloc<std::allocator<std::_Container_proxy> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QEAAXPEAU_Container_proxy@2@_K@Z
_TEXT	SEGMENT
this$dead$ = 8
_Ptr$ = 16
_Count$dead$ = 24
?deallocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QEAAXPEAU_Container_proxy@2@_K@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::deallocate, COMDAT

; 586  : 		::operator delete(_Ptr);

  00000	48 8b ca	 mov	 rcx, rdx
  00003	e9 00 00 00 00	 jmp	 ??3@YAXPEAX@Z		; operator delete
?deallocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QEAAXPEAU_Container_proxy@2@_K@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QEAAPEAU_Container_proxy@2@_K@Z
_TEXT	SEGMENT
this$dead$ = 48
_Count$dead$ = 56
?allocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QEAAPEAU_Container_proxy@2@_K@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::allocate, COMDAT

; 875  : 		{	// allocate array of _Count elements

$LN17:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  00004	b9 10 00 00 00	 mov	 ecx, 16
  00009	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  0000e	48 85 c0	 test	 rax, rax
  00011	74 05		 je	 SHORT $LN15@allocate

; 876  : 		return (_Mybase::allocate(_Count));
; 877  : 		}

  00013	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00017	c3		 ret	 0
$LN15@allocate:

; 29   : 		_Xbad_alloc();	// report no memory

  00018	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
  0001d	cc		 int	 3
$LN14@allocate:
?allocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QEAAPEAU_Container_proxy@2@_K@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@U_Container_proxy@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$allocator@U_Container_proxy@std@@@std@@QEAA@XZ PROC ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>, COMDAT

; 566  : 		{	// construct default allocator (do nothing)
; 567  : 		}

  00000	48 8b c1	 mov	 rax, rcx
  00003	c3		 ret	 0
??0?$allocator@U_Container_proxy@std@@@std@@QEAA@XZ ENDP ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QEAAXPEAU_Container_proxy@2@_K@Z
_TEXT	SEGMENT
this$dead$ = 8
_Ptr$ = 16
__formal$dead$ = 24
?deallocate@?$allocator@U_Container_proxy@std@@@std@@QEAAXPEAU_Container_proxy@2@_K@Z PROC ; std::allocator<std::_Container_proxy>::deallocate, COMDAT

; 586  : 		::operator delete(_Ptr);

  00000	48 8b ca	 mov	 rcx, rdx
  00003	e9 00 00 00 00	 jmp	 ??3@YAXPEAX@Z		; operator delete
?deallocate@?$allocator@U_Container_proxy@std@@@std@@QEAAXPEAU_Container_proxy@2@_K@Z ENDP ; std::allocator<std::_Container_proxy>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@U_Container_proxy@std@@@std@@QEAAPEAU_Container_proxy@2@_K@Z
_TEXT	SEGMENT
this$dead$ = 48
_Count$dead$ = 56
?allocate@?$allocator@U_Container_proxy@std@@@std@@QEAAPEAU_Container_proxy@2@_K@Z PROC ; std::allocator<std::_Container_proxy>::allocate, COMDAT

; 590  : 		{	// allocate array of _Count elements

$LN14:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  00004	b9 10 00 00 00	 mov	 ecx, 16
  00009	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  0000e	48 85 c0	 test	 rax, rax
  00011	74 05		 je	 SHORT $LN12@allocate

; 591  : 		return (_Allocate(_Count, (pointer)0));
; 592  : 		}

  00013	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00017	c3		 ret	 0
$LN12@allocate:

; 29   : 		_Xbad_alloc();	// report no memory

  00018	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
  0001d	cc		 int	 3
$LN11@allocate:
?allocate@?$allocator@U_Container_proxy@std@@@std@@QEAAPEAU_Container_proxy@2@_K@Z ENDP ; std::allocator<std::_Container_proxy>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\chrono
;	COMDAT ??$?0_J@?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@chrono@std@@QEAA@AEB_JPEAPEAX@Z
_TEXT	SEGMENT
this$ = 8
_Val$ = 16
__formal$dead$ = 24
??$?0_J@?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@chrono@std@@QEAA@AEB_JPEAPEAX@Z PROC ; std::chrono::duration<__int64,std::ratio<1,10000000> >::duration<__int64,std::ratio<1,10000000> ><__int64>, COMDAT

; 105  : 		{	// construct from representation

  00000	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  00003	48 89 01	 mov	 QWORD PTR [rcx], rax

; 106  : 		static_assert(_Is_ratio<_Period>::value,
; 107  : 			"period not an instance of std::ratio");
; 108  : 		static_assert(0 < _Period::num,
; 109  : 			"duration negative or zero");
; 110  : 		}

  00006	48 8b c1	 mov	 rax, rcx
  00009	c3		 ret	 0
??$?0_J@?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@chrono@std@@QEAA@AEB_JPEAPEAX@Z ENDP ; std::chrono::duration<__int64,std::ratio<1,10000000> >::duration<__int64,std::ratio<1,10000000> ><__int64>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xrefwrap
;	COMDAT ??$ref@PEAVThread@@@std@@YA?AV?$reference_wrapper@PEAVThread@@@0@AEAPEAVThread@@@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 8
_Val$ = 16
??$ref@PEAVThread@@@std@@YA?AV?$reference_wrapper@PEAVThread@@@0@AEAPEAVThread@@@Z PROC ; std::ref<Thread * __ptr64>, COMDAT

; 346  : 		{	// construct

  00000	48 89 11	 mov	 QWORD PTR [rcx], rdx

; 883  : 	return (reference_wrapper<_Ty>(_Val));

  00003	48 8b c1	 mov	 rax, rcx

; 884  : 	}

  00006	c3		 ret	 0
??$ref@PEAVThread@@@std@@YA?AV?$reference_wrapper@PEAVThread@@@0@AEAPEAVThread@@@Z ENDP ; std::ref<Thread * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thread
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xrefwrap
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\functional
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xrefwrap
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thread
;	COMDAT ??$?0P6AXPEAVThread@@@ZV?$reference_wrapper@PEAVThread@@@std@@@thread@std@@QEAA@P6AXPEAVThread@@@Z$$QEAV?$reference_wrapper@PEAVThread@@@1@@Z
_TEXT	SEGMENT
$T1 = 32
_Launcher$2 = 40
this$ = 112
_Fx$dead$ = 120
_V0$ = 128
??$?0P6AXPEAVThread@@@ZV?$reference_wrapper@PEAVThread@@@std@@@thread@std@@QEAA@P6AXPEAVThread@@@Z$$QEAV?$reference_wrapper@PEAVThread@@@1@@Z PROC ; std::thread::thread<void (__cdecl*)(Thread * __ptr64),std::reference_wrapper<Thread * __ptr64> >, COMDAT

; 52   : _VARIADIC_EXPAND_0X(_THREAD_CONS, , , , )

$LN107:
  00000	40 57		 push	 rdi
  00002	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  00006	48 c7 44 24 20
	fe ff ff ff	 mov	 QWORD PTR $T1[rsp], -2
  0000f	48 89 5c 24 70	 mov	 QWORD PTR [rsp+112], rbx
  00014	48 8b f9	 mov	 rdi, rcx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xrefwrap

; 351  : 		return (*_Ptr);

  00017	49 8b 18	 mov	 rbx, QWORD PTR [r8]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 182  : 		{	// construct from target

  0001a	48 8d 4c 24 28	 lea	 rcx, QWORD PTR _Launcher$2[rsp]
  0001f	e8 00 00 00 00	 call	 ??0_Pad@std@@QEAA@XZ	; std::_Pad::_Pad
  00024	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7?$_LaunchPad@V?$_Bind@$00XQ6AXPEAVThread@@@ZV?$reference_wrapper@PEAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@std@@@std@@6B@
  0002b	48 89 44 24 28	 mov	 QWORD PTR _Launcher$2[rsp], rax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\functional

; 1152 : _VARIADIC_EXPAND_0X(_CLASS_BIND, , , , )

  00030	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?loop@Thread@@KAXPEAV1@@Z ; Thread::loop
  00037	48 89 44 24 48	 mov	 QWORD PTR _Launcher$2[rsp+32], rax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xrefwrap

; 346  : 		{	// construct

  0003c	48 89 5c 24 50	 mov	 QWORD PTR _Launcher$2[rsp+40], rbx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 206  : 	_Launcher._Launch(_Thr);

  00041	48 8b d7	 mov	 rdx, rdi
  00044	48 8d 4c 24 28	 lea	 rcx, QWORD PTR _Launcher$2[rsp]
  00049	e8 00 00 00 00	 call	 ?_Launch@_Pad@std@@QEAAXPEAU_Thrd_imp_t@@@Z ; std::_Pad::_Launch
  0004e	90		 npad	 1
  0004f	48 8d 4c 24 28	 lea	 rcx, QWORD PTR _Launcher$2[rsp]
  00054	e8 00 00 00 00	 call	 ??1_Pad@std@@QEAA@XZ	; std::_Pad::~_Pad
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thread

; 52   : _VARIADIC_EXPAND_0X(_THREAD_CONS, , , , )

  00059	48 8b c7	 mov	 rax, rdi
  0005c	48 8b 5c 24 70	 mov	 rbx, QWORD PTR [rsp+112]
  00061	48 83 c4 60	 add	 rsp, 96			; 00000060H
  00065	5f		 pop	 rdi
  00066	c3		 ret	 0
??$?0P6AXPEAVThread@@@ZV?$reference_wrapper@PEAVThread@@@std@@@thread@std@@QEAA@P6AXPEAVThread@@@Z$$QEAV?$reference_wrapper@PEAVThread@@@1@@Z ENDP ; std::thread::thread<void (__cdecl*)(Thread * __ptr64),std::reference_wrapper<Thread * __ptr64> >
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
_Launcher$2 = 40
this$ = 112
_Fx$dead$ = 120
_V0$ = 128
?dtor$0@?0???$?0P6AXPEAVThread@@@ZV?$reference_wrapper@PEAVThread@@@std@@@thread@std@@QEAA@P6AXPEAVThread@@@Z$$QEAV?$reference_wrapper@PEAVThread@@@1@@Z@4HA PROC ; `std::thread::thread<void (__cdecl*)(Thread * __ptr64),std::reference_wrapper<Thread * __ptr64> >'::`1'::dtor$0
  00000	48 8d 8a 28 00
	00 00		 lea	 rcx, QWORD PTR _Launcher$2[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1?$_LaunchPad@V?$_Bind@$00XQ6AXPEAVThread@@@ZV?$reference_wrapper@PEAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@std@@@std@@QEAA@XZ
?dtor$0@?0???$?0P6AXPEAVThread@@@ZV?$reference_wrapper@PEAVThread@@@std@@@thread@std@@QEAA@P6AXPEAVThread@@@Z$$QEAV?$reference_wrapper@PEAVThread@@@1@@Z@4HA ENDP ; `std::thread::thread<void (__cdecl*)(Thread * __ptr64),std::reference_wrapper<Thread * __ptr64> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\chrono
;	COMDAT ??$?GUsystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@12@V312@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@01@AEBV?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@01@0@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 8
_Left$ = 16
_Right$ = 24
??$?GUsystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@12@V312@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@01@AEBV?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@01@0@Z PROC ; std::chrono::operator-<std::chrono::system_clock,std::chrono::duration<__int64,std::ratio<1,10000000> >,std::chrono::duration<__int64,std::ratio<1,10000000> > >, COMDAT

; 174  : 		_MyRep -= _Right._MyRep;

  00000	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  00003	49 2b 00	 sub	 rax, QWORD PTR [r8]

; 175  : 		return (*this);
; 176  : 		}
; 177  : 
; 178  : 	_Myt& operator*=(const _Rep& _Right)
; 179  : 		{	// multiply rep by _Right
; 180  : 		_MyRep *= _Right;
; 181  : 		return (*this);
; 182  : 		}
; 183  : 
; 184  : 	_Myt& operator/=(const _Rep& _Right)
; 185  : 		{	// divide rep by _Right
; 186  : 		_MyRep /= _Right;
; 187  : 		return (*this);
; 188  : 		}
; 189  : 
; 190  : 	_Myt& operator%=(const _Rep& _Right)
; 191  : 		{	// modulus rep by _Right
; 192  : 		_MyRep %= _Right;
; 193  : 		return (*this);
; 194  : 		}
; 195  : 
; 196  : 	_Myt& operator%=(const _Myt& _Right)
; 197  : 		{	// modulus rep by _Right
; 198  : 		_MyRep %= _Right.count();
; 199  : 		return (*this);
; 200  : 		}
; 201  : 
; 202  : 	static _Myt zero()
; 203  : 		{	// get zero value
; 204  : 		return (_Myt(duration_values<_Rep>::zero()));
; 205  : 		}
; 206  : 
; 207  : 	static _Myt (min)()
; 208  : 		{	// get minimum value
; 209  : 		return (_Myt((duration_values<_Rep>::min)()));
; 210  : 		}
; 211  : 	static _Myt (max)()
; 212  : 		{	// get maximum value
; 213  : 		return (_Myt((duration_values<_Rep>::max)()));
; 214  : 		}
; 215  : 
; 216  : private:
; 217  : 	_Rep _MyRep;	// the stored rep
; 218  : 	};
; 219  : 
; 220  : template<class _Rep1,
; 221  : 	class _Period1,
; 222  : 	class _Period2>
; 223  : 	class duration<duration<_Rep1, _Period1>, _Period2>
; 224  : 	{	// undefined: duration type as first template argument
; 225  : 	duration()
; 226  : 		{	// check asserts
; 227  : 		static_assert(_Always_false<_Rep1>::value,
; 228  : 			"duration can't have duration as first template argument");
; 229  : 		}
; 230  : 	};
; 231  : 
; 232  : 	// CLASS TEMPLATE _Is_duration
; 233  : template<class _Rep,
; 234  : 	class _Period>
; 235  : 	struct _Is_duration<duration<_Rep, _Period> >
; 236  : 	{	// tests for duration
; 237  : 	static const bool value = true;
; 238  : 	};
; 239  : 
; 240  : template<class _Clock,
; 241  : 	class _Duration = typename _Clock::duration>
; 242  : 	class time_point
; 243  : 	{	// represents a point in time
; 244  : public:
; 245  : 	typedef _Clock clock;
; 246  : 	typedef _Duration duration;
; 247  : 	typedef typename _Duration::rep rep;
; 248  : 	typedef typename _Duration::period period;
; 249  : 
; 250  : 	time_point()
; 251  : 		: _MyDur(_Duration::zero())
; 252  : 		{	// check asserts
; 253  : 		static_assert(_Is_duration<_Duration>::value,
; 254  : 			"duration must be an instance of std::duration");
; 255  : 		}
; 256  : 
; 257  : 	explicit time_point(const _Duration& _Other)
; 258  : 		: _MyDur(_Other)
; 259  : 		{	// construct from a duration
; 260  : 		}
; 261  : 
; 262  : 	template<class _Duration2>
; 263  : 		time_point(const time_point<_Clock, _Duration2>& _Tp,
; 264  : 			typename enable_if<is_convertible<_Duration2, _Duration>::value,
; 265  : 			void>::type ** = 0)
; 266  : 		: _MyDur(_Tp.time_since_epoch())
; 267  : 		{	// construct from another duration
; 268  : 		}
; 269  : 
; 270  : 	_Duration time_since_epoch() const
; 271  : 		{	// get duration from epoch
; 272  : 		return (_MyDur);
; 273  : 		}
; 274  : 
; 275  : 	time_point& operator+=(const _Duration& _Dur)
; 276  : 		{	// increment by duration
; 277  : 		_MyDur += _Dur;
; 278  : 		return (*this);
; 279  : 		}
; 280  : 
; 281  : 	time_point& operator-=(const _Duration& _Dur)
; 282  : 		{	// decrement by duration
; 283  : 		_MyDur -= _Dur;
; 284  : 		return (*this);
; 285  : 		}
; 286  : 
; 287  : 	static time_point (min)()
; 288  : 		{	// get minimum time point
; 289  : 		return (time_point((_Duration::min)()));
; 290  : 		}
; 291  : 	static time_point (max)()
; 292  : 		{	// get maximum time point
; 293  : 		return (time_point((_Duration::max)()));
; 294  : 		}
; 295  : 
; 296  : private:
; 297  : 	_Duration _MyDur;	// duration since the epoch
; 298  : 	};
; 299  : }	// namespace chrono
; 300  : 
; 301  : 	// CLASS TEMPLATE _Lcm (LEAST COMMON MULTIPLE)
; 302  : template<intmax_t _Ax,
; 303  : 	intmax_t _Bx>
; 304  : 	struct _Lcm
; 305  : 	{   /* compute least common multiple of _Ax and _Bx */
; 306  : 	static const intmax_t _Gx = _Gcd<_Ax, _Bx>::value;
; 307  : 	static const intmax_t value = (_Ax / _Gx) * _Bx;
; 308  : 	};
; 309  : 
; 310  : 	// CLASS TEMPLATE common_type SPECIALIZATIONS
; 311  : template<class _Rep1,
; 312  : 	class _Period1,
; 313  : 	class _Rep2,
; 314  : 	class _Period2>
; 315  : 	struct common_type<
; 316  : 		chrono::duration<_Rep1, _Period1>,
; 317  : 		chrono::duration<_Rep2, _Period2> >
; 318  : 	{	// common type of two durations
; 319  : 	typedef chrono::duration<typename common_type<_Rep1, _Rep2>::type,
; 320  : 		ratio<_Gcd<_Period1::num, _Period2::num>::value,
; 321  : 			_Lcm<_Period1::den, _Period2::den>::value> > type;
; 322  : 	};
; 323  : 
; 324  : template<class _Clock,
; 325  : 	class _Duration1,
; 326  : 	class _Duration2>
; 327  : 	struct common_type<
; 328  : 		chrono::time_point<_Clock, _Duration1>,
; 329  : 		chrono::time_point<_Clock, _Duration2> >
; 330  : 	{	// common type of two time points
; 331  : 	typedef chrono::time_point<
; 332  : 		_Clock, typename common_type<_Duration1, _Duration2>::type> type;
; 333  : 	};
; 334  : 
; 335  : namespace chrono {
; 336  : 	// duration ARITHMETIC
; 337  : template<class _Rep1,
; 338  : 	class _Period1,
; 339  : 	class _Rep2,
; 340  : 	class _Period2> inline
; 341  : 	typename common_type<
; 342  : 		duration<_Rep1, _Period1>,
; 343  : 		duration<_Rep2, _Period2> >::type
; 344  : 		operator+(
; 345  : 			const duration<_Rep1, _Period1>& _Left,
; 346  : 			const duration<_Rep2, _Period2>& _Right)
; 347  : 	{	// add two durations
; 348  : 	typedef typename common_type<
; 349  : 		duration<_Rep1, _Period1>,
; 350  : 		duration<_Rep2, _Period2> >::type _CD;
; 351  : 		return (_CD(_Left) += _Right);
; 352  : 		}
; 353  : 
; 354  : template<class _Rep1,
; 355  : 	class _Period1,
; 356  : 	class _Rep2,
; 357  : 	class _Period2> inline
; 358  : 	typename common_type<
; 359  : 		duration<_Rep1, _Period1>,
; 360  : 		duration<_Rep2, _Period2> >::type
; 361  : 		operator-(
; 362  : 			const duration<_Rep1, _Period1>& _Left,
; 363  : 			const duration<_Rep2, _Period2>& _Right)
; 364  : 	{	// subtract two durations
; 365  : 	typedef typename common_type<
; 366  : 		duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _CD;
; 367  : 	return (_CD(_Left) -= _Right);

  00006	48 89 01	 mov	 QWORD PTR [rcx], rax

; 614  : 	return (_Left.time_since_epoch() - _Right.time_since_epoch());

  00009	48 8b c1	 mov	 rax, rcx

; 615  : 	}

  0000c	c3		 ret	 0
??$?GUsystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@12@V312@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@01@AEBV?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@01@0@Z ENDP ; std::chrono::operator-<std::chrono::system_clock,std::chrono::duration<__int64,std::ratio<1,10000000> >,std::chrono::duration<__int64,std::ratio<1,10000000> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\chrono
;	COMDAT ??$duration_cast@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@_JU?$ratio@$00$0JIJGIA@@3@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@AEBV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@01@@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 8
_Dur$ = 16
??$duration_cast@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@_JU?$ratio@$00$0JIJGIA@@3@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@AEBV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@01@@Z PROC ; std::chrono::duration_cast<std::chrono::duration<__int64,std::ratio<1,1000000000> >,__int64,std::ratio<1,10000000> >, COMDAT

; 536  : 	typedef typename ratio_divide<_Period, typename _To::period>::type _CF;
; 537  : 	typedef typename common_type<
; 538  : 		typename common_type<typename _To::rep, _Rep>::type,
; 539  : 			intmax_t>::type _CR;
; 540  : 	if (_CF::num == 1 && _CF::den == 1)
; 541  : 		return (_To(static_cast<typename _To::rep>(_Dur.count())));
; 542  : 	else if (_CF::num != 1 && _CF::den == 1)
; 543  : 		return (_To(static_cast<typename _To::rep>(

  00000	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  00003	48 6b c0 64	 imul	 rax, 100		; 00000064H

; 105  : 		{	// construct from representation

  00007	48 89 01	 mov	 QWORD PTR [rcx], rax

; 536  : 	typedef typename ratio_divide<_Period, typename _To::period>::type _CF;
; 537  : 	typedef typename common_type<
; 538  : 		typename common_type<typename _To::rep, _Rep>::type,
; 539  : 			intmax_t>::type _CR;
; 540  : 	if (_CF::num == 1 && _CF::den == 1)
; 541  : 		return (_To(static_cast<typename _To::rep>(_Dur.count())));
; 542  : 	else if (_CF::num != 1 && _CF::den == 1)
; 543  : 		return (_To(static_cast<typename _To::rep>(

  0000a	48 8b c1	 mov	 rax, rcx

; 544  : 			static_cast<_CR>(_Dur.count())) * static_cast<_CR>(_CF::num)));
; 545  : 	else if (_CF::num == 1 && _CF::den != 1)
; 546  : 		return (_To(static_cast<typename _To::rep>(
; 547  : 			static_cast<_CR>(_Dur.count()) / static_cast<_CR>(_CF::den))));
; 548  : 	else
; 549  : 		return (_To(static_cast<typename _To::rep>(
; 550  : 			static_cast<_CR>(_Dur.count()) * static_cast<_CR>(_CF::num)
; 551  : 			/ static_cast<_CR>(_CF::den))));
; 552  : 	}

  0000d	c3		 ret	 0
??$duration_cast@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@_JU?$ratio@$00$0JIJGIA@@3@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@AEBV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@01@@Z ENDP ; std::chrono::duration_cast<std::chrono::duration<__int64,std::ratio<1,1000000000> >,__int64,std::ratio<1,10000000> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@PEAV?$shared_ptr@VChunkBase@@@std@@@?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QEAAXPEAPEAV?$shared_ptr@VChunkBase@@@1@@Z
_TEXT	SEGMENT
this$dead$ = 8
_Ptr$dead$ = 16
??$destroy@PEAV?$shared_ptr@VChunkBase@@@std@@@?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QEAAXPEAPEAV?$shared_ptr@VChunkBase@@@1@@Z PROC ; std::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> > >::destroy<std::shared_ptr<ChunkBase> * __ptr64>, COMDAT

; 908  : 		{	// destroy object at _Ptr
; 909  : 		_Mytraits::destroy(*this, _Ptr);
; 910  : 		}

  00000	c2 00 00	 ret	 0
??$destroy@PEAV?$shared_ptr@VChunkBase@@@std@@@?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QEAAXPEAPEAV?$shared_ptr@VChunkBase@@@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> > >::destroy<std::shared_ptr<ChunkBase> * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@U_Container_proxy@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QEAAXPEAU_Container_proxy@1@@Z
_TEXT	SEGMENT
this$dead$ = 8
_Ptr$dead$ = 16
??$destroy@U_Container_proxy@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QEAAXPEAU_Container_proxy@1@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::destroy<std::_Container_proxy>, COMDAT

; 908  : 		{	// destroy object at _Ptr
; 909  : 		_Mytraits::destroy(*this, _Ptr);
; 910  : 		}

  00000	c2 00 00	 ret	 0
??$destroy@U_Container_proxy@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QEAAXPEAU_Container_proxy@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::destroy<std::_Container_proxy>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@U_Container_proxy@std@@U12@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QEAAXPEAU_Container_proxy@1@$$QEAU21@@Z
_TEXT	SEGMENT
this$dead$ = 8
_Ptr$ = 16
_V0$ = 24
??$construct@U_Container_proxy@std@@U12@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QEAAXPEAU_Container_proxy@1@$$QEAU21@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::construct<std::_Container_proxy,std::_Container_proxy>, COMDAT

; 617  : _VARIADIC_EXPAND_0X(_ALLOC_MEMBER_CONSTRUCT, , , , )

  00000	48 85 d2	 test	 rdx, rdx
  00003	74 0e		 je	 SHORT $LN11@construct
  00005	49 8b 00	 mov	 rax, QWORD PTR [r8]
  00008	48 89 02	 mov	 QWORD PTR [rdx], rax
  0000b	49 8b 40 08	 mov	 rax, QWORD PTR [r8+8]
  0000f	48 89 42 08	 mov	 QWORD PTR [rdx+8], rax
$LN11@construct:

; 903  : _VARIADIC_EXPAND_0X(_WRAP_ALLOC_CONSTRUCT, , , , )

  00013	f3 c3		 fatret	 0
??$construct@U_Container_proxy@std@@U12@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QEAAXPEAU_Container_proxy@1@$$QEAU21@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::construct<std::_Container_proxy,std::_Container_proxy>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$_Allocate@U_Container_proxy@std@@@std@@YAPEAU_Container_proxy@0@_KPEAU10@@Z
_TEXT	SEGMENT
_Count$ = 48
??$_Allocate@U_Container_proxy@std@@@std@@YAPEAU_Container_proxy@0@_KPEAU10@@Z PROC ; std::_Allocate<std::_Container_proxy>, COMDAT

; 22   : 	{	// allocate storage for _Count elements of type _Ty

$LN14:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 23   : 	void *_Ptr = 0;
; 24   : 
; 25   : 	if (_Count == 0)
; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  00004	48 b8 ff ff ff
	ff ff ff ff 0f	 mov	 rax, 1152921504606846975 ; 0fffffffffffffffH
  0000e	48 3b c8	 cmp	 rcx, rax
  00011	77 13		 ja	 SHORT $LN12@Allocate
  00013	48 c1 e1 04	 shl	 rcx, 4
  00017	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  0001c	48 85 c0	 test	 rax, rax
  0001f	74 05		 je	 SHORT $LN12@Allocate

; 30   : 
; 31   : 	return ((_Ty *)_Ptr);
; 32   : 	}

  00021	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00025	c3		 ret	 0
$LN12@Allocate:

; 29   : 		_Xbad_alloc();	// report no memory

  00026	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
  0002b	cc		 int	 3
$LN11@Allocate:
??$_Allocate@U_Container_proxy@std@@@std@@YAPEAU_Container_proxy@0@_KPEAU10@@Z ENDP ; std::_Allocate<std::_Container_proxy>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xrefwrap
;	COMDAT ??0?$reference_wrapper@PEAVThread@@@std@@QEAA@AEAPEAVThread@@@Z
_TEXT	SEGMENT
this$ = 8
_Val$ = 16
??0?$reference_wrapper@PEAVThread@@@std@@QEAA@AEAPEAVThread@@@Z PROC ; std::reference_wrapper<Thread * __ptr64>::reference_wrapper<Thread * __ptr64>, COMDAT

; 346  : 		{	// construct

  00000	48 89 11	 mov	 QWORD PTR [rcx], rdx

; 865  : 		}

  00003	48 8b c1	 mov	 rax, rcx
  00006	c3		 ret	 0
??0?$reference_wrapper@PEAVThread@@@std@@QEAA@AEAPEAVThread@@@Z ENDP ; std::reference_wrapper<Thread * __ptr64>::reference_wrapper<Thread * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xrefwrap
;	COMDAT ??B?$reference_wrapper@PEAVThread@@@std@@QEBAAEAPEAVThread@@XZ
_TEXT	SEGMENT
this$ = 8
??B?$reference_wrapper@PEAVThread@@@std@@QEBAAEAPEAVThread@@XZ PROC ; std::reference_wrapper<Thread * __ptr64>::operator Thread * __ptr64 & __ptr64, COMDAT

; 869  : 		return (this->_Get());

  00000	48 8b 01	 mov	 rax, QWORD PTR [rcx]

; 870  : 		}

  00003	c3		 ret	 0
??B?$reference_wrapper@PEAVThread@@@std@@QEBAAEAPEAVThread@@XZ ENDP ; std::reference_wrapper<Thread * __ptr64>::operator Thread * __ptr64 & __ptr64
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xrefwrap
;	COMDAT ??0?$_Refwrap_impl@PEAVThread@@@std@@QEAA@AEAPEAVThread@@@Z
_TEXT	SEGMENT
this$ = 8
_Val$ = 16
??0?$_Refwrap_impl@PEAVThread@@@std@@QEAA@AEAPEAVThread@@@Z PROC ; std::_Refwrap_impl<Thread * __ptr64>::_Refwrap_impl<Thread * __ptr64>, COMDAT

; 346  : 		{	// construct

  00000	48 89 11	 mov	 QWORD PTR [rcx], rdx

; 720  : 		}

  00003	48 8b c1	 mov	 rax, rcx
  00006	c3		 ret	 0
??0?$_Refwrap_impl@PEAVThread@@@std@@QEAA@AEAPEAVThread@@@Z ENDP ; std::_Refwrap_impl<Thread * __ptr64>::_Refwrap_impl<Thread * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xrefwrap
;	COMDAT ?_Get@?$_Call_wrapper_base@U?$_Callable_obj@PEAVThread@@$00@std@@@std@@QEBAAEAPEAVThread@@XZ
_TEXT	SEGMENT
this$ = 8
?_Get@?$_Call_wrapper_base@U?$_Callable_obj@PEAVThread@@$00@std@@@std@@QEBAAEAPEAVThread@@XZ PROC ; std::_Call_wrapper_base<std::_Callable_obj<Thread * __ptr64,1> >::_Get, COMDAT

; 567  : 		return (_Callee._Get());

  00000	48 8b 01	 mov	 rax, QWORD PTR [rcx]

; 568  : 		}

  00003	c3		 ret	 0
?_Get@?$_Call_wrapper_base@U?$_Callable_obj@PEAVThread@@$00@std@@@std@@QEBAAEAPEAVThread@@XZ ENDP ; std::_Call_wrapper_base<std::_Callable_obj<Thread * __ptr64,1> >::_Get
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xrefwrap
;	COMDAT ??0?$_Call_wrapper@U?$_Callable_obj@PEAVThread@@$00@std@@$0A@@std@@QEAA@AEAPEAVThread@@@Z
_TEXT	SEGMENT
this$ = 8
_Val$ = 16
??0?$_Call_wrapper@U?$_Callable_obj@PEAVThread@@$00@std@@$0A@@std@@QEAA@AEAPEAVThread@@@Z PROC ; std::_Call_wrapper<std::_Callable_obj<Thread * __ptr64,1>,0>::_Call_wrapper<std::_Callable_obj<Thread * __ptr64,1>,0>, COMDAT

; 346  : 		{	// construct

  00000	48 89 11	 mov	 QWORD PTR [rcx], rdx

; 589  : 		}

  00003	48 8b c1	 mov	 rax, rcx
  00006	c3		 ret	 0
??0?$_Call_wrapper@U?$_Callable_obj@PEAVThread@@$00@std@@$0A@@std@@QEAA@AEAPEAVThread@@@Z ENDP ; std::_Call_wrapper<std::_Callable_obj<Thread * __ptr64,1>,0>::_Call_wrapper<std::_Callable_obj<Thread * __ptr64,1>,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xrefwrap
;	COMDAT ?_Get@?$_Callable_base@PEAVThread@@$00@std@@QEBAAEAPEAVThread@@XZ
_TEXT	SEGMENT
this$ = 8
?_Get@?$_Callable_base@PEAVThread@@$00@std@@QEBAAEAPEAVThread@@XZ PROC ; std::_Callable_base<Thread * __ptr64,1>::_Get, COMDAT

; 351  : 		return (*_Ptr);

  00000	48 8b 01	 mov	 rax, QWORD PTR [rcx]

; 352  : 		}

  00003	c3		 ret	 0
?_Get@?$_Callable_base@PEAVThread@@$00@std@@QEBAAEAPEAVThread@@XZ ENDP ; std::_Callable_base<Thread * __ptr64,1>::_Get
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xrefwrap
;	COMDAT ??0?$_Call_wrapper_base@U?$_Callable_obj@PEAVThread@@$00@std@@@std@@QEAA@AEAPEAVThread@@@Z
_TEXT	SEGMENT
this$ = 8
_Val$ = 16
??0?$_Call_wrapper_base@U?$_Callable_obj@PEAVThread@@$00@std@@@std@@QEAA@AEAPEAVThread@@@Z PROC ; std::_Call_wrapper_base<std::_Callable_obj<Thread * __ptr64,1> >::_Call_wrapper_base<std::_Callable_obj<Thread * __ptr64,1> >, COMDAT

; 346  : 		{	// construct

  00000	48 89 11	 mov	 QWORD PTR [rcx], rdx

; 558  : 		}

  00003	48 8b c1	 mov	 rax, rcx
  00006	c3		 ret	 0
??0?$_Call_wrapper_base@U?$_Callable_obj@PEAVThread@@$00@std@@@std@@QEAA@AEAPEAVThread@@@Z ENDP ; std::_Call_wrapper_base<std::_Callable_obj<Thread * __ptr64,1> >::_Call_wrapper_base<std::_Callable_obj<Thread * __ptr64,1> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\type_traits
;	COMDAT ??$forward@P6AXPEAVThread@@@Z@std@@YA$$QEAP6AXPEAVThread@@@ZAEAP6AX0@Z@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@P6AXPEAVThread@@@Z@std@@YA$$QEAP6AXPEAVThread@@@ZAEAP6AX0@Z@Z PROC ; std::forward<void (__cdecl*)(Thread * __ptr64)>, COMDAT

; 1776 : 	return (static_cast<_Ty&&>(_Arg));

  00000	48 8b c1	 mov	 rax, rcx

; 1777 : 	}

  00003	c3		 ret	 0
??$forward@P6AXPEAVThread@@@Z@std@@YA$$QEAP6AXPEAVThread@@@ZAEAP6AX0@Z@Z ENDP ; std::forward<void (__cdecl*)(Thread * __ptr64)>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\type_traits
;	COMDAT ??$_Decay_copy@P6AXPEAVThread@@@Z@std@@YAP6AXPEAVThread@@@Z$$QEAP6AX0@Z@Z
_TEXT	SEGMENT
_Arg$ = 8
??$_Decay_copy@P6AXPEAVThread@@@Z@std@@YAP6AXPEAVThread@@@Z$$QEAP6AX0@Z@Z PROC ; std::_Decay_copy<void (__cdecl*)(Thread * __ptr64)>, COMDAT

; 1816 : 	return (_STD forward<_Ty>(_Arg));

  00000	48 8b 01	 mov	 rax, QWORD PTR [rcx]

; 1817 : 	}

  00003	c3		 ret	 0
??$_Decay_copy@P6AXPEAVThread@@@Z@std@@YAP6AXPEAVThread@@@Z$$QEAP6AX0@Z@Z ENDP ; std::_Decay_copy<void (__cdecl*)(Thread * __ptr64)>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\type_traits
;	COMDAT ??$forward@V?$reference_wrapper@PEAVThread@@@std@@@std@@YA$$QEAV?$reference_wrapper@PEAVThread@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@V?$reference_wrapper@PEAVThread@@@std@@@std@@YA$$QEAV?$reference_wrapper@PEAVThread@@@0@AEAV10@@Z PROC ; std::forward<std::reference_wrapper<Thread * __ptr64> >, COMDAT

; 1776 : 	return (static_cast<_Ty&&>(_Arg));

  00000	48 8b c1	 mov	 rax, rcx

; 1777 : 	}

  00003	c3		 ret	 0
??$forward@V?$reference_wrapper@PEAVThread@@@std@@@std@@YA$$QEAV?$reference_wrapper@PEAVThread@@@0@AEAV10@@Z ENDP ; std::forward<std::reference_wrapper<Thread * __ptr64> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\functional
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xrefwrap
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\functional
;	COMDAT ??$bind@XPEAVThread@@V?$reference_wrapper@PEAVThread@@@std@@@std@@YA?AV?$_Bind@$00XQ6AXPEAVThread@@@ZV?$reference_wrapper@PEAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@0@P6AXPEAVThread@@@Z$$QEAV?$reference_wrapper@PEAVThread@@@0@@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 8
_Pfx$ = 16
_Vx0$ = 24
??$bind@XPEAVThread@@V?$reference_wrapper@PEAVThread@@@std@@@std@@YA?AV?$_Bind@$00XQ6AXPEAVThread@@@ZV?$reference_wrapper@PEAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@0@P6AXPEAVThread@@@Z$$QEAV?$reference_wrapper@PEAVThread@@@0@@Z PROC ; std::bind<void,Thread * __ptr64,std::reference_wrapper<Thread * __ptr64> >, COMDAT

; 1152 : _VARIADIC_EXPAND_0X(_CLASS_BIND, , , , )

  00000	48 89 11	 mov	 QWORD PTR [rcx], rdx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xrefwrap

; 346  : 		{	// construct

  00003	49 8b 00	 mov	 rax, QWORD PTR [r8]
  00006	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\functional

; 1387 : _VARIADIC_EXPAND_0X_0X(_BIND_IMPLICIT1)

  0000a	48 8b c1	 mov	 rax, rcx
  0000d	c3		 ret	 0
??$bind@XPEAVThread@@V?$reference_wrapper@PEAVThread@@@std@@@std@@YA?AV?$_Bind@$00XQ6AXPEAVThread@@@ZV?$reference_wrapper@PEAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@0@P6AXPEAVThread@@@Z$$QEAV?$reference_wrapper@PEAVThread@@@0@@Z ENDP ; std::bind<void,Thread * __ptr64,std::reference_wrapper<Thread * __ptr64> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\functional
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xrefwrap
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
;	COMDAT ??$_Launch@V?$_Bind@$00XQ6AXPEAVThread@@@ZV?$reference_wrapper@PEAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@std@@@std@@YAXPEAU_Thrd_imp_t@@$$QEAV?$_Bind@$00XQ6AXPEAVThread@@@ZV?$reference_wrapper@PEAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@0@@Z
_TEXT	SEGMENT
$T1 = 32
_Launcher$ = 40
_Thr$ = 112
_Tg$ = 120
??$_Launch@V?$_Bind@$00XQ6AXPEAVThread@@@ZV?$reference_wrapper@PEAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@std@@@std@@YAXPEAU_Thrd_imp_t@@$$QEAV?$_Bind@$00XQ6AXPEAVThread@@@ZV?$reference_wrapper@PEAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@0@@Z PROC ; std::_Launch<std::_Bind<1,void,void (__cdecl*const)(Thread * __ptr64),std::reference_wrapper<Thread * __ptr64>,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil> >, COMDAT

; 204  : 	{	// launch a new thread

$LN55:
  00000	40 57		 push	 rdi
  00002	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  00006	48 c7 44 24 20
	fe ff ff ff	 mov	 QWORD PTR $T1[rsp], -2
  0000f	48 89 5c 24 70	 mov	 QWORD PTR [rsp+112], rbx
  00014	48 8b da	 mov	 rbx, rdx
  00017	48 8b f9	 mov	 rdi, rcx

; 182  : 		{	// construct from target

  0001a	48 8d 4c 24 28	 lea	 rcx, QWORD PTR _Launcher$[rsp]
  0001f	e8 00 00 00 00	 call	 ??0_Pad@std@@QEAA@XZ	; std::_Pad::_Pad
  00024	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7?$_LaunchPad@V?$_Bind@$00XQ6AXPEAVThread@@@ZV?$reference_wrapper@PEAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@std@@@std@@6B@
  0002b	48 89 44 24 28	 mov	 QWORD PTR _Launcher$[rsp], rax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\functional

; 1152 : _VARIADIC_EXPAND_0X(_CLASS_BIND, , , , )

  00030	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00033	48 89 44 24 48	 mov	 QWORD PTR _Launcher$[rsp+32], rax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xrefwrap

; 346  : 		{	// construct

  00038	48 8b 43 08	 mov	 rax, QWORD PTR [rbx+8]
  0003c	48 89 44 24 50	 mov	 QWORD PTR _Launcher$[rsp+40], rax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 206  : 	_Launcher._Launch(_Thr);

  00041	48 8b d7	 mov	 rdx, rdi
  00044	48 8d 4c 24 28	 lea	 rcx, QWORD PTR _Launcher$[rsp]
  00049	e8 00 00 00 00	 call	 ?_Launch@_Pad@std@@QEAAXPEAU_Thrd_imp_t@@@Z ; std::_Pad::_Launch
  0004e	90		 npad	 1
  0004f	48 8d 4c 24 28	 lea	 rcx, QWORD PTR _Launcher$[rsp]
  00054	e8 00 00 00 00	 call	 ??1_Pad@std@@QEAA@XZ	; std::_Pad::~_Pad

; 207  : 	}

  00059	48 8b 5c 24 70	 mov	 rbx, QWORD PTR [rsp+112]
  0005e	48 83 c4 60	 add	 rsp, 96			; 00000060H
  00062	5f		 pop	 rdi
  00063	c3		 ret	 0
??$_Launch@V?$_Bind@$00XQ6AXPEAVThread@@@ZV?$reference_wrapper@PEAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@std@@@std@@YAXPEAU_Thrd_imp_t@@$$QEAV?$_Bind@$00XQ6AXPEAVThread@@@ZV?$reference_wrapper@PEAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@0@@Z ENDP ; std::_Launch<std::_Bind<1,void,void (__cdecl*const)(Thread * __ptr64),std::reference_wrapper<Thread * __ptr64>,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil> >
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
_Launcher$ = 40
_Thr$ = 112
_Tg$ = 120
?dtor$0@?0???$_Launch@V?$_Bind@$00XQ6AXPEAVThread@@@ZV?$reference_wrapper@PEAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@std@@@std@@YAXPEAU_Thrd_imp_t@@$$QEAV?$_Bind@$00XQ6AXPEAVThread@@@ZV?$reference_wrapper@PEAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@0@@Z@4HA PROC ; `std::_Launch<std::_Bind<1,void,void (__cdecl*const)(Thread * __ptr64),std::reference_wrapper<Thread * __ptr64>,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil> >'::`1'::dtor$0
  00000	48 8d 8a 28 00
	00 00		 lea	 rcx, QWORD PTR _Launcher$[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1?$_LaunchPad@V?$_Bind@$00XQ6AXPEAVThread@@@ZV?$reference_wrapper@PEAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@std@@@std@@QEAA@XZ
?dtor$0@?0???$_Launch@V?$_Bind@$00XQ6AXPEAVThread@@@ZV?$reference_wrapper@PEAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@std@@@std@@YAXPEAU_Thrd_imp_t@@$$QEAV?$_Bind@$00XQ6AXPEAVThread@@@ZV?$reference_wrapper@PEAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@0@@Z@4HA ENDP ; `std::_Launch<std::_Bind<1,void,void (__cdecl*const)(Thread * __ptr64),std::reference_wrapper<Thread * __ptr64>,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\chrono
;	COMDAT ??$?G_JU?$ratio@$00$0JIJGIA@@std@@_JU01@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@01@AEBV201@0@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 8
_Left$ = 16
_Right$ = 24
??$?G_JU?$ratio@$00$0JIJGIA@@std@@_JU01@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@01@AEBV201@0@Z PROC ; std::chrono::operator-<__int64,std::ratio<1,10000000>,__int64,std::ratio<1,10000000> >, COMDAT

; 174  : 		_MyRep -= _Right._MyRep;

  00000	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  00003	49 2b 00	 sub	 rax, QWORD PTR [r8]

; 365  : 	typedef typename common_type<
; 366  : 		duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _CD;
; 367  : 	return (_CD(_Left) -= _Right);

  00006	48 89 01	 mov	 QWORD PTR [rcx], rax
  00009	48 8b c1	 mov	 rax, rcx

; 368  : 	}

  0000c	c3		 ret	 0
??$?G_JU?$ratio@$00$0JIJGIA@@std@@_JU01@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@01@AEBV201@0@Z ENDP ; std::chrono::operator-<__int64,std::ratio<1,10000000>,__int64,std::ratio<1,10000000> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\chrono
;	COMDAT ??$?0_J@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEAA@AEB_JPEAPEAX@Z
_TEXT	SEGMENT
this$ = 8
_Val$ = 16
__formal$dead$ = 24
??$?0_J@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEAA@AEB_JPEAPEAX@Z PROC ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::duration<__int64,std::ratio<1,1000000000> ><__int64>, COMDAT

; 105  : 		{	// construct from representation

  00000	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  00003	48 89 01	 mov	 QWORD PTR [rcx], rax

; 106  : 		static_assert(_Is_ratio<_Period>::value,
; 107  : 			"period not an instance of std::ratio");
; 108  : 		static_assert(0 < _Period::num,
; 109  : 			"duration negative or zero");
; 110  : 		}

  00006	48 8b c1	 mov	 rax, rcx
  00009	c3		 ret	 0
??$?0_J@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEAA@AEB_JPEAPEAX@Z ENDP ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::duration<__int64,std::ratio<1,1000000000> ><__int64>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@PEAV?$shared_ptr@VChunkBase@@@std@@@?$allocator_traits@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$shared_ptr@VChunkBase@@@std@@@1@PEAPEAV?$shared_ptr@VChunkBase@@@1@@Z
_TEXT	SEGMENT
_Al$dead$ = 8
_Ptr$dead$ = 16
??$destroy@PEAV?$shared_ptr@VChunkBase@@@std@@@?$allocator_traits@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$shared_ptr@VChunkBase@@@std@@@1@PEAPEAV?$shared_ptr@VChunkBase@@@1@@Z PROC ; std::allocator_traits<std::allocator<std::shared_ptr<ChunkBase> > >::destroy<std::shared_ptr<ChunkBase> * __ptr64>, COMDAT

; 756  : 		{	// destroy object at _Ptr
; 757  : 		_Al.destroy(_Ptr);
; 758  : 		}

  00000	c2 00 00	 ret	 0
??$destroy@PEAV?$shared_ptr@VChunkBase@@@std@@@?$allocator_traits@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$shared_ptr@VChunkBase@@@std@@@1@PEAPEAV?$shared_ptr@VChunkBase@@@1@@Z ENDP ; std::allocator_traits<std::allocator<std::shared_ptr<ChunkBase> > >::destroy<std::shared_ptr<ChunkBase> * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@U_Container_proxy@std@@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAEAV?$allocator@U_Container_proxy@std@@@1@PEAU_Container_proxy@1@@Z
_TEXT	SEGMENT
_Al$dead$ = 8
_Ptr$dead$ = 16
??$destroy@U_Container_proxy@std@@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAEAV?$allocator@U_Container_proxy@std@@@1@PEAU_Container_proxy@1@@Z PROC ; std::allocator_traits<std::allocator<std::_Container_proxy> >::destroy<std::_Container_proxy>, COMDAT

; 756  : 		{	// destroy object at _Ptr
; 757  : 		_Al.destroy(_Ptr);
; 758  : 		}

  00000	c2 00 00	 ret	 0
??$destroy@U_Container_proxy@std@@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAEAV?$allocator@U_Container_proxy@std@@@1@PEAU_Container_proxy@1@@Z ENDP ; std::allocator_traits<std::allocator<std::_Container_proxy> >::destroy<std::_Container_proxy>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\type_traits
;	COMDAT ??$forward@U_Container_proxy@std@@@std@@YA$$QEAU_Container_proxy@0@AEAU10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@U_Container_proxy@std@@@std@@YA$$QEAU_Container_proxy@0@AEAU10@@Z PROC ; std::forward<std::_Container_proxy>, COMDAT

; 1776 : 	return (static_cast<_Ty&&>(_Arg));

  00000	48 8b c1	 mov	 rax, rcx

; 1777 : 	}

  00003	c3		 ret	 0
??$forward@U_Container_proxy@std@@@std@@YA$$QEAU_Container_proxy@0@AEAU10@@Z ENDP ; std::forward<std::_Container_proxy>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@U_Container_proxy@std@@U12@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAEAV?$allocator@U_Container_proxy@std@@@1@PEAU_Container_proxy@1@$$QEAU31@@Z
_TEXT	SEGMENT
_Al$dead$ = 8
_Ptr$ = 16
_V0$ = 24
??$construct@U_Container_proxy@std@@U12@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAEAV?$allocator@U_Container_proxy@std@@@1@PEAU_Container_proxy@1@$$QEAU31@@Z PROC ; std::allocator_traits<std::allocator<std::_Container_proxy> >::construct<std::_Container_proxy,std::_Container_proxy>, COMDAT

; 617  : _VARIADIC_EXPAND_0X(_ALLOC_MEMBER_CONSTRUCT, , , , )

  00000	48 85 d2	 test	 rdx, rdx
  00003	74 0e		 je	 SHORT $LN7@construct
  00005	49 8b 00	 mov	 rax, QWORD PTR [r8]
  00008	48 89 02	 mov	 QWORD PTR [rdx], rax
  0000b	49 8b 40 08	 mov	 rax, QWORD PTR [r8+8]
  0000f	48 89 42 08	 mov	 QWORD PTR [rdx+8], rax
$LN7@construct:

; 751  : _VARIADIC_EXPAND_0X(_ALLOC_TRAITS_SPECIAL_CONSTRUCT, , , , )

  00013	f3 c3		 fatret	 0
??$construct@U_Container_proxy@std@@U12@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAEAV?$allocator@U_Container_proxy@std@@@1@PEAU_Container_proxy@1@$$QEAU31@@Z ENDP ; std::allocator_traits<std::allocator<std::_Container_proxy> >::construct<std::_Container_proxy,std::_Container_proxy>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xrefwrap
;	COMDAT ??$?0AEAPEAVThread@@@?$_Callable_obj@PEAVThread@@$00@std@@QEAA@AEAPEAVThread@@@Z
_TEXT	SEGMENT
this$ = 8
_Val$ = 16
??$?0AEAPEAVThread@@@?$_Callable_obj@PEAVThread@@$00@std@@QEAA@AEAPEAVThread@@@Z PROC ; std::_Callable_obj<Thread * __ptr64,1>::_Callable_obj<Thread * __ptr64,1><Thread * __ptr64 & __ptr64>, COMDAT

; 346  : 		{	// construct

  00000	48 89 11	 mov	 QWORD PTR [rcx], rdx

; 416  : 		}

  00003	48 8b c1	 mov	 rax, rcx
  00006	c3		 ret	 0
??$?0AEAPEAVThread@@@?$_Callable_obj@PEAVThread@@$00@std@@QEAA@AEAPEAVThread@@@Z ENDP ; std::_Callable_obj<Thread * __ptr64,1>::_Callable_obj<Thread * __ptr64,1><Thread * __ptr64 & __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1?$_LaunchPad@V?$_Bind@$00XQ6AXPEAVThread@@@ZV?$reference_wrapper@PEAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$_LaunchPad@V?$_Bind@$00XQ6AXPEAVThread@@@ZV?$reference_wrapper@PEAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@std@@@std@@QEAA@XZ PROC ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(Thread * __ptr64),std::reference_wrapper<Thread * __ptr64>,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil> >::~_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(Thread * __ptr64),std::reference_wrapper<Thread * __ptr64>,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil> >, COMDAT
  00000	e9 00 00 00 00	 jmp	 ??1_Pad@std@@QEAA@XZ	; std::_Pad::~_Pad
??1?$_LaunchPad@V?$_Bind@$00XQ6AXPEAVThread@@@ZV?$reference_wrapper@PEAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@std@@@std@@QEAA@XZ ENDP ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(Thread * __ptr64),std::reference_wrapper<Thread * __ptr64>,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil> >::~_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(Thread * __ptr64),std::reference_wrapper<Thread * __ptr64>,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\chrono
;	COMDAT ??Z?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@chrono@std@@QEAAAEAV012@AEBV012@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
??Z?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@chrono@std@@QEAAAEAV012@AEBV012@@Z PROC ; std::chrono::duration<__int64,std::ratio<1,10000000> >::operator-=, COMDAT

; 174  : 		_MyRep -= _Right._MyRep;

  00000	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  00003	48 29 01	 sub	 QWORD PTR [rcx], rax

; 175  : 		return (*this);

  00006	48 8b c1	 mov	 rax, rcx

; 176  : 		}

  00009	c3		 ret	 0
??Z?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@chrono@std@@QEAAAEAV012@AEBV012@@Z ENDP ; std::chrono::duration<__int64,std::ratio<1,10000000> >::operator-=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xrefwrap
;	COMDAT ??0?$_Callable_base@PEAVThread@@$00@std@@QEAA@AEAPEAVThread@@@Z
_TEXT	SEGMENT
this$ = 8
_Val$ = 16
??0?$_Callable_base@PEAVThread@@$00@std@@QEAA@AEAPEAVThread@@@Z PROC ; std::_Callable_base<Thread * __ptr64,1>::_Callable_base<Thread * __ptr64,1>, COMDAT

; 346  : 		{	// construct

  00000	48 89 11	 mov	 QWORD PTR [rcx], rdx

; 347  : 		}

  00003	48 8b c1	 mov	 rax, rcx
  00006	c3		 ret	 0
??0?$_Callable_base@PEAVThread@@$00@std@@QEAA@AEAPEAVThread@@@Z ENDP ; std::_Callable_base<Thread * __ptr64,1>::_Callable_base<Thread * __ptr64,1>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\functional
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xrefwrap
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\functional
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
;	COMDAT ?_Go@?$_LaunchPad@V?$_Bind@$00XQ6AXPEAVThread@@@ZV?$reference_wrapper@PEAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@std@@@std@@UEAAIXZ
_TEXT	SEGMENT
this$ = 48
?_Go@?$_LaunchPad@V?$_Bind@$00XQ6AXPEAVThread@@@ZV?$reference_wrapper@PEAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@std@@@std@@UEAAIXZ PROC ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(Thread * __ptr64),std::reference_wrapper<Thread * __ptr64>,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil> >::_Go, COMDAT

; 186  : 		{	// run the thread function object

$LN62:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\functional

; 1152 : _VARIADIC_EXPAND_0X(_CLASS_BIND, , , , )

  0000a	48 8b 79 20	 mov	 rdi, QWORD PTR [rcx+32]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xrefwrap

; 346  : 		{	// construct

  0000e	48 8b 59 28	 mov	 rbx, QWORD PTR [rcx+40]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 194  : 		_Ln->_Release();

  00012	e8 00 00 00 00	 call	 ?_Release@_Pad@std@@QEAAXXZ ; std::_Pad::_Release
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\functional

; 1152 : _VARIADIC_EXPAND_0X(_CLASS_BIND, , , , )

  00017	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  0001a	ff d7		 call	 rdi
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 188  : 		}

  0001c	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00021	33 c0		 xor	 eax, eax
  00023	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00027	5f		 pop	 rdi
  00028	c3		 ret	 0
?_Go@?$_LaunchPad@V?$_Bind@$00XQ6AXPEAVThread@@@ZV?$reference_wrapper@PEAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@std@@@std@@UEAAIXZ ENDP ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(Thread * __ptr64),std::reference_wrapper<Thread * __ptr64>,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil> >::_Go
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\functional
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xrefwrap
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\functional
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
;	COMDAT ?_Run@?$_LaunchPad@V?$_Bind@$00XQ6AXPEAVThread@@@ZV?$reference_wrapper@PEAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@std@@@std@@CAIPEAV12@@Z
_TEXT	SEGMENT
_Ln$ = 48
?_Run@?$_LaunchPad@V?$_Bind@$00XQ6AXPEAVThread@@@ZV?$reference_wrapper@PEAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@std@@@std@@CAIPEAV12@@Z PROC ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(Thread * __ptr64),std::reference_wrapper<Thread * __ptr64>,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil> >::_Run, COMDAT

; 192  : 		{	// make local copy of function object and call it

$LN60:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\functional

; 1152 : _VARIADIC_EXPAND_0X(_CLASS_BIND, , , , )

  0000a	48 8b 79 20	 mov	 rdi, QWORD PTR [rcx+32]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xrefwrap

; 346  : 		{	// construct

  0000e	48 8b 59 28	 mov	 rbx, QWORD PTR [rcx+40]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 194  : 		_Ln->_Release();

  00012	e8 00 00 00 00	 call	 ?_Release@_Pad@std@@QEAAXXZ ; std::_Pad::_Release
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\functional

; 1152 : _VARIADIC_EXPAND_0X(_CLASS_BIND, , , , )

  00017	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  0001a	ff d7		 call	 rdi
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 197  : 		}

  0001c	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00021	33 c0		 xor	 eax, eax
  00023	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00027	5f		 pop	 rdi
  00028	c3		 ret	 0
?_Run@?$_LaunchPad@V?$_Bind@$00XQ6AXPEAVThread@@@ZV?$reference_wrapper@PEAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@std@@@std@@CAIPEAV12@@Z ENDP ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(Thread * __ptr64),std::reference_wrapper<Thread * __ptr64>,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil> >::_Run
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\functional
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xrefwrap
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\functional
;	COMDAT ??0?$_Bind@$00XQ6AXPEAVThread@@@ZV?$reference_wrapper@PEAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@std@@QEAA@$$QEAV01@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
??0?$_Bind@$00XQ6AXPEAVThread@@@ZV?$reference_wrapper@PEAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@std@@QEAA@$$QEAV01@@Z PROC ; std::_Bind<1,void,void (__cdecl*const)(Thread * __ptr64),std::reference_wrapper<Thread * __ptr64>,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::_Bind<1,void,void (__cdecl*const)(Thread * __ptr64),std::reference_wrapper<Thread * __ptr64>,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>, COMDAT

; 1152 : _VARIADIC_EXPAND_0X(_CLASS_BIND, , , , )

  00000	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  00003	48 89 01	 mov	 QWORD PTR [rcx], rax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xrefwrap

; 346  : 		{	// construct

  00006	48 8b 42 08	 mov	 rax, QWORD PTR [rdx+8]
  0000a	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\functional

; 1152 : _VARIADIC_EXPAND_0X(_CLASS_BIND, , , , )

  0000e	48 8b c1	 mov	 rax, rcx
  00011	c3		 ret	 0
??0?$_Bind@$00XQ6AXPEAVThread@@@ZV?$reference_wrapper@PEAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@std@@QEAA@$$QEAV01@@Z ENDP ; std::_Bind<1,void,void (__cdecl*const)(Thread * __ptr64),std::reference_wrapper<Thread * __ptr64>,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::_Bind<1,void,void (__cdecl*const)(Thread * __ptr64),std::reference_wrapper<Thread * __ptr64>,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\functional
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xrefwrap
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\functional
;	COMDAT ??R?$_Bind@$00XQ6AXPEAVThread@@@ZV?$reference_wrapper@PEAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
??R?$_Bind@$00XQ6AXPEAVThread@@@ZV?$reference_wrapper@PEAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@std@@QEAAXXZ PROC ; std::_Bind<1,void,void (__cdecl*const)(Thread * __ptr64),std::reference_wrapper<Thread * __ptr64>,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::operator(), COMDAT

; 1152 : _VARIADIC_EXPAND_0X(_CLASS_BIND, , , , )

  00000	48 8b c1	 mov	 rax, rcx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xrefwrap

; 351  : 		return (*_Ptr);

  00003	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\functional

; 1152 : _VARIADIC_EXPAND_0X(_CLASS_BIND, , , , )

  00007	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0000a	48 ff 20	 rex_jmp QWORD PTR [rax]
??R?$_Bind@$00XQ6AXPEAVThread@@@ZV?$reference_wrapper@PEAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@std@@QEAAXXZ ENDP ; std::_Bind<1,void,void (__cdecl*const)(Thread * __ptr64),std::reference_wrapper<Thread * __ptr64>,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\tuple
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xrefwrap
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\tuple
;	COMDAT ??0?$tuple@V?$reference_wrapper@PEAVThread@@@std@@U_Nil@2@U32@U32@U32@U32@U32@U32@@std@@QEAA@$$QEAV01@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
??0?$tuple@V?$reference_wrapper@PEAVThread@@@std@@U_Nil@2@U32@U32@U32@U32@U32@U32@@std@@QEAA@$$QEAV01@@Z PROC ; std::tuple<std::reference_wrapper<Thread * __ptr64>,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::tuple<std::reference_wrapper<Thread * __ptr64>,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>, COMDAT
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xrefwrap

; 346  : 		{	// construct

  00000	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  00003	48 89 01	 mov	 QWORD PTR [rcx], rax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\tuple

; 521  : _VARIADIC_EXPAND_0X(_CLASS_TUPLE, , , , )

  00006	48 8b c1	 mov	 rax, rcx
  00009	c3		 ret	 0
??0?$tuple@V?$reference_wrapper@PEAVThread@@@std@@U_Nil@2@U32@U32@U32@U32@U32@U32@@std@@QEAA@$$QEAV01@@Z ENDP ; std::tuple<std::reference_wrapper<Thread * __ptr64>,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::tuple<std::reference_wrapper<Thread * __ptr64>,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\tuple
;	COMDAT ?_Get_rest@?$tuple@V?$reference_wrapper@PEAVThread@@@std@@U_Nil@2@U32@U32@U32@U32@U32@U32@@std@@QEAAAEAV?$tuple@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_rest@?$tuple@V?$reference_wrapper@PEAVThread@@@std@@U_Nil@2@U32@U32@U32@U32@U32@U32@@std@@QEAAAEAV?$tuple@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@2@XZ PROC ; std::tuple<std::reference_wrapper<Thread * __ptr64>,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::_Get_rest, COMDAT

; 521  : _VARIADIC_EXPAND_0X(_CLASS_TUPLE, , , , )

  00000	48 8b c1	 mov	 rax, rcx
  00003	c3		 ret	 0
?_Get_rest@?$tuple@V?$reference_wrapper@PEAVThread@@@std@@U_Nil@2@U32@U32@U32@U32@U32@U32@@std@@QEAAAEAV?$tuple@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@2@XZ ENDP ; std::tuple<std::reference_wrapper<Thread * __ptr64>,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::_Get_rest
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\functional
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xrefwrap
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\functional
;	COMDAT ??$?0AEAP6AXPEAVThread@@@ZV?$reference_wrapper@PEAVThread@@@std@@@?$_Bind@$00XQ6AXPEAVThread@@@ZV?$reference_wrapper@PEAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@std@@QEAA@AEAP6AXPEAVThread@@@Z$$QEAV?$reference_wrapper@PEAVThread@@@1@@Z
_TEXT	SEGMENT
this$ = 8
_Fx$ = 16
_Vx0$ = 24
??$?0AEAP6AXPEAVThread@@@ZV?$reference_wrapper@PEAVThread@@@std@@@?$_Bind@$00XQ6AXPEAVThread@@@ZV?$reference_wrapper@PEAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@std@@QEAA@AEAP6AXPEAVThread@@@Z$$QEAV?$reference_wrapper@PEAVThread@@@1@@Z PROC ; std::_Bind<1,void,void (__cdecl*const)(Thread * __ptr64),std::reference_wrapper<Thread * __ptr64>,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::_Bind<1,void,void (__cdecl*const)(Thread * __ptr64),std::reference_wrapper<Thread * __ptr64>,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil><void (__cdecl*& __ptr64)(Thread * __ptr64),std::reference_wrapper<Thread * __ptr64> >, COMDAT

; 1152 : _VARIADIC_EXPAND_0X(_CLASS_BIND, , , , )

  00000	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  00003	48 89 01	 mov	 QWORD PTR [rcx], rax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xrefwrap

; 346  : 		{	// construct

  00006	49 8b 00	 mov	 rax, QWORD PTR [r8]
  00009	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\functional

; 1152 : _VARIADIC_EXPAND_0X(_CLASS_BIND, , , , )

  0000d	48 8b c1	 mov	 rax, rcx
  00010	c3		 ret	 0
??$?0AEAP6AXPEAVThread@@@ZV?$reference_wrapper@PEAVThread@@@std@@@?$_Bind@$00XQ6AXPEAVThread@@@ZV?$reference_wrapper@PEAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@std@@QEAA@AEAP6AXPEAVThread@@@Z$$QEAV?$reference_wrapper@PEAVThread@@@1@@Z ENDP ; std::_Bind<1,void,void (__cdecl*const)(Thread * __ptr64),std::reference_wrapper<Thread * __ptr64>,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::_Bind<1,void,void (__cdecl*const)(Thread * __ptr64),std::reference_wrapper<Thread * __ptr64>,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil><void (__cdecl*& __ptr64)(Thread * __ptr64),std::reference_wrapper<Thread * __ptr64> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\type_traits
;	COMDAT ??$forward@V?$_Bind@$00XQ6AXPEAVThread@@@ZV?$reference_wrapper@PEAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@std@@@std@@YA$$QEAV?$_Bind@$00XQ6AXPEAVThread@@@ZV?$reference_wrapper@PEAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@V?$_Bind@$00XQ6AXPEAVThread@@@ZV?$reference_wrapper@PEAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@std@@@std@@YA$$QEAV?$_Bind@$00XQ6AXPEAVThread@@@ZV?$reference_wrapper@PEAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@0@AEAV10@@Z PROC ; std::forward<std::_Bind<1,void,void (__cdecl*const)(Thread * __ptr64),std::reference_wrapper<Thread * __ptr64>,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil> >, COMDAT

; 1776 : 	return (static_cast<_Ty&&>(_Arg));

  00000	48 8b c1	 mov	 rax, rcx

; 1777 : 	}

  00003	c3		 ret	 0
??$forward@V?$_Bind@$00XQ6AXPEAVThread@@@ZV?$reference_wrapper@PEAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@std@@@std@@YA$$QEAV?$_Bind@$00XQ6AXPEAVThread@@@ZV?$reference_wrapper@PEAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@0@AEAV10@@Z ENDP ; std::forward<std::_Bind<1,void,void (__cdecl*const)(Thread * __ptr64),std::reference_wrapper<Thread * __ptr64>,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\functional
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xrefwrap
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xrefwrap
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
;	COMDAT ??$?0V?$_Bind@$00XQ6AXPEAVThread@@@ZV?$reference_wrapper@PEAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@std@@@?$_LaunchPad@V?$_Bind@$00XQ6AXPEAVThread@@@ZV?$reference_wrapper@PEAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@std@@@std@@QEAA@$$QEAV?$_Bind@$00XQ6AXPEAVThread@@@ZV?$reference_wrapper@PEAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@1@@Z
_TEXT	SEGMENT
this$ = 48
_Tgt$ = 56
??$?0V?$_Bind@$00XQ6AXPEAVThread@@@ZV?$reference_wrapper@PEAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@std@@@?$_LaunchPad@V?$_Bind@$00XQ6AXPEAVThread@@@ZV?$reference_wrapper@PEAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@std@@@std@@QEAA@$$QEAV?$_Bind@$00XQ6AXPEAVThread@@@ZV?$reference_wrapper@PEAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@1@@Z PROC ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(Thread * __ptr64),std::reference_wrapper<Thread * __ptr64>,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil> >::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(Thread * __ptr64),std::reference_wrapper<Thread * __ptr64>,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil> ><std::_Bind<1,void,void (__cdecl*const)(Thread * __ptr64),std::reference_wrapper<Thread * __ptr64>,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil> >, COMDAT

; 182  : 		{	// construct from target

$LN49:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b da	 mov	 rbx, rdx
  0000d	48 8b f9	 mov	 rdi, rcx
  00010	e8 00 00 00 00	 call	 ??0_Pad@std@@QEAA@XZ	; std::_Pad::_Pad
  00015	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7?$_LaunchPad@V?$_Bind@$00XQ6AXPEAVThread@@@ZV?$reference_wrapper@PEAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@std@@@std@@6B@
  0001c	48 89 07	 mov	 QWORD PTR [rdi], rax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\functional

; 1152 : _VARIADIC_EXPAND_0X(_CLASS_BIND, , , , )

  0001f	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00022	48 89 47 20	 mov	 QWORD PTR [rdi+32], rax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xrefwrap

; 346  : 		{	// construct

  00026	48 8b 43 08	 mov	 rax, QWORD PTR [rbx+8]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 183  : 		}

  0002a	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xrefwrap

; 346  : 		{	// construct

  0002f	48 89 47 28	 mov	 QWORD PTR [rdi+40], rax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 183  : 		}

  00033	48 8b c7	 mov	 rax, rdi
  00036	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003a	5f		 pop	 rdi
  0003b	c3		 ret	 0
??$?0V?$_Bind@$00XQ6AXPEAVThread@@@ZV?$reference_wrapper@PEAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@std@@@?$_LaunchPad@V?$_Bind@$00XQ6AXPEAVThread@@@ZV?$reference_wrapper@PEAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@std@@@std@@QEAA@$$QEAV?$_Bind@$00XQ6AXPEAVThread@@@ZV?$reference_wrapper@PEAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@1@@Z ENDP ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(Thread * __ptr64),std::reference_wrapper<Thread * __ptr64>,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil> >::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(Thread * __ptr64),std::reference_wrapper<Thread * __ptr64>,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil> ><std::_Bind<1,void,void (__cdecl*const)(Thread * __ptr64),std::reference_wrapper<Thread * __ptr64>,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@PEAV?$shared_ptr@VChunkBase@@@std@@@?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAAXPEAPEAV?$shared_ptr@VChunkBase@@@1@@Z
_TEXT	SEGMENT
this$dead$ = 8
_Ptr$dead$ = 16
??$destroy@PEAV?$shared_ptr@VChunkBase@@@std@@@?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAAXPEAPEAV?$shared_ptr@VChunkBase@@@1@@Z PROC ; std::allocator<std::shared_ptr<ChunkBase> >::destroy<std::shared_ptr<ChunkBase> * __ptr64>, COMDAT

; 622  : 		{	// destroy object at _Ptr
; 623  : 		_Ptr->~_Uty();
; 624  : 		}

  00000	c2 00 00	 ret	 0
??$destroy@PEAV?$shared_ptr@VChunkBase@@@std@@@?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAAXPEAPEAV?$shared_ptr@VChunkBase@@@1@@Z ENDP ; std::allocator<std::shared_ptr<ChunkBase> >::destroy<std::shared_ptr<ChunkBase> * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QEAAXPEAU_Container_proxy@1@@Z
_TEXT	SEGMENT
this$dead$ = 8
_Ptr$dead$ = 16
??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QEAAXPEAU_Container_proxy@1@@Z PROC ; std::allocator<std::_Container_proxy>::destroy<std::_Container_proxy>, COMDAT

; 622  : 		{	// destroy object at _Ptr
; 623  : 		_Ptr->~_Uty();
; 624  : 		}

  00000	c2 00 00	 ret	 0
??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QEAAXPEAU_Container_proxy@1@@Z ENDP ; std::allocator<std::_Container_proxy>::destroy<std::_Container_proxy>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QEAAXPEAU_Container_proxy@1@$$QEAU21@@Z
_TEXT	SEGMENT
this$dead$ = 8
_Ptr$ = 16
_V0$ = 24
??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QEAAXPEAU_Container_proxy@1@$$QEAU21@@Z PROC ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>, COMDAT

; 617  : _VARIADIC_EXPAND_0X(_ALLOC_MEMBER_CONSTRUCT, , , , )

  00000	48 85 d2	 test	 rdx, rdx
  00003	74 0e		 je	 SHORT $LN3@construct
  00005	49 8b 00	 mov	 rax, QWORD PTR [r8]
  00008	48 89 02	 mov	 QWORD PTR [rdx], rax
  0000b	49 8b 40 08	 mov	 rax, QWORD PTR [r8+8]
  0000f	48 89 42 08	 mov	 QWORD PTR [rdx+8], rax
$LN3@construct:
  00013	f3 c3		 fatret	 0
??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QEAAXPEAU_Container_proxy@1@$$QEAU21@@Z ENDP ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\type_traits
;	COMDAT ??$forward@AEAPEAVThread@@@std@@YAAEAPEAVThread@@AEAPEAV1@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEAPEAVThread@@@std@@YAAEAPEAVThread@@AEAPEAV1@@Z PROC ; std::forward<Thread * __ptr64 & __ptr64>, COMDAT

; 1776 : 	return (static_cast<_Ty&&>(_Arg));

  00000	48 8b c1	 mov	 rax, rcx

; 1777 : 	}

  00003	c3		 ret	 0
??$forward@AEAPEAVThread@@@std@@YAAEAPEAVThread@@AEAPEAV1@@Z ENDP ; std::forward<Thread * __ptr64 & __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstddef
;	COMDAT ??$addressof@PEAVThread@@@std@@YAPEAPEAVThread@@AEAPEAV1@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@PEAVThread@@@std@@YAPEAPEAVThread@@AEAPEAV1@@Z PROC ; std::addressof<Thread * __ptr64>, COMDAT

; 86   : 	return (reinterpret_cast<_Ty *>(
; 87   : 		(&const_cast<char&>(
; 88   : 		reinterpret_cast<const volatile char&>(_Val)))));

  00000	48 8b c1	 mov	 rax, rcx

; 89   : 	}

  00003	c3		 ret	 0
??$addressof@PEAVThread@@@std@@YAPEAPEAVThread@@AEAPEAV1@@Z ENDP ; std::addressof<Thread * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\type_traits
;	COMDAT ??$forward@V?$tuple@V?$reference_wrapper@PEAVThread@@@std@@U_Nil@2@U32@U32@U32@U32@U32@U32@@std@@@std@@YA$$QEAV?$tuple@V?$reference_wrapper@PEAVThread@@@std@@U_Nil@2@U32@U32@U32@U32@U32@U32@@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@V?$tuple@V?$reference_wrapper@PEAVThread@@@std@@U_Nil@2@U32@U32@U32@U32@U32@U32@@std@@@std@@YA$$QEAV?$tuple@V?$reference_wrapper@PEAVThread@@@std@@U_Nil@2@U32@U32@U32@U32@U32@U32@@0@AEAV10@@Z PROC ; std::forward<std::tuple<std::reference_wrapper<Thread * __ptr64>,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil> >, COMDAT

; 1776 : 	return (static_cast<_Ty&&>(_Arg));

  00000	48 8b c1	 mov	 rax, rcx

; 1777 : 	}

  00003	c3		 ret	 0
??$forward@V?$tuple@V?$reference_wrapper@PEAVThread@@@std@@U_Nil@2@U32@U32@U32@U32@U32@U32@@std@@@std@@YA$$QEAV?$tuple@V?$reference_wrapper@PEAVThread@@@std@@U_Nil@2@U32@U32@U32@U32@U32@U32@@0@AEAV10@@Z ENDP ; std::forward<std::tuple<std::reference_wrapper<Thread * __ptr64>,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\tuple
;	COMDAT ??$get@$0A@V?$reference_wrapper@PEAVThread@@@std@@@std@@YAAEAV?$reference_wrapper@PEAVThread@@@0@AEAV?$tuple@V?$reference_wrapper@PEAVThread@@@std@@U_Nil@2@U32@U32@U32@U32@U32@U32@@0@@Z
_TEXT	SEGMENT
_Tuple$ = 8
??$get@$0A@V?$reference_wrapper@PEAVThread@@@std@@@std@@YAAEAV?$reference_wrapper@PEAVThread@@@0@AEAV?$tuple@V?$reference_wrapper@PEAVThread@@@std@@U_Nil@2@U32@U32@U32@U32@U32@U32@@0@@Z PROC ; std::get<0,std::reference_wrapper<Thread * __ptr64> >, COMDAT

; 697  : _VARIADIC_EXPAND_0X(_TUPLE_GET, _COMMA, , , )

  00000	48 8b c1	 mov	 rax, rcx
  00003	c3		 ret	 0
??$get@$0A@V?$reference_wrapper@PEAVThread@@@std@@@std@@YAAEAV?$reference_wrapper@PEAVThread@@@0@AEAV?$tuple@V?$reference_wrapper@PEAVThread@@@std@@U_Nil@2@U32@U32@U32@U32@U32@U32@@0@@Z ENDP ; std::get<0,std::reference_wrapper<Thread * __ptr64> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\functional
;	COMDAT ??$_Fixarg@AEAP6AXPEAVThread@@@ZV?$reference_wrapper@PEAVThread@@@std@@V?$tuple@V?$reference_wrapper@PEAVThread@@@std@@U_Nil@2@U32@U32@U32@U32@U32@U32@@3@V?$tuple@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@3@@std@@YAAEAPEAVThread@@AEAP6AXPEAV1@@ZAEAV?$tuple@V?$reference_wrapper@PEAVThread@@@std@@U_Nil@2@U32@U32@U32@U32@U32@U32@@0@AEAV?$tuple@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@0@AEAV?$reference_wrapper@PEAVThread@@@0@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
_Mybargs$dead$ = 16
_Myfargs$dead$ = 24
_Arg$ = 32
??$_Fixarg@AEAP6AXPEAVThread@@@ZV?$reference_wrapper@PEAVThread@@@std@@V?$tuple@V?$reference_wrapper@PEAVThread@@@std@@U_Nil@2@U32@U32@U32@U32@U32@U32@@3@V?$tuple@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@3@@std@@YAAEAPEAVThread@@AEAP6AXPEAV1@@ZAEAV?$tuple@V?$reference_wrapper@PEAVThread@@@std@@U_Nil@2@U32@U32@U32@U32@U32@U32@@0@AEAV?$tuple@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@0@AEAV?$reference_wrapper@PEAVThread@@@0@@Z PROC ; std::_Fixarg<void (__cdecl*& __ptr64)(Thread * __ptr64),std::reference_wrapper<Thread * __ptr64>,std::tuple<std::reference_wrapper<Thread * __ptr64>,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>,std::tuple<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil> >, COMDAT

; 1036 : 	return (_Arg.get());

  00000	49 8b 01	 mov	 rax, QWORD PTR [r9]

; 1037 : 	}

  00003	c3		 ret	 0
??$_Fixarg@AEAP6AXPEAVThread@@@ZV?$reference_wrapper@PEAVThread@@@std@@V?$tuple@V?$reference_wrapper@PEAVThread@@@std@@U_Nil@2@U32@U32@U32@U32@U32@U32@@3@V?$tuple@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@3@@std@@YAAEAPEAVThread@@AEAP6AXPEAV1@@ZAEAV?$tuple@V?$reference_wrapper@PEAVThread@@@std@@U_Nil@2@U32@U32@U32@U32@U32@U32@@0@AEAV?$tuple@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@0@AEAV?$reference_wrapper@PEAVThread@@@0@@Z ENDP ; std::_Fixarg<void (__cdecl*& __ptr64)(Thread * __ptr64),std::reference_wrapper<Thread * __ptr64>,std::tuple<std::reference_wrapper<Thread * __ptr64>,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>,std::tuple<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\tuple
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xrefwrap
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\tuple
;	COMDAT ??$?0V?$reference_wrapper@PEAVThread@@@std@@@?$_Tuple_val@V?$reference_wrapper@PEAVThread@@@std@@@std@@QEAA@$$QEAV?$reference_wrapper@PEAVThread@@@1@@Z
_TEXT	SEGMENT
this$ = 8
_Arg$ = 16
??$?0V?$reference_wrapper@PEAVThread@@@std@@@?$_Tuple_val@V?$reference_wrapper@PEAVThread@@@std@@@std@@QEAA@$$QEAV?$reference_wrapper@PEAVThread@@@1@@Z PROC ; std::_Tuple_val<std::reference_wrapper<Thread * __ptr64> >::_Tuple_val<std::reference_wrapper<Thread * __ptr64> ><std::reference_wrapper<Thread * __ptr64> >, COMDAT
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xrefwrap

; 346  : 		{	// construct

  00000	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  00003	48 89 01	 mov	 QWORD PTR [rcx], rax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\tuple

; 152  : 		}

  00006	48 8b c1	 mov	 rax, rcx
  00009	c3		 ret	 0
??$?0V?$reference_wrapper@PEAVThread@@@std@@@?$_Tuple_val@V?$reference_wrapper@PEAVThread@@@std@@@std@@QEAA@$$QEAV?$reference_wrapper@PEAVThread@@@1@@Z ENDP ; std::_Tuple_val<std::reference_wrapper<Thread * __ptr64> >::_Tuple_val<std::reference_wrapper<Thread * __ptr64> ><std::reference_wrapper<Thread * __ptr64> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xrefwrap
;	COMDAT ?get@?$reference_wrapper@PEAVThread@@@std@@QEBAAEAPEAVThread@@XZ
_TEXT	SEGMENT
this$ = 8
?get@?$reference_wrapper@PEAVThread@@@std@@QEBAAEAPEAVThread@@XZ PROC ; std::reference_wrapper<Thread * __ptr64>::get, COMDAT

; 874  : 		return (this->_Get());

  00000	48 8b 01	 mov	 rax, QWORD PTR [rcx]

; 875  : 		}

  00003	c3		 ret	 0
?get@?$reference_wrapper@PEAVThread@@@std@@QEBAAEAPEAVThread@@XZ ENDP ; std::reference_wrapper<Thread * __ptr64>::get
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\type_traits
;	COMDAT ??$forward@AEAP6AXPEAVThread@@@Z@std@@YAAEAP6AXPEAVThread@@@ZAEAP6AX0@Z@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEAP6AXPEAVThread@@@Z@std@@YAAEAP6AXPEAVThread@@@ZAEAP6AX0@Z@Z PROC ; std::forward<void (__cdecl*& __ptr64)(Thread * __ptr64)>, COMDAT

; 1776 : 	return (static_cast<_Ty&&>(_Arg));

  00000	48 8b c1	 mov	 rax, rcx

; 1777 : 	}

  00003	c3		 ret	 0
??$forward@AEAP6AXPEAVThread@@@Z@std@@YAAEAP6AXPEAVThread@@@ZAEAP6AX0@Z@Z ENDP ; std::forward<void (__cdecl*& __ptr64)(Thread * __ptr64)>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\tuple
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xrefwrap
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\tuple
;	COMDAT ??$?0V?$reference_wrapper@PEAVThread@@@std@@@?$tuple@V?$reference_wrapper@PEAVThread@@@std@@U_Nil@2@U32@U32@U32@U32@U32@U32@@std@@QEAA@$$QEAV?$reference_wrapper@PEAVThread@@@1@PEAPEAX@Z
_TEXT	SEGMENT
this$ = 8
_Arg0$ = 16
__formal$dead$ = 24
??$?0V?$reference_wrapper@PEAVThread@@@std@@@?$tuple@V?$reference_wrapper@PEAVThread@@@std@@U_Nil@2@U32@U32@U32@U32@U32@U32@@std@@QEAA@$$QEAV?$reference_wrapper@PEAVThread@@@1@PEAPEAX@Z PROC ; std::tuple<std::reference_wrapper<Thread * __ptr64>,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::tuple<std::reference_wrapper<Thread * __ptr64>,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil><std::reference_wrapper<Thread * __ptr64> >, COMDAT
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xrefwrap

; 346  : 		{	// construct

  00000	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  00003	48 89 01	 mov	 QWORD PTR [rcx], rax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\tuple

; 521  : _VARIADIC_EXPAND_0X(_CLASS_TUPLE, , , , )

  00006	48 8b c1	 mov	 rax, rcx
  00009	c3		 ret	 0
??$?0V?$reference_wrapper@PEAVThread@@@std@@@?$tuple@V?$reference_wrapper@PEAVThread@@@std@@U_Nil@2@U32@U32@U32@U32@U32@U32@@std@@QEAA@$$QEAV?$reference_wrapper@PEAVThread@@@1@PEAPEAX@Z ENDP ; std::tuple<std::reference_wrapper<Thread * __ptr64>,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::tuple<std::reference_wrapper<Thread * __ptr64>,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil><std::reference_wrapper<Thread * __ptr64> >
_TEXT	ENDS
END
