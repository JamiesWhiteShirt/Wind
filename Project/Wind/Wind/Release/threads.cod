; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.50727.1 

	TITLE	C:\Users\Glenn\Documents\GitHub\Wind\Project\Wind\Wind\threads.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	?stop@GlobalThread@@3_NA			; GlobalThread::stop
PUBLIC	??_R4ChunkDrawThread@@6B@			; ChunkDrawThread::`RTTI Complete Object Locator'
PUBLIC	??_7Thread@@6B@					; Thread::`vftable'
PUBLIC	??_R1A@?0A@EA@ChunkDrawThread@@8		; ChunkDrawThread::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3ChunkDrawThread@@8				; ChunkDrawThread::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2ChunkDrawThread@@8				; ChunkDrawThread::`RTTI Base Class Array'
PUBLIC	??_7?$_LaunchPad@V?$_Bind@$00XQ6AXPAVThread@@@ZV?$reference_wrapper@PAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@std@@@std@@6B@ ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(Thread *),std::reference_wrapper<Thread *>,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil> >::`vftable'
PUBLIC	??_R0?AVChunkDrawThread@@@8			; ChunkDrawThread `RTTI Type Descriptor'
PUBLIC	??_R1A@?0A@EA@Thread@@8				; Thread::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@RenderThread@@8			; RenderThread::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVThread@@@8				; Thread `RTTI Type Descriptor'
PUBLIC	??_R1A@?0A@EA@LimitedThread@@8			; LimitedThread::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3?$_LaunchPad@V?$_Bind@$00XQ6AXPAVThread@@@ZV?$reference_wrapper@PAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@std@@@std@@8 ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(Thread *),std::reference_wrapper<Thread *>,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_7ChunkLoadThread@@6B@			; ChunkLoadThread::`vftable'
PUBLIC	??_7ChunkDrawThread@@6B@			; ChunkDrawThread::`vftable'
PUBLIC	??_R0?AV?$_LaunchPad@V?$_Bind@$00XQ6AXPAVThread@@@ZV?$reference_wrapper@PAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@std@@@std@@@8 ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(Thread *),std::reference_wrapper<Thread *>,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil> > `RTTI Type Descriptor'
PUBLIC	??_7RenderThread@@6B@				; RenderThread::`vftable'
PUBLIC	??_R2RenderThread@@8				; RenderThread::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$_LaunchPad@V?$_Bind@$00XQ6AXPAVThread@@@ZV?$reference_wrapper@PAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@std@@@std@@8 ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(Thread *),std::reference_wrapper<Thread *>,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@ChunkLoadThread@@8		; ChunkLoadThread::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVLimitedThread@@@8			; LimitedThread `RTTI Type Descriptor'
PUBLIC	??_R4ChunkLoadThread@@6B@			; ChunkLoadThread::`RTTI Complete Object Locator'
PUBLIC	??_R4?$_LaunchPad@V?$_Bind@$00XQ6AXPAVThread@@@ZV?$reference_wrapper@PAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@std@@@std@@6B@ ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(Thread *),std::reference_wrapper<Thread *>,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil> >::`RTTI Complete Object Locator'
PUBLIC	??_R2ChunkLoadThread@@8				; ChunkLoadThread::`RTTI Base Class Array'
PUBLIC	??_R2Thread@@8					; Thread::`RTTI Base Class Array'
PUBLIC	??_R4Thread@@6B@				; Thread::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVChunkLoadThread@@@8			; ChunkLoadThread `RTTI Type Descriptor'
PUBLIC	??_R0?AVRenderThread@@@8			; RenderThread `RTTI Type Descriptor'
PUBLIC	??_R2?$_LaunchPad@V?$_Bind@$00XQ6AXPAVThread@@@ZV?$reference_wrapper@PAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@std@@@std@@8 ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(Thread *),std::reference_wrapper<Thread *>,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil> >::`RTTI Base Class Array'
PUBLIC	??_R3Thread@@8					; Thread::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R3LimitedThread@@8				; LimitedThread::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R3ChunkLoadThread@@8				; ChunkLoadThread::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R4LimitedThread@@6B@				; LimitedThread::`RTTI Complete Object Locator'
PUBLIC	??_7LimitedThread@@6B@				; LimitedThread::`vftable'
PUBLIC	??_R3RenderThread@@8				; RenderThread::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R4RenderThread@@6B@				; RenderThread::`RTTI Complete Object Locator'
PUBLIC	??_R2LimitedThread@@8				; LimitedThread::`RTTI Base Class Array'
EXTRN	__Mtx_init:PROC
EXTRN	??_L@YGXPAXIHP6EX0@Z1@Z:PROC			; `eh vector constructor iterator'
EXTRN	__Thrd_current:PROC
EXTRN	__Thrd_join:PROC
EXTRN	??_M@YGXPAXIHP6EX0@Z@Z:PROC			; `eh vector destructor iterator'
EXTRN	__Mtx_destroy:PROC
EXTRN	__Xtime_get_ticks:PROC
EXTRN	?_Throw_Cpp_error@std@@YAXH@Z:PROC		; std::_Throw_Cpp_error
EXTRN	__Thrd_equal:PROC
?stop@GlobalThread@@3_NA DB 01H DUP (?)			; GlobalThread::stop
_BSS	ENDS
;	COMDAT ??_R2LimitedThread@@8
rdata$r	SEGMENT
??_R2LimitedThread@@8 DD FLAT:??_R1A@?0A@EA@LimitedThread@@8 ; LimitedThread::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@Thread@@8
rdata$r	ENDS
;	COMDAT ??_R4RenderThread@@6B@
rdata$r	SEGMENT
??_R4RenderThread@@6B@ DD 00H				; RenderThread::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVRenderThread@@@8
	DD	FLAT:??_R3RenderThread@@8
rdata$r	ENDS
;	COMDAT ??_R3RenderThread@@8
rdata$r	SEGMENT
??_R3RenderThread@@8 DD 00H				; RenderThread::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2RenderThread@@8
rdata$r	ENDS
;	COMDAT ??_7LimitedThread@@6B@
CONST	SEGMENT
??_7LimitedThread@@6B@ DD FLAT:??_R4LimitedThread@@6B@	; LimitedThread::`vftable'
	DD	FLAT:?shouldTick@LimitedThread@@MAE_NXZ
	DD	FLAT:?preStart@Thread@@UAEXXZ
	DD	FLAT:?postStop@Thread@@UAEXXZ
	DD	FLAT:?start@Thread@@UAE_NXZ
	DD	FLAT:?stop@Thread@@UAE_NXZ
	DD	FLAT:__purecall
CONST	ENDS
;	COMDAT ??_R4LimitedThread@@6B@
rdata$r	SEGMENT
??_R4LimitedThread@@6B@ DD 00H				; LimitedThread::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVLimitedThread@@@8
	DD	FLAT:??_R3LimitedThread@@8
rdata$r	ENDS
;	COMDAT ??_R3ChunkLoadThread@@8
rdata$r	SEGMENT
??_R3ChunkLoadThread@@8 DD 00H				; ChunkLoadThread::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2ChunkLoadThread@@8
rdata$r	ENDS
;	COMDAT ??_R3LimitedThread@@8
rdata$r	SEGMENT
??_R3LimitedThread@@8 DD 00H				; LimitedThread::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2LimitedThread@@8
rdata$r	ENDS
;	COMDAT ??_R3Thread@@8
rdata$r	SEGMENT
??_R3Thread@@8 DD 00H					; Thread::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2Thread@@8
rdata$r	ENDS
;	COMDAT ??_R2?$_LaunchPad@V?$_Bind@$00XQ6AXPAVThread@@@ZV?$reference_wrapper@PAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@std@@@std@@8
rdata$r	SEGMENT
??_R2?$_LaunchPad@V?$_Bind@$00XQ6AXPAVThread@@@ZV?$reference_wrapper@PAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@std@@@std@@8 DD FLAT:??_R1A@?0A@EA@?$_LaunchPad@V?$_Bind@$00XQ6AXPAVThread@@@ZV?$reference_wrapper@PAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@std@@@std@@8 ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(Thread *),std::reference_wrapper<Thread *>,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil> >::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@_Pad@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVRenderThread@@@8
_DATA	SEGMENT
??_R0?AVRenderThread@@@8 DD FLAT:??_7type_info@@6B@	; RenderThread `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVRenderThread@@', 00H
_DATA	ENDS
;	COMDAT ??_R0?AVChunkLoadThread@@@8
_DATA	SEGMENT
??_R0?AVChunkLoadThread@@@8 DD FLAT:??_7type_info@@6B@	; ChunkLoadThread `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVChunkLoadThread@@', 00H
_DATA	ENDS
;	COMDAT ??_R4Thread@@6B@
rdata$r	SEGMENT
??_R4Thread@@6B@ DD 00H					; Thread::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVThread@@@8
	DD	FLAT:??_R3Thread@@8
rdata$r	ENDS
;	COMDAT ??_R2Thread@@8
rdata$r	SEGMENT
??_R2Thread@@8 DD FLAT:??_R1A@?0A@EA@Thread@@8		; Thread::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R2ChunkLoadThread@@8
rdata$r	SEGMENT
??_R2ChunkLoadThread@@8 DD FLAT:??_R1A@?0A@EA@ChunkLoadThread@@8 ; ChunkLoadThread::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@Thread@@8
rdata$r	ENDS
;	COMDAT ??_R4?$_LaunchPad@V?$_Bind@$00XQ6AXPAVThread@@@ZV?$reference_wrapper@PAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@std@@@std@@6B@
rdata$r	SEGMENT
??_R4?$_LaunchPad@V?$_Bind@$00XQ6AXPAVThread@@@ZV?$reference_wrapper@PAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@std@@@std@@6B@ DD 00H ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(Thread *),std::reference_wrapper<Thread *>,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil> >::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$_LaunchPad@V?$_Bind@$00XQ6AXPAVThread@@@ZV?$reference_wrapper@PAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@std@@@std@@@8
	DD	FLAT:??_R3?$_LaunchPad@V?$_Bind@$00XQ6AXPAVThread@@@ZV?$reference_wrapper@PAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R4ChunkLoadThread@@6B@
rdata$r	SEGMENT
??_R4ChunkLoadThread@@6B@ DD 00H			; ChunkLoadThread::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVChunkLoadThread@@@8
	DD	FLAT:??_R3ChunkLoadThread@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVLimitedThread@@@8
_DATA	SEGMENT
??_R0?AVLimitedThread@@@8 DD FLAT:??_7type_info@@6B@	; LimitedThread `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVLimitedThread@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@ChunkLoadThread@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@ChunkLoadThread@@8 DD FLAT:??_R0?AVChunkLoadThread@@@8 ; ChunkLoadThread::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3ChunkLoadThread@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$_LaunchPad@V?$_Bind@$00XQ6AXPAVThread@@@ZV?$reference_wrapper@PAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$_LaunchPad@V?$_Bind@$00XQ6AXPAVThread@@@ZV?$reference_wrapper@PAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@std@@@std@@8 DD FLAT:??_R0?AV?$_LaunchPad@V?$_Bind@$00XQ6AXPAVThread@@@ZV?$reference_wrapper@PAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@std@@@std@@@8 ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(Thread *),std::reference_wrapper<Thread *>,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$_LaunchPad@V?$_Bind@$00XQ6AXPAVThread@@@ZV?$reference_wrapper@PAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2RenderThread@@8
rdata$r	SEGMENT
??_R2RenderThread@@8 DD FLAT:??_R1A@?0A@EA@RenderThread@@8 ; RenderThread::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@Thread@@8
rdata$r	ENDS
;	COMDAT ??_7RenderThread@@6B@
CONST	SEGMENT
??_7RenderThread@@6B@ DD FLAT:??_R4RenderThread@@6B@	; RenderThread::`vftable'
	DD	FLAT:?shouldTick@Thread@@MAE_NXZ
	DD	FLAT:?preStart@RenderThread@@UAEXXZ
	DD	FLAT:?postStop@RenderThread@@UAEXXZ
	DD	FLAT:?start@Thread@@UAE_NXZ
	DD	FLAT:?stop@Thread@@UAE_NXZ
	DD	FLAT:?tick@RenderThread@@EAE_NXZ
CONST	ENDS
;	COMDAT ??_R0?AV?$_LaunchPad@V?$_Bind@$00XQ6AXPAVThread@@@ZV?$reference_wrapper@PAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@std@@@std@@@8
_DATA	SEGMENT
??_R0?AV?$_LaunchPad@V?$_Bind@$00XQ6AXPAVThread@@@ZV?$reference_wrapper@PAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@std@@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(Thread *),std::reference_wrapper<Thread *>,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil> > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$_LaunchPad@V?$_Bind@$00XQ6AXPAVThread@@@ZV?$refere'
	DB	'nce_wrapper@PAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@std'
	DB	'@@@std@@', 00H
_DATA	ENDS
;	COMDAT ??_7ChunkDrawThread@@6B@
CONST	SEGMENT
??_7ChunkDrawThread@@6B@ DD FLAT:??_R4ChunkDrawThread@@6B@ ; ChunkDrawThread::`vftable'
	DD	FLAT:?shouldTick@Thread@@MAE_NXZ
	DD	FLAT:?preStart@Thread@@UAEXXZ
	DD	FLAT:?postStop@Thread@@UAEXXZ
	DD	FLAT:?start@Thread@@UAE_NXZ
	DD	FLAT:?stop@Thread@@UAE_NXZ
	DD	FLAT:?tick@ChunkDrawThread@@EAE_NXZ
CONST	ENDS
;	COMDAT ??_7ChunkLoadThread@@6B@
CONST	SEGMENT
??_7ChunkLoadThread@@6B@ DD FLAT:??_R4ChunkLoadThread@@6B@ ; ChunkLoadThread::`vftable'
	DD	FLAT:?shouldTick@Thread@@MAE_NXZ
	DD	FLAT:?preStart@Thread@@UAEXXZ
	DD	FLAT:?postStop@Thread@@UAEXXZ
	DD	FLAT:?start@Thread@@UAE_NXZ
	DD	FLAT:?stop@Thread@@UAE_NXZ
	DD	FLAT:?tick@ChunkLoadThread@@EAE_NXZ
CONST	ENDS
;	COMDAT ??_R3?$_LaunchPad@V?$_Bind@$00XQ6AXPAVThread@@@ZV?$reference_wrapper@PAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@std@@@std@@8
rdata$r	SEGMENT
??_R3?$_LaunchPad@V?$_Bind@$00XQ6AXPAVThread@@@ZV?$reference_wrapper@PAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@std@@@std@@8 DD 00H ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(Thread *),std::reference_wrapper<Thread *>,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2?$_LaunchPad@V?$_Bind@$00XQ6AXPAVThread@@@ZV?$reference_wrapper@PAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@LimitedThread@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@LimitedThread@@8 DD FLAT:??_R0?AVLimitedThread@@@8 ; LimitedThread::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3LimitedThread@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVThread@@@8
_DATA	SEGMENT
??_R0?AVThread@@@8 DD FLAT:??_7type_info@@6B@		; Thread `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVThread@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@RenderThread@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@RenderThread@@8 DD FLAT:??_R0?AVRenderThread@@@8 ; RenderThread::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3RenderThread@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@Thread@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@Thread@@8 DD FLAT:??_R0?AVThread@@@8	; Thread::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3Thread@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVChunkDrawThread@@@8
_DATA	SEGMENT
??_R0?AVChunkDrawThread@@@8 DD FLAT:??_7type_info@@6B@	; ChunkDrawThread `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVChunkDrawThread@@', 00H
_DATA	ENDS
;	COMDAT ??_7?$_LaunchPad@V?$_Bind@$00XQ6AXPAVThread@@@ZV?$reference_wrapper@PAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@std@@@std@@6B@
CONST	SEGMENT
??_7?$_LaunchPad@V?$_Bind@$00XQ6AXPAVThread@@@ZV?$reference_wrapper@PAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@std@@@std@@6B@ DD FLAT:??_R4?$_LaunchPad@V?$_Bind@$00XQ6AXPAVThread@@@ZV?$reference_wrapper@PAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@std@@@std@@6B@ ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(Thread *),std::reference_wrapper<Thread *>,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil> >::`vftable'
	DD	FLAT:?_Go@?$_LaunchPad@V?$_Bind@$00XQ6AXPAVThread@@@ZV?$reference_wrapper@PAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@std@@@std@@UAEIXZ
CONST	ENDS
;	COMDAT ??_R2ChunkDrawThread@@8
rdata$r	SEGMENT
??_R2ChunkDrawThread@@8 DD FLAT:??_R1A@?0A@EA@ChunkDrawThread@@8 ; ChunkDrawThread::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@Thread@@8
rdata$r	ENDS
;	COMDAT ??_R3ChunkDrawThread@@8
rdata$r	SEGMENT
??_R3ChunkDrawThread@@8 DD 00H				; ChunkDrawThread::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2ChunkDrawThread@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@ChunkDrawThread@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@ChunkDrawThread@@8 DD FLAT:??_R0?AVChunkDrawThread@@@8 ; ChunkDrawThread::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3ChunkDrawThread@@8
rdata$r	ENDS
;	COMDAT ??_7Thread@@6B@
CONST	SEGMENT
??_7Thread@@6B@ DD FLAT:??_R4Thread@@6B@		; Thread::`vftable'
	DD	FLAT:?shouldTick@Thread@@MAE_NXZ
	DD	FLAT:?preStart@Thread@@UAEXXZ
	DD	FLAT:?postStop@Thread@@UAEXXZ
	DD	FLAT:?start@Thread@@UAE_NXZ
	DD	FLAT:?stop@Thread@@UAE_NXZ
	DD	FLAT:__purecall
CONST	ENDS
;	COMDAT ??_R4ChunkDrawThread@@6B@
rdata$r	SEGMENT
??_R4ChunkDrawThread@@6B@ DD 00H			; ChunkDrawThread::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVChunkDrawThread@@@8
	DD	FLAT:??_R3ChunkDrawThread@@8
PUBLIC	??$?0V?$reference_wrapper@PAVThread@@@std@@@?$tuple@V?$reference_wrapper@PAVThread@@@std@@U_Nil@2@U32@U32@U32@U32@U32@U32@@std@@QAE@$$QAV?$reference_wrapper@PAVThread@@@1@PAPAX@Z ; std::tuple<std::reference_wrapper<Thread *>,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::tuple<std::reference_wrapper<Thread *>,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil><std::reference_wrapper<Thread *> >
PUBLIC	??$forward@AAP6AXPAVThread@@@Z@std@@YAAAP6AXPAVThread@@@ZAAP6AX0@Z@Z ; std::forward<void (__cdecl*&)(Thread *)>
PUBLIC	?get@?$reference_wrapper@PAVThread@@@std@@QBEAAPAVThread@@XZ ; std::reference_wrapper<Thread *>::get
PUBLIC	??$?0V?$reference_wrapper@PAVThread@@@std@@@?$_Tuple_val@V?$reference_wrapper@PAVThread@@@std@@@std@@QAE@$$QAV?$reference_wrapper@PAVThread@@@1@@Z ; std::_Tuple_val<std::reference_wrapper<Thread *> >::_Tuple_val<std::reference_wrapper<Thread *> ><std::reference_wrapper<Thread *> >
PUBLIC	??$_Fixarg@AAP6AXPAVThread@@@ZV?$reference_wrapper@PAVThread@@@std@@V?$tuple@V?$reference_wrapper@PAVThread@@@std@@U_Nil@2@U32@U32@U32@U32@U32@U32@@3@V?$tuple@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@3@@std@@YAAAPAVThread@@AAP6AXPAV1@@ZAAV?$tuple@V?$reference_wrapper@PAVThread@@@std@@U_Nil@2@U32@U32@U32@U32@U32@U32@@0@AAV?$tuple@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@0@AAV?$reference_wrapper@PAVThread@@@0@@Z ; std::_Fixarg<void (__cdecl*&)(Thread *),std::reference_wrapper<Thread *>,std::tuple<std::reference_wrapper<Thread *>,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>,std::tuple<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil> >
PUBLIC	??$get@$0A@V?$reference_wrapper@PAVThread@@@std@@@std@@YAAAV?$reference_wrapper@PAVThread@@@0@AAV?$tuple@V?$reference_wrapper@PAVThread@@@std@@U_Nil@2@U32@U32@U32@U32@U32@U32@@0@@Z ; std::get<0,std::reference_wrapper<Thread *> >
PUBLIC	??$forward@V?$tuple@V?$reference_wrapper@PAVThread@@@std@@U_Nil@2@U32@U32@U32@U32@U32@U32@@std@@@std@@YA$$QAV?$tuple@V?$reference_wrapper@PAVThread@@@std@@U_Nil@2@U32@U32@U32@U32@U32@U32@@0@AAV10@@Z ; std::forward<std::tuple<std::reference_wrapper<Thread *>,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil> >
PUBLIC	??$addressof@PAVThread@@@std@@YAPAPAVThread@@AAPAV1@@Z ; std::addressof<Thread *>
PUBLIC	??$forward@AAPAVThread@@@std@@YAAAPAVThread@@AAPAV1@@Z ; std::forward<Thread * &>
PUBLIC	??$?0V?$_Bind@$00XQ6AXPAVThread@@@ZV?$reference_wrapper@PAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@std@@@?$_LaunchPad@V?$_Bind@$00XQ6AXPAVThread@@@ZV?$reference_wrapper@PAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@std@@@std@@QAE@$$QAV?$_Bind@$00XQ6AXPAVThread@@@ZV?$reference_wrapper@PAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@1@@Z ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(Thread *),std::reference_wrapper<Thread *>,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil> >::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(Thread *),std::reference_wrapper<Thread *>,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil> ><std::_Bind<1,void,void (__cdecl*const)(Thread *),std::reference_wrapper<Thread *>,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil> >
PUBLIC	??$forward@V?$_Bind@$00XQ6AXPAVThread@@@ZV?$reference_wrapper@PAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@std@@@std@@YA$$QAV?$_Bind@$00XQ6AXPAVThread@@@ZV?$reference_wrapper@PAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@0@AAV10@@Z ; std::forward<std::_Bind<1,void,void (__cdecl*const)(Thread *),std::reference_wrapper<Thread *>,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil> >
PUBLIC	??$?0AAP6AXPAVThread@@@ZV?$reference_wrapper@PAVThread@@@std@@@?$_Bind@$00XQ6AXPAVThread@@@ZV?$reference_wrapper@PAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@std@@QAE@AAP6AXPAVThread@@@Z$$QAV?$reference_wrapper@PAVThread@@@1@@Z ; std::_Bind<1,void,void (__cdecl*const)(Thread *),std::reference_wrapper<Thread *>,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::_Bind<1,void,void (__cdecl*const)(Thread *),std::reference_wrapper<Thread *>,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil><void (__cdecl*&)(Thread *),std::reference_wrapper<Thread *> >
PUBLIC	?_Get_rest@?$tuple@V?$reference_wrapper@PAVThread@@@std@@U_Nil@2@U32@U32@U32@U32@U32@U32@@std@@QAEAAV?$tuple@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@2@XZ ; std::tuple<std::reference_wrapper<Thread *>,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::_Get_rest
PUBLIC	??0?$tuple@V?$reference_wrapper@PAVThread@@@std@@U_Nil@2@U32@U32@U32@U32@U32@U32@@std@@QAE@$$QAV01@@Z ; std::tuple<std::reference_wrapper<Thread *>,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::tuple<std::reference_wrapper<Thread *>,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>
PUBLIC	??R?$_Bind@$00XQ6AXPAVThread@@@ZV?$reference_wrapper@PAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@std@@QAEXXZ ; std::_Bind<1,void,void (__cdecl*const)(Thread *),std::reference_wrapper<Thread *>,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::operator()
PUBLIC	??0?$_Bind@$00XQ6AXPAVThread@@@ZV?$reference_wrapper@PAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@std@@QAE@$$QAV01@@Z ; std::_Bind<1,void,void (__cdecl*const)(Thread *),std::reference_wrapper<Thread *>,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::_Bind<1,void,void (__cdecl*const)(Thread *),std::reference_wrapper<Thread *>,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>
PUBLIC	?_Run@?$_LaunchPad@V?$_Bind@$00XQ6AXPAVThread@@@ZV?$reference_wrapper@PAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@std@@@std@@CAIPAV12@@Z ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(Thread *),std::reference_wrapper<Thread *>,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil> >::_Run
PUBLIC	?_Go@?$_LaunchPad@V?$_Bind@$00XQ6AXPAVThread@@@ZV?$reference_wrapper@PAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@std@@@std@@UAEIXZ ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(Thread *),std::reference_wrapper<Thread *>,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil> >::_Go
PUBLIC	??0?$_Callable_base@PAVThread@@$00@std@@QAE@AAPAVThread@@@Z ; std::_Callable_base<Thread *,1>::_Callable_base<Thread *,1>
PUBLIC	??Z?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@chrono@std@@QAEAAV012@ABV012@@Z ; std::chrono::duration<__int64,std::ratio<1,10000000> >::operator-=
PUBLIC	??1?$_LaunchPad@V?$_Bind@$00XQ6AXPAVThread@@@ZV?$reference_wrapper@PAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@std@@@std@@QAE@XZ ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(Thread *),std::reference_wrapper<Thread *>,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil> >::~_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(Thread *),std::reference_wrapper<Thread *>,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil> >
PUBLIC	??$?0AAPAVThread@@@?$_Callable_obj@PAVThread@@$00@std@@QAE@AAPAVThread@@@Z ; std::_Callable_obj<Thread *,1>::_Callable_obj<Thread *,1><Thread * &>
PUBLIC	??$?0_J@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAE@AB_JPAPAX@Z ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::duration<__int64,std::ratio<1,1000000000> ><__int64>
PUBLIC	??$?G_JU?$ratio@$00$0JIJGIA@@std@@_JU01@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@01@ABV201@0@Z ; std::chrono::operator-<__int64,std::ratio<1,10000000>,__int64,std::ratio<1,10000000> >
PUBLIC	??$_Launch@V?$_Bind@$00XQ6AXPAVThread@@@ZV?$reference_wrapper@PAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@std@@@std@@YAXPAU_Thrd_imp_t@@$$QAV?$_Bind@$00XQ6AXPAVThread@@@ZV?$reference_wrapper@PAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@0@@Z ; std::_Launch<std::_Bind<1,void,void (__cdecl*const)(Thread *),std::reference_wrapper<Thread *>,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil> >
PUBLIC	??$bind@XPAVThread@@V?$reference_wrapper@PAVThread@@@std@@@std@@YA?AV?$_Bind@$00XQ6AXPAVThread@@@ZV?$reference_wrapper@PAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@0@P6AXPAVThread@@@Z$$QAV?$reference_wrapper@PAVThread@@@0@@Z ; std::bind<void,Thread *,std::reference_wrapper<Thread *> >
PUBLIC	??$forward@V?$reference_wrapper@PAVThread@@@std@@@std@@YA$$QAV?$reference_wrapper@PAVThread@@@0@AAV10@@Z ; std::forward<std::reference_wrapper<Thread *> >
PUBLIC	??$_Decay_copy@P6AXPAVThread@@@Z@std@@YAP6AXPAVThread@@@Z$$QAP6AX0@Z@Z ; std::_Decay_copy<void (__cdecl*)(Thread *)>
PUBLIC	??$forward@P6AXPAVThread@@@Z@std@@YA$$QAP6AXPAVThread@@@ZAAP6AX0@Z@Z ; std::forward<void (__cdecl*)(Thread *)>
PUBLIC	??0?$_Call_wrapper_base@U?$_Callable_obj@PAVThread@@$00@std@@@std@@QAE@AAPAVThread@@@Z ; std::_Call_wrapper_base<std::_Callable_obj<Thread *,1> >::_Call_wrapper_base<std::_Callable_obj<Thread *,1> >
PUBLIC	?_Get@?$_Callable_base@PAVThread@@$00@std@@QBEAAPAVThread@@XZ ; std::_Callable_base<Thread *,1>::_Get
PUBLIC	??0?$_Call_wrapper@U?$_Callable_obj@PAVThread@@$00@std@@$0A@@std@@QAE@AAPAVThread@@@Z ; std::_Call_wrapper<std::_Callable_obj<Thread *,1>,0>::_Call_wrapper<std::_Callable_obj<Thread *,1>,0>
PUBLIC	?_Get@?$_Call_wrapper_base@U?$_Callable_obj@PAVThread@@$00@std@@@std@@QBEAAPAVThread@@XZ ; std::_Call_wrapper_base<std::_Callable_obj<Thread *,1> >::_Get
PUBLIC	??0?$_Refwrap_impl@PAVThread@@@std@@QAE@AAPAVThread@@@Z ; std::_Refwrap_impl<Thread *>::_Refwrap_impl<Thread *>
PUBLIC	??B?$reference_wrapper@PAVThread@@@std@@QBEAAPAVThread@@XZ ; std::reference_wrapper<Thread *>::operator Thread * &
PUBLIC	??0?$reference_wrapper@PAVThread@@@std@@QAE@AAPAVThread@@@Z ; std::reference_wrapper<Thread *>::reference_wrapper<Thread *>
PUBLIC	??$duration_cast@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@_JU?$ratio@$00$0JIJGIA@@3@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@ABV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@01@@Z ; std::chrono::duration_cast<std::chrono::duration<__int64,std::ratio<1,1000000000> >,__int64,std::ratio<1,10000000> >
PUBLIC	??$?GUsystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@12@V312@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@01@ABV?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@01@0@Z ; std::chrono::operator-<std::chrono::system_clock,std::chrono::duration<__int64,std::ratio<1,10000000> >,std::chrono::duration<__int64,std::ratio<1,10000000> > >
PUBLIC	??$?0P6AXPAVThread@@@ZV?$reference_wrapper@PAVThread@@@std@@@thread@std@@QAE@P6AXPAVThread@@@Z$$QAV?$reference_wrapper@PAVThread@@@1@@Z ; std::thread::thread<void (__cdecl*)(Thread *),std::reference_wrapper<Thread *> >
PUBLIC	??$ref@PAVThread@@@std@@YA?AV?$reference_wrapper@PAVThread@@@0@AAPAVThread@@@Z ; std::ref<Thread *>
PUBLIC	??$?0_J@?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@chrono@std@@QAE@AB_JPAPAX@Z ; std::chrono::duration<__int64,std::ratio<1,10000000> >::duration<__int64,std::ratio<1,10000000> ><__int64>
PUBLIC	?count@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QBE_JXZ ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::count
PUBLIC	?count@?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@chrono@std@@QBE_JXZ ; std::chrono::duration<__int64,std::ratio<1,10000000> >::count
PUBLIC	?time_since_epoch@?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@chrono@std@@QBE?AV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@XZ ; std::chrono::time_point<std::chrono::system_clock,std::chrono::duration<__int64,std::ratio<1,10000000> > >::time_since_epoch
PUBLIC	??0?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@chrono@std@@QAE@ABV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@12@@Z ; std::chrono::time_point<std::chrono::system_clock,std::chrono::duration<__int64,std::ratio<1,10000000> > >::time_point<std::chrono::system_clock,std::chrono::duration<__int64,std::ratio<1,10000000> > >
PUBLIC	?shouldTick@LimitedThread@@MAE_NXZ		; LimitedThread::shouldTick
PUBLIC	?postStop@Thread@@UAEXXZ			; Thread::postStop
PUBLIC	?preStart@Thread@@UAEXXZ			; Thread::preStart
PUBLIC	?stop@Thread@@UAE_NXZ				; Thread::stop
PUBLIC	?start@Thread@@UAE_NXZ				; Thread::start
PUBLIC	?shouldTick@Thread@@MAE_NXZ			; Thread::shouldTick
PUBLIC	?loop@Thread@@KAXPAV1@@Z			; Thread::loop
PUBLIC	??1RenderThread@@QAE@XZ				; RenderThread::~RenderThread
PUBLIC	??0RenderThread@@QAE@XZ				; RenderThread::RenderThread
PUBLIC	??1ChunkLoadThread@@QAE@XZ			; ChunkLoadThread::~ChunkLoadThread
PUBLIC	??0ChunkLoadThread@@QAE@XZ			; ChunkLoadThread::ChunkLoadThread
PUBLIC	??1mutex@std@@QAE@XZ				; std::mutex::~mutex
PUBLIC	??1Thread@@QAE@XZ				; Thread::~Thread
PUBLIC	??0Thread@@QAE@XZ				; Thread::Thread
PUBLIC	??1ChunkDrawThread@@QAE@XZ			; ChunkDrawThread::~ChunkDrawThread
PUBLIC	??0ChunkDrawThread@@QAE@XZ			; ChunkDrawThread::ChunkDrawThread
PUBLIC	??0mutex@std@@QAE@XZ				; std::mutex::mutex
PUBLIC	??1_Mutex_base@std@@QAE@XZ			; std::_Mutex_base::~_Mutex_base
PUBLIC	??0_Mutex_base@std@@QAE@H@Z			; std::_Mutex_base::_Mutex_base
PUBLIC	??8std@@YA_NVid@thread@0@0@Z			; std::operator==
PUBLIC	?get_id@this_thread@std@@YA?AVid@thread@2@XZ	; std::this_thread::get_id
PUBLIC	?get_id@thread@std@@QBE?AVid@12@XZ		; std::thread::get_id
PUBLIC	?join@thread@std@@QAEXXZ			; std::thread::join
PUBLIC	??0id@thread@std@@AAE@U_Thrd_imp_t@@@Z		; std::thread::id::id
PUBLIC	??0id@thread@std@@AAE@ABV12@@Z			; std::thread::id::id
PUBLIC	?_Mtx_initX@std@@YAHPAPAU_Mtx_internal_imp_t@@H@Z ; std::_Mtx_initX
PUBLIC	?now@system_clock@chrono@std@@SA?AV?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@23@XZ ; std::chrono::system_clock::now
PUBLIC	?renderThread@@3VRenderThread@@A		; renderThread
PUBLIC	?chunkLoadThreads@@3PAVChunkLoadThread@@A	; chunkLoadThreads
PUBLIC	?chunkDrawThreads@@3PAVChunkDrawThread@@A	; chunkDrawThreads
PUBLIC	?world@GlobalThread@@3VWorld@@A			; GlobalThread::world
	ALIGN	4

__Tuple_alloc DB 01H DUP (?)
	ALIGN	4

_ignore	DB	01H DUP (?)
	ALIGN	4

_allocator_arg DB 01H DUP (?)
	ALIGN	4

_piecewise_construct DB 01H DUP (?)
	ALIGN	4

?chunkLoadThreads@@3PAVChunkLoadThread@@A DB 0438H DUP (?) ; chunkLoadThreads
?chunkDrawThreads@@3PAVChunkDrawThread@@A DB 01180H DUP (?) ; chunkDrawThreads
?world@GlobalThread@@3VWorld@@A DB 03cH DUP (?)		; GlobalThread::world
_BSS	ENDS
?renderThread@@3VRenderThread@@A DD FLAT:??_7Thread@@6B@ ; renderThread
	DB	4 DUP(00H)
	DD	00H
_DATA	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0ChunkDrawThread@@QAE@XZ DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$??0ChunkDrawThread@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0ChunkDrawThread@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0ChunkDrawThread@@QAE@XZ$5
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??0ChunkDrawThread@@QAE@XZ$0
	DD	01H
	DD	FLAT:__unwindfunclet$??0ChunkDrawThread@@QAE@XZ$1
	DD	02H
	DD	FLAT:__unwindfunclet$??0ChunkDrawThread@@QAE@XZ$2
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0Thread@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0Thread@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0Thread@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0Thread@@QAE@XZ$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0ChunkLoadThread@@QAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0ChunkLoadThread@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0ChunkLoadThread@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0ChunkLoadThread@@QAE@XZ$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??0ChunkLoadThread@@QAE@XZ$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??__ErenderThread@@YAXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??__ErenderThread@@YAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??__ErenderThread@@YAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??__ErenderThread@@YAXXZ$1
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0RenderThread@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0RenderThread@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0RenderThread@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0RenderThread@@QAE@XZ$1
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?start@Thread@@UAE_NXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?start@Thread@@UAE_NXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?start@Thread@@UAE_NXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?start@Thread@@UAE_NXZ$1
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$?0P6AXPAVThread@@@ZV?$reference_wrapper@PAVThread@@@std@@@thread@std@@QAE@P6AXPAVThread@@@Z$$QAV?$reference_wrapper@PAVThread@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$?0P6AXPAVThread@@@ZV?$reference_wrapper@PAVThread@@@std@@@thread@std@@QAE@P6AXPAVThread@@@Z$$QAV?$reference_wrapper@PAVThread@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$?0P6AXPAVThread@@@ZV?$reference_wrapper@PAVThread@@@std@@@thread@std@@QAE@P6AXPAVThread@@@Z$$QAV?$reference_wrapper@PAVThread@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?0P6AXPAVThread@@@ZV?$reference_wrapper@PAVThread@@@std@@@thread@std@@QAE@P6AXPAVThread@@@Z$$QAV?$reference_wrapper@PAVThread@@@1@@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Launch@V?$_Bind@$00XQ6AXPAVThread@@@ZV?$reference_wrapper@PAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@std@@@std@@YAXPAU_Thrd_imp_t@@$$QAV?$_Bind@$00XQ6AXPAVThread@@@ZV?$reference_wrapper@PAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Launch@V?$_Bind@$00XQ6AXPAVThread@@@ZV?$reference_wrapper@PAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@std@@@std@@YAXPAU_Thrd_imp_t@@$$QAV?$_Bind@$00XQ6AXPAVThread@@@ZV?$reference_wrapper@PAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$_Launch@V?$_Bind@$00XQ6AXPAVThread@@@ZV?$reference_wrapper@PAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@std@@@std@@YAXPAU_Thrd_imp_t@@$$QAV?$_Bind@$00XQ6AXPAVThread@@@ZV?$reference_wrapper@PAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Launch@V?$_Bind@$00XQ6AXPAVThread@@@ZV?$reference_wrapper@PAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@std@@@std@@YAXPAU_Thrd_imp_t@@$$QAV?$_Bind@$00XQ6AXPAVThread@@@ZV?$reference_wrapper@PAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@0@@Z$0
_chunkDrawThreads$initializer$ DD FLAT:??__EchunkDrawThreads@@YAXXZ
_chunkLoadThreads$initializer$ DD FLAT:??__EchunkLoadThreads@@YAXXZ
_renderThread$initializer$ DD FLAT:??__ErenderThread@@YAXXZ
_world$initializer$ DD FLAT:??__Eworld@GlobalThread@@YAXXZ
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\chrono
;	COMDAT ?now@system_clock@chrono@std@@SA?AV?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@23@XZ
_TEXT	SEGMENT
?now@system_clock@chrono@std@@SA?AV?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@23@XZ PROC ; std::chrono::system_clock::now, COMDAT
; ___$ReturnUdt$ = ecx

; 705  : 		{	// get current time

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 706  : 		return (time_point(duration(_Xtime_get_ticks())));

  00003	e8 00 00 00 00	 call	 __Xtime_get_ticks

; 259  : 		{	// construct from a duration

  00008	89 06		 mov	 DWORD PTR [esi], eax
  0000a	89 56 04	 mov	 DWORD PTR [esi+4], edx

; 706  : 		return (time_point(duration(_Xtime_get_ticks())));

  0000d	8b c6		 mov	 eax, esi

; 707  : 		}

  0000f	5e		 pop	 esi
  00010	c3		 ret	 0
?now@system_clock@chrono@std@@SA?AV?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@23@XZ ENDP ; std::chrono::system_clock::now
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
;	COMDAT ?_Mtx_initX@std@@YAHPAPAU_Mtx_internal_imp_t@@H@Z
_TEXT	SEGMENT
__Mtx$ = 8						; size = 4
__Type$ = 12						; size = 4
?_Mtx_initX@std@@YAHPAPAU_Mtx_internal_imp_t@@H@Z PROC	; std::_Mtx_initX, COMDAT

; 62   : 	{	// throw exception on failure

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 63   : 	return (_Check_C_return(_Mtx_init(_Mtx, _Type)));

  00004	ff 75 0c	 push	 DWORD PTR __Type$[ebp]
  00007	ff 75 08	 push	 DWORD PTR __Mtx$[ebp]
  0000a	e8 00 00 00 00	 call	 __Mtx_init
  0000f	8b f0		 mov	 esi, eax
  00011	83 c4 08	 add	 esp, 8

; 32   : 	if (_Res != _Thrd_success)

  00014	85 f6		 test	 esi, esi
  00016	74 0b		 je	 SHORT $LN3@Mtx_initX

; 33   : 		_Throw_C_error(_Res);

  00018	56		 push	 esi
  00019	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
  0001e	83 c4 04	 add	 esp, 4

; 63   : 	return (_Check_C_return(_Mtx_init(_Mtx, _Type)));

  00021	8b c6		 mov	 eax, esi
$LN3@Mtx_initX:
  00023	5e		 pop	 esi

; 64   : 	}

  00024	5d		 pop	 ebp
  00025	c3		 ret	 0
?_Mtx_initX@std@@YAHPAPAU_Mtx_internal_imp_t@@H@Z ENDP	; std::_Mtx_initX
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thread
;	COMDAT ??0id@thread@std@@AAE@ABV12@@Z
_TEXT	SEGMENT
__Thrd$ = 8						; size = 4
??0id@thread@std@@AAE@ABV12@@Z PROC			; std::thread::id::id, COMDAT
; _this$ = ecx

; 193  : 		{	// construct from thread object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 55 08	 mov	 edx, DWORD PTR __Thrd$[ebp]
  00006	8b 02		 mov	 eax, DWORD PTR [edx]
  00008	89 01		 mov	 DWORD PTR [ecx], eax
  0000a	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0000d	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 194  : 		}

  00010	8b c1		 mov	 eax, ecx
  00012	5d		 pop	 ebp
  00013	c2 04 00	 ret	 4
??0id@thread@std@@AAE@ABV12@@Z ENDP			; std::thread::id::id
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thread
;	COMDAT ??0id@thread@std@@AAE@U_Thrd_imp_t@@@Z
_TEXT	SEGMENT
__Thrd$ = 8						; size = 8
??0id@thread@std@@AAE@U_Thrd_imp_t@@@Z PROC		; std::thread::id::id, COMDAT
; _this$ = ecx

; 198  : 		{	// construct from thread identifier

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Thrd$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax
  00008	8b 45 0c	 mov	 eax, DWORD PTR __Thrd$[ebp+4]
  0000b	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 199  : 		}

  0000e	8b c1		 mov	 eax, ecx
  00010	5d		 pop	 ebp
  00011	c2 08 00	 ret	 8
??0id@thread@std@@AAE@U_Thrd_imp_t@@@Z ENDP		; std::thread::id::id
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thread
;	COMDAT ?join@thread@std@@QAEXXZ
_TEXT	SEGMENT
?join@thread@std@@QAEXXZ PROC				; std::thread::join, COMDAT
; _this$ = ecx

; 210  : 	{	// join thread

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	51		 push	 ecx
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx

; 83   : 		return (!_Thr_is_null(_Thr));

  0000a	83 7e 04 00	 cmp	 DWORD PTR [esi+4], 0

; 211  : 	if (!joinable())

  0000e	75 1a		 jne	 SHORT $LN3@join

; 212  : 		_Throw_Cpp_error(_INVALID_ARGUMENT);

  00010	6a 01		 push	 1
  00012	e8 00 00 00 00	 call	 ?_Throw_Cpp_error@std@@YAXH@Z ; std::_Throw_Cpp_error
  00017	83 c4 04	 add	 esp, 4

; 213  : 	if (_Thr_is_null(_Thr))

  0001a	83 7e 04 00	 cmp	 DWORD PTR [esi+4], 0
  0001e	75 0a		 jne	 SHORT $LN3@join

; 214  : 		_Throw_Cpp_error(_INVALID_ARGUMENT);

  00020	6a 01		 push	 1
  00022	e8 00 00 00 00	 call	 ?_Throw_Cpp_error@std@@YAXH@Z ; std::_Throw_Cpp_error
  00027	83 c4 04	 add	 esp, 4
$LN3@join:

; 221  : 
; 222  : inline thread::id thread::get_id() const _NOEXCEPT
; 223  : 	{	// return id for this thread
; 224  : 	return (id(*this));
; 225  : 	}
; 226  : 
; 227  : inline thread::id this_thread::get_id() _NOEXCEPT
; 228  : 	{	// return id for current thread
; 229  : 	return (_Thrd_current());

  0002a	e8 00 00 00 00	 call	 __Thrd_current

; 230  : 	}
; 231  : 
; 232  : inline void swap(thread& _Left, thread& _Right) _NOEXCEPT
; 233  : 	{	// swap _Left with _Right
; 234  : 	_Left.swap(_Right);
; 235  : 	}
; 236  : 
; 237  : inline bool operator==(thread::id _Left, thread::id _Right) _NOEXCEPT
; 238  : 	{	// return true if _Left and _Right identify the same thread
; 239  : 	return (_Thrd_equal(_Left._Thr, _Right._Thr));

  0002f	52		 push	 edx
  00030	50		 push	 eax
  00031	ff 76 04	 push	 DWORD PTR [esi+4]
  00034	ff 36		 push	 DWORD PTR [esi]
  00036	e8 00 00 00 00	 call	 __Thrd_equal
  0003b	83 c4 10	 add	 esp, 16			; 00000010H
  0003e	85 c0		 test	 eax, eax

; 215  : 	if (get_id() == _STD this_thread::get_id())

  00040	74 0a		 je	 SHORT $LN2@join

; 216  : 		_Throw_Cpp_error(_RESOURCE_DEADLOCK_WOULD_OCCUR);

  00042	6a 05		 push	 5
  00044	e8 00 00 00 00	 call	 ?_Throw_Cpp_error@std@@YAXH@Z ; std::_Throw_Cpp_error
  00049	83 c4 04	 add	 esp, 4
$LN2@join:

; 217  : 	if (_Thrd_join(_Thr, 0) != _Thrd_success)

  0004c	6a 00		 push	 0
  0004e	ff 76 04	 push	 DWORD PTR [esi+4]
  00051	ff 36		 push	 DWORD PTR [esi]
  00053	e8 00 00 00 00	 call	 __Thrd_join
  00058	83 c4 0c	 add	 esp, 12			; 0000000cH
  0005b	85 c0		 test	 eax, eax
  0005d	74 0a		 je	 SHORT $LN19@join

; 218  : 		_Throw_Cpp_error(_NO_SUCH_PROCESS);

  0005f	6a 02		 push	 2
  00061	e8 00 00 00 00	 call	 ?_Throw_Cpp_error@std@@YAXH@Z ; std::_Throw_Cpp_error
  00066	83 c4 04	 add	 esp, 4
$LN19@join:

; 219  : 	_Thr_set_null(_Thr);

  00069	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 220  : 	}

  00070	5e		 pop	 esi
  00071	8b e5		 mov	 esp, ebp
  00073	5d		 pop	 ebp
  00074	c3		 ret	 0
?join@thread@std@@QAEXXZ ENDP				; std::thread::join
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thread
;	COMDAT ?get_id@thread@std@@QBE?AVid@12@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?get_id@thread@std@@QBE?AVid@12@XZ PROC			; std::thread::get_id, COMDAT
; _this$ = ecx

; 223  : 	{	// return id for this thread

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 193  : 		{	// construct from thread object

  00003	8b 11		 mov	 edx, DWORD PTR [ecx]
  00005	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00008	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0000b	89 10		 mov	 DWORD PTR [eax], edx
  0000d	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 224  : 	return (id(*this));
; 225  : 	}

  00010	5d		 pop	 ebp
  00011	c2 04 00	 ret	 4
?get_id@thread@std@@QBE?AVid@12@XZ ENDP			; std::thread::get_id
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thread
;	COMDAT ?get_id@this_thread@std@@YA?AVid@thread@2@XZ
_TEXT	SEGMENT
?get_id@this_thread@std@@YA?AVid@thread@2@XZ PROC	; std::this_thread::get_id, COMDAT
; ___$ReturnUdt$ = ecx

; 228  : 	{	// return id for current thread

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 229  : 	return (_Thrd_current());

  00003	e8 00 00 00 00	 call	 __Thrd_current

; 198  : 		{	// construct from thread identifier

  00008	89 06		 mov	 DWORD PTR [esi], eax
  0000a	89 56 04	 mov	 DWORD PTR [esi+4], edx

; 229  : 	return (_Thrd_current());

  0000d	8b c6		 mov	 eax, esi

; 230  : 	}

  0000f	5e		 pop	 esi
  00010	c3		 ret	 0
?get_id@this_thread@std@@YA?AVid@thread@2@XZ ENDP	; std::this_thread::get_id
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thread
;	COMDAT ??8std@@YA_NVid@thread@0@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 8
__Right$ = 16						; size = 8
??8std@@YA_NVid@thread@0@0@Z PROC			; std::operator==, COMDAT

; 238  : 	{	// return true if _Left and _Right identify the same thread

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 239  : 	return (_Thrd_equal(_Left._Thr, _Right._Thr));

  00003	ff 75 14	 push	 DWORD PTR __Right$[ebp+4]
  00006	ff 75 10	 push	 DWORD PTR __Right$[ebp]
  00009	ff 75 0c	 push	 DWORD PTR __Left$[ebp+4]
  0000c	ff 75 08	 push	 DWORD PTR __Left$[ebp]
  0000f	e8 00 00 00 00	 call	 __Thrd_equal
  00014	83 c4 10	 add	 esp, 16			; 00000010H
  00017	85 c0		 test	 eax, eax
  00019	0f 95 c0	 setne	 al

; 240  : 	}

  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
??8std@@YA_NVid@thread@0@0@Z ENDP			; std::operator==
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\mutex
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\mutex
;	COMDAT ??0_Mutex_base@std@@QAE@H@Z
_TEXT	SEGMENT
__Flags$dead$ = 8					; size = 4
??0_Mutex_base@std@@QAE@H@Z PROC			; std::_Mutex_base::_Mutex_base, COMDAT
; _this$ = ecx

; 26   : 	_Mutex_base(int _Flags = 0)

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 63   : 	return (_Check_C_return(_Mtx_init(_Mtx, _Type)));

  00003	6a 02		 push	 2
  00005	56		 push	 esi
  00006	e8 00 00 00 00	 call	 __Mtx_init
  0000b	83 c4 08	 add	 esp, 8

; 32   : 	if (_Res != _Thrd_success)

  0000e	85 c0		 test	 eax, eax
  00010	74 09		 je	 SHORT $LN8@Mutex_base

; 33   : 		_Throw_C_error(_Res);

  00012	50		 push	 eax
  00013	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
  00018	83 c4 04	 add	 esp, 4
$LN8@Mutex_base:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\mutex

; 29   : 		}

  0001b	8b c6		 mov	 eax, esi
  0001d	5e		 pop	 esi
  0001e	c2 04 00	 ret	 4
??0_Mutex_base@std@@QAE@H@Z ENDP			; std::_Mutex_base::_Mutex_base
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\mutex
;	COMDAT ??1_Mutex_base@std@@QAE@XZ
_TEXT	SEGMENT
??1_Mutex_base@std@@QAE@XZ PROC				; std::_Mutex_base::~_Mutex_base, COMDAT
; _this$ = ecx

; 33   : 		_Mtx_destroy(&_Mtx);

  00000	51		 push	 ecx
  00001	e8 00 00 00 00	 call	 __Mtx_destroy
  00006	59		 pop	 ecx

; 34   : 		}

  00007	c3		 ret	 0
??1_Mutex_base@std@@QAE@XZ ENDP				; std::_Mutex_base::~_Mutex_base
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\mutex
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\mutex
;	COMDAT ??0mutex@std@@QAE@XZ
_TEXT	SEGMENT
??0mutex@std@@QAE@XZ PROC				; std::mutex::mutex, COMDAT
; _this$ = ecx

; 112  : 		{	// default construct

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 63   : 	return (_Check_C_return(_Mtx_init(_Mtx, _Type)));

  00003	6a 02		 push	 2
  00005	56		 push	 esi
  00006	e8 00 00 00 00	 call	 __Mtx_init
  0000b	83 c4 08	 add	 esp, 8

; 32   : 	if (_Res != _Thrd_success)

  0000e	85 c0		 test	 eax, eax
  00010	74 09		 je	 SHORT $LN10@mutex

; 33   : 		_Throw_C_error(_Res);

  00012	50		 push	 eax
  00013	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
  00018	83 c4 04	 add	 esp, 4
$LN10@mutex:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\mutex

; 113  : 		}

  0001b	8b c6		 mov	 eax, esi
  0001d	5e		 pop	 esi
  0001e	c3		 ret	 0
??0mutex@std@@QAE@XZ ENDP				; std::mutex::mutex
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\threads.cpp
;	COMDAT ??__EchunkDrawThreads@@YAXXZ
text$yc	SEGMENT
??__EchunkDrawThreads@@YAXXZ PROC			; `dynamic initializer for 'chunkDrawThreads'', COMDAT

; 3    : ChunkDrawThread chunkDrawThreads[DRAW_THREAD_AMOUNT];

  00000	68 00 00 00 00	 push	 OFFSET ??1ChunkDrawThread@@QAE@XZ
  00005	68 00 00 00 00	 push	 OFFSET ??0ChunkDrawThread@@QAE@XZ
  0000a	6a 04		 push	 4
  0000c	68 60 04 00 00	 push	 1120			; 00000460H
  00011	68 00 00 00 00	 push	 OFFSET ?chunkDrawThreads@@3PAVChunkDrawThread@@A ; chunkDrawThreads
  00016	e8 00 00 00 00	 call	 ??_L@YGXPAXIHP6EX0@Z1@Z
  0001b	68 00 00 00 00	 push	 OFFSET ??__FchunkDrawThreads@@YAXXZ ; `dynamic atexit destructor for 'chunkDrawThreads''
  00020	e8 00 00 00 00	 call	 _atexit
  00025	59		 pop	 ecx
  00026	c3		 ret	 0
??__EchunkDrawThreads@@YAXXZ ENDP			; `dynamic initializer for 'chunkDrawThreads''
text$yc	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??__FchunkDrawThreads@@YAXXZ
text$yd	SEGMENT
??__FchunkDrawThreads@@YAXXZ PROC			; `dynamic atexit destructor for 'chunkDrawThreads'', COMDAT
  00000	68 00 00 00 00	 push	 OFFSET ??1ChunkDrawThread@@QAE@XZ
  00005	6a 04		 push	 4
  00007	68 60 04 00 00	 push	 1120			; 00000460H
  0000c	68 00 00 00 00	 push	 OFFSET ?chunkDrawThreads@@3PAVChunkDrawThread@@A ; chunkDrawThreads
  00011	e8 00 00 00 00	 call	 ??_M@YGXPAXIHP6EX0@Z@Z
  00016	c3		 ret	 0
??__FchunkDrawThreads@@YAXXZ ENDP			; `dynamic atexit destructor for 'chunkDrawThreads''
text$yd	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thread
; File c:\users\glenn\documents\github\wind\project\wind\wind\memutil.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\queue
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\mutex
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
;	COMDAT ??0ChunkDrawThread@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0ChunkDrawThread@@QAE@XZ PROC				; ChunkDrawThread::ChunkDrawThread, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0ChunkDrawThread@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	57		 push	 edi
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	8b f1		 mov	 esi, ecx
  00027	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi
  0002a	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7Thread@@6B@
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thread

; 39   : 		_Thr_set_null(_Thr);

  00030	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
; File c:\users\glenn\documents\github\wind\project\wind\wind\memutil.cpp

; 7    : {

  00037	68 02 10 00 00	 push	 4098			; 00001002H
  0003c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00043	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00048	89 86 14 04 00
	00		 mov	 DWORD PTR [esi+1044], eax
  0004e	c7 86 18 04 00
	00 02 10 00 00	 mov	 DWORD PTR [esi+1048], 4098 ; 00001002H
  00058	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  0005f	8d be 20 04 00
	00		 lea	 edi, DWORD PTR [esi+1056]
  00065	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7ChunkDrawThread@@6B@
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0006b	6a 08		 push	 8
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility

; 79   : 		{	// construct childless container

  0006d	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 778  : 		_Map = _Mapptr();

  00073	c7 47 04 00 00
	00 00		 mov	 DWORD PTR [edi+4], 0

; 779  : 		_Mapsize = 0;

  0007a	c7 47 08 00 00
	00 00		 mov	 DWORD PTR [edi+8], 0

; 780  : 		_Myoff = 0;

  00081	c7 47 0c 00 00
	00 00		 mov	 DWORD PTR [edi+12], 0

; 781  : 		_Mysize = 0;

  00088	c7 47 10 00 00
	00 00		 mov	 DWORD PTR [edi+16], 0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0008f	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00094	83 c4 08	 add	 esp, 8
  00097	85 c0		 test	 eax, eax
  00099	75 05		 jne	 SHORT $LN42@ChunkDrawT

; 29   : 		_Xbad_alloc();	// report no memory

  0009b	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN183@ChunkDrawT:
$LN42@ChunkDrawT:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 900  : 		this->_Myproxy = _Alproxy.allocate(1);

  000a0	89 07		 mov	 DWORD PTR [edi], eax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 617  : _VARIADIC_EXPAND_0X(_ALLOC_MEMBER_CONSTRUCT, , , , )

  000a2	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  000a8	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 902  : 		this->_Myproxy->_Mycont = this;

  000af	8b 07		 mov	 eax, DWORD PTR [edi]
  000b1	89 38		 mov	 DWORD PTR [eax], edi
  000b3	8d be 34 04 00
	00		 lea	 edi, DWORD PTR [esi+1076]
  000b9	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  000bd	6a 08		 push	 8
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility

; 79   : 		{	// construct childless container

  000bf	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 778  : 		_Map = _Mapptr();

  000c5	c7 47 04 00 00
	00 00		 mov	 DWORD PTR [edi+4], 0

; 779  : 		_Mapsize = 0;

  000cc	c7 47 08 00 00
	00 00		 mov	 DWORD PTR [edi+8], 0

; 780  : 		_Myoff = 0;

  000d3	c7 47 0c 00 00
	00 00		 mov	 DWORD PTR [edi+12], 0

; 781  : 		_Mysize = 0;

  000da	c7 47 10 00 00
	00 00		 mov	 DWORD PTR [edi+16], 0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  000e1	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  000e6	83 c4 04	 add	 esp, 4
  000e9	85 c0		 test	 eax, eax
  000eb	75 05		 jne	 SHORT $LN93@ChunkDrawT

; 29   : 		_Xbad_alloc();	// report no memory

  000ed	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN184@ChunkDrawT:
$LN93@ChunkDrawT:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 900  : 		this->_Myproxy = _Alproxy.allocate(1);

  000f2	89 07		 mov	 DWORD PTR [edi], eax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 617  : _VARIADIC_EXPAND_0X(_ALLOC_MEMBER_CONSTRUCT, , , , )

  000f4	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  000fa	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 902  : 		this->_Myproxy->_Mycont = this;

  00101	8b 07		 mov	 eax, DWORD PTR [edi]
  00103	89 38		 mov	 DWORD PTR [eax], edi
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\queue

; 30   : 		{	// construct with empty container

  00105	8d be 48 04 00
	00		 lea	 edi, DWORD PTR [esi+1096]
  0010b	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0010f	6a 08		 push	 8
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility

; 79   : 		{	// construct childless container

  00111	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 778  : 		_Map = _Mapptr();

  00117	c7 47 04 00 00
	00 00		 mov	 DWORD PTR [edi+4], 0

; 779  : 		_Mapsize = 0;

  0011e	c7 47 08 00 00
	00 00		 mov	 DWORD PTR [edi+8], 0

; 780  : 		_Myoff = 0;

  00125	c7 47 0c 00 00
	00 00		 mov	 DWORD PTR [edi+12], 0

; 781  : 		_Mysize = 0;

  0012c	c7 47 10 00 00
	00 00		 mov	 DWORD PTR [edi+16], 0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  00133	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00138	83 c4 04	 add	 esp, 4
  0013b	85 c0		 test	 eax, eax
  0013d	75 05		 jne	 SHORT $LN143@ChunkDrawT

; 29   : 		_Xbad_alloc();	// report no memory

  0013f	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN185@ChunkDrawT:
$LN143@ChunkDrawT:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 900  : 		this->_Myproxy = _Alproxy.allocate(1);

  00144	89 07		 mov	 DWORD PTR [edi], eax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 617  : _VARIADIC_EXPAND_0X(_ALLOC_MEMBER_CONSTRUCT, , , , )

  00146	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  0014c	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 902  : 		this->_Myproxy->_Mycont = this;

  00153	8b 07		 mov	 eax, DWORD PTR [edi]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 63   : 	return (_Check_C_return(_Mtx_init(_Mtx, _Type)));

  00155	6a 02		 push	 2
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 902  : 		this->_Myproxy->_Mycont = this;

  00157	89 38		 mov	 DWORD PTR [eax], edi
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\mutex

; 28   : 		_Mtx_initX(&_Mtx, _Flags | _Mtx_try);

  00159	8d 86 5c 04 00
	00		 lea	 eax, DWORD PTR [esi+1116]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 63   : 	return (_Check_C_return(_Mtx_init(_Mtx, _Type)));

  0015f	50		 push	 eax
  00160	e8 00 00 00 00	 call	 __Mtx_init
  00165	83 c4 08	 add	 esp, 8

; 32   : 	if (_Res != _Thrd_success)

  00168	85 c0		 test	 eax, eax
  0016a	74 09		 je	 SHORT $LN178@ChunkDrawT

; 33   : 		_Throw_C_error(_Res);

  0016c	50		 push	 eax
  0016d	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
  00172	83 c4 04	 add	 esp, 4
$LN178@ChunkDrawT:
  00175	8b c6		 mov	 eax, esi
  00177	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0017a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00181	59		 pop	 ecx
  00182	5f		 pop	 edi
  00183	5e		 pop	 esi
  00184	8b e5		 mov	 esp, ebp
  00186	5d		 pop	 ebp
  00187	c3		 ret	 0
$LN182@ChunkDrawT:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0ChunkDrawThread@@QAE@XZ$5:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	83 c1 04	 add	 ecx, 4
  00006	e9 00 00 00 00	 jmp	 ??1thread@std@@QAE@XZ	; std::thread::~thread
__unwindfunclet$??0ChunkDrawThread@@QAE@XZ$0:
  0000b	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e9 00 00 00 00	 jmp	 ??1Thread@@QAE@XZ
__unwindfunclet$??0ChunkDrawThread@@QAE@XZ$1:
  00013	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	81 c1 20 04 00
	00		 add	 ecx, 1056		; 00000420H
  0001c	e9 00 00 00 00	 jmp	 ??1?$queue@V?$shared_ptr@VChunkBase@@@std@@V?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@2@@std@@QAE@XZ
__unwindfunclet$??0ChunkDrawThread@@QAE@XZ$2:
  00021	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00024	81 c1 34 04 00
	00		 add	 ecx, 1076		; 00000434H
  0002a	e9 00 00 00 00	 jmp	 ??1?$queue@V?$shared_ptr@VChunkBase@@@std@@V?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@2@@std@@QAE@XZ
__ehhandler$??0ChunkDrawThread@@QAE@XZ:
  0002f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00033	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00036	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  00039	33 c8		 xor	 ecx, eax
  0003b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00040	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0ChunkDrawThread@@QAE@XZ
  00045	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0ChunkDrawThread@@QAE@XZ ENDP				; ChunkDrawThread::ChunkDrawThread
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\mutex
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\users\glenn\documents\github\wind\project\wind\wind\memutil.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thread
;	COMDAT ??1ChunkDrawThread@@QAE@XZ
_TEXT	SEGMENT
??1ChunkDrawThread@@QAE@XZ PROC				; ChunkDrawThread::~ChunkDrawThread, COMDAT
; _this$ = ecx
  00000	56		 push	 esi
  00001	57		 push	 edi
  00002	8b f9		 mov	 edi, ecx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\mutex

; 33   : 		_Mtx_destroy(&_Mtx);

  00004	8d 87 5c 04 00
	00		 lea	 eax, DWORD PTR [edi+1116]
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 __Mtx_destroy
  00010	83 c4 04	 add	 esp, 4
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 1222 : 		_Tidy();

  00013	8d 8f 48 04 00
	00		 lea	 ecx, DWORD PTR [edi+1096]
  00019	e8 00 00 00 00	 call	 ?_Tidy@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IAEXXZ ; std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::_Tidy
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 586  : 		::operator delete(_Ptr);

  0001e	ff b7 48 04 00
	00		 push	 DWORD PTR [edi+1096]
  00024	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00029	83 c4 04	 add	 esp, 4
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 1222 : 		_Tidy();

  0002c	8d 8f 34 04 00
	00		 lea	 ecx, DWORD PTR [edi+1076]

; 912  : 		this->_Myproxy = 0;

  00032	c7 87 48 04 00
	00 00 00 00 00	 mov	 DWORD PTR [edi+1096], 0

; 1222 : 		_Tidy();

  0003c	e8 00 00 00 00	 call	 ?_Tidy@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IAEXXZ ; std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::_Tidy
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 586  : 		::operator delete(_Ptr);

  00041	ff b7 34 04 00
	00		 push	 DWORD PTR [edi+1076]
  00047	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0004c	83 c4 04	 add	 esp, 4
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 1222 : 		_Tidy();

  0004f	8d 8f 20 04 00
	00		 lea	 ecx, DWORD PTR [edi+1056]

; 912  : 		this->_Myproxy = 0;

  00055	c7 87 34 04 00
	00 00 00 00 00	 mov	 DWORD PTR [edi+1076], 0

; 1222 : 		_Tidy();

  0005f	e8 00 00 00 00	 call	 ?_Tidy@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IAEXXZ ; std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::_Tidy
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 586  : 		::operator delete(_Ptr);

  00064	ff b7 20 04 00
	00		 push	 DWORD PTR [edi+1056]
  0006a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 912  : 		this->_Myproxy = 0;

  0006f	c7 87 20 04 00
	00 00 00 00 00	 mov	 DWORD PTR [edi+1056], 0
; File c:\users\glenn\documents\github\wind\project\wind\wind\memutil.cpp

; 13   : 	delete[] heap;

  00079	ff b7 14 04 00
	00		 push	 DWORD PTR [edi+1044]
  0007f	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00084	83 c4 08	 add	 esp, 8
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thread

; 83   : 		return (!_Thr_is_null(_Thr));

  00087	83 7f 08 00	 cmp	 DWORD PTR [edi+8], 0
  0008b	5f		 pop	 edi
  0008c	5e		 pop	 esi

; 57   : 		if (joinable())

  0008d	75 01		 jne	 SHORT $LN63@ChunkDrawT
  0008f	c3		 ret	 0
$LN63@ChunkDrawT:

; 58   : 			_XSTD terminate();

  00090	e8 00 00 00 00	 call	 ?terminate@@YAXXZ	; terminate
$LN65@ChunkDrawT:
$LN62@ChunkDrawT:
  00095	cc		 int	 3
??1ChunkDrawThread@@QAE@XZ ENDP				; ChunkDrawThread::~ChunkDrawThread
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thread
; File c:\users\glenn\documents\github\wind\project\wind\wind\memutil.cpp
;	COMDAT ??0Thread@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0Thread@@QAE@XZ PROC					; Thread::Thread, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0Thread@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00024	8b f1		 mov	 esi, ecx
  00026	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi
  00029	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7Thread@@6B@
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thread

; 39   : 		_Thr_set_null(_Thr);

  0002f	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
; File c:\users\glenn\documents\github\wind\project\wind\wind\memutil.cpp

; 7    : {

  00036	68 02 10 00 00	 push	 4098			; 00001002H
  0003b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00042	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00047	89 86 14 04 00
	00		 mov	 DWORD PTR [esi+1044], eax
  0004d	83 c4 04	 add	 esp, 4
  00050	c7 86 18 04 00
	00 02 10 00 00	 mov	 DWORD PTR [esi+1048], 4098 ; 00001002H
  0005a	8b c6		 mov	 eax, esi
  0005c	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0005f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00066	59		 pop	 ecx
  00067	5e		 pop	 esi
  00068	8b e5		 mov	 esp, ebp
  0006a	5d		 pop	 ebp
  0006b	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0Thread@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	83 c1 04	 add	 ecx, 4
  00006	e9 00 00 00 00	 jmp	 ??1thread@std@@QAE@XZ	; std::thread::~thread
__ehhandler$??0Thread@@QAE@XZ:
  0000b	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000f	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00012	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  00015	33 c8		 xor	 ecx, eax
  00017	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001c	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0Thread@@QAE@XZ
  00021	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0Thread@@QAE@XZ ENDP					; Thread::Thread
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\memutil.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thread
;	COMDAT ??1Thread@@QAE@XZ
_TEXT	SEGMENT
??1Thread@@QAE@XZ PROC					; Thread::~Thread, COMDAT
; _this$ = ecx
  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
; File c:\users\glenn\documents\github\wind\project\wind\wind\memutil.cpp

; 13   : 	delete[] heap;

  00003	ff b6 14 04 00
	00		 push	 DWORD PTR [esi+1044]
  00009	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000e	83 c4 04	 add	 esp, 4
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thread

; 83   : 		return (!_Thr_is_null(_Thr));

  00011	83 7e 08 00	 cmp	 DWORD PTR [esi+8], 0
  00015	5e		 pop	 esi

; 57   : 		if (joinable())

  00016	75 01		 jne	 SHORT $LN14@Thread
  00018	c3		 ret	 0
$LN14@Thread:

; 58   : 			_XSTD terminate();

  00019	e8 00 00 00 00	 call	 ?terminate@@YAXXZ	; terminate
$LN16@Thread:
$LN13@Thread:
  0001e	cc		 int	 3
??1Thread@@QAE@XZ ENDP					; Thread::~Thread
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\mutex
;	COMDAT ??1mutex@std@@QAE@XZ
_TEXT	SEGMENT
??1mutex@std@@QAE@XZ PROC				; std::mutex::~mutex, COMDAT
; _this$ = ecx

; 33   : 		_Mtx_destroy(&_Mtx);

  00000	51		 push	 ecx
  00001	e8 00 00 00 00	 call	 __Mtx_destroy
  00006	59		 pop	 ecx
  00007	c3		 ret	 0
??1mutex@std@@QAE@XZ ENDP				; std::mutex::~mutex
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\threads.cpp
;	COMDAT ??__EchunkLoadThreads@@YAXXZ
text$yc	SEGMENT
??__EchunkLoadThreads@@YAXXZ PROC			; `dynamic initializer for 'chunkLoadThreads'', COMDAT

; 4    : ChunkLoadThread chunkLoadThreads[LOAD_THREAD_AMOUNT];

  00000	68 00 00 00 00	 push	 OFFSET ??1ChunkLoadThread@@QAE@XZ
  00005	68 00 00 00 00	 push	 OFFSET ??0ChunkLoadThread@@QAE@XZ
  0000a	6a 01		 push	 1
  0000c	68 38 04 00 00	 push	 1080			; 00000438H
  00011	68 00 00 00 00	 push	 OFFSET ?chunkLoadThreads@@3PAVChunkLoadThread@@A ; chunkLoadThreads
  00016	e8 00 00 00 00	 call	 ??_L@YGXPAXIHP6EX0@Z1@Z
  0001b	68 00 00 00 00	 push	 OFFSET ??__FchunkLoadThreads@@YAXXZ ; `dynamic atexit destructor for 'chunkLoadThreads''
  00020	e8 00 00 00 00	 call	 _atexit
  00025	59		 pop	 ecx
  00026	c3		 ret	 0
??__EchunkLoadThreads@@YAXXZ ENDP			; `dynamic initializer for 'chunkLoadThreads''
text$yc	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??__FchunkLoadThreads@@YAXXZ
text$yd	SEGMENT
??__FchunkLoadThreads@@YAXXZ PROC			; `dynamic atexit destructor for 'chunkLoadThreads'', COMDAT
  00000	68 00 00 00 00	 push	 OFFSET ??1ChunkLoadThread@@QAE@XZ
  00005	6a 01		 push	 1
  00007	68 38 04 00 00	 push	 1080			; 00000438H
  0000c	68 00 00 00 00	 push	 OFFSET ?chunkLoadThreads@@3PAVChunkLoadThread@@A ; chunkLoadThreads
  00011	e8 00 00 00 00	 call	 ??_M@YGXPAXIHP6EX0@Z@Z
  00016	c3		 ret	 0
??__FchunkLoadThreads@@YAXXZ ENDP			; `dynamic atexit destructor for 'chunkLoadThreads''
text$yd	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thread
; File c:\users\glenn\documents\github\wind\project\wind\wind\memutil.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\queue
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\mutex
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
;	COMDAT ??0ChunkLoadThread@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0ChunkLoadThread@@QAE@XZ PROC				; ChunkLoadThread::ChunkLoadThread, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0ChunkLoadThread@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	57		 push	 edi
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	8b f1		 mov	 esi, ecx
  00027	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi
  0002a	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7Thread@@6B@
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thread

; 39   : 		_Thr_set_null(_Thr);

  00030	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
; File c:\users\glenn\documents\github\wind\project\wind\wind\memutil.cpp

; 7    : {

  00037	68 02 10 00 00	 push	 4098			; 00001002H
  0003c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00043	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00048	89 86 14 04 00
	00		 mov	 DWORD PTR [esi+1044], eax
  0004e	c7 86 18 04 00
	00 02 10 00 00	 mov	 DWORD PTR [esi+1048], 4098 ; 00001002H
  00058	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\queue

; 30   : 		{	// construct with empty container

  0005f	8d be 20 04 00
	00		 lea	 edi, DWORD PTR [esi+1056]
  00065	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7ChunkLoadThread@@6B@
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0006b	6a 08		 push	 8
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility

; 79   : 		{	// construct childless container

  0006d	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 778  : 		_Map = _Mapptr();

  00073	c7 47 04 00 00
	00 00		 mov	 DWORD PTR [edi+4], 0

; 779  : 		_Mapsize = 0;

  0007a	c7 47 08 00 00
	00 00		 mov	 DWORD PTR [edi+8], 0

; 780  : 		_Myoff = 0;

  00081	c7 47 0c 00 00
	00 00		 mov	 DWORD PTR [edi+12], 0

; 781  : 		_Mysize = 0;

  00088	c7 47 10 00 00
	00 00		 mov	 DWORD PTR [edi+16], 0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0008f	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00094	83 c4 08	 add	 esp, 8
  00097	85 c0		 test	 eax, eax
  00099	75 05		 jne	 SHORT $LN40@ChunkLoadT

; 29   : 		_Xbad_alloc();	// report no memory

  0009b	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN81@ChunkLoadT:
$LN40@ChunkLoadT:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 900  : 		this->_Myproxy = _Alproxy.allocate(1);

  000a0	89 07		 mov	 DWORD PTR [edi], eax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 617  : _VARIADIC_EXPAND_0X(_ALLOC_MEMBER_CONSTRUCT, , , , )

  000a2	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  000a8	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 902  : 		this->_Myproxy->_Mycont = this;

  000af	8b 07		 mov	 eax, DWORD PTR [edi]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 63   : 	return (_Check_C_return(_Mtx_init(_Mtx, _Type)));

  000b1	6a 02		 push	 2
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 902  : 		this->_Myproxy->_Mycont = this;

  000b3	89 38		 mov	 DWORD PTR [eax], edi
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\mutex

; 28   : 		_Mtx_initX(&_Mtx, _Flags | _Mtx_try);

  000b5	8d 86 34 04 00
	00		 lea	 eax, DWORD PTR [esi+1076]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 63   : 	return (_Check_C_return(_Mtx_init(_Mtx, _Type)));

  000bb	50		 push	 eax
  000bc	e8 00 00 00 00	 call	 __Mtx_init
  000c1	83 c4 08	 add	 esp, 8

; 32   : 	if (_Res != _Thrd_success)

  000c4	85 c0		 test	 eax, eax
  000c6	74 09		 je	 SHORT $LN76@ChunkLoadT

; 33   : 		_Throw_C_error(_Res);

  000c8	50		 push	 eax
  000c9	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
  000ce	83 c4 04	 add	 esp, 4
$LN76@ChunkLoadT:
  000d1	8b c6		 mov	 eax, esi
  000d3	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000d6	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000dd	59		 pop	 ecx
  000de	5f		 pop	 edi
  000df	5e		 pop	 esi
  000e0	8b e5		 mov	 esp, ebp
  000e2	5d		 pop	 ebp
  000e3	c3		 ret	 0
$LN80@ChunkLoadT:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0ChunkLoadThread@@QAE@XZ$3:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	83 c1 04	 add	 ecx, 4
  00006	e9 00 00 00 00	 jmp	 ??1thread@std@@QAE@XZ	; std::thread::~thread
__unwindfunclet$??0ChunkLoadThread@@QAE@XZ$0:
  0000b	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e9 00 00 00 00	 jmp	 ??1Thread@@QAE@XZ
__ehhandler$??0ChunkLoadThread@@QAE@XZ:
  00013	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00017	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001a	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  0001d	33 c8		 xor	 ecx, eax
  0001f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00024	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0ChunkLoadThread@@QAE@XZ
  00029	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0ChunkLoadThread@@QAE@XZ ENDP				; ChunkLoadThread::ChunkLoadThread
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\mutex
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\users\glenn\documents\github\wind\project\wind\wind\memutil.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thread
;	COMDAT ??1ChunkLoadThread@@QAE@XZ
_TEXT	SEGMENT
??1ChunkLoadThread@@QAE@XZ PROC				; ChunkLoadThread::~ChunkLoadThread, COMDAT
; _this$ = ecx
  00000	56		 push	 esi
  00001	57		 push	 edi
  00002	8b f9		 mov	 edi, ecx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\mutex

; 33   : 		_Mtx_destroy(&_Mtx);

  00004	8d 87 34 04 00
	00		 lea	 eax, DWORD PTR [edi+1076]
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 __Mtx_destroy
  00010	83 c4 04	 add	 esp, 4
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 1222 : 		_Tidy();

  00013	8d 8f 20 04 00
	00		 lea	 ecx, DWORD PTR [edi+1056]
  00019	e8 00 00 00 00	 call	 ?_Tidy@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IAEXXZ ; std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::_Tidy
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 586  : 		::operator delete(_Ptr);

  0001e	ff b7 20 04 00
	00		 push	 DWORD PTR [edi+1056]
  00024	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 912  : 		this->_Myproxy = 0;

  00029	c7 87 20 04 00
	00 00 00 00 00	 mov	 DWORD PTR [edi+1056], 0
; File c:\users\glenn\documents\github\wind\project\wind\wind\memutil.cpp

; 13   : 	delete[] heap;

  00033	ff b7 14 04 00
	00		 push	 DWORD PTR [edi+1044]
  00039	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0003e	83 c4 08	 add	 esp, 8
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thread

; 83   : 		return (!_Thr_is_null(_Thr));

  00041	83 7f 08 00	 cmp	 DWORD PTR [edi+8], 0
  00045	5f		 pop	 edi
  00046	5e		 pop	 esi

; 57   : 		if (joinable())

  00047	75 01		 jne	 SHORT $LN35@ChunkLoadT
  00049	c3		 ret	 0
$LN35@ChunkLoadT:

; 58   : 			_XSTD terminate();

  0004a	e8 00 00 00 00	 call	 ?terminate@@YAXXZ	; terminate
$LN37@ChunkLoadT:
$LN34@ChunkLoadT:
  0004f	cc		 int	 3
??1ChunkLoadThread@@QAE@XZ ENDP				; ChunkLoadThread::~ChunkLoadThread
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\threads.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\memutil.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\threads.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\memutil.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\threads.cpp
;	COMDAT ??__ErenderThread@@YAXXZ
text$yc	SEGMENT
__$EHRec$ = -12						; size = 12
??__ErenderThread@@YAXXZ PROC				; `dynamic initializer for 'renderThread'', COMDAT

; 5    : RenderThread renderThread;

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??__ErenderThread@@YAXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00016	33 c5		 xor	 eax, ebp
  00018	50		 push	 eax
  00019	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
; File c:\users\glenn\documents\github\wind\project\wind\wind\memutil.cpp

; 7    : {

  00022	68 02 10 00 00	 push	 4098			; 00001002H
  00027	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0002e	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
; File c:\users\glenn\documents\github\wind\project\wind\wind\threads.cpp

; 5    : RenderThread renderThread;

  00033	68 00 00 00 00	 push	 OFFSET ??__FrenderThread@@YAXXZ ; `dynamic atexit destructor for 'renderThread''
; File c:\users\glenn\documents\github\wind\project\wind\wind\memutil.cpp

; 7    : {

  00038	a3 14 04 00 00	 mov	 DWORD PTR ?renderThread@@3VRenderThread@@A+1044, eax
  0003d	c7 05 18 04 00
	00 02 10 00 00	 mov	 DWORD PTR ?renderThread@@3VRenderThread@@A+1048, 4098 ; 00001002H
  00047	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?renderThread@@3VRenderThread@@A, OFFSET ??_7RenderThread@@6B@
; File c:\users\glenn\documents\github\wind\project\wind\wind\threads.cpp

; 5    : RenderThread renderThread;

  00051	e8 00 00 00 00	 call	 _atexit
  00056	83 c4 08	 add	 esp, 8
  00059	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0005c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00063	59		 pop	 ecx
  00064	8b e5		 mov	 esp, ebp
  00066	5d		 pop	 ebp
  00067	c3		 ret	 0
text$yc	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??__ErenderThread@@YAXXZ$1:
  00000	b9 04 00 00 00	 mov	 ecx, OFFSET ?renderThread@@3VRenderThread@@A+4
  00005	e9 00 00 00 00	 jmp	 ??1thread@std@@QAE@XZ	; std::thread::~thread
__ehhandler$??__ErenderThread@@YAXXZ:
  0000a	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000e	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00011	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00014	33 c8		 xor	 ecx, eax
  00016	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001b	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??__ErenderThread@@YAXXZ
  00020	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??__ErenderThread@@YAXXZ ENDP				; `dynamic initializer for 'renderThread''
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\memutil.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thread
;	COMDAT ??__FrenderThread@@YAXXZ
text$yd	SEGMENT
??__FrenderThread@@YAXXZ PROC				; `dynamic atexit destructor for 'renderThread'', COMDAT
; File c:\users\glenn\documents\github\wind\project\wind\wind\memutil.cpp

; 13   : 	delete[] heap;

  00000	ff 35 14 04 00
	00		 push	 DWORD PTR ?renderThread@@3VRenderThread@@A+1044
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	83 c4 04	 add	 esp, 4
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thread

; 83   : 		return (!_Thr_is_null(_Thr));

  0000e	83 3d 08 00 00
	00 00		 cmp	 DWORD PTR ?renderThread@@3VRenderThread@@A+8, 0

; 57   : 		if (joinable())

  00015	0f 85 00 00 00
	00		 jne	 ?terminate@@YAXXZ	; terminate
  0001b	c3		 ret	 0
??__FrenderThread@@YAXXZ ENDP				; `dynamic atexit destructor for 'renderThread''
text$yd	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thread
; File c:\users\glenn\documents\github\wind\project\wind\wind\memutil.cpp
;	COMDAT ??0RenderThread@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0RenderThread@@QAE@XZ PROC				; RenderThread::RenderThread, COMDAT
; _this$dead$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0RenderThread@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _this$[ebp], OFFSET ?renderThread@@3VRenderThread@@A ; renderThread
  0002a	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?renderThread@@3VRenderThread@@A, OFFSET ??_7Thread@@6B@
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thread

; 39   : 		_Thr_set_null(_Thr);

  00034	c7 05 08 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?renderThread@@3VRenderThread@@A+8, 0
; File c:\users\glenn\documents\github\wind\project\wind\wind\memutil.cpp

; 7    : {

  0003e	68 02 10 00 00	 push	 4098			; 00001002H
  00043	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0004a	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0004f	a3 14 04 00 00	 mov	 DWORD PTR ?renderThread@@3VRenderThread@@A+1044, eax
  00054	83 c4 04	 add	 esp, 4
  00057	c7 05 18 04 00
	00 02 10 00 00	 mov	 DWORD PTR ?renderThread@@3VRenderThread@@A+1048, 4098 ; 00001002H
  00061	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?renderThread@@3VRenderThread@@A, OFFSET ??_7RenderThread@@6B@
  0006b	b8 00 00 00 00	 mov	 eax, OFFSET ?renderThread@@3VRenderThread@@A ; renderThread
  00070	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00073	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0007a	59		 pop	 ecx
  0007b	8b e5		 mov	 esp, ebp
  0007d	5d		 pop	 ebp
  0007e	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0RenderThread@@QAE@XZ$1:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	83 c1 04	 add	 ecx, 4
  00006	e9 00 00 00 00	 jmp	 ??1thread@std@@QAE@XZ	; std::thread::~thread
__ehhandler$??0RenderThread@@QAE@XZ:
  0000b	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000f	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00012	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00015	33 c8		 xor	 ecx, eax
  00017	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001c	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0RenderThread@@QAE@XZ
  00021	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0RenderThread@@QAE@XZ ENDP				; RenderThread::RenderThread
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\memutil.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thread
;	COMDAT ??1RenderThread@@QAE@XZ
_TEXT	SEGMENT
??1RenderThread@@QAE@XZ PROC				; RenderThread::~RenderThread, COMDAT
; _this$dead$ = ecx
; File c:\users\glenn\documents\github\wind\project\wind\wind\memutil.cpp

; 13   : 	delete[] heap;

  00000	ff 35 14 04 00
	00		 push	 DWORD PTR ?renderThread@@3VRenderThread@@A+1044
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	83 c4 04	 add	 esp, 4
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thread

; 83   : 		return (!_Thr_is_null(_Thr));

  0000e	83 3d 08 00 00
	00 00		 cmp	 DWORD PTR ?renderThread@@3VRenderThread@@A+8, 0

; 57   : 		if (joinable())

  00015	0f 85 00 00 00
	00		 jne	 ?terminate@@YAXXZ	; terminate
  0001b	c3		 ret	 0
??1RenderThread@@QAE@XZ ENDP				; RenderThread::~RenderThread
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\threads.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\list.h
; File c:\users\glenn\documents\github\wind\project\wind\wind\threads.cpp
;	COMDAT ?loop@Thread@@KAXPAV1@@Z
_TEXT	SEGMENT
_theThread$ = 8						; size = 4
?loop@Thread@@KAXPAV1@@Z PROC				; Thread::loop, COMDAT

; 8    : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 9    : 	theThread->preStart();

  00004	8b 75 08	 mov	 esi, DWORD PTR _theThread$[ebp]
  00007	8b ce		 mov	 ecx, esi
  00009	8b 06		 mov	 eax, DWORD PTR [esi]
  0000b	ff 50 04	 call	 DWORD PTR [eax+4]

; 10   : 	while(!theThread->quit)

  0000e	80 7e 0d 00	 cmp	 BYTE PTR [esi+13], 0
  00012	75 5b		 jne	 SHORT $LN25@loop
  00014	53		 push	 ebx
  00015	57		 push	 edi
$LL8@loop:

; 11   : 	{
; 12   : 		for(int i = 0; i < theThread->taskList.getSize(); i++)

  00016	33 ff		 xor	 edi, edi
  00018	39 be 10 04 00
	00		 cmp	 DWORD PTR [esi+1040], edi
  0001e	7e 2e		 jle	 SHORT $LN4@loop
  00020	8d 5e 10	 lea	 ebx, DWORD PTR [esi+16]
$LL6@loop:
; File c:\users\glenn\documents\github\wind\project\wind\wind\list.h

; 53   : 		return List::operator[](index);

  00023	8b 0b		 mov	 ecx, DWORD PTR [ebx]
; File c:\users\glenn\documents\github\wind\project\wind\wind\threads.cpp

; 14   : 			if(!theThread->taskList[i]->invoke())

  00025	8b 01		 mov	 eax, DWORD PTR [ecx]
  00027	8b 00		 mov	 eax, DWORD PTR [eax]
  00029	ff d0		 call	 eax
  0002b	0f b6 0d 00 00
	00 00		 movzx	 ecx, BYTE PTR ?stop@GlobalThread@@3_NA ; GlobalThread::stop
  00032	84 c0		 test	 al, al
  00034	b8 01 00 00 00	 mov	 eax, 1
  00039	0f 44 c8	 cmove	 ecx, eax
  0003c	47		 inc	 edi
  0003d	88 0d 00 00 00
	00		 mov	 BYTE PTR ?stop@GlobalThread@@3_NA, cl ; GlobalThread::stop
  00043	8d 5b 04	 lea	 ebx, DWORD PTR [ebx+4]
  00046	3b be 10 04 00
	00		 cmp	 edi, DWORD PTR [esi+1040]
  0004c	7c d5		 jl	 SHORT $LL6@loop
$LN4@loop:

; 15   : 			{
; 16   : 				GlobalThread::stop = true;
; 17   : 			}
; 18   : 		}
; 19   : 
; 20   : 		if(theThread->shouldTick())

  0004e	8b 06		 mov	 eax, DWORD PTR [esi]
  00050	8b ce		 mov	 ecx, esi
  00052	8b 00		 mov	 eax, DWORD PTR [eax]
  00054	ff d0		 call	 eax
  00056	84 c0		 test	 al, al
  00058	74 0d		 je	 SHORT $LN1@loop

; 21   : 		{
; 22   : 			if(!theThread->tick()) break;

  0005a	8b 06		 mov	 eax, DWORD PTR [esi]
  0005c	8b ce		 mov	 ecx, esi
  0005e	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  00061	ff d0		 call	 eax
  00063	84 c0		 test	 al, al
  00065	74 06		 je	 SHORT $LN26@loop
$LN1@loop:

; 10   : 	while(!theThread->quit)

  00067	80 7e 0d 00	 cmp	 BYTE PTR [esi+13], 0
  0006b	74 a9		 je	 SHORT $LL8@loop
$LN26@loop:
  0006d	5f		 pop	 edi
  0006e	5b		 pop	 ebx
$LN25@loop:

; 23   : 		}
; 24   : 	}
; 25   : 	theThread->postStop();

  0006f	8b 06		 mov	 eax, DWORD PTR [esi]
  00071	8b ce		 mov	 ecx, esi
  00073	5e		 pop	 esi

; 26   : }

  00074	5d		 pop	 ebp

; 23   : 		}
; 24   : 	}
; 25   : 	theThread->postStop();

  00075	ff 60 08	 jmp	 DWORD PTR [eax+8]
?loop@Thread@@KAXPAV1@@Z ENDP				; Thread::loop
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\threads.cpp
;	COMDAT ?shouldTick@Thread@@MAE_NXZ
_TEXT	SEGMENT
?shouldTick@Thread@@MAE_NXZ PROC			; Thread::shouldTick, COMDAT
; _this$ = ecx

; 30   : 	return true;

  00000	b0 01		 mov	 al, 1

; 31   : }

  00002	c3		 ret	 0
?shouldTick@Thread@@MAE_NXZ ENDP			; Thread::shouldTick
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\threads.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\users\glenn\documents\github\wind\project\wind\wind\threads.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xrefwrap
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\functional
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xrefwrap
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thread
; File c:\users\glenn\documents\github\wind\project\wind\wind\threads.cpp
;	COMDAT ?start@Thread@@UAE_NXZ
_TEXT	SEGMENT
_theThread$ = -52					; size = 4
$T2 = -48						; size = 8
__Launcher$3 = -40					; size = 24
__$EHRec$ = -12						; size = 12
?start@Thread@@UAE_NXZ PROC				; Thread::start, COMDAT
; _this$ = ecx

; 34   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	6a ff		 push	 -1
  00008	68 00 00 00 00	 push	 __ehhandler$?start@Thread@@UAE_NXZ
  0000d	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00013	50		 push	 eax
  00014	83 ec 28	 sub	 esp, 40			; 00000028H
  00017	56		 push	 esi
  00018	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001d	33 c4		 xor	 eax, esp
  0001f	50		 push	 eax
  00020	8d 44 24 30	 lea	 eax, DWORD PTR __$EHRec$[esp+60]
  00024	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002a	8b f1		 mov	 esi, ecx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 182  : 		{	// construct from target

  0002c	8d 4c 24 14	 lea	 ecx, DWORD PTR __Launcher$3[esp+60]
; File c:\users\glenn\documents\github\wind\project\wind\wind\threads.cpp

; 35   : 	started = true;

  00030	66 c7 46 0c 01
	00		 mov	 WORD PTR [esi+12], 1

; 36   : 	quit = false;
; 37   : 	Thread* theThread = this;

  00036	89 74 24 08	 mov	 DWORD PTR _theThread$[esp+60], esi
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 182  : 		{	// construct from target

  0003a	e8 00 00 00 00	 call	 ??0_Pad@std@@QAE@XZ	; std::_Pad::_Pad
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xrefwrap

; 346  : 		{	// construct

  0003f	8d 44 24 08	 lea	 eax, DWORD PTR _theThread$[esp+60]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 182  : 		{	// construct from target

  00043	c7 44 24 14 00
	00 00 00	 mov	 DWORD PTR __Launcher$3[esp+60], OFFSET ??_7?$_LaunchPad@V?$_Bind@$00XQ6AXPAVThread@@@ZV?$reference_wrapper@PAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@std@@@std@@6B@
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\functional

; 1152 : _VARIADIC_EXPAND_0X(_CLASS_BIND, , , , )

  0004b	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR __Launcher$3[esp+76], OFFSET ?loop@Thread@@KAXPAV1@@Z ; Thread::loop
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xrefwrap

; 346  : 		{	// construct

  00053	89 44 24 28	 mov	 DWORD PTR __Launcher$3[esp+80], eax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 206  : 	_Launcher._Launch(_Thr);

  00057	8d 44 24 0c	 lea	 eax, DWORD PTR $T2[esp+60]
  0005b	50		 push	 eax
  0005c	8d 4c 24 18	 lea	 ecx, DWORD PTR __Launcher$3[esp+64]
  00060	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+72], 0
  00068	e8 00 00 00 00	 call	 ?_Launch@_Pad@std@@QAEXPAU_Thrd_imp_t@@@Z ; std::_Pad::_Launch
  0006d	8d 4c 24 14	 lea	 ecx, DWORD PTR __Launcher$3[esp+60]

; 207  : 	}

  00071	c7 44 24 38 ff
	ff ff ff	 mov	 DWORD PTR __$EHRec$[esp+68], -1
  00079	e8 00 00 00 00	 call	 ??1_Pad@std@@QAE@XZ	; std::_Pad::~_Pad
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thread

; 83   : 		return (!_Thr_is_null(_Thr));

  0007e	83 7e 08 00	 cmp	 DWORD PTR [esi+8], 0

; 84   : 		}
; 85   : 
; 86   : 	void join();
; 87   : 
; 88   : 	void detach()
; 89   : 		{	// detach thread
; 90   : 		if (!joinable())
; 91   : 			_Throw_Cpp_error(_INVALID_ARGUMENT);
; 92   : 		_Thrd_detachX(_Thr);
; 93   : 		_Thr_set_null(_Thr);
; 94   : 		}
; 95   : 
; 96   : 	id get_id() const _NOEXCEPT;
; 97   : 
; 98   : 	static unsigned int hardware_concurrency() _NOEXCEPT
; 99   : 		{	// return number of hardware thread contexts
; 100  : 		return (::Concurrency::details::_GetConcurrency());
; 101  : 		}
; 102  : 
; 103  : 	native_handle_type native_handle()
; 104  : 		{	// return Win32 HANDLE as void *
; 105  : 		return (_Thr._Hnd);
; 106  : 		}
; 107  : 
; 108  : private:
; 109  : 	thread& _Move_thread(thread& _Other)
; 110  : 		{	// move from _Other
; 111  : 		if (joinable())

  00082	74 05		 je	 SHORT $LN152@start

; 112  : 			_XSTD terminate();

  00084	e8 00 00 00 00	 call	 ?terminate@@YAXXZ	; terminate
$LN168@start:
$LN152@start:

; 113  : 		_Thr = _Other._Thr;

  00089	8b 44 24 0c	 mov	 eax, DWORD PTR $T2[esp+60]
  0008d	89 46 04	 mov	 DWORD PTR [esi+4], eax
  00090	8b 44 24 10	 mov	 eax, DWORD PTR $T2[esp+64]
  00094	89 46 08	 mov	 DWORD PTR [esi+8], eax

; 83   : 		return (!_Thr_is_null(_Thr));

  00097	33 c0		 xor	 eax, eax
  00099	39 46 08	 cmp	 DWORD PTR [esi+8], eax
  0009c	0f 95 c0	 setne	 al
; File c:\users\glenn\documents\github\wind\project\wind\wind\threads.cpp

; 40   : }

  0009f	8b 4c 24 30	 mov	 ecx, DWORD PTR __$EHRec$[esp+60]
  000a3	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000aa	59		 pop	 ecx
  000ab	5e		 pop	 esi
  000ac	8b e5		 mov	 esp, ebp
  000ae	5d		 pop	 ebp
  000af	c3		 ret	 0
$LN167@start:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?start@Thread@@UAE_NXZ$1:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR __Launcher$3[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_LaunchPad@V?$_Bind@$00XQ6AXPAVThread@@@ZV?$reference_wrapper@PAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@std@@@std@@QAE@XZ
__ehhandler$?start@Thread@@UAE_NXZ:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 d4	 lea	 eax, DWORD PTR [edx-44]
  0000f	8b 4a d0	 mov	 ecx, DWORD PTR [edx-48]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?start@Thread@@UAE_NXZ
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?start@Thread@@UAE_NXZ ENDP				; Thread::start
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\threads.cpp
;	COMDAT ?stop@Thread@@UAE_NXZ
_TEXT	SEGMENT
?stop@Thread@@UAE_NXZ PROC				; Thread::stop, COMDAT
; _this$ = ecx

; 44   : 	quit = true;
; 45   : 	if(started) thread.join();

  00000	80 79 0c 00	 cmp	 BYTE PTR [ecx+12], 0
  00004	c6 41 0d 01	 mov	 BYTE PTR [ecx+13], 1
  00008	74 08		 je	 SHORT $LN4@stop
  0000a	83 c1 04	 add	 ecx, 4
  0000d	e8 00 00 00 00	 call	 ?join@thread@std@@QAEXXZ ; std::thread::join
$LN4@stop:

; 46   : 	return true;

  00012	b0 01		 mov	 al, 1

; 47   : }

  00014	c3		 ret	 0
?stop@Thread@@UAE_NXZ ENDP				; Thread::stop
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\threads.cpp
;	COMDAT ?preStart@Thread@@UAEXXZ
_TEXT	SEGMENT
?preStart@Thread@@UAEXXZ PROC				; Thread::preStart, COMDAT
; _this$ = ecx

; 51   : 
; 52   : }

  00000	c3		 ret	 0
?preStart@Thread@@UAEXXZ ENDP				; Thread::preStart
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\threads.cpp
;	COMDAT ?postStop@Thread@@UAEXXZ
_TEXT	SEGMENT
?postStop@Thread@@UAEXXZ PROC				; Thread::postStop, COMDAT
; _this$ = ecx

; 56   : 
; 57   : }

  00000	c3		 ret	 0
?postStop@Thread@@UAEXXZ ENDP				; Thread::postStop
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\threads.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\chrono
; File c:\users\glenn\documents\github\wind\project\wind\wind\threads.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\chrono
; File c:\users\glenn\documents\github\wind\project\wind\wind\threads.cpp
;	COMDAT ?shouldTick@LimitedThread@@MAE_NXZ
_TEXT	SEGMENT
?shouldTick@LimitedThread@@MAE_NXZ PROC			; LimitedThread::shouldTick, COMDAT
; _this$ = ecx

; 66   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	8b f9		 mov	 edi, ecx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\chrono

; 706  : 		return (time_point(duration(_Xtime_get_ticks())));

  0000a	e8 00 00 00 00	 call	 __Xtime_get_ticks

; 105  : 		{	// construct from representation

  0000f	2b 87 20 04 00
	00		 sub	 eax, DWORD PTR [edi+1056]

; 106  : 		static_assert(_Is_ratio<_Period>::value,
; 107  : 			"period not an instance of std::ratio");
; 108  : 		static_assert(0 < _Period::num,
; 109  : 			"duration negative or zero");
; 110  : 		}
; 111  : 
; 112  : 	template<class _Rep2,
; 113  : 		class _Period2>
; 114  : 		duration(const duration<_Rep2, _Period2>& _Dur,
; 115  : 			typename enable_if<treat_as_floating_point<_Rep>::value
; 116  : 				|| ratio_divide<_Period2, _Period>::type::den == 1
; 117  : 					&& !treat_as_floating_point<_Rep2>::value,
; 118  : 				void>::type ** = 0)
; 119  : 		: _MyRep(duration_cast<_Myt>(_Dur).count())
; 120  : 		{	// construct from a duration
; 121  : 		typedef typename ratio_divide<_Period2, _Period>::type _Checked_type;
; 122  : 
; 123  : 		static_assert(_Is_ratio<_Period>::value,
; 124  : 			"period not an instance of std::ratio");
; 125  : 		static_assert(0 < _Period::num,
; 126  : 			"duration negative or zero");
; 127  : 		}
; 128  : 
; 129  : 	_Rep count() const
; 130  : 		{	// get stored rep
; 131  : 		return (_MyRep);
; 132  : 		}
; 133  : 
; 134  : 	_Myt operator+() const
; 135  : 		{	// get value
; 136  : 		return (*this);
; 137  : 		}
; 138  : 
; 139  : 	_Myt operator-() const
; 140  : 		{	// get negated value
; 141  : 		return (_Myt(0 - _MyRep));
; 142  : 		}
; 143  : 
; 144  : 	_Myt& operator++()
; 145  : 		{	// increment rep
; 146  : 		++_MyRep;
; 147  : 		return (*this);
; 148  : 		}
; 149  : 
; 150  : 	_Myt operator++(int)
; 151  : 		{	// postincrement rep
; 152  : 		return (_Myt(_MyRep++));
; 153  : 		}
; 154  : 
; 155  : 	_Myt& operator--()
; 156  : 		{	// decrement rep
; 157  : 		--_MyRep;
; 158  : 		return (*this);
; 159  : 		}
; 160  : 
; 161  : 	_Myt operator--(int)
; 162  : 		{	// postdecrement rep
; 163  : 		return (_Myt(_MyRep--));
; 164  : 		}
; 165  : 
; 166  : 	_Myt& operator+=(const _Myt& _Right)
; 167  : 		{	// add _Right to rep
; 168  : 		_MyRep += _Right._MyRep;
; 169  : 		return (*this);
; 170  : 		}
; 171  : 
; 172  : 	_Myt& operator-=(const _Myt& _Right)
; 173  : 		{	// subtract _Right from rep
; 174  : 		_MyRep -= _Right._MyRep;
; 175  : 		return (*this);
; 176  : 		}
; 177  : 
; 178  : 	_Myt& operator*=(const _Rep& _Right)
; 179  : 		{	// multiply rep by _Right
; 180  : 		_MyRep *= _Right;
; 181  : 		return (*this);
; 182  : 		}
; 183  : 
; 184  : 	_Myt& operator/=(const _Rep& _Right)
; 185  : 		{	// divide rep by _Right
; 186  : 		_MyRep /= _Right;
; 187  : 		return (*this);
; 188  : 		}
; 189  : 
; 190  : 	_Myt& operator%=(const _Rep& _Right)
; 191  : 		{	// modulus rep by _Right
; 192  : 		_MyRep %= _Right;
; 193  : 		return (*this);
; 194  : 		}
; 195  : 
; 196  : 	_Myt& operator%=(const _Myt& _Right)
; 197  : 		{	// modulus rep by _Right
; 198  : 		_MyRep %= _Right.count();
; 199  : 		return (*this);
; 200  : 		}
; 201  : 
; 202  : 	static _Myt zero()
; 203  : 		{	// get zero value
; 204  : 		return (_Myt(duration_values<_Rep>::zero()));
; 205  : 		}
; 206  : 
; 207  : 	static _Myt (min)()
; 208  : 		{	// get minimum value
; 209  : 		return (_Myt((duration_values<_Rep>::min)()));
; 210  : 		}
; 211  : 	static _Myt (max)()
; 212  : 		{	// get maximum value
; 213  : 		return (_Myt((duration_values<_Rep>::max)()));
; 214  : 		}
; 215  : 
; 216  : private:
; 217  : 	_Rep _MyRep;	// the stored rep
; 218  : 	};
; 219  : 
; 220  : template<class _Rep1,
; 221  : 	class _Period1,
; 222  : 	class _Period2>
; 223  : 	class duration<duration<_Rep1, _Period1>, _Period2>
; 224  : 	{	// undefined: duration type as first template argument
; 225  : 	duration()
; 226  : 		{	// check asserts
; 227  : 		static_assert(_Always_false<_Rep1>::value,
; 228  : 			"duration can't have duration as first template argument");
; 229  : 		}
; 230  : 	};
; 231  : 
; 232  : 	// CLASS TEMPLATE _Is_duration
; 233  : template<class _Rep,
; 234  : 	class _Period>
; 235  : 	struct _Is_duration<duration<_Rep, _Period> >
; 236  : 	{	// tests for duration
; 237  : 	static const bool value = true;
; 238  : 	};
; 239  : 
; 240  : template<class _Clock,
; 241  : 	class _Duration = typename _Clock::duration>
; 242  : 	class time_point
; 243  : 	{	// represents a point in time
; 244  : public:
; 245  : 	typedef _Clock clock;
; 246  : 	typedef _Duration duration;
; 247  : 	typedef typename _Duration::rep rep;
; 248  : 	typedef typename _Duration::period period;
; 249  : 
; 250  : 	time_point()
; 251  : 		: _MyDur(_Duration::zero())
; 252  : 		{	// check asserts
; 253  : 		static_assert(_Is_duration<_Duration>::value,
; 254  : 			"duration must be an instance of std::duration");
; 255  : 		}
; 256  : 
; 257  : 	explicit time_point(const _Duration& _Other)
; 258  : 		: _MyDur(_Other)
; 259  : 		{	// construct from a duration
; 260  : 		}
; 261  : 
; 262  : 	template<class _Duration2>
; 263  : 		time_point(const time_point<_Clock, _Duration2>& _Tp,
; 264  : 			typename enable_if<is_convertible<_Duration2, _Duration>::value,
; 265  : 			void>::type ** = 0)
; 266  : 		: _MyDur(_Tp.time_since_epoch())
; 267  : 		{	// construct from another duration
; 268  : 		}
; 269  : 
; 270  : 	_Duration time_since_epoch() const
; 271  : 		{	// get duration from epoch
; 272  : 		return (_MyDur);
; 273  : 		}
; 274  : 
; 275  : 	time_point& operator+=(const _Duration& _Dur)
; 276  : 		{	// increment by duration
; 277  : 		_MyDur += _Dur;
; 278  : 		return (*this);
; 279  : 		}
; 280  : 
; 281  : 	time_point& operator-=(const _Duration& _Dur)
; 282  : 		{	// decrement by duration
; 283  : 		_MyDur -= _Dur;
; 284  : 		return (*this);
; 285  : 		}
; 286  : 
; 287  : 	static time_point (min)()
; 288  : 		{	// get minimum time point
; 289  : 		return (time_point((_Duration::min)()));
; 290  : 		}
; 291  : 	static time_point (max)()
; 292  : 		{	// get maximum time point
; 293  : 		return (time_point((_Duration::max)()));
; 294  : 		}
; 295  : 
; 296  : private:
; 297  : 	_Duration _MyDur;	// duration since the epoch
; 298  : 	};
; 299  : }	// namespace chrono
; 300  : 
; 301  : 	// CLASS TEMPLATE _Lcm (LEAST COMMON MULTIPLE)
; 302  : template<intmax_t _Ax,
; 303  : 	intmax_t _Bx>
; 304  : 	struct _Lcm
; 305  : 	{   /* compute least common multiple of _Ax and _Bx */
; 306  : 	static const intmax_t _Gx = _Gcd<_Ax, _Bx>::value;
; 307  : 	static const intmax_t value = (_Ax / _Gx) * _Bx;
; 308  : 	};
; 309  : 
; 310  : 	// CLASS TEMPLATE common_type SPECIALIZATIONS
; 311  : template<class _Rep1,
; 312  : 	class _Period1,
; 313  : 	class _Rep2,
; 314  : 	class _Period2>
; 315  : 	struct common_type<
; 316  : 		chrono::duration<_Rep1, _Period1>,
; 317  : 		chrono::duration<_Rep2, _Period2> >
; 318  : 	{	// common type of two durations
; 319  : 	typedef chrono::duration<typename common_type<_Rep1, _Rep2>::type,
; 320  : 		ratio<_Gcd<_Period1::num, _Period2::num>::value,
; 321  : 			_Lcm<_Period1::den, _Period2::den>::value> > type;
; 322  : 	};
; 323  : 
; 324  : template<class _Clock,
; 325  : 	class _Duration1,
; 326  : 	class _Duration2>
; 327  : 	struct common_type<
; 328  : 		chrono::time_point<_Clock, _Duration1>,
; 329  : 		chrono::time_point<_Clock, _Duration2> >
; 330  : 	{	// common type of two time points
; 331  : 	typedef chrono::time_point<
; 332  : 		_Clock, typename common_type<_Duration1, _Duration2>::type> type;
; 333  : 	};
; 334  : 
; 335  : namespace chrono {
; 336  : 	// duration ARITHMETIC
; 337  : template<class _Rep1,
; 338  : 	class _Period1,
; 339  : 	class _Rep2,
; 340  : 	class _Period2> inline
; 341  : 	typename common_type<
; 342  : 		duration<_Rep1, _Period1>,
; 343  : 		duration<_Rep2, _Period2> >::type
; 344  : 		operator+(
; 345  : 			const duration<_Rep1, _Period1>& _Left,
; 346  : 			const duration<_Rep2, _Period2>& _Right)
; 347  : 	{	// add two durations
; 348  : 	typedef typename common_type<
; 349  : 		duration<_Rep1, _Period1>,
; 350  : 		duration<_Rep2, _Period2> >::type _CD;
; 351  : 		return (_CD(_Left) += _Right);
; 352  : 		}
; 353  : 
; 354  : template<class _Rep1,
; 355  : 	class _Period1,
; 356  : 	class _Rep2,
; 357  : 	class _Period2> inline
; 358  : 	typename common_type<
; 359  : 		duration<_Rep1, _Period1>,
; 360  : 		duration<_Rep2, _Period2> >::type
; 361  : 		operator-(
; 362  : 			const duration<_Rep1, _Period1>& _Left,
; 363  : 			const duration<_Rep2, _Period2>& _Right)
; 364  : 	{	// subtract two durations
; 365  : 	typedef typename common_type<
; 366  : 		duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _CD;
; 367  : 	return (_CD(_Left) -= _Right);
; 368  : 	}
; 369  : 
; 370  : template<class _Rep1,
; 371  : 	class _Period1,
; 372  : 	class _Rep2> inline
; 373  : 	typename enable_if<is_convertible<_Rep2,
; 374  : 		typename common_type<_Rep1, _Rep2>::type>::value,
; 375  : 		duration<typename common_type<_Rep1, _Rep2>::type, _Period1> >::type
; 376  : 		operator*(
; 377  : 			const duration<_Rep1, _Period1>& _Left,
; 378  : 			const _Rep2& _Right)
; 379  : 	{	// multiply duration by rep
; 380  : 	typedef typename common_type<_Rep1, _Rep2>::type _CR;
; 381  : 	return (duration<_CR, _Period1>(_Left) *= _Right);
; 382  : 	}
; 383  : 
; 384  : template<class _Rep1,
; 385  : 	class _Rep2,
; 386  : 	class _Period2> inline
; 387  : 	typename enable_if<is_convertible<_Rep1,
; 388  : 		typename common_type<_Rep1, _Rep2>::type>::value,
; 389  : 		duration<typename common_type<_Rep1, _Rep2>::type, _Period2> >::type
; 390  : 		operator*(
; 391  : 			const _Rep1& _Left,
; 392  : 			const duration<_Rep2, _Period2>& _Right)
; 393  : 	{	// multiply rep by duration
; 394  : 	return (_Right * _Left);
; 395  : 	}
; 396  : 
; 397  : template<class _Rep1,
; 398  : 	class _Period1,
; 399  : 	class _Rep2> inline
; 400  : 	typename enable_if<is_convertible<_Rep2,
; 401  : 		typename common_type<_Rep1, _Rep2>::type>::value
; 402  : 		&& !_Is_duration<_Rep2>::value,
; 403  : 		duration<typename common_type<_Rep1, _Rep2>::type, _Period1> >::type
; 404  : 		operator/(
; 405  : 			const duration<_Rep1, _Period1>& _Left,
; 406  : 			const _Rep2& _Right)
; 407  : 	{	// divide duration by rep
; 408  : 	typedef typename common_type<_Rep1, _Rep2>::type _CR;
; 409  : 	return (duration<_CR, _Period1>(_Left) /= _Right);
; 410  : 	}
; 411  : 
; 412  : template<class _Rep1,
; 413  : 	class _Period1,
; 414  : 	class _Rep2,
; 415  : 	class _Period2> inline
; 416  : 	typename common_type<_Rep1, _Rep2>::type
; 417  : 		operator/(
; 418  : 			const duration<_Rep1, _Period1>& _Left,
; 419  : 			const duration<_Rep2, _Period2>& _Right)
; 420  : 	{	// divide duration by duration
; 421  : 	typedef typename common_type<
; 422  : 		duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _CD;
; 423  : 	return (_CD(_Left).count() / _CD(_Right).count());
; 424  : 	}
; 425  : 
; 426  : template<class _Rep1,
; 427  : 	class _Period1,
; 428  : 	class _Rep2> inline
; 429  : 	typename enable_if<is_convertible<_Rep2,
; 430  : 		typename common_type<_Rep1, _Rep2>::type>::value
; 431  : 		&& !_Is_duration<_Rep2>::value,
; 432  : 		duration<typename common_type<_Rep1, _Rep2>::type, _Period1> >::type
; 433  : 		operator%(
; 434  : 			const duration<_Rep1, _Period1>& _Left,
; 435  : 			const _Rep2& _Right)
; 436  : 	{	// divide duration by rep
; 437  : 	typedef typename common_type<_Rep1, _Rep2>::type _CR;
; 438  : 	return (duration<_CR, _Period1>(_Left) %= _Right);
; 439  : 	}
; 440  : 
; 441  : template<class _Rep1,
; 442  : 	class _Period1,
; 443  : 	class _Rep2,
; 444  : 	class _Period2> inline
; 445  : 	typename common_type<_Rep1, _Rep2>::type
; 446  : 		operator%(
; 447  : 			const duration<_Rep1, _Period1>& _Left,
; 448  : 			const duration<_Rep2, _Period2>& _Right)
; 449  : 	{	// divide duration by duration
; 450  : 	typedef typename common_type<
; 451  : 		duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _CD;
; 452  : 	return (_CD(_Left).count() % _CD(_Right).count());
; 453  : 	}
; 454  : 
; 455  : 	// duration COMPARISONS
; 456  : template<class _Rep1,
; 457  : 	class _Period1,
; 458  : 	class _Rep2,
; 459  : 	class _Period2> inline
; 460  : 	bool operator==(
; 461  : 		const duration<_Rep1, _Period1>& _Left,
; 462  : 		const duration<_Rep2, _Period2>& _Right)
; 463  : 	{	// test if duration == duration
; 464  : 	typedef typename common_type<
; 465  : 		duration<_Rep1, _Period1>,
; 466  : 		duration<_Rep2, _Period2> >::type _CT;
; 467  : 	return (_CT(_Left).count() == _CT(_Right).count());
; 468  : 	}
; 469  : 
; 470  : template<class _Rep1,
; 471  : 	class _Period1,
; 472  : 	class _Rep2,
; 473  : 	class _Period2> inline
; 474  : 	bool operator!=(
; 475  : 		const duration<_Rep1, _Period1>& _Left,
; 476  : 		const duration<_Rep2, _Period2>& _Right)
; 477  : 	{	// test if duration != duration
; 478  : 	return (!(_Left == _Right));
; 479  : 	}
; 480  : 
; 481  : template<class _Rep1,
; 482  : 	class _Period1,
; 483  : 	class _Rep2,
; 484  : 	class _Period2> inline
; 485  : 	bool operator<(
; 486  : 		const duration<_Rep1, _Period1>& _Left,
; 487  : 		const duration<_Rep2, _Period2>& _Right)
; 488  : 	{	// test if duration < duration
; 489  : 	typedef typename common_type<
; 490  : 		duration<_Rep1, _Period1>,
; 491  : 		duration<_Rep2, _Period2> >::type _CT;
; 492  : 	return (_CT(_Left).count() < _CT(_Right).count());
; 493  : 	}
; 494  : 
; 495  : template<class _Rep1,
; 496  : 	class _Period1,
; 497  : 	class _Rep2,
; 498  : 	class _Period2> inline
; 499  : 	bool operator<=(
; 500  : 		const duration<_Rep1, _Period1>& _Left,
; 501  : 		const duration<_Rep2, _Period2>& _Right)
; 502  : 	{	// test if duration <= duration
; 503  : 	return (!(_Right < _Left));
; 504  : 	}
; 505  : 
; 506  : template<class _Rep1,
; 507  : 	class _Period1,
; 508  : 	class _Rep2,
; 509  : 	class _Period2> inline
; 510  : 	bool operator>(
; 511  : 		const duration<_Rep1, _Period1>& _Left,
; 512  : 		const duration<_Rep2, _Period2>& _Right)
; 513  : 	{	// test if duration > duration
; 514  : 	return (_Right < _Left);
; 515  : 	}
; 516  : 
; 517  : template<class _Rep1,
; 518  : 	class _Period1,
; 519  : 	class _Rep2,
; 520  : 	class _Period2> inline
; 521  : 	bool operator>=(
; 522  : 		const duration<_Rep1, _Period1>& _Left,
; 523  : 		const duration<_Rep2, _Period2>& _Right)
; 524  : 	{	// test if duration >= duration
; 525  : 	return (!(_Left < _Right));
; 526  : 	}
; 527  : 
; 528  : 	// duration_cast
; 529  : template<class _To,
; 530  : 	class _Rep,
; 531  : 	class _Period> inline
; 532  : 	typename enable_if<_Is_duration<_To>::value,
; 533  : 		_To>::type
; 534  : 		duration_cast(const duration<_Rep, _Period>& _Dur)
; 535  : 	{	// convert duration to another duration
; 536  : 	typedef typename ratio_divide<_Period, typename _To::period>::type _CF;
; 537  : 	typedef typename common_type<
; 538  : 		typename common_type<typename _To::rep, _Rep>::type,
; 539  : 			intmax_t>::type _CR;
; 540  : 	if (_CF::num == 1 && _CF::den == 1)
; 541  : 		return (_To(static_cast<typename _To::rep>(_Dur.count())));
; 542  : 	else if (_CF::num != 1 && _CF::den == 1)
; 543  : 		return (_To(static_cast<typename _To::rep>(

  00015	6a 00		 push	 0

; 105  : 		{	// construct from representation

  00017	1b 97 24 04 00
	00		 sbb	 edx, DWORD PTR [edi+1060]

; 106  : 		static_assert(_Is_ratio<_Period>::value,
; 107  : 			"period not an instance of std::ratio");
; 108  : 		static_assert(0 < _Period::num,
; 109  : 			"duration negative or zero");
; 110  : 		}
; 111  : 
; 112  : 	template<class _Rep2,
; 113  : 		class _Period2>
; 114  : 		duration(const duration<_Rep2, _Period2>& _Dur,
; 115  : 			typename enable_if<treat_as_floating_point<_Rep>::value
; 116  : 				|| ratio_divide<_Period2, _Period>::type::den == 1
; 117  : 					&& !treat_as_floating_point<_Rep2>::value,
; 118  : 				void>::type ** = 0)
; 119  : 		: _MyRep(duration_cast<_Myt>(_Dur).count())
; 120  : 		{	// construct from a duration
; 121  : 		typedef typename ratio_divide<_Period2, _Period>::type _Checked_type;
; 122  : 
; 123  : 		static_assert(_Is_ratio<_Period>::value,
; 124  : 			"period not an instance of std::ratio");
; 125  : 		static_assert(0 < _Period::num,
; 126  : 			"duration negative or zero");
; 127  : 		}
; 128  : 
; 129  : 	_Rep count() const
; 130  : 		{	// get stored rep
; 131  : 		return (_MyRep);
; 132  : 		}
; 133  : 
; 134  : 	_Myt operator+() const
; 135  : 		{	// get value
; 136  : 		return (*this);
; 137  : 		}
; 138  : 
; 139  : 	_Myt operator-() const
; 140  : 		{	// get negated value
; 141  : 		return (_Myt(0 - _MyRep));
; 142  : 		}
; 143  : 
; 144  : 	_Myt& operator++()
; 145  : 		{	// increment rep
; 146  : 		++_MyRep;
; 147  : 		return (*this);
; 148  : 		}
; 149  : 
; 150  : 	_Myt operator++(int)
; 151  : 		{	// postincrement rep
; 152  : 		return (_Myt(_MyRep++));
; 153  : 		}
; 154  : 
; 155  : 	_Myt& operator--()
; 156  : 		{	// decrement rep
; 157  : 		--_MyRep;
; 158  : 		return (*this);
; 159  : 		}
; 160  : 
; 161  : 	_Myt operator--(int)
; 162  : 		{	// postdecrement rep
; 163  : 		return (_Myt(_MyRep--));
; 164  : 		}
; 165  : 
; 166  : 	_Myt& operator+=(const _Myt& _Right)
; 167  : 		{	// add _Right to rep
; 168  : 		_MyRep += _Right._MyRep;
; 169  : 		return (*this);
; 170  : 		}
; 171  : 
; 172  : 	_Myt& operator-=(const _Myt& _Right)
; 173  : 		{	// subtract _Right from rep
; 174  : 		_MyRep -= _Right._MyRep;
; 175  : 		return (*this);
; 176  : 		}
; 177  : 
; 178  : 	_Myt& operator*=(const _Rep& _Right)
; 179  : 		{	// multiply rep by _Right
; 180  : 		_MyRep *= _Right;
; 181  : 		return (*this);
; 182  : 		}
; 183  : 
; 184  : 	_Myt& operator/=(const _Rep& _Right)
; 185  : 		{	// divide rep by _Right
; 186  : 		_MyRep /= _Right;
; 187  : 		return (*this);
; 188  : 		}
; 189  : 
; 190  : 	_Myt& operator%=(const _Rep& _Right)
; 191  : 		{	// modulus rep by _Right
; 192  : 		_MyRep %= _Right;
; 193  : 		return (*this);
; 194  : 		}
; 195  : 
; 196  : 	_Myt& operator%=(const _Myt& _Right)
; 197  : 		{	// modulus rep by _Right
; 198  : 		_MyRep %= _Right.count();
; 199  : 		return (*this);
; 200  : 		}
; 201  : 
; 202  : 	static _Myt zero()
; 203  : 		{	// get zero value
; 204  : 		return (_Myt(duration_values<_Rep>::zero()));
; 205  : 		}
; 206  : 
; 207  : 	static _Myt (min)()
; 208  : 		{	// get minimum value
; 209  : 		return (_Myt((duration_values<_Rep>::min)()));
; 210  : 		}
; 211  : 	static _Myt (max)()
; 212  : 		{	// get maximum value
; 213  : 		return (_Myt((duration_values<_Rep>::max)()));
; 214  : 		}
; 215  : 
; 216  : private:
; 217  : 	_Rep _MyRep;	// the stored rep
; 218  : 	};
; 219  : 
; 220  : template<class _Rep1,
; 221  : 	class _Period1,
; 222  : 	class _Period2>
; 223  : 	class duration<duration<_Rep1, _Period1>, _Period2>
; 224  : 	{	// undefined: duration type as first template argument
; 225  : 	duration()
; 226  : 		{	// check asserts
; 227  : 		static_assert(_Always_false<_Rep1>::value,
; 228  : 			"duration can't have duration as first template argument");
; 229  : 		}
; 230  : 	};
; 231  : 
; 232  : 	// CLASS TEMPLATE _Is_duration
; 233  : template<class _Rep,
; 234  : 	class _Period>
; 235  : 	struct _Is_duration<duration<_Rep, _Period> >
; 236  : 	{	// tests for duration
; 237  : 	static const bool value = true;
; 238  : 	};
; 239  : 
; 240  : template<class _Clock,
; 241  : 	class _Duration = typename _Clock::duration>
; 242  : 	class time_point
; 243  : 	{	// represents a point in time
; 244  : public:
; 245  : 	typedef _Clock clock;
; 246  : 	typedef _Duration duration;
; 247  : 	typedef typename _Duration::rep rep;
; 248  : 	typedef typename _Duration::period period;
; 249  : 
; 250  : 	time_point()
; 251  : 		: _MyDur(_Duration::zero())
; 252  : 		{	// check asserts
; 253  : 		static_assert(_Is_duration<_Duration>::value,
; 254  : 			"duration must be an instance of std::duration");
; 255  : 		}
; 256  : 
; 257  : 	explicit time_point(const _Duration& _Other)
; 258  : 		: _MyDur(_Other)
; 259  : 		{	// construct from a duration
; 260  : 		}
; 261  : 
; 262  : 	template<class _Duration2>
; 263  : 		time_point(const time_point<_Clock, _Duration2>& _Tp,
; 264  : 			typename enable_if<is_convertible<_Duration2, _Duration>::value,
; 265  : 			void>::type ** = 0)
; 266  : 		: _MyDur(_Tp.time_since_epoch())
; 267  : 		{	// construct from another duration
; 268  : 		}
; 269  : 
; 270  : 	_Duration time_since_epoch() const
; 271  : 		{	// get duration from epoch
; 272  : 		return (_MyDur);
; 273  : 		}
; 274  : 
; 275  : 	time_point& operator+=(const _Duration& _Dur)
; 276  : 		{	// increment by duration
; 277  : 		_MyDur += _Dur;
; 278  : 		return (*this);
; 279  : 		}
; 280  : 
; 281  : 	time_point& operator-=(const _Duration& _Dur)
; 282  : 		{	// decrement by duration
; 283  : 		_MyDur -= _Dur;
; 284  : 		return (*this);
; 285  : 		}
; 286  : 
; 287  : 	static time_point (min)()
; 288  : 		{	// get minimum time point
; 289  : 		return (time_point((_Duration::min)()));
; 290  : 		}
; 291  : 	static time_point (max)()
; 292  : 		{	// get maximum time point
; 293  : 		return (time_point((_Duration::max)()));
; 294  : 		}
; 295  : 
; 296  : private:
; 297  : 	_Duration _MyDur;	// duration since the epoch
; 298  : 	};
; 299  : }	// namespace chrono
; 300  : 
; 301  : 	// CLASS TEMPLATE _Lcm (LEAST COMMON MULTIPLE)
; 302  : template<intmax_t _Ax,
; 303  : 	intmax_t _Bx>
; 304  : 	struct _Lcm
; 305  : 	{   /* compute least common multiple of _Ax and _Bx */
; 306  : 	static const intmax_t _Gx = _Gcd<_Ax, _Bx>::value;
; 307  : 	static const intmax_t value = (_Ax / _Gx) * _Bx;
; 308  : 	};
; 309  : 
; 310  : 	// CLASS TEMPLATE common_type SPECIALIZATIONS
; 311  : template<class _Rep1,
; 312  : 	class _Period1,
; 313  : 	class _Rep2,
; 314  : 	class _Period2>
; 315  : 	struct common_type<
; 316  : 		chrono::duration<_Rep1, _Period1>,
; 317  : 		chrono::duration<_Rep2, _Period2> >
; 318  : 	{	// common type of two durations
; 319  : 	typedef chrono::duration<typename common_type<_Rep1, _Rep2>::type,
; 320  : 		ratio<_Gcd<_Period1::num, _Period2::num>::value,
; 321  : 			_Lcm<_Period1::den, _Period2::den>::value> > type;
; 322  : 	};
; 323  : 
; 324  : template<class _Clock,
; 325  : 	class _Duration1,
; 326  : 	class _Duration2>
; 327  : 	struct common_type<
; 328  : 		chrono::time_point<_Clock, _Duration1>,
; 329  : 		chrono::time_point<_Clock, _Duration2> >
; 330  : 	{	// common type of two time points
; 331  : 	typedef chrono::time_point<
; 332  : 		_Clock, typename common_type<_Duration1, _Duration2>::type> type;
; 333  : 	};
; 334  : 
; 335  : namespace chrono {
; 336  : 	// duration ARITHMETIC
; 337  : template<class _Rep1,
; 338  : 	class _Period1,
; 339  : 	class _Rep2,
; 340  : 	class _Period2> inline
; 341  : 	typename common_type<
; 342  : 		duration<_Rep1, _Period1>,
; 343  : 		duration<_Rep2, _Period2> >::type
; 344  : 		operator+(
; 345  : 			const duration<_Rep1, _Period1>& _Left,
; 346  : 			const duration<_Rep2, _Period2>& _Right)
; 347  : 	{	// add two durations
; 348  : 	typedef typename common_type<
; 349  : 		duration<_Rep1, _Period1>,
; 350  : 		duration<_Rep2, _Period2> >::type _CD;
; 351  : 		return (_CD(_Left) += _Right);
; 352  : 		}
; 353  : 
; 354  : template<class _Rep1,
; 355  : 	class _Period1,
; 356  : 	class _Rep2,
; 357  : 	class _Period2> inline
; 358  : 	typename common_type<
; 359  : 		duration<_Rep1, _Period1>,
; 360  : 		duration<_Rep2, _Period2> >::type
; 361  : 		operator-(
; 362  : 			const duration<_Rep1, _Period1>& _Left,
; 363  : 			const duration<_Rep2, _Period2>& _Right)
; 364  : 	{	// subtract two durations
; 365  : 	typedef typename common_type<
; 366  : 		duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _CD;
; 367  : 	return (_CD(_Left) -= _Right);
; 368  : 	}
; 369  : 
; 370  : template<class _Rep1,
; 371  : 	class _Period1,
; 372  : 	class _Rep2> inline
; 373  : 	typename enable_if<is_convertible<_Rep2,
; 374  : 		typename common_type<_Rep1, _Rep2>::type>::value,
; 375  : 		duration<typename common_type<_Rep1, _Rep2>::type, _Period1> >::type
; 376  : 		operator*(
; 377  : 			const duration<_Rep1, _Period1>& _Left,
; 378  : 			const _Rep2& _Right)
; 379  : 	{	// multiply duration by rep
; 380  : 	typedef typename common_type<_Rep1, _Rep2>::type _CR;
; 381  : 	return (duration<_CR, _Period1>(_Left) *= _Right);
; 382  : 	}
; 383  : 
; 384  : template<class _Rep1,
; 385  : 	class _Rep2,
; 386  : 	class _Period2> inline
; 387  : 	typename enable_if<is_convertible<_Rep1,
; 388  : 		typename common_type<_Rep1, _Rep2>::type>::value,
; 389  : 		duration<typename common_type<_Rep1, _Rep2>::type, _Period2> >::type
; 390  : 		operator*(
; 391  : 			const _Rep1& _Left,
; 392  : 			const duration<_Rep2, _Period2>& _Right)
; 393  : 	{	// multiply rep by duration
; 394  : 	return (_Right * _Left);
; 395  : 	}
; 396  : 
; 397  : template<class _Rep1,
; 398  : 	class _Period1,
; 399  : 	class _Rep2> inline
; 400  : 	typename enable_if<is_convertible<_Rep2,
; 401  : 		typename common_type<_Rep1, _Rep2>::type>::value
; 402  : 		&& !_Is_duration<_Rep2>::value,
; 403  : 		duration<typename common_type<_Rep1, _Rep2>::type, _Period1> >::type
; 404  : 		operator/(
; 405  : 			const duration<_Rep1, _Period1>& _Left,
; 406  : 			const _Rep2& _Right)
; 407  : 	{	// divide duration by rep
; 408  : 	typedef typename common_type<_Rep1, _Rep2>::type _CR;
; 409  : 	return (duration<_CR, _Period1>(_Left) /= _Right);
; 410  : 	}
; 411  : 
; 412  : template<class _Rep1,
; 413  : 	class _Period1,
; 414  : 	class _Rep2,
; 415  : 	class _Period2> inline
; 416  : 	typename common_type<_Rep1, _Rep2>::type
; 417  : 		operator/(
; 418  : 			const duration<_Rep1, _Period1>& _Left,
; 419  : 			const duration<_Rep2, _Period2>& _Right)
; 420  : 	{	// divide duration by duration
; 421  : 	typedef typename common_type<
; 422  : 		duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _CD;
; 423  : 	return (_CD(_Left).count() / _CD(_Right).count());
; 424  : 	}
; 425  : 
; 426  : template<class _Rep1,
; 427  : 	class _Period1,
; 428  : 	class _Rep2> inline
; 429  : 	typename enable_if<is_convertible<_Rep2,
; 430  : 		typename common_type<_Rep1, _Rep2>::type>::value
; 431  : 		&& !_Is_duration<_Rep2>::value,
; 432  : 		duration<typename common_type<_Rep1, _Rep2>::type, _Period1> >::type
; 433  : 		operator%(
; 434  : 			const duration<_Rep1, _Period1>& _Left,
; 435  : 			const _Rep2& _Right)
; 436  : 	{	// divide duration by rep
; 437  : 	typedef typename common_type<_Rep1, _Rep2>::type _CR;
; 438  : 	return (duration<_CR, _Period1>(_Left) %= _Right);
; 439  : 	}
; 440  : 
; 441  : template<class _Rep1,
; 442  : 	class _Period1,
; 443  : 	class _Rep2,
; 444  : 	class _Period2> inline
; 445  : 	typename common_type<_Rep1, _Rep2>::type
; 446  : 		operator%(
; 447  : 			const duration<_Rep1, _Period1>& _Left,
; 448  : 			const duration<_Rep2, _Period2>& _Right)
; 449  : 	{	// divide duration by duration
; 450  : 	typedef typename common_type<
; 451  : 		duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _CD;
; 452  : 	return (_CD(_Left).count() % _CD(_Right).count());
; 453  : 	}
; 454  : 
; 455  : 	// duration COMPARISONS
; 456  : template<class _Rep1,
; 457  : 	class _Period1,
; 458  : 	class _Rep2,
; 459  : 	class _Period2> inline
; 460  : 	bool operator==(
; 461  : 		const duration<_Rep1, _Period1>& _Left,
; 462  : 		const duration<_Rep2, _Period2>& _Right)
; 463  : 	{	// test if duration == duration
; 464  : 	typedef typename common_type<
; 465  : 		duration<_Rep1, _Period1>,
; 466  : 		duration<_Rep2, _Period2> >::type _CT;
; 467  : 	return (_CT(_Left).count() == _CT(_Right).count());
; 468  : 	}
; 469  : 
; 470  : template<class _Rep1,
; 471  : 	class _Period1,
; 472  : 	class _Rep2,
; 473  : 	class _Period2> inline
; 474  : 	bool operator!=(
; 475  : 		const duration<_Rep1, _Period1>& _Left,
; 476  : 		const duration<_Rep2, _Period2>& _Right)
; 477  : 	{	// test if duration != duration
; 478  : 	return (!(_Left == _Right));
; 479  : 	}
; 480  : 
; 481  : template<class _Rep1,
; 482  : 	class _Period1,
; 483  : 	class _Rep2,
; 484  : 	class _Period2> inline
; 485  : 	bool operator<(
; 486  : 		const duration<_Rep1, _Period1>& _Left,
; 487  : 		const duration<_Rep2, _Period2>& _Right)
; 488  : 	{	// test if duration < duration
; 489  : 	typedef typename common_type<
; 490  : 		duration<_Rep1, _Period1>,
; 491  : 		duration<_Rep2, _Period2> >::type _CT;
; 492  : 	return (_CT(_Left).count() < _CT(_Right).count());
; 493  : 	}
; 494  : 
; 495  : template<class _Rep1,
; 496  : 	class _Period1,
; 497  : 	class _Rep2,
; 498  : 	class _Period2> inline
; 499  : 	bool operator<=(
; 500  : 		const duration<_Rep1, _Period1>& _Left,
; 501  : 		const duration<_Rep2, _Period2>& _Right)
; 502  : 	{	// test if duration <= duration
; 503  : 	return (!(_Right < _Left));
; 504  : 	}
; 505  : 
; 506  : template<class _Rep1,
; 507  : 	class _Period1,
; 508  : 	class _Rep2,
; 509  : 	class _Period2> inline
; 510  : 	bool operator>(
; 511  : 		const duration<_Rep1, _Period1>& _Left,
; 512  : 		const duration<_Rep2, _Period2>& _Right)
; 513  : 	{	// test if duration > duration
; 514  : 	return (_Right < _Left);
; 515  : 	}
; 516  : 
; 517  : template<class _Rep1,
; 518  : 	class _Period1,
; 519  : 	class _Rep2,
; 520  : 	class _Period2> inline
; 521  : 	bool operator>=(
; 522  : 		const duration<_Rep1, _Period1>& _Left,
; 523  : 		const duration<_Rep2, _Period2>& _Right)
; 524  : 	{	// test if duration >= duration
; 525  : 	return (!(_Left < _Right));
; 526  : 	}
; 527  : 
; 528  : 	// duration_cast
; 529  : template<class _To,
; 530  : 	class _Rep,
; 531  : 	class _Period> inline
; 532  : 	typename enable_if<_Is_duration<_To>::value,
; 533  : 		_To>::type
; 534  : 		duration_cast(const duration<_Rep, _Period>& _Dur)
; 535  : 	{	// convert duration to another duration
; 536  : 	typedef typename ratio_divide<_Period, typename _To::period>::type _CF;
; 537  : 	typedef typename common_type<
; 538  : 		typename common_type<typename _To::rep, _Rep>::type,
; 539  : 			intmax_t>::type _CR;
; 540  : 	if (_CF::num == 1 && _CF::den == 1)
; 541  : 		return (_To(static_cast<typename _To::rep>(_Dur.count())));
; 542  : 	else if (_CF::num != 1 && _CF::den == 1)
; 543  : 		return (_To(static_cast<typename _To::rep>(

  0001d	6a 64		 push	 100			; 00000064H
  0001f	52		 push	 edx
  00020	50		 push	 eax
  00021	e8 00 00 00 00	 call	 __allmul

; 105  : 		{	// construct from representation

  00026	8b f0		 mov	 esi, eax
; File c:\users\glenn\documents\github\wind\project\wind\wind\threads.cpp

; 70   : 	int tick = difference / tickTime;

  00028	8b 87 2c 04 00
	00		 mov	 eax, DWORD PTR [edi+1068]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\chrono

; 105  : 		{	// construct from representation

  0002e	8b ca		 mov	 ecx, edx
; File c:\users\glenn\documents\github\wind\project\wind\wind\threads.cpp

; 70   : 	int tick = difference / tickTime;

  00030	99		 cdq
  00031	52		 push	 edx
  00032	50		 push	 eax
  00033	51		 push	 ecx
  00034	56		 push	 esi
  00035	e8 00 00 00 00	 call	 __alldiv

; 71   : 	int ticksToProcess = tick - lastTick;

  0003a	8b c8		 mov	 ecx, eax
  0003c	2b 8f 28 04 00
	00		 sub	 ecx, DWORD PTR [edi+1064]

; 72   : 	lastTick = tick;

  00042	89 87 28 04 00
	00		 mov	 DWORD PTR [edi+1064], eax

; 73   : 
; 74   : 	if(ticksToProcess > 0)

  00048	85 c9		 test	 ecx, ecx
  0004a	7e 0f		 jle	 SHORT $LN1@shouldTick

; 75   : 	{
; 76   : 		lastTick++;

  0004c	40		 inc	 eax
  0004d	89 87 28 04 00
	00		 mov	 DWORD PTR [edi+1064], eax

; 77   : 		return true;

  00053	b0 01		 mov	 al, 1

; 78   : 	}
; 79   : 	return false;
; 80   : }

  00055	5f		 pop	 edi
  00056	5e		 pop	 esi
  00057	8b e5		 mov	 esp, ebp
  00059	5d		 pop	 ebp
  0005a	c3		 ret	 0
$LN1@shouldTick:
  0005b	5f		 pop	 edi
  0005c	32 c0		 xor	 al, al
  0005e	5e		 pop	 esi
  0005f	8b e5		 mov	 esp, ebp
  00061	5d		 pop	 ebp
  00062	c3		 ret	 0
?shouldTick@LimitedThread@@MAE_NXZ ENDP			; LimitedThread::shouldTick
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\threads.cpp
;	COMDAT ??__Eworld@GlobalThread@@YAXXZ
text$yc	SEGMENT
??__Eworld@GlobalThread@@YAXXZ PROC			; GlobalThread::`dynamic initializer for 'world'', COMDAT

; 85   : World GlobalThread::world;

  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?world@GlobalThread@@3VWorld@@A ; GlobalThread::world
  00005	e8 00 00 00 00	 call	 ??0World@@QAE@XZ	; World::World
  0000a	68 00 00 00 00	 push	 OFFSET ??__Fworld@GlobalThread@@YAXXZ ; GlobalThread::`dynamic atexit destructor for 'world''
  0000f	e8 00 00 00 00	 call	 _atexit
  00014	59		 pop	 ecx
  00015	c3		 ret	 0
??__Eworld@GlobalThread@@YAXXZ ENDP			; GlobalThread::`dynamic initializer for 'world''
text$yc	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??__Fworld@GlobalThread@@YAXXZ
text$yd	SEGMENT
??__Fworld@GlobalThread@@YAXXZ PROC			; GlobalThread::`dynamic atexit destructor for 'world'', COMDAT
  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?world@GlobalThread@@3VWorld@@A ; GlobalThread::world
  00005	e9 00 00 00 00	 jmp	 ??1World@@QAE@XZ	; World::~World
??__Fworld@GlobalThread@@YAXXZ ENDP			; GlobalThread::`dynamic atexit destructor for 'world''
text$yd	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\chrono
;	COMDAT ??0?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@chrono@std@@QAE@ABV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@12@@Z
_TEXT	SEGMENT
__Other$ = 8						; size = 4
??0?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@chrono@std@@QAE@ABV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@12@@Z PROC ; std::chrono::time_point<std::chrono::system_clock,std::chrono::duration<__int64,std::ratio<1,10000000> > >::time_point<std::chrono::system_clock,std::chrono::duration<__int64,std::ratio<1,10000000> > >, COMDAT
; _this$ = ecx

; 259  : 		{	// construct from a duration

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 55 08	 mov	 edx, DWORD PTR __Other$[ebp]
  00006	8b 02		 mov	 eax, DWORD PTR [edx]
  00008	89 01		 mov	 DWORD PTR [ecx], eax
  0000a	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0000d	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 260  : 		}

  00010	8b c1		 mov	 eax, ecx
  00012	5d		 pop	 ebp
  00013	c2 04 00	 ret	 4
??0?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@chrono@std@@QAE@ABV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@12@@Z ENDP ; std::chrono::time_point<std::chrono::system_clock,std::chrono::duration<__int64,std::ratio<1,10000000> > >::time_point<std::chrono::system_clock,std::chrono::duration<__int64,std::ratio<1,10000000> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\chrono
;	COMDAT ?time_since_epoch@?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@chrono@std@@QBE?AV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?time_since_epoch@?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@chrono@std@@QBE?AV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@XZ PROC ; std::chrono::time_point<std::chrono::system_clock,std::chrono::duration<__int64,std::ratio<1,10000000> > >::time_since_epoch, COMDAT
; _this$ = ecx

; 271  : 		{	// get duration from epoch

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 272  : 		return (_MyDur);

  00003	8b 11		 mov	 edx, DWORD PTR [ecx]
  00005	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00008	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0000b	89 10		 mov	 DWORD PTR [eax], edx
  0000d	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 273  : 		}

  00010	5d		 pop	 ebp
  00011	c2 04 00	 ret	 4
?time_since_epoch@?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@chrono@std@@QBE?AV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@XZ ENDP ; std::chrono::time_point<std::chrono::system_clock,std::chrono::duration<__int64,std::ratio<1,10000000> > >::time_since_epoch
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\chrono
;	COMDAT ?count@?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@chrono@std@@QBE_JXZ
_TEXT	SEGMENT
?count@?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@chrono@std@@QBE_JXZ PROC ; std::chrono::duration<__int64,std::ratio<1,10000000> >::count, COMDAT
; _this$ = ecx

; 131  : 		return (_MyRep);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]

; 132  : 		}

  00005	c3		 ret	 0
?count@?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@chrono@std@@QBE_JXZ ENDP ; std::chrono::duration<__int64,std::ratio<1,10000000> >::count
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\chrono
;	COMDAT ?count@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QBE_JXZ
_TEXT	SEGMENT
?count@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QBE_JXZ PROC ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::count, COMDAT
; _this$ = ecx

; 131  : 		return (_MyRep);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]

; 132  : 		}

  00005	c3		 ret	 0
?count@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QBE_JXZ ENDP ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::count
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\chrono
;	COMDAT ??$?0_J@?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@chrono@std@@QAE@AB_JPAPAX@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
___formal$dead$ = 12					; size = 4
??$?0_J@?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@chrono@std@@QAE@AB_JPAPAX@Z PROC ; std::chrono::duration<__int64,std::ratio<1,10000000> >::duration<__int64,std::ratio<1,10000000> ><__int64>, COMDAT
; _this$ = ecx

; 105  : 		{	// construct from representation

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 55 08	 mov	 edx, DWORD PTR __Val$[ebp]
  00006	8b 02		 mov	 eax, DWORD PTR [edx]
  00008	89 01		 mov	 DWORD PTR [ecx], eax
  0000a	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0000d	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 106  : 		static_assert(_Is_ratio<_Period>::value,
; 107  : 			"period not an instance of std::ratio");
; 108  : 		static_assert(0 < _Period::num,
; 109  : 			"duration negative or zero");
; 110  : 		}

  00010	8b c1		 mov	 eax, ecx
  00012	5d		 pop	 ebp
  00013	c2 08 00	 ret	 8
??$?0_J@?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@chrono@std@@QAE@AB_JPAPAX@Z ENDP ; std::chrono::duration<__int64,std::ratio<1,10000000> >::duration<__int64,std::ratio<1,10000000> ><__int64>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xrefwrap
;	COMDAT ??$ref@PAVThread@@@std@@YA?AV?$reference_wrapper@PAVThread@@@0@AAPAVThread@@@Z
_TEXT	SEGMENT
??$ref@PAVThread@@@std@@YA?AV?$reference_wrapper@PAVThread@@@0@AAPAVThread@@@Z PROC ; std::ref<Thread *>, COMDAT
; ___$ReturnUdt$ = ecx
; __Val$ = edx

; 346  : 		{	// construct

  00000	89 11		 mov	 DWORD PTR [ecx], edx

; 883  : 	return (reference_wrapper<_Ty>(_Val));

  00002	8b c1		 mov	 eax, ecx

; 884  : 	}

  00004	c3		 ret	 0
??$ref@PAVThread@@@std@@YA?AV?$reference_wrapper@PAVThread@@@0@AAPAVThread@@@Z ENDP ; std::ref<Thread *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thread
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xrefwrap
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xrefwrap
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\functional
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xrefwrap
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thread
;	COMDAT ??$?0P6AXPAVThread@@@ZV?$reference_wrapper@PAVThread@@@std@@@thread@std@@QAE@P6AXPAVThread@@@Z$$QAV?$reference_wrapper@PAVThread@@@1@@Z
_TEXT	SEGMENT
__Launcher$2 = -36					; size = 24
__$EHRec$ = -12						; size = 12
__Fx$dead$ = 8						; size = 4
__V0$ = 12						; size = 4
??$?0P6AXPAVThread@@@ZV?$reference_wrapper@PAVThread@@@std@@@thread@std@@QAE@P6AXPAVThread@@@Z$$QAV?$reference_wrapper@PAVThread@@@1@@Z PROC ; std::thread::thread<void (__cdecl*)(Thread *),std::reference_wrapper<Thread *> >, COMDAT
; _this$ = ecx

; 52   : _VARIADIC_EXPAND_0X(_THREAD_CONS, , , , )

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?0P6AXPAVThread@@@ZV?$reference_wrapper@PAVThread@@@std@@@thread@std@@QAE@P6AXPAVThread@@@Z$$QAV?$reference_wrapper@PAVThread@@@1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 18	 sub	 esp, 24			; 00000018H
  00014	56		 push	 esi
  00015	57		 push	 edi
  00016	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001b	33 c5		 xor	 eax, ebp
  0001d	50		 push	 eax
  0001e	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00021	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00027	8b f9		 mov	 edi, ecx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xrefwrap

; 351  : 		return (*_Ptr);

  00029	8b 45 0c	 mov	 eax, DWORD PTR __V0$[ebp]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 182  : 		{	// construct from target

  0002c	8d 4d dc	 lea	 ecx, DWORD PTR __Launcher$2[ebp]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xrefwrap

; 351  : 		return (*_Ptr);

  0002f	8b 30		 mov	 esi, DWORD PTR [eax]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 182  : 		{	// construct from target

  00031	e8 00 00 00 00	 call	 ??0_Pad@std@@QAE@XZ	; std::_Pad::_Pad
  00036	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR __Launcher$2[ebp], OFFSET ??_7?$_LaunchPad@V?$_Bind@$00XQ6AXPAVThread@@@ZV?$reference_wrapper@PAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@std@@@std@@6B@
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\functional

; 1152 : _VARIADIC_EXPAND_0X(_CLASS_BIND, , , , )

  0003d	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR __Launcher$2[ebp+16], OFFSET ?loop@Thread@@KAXPAV1@@Z ; Thread::loop
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xrefwrap

; 346  : 		{	// construct

  00044	89 75 f0	 mov	 DWORD PTR __Launcher$2[ebp+20], esi
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 206  : 	_Launcher._Launch(_Thr);

  00047	57		 push	 edi
  00048	8d 4d dc	 lea	 ecx, DWORD PTR __Launcher$2[ebp]
  0004b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00052	e8 00 00 00 00	 call	 ?_Launch@_Pad@std@@QAEXPAU_Thrd_imp_t@@@Z ; std::_Pad::_Launch
  00057	8d 4d dc	 lea	 ecx, DWORD PTR __Launcher$2[ebp]
  0005a	e8 00 00 00 00	 call	 ??1_Pad@std@@QAE@XZ	; std::_Pad::~_Pad
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thread

; 52   : _VARIADIC_EXPAND_0X(_THREAD_CONS, , , , )

  0005f	8b c7		 mov	 eax, edi
  00061	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00064	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0006b	59		 pop	 ecx
  0006c	5f		 pop	 edi
  0006d	5e		 pop	 esi
  0006e	8b e5		 mov	 esp, ebp
  00070	5d		 pop	 ebp
  00071	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$?0P6AXPAVThread@@@ZV?$reference_wrapper@PAVThread@@@std@@@thread@std@@QAE@P6AXPAVThread@@@Z$$QAV?$reference_wrapper@PAVThread@@@1@@Z$0:
  00000	8d 4d dc	 lea	 ecx, DWORD PTR __Launcher$2[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_LaunchPad@V?$_Bind@$00XQ6AXPAVThread@@@ZV?$reference_wrapper@PAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@std@@@std@@QAE@XZ
__ehhandler$??$?0P6AXPAVThread@@@ZV?$reference_wrapper@PAVThread@@@std@@@thread@std@@QAE@P6AXPAVThread@@@Z$$QAV?$reference_wrapper@PAVThread@@@1@@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a dc	 mov	 ecx, DWORD PTR [edx-36]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$?0P6AXPAVThread@@@ZV?$reference_wrapper@PAVThread@@@std@@@thread@std@@QAE@P6AXPAVThread@@@Z$$QAV?$reference_wrapper@PAVThread@@@1@@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$?0P6AXPAVThread@@@ZV?$reference_wrapper@PAVThread@@@std@@@thread@std@@QAE@P6AXPAVThread@@@Z$$QAV?$reference_wrapper@PAVThread@@@1@@Z ENDP ; std::thread::thread<void (__cdecl*)(Thread *),std::reference_wrapper<Thread *> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\chrono
;	COMDAT ??$?GUsystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@12@V312@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@01@ABV?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@01@0@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??$?GUsystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@12@V312@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@01@ABV?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@01@0@Z PROC ; std::chrono::operator-<std::chrono::system_clock,std::chrono::duration<__int64,std::ratio<1,10000000> >,std::chrono::duration<__int64,std::ratio<1,10000000> > >, COMDAT
; ___$ReturnUdt$ = ecx
; __Left$ = edx

; 613  : 	{	// add time_point to time_point

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 175  : 		return (*this);
; 176  : 		}
; 177  : 
; 178  : 	_Myt& operator*=(const _Rep& _Right)
; 179  : 		{	// multiply rep by _Right
; 180  : 		_MyRep *= _Right;
; 181  : 		return (*this);
; 182  : 		}
; 183  : 
; 184  : 	_Myt& operator/=(const _Rep& _Right)
; 185  : 		{	// divide rep by _Right
; 186  : 		_MyRep /= _Right;
; 187  : 		return (*this);
; 188  : 		}
; 189  : 
; 190  : 	_Myt& operator%=(const _Rep& _Right)
; 191  : 		{	// modulus rep by _Right
; 192  : 		_MyRep %= _Right;
; 193  : 		return (*this);
; 194  : 		}
; 195  : 
; 196  : 	_Myt& operator%=(const _Myt& _Right)
; 197  : 		{	// modulus rep by _Right
; 198  : 		_MyRep %= _Right.count();
; 199  : 		return (*this);
; 200  : 		}
; 201  : 
; 202  : 	static _Myt zero()
; 203  : 		{	// get zero value
; 204  : 		return (_Myt(duration_values<_Rep>::zero()));
; 205  : 		}
; 206  : 
; 207  : 	static _Myt (min)()
; 208  : 		{	// get minimum value
; 209  : 		return (_Myt((duration_values<_Rep>::min)()));
; 210  : 		}
; 211  : 	static _Myt (max)()
; 212  : 		{	// get maximum value
; 213  : 		return (_Myt((duration_values<_Rep>::max)()));
; 214  : 		}
; 215  : 
; 216  : private:
; 217  : 	_Rep _MyRep;	// the stored rep
; 218  : 	};
; 219  : 
; 220  : template<class _Rep1,
; 221  : 	class _Period1,
; 222  : 	class _Period2>
; 223  : 	class duration<duration<_Rep1, _Period1>, _Period2>
; 224  : 	{	// undefined: duration type as first template argument
; 225  : 	duration()
; 226  : 		{	// check asserts
; 227  : 		static_assert(_Always_false<_Rep1>::value,
; 228  : 			"duration can't have duration as first template argument");
; 229  : 		}
; 230  : 	};
; 231  : 
; 232  : 	// CLASS TEMPLATE _Is_duration
; 233  : template<class _Rep,
; 234  : 	class _Period>
; 235  : 	struct _Is_duration<duration<_Rep, _Period> >
; 236  : 	{	// tests for duration
; 237  : 	static const bool value = true;
; 238  : 	};
; 239  : 
; 240  : template<class _Clock,
; 241  : 	class _Duration = typename _Clock::duration>
; 242  : 	class time_point
; 243  : 	{	// represents a point in time
; 244  : public:
; 245  : 	typedef _Clock clock;
; 246  : 	typedef _Duration duration;
; 247  : 	typedef typename _Duration::rep rep;
; 248  : 	typedef typename _Duration::period period;
; 249  : 
; 250  : 	time_point()
; 251  : 		: _MyDur(_Duration::zero())
; 252  : 		{	// check asserts
; 253  : 		static_assert(_Is_duration<_Duration>::value,
; 254  : 			"duration must be an instance of std::duration");
; 255  : 		}
; 256  : 
; 257  : 	explicit time_point(const _Duration& _Other)
; 258  : 		: _MyDur(_Other)
; 259  : 		{	// construct from a duration
; 260  : 		}
; 261  : 
; 262  : 	template<class _Duration2>
; 263  : 		time_point(const time_point<_Clock, _Duration2>& _Tp,
; 264  : 			typename enable_if<is_convertible<_Duration2, _Duration>::value,
; 265  : 			void>::type ** = 0)
; 266  : 		: _MyDur(_Tp.time_since_epoch())
; 267  : 		{	// construct from another duration
; 268  : 		}
; 269  : 
; 270  : 	_Duration time_since_epoch() const
; 271  : 		{	// get duration from epoch
; 272  : 		return (_MyDur);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]

; 613  : 	{	// add time_point to time_point

  00006	53		 push	 ebx
  00007	56		 push	 esi

; 273  : 		}
; 274  : 
; 275  : 	time_point& operator+=(const _Duration& _Dur)
; 276  : 		{	// increment by duration
; 277  : 		_MyDur += _Dur;
; 278  : 		return (*this);
; 279  : 		}
; 280  : 
; 281  : 	time_point& operator-=(const _Duration& _Dur)
; 282  : 		{	// decrement by duration
; 283  : 		_MyDur -= _Dur;
; 284  : 		return (*this);
; 285  : 		}
; 286  : 
; 287  : 	static time_point (min)()
; 288  : 		{	// get minimum time point
; 289  : 		return (time_point((_Duration::min)()));
; 290  : 		}
; 291  : 	static time_point (max)()
; 292  : 		{	// get maximum time point
; 293  : 		return (time_point((_Duration::max)()));
; 294  : 		}
; 295  : 
; 296  : private:
; 297  : 	_Duration _MyDur;	// duration since the epoch
; 298  : 	};
; 299  : }	// namespace chrono
; 300  : 
; 301  : 	// CLASS TEMPLATE _Lcm (LEAST COMMON MULTIPLE)
; 302  : template<intmax_t _Ax,
; 303  : 	intmax_t _Bx>
; 304  : 	struct _Lcm
; 305  : 	{   /* compute least common multiple of _Ax and _Bx */
; 306  : 	static const intmax_t _Gx = _Gcd<_Ax, _Bx>::value;
; 307  : 	static const intmax_t value = (_Ax / _Gx) * _Bx;
; 308  : 	};
; 309  : 
; 310  : 	// CLASS TEMPLATE common_type SPECIALIZATIONS
; 311  : template<class _Rep1,
; 312  : 	class _Period1,
; 313  : 	class _Rep2,
; 314  : 	class _Period2>
; 315  : 	struct common_type<
; 316  : 		chrono::duration<_Rep1, _Period1>,
; 317  : 		chrono::duration<_Rep2, _Period2> >
; 318  : 	{	// common type of two durations
; 319  : 	typedef chrono::duration<typename common_type<_Rep1, _Rep2>::type,
; 320  : 		ratio<_Gcd<_Period1::num, _Period2::num>::value,
; 321  : 			_Lcm<_Period1::den, _Period2::den>::value> > type;
; 322  : 	};
; 323  : 
; 324  : template<class _Clock,
; 325  : 	class _Duration1,
; 326  : 	class _Duration2>
; 327  : 	struct common_type<
; 328  : 		chrono::time_point<_Clock, _Duration1>,
; 329  : 		chrono::time_point<_Clock, _Duration2> >
; 330  : 	{	// common type of two time points
; 331  : 	typedef chrono::time_point<
; 332  : 		_Clock, typename common_type<_Duration1, _Duration2>::type> type;
; 333  : 	};
; 334  : 
; 335  : namespace chrono {
; 336  : 	// duration ARITHMETIC
; 337  : template<class _Rep1,
; 338  : 	class _Period1,
; 339  : 	class _Rep2,
; 340  : 	class _Period2> inline
; 341  : 	typename common_type<
; 342  : 		duration<_Rep1, _Period1>,
; 343  : 		duration<_Rep2, _Period2> >::type
; 344  : 		operator+(
; 345  : 			const duration<_Rep1, _Period1>& _Left,
; 346  : 			const duration<_Rep2, _Period2>& _Right)
; 347  : 	{	// add two durations
; 348  : 	typedef typename common_type<
; 349  : 		duration<_Rep1, _Period1>,
; 350  : 		duration<_Rep2, _Period2> >::type _CD;
; 351  : 		return (_CD(_Left) += _Right);
; 352  : 		}
; 353  : 
; 354  : template<class _Rep1,
; 355  : 	class _Period1,
; 356  : 	class _Rep2,
; 357  : 	class _Period2> inline
; 358  : 	typename common_type<
; 359  : 		duration<_Rep1, _Period1>,
; 360  : 		duration<_Rep2, _Period2> >::type
; 361  : 		operator-(
; 362  : 			const duration<_Rep1, _Period1>& _Left,
; 363  : 			const duration<_Rep2, _Period2>& _Right)
; 364  : 	{	// subtract two durations
; 365  : 	typedef typename common_type<
; 366  : 		duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _CD;
; 367  : 	return (_CD(_Left) -= _Right);

  00008	8b 32		 mov	 esi, DWORD PTR [edx]

; 613  : 	{	// add time_point to time_point

  0000a	57		 push	 edi

; 175  : 		return (*this);
; 176  : 		}
; 177  : 
; 178  : 	_Myt& operator*=(const _Rep& _Right)
; 179  : 		{	// multiply rep by _Right
; 180  : 		_MyRep *= _Right;
; 181  : 		return (*this);
; 182  : 		}
; 183  : 
; 184  : 	_Myt& operator/=(const _Rep& _Right)
; 185  : 		{	// divide rep by _Right
; 186  : 		_MyRep /= _Right;
; 187  : 		return (*this);
; 188  : 		}
; 189  : 
; 190  : 	_Myt& operator%=(const _Rep& _Right)
; 191  : 		{	// modulus rep by _Right
; 192  : 		_MyRep %= _Right;
; 193  : 		return (*this);
; 194  : 		}
; 195  : 
; 196  : 	_Myt& operator%=(const _Myt& _Right)
; 197  : 		{	// modulus rep by _Right
; 198  : 		_MyRep %= _Right.count();
; 199  : 		return (*this);
; 200  : 		}
; 201  : 
; 202  : 	static _Myt zero()
; 203  : 		{	// get zero value
; 204  : 		return (_Myt(duration_values<_Rep>::zero()));
; 205  : 		}
; 206  : 
; 207  : 	static _Myt (min)()
; 208  : 		{	// get minimum value
; 209  : 		return (_Myt((duration_values<_Rep>::min)()));
; 210  : 		}
; 211  : 	static _Myt (max)()
; 212  : 		{	// get maximum value
; 213  : 		return (_Myt((duration_values<_Rep>::max)()));
; 214  : 		}
; 215  : 
; 216  : private:
; 217  : 	_Rep _MyRep;	// the stored rep
; 218  : 	};
; 219  : 
; 220  : template<class _Rep1,
; 221  : 	class _Period1,
; 222  : 	class _Period2>
; 223  : 	class duration<duration<_Rep1, _Period1>, _Period2>
; 224  : 	{	// undefined: duration type as first template argument
; 225  : 	duration()
; 226  : 		{	// check asserts
; 227  : 		static_assert(_Always_false<_Rep1>::value,
; 228  : 			"duration can't have duration as first template argument");
; 229  : 		}
; 230  : 	};
; 231  : 
; 232  : 	// CLASS TEMPLATE _Is_duration
; 233  : template<class _Rep,
; 234  : 	class _Period>
; 235  : 	struct _Is_duration<duration<_Rep, _Period> >
; 236  : 	{	// tests for duration
; 237  : 	static const bool value = true;
; 238  : 	};
; 239  : 
; 240  : template<class _Clock,
; 241  : 	class _Duration = typename _Clock::duration>
; 242  : 	class time_point
; 243  : 	{	// represents a point in time
; 244  : public:
; 245  : 	typedef _Clock clock;
; 246  : 	typedef _Duration duration;
; 247  : 	typedef typename _Duration::rep rep;
; 248  : 	typedef typename _Duration::period period;
; 249  : 
; 250  : 	time_point()
; 251  : 		: _MyDur(_Duration::zero())
; 252  : 		{	// check asserts
; 253  : 		static_assert(_Is_duration<_Duration>::value,
; 254  : 			"duration must be an instance of std::duration");
; 255  : 		}
; 256  : 
; 257  : 	explicit time_point(const _Duration& _Other)
; 258  : 		: _MyDur(_Other)
; 259  : 		{	// construct from a duration
; 260  : 		}
; 261  : 
; 262  : 	template<class _Duration2>
; 263  : 		time_point(const time_point<_Clock, _Duration2>& _Tp,
; 264  : 			typename enable_if<is_convertible<_Duration2, _Duration>::value,
; 265  : 			void>::type ** = 0)
; 266  : 		: _MyDur(_Tp.time_since_epoch())
; 267  : 		{	// construct from another duration
; 268  : 		}
; 269  : 
; 270  : 	_Duration time_since_epoch() const
; 271  : 		{	// get duration from epoch
; 272  : 		return (_MyDur);

  0000b	8b 38		 mov	 edi, DWORD PTR [eax]

; 613  : 	{	// add time_point to time_point

  0000d	8b d9		 mov	 ebx, ecx

; 175  : 		return (*this);
; 176  : 		}
; 177  : 
; 178  : 	_Myt& operator*=(const _Rep& _Right)
; 179  : 		{	// multiply rep by _Right
; 180  : 		_MyRep *= _Right;
; 181  : 		return (*this);
; 182  : 		}
; 183  : 
; 184  : 	_Myt& operator/=(const _Rep& _Right)
; 185  : 		{	// divide rep by _Right
; 186  : 		_MyRep /= _Right;
; 187  : 		return (*this);
; 188  : 		}
; 189  : 
; 190  : 	_Myt& operator%=(const _Rep& _Right)
; 191  : 		{	// modulus rep by _Right
; 192  : 		_MyRep %= _Right;
; 193  : 		return (*this);
; 194  : 		}
; 195  : 
; 196  : 	_Myt& operator%=(const _Myt& _Right)
; 197  : 		{	// modulus rep by _Right
; 198  : 		_MyRep %= _Right.count();
; 199  : 		return (*this);
; 200  : 		}
; 201  : 
; 202  : 	static _Myt zero()
; 203  : 		{	// get zero value
; 204  : 		return (_Myt(duration_values<_Rep>::zero()));
; 205  : 		}
; 206  : 
; 207  : 	static _Myt (min)()
; 208  : 		{	// get minimum value
; 209  : 		return (_Myt((duration_values<_Rep>::min)()));
; 210  : 		}
; 211  : 	static _Myt (max)()
; 212  : 		{	// get maximum value
; 213  : 		return (_Myt((duration_values<_Rep>::max)()));
; 214  : 		}
; 215  : 
; 216  : private:
; 217  : 	_Rep _MyRep;	// the stored rep
; 218  : 	};
; 219  : 
; 220  : template<class _Rep1,
; 221  : 	class _Period1,
; 222  : 	class _Period2>
; 223  : 	class duration<duration<_Rep1, _Period1>, _Period2>
; 224  : 	{	// undefined: duration type as first template argument
; 225  : 	duration()
; 226  : 		{	// check asserts
; 227  : 		static_assert(_Always_false<_Rep1>::value,
; 228  : 			"duration can't have duration as first template argument");
; 229  : 		}
; 230  : 	};
; 231  : 
; 232  : 	// CLASS TEMPLATE _Is_duration
; 233  : template<class _Rep,
; 234  : 	class _Period>
; 235  : 	struct _Is_duration<duration<_Rep, _Period> >
; 236  : 	{	// tests for duration
; 237  : 	static const bool value = true;
; 238  : 	};
; 239  : 
; 240  : template<class _Clock,
; 241  : 	class _Duration = typename _Clock::duration>
; 242  : 	class time_point
; 243  : 	{	// represents a point in time
; 244  : public:
; 245  : 	typedef _Clock clock;
; 246  : 	typedef _Duration duration;
; 247  : 	typedef typename _Duration::rep rep;
; 248  : 	typedef typename _Duration::period period;
; 249  : 
; 250  : 	time_point()
; 251  : 		: _MyDur(_Duration::zero())
; 252  : 		{	// check asserts
; 253  : 		static_assert(_Is_duration<_Duration>::value,
; 254  : 			"duration must be an instance of std::duration");
; 255  : 		}
; 256  : 
; 257  : 	explicit time_point(const _Duration& _Other)
; 258  : 		: _MyDur(_Other)
; 259  : 		{	// construct from a duration
; 260  : 		}
; 261  : 
; 262  : 	template<class _Duration2>
; 263  : 		time_point(const time_point<_Clock, _Duration2>& _Tp,
; 264  : 			typename enable_if<is_convertible<_Duration2, _Duration>::value,
; 265  : 			void>::type ** = 0)
; 266  : 		: _MyDur(_Tp.time_since_epoch())
; 267  : 		{	// construct from another duration
; 268  : 		}
; 269  : 
; 270  : 	_Duration time_since_epoch() const
; 271  : 		{	// get duration from epoch
; 272  : 		return (_MyDur);

  0000f	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]

; 273  : 		}
; 274  : 
; 275  : 	time_point& operator+=(const _Duration& _Dur)
; 276  : 		{	// increment by duration
; 277  : 		_MyDur += _Dur;
; 278  : 		return (*this);
; 279  : 		}
; 280  : 
; 281  : 	time_point& operator-=(const _Duration& _Dur)
; 282  : 		{	// decrement by duration
; 283  : 		_MyDur -= _Dur;
; 284  : 		return (*this);
; 285  : 		}
; 286  : 
; 287  : 	static time_point (min)()
; 288  : 		{	// get minimum time point
; 289  : 		return (time_point((_Duration::min)()));
; 290  : 		}
; 291  : 	static time_point (max)()
; 292  : 		{	// get maximum time point
; 293  : 		return (time_point((_Duration::max)()));
; 294  : 		}
; 295  : 
; 296  : private:
; 297  : 	_Duration _MyDur;	// duration since the epoch
; 298  : 	};
; 299  : }	// namespace chrono
; 300  : 
; 301  : 	// CLASS TEMPLATE _Lcm (LEAST COMMON MULTIPLE)
; 302  : template<intmax_t _Ax,
; 303  : 	intmax_t _Bx>
; 304  : 	struct _Lcm
; 305  : 	{   /* compute least common multiple of _Ax and _Bx */
; 306  : 	static const intmax_t _Gx = _Gcd<_Ax, _Bx>::value;
; 307  : 	static const intmax_t value = (_Ax / _Gx) * _Bx;
; 308  : 	};
; 309  : 
; 310  : 	// CLASS TEMPLATE common_type SPECIALIZATIONS
; 311  : template<class _Rep1,
; 312  : 	class _Period1,
; 313  : 	class _Rep2,
; 314  : 	class _Period2>
; 315  : 	struct common_type<
; 316  : 		chrono::duration<_Rep1, _Period1>,
; 317  : 		chrono::duration<_Rep2, _Period2> >
; 318  : 	{	// common type of two durations
; 319  : 	typedef chrono::duration<typename common_type<_Rep1, _Rep2>::type,
; 320  : 		ratio<_Gcd<_Period1::num, _Period2::num>::value,
; 321  : 			_Lcm<_Period1::den, _Period2::den>::value> > type;
; 322  : 	};
; 323  : 
; 324  : template<class _Clock,
; 325  : 	class _Duration1,
; 326  : 	class _Duration2>
; 327  : 	struct common_type<
; 328  : 		chrono::time_point<_Clock, _Duration1>,
; 329  : 		chrono::time_point<_Clock, _Duration2> >
; 330  : 	{	// common type of two time points
; 331  : 	typedef chrono::time_point<
; 332  : 		_Clock, typename common_type<_Duration1, _Duration2>::type> type;
; 333  : 	};
; 334  : 
; 335  : namespace chrono {
; 336  : 	// duration ARITHMETIC
; 337  : template<class _Rep1,
; 338  : 	class _Period1,
; 339  : 	class _Rep2,
; 340  : 	class _Period2> inline
; 341  : 	typename common_type<
; 342  : 		duration<_Rep1, _Period1>,
; 343  : 		duration<_Rep2, _Period2> >::type
; 344  : 		operator+(
; 345  : 			const duration<_Rep1, _Period1>& _Left,
; 346  : 			const duration<_Rep2, _Period2>& _Right)
; 347  : 	{	// add two durations
; 348  : 	typedef typename common_type<
; 349  : 		duration<_Rep1, _Period1>,
; 350  : 		duration<_Rep2, _Period2> >::type _CD;
; 351  : 		return (_CD(_Left) += _Right);
; 352  : 		}
; 353  : 
; 354  : template<class _Rep1,
; 355  : 	class _Period1,
; 356  : 	class _Rep2,
; 357  : 	class _Period2> inline
; 358  : 	typename common_type<
; 359  : 		duration<_Rep1, _Period1>,
; 360  : 		duration<_Rep2, _Period2> >::type
; 361  : 		operator-(
; 362  : 			const duration<_Rep1, _Period1>& _Left,
; 363  : 			const duration<_Rep2, _Period2>& _Right)
; 364  : 	{	// subtract two durations
; 365  : 	typedef typename common_type<
; 366  : 		duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _CD;
; 367  : 	return (_CD(_Left) -= _Right);

  00012	8b 42 04	 mov	 eax, DWORD PTR [edx+4]

; 174  : 		_MyRep -= _Right._MyRep;

  00015	2b f7		 sub	 esi, edi
  00017	1b c1		 sbb	 eax, ecx

; 614  : 	return (_Left.time_since_epoch() - _Right.time_since_epoch());
; 615  : 	}

  00019	5f		 pop	 edi

; 273  : 		}
; 274  : 
; 275  : 	time_point& operator+=(const _Duration& _Dur)
; 276  : 		{	// increment by duration
; 277  : 		_MyDur += _Dur;
; 278  : 		return (*this);
; 279  : 		}
; 280  : 
; 281  : 	time_point& operator-=(const _Duration& _Dur)
; 282  : 		{	// decrement by duration
; 283  : 		_MyDur -= _Dur;
; 284  : 		return (*this);
; 285  : 		}
; 286  : 
; 287  : 	static time_point (min)()
; 288  : 		{	// get minimum time point
; 289  : 		return (time_point((_Duration::min)()));
; 290  : 		}
; 291  : 	static time_point (max)()
; 292  : 		{	// get maximum time point
; 293  : 		return (time_point((_Duration::max)()));
; 294  : 		}
; 295  : 
; 296  : private:
; 297  : 	_Duration _MyDur;	// duration since the epoch
; 298  : 	};
; 299  : }	// namespace chrono
; 300  : 
; 301  : 	// CLASS TEMPLATE _Lcm (LEAST COMMON MULTIPLE)
; 302  : template<intmax_t _Ax,
; 303  : 	intmax_t _Bx>
; 304  : 	struct _Lcm
; 305  : 	{   /* compute least common multiple of _Ax and _Bx */
; 306  : 	static const intmax_t _Gx = _Gcd<_Ax, _Bx>::value;
; 307  : 	static const intmax_t value = (_Ax / _Gx) * _Bx;
; 308  : 	};
; 309  : 
; 310  : 	// CLASS TEMPLATE common_type SPECIALIZATIONS
; 311  : template<class _Rep1,
; 312  : 	class _Period1,
; 313  : 	class _Rep2,
; 314  : 	class _Period2>
; 315  : 	struct common_type<
; 316  : 		chrono::duration<_Rep1, _Period1>,
; 317  : 		chrono::duration<_Rep2, _Period2> >
; 318  : 	{	// common type of two durations
; 319  : 	typedef chrono::duration<typename common_type<_Rep1, _Rep2>::type,
; 320  : 		ratio<_Gcd<_Period1::num, _Period2::num>::value,
; 321  : 			_Lcm<_Period1::den, _Period2::den>::value> > type;
; 322  : 	};
; 323  : 
; 324  : template<class _Clock,
; 325  : 	class _Duration1,
; 326  : 	class _Duration2>
; 327  : 	struct common_type<
; 328  : 		chrono::time_point<_Clock, _Duration1>,
; 329  : 		chrono::time_point<_Clock, _Duration2> >
; 330  : 	{	// common type of two time points
; 331  : 	typedef chrono::time_point<
; 332  : 		_Clock, typename common_type<_Duration1, _Duration2>::type> type;
; 333  : 	};
; 334  : 
; 335  : namespace chrono {
; 336  : 	// duration ARITHMETIC
; 337  : template<class _Rep1,
; 338  : 	class _Period1,
; 339  : 	class _Rep2,
; 340  : 	class _Period2> inline
; 341  : 	typename common_type<
; 342  : 		duration<_Rep1, _Period1>,
; 343  : 		duration<_Rep2, _Period2> >::type
; 344  : 		operator+(
; 345  : 			const duration<_Rep1, _Period1>& _Left,
; 346  : 			const duration<_Rep2, _Period2>& _Right)
; 347  : 	{	// add two durations
; 348  : 	typedef typename common_type<
; 349  : 		duration<_Rep1, _Period1>,
; 350  : 		duration<_Rep2, _Period2> >::type _CD;
; 351  : 		return (_CD(_Left) += _Right);
; 352  : 		}
; 353  : 
; 354  : template<class _Rep1,
; 355  : 	class _Period1,
; 356  : 	class _Rep2,
; 357  : 	class _Period2> inline
; 358  : 	typename common_type<
; 359  : 		duration<_Rep1, _Period1>,
; 360  : 		duration<_Rep2, _Period2> >::type
; 361  : 		operator-(
; 362  : 			const duration<_Rep1, _Period1>& _Left,
; 363  : 			const duration<_Rep2, _Period2>& _Right)
; 364  : 	{	// subtract two durations
; 365  : 	typedef typename common_type<
; 366  : 		duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _CD;
; 367  : 	return (_CD(_Left) -= _Right);

  0001a	89 33		 mov	 DWORD PTR [ebx], esi
  0001c	89 43 04	 mov	 DWORD PTR [ebx+4], eax

; 614  : 	return (_Left.time_since_epoch() - _Right.time_since_epoch());
; 615  : 	}

  0001f	5e		 pop	 esi
  00020	8b c3		 mov	 eax, ebx
  00022	5b		 pop	 ebx
  00023	5d		 pop	 ebp
  00024	c3		 ret	 0
??$?GUsystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@12@V312@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@01@ABV?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@01@0@Z ENDP ; std::chrono::operator-<std::chrono::system_clock,std::chrono::duration<__int64,std::ratio<1,10000000> >,std::chrono::duration<__int64,std::ratio<1,10000000> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\chrono
;	COMDAT ??$duration_cast@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@_JU?$ratio@$00$0JIJGIA@@3@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@ABV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@01@@Z
_TEXT	SEGMENT
??$duration_cast@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@_JU?$ratio@$00$0JIJGIA@@3@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@ABV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@01@@Z PROC ; std::chrono::duration_cast<std::chrono::duration<__int64,std::ratio<1,1000000000> >,__int64,std::ratio<1,10000000> >, COMDAT
; ___$ReturnUdt$ = ecx
; __Dur$ = edx

; 535  : 	{	// convert duration to another duration

  00000	56		 push	 esi

; 536  : 	typedef typename ratio_divide<_Period, typename _To::period>::type _CF;
; 537  : 	typedef typename common_type<
; 538  : 		typename common_type<typename _To::rep, _Rep>::type,
; 539  : 			intmax_t>::type _CR;
; 540  : 	if (_CF::num == 1 && _CF::den == 1)
; 541  : 		return (_To(static_cast<typename _To::rep>(_Dur.count())));
; 542  : 	else if (_CF::num != 1 && _CF::den == 1)
; 543  : 		return (_To(static_cast<typename _To::rep>(

  00001	6a 00		 push	 0
  00003	6a 64		 push	 100			; 00000064H
  00005	ff 72 04	 push	 DWORD PTR [edx+4]
  00008	8b f1		 mov	 esi, ecx
  0000a	ff 32		 push	 DWORD PTR [edx]
  0000c	e8 00 00 00 00	 call	 __allmul

; 105  : 		{	// construct from representation

  00011	89 06		 mov	 DWORD PTR [esi], eax
  00013	89 56 04	 mov	 DWORD PTR [esi+4], edx

; 536  : 	typedef typename ratio_divide<_Period, typename _To::period>::type _CF;
; 537  : 	typedef typename common_type<
; 538  : 		typename common_type<typename _To::rep, _Rep>::type,
; 539  : 			intmax_t>::type _CR;
; 540  : 	if (_CF::num == 1 && _CF::den == 1)
; 541  : 		return (_To(static_cast<typename _To::rep>(_Dur.count())));
; 542  : 	else if (_CF::num != 1 && _CF::den == 1)
; 543  : 		return (_To(static_cast<typename _To::rep>(

  00016	8b c6		 mov	 eax, esi

; 544  : 			static_cast<_CR>(_Dur.count())) * static_cast<_CR>(_CF::num)));
; 545  : 	else if (_CF::num == 1 && _CF::den != 1)
; 546  : 		return (_To(static_cast<typename _To::rep>(
; 547  : 			static_cast<_CR>(_Dur.count()) / static_cast<_CR>(_CF::den))));
; 548  : 	else
; 549  : 		return (_To(static_cast<typename _To::rep>(
; 550  : 			static_cast<_CR>(_Dur.count()) * static_cast<_CR>(_CF::num)
; 551  : 			/ static_cast<_CR>(_CF::den))));
; 552  : 	}

  00018	5e		 pop	 esi
  00019	c3		 ret	 0
??$duration_cast@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@_JU?$ratio@$00$0JIJGIA@@3@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@ABV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@01@@Z ENDP ; std::chrono::duration_cast<std::chrono::duration<__int64,std::ratio<1,1000000000> >,__int64,std::ratio<1,10000000> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xrefwrap
;	COMDAT ??0?$reference_wrapper@PAVThread@@@std@@QAE@AAPAVThread@@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??0?$reference_wrapper@PAVThread@@@std@@QAE@AAPAVThread@@@Z PROC ; std::reference_wrapper<Thread *>::reference_wrapper<Thread *>, COMDAT
; _this$ = ecx

; 864  : 		{	// construct

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 346  : 		{	// construct

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 865  : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
??0?$reference_wrapper@PAVThread@@@std@@QAE@AAPAVThread@@@Z ENDP ; std::reference_wrapper<Thread *>::reference_wrapper<Thread *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xrefwrap
;	COMDAT ??B?$reference_wrapper@PAVThread@@@std@@QBEAAPAVThread@@XZ
_TEXT	SEGMENT
??B?$reference_wrapper@PAVThread@@@std@@QBEAAPAVThread@@XZ PROC ; std::reference_wrapper<Thread *>::operator Thread * &, COMDAT
; _this$ = ecx

; 869  : 		return (this->_Get());

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 870  : 		}

  00002	c3		 ret	 0
??B?$reference_wrapper@PAVThread@@@std@@QBEAAPAVThread@@XZ ENDP ; std::reference_wrapper<Thread *>::operator Thread * &
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xrefwrap
;	COMDAT ??0?$_Refwrap_impl@PAVThread@@@std@@QAE@AAPAVThread@@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??0?$_Refwrap_impl@PAVThread@@@std@@QAE@AAPAVThread@@@Z PROC ; std::_Refwrap_impl<Thread *>::_Refwrap_impl<Thread *>, COMDAT
; _this$ = ecx

; 719  : 		{	// construct

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 346  : 		{	// construct

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 720  : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
??0?$_Refwrap_impl@PAVThread@@@std@@QAE@AAPAVThread@@@Z ENDP ; std::_Refwrap_impl<Thread *>::_Refwrap_impl<Thread *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xrefwrap
;	COMDAT ?_Get@?$_Call_wrapper_base@U?$_Callable_obj@PAVThread@@$00@std@@@std@@QBEAAPAVThread@@XZ
_TEXT	SEGMENT
?_Get@?$_Call_wrapper_base@U?$_Callable_obj@PAVThread@@$00@std@@@std@@QBEAAPAVThread@@XZ PROC ; std::_Call_wrapper_base<std::_Callable_obj<Thread *,1> >::_Get, COMDAT
; _this$ = ecx

; 567  : 		return (_Callee._Get());

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 568  : 		}

  00002	c3		 ret	 0
?_Get@?$_Call_wrapper_base@U?$_Callable_obj@PAVThread@@$00@std@@@std@@QBEAAPAVThread@@XZ ENDP ; std::_Call_wrapper_base<std::_Callable_obj<Thread *,1> >::_Get
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xrefwrap
;	COMDAT ??0?$_Call_wrapper@U?$_Callable_obj@PAVThread@@$00@std@@$0A@@std@@QAE@AAPAVThread@@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??0?$_Call_wrapper@U?$_Callable_obj@PAVThread@@$00@std@@$0A@@std@@QAE@AAPAVThread@@@Z PROC ; std::_Call_wrapper<std::_Callable_obj<Thread *,1>,0>::_Call_wrapper<std::_Callable_obj<Thread *,1>,0>, COMDAT
; _this$ = ecx

; 588  : 		{	// construct

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 346  : 		{	// construct

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 589  : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
??0?$_Call_wrapper@U?$_Callable_obj@PAVThread@@$00@std@@$0A@@std@@QAE@AAPAVThread@@@Z ENDP ; std::_Call_wrapper<std::_Callable_obj<Thread *,1>,0>::_Call_wrapper<std::_Callable_obj<Thread *,1>,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xrefwrap
;	COMDAT ?_Get@?$_Callable_base@PAVThread@@$00@std@@QBEAAPAVThread@@XZ
_TEXT	SEGMENT
?_Get@?$_Callable_base@PAVThread@@$00@std@@QBEAAPAVThread@@XZ PROC ; std::_Callable_base<Thread *,1>::_Get, COMDAT
; _this$ = ecx

; 351  : 		return (*_Ptr);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 352  : 		}

  00002	c3		 ret	 0
?_Get@?$_Callable_base@PAVThread@@$00@std@@QBEAAPAVThread@@XZ ENDP ; std::_Callable_base<Thread *,1>::_Get
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xrefwrap
;	COMDAT ??0?$_Call_wrapper_base@U?$_Callable_obj@PAVThread@@$00@std@@@std@@QAE@AAPAVThread@@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??0?$_Call_wrapper_base@U?$_Callable_obj@PAVThread@@$00@std@@@std@@QAE@AAPAVThread@@@Z PROC ; std::_Call_wrapper_base<std::_Callable_obj<Thread *,1> >::_Call_wrapper_base<std::_Callable_obj<Thread *,1> >, COMDAT
; _this$ = ecx

; 557  : 		{	// construct

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 346  : 		{	// construct

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 558  : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
??0?$_Call_wrapper_base@U?$_Callable_obj@PAVThread@@$00@std@@@std@@QAE@AAPAVThread@@@Z ENDP ; std::_Call_wrapper_base<std::_Callable_obj<Thread *,1> >::_Call_wrapper_base<std::_Callable_obj<Thread *,1> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\type_traits
;	COMDAT ??$forward@P6AXPAVThread@@@Z@std@@YA$$QAP6AXPAVThread@@@ZAAP6AX0@Z@Z
_TEXT	SEGMENT
??$forward@P6AXPAVThread@@@Z@std@@YA$$QAP6AXPAVThread@@@ZAAP6AX0@Z@Z PROC ; std::forward<void (__cdecl*)(Thread *)>, COMDAT
; __Arg$ = ecx

; 1776 : 	return (static_cast<_Ty&&>(_Arg));

  00000	8b c1		 mov	 eax, ecx

; 1777 : 	}

  00002	c3		 ret	 0
??$forward@P6AXPAVThread@@@Z@std@@YA$$QAP6AXPAVThread@@@ZAAP6AX0@Z@Z ENDP ; std::forward<void (__cdecl*)(Thread *)>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\type_traits
;	COMDAT ??$_Decay_copy@P6AXPAVThread@@@Z@std@@YAP6AXPAVThread@@@Z$$QAP6AX0@Z@Z
_TEXT	SEGMENT
??$_Decay_copy@P6AXPAVThread@@@Z@std@@YAP6AXPAVThread@@@Z$$QAP6AX0@Z@Z PROC ; std::_Decay_copy<void (__cdecl*)(Thread *)>, COMDAT
; __Arg$ = ecx

; 1816 : 	return (_STD forward<_Ty>(_Arg));

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 1817 : 	}

  00002	c3		 ret	 0
??$_Decay_copy@P6AXPAVThread@@@Z@std@@YAP6AXPAVThread@@@Z$$QAP6AX0@Z@Z ENDP ; std::_Decay_copy<void (__cdecl*)(Thread *)>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\type_traits
;	COMDAT ??$forward@V?$reference_wrapper@PAVThread@@@std@@@std@@YA$$QAV?$reference_wrapper@PAVThread@@@0@AAV10@@Z
_TEXT	SEGMENT
??$forward@V?$reference_wrapper@PAVThread@@@std@@@std@@YA$$QAV?$reference_wrapper@PAVThread@@@0@AAV10@@Z PROC ; std::forward<std::reference_wrapper<Thread *> >, COMDAT
; __Arg$ = ecx

; 1776 : 	return (static_cast<_Ty&&>(_Arg));

  00000	8b c1		 mov	 eax, ecx

; 1777 : 	}

  00002	c3		 ret	 0
??$forward@V?$reference_wrapper@PAVThread@@@std@@@std@@YA$$QAV?$reference_wrapper@PAVThread@@@0@AAV10@@Z ENDP ; std::forward<std::reference_wrapper<Thread *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\functional
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xrefwrap
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\functional
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xrefwrap
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\functional
;	COMDAT ??$bind@XPAVThread@@V?$reference_wrapper@PAVThread@@@std@@@std@@YA?AV?$_Bind@$00XQ6AXPAVThread@@@ZV?$reference_wrapper@PAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@0@P6AXPAVThread@@@Z$$QAV?$reference_wrapper@PAVThread@@@0@@Z
_TEXT	SEGMENT
__Vx0$ = 8						; size = 4
??$bind@XPAVThread@@V?$reference_wrapper@PAVThread@@@std@@@std@@YA?AV?$_Bind@$00XQ6AXPAVThread@@@ZV?$reference_wrapper@PAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@0@P6AXPAVThread@@@Z$$QAV?$reference_wrapper@PAVThread@@@0@@Z PROC ; std::bind<void,Thread *,std::reference_wrapper<Thread *> >, COMDAT
; ___$ReturnUdt$ = ecx
; __Pfx$ = edx

; 1387 : _VARIADIC_EXPAND_0X_0X(_BIND_IMPLICIT1)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xrefwrap

; 346  : 		{	// construct

  00003	8b 45 08	 mov	 eax, DWORD PTR __Vx0$[ebp]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\functional

; 1152 : _VARIADIC_EXPAND_0X(_CLASS_BIND, , , , )

  00006	89 11		 mov	 DWORD PTR [ecx], edx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xrefwrap

; 346  : 		{	// construct

  00008	8b 00		 mov	 eax, DWORD PTR [eax]
  0000a	89 41 04	 mov	 DWORD PTR [ecx+4], eax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\functional

; 1387 : _VARIADIC_EXPAND_0X_0X(_BIND_IMPLICIT1)

  0000d	8b c1		 mov	 eax, ecx
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
??$bind@XPAVThread@@V?$reference_wrapper@PAVThread@@@std@@@std@@YA?AV?$_Bind@$00XQ6AXPAVThread@@@ZV?$reference_wrapper@PAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@0@P6AXPAVThread@@@Z$$QAV?$reference_wrapper@PAVThread@@@0@@Z ENDP ; std::bind<void,Thread *,std::reference_wrapper<Thread *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\functional
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xrefwrap
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xrefwrap
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
;	COMDAT ??$_Launch@V?$_Bind@$00XQ6AXPAVThread@@@ZV?$reference_wrapper@PAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@std@@@std@@YAXPAU_Thrd_imp_t@@$$QAV?$_Bind@$00XQ6AXPAVThread@@@ZV?$reference_wrapper@PAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@0@@Z
_TEXT	SEGMENT
__Launcher$ = -36					; size = 24
__$EHRec$ = -12						; size = 12
??$_Launch@V?$_Bind@$00XQ6AXPAVThread@@@ZV?$reference_wrapper@PAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@std@@@std@@YAXPAU_Thrd_imp_t@@$$QAV?$_Bind@$00XQ6AXPAVThread@@@ZV?$reference_wrapper@PAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@0@@Z PROC ; std::_Launch<std::_Bind<1,void,void (__cdecl*const)(Thread *),std::reference_wrapper<Thread *>,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil> >, COMDAT
; __Thr$ = ecx
; __Tg$ = edx

; 204  : 	{	// launch a new thread

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Launch@V?$_Bind@$00XQ6AXPAVThread@@@ZV?$reference_wrapper@PAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@std@@@std@@YAXPAU_Thrd_imp_t@@$$QAV?$_Bind@$00XQ6AXPAVThread@@@ZV?$reference_wrapper@PAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 18	 sub	 esp, 24			; 00000018H
  00014	56		 push	 esi
  00015	57		 push	 edi
  00016	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001b	33 c5		 xor	 eax, ebp
  0001d	50		 push	 eax
  0001e	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00021	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00027	8b f2		 mov	 esi, edx
  00029	8b f9		 mov	 edi, ecx

; 182  : 		{	// construct from target

  0002b	8d 4d dc	 lea	 ecx, DWORD PTR __Launcher$[ebp]
  0002e	e8 00 00 00 00	 call	 ??0_Pad@std@@QAE@XZ	; std::_Pad::_Pad
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\functional

; 1152 : _VARIADIC_EXPAND_0X(_CLASS_BIND, , , , )

  00033	8b 06		 mov	 eax, DWORD PTR [esi]
  00035	89 45 ec	 mov	 DWORD PTR __Launcher$[ebp+16], eax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xrefwrap

; 346  : 		{	// construct

  00038	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 182  : 		{	// construct from target

  0003b	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR __Launcher$[ebp], OFFSET ??_7?$_LaunchPad@V?$_Bind@$00XQ6AXPAVThread@@@ZV?$reference_wrapper@PAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@std@@@std@@6B@
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xrefwrap

; 346  : 		{	// construct

  00042	89 45 f0	 mov	 DWORD PTR __Launcher$[ebp+20], eax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 206  : 	_Launcher._Launch(_Thr);

  00045	57		 push	 edi
  00046	8d 4d dc	 lea	 ecx, DWORD PTR __Launcher$[ebp]
  00049	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00050	e8 00 00 00 00	 call	 ?_Launch@_Pad@std@@QAEXPAU_Thrd_imp_t@@@Z ; std::_Pad::_Launch
  00055	8d 4d dc	 lea	 ecx, DWORD PTR __Launcher$[ebp]
  00058	e8 00 00 00 00	 call	 ??1_Pad@std@@QAE@XZ	; std::_Pad::~_Pad

; 207  : 	}

  0005d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00060	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00067	59		 pop	 ecx
  00068	5f		 pop	 edi
  00069	5e		 pop	 esi
  0006a	8b e5		 mov	 esp, ebp
  0006c	5d		 pop	 ebp
  0006d	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Launch@V?$_Bind@$00XQ6AXPAVThread@@@ZV?$reference_wrapper@PAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@std@@@std@@YAXPAU_Thrd_imp_t@@$$QAV?$_Bind@$00XQ6AXPAVThread@@@ZV?$reference_wrapper@PAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@0@@Z$0:
  00000	8d 4d dc	 lea	 ecx, DWORD PTR __Launcher$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_LaunchPad@V?$_Bind@$00XQ6AXPAVThread@@@ZV?$reference_wrapper@PAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@std@@@std@@QAE@XZ
__ehhandler$??$_Launch@V?$_Bind@$00XQ6AXPAVThread@@@ZV?$reference_wrapper@PAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@std@@@std@@YAXPAU_Thrd_imp_t@@$$QAV?$_Bind@$00XQ6AXPAVThread@@@ZV?$reference_wrapper@PAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@0@@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a dc	 mov	 ecx, DWORD PTR [edx-36]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Launch@V?$_Bind@$00XQ6AXPAVThread@@@ZV?$reference_wrapper@PAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@std@@@std@@YAXPAU_Thrd_imp_t@@$$QAV?$_Bind@$00XQ6AXPAVThread@@@ZV?$reference_wrapper@PAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@0@@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Launch@V?$_Bind@$00XQ6AXPAVThread@@@ZV?$reference_wrapper@PAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@std@@@std@@YAXPAU_Thrd_imp_t@@$$QAV?$_Bind@$00XQ6AXPAVThread@@@ZV?$reference_wrapper@PAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@0@@Z ENDP ; std::_Launch<std::_Bind<1,void,void (__cdecl*const)(Thread *),std::reference_wrapper<Thread *>,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\chrono
;	COMDAT ??$?G_JU?$ratio@$00$0JIJGIA@@std@@_JU01@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@01@ABV201@0@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??$?G_JU?$ratio@$00$0JIJGIA@@std@@_JU01@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@01@ABV201@0@Z PROC ; std::chrono::operator-<__int64,std::ratio<1,10000000>,__int64,std::ratio<1,10000000> >, COMDAT
; ___$ReturnUdt$ = ecx
; __Left$ = edx

; 364  : 	{	// subtract two durations

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 174  : 		_MyRep -= _Right._MyRep;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]

; 364  : 	{	// subtract two durations

  00006	56		 push	 esi

; 365  : 	typedef typename common_type<
; 366  : 		duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _CD;
; 367  : 	return (_CD(_Left) -= _Right);

  00007	8b 32		 mov	 esi, DWORD PTR [edx]

; 174  : 		_MyRep -= _Right._MyRep;

  00009	2b 30		 sub	 esi, DWORD PTR [eax]

; 365  : 	typedef typename common_type<
; 366  : 		duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _CD;
; 367  : 	return (_CD(_Left) -= _Right);

  0000b	8b 52 04	 mov	 edx, DWORD PTR [edx+4]

; 174  : 		_MyRep -= _Right._MyRep;

  0000e	1b 50 04	 sbb	 edx, DWORD PTR [eax+4]

; 365  : 	typedef typename common_type<
; 366  : 		duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _CD;
; 367  : 	return (_CD(_Left) -= _Right);

  00011	89 31		 mov	 DWORD PTR [ecx], esi
  00013	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  00016	8b c1		 mov	 eax, ecx

; 368  : 	}

  00018	5e		 pop	 esi
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
??$?G_JU?$ratio@$00$0JIJGIA@@std@@_JU01@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@01@ABV201@0@Z ENDP ; std::chrono::operator-<__int64,std::ratio<1,10000000>,__int64,std::ratio<1,10000000> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\chrono
;	COMDAT ??$?0_J@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAE@AB_JPAPAX@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
___formal$dead$ = 12					; size = 4
??$?0_J@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAE@AB_JPAPAX@Z PROC ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::duration<__int64,std::ratio<1,1000000000> ><__int64>, COMDAT
; _this$ = ecx

; 105  : 		{	// construct from representation

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 55 08	 mov	 edx, DWORD PTR __Val$[ebp]
  00006	8b 02		 mov	 eax, DWORD PTR [edx]
  00008	89 01		 mov	 DWORD PTR [ecx], eax
  0000a	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0000d	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 106  : 		static_assert(_Is_ratio<_Period>::value,
; 107  : 			"period not an instance of std::ratio");
; 108  : 		static_assert(0 < _Period::num,
; 109  : 			"duration negative or zero");
; 110  : 		}

  00010	8b c1		 mov	 eax, ecx
  00012	5d		 pop	 ebp
  00013	c2 08 00	 ret	 8
??$?0_J@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAE@AB_JPAPAX@Z ENDP ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::duration<__int64,std::ratio<1,1000000000> ><__int64>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xrefwrap
;	COMDAT ??$?0AAPAVThread@@@?$_Callable_obj@PAVThread@@$00@std@@QAE@AAPAVThread@@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$?0AAPAVThread@@@?$_Callable_obj@PAVThread@@$00@std@@QAE@AAPAVThread@@@Z PROC ; std::_Callable_obj<Thread *,1>::_Callable_obj<Thread *,1><Thread * &>, COMDAT
; _this$ = ecx

; 415  : 		{	// construct

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 346  : 		{	// construct

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 416  : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
??$?0AAPAVThread@@@?$_Callable_obj@PAVThread@@$00@std@@QAE@AAPAVThread@@@Z ENDP ; std::_Callable_obj<Thread *,1>::_Callable_obj<Thread *,1><Thread * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1?$_LaunchPad@V?$_Bind@$00XQ6AXPAVThread@@@ZV?$reference_wrapper@PAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_LaunchPad@V?$_Bind@$00XQ6AXPAVThread@@@ZV?$reference_wrapper@PAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@std@@@std@@QAE@XZ PROC ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(Thread *),std::reference_wrapper<Thread *>,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil> >::~_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(Thread *),std::reference_wrapper<Thread *>,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil> >, COMDAT
; _this$ = ecx
  00000	e9 00 00 00 00	 jmp	 ??1_Pad@std@@QAE@XZ	; std::_Pad::~_Pad
??1?$_LaunchPad@V?$_Bind@$00XQ6AXPAVThread@@@ZV?$reference_wrapper@PAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@std@@@std@@QAE@XZ ENDP ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(Thread *),std::reference_wrapper<Thread *>,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil> >::~_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(Thread *),std::reference_wrapper<Thread *>,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\chrono
;	COMDAT ??Z?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@chrono@std@@QAEAAV012@ABV012@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??Z?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@chrono@std@@QAEAAV012@ABV012@@Z PROC ; std::chrono::duration<__int64,std::ratio<1,10000000> >::operator-=, COMDAT
; _this$ = ecx

; 173  : 		{	// subtract _Right from rep

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 174  : 		_MyRep -= _Right._MyRep;

  00003	8b 55 08	 mov	 edx, DWORD PTR __Right$[ebp]
  00006	8b 02		 mov	 eax, DWORD PTR [edx]
  00008	29 01		 sub	 DWORD PTR [ecx], eax
  0000a	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0000d	19 41 04	 sbb	 DWORD PTR [ecx+4], eax

; 175  : 		return (*this);

  00010	8b c1		 mov	 eax, ecx

; 176  : 		}

  00012	5d		 pop	 ebp
  00013	c2 04 00	 ret	 4
??Z?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@chrono@std@@QAEAAV012@ABV012@@Z ENDP ; std::chrono::duration<__int64,std::ratio<1,10000000> >::operator-=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xrefwrap
;	COMDAT ??0?$_Callable_base@PAVThread@@$00@std@@QAE@AAPAVThread@@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??0?$_Callable_base@PAVThread@@$00@std@@QAE@AAPAVThread@@@Z PROC ; std::_Callable_base<Thread *,1>::_Callable_base<Thread *,1>, COMDAT
; _this$ = ecx

; 346  : 		{	// construct

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 347  : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
??0?$_Callable_base@PAVThread@@$00@std@@QAE@AAPAVThread@@@Z ENDP ; std::_Callable_base<Thread *,1>::_Callable_base<Thread *,1>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xrefwrap
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\functional
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\functional
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
;	COMDAT ?_Go@?$_LaunchPad@V?$_Bind@$00XQ6AXPAVThread@@@ZV?$reference_wrapper@PAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@std@@@std@@UAEIXZ
_TEXT	SEGMENT
?_Go@?$_LaunchPad@V?$_Bind@$00XQ6AXPAVThread@@@ZV?$reference_wrapper@PAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@std@@@std@@UAEIXZ PROC ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(Thread *),std::reference_wrapper<Thread *>,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil> >::_Go, COMDAT
; _this$ = ecx

; 186  : 		{	// run the thread function object

  00000	56		 push	 esi
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xrefwrap

; 346  : 		{	// construct

  00001	8b 71 14	 mov	 esi, DWORD PTR [ecx+20]
  00004	57		 push	 edi
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\functional

; 1152 : _VARIADIC_EXPAND_0X(_CLASS_BIND, , , , )

  00005	8b 79 10	 mov	 edi, DWORD PTR [ecx+16]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 194  : 		_Ln->_Release();

  00008	e8 00 00 00 00	 call	 ?_Release@_Pad@std@@QAEXXZ ; std::_Pad::_Release
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\functional

; 1152 : _VARIADIC_EXPAND_0X(_CLASS_BIND, , , , )

  0000d	ff 36		 push	 DWORD PTR [esi]
  0000f	ff d7		 call	 edi
  00011	83 c4 04	 add	 esp, 4
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 187  : 		return (_Run(this));

  00014	33 c0		 xor	 eax, eax
  00016	5f		 pop	 edi
  00017	5e		 pop	 esi

; 188  : 		}

  00018	c3		 ret	 0
?_Go@?$_LaunchPad@V?$_Bind@$00XQ6AXPAVThread@@@ZV?$reference_wrapper@PAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@std@@@std@@UAEIXZ ENDP ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(Thread *),std::reference_wrapper<Thread *>,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil> >::_Go
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xrefwrap
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\functional
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\functional
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
;	COMDAT ?_Run@?$_LaunchPad@V?$_Bind@$00XQ6AXPAVThread@@@ZV?$reference_wrapper@PAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@std@@@std@@CAIPAV12@@Z
_TEXT	SEGMENT
?_Run@?$_LaunchPad@V?$_Bind@$00XQ6AXPAVThread@@@ZV?$reference_wrapper@PAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@std@@@std@@CAIPAV12@@Z PROC ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(Thread *),std::reference_wrapper<Thread *>,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil> >::_Run, COMDAT
; __Ln$ = ecx

; 192  : 		{	// make local copy of function object and call it

  00000	56		 push	 esi
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xrefwrap

; 346  : 		{	// construct

  00001	8b 71 14	 mov	 esi, DWORD PTR [ecx+20]
  00004	57		 push	 edi
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\functional

; 1152 : _VARIADIC_EXPAND_0X(_CLASS_BIND, , , , )

  00005	8b 79 10	 mov	 edi, DWORD PTR [ecx+16]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 194  : 		_Ln->_Release();

  00008	e8 00 00 00 00	 call	 ?_Release@_Pad@std@@QAEXXZ ; std::_Pad::_Release
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\functional

; 1152 : _VARIADIC_EXPAND_0X(_CLASS_BIND, , , , )

  0000d	ff 36		 push	 DWORD PTR [esi]
  0000f	ff d7		 call	 edi
  00011	83 c4 04	 add	 esp, 4
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 196  : 		return (0);

  00014	33 c0		 xor	 eax, eax
  00016	5f		 pop	 edi
  00017	5e		 pop	 esi

; 197  : 		}

  00018	c3		 ret	 0
?_Run@?$_LaunchPad@V?$_Bind@$00XQ6AXPAVThread@@@ZV?$reference_wrapper@PAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@std@@@std@@CAIPAV12@@Z ENDP ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(Thread *),std::reference_wrapper<Thread *>,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil> >::_Run
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\functional
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xrefwrap
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\functional
;	COMDAT ??0?$_Bind@$00XQ6AXPAVThread@@@ZV?$reference_wrapper@PAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@std@@QAE@$$QAV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$_Bind@$00XQ6AXPAVThread@@@ZV?$reference_wrapper@PAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@std@@QAE@$$QAV01@@Z PROC ; std::_Bind<1,void,void (__cdecl*const)(Thread *),std::reference_wrapper<Thread *>,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::_Bind<1,void,void (__cdecl*const)(Thread *),std::reference_wrapper<Thread *>,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>, COMDAT
; _this$ = ecx

; 1152 : _VARIADIC_EXPAND_0X(_CLASS_BIND, , , , )

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 55 08	 mov	 edx, DWORD PTR __Right$[ebp]
  00006	8b 02		 mov	 eax, DWORD PTR [edx]
  00008	89 01		 mov	 DWORD PTR [ecx], eax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xrefwrap

; 346  : 		{	// construct

  0000a	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0000d	89 41 04	 mov	 DWORD PTR [ecx+4], eax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\functional

; 1152 : _VARIADIC_EXPAND_0X(_CLASS_BIND, , , , )

  00010	8b c1		 mov	 eax, ecx
  00012	5d		 pop	 ebp
  00013	c2 04 00	 ret	 4
??0?$_Bind@$00XQ6AXPAVThread@@@ZV?$reference_wrapper@PAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@std@@QAE@$$QAV01@@Z ENDP ; std::_Bind<1,void,void (__cdecl*const)(Thread *),std::reference_wrapper<Thread *>,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::_Bind<1,void,void (__cdecl*const)(Thread *),std::reference_wrapper<Thread *>,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\functional
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xrefwrap
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\functional
;	COMDAT ??R?$_Bind@$00XQ6AXPAVThread@@@ZV?$reference_wrapper@PAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@std@@QAEXXZ
_TEXT	SEGMENT
??R?$_Bind@$00XQ6AXPAVThread@@@ZV?$reference_wrapper@PAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@std@@QAEXXZ PROC ; std::_Bind<1,void,void (__cdecl*const)(Thread *),std::reference_wrapper<Thread *>,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::operator(), COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xrefwrap

; 351  : 		return (*_Ptr);

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\functional

; 1152 : _VARIADIC_EXPAND_0X(_CLASS_BIND, , , , )

  00003	ff 30		 push	 DWORD PTR [eax]
  00005	8b 01		 mov	 eax, DWORD PTR [ecx]
  00007	ff d0		 call	 eax
  00009	59		 pop	 ecx
  0000a	c3		 ret	 0
??R?$_Bind@$00XQ6AXPAVThread@@@ZV?$reference_wrapper@PAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@std@@QAEXXZ ENDP ; std::_Bind<1,void,void (__cdecl*const)(Thread *),std::reference_wrapper<Thread *>,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\tuple
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xrefwrap
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\tuple
;	COMDAT ??0?$tuple@V?$reference_wrapper@PAVThread@@@std@@U_Nil@2@U32@U32@U32@U32@U32@U32@@std@@QAE@$$QAV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$tuple@V?$reference_wrapper@PAVThread@@@std@@U_Nil@2@U32@U32@U32@U32@U32@U32@@std@@QAE@$$QAV01@@Z PROC ; std::tuple<std::reference_wrapper<Thread *>,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::tuple<std::reference_wrapper<Thread *>,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>, COMDAT
; _this$ = ecx

; 521  : _VARIADIC_EXPAND_0X(_CLASS_TUPLE, , , , )

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xrefwrap

; 346  : 		{	// construct

  00003	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00006	8b 00		 mov	 eax, DWORD PTR [eax]
  00008	89 01		 mov	 DWORD PTR [ecx], eax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\tuple

; 521  : _VARIADIC_EXPAND_0X(_CLASS_TUPLE, , , , )

  0000a	8b c1		 mov	 eax, ecx
  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4
??0?$tuple@V?$reference_wrapper@PAVThread@@@std@@U_Nil@2@U32@U32@U32@U32@U32@U32@@std@@QAE@$$QAV01@@Z ENDP ; std::tuple<std::reference_wrapper<Thread *>,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::tuple<std::reference_wrapper<Thread *>,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\tuple
;	COMDAT ?_Get_rest@?$tuple@V?$reference_wrapper@PAVThread@@@std@@U_Nil@2@U32@U32@U32@U32@U32@U32@@std@@QAEAAV?$tuple@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@2@XZ
_TEXT	SEGMENT
?_Get_rest@?$tuple@V?$reference_wrapper@PAVThread@@@std@@U_Nil@2@U32@U32@U32@U32@U32@U32@@std@@QAEAAV?$tuple@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@2@XZ PROC ; std::tuple<std::reference_wrapper<Thread *>,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::_Get_rest, COMDAT
; _this$ = ecx

; 521  : _VARIADIC_EXPAND_0X(_CLASS_TUPLE, , , , )

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
?_Get_rest@?$tuple@V?$reference_wrapper@PAVThread@@@std@@U_Nil@2@U32@U32@U32@U32@U32@U32@@std@@QAEAAV?$tuple@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@2@XZ ENDP ; std::tuple<std::reference_wrapper<Thread *>,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::_Get_rest
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\functional
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xrefwrap
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\functional
;	COMDAT ??$?0AAP6AXPAVThread@@@ZV?$reference_wrapper@PAVThread@@@std@@@?$_Bind@$00XQ6AXPAVThread@@@ZV?$reference_wrapper@PAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@std@@QAE@AAP6AXPAVThread@@@Z$$QAV?$reference_wrapper@PAVThread@@@1@@Z
_TEXT	SEGMENT
__Fx$ = 8						; size = 4
__Vx0$ = 12						; size = 4
??$?0AAP6AXPAVThread@@@ZV?$reference_wrapper@PAVThread@@@std@@@?$_Bind@$00XQ6AXPAVThread@@@ZV?$reference_wrapper@PAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@std@@QAE@AAP6AXPAVThread@@@Z$$QAV?$reference_wrapper@PAVThread@@@1@@Z PROC ; std::_Bind<1,void,void (__cdecl*const)(Thread *),std::reference_wrapper<Thread *>,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::_Bind<1,void,void (__cdecl*const)(Thread *),std::reference_wrapper<Thread *>,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil><void (__cdecl*&)(Thread *),std::reference_wrapper<Thread *> >, COMDAT
; _this$ = ecx

; 1152 : _VARIADIC_EXPAND_0X(_CLASS_BIND, , , , )

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Fx$[ebp]
  00006	8b 00		 mov	 eax, DWORD PTR [eax]
  00008	89 01		 mov	 DWORD PTR [ecx], eax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xrefwrap

; 346  : 		{	// construct

  0000a	8b 45 0c	 mov	 eax, DWORD PTR __Vx0$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 41 04	 mov	 DWORD PTR [ecx+4], eax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\functional

; 1152 : _VARIADIC_EXPAND_0X(_CLASS_BIND, , , , )

  00012	8b c1		 mov	 eax, ecx
  00014	5d		 pop	 ebp
  00015	c2 08 00	 ret	 8
??$?0AAP6AXPAVThread@@@ZV?$reference_wrapper@PAVThread@@@std@@@?$_Bind@$00XQ6AXPAVThread@@@ZV?$reference_wrapper@PAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@std@@QAE@AAP6AXPAVThread@@@Z$$QAV?$reference_wrapper@PAVThread@@@1@@Z ENDP ; std::_Bind<1,void,void (__cdecl*const)(Thread *),std::reference_wrapper<Thread *>,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::_Bind<1,void,void (__cdecl*const)(Thread *),std::reference_wrapper<Thread *>,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil><void (__cdecl*&)(Thread *),std::reference_wrapper<Thread *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\type_traits
;	COMDAT ??$forward@V?$_Bind@$00XQ6AXPAVThread@@@ZV?$reference_wrapper@PAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@std@@@std@@YA$$QAV?$_Bind@$00XQ6AXPAVThread@@@ZV?$reference_wrapper@PAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@0@AAV10@@Z
_TEXT	SEGMENT
??$forward@V?$_Bind@$00XQ6AXPAVThread@@@ZV?$reference_wrapper@PAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@std@@@std@@YA$$QAV?$_Bind@$00XQ6AXPAVThread@@@ZV?$reference_wrapper@PAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@0@AAV10@@Z PROC ; std::forward<std::_Bind<1,void,void (__cdecl*const)(Thread *),std::reference_wrapper<Thread *>,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil> >, COMDAT
; __Arg$ = ecx

; 1776 : 	return (static_cast<_Ty&&>(_Arg));

  00000	8b c1		 mov	 eax, ecx

; 1777 : 	}

  00002	c3		 ret	 0
??$forward@V?$_Bind@$00XQ6AXPAVThread@@@ZV?$reference_wrapper@PAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@std@@@std@@YA$$QAV?$_Bind@$00XQ6AXPAVThread@@@ZV?$reference_wrapper@PAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@0@AAV10@@Z ENDP ; std::forward<std::_Bind<1,void,void (__cdecl*const)(Thread *),std::reference_wrapper<Thread *>,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\functional
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\functional
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xrefwrap
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
;	COMDAT ??$?0V?$_Bind@$00XQ6AXPAVThread@@@ZV?$reference_wrapper@PAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@std@@@?$_LaunchPad@V?$_Bind@$00XQ6AXPAVThread@@@ZV?$reference_wrapper@PAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@std@@@std@@QAE@$$QAV?$_Bind@$00XQ6AXPAVThread@@@ZV?$reference_wrapper@PAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@1@@Z
_TEXT	SEGMENT
__Tgt$ = 8						; size = 4
??$?0V?$_Bind@$00XQ6AXPAVThread@@@ZV?$reference_wrapper@PAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@std@@@?$_LaunchPad@V?$_Bind@$00XQ6AXPAVThread@@@ZV?$reference_wrapper@PAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@std@@@std@@QAE@$$QAV?$_Bind@$00XQ6AXPAVThread@@@ZV?$reference_wrapper@PAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@1@@Z PROC ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(Thread *),std::reference_wrapper<Thread *>,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil> >::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(Thread *),std::reference_wrapper<Thread *>,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil> ><std::_Bind<1,void,void (__cdecl*const)(Thread *),std::reference_wrapper<Thread *>,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil> >, COMDAT
; _this$ = ecx

; 182  : 		{	// construct from target

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??0_Pad@std@@QAE@XZ	; std::_Pad::_Pad
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\functional

; 1152 : _VARIADIC_EXPAND_0X(_CLASS_BIND, , , , )

  0000b	8b 55 08	 mov	 edx, DWORD PTR __Tgt$[ebp]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 182  : 		{	// construct from target

  0000e	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$_LaunchPad@V?$_Bind@$00XQ6AXPAVThread@@@ZV?$reference_wrapper@PAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@std@@@std@@6B@
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\functional

; 1152 : _VARIADIC_EXPAND_0X(_CLASS_BIND, , , , )

  00014	8b 02		 mov	 eax, DWORD PTR [edx]
  00016	89 46 10	 mov	 DWORD PTR [esi+16], eax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xrefwrap

; 346  : 		{	// construct

  00019	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0001c	89 46 14	 mov	 DWORD PTR [esi+20], eax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 183  : 		}

  0001f	8b c6		 mov	 eax, esi
  00021	5e		 pop	 esi
  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
??$?0V?$_Bind@$00XQ6AXPAVThread@@@ZV?$reference_wrapper@PAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@std@@@?$_LaunchPad@V?$_Bind@$00XQ6AXPAVThread@@@ZV?$reference_wrapper@PAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@std@@@std@@QAE@$$QAV?$_Bind@$00XQ6AXPAVThread@@@ZV?$reference_wrapper@PAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@1@@Z ENDP ; std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(Thread *),std::reference_wrapper<Thread *>,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil> >::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(Thread *),std::reference_wrapper<Thread *>,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil> ><std::_Bind<1,void,void (__cdecl*const)(Thread *),std::reference_wrapper<Thread *>,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\type_traits
;	COMDAT ??$forward@AAPAVThread@@@std@@YAAAPAVThread@@AAPAV1@@Z
_TEXT	SEGMENT
??$forward@AAPAVThread@@@std@@YAAAPAVThread@@AAPAV1@@Z PROC ; std::forward<Thread * &>, COMDAT
; __Arg$ = ecx

; 1776 : 	return (static_cast<_Ty&&>(_Arg));

  00000	8b c1		 mov	 eax, ecx

; 1777 : 	}

  00002	c3		 ret	 0
??$forward@AAPAVThread@@@std@@YAAAPAVThread@@AAPAV1@@Z ENDP ; std::forward<Thread * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstddef
;	COMDAT ??$addressof@PAVThread@@@std@@YAPAPAVThread@@AAPAV1@@Z
_TEXT	SEGMENT
??$addressof@PAVThread@@@std@@YAPAPAVThread@@AAPAV1@@Z PROC ; std::addressof<Thread *>, COMDAT
; __Val$ = ecx

; 86   : 	return (reinterpret_cast<_Ty *>(
; 87   : 		(&const_cast<char&>(
; 88   : 		reinterpret_cast<const volatile char&>(_Val)))));

  00000	8b c1		 mov	 eax, ecx

; 89   : 	}

  00002	c3		 ret	 0
??$addressof@PAVThread@@@std@@YAPAPAVThread@@AAPAV1@@Z ENDP ; std::addressof<Thread *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\type_traits
;	COMDAT ??$forward@V?$tuple@V?$reference_wrapper@PAVThread@@@std@@U_Nil@2@U32@U32@U32@U32@U32@U32@@std@@@std@@YA$$QAV?$tuple@V?$reference_wrapper@PAVThread@@@std@@U_Nil@2@U32@U32@U32@U32@U32@U32@@0@AAV10@@Z
_TEXT	SEGMENT
??$forward@V?$tuple@V?$reference_wrapper@PAVThread@@@std@@U_Nil@2@U32@U32@U32@U32@U32@U32@@std@@@std@@YA$$QAV?$tuple@V?$reference_wrapper@PAVThread@@@std@@U_Nil@2@U32@U32@U32@U32@U32@U32@@0@AAV10@@Z PROC ; std::forward<std::tuple<std::reference_wrapper<Thread *>,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil> >, COMDAT
; __Arg$ = ecx

; 1776 : 	return (static_cast<_Ty&&>(_Arg));

  00000	8b c1		 mov	 eax, ecx

; 1777 : 	}

  00002	c3		 ret	 0
??$forward@V?$tuple@V?$reference_wrapper@PAVThread@@@std@@U_Nil@2@U32@U32@U32@U32@U32@U32@@std@@@std@@YA$$QAV?$tuple@V?$reference_wrapper@PAVThread@@@std@@U_Nil@2@U32@U32@U32@U32@U32@U32@@0@AAV10@@Z ENDP ; std::forward<std::tuple<std::reference_wrapper<Thread *>,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\tuple
;	COMDAT ??$get@$0A@V?$reference_wrapper@PAVThread@@@std@@@std@@YAAAV?$reference_wrapper@PAVThread@@@0@AAV?$tuple@V?$reference_wrapper@PAVThread@@@std@@U_Nil@2@U32@U32@U32@U32@U32@U32@@0@@Z
_TEXT	SEGMENT
??$get@$0A@V?$reference_wrapper@PAVThread@@@std@@@std@@YAAAV?$reference_wrapper@PAVThread@@@0@AAV?$tuple@V?$reference_wrapper@PAVThread@@@std@@U_Nil@2@U32@U32@U32@U32@U32@U32@@0@@Z PROC ; std::get<0,std::reference_wrapper<Thread *> >, COMDAT
; __Tuple$ = ecx

; 697  : _VARIADIC_EXPAND_0X(_TUPLE_GET, _COMMA, , , )

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??$get@$0A@V?$reference_wrapper@PAVThread@@@std@@@std@@YAAAV?$reference_wrapper@PAVThread@@@0@AAV?$tuple@V?$reference_wrapper@PAVThread@@@std@@U_Nil@2@U32@U32@U32@U32@U32@U32@@0@@Z ENDP ; std::get<0,std::reference_wrapper<Thread *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\functional
;	COMDAT ??$_Fixarg@AAP6AXPAVThread@@@ZV?$reference_wrapper@PAVThread@@@std@@V?$tuple@V?$reference_wrapper@PAVThread@@@std@@U_Nil@2@U32@U32@U32@U32@U32@U32@@3@V?$tuple@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@3@@std@@YAAAPAVThread@@AAP6AXPAV1@@ZAAV?$tuple@V?$reference_wrapper@PAVThread@@@std@@U_Nil@2@U32@U32@U32@U32@U32@U32@@0@AAV?$tuple@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@0@AAV?$reference_wrapper@PAVThread@@@0@@Z
_TEXT	SEGMENT
__Myfargs$dead$ = 8					; size = 4
__Arg$ = 12						; size = 4
??$_Fixarg@AAP6AXPAVThread@@@ZV?$reference_wrapper@PAVThread@@@std@@V?$tuple@V?$reference_wrapper@PAVThread@@@std@@U_Nil@2@U32@U32@U32@U32@U32@U32@@3@V?$tuple@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@3@@std@@YAAAPAVThread@@AAP6AXPAV1@@ZAAV?$tuple@V?$reference_wrapper@PAVThread@@@std@@U_Nil@2@U32@U32@U32@U32@U32@U32@@0@AAV?$tuple@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@0@AAV?$reference_wrapper@PAVThread@@@0@@Z PROC ; std::_Fixarg<void (__cdecl*&)(Thread *),std::reference_wrapper<Thread *>,std::tuple<std::reference_wrapper<Thread *>,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>,std::tuple<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil> >, COMDAT
; ___formal$dead$ = ecx
; __Mybargs$dead$ = edx

; 1035 : 	{	// convert a reference_wrapper argument

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1036 : 	return (_Arg.get());

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Arg$[ebp]
  00006	8b 00		 mov	 eax, DWORD PTR [eax]

; 1037 : 	}

  00008	5d		 pop	 ebp
  00009	c3		 ret	 0
??$_Fixarg@AAP6AXPAVThread@@@ZV?$reference_wrapper@PAVThread@@@std@@V?$tuple@V?$reference_wrapper@PAVThread@@@std@@U_Nil@2@U32@U32@U32@U32@U32@U32@@3@V?$tuple@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@3@@std@@YAAAPAVThread@@AAP6AXPAV1@@ZAAV?$tuple@V?$reference_wrapper@PAVThread@@@std@@U_Nil@2@U32@U32@U32@U32@U32@U32@@0@AAV?$tuple@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@0@AAV?$reference_wrapper@PAVThread@@@0@@Z ENDP ; std::_Fixarg<void (__cdecl*&)(Thread *),std::reference_wrapper<Thread *>,std::tuple<std::reference_wrapper<Thread *>,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>,std::tuple<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\tuple
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xrefwrap
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\tuple
;	COMDAT ??$?0V?$reference_wrapper@PAVThread@@@std@@@?$_Tuple_val@V?$reference_wrapper@PAVThread@@@std@@@std@@QAE@$$QAV?$reference_wrapper@PAVThread@@@1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$?0V?$reference_wrapper@PAVThread@@@std@@@?$_Tuple_val@V?$reference_wrapper@PAVThread@@@std@@@std@@QAE@$$QAV?$reference_wrapper@PAVThread@@@1@@Z PROC ; std::_Tuple_val<std::reference_wrapper<Thread *> >::_Tuple_val<std::reference_wrapper<Thread *> ><std::reference_wrapper<Thread *> >, COMDAT
; _this$ = ecx

; 151  : 		{	// construct with argument

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xrefwrap

; 346  : 		{	// construct

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]
  00006	8b 00		 mov	 eax, DWORD PTR [eax]
  00008	89 01		 mov	 DWORD PTR [ecx], eax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\tuple

; 152  : 		}

  0000a	8b c1		 mov	 eax, ecx
  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4
??$?0V?$reference_wrapper@PAVThread@@@std@@@?$_Tuple_val@V?$reference_wrapper@PAVThread@@@std@@@std@@QAE@$$QAV?$reference_wrapper@PAVThread@@@1@@Z ENDP ; std::_Tuple_val<std::reference_wrapper<Thread *> >::_Tuple_val<std::reference_wrapper<Thread *> ><std::reference_wrapper<Thread *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xrefwrap
;	COMDAT ?get@?$reference_wrapper@PAVThread@@@std@@QBEAAPAVThread@@XZ
_TEXT	SEGMENT
?get@?$reference_wrapper@PAVThread@@@std@@QBEAAPAVThread@@XZ PROC ; std::reference_wrapper<Thread *>::get, COMDAT
; _this$ = ecx

; 874  : 		return (this->_Get());

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 875  : 		}

  00002	c3		 ret	 0
?get@?$reference_wrapper@PAVThread@@@std@@QBEAAPAVThread@@XZ ENDP ; std::reference_wrapper<Thread *>::get
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\type_traits
;	COMDAT ??$forward@AAP6AXPAVThread@@@Z@std@@YAAAP6AXPAVThread@@@ZAAP6AX0@Z@Z
_TEXT	SEGMENT
??$forward@AAP6AXPAVThread@@@Z@std@@YAAAP6AXPAVThread@@@ZAAP6AX0@Z@Z PROC ; std::forward<void (__cdecl*&)(Thread *)>, COMDAT
; __Arg$ = ecx

; 1776 : 	return (static_cast<_Ty&&>(_Arg));

  00000	8b c1		 mov	 eax, ecx

; 1777 : 	}

  00002	c3		 ret	 0
??$forward@AAP6AXPAVThread@@@Z@std@@YAAAP6AXPAVThread@@@ZAAP6AX0@Z@Z ENDP ; std::forward<void (__cdecl*&)(Thread *)>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\tuple
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xrefwrap
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\tuple
;	COMDAT ??$?0V?$reference_wrapper@PAVThread@@@std@@@?$tuple@V?$reference_wrapper@PAVThread@@@std@@U_Nil@2@U32@U32@U32@U32@U32@U32@@std@@QAE@$$QAV?$reference_wrapper@PAVThread@@@1@PAPAX@Z
_TEXT	SEGMENT
__Arg0$ = 8						; size = 4
___formal$dead$ = 12					; size = 4
??$?0V?$reference_wrapper@PAVThread@@@std@@@?$tuple@V?$reference_wrapper@PAVThread@@@std@@U_Nil@2@U32@U32@U32@U32@U32@U32@@std@@QAE@$$QAV?$reference_wrapper@PAVThread@@@1@PAPAX@Z PROC ; std::tuple<std::reference_wrapper<Thread *>,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::tuple<std::reference_wrapper<Thread *>,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil><std::reference_wrapper<Thread *> >, COMDAT
; _this$ = ecx

; 521  : _VARIADIC_EXPAND_0X(_CLASS_TUPLE, , , , )

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xrefwrap

; 346  : 		{	// construct

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg0$[ebp]
  00006	8b 00		 mov	 eax, DWORD PTR [eax]
  00008	89 01		 mov	 DWORD PTR [ecx], eax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\tuple

; 521  : _VARIADIC_EXPAND_0X(_CLASS_TUPLE, , , , )

  0000a	8b c1		 mov	 eax, ecx
  0000c	5d		 pop	 ebp
  0000d	c2 08 00	 ret	 8
??$?0V?$reference_wrapper@PAVThread@@@std@@@?$tuple@V?$reference_wrapper@PAVThread@@@std@@U_Nil@2@U32@U32@U32@U32@U32@U32@@std@@QAE@$$QAV?$reference_wrapper@PAVThread@@@1@PAPAX@Z ENDP ; std::tuple<std::reference_wrapper<Thread *>,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::tuple<std::reference_wrapper<Thread *>,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil><std::reference_wrapper<Thread *> >
_TEXT	ENDS
END
