; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.50727.1 

	TITLE	C:\Users\Glenn\Documents\GitHub\Wind\Project\Wind\Wind\window.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	?instance@GLWindow@@2PAV1@A			; GLWindow::instance
PUBLIC	?wglSwapIntervalEXT@@3P6GPAUHGLRC__@@H@ZA	; wglSwapIntervalEXT
PUBLIC	?wglCreateContextAttribsARB@@3P6GPAUHGLRC__@@PAUHDC__@@PAU1@PBH@ZA ; wglCreateContextAttribsARB
EXTRN	__imp__wglDeleteContext@4:PROC
EXTRN	__imp__DestroyWindow@4:PROC
EXTRN	__imp__PostQuitMessage@4:PROC
EXTRN	__imp__GetRawInputData@20:PROC
EXTRN	__imp__UnregisterClassW@8:PROC
EXTRN	__imp__SetForegroundWindow@4:PROC
EXTRN	__imp__LoadCursorW@8:PROC
EXTRN	__imp__SetFocus@4:PROC
EXTRN	__imp__GetDC@4:PROC
EXTRN	__imp__LoadIconW@8:PROC
EXTRN	__imp__wglMakeCurrent@8:PROC
EXTRN	__imp__ReleaseDC@8:PROC
EXTRN	__imp__ShowWindow@8:PROC
EXTRN	__imp__RegisterRawInputDevices@12:PROC
EXTRN	__imp__CreateWindowExW@48:PROC
EXTRN	__imp__AdjustWindowRectEx@16:PROC
EXTRN	__imp__MessageBoxW@16:PROC
EXTRN	__imp__RegisterClassW@4:PROC
EXTRN	__imp__ChoosePixelFormat@8:PROC
EXTRN	__imp__SetPixelFormat@12:PROC
EXTRN	__imp__SwapBuffers@4:PROC
EXTRN	__imp__DefWindowProcW@16:PROC
EXTRN	__imp__wglCreateContext@4:PROC
	ALIGN	4

?instance@GLWindow@@2PAV1@A DD 01H DUP (?)		; GLWindow::instance
?wglSwapIntervalEXT@@3P6GPAUHGLRC__@@H@ZA DD 01H DUP (?) ; wglSwapIntervalEXT
?wglCreateContextAttribsARB@@3P6GPAUHGLRC__@@PAUHDC__@@PAU1@PBH@ZA DD 01H DUP (?) ; wglCreateContextAttribsARB
_BSS	ENDS
;	COMDAT ?pfd@?7??initWindow@GLWindow@@QAEXXZ@4UtagPIXELFORMATDESCRIPTOR@@A
_DATA	SEGMENT
?pfd@?7??initWindow@GLWindow@@QAEXXZ@4UtagPIXELFORMATDESCRIPTOR@@A DW 028H ; `GLWindow::initWindow'::`8'::pfd
	DW	01H
	DD	025H
	DB	00H
	DB	010H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	010H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DD	00H
	DD	00H
	DD	00H
$SG4294937617 DB 'G', 00H, 'L', 00H, 'W', 00H, 'i', 00H, 'n', 00H, 'd', 00H
	DB	'o', 00H, 'w', 00H, 00H, 00H
$SG4294937616 DB 'R', 00H, 'e', 00H, 'g', 00H, 'i', 00H, 's', 00H, 't', 00H
	DB	'r', 00H, 'a', 00H, 't', 00H, 'i', 00H, 'o', 00H, 'n', 00H, ' '
	DB	00H, 'e', 00H, 'r', 00H, 'r', 00H, 'o', 00H, 'r', 00H, 00H, 00H
	ORG $+2
$SG4294937615 DB 'C', 00H, 'o', 00H, 'u', 00H, 'l', 00H, 'd', 00H, ' ', 00H
	DB	'n', 00H, 'o', 00H, 't', 00H, ' ', 00H, 'r', 00H, 'e', 00H, 'g'
	DB	00H, 'i', 00H, 's', 00H, 't', 00H, 'e', 00H, 'r', 00H, ' ', 00H
	DB	'w', 00H, 'i', 00H, 'n', 00H, 'd', 00H, 'o', 00H, 'w', 00H, ' '
	DB	00H, 'c', 00H, 'l', 00H, 'a', 00H, 's', 00H, 's', 00H, '.', 00H
	DB	00H, 00H
	ORG $+2
$SG4294937614 DB 'G', 00H, 'L', 00H, 'W', 00H, 'i', 00H, 'n', 00H, 'd', 00H
	DB	'o', 00H, 'w', 00H, 00H, 00H
	ORG $+2
$SG4294937613 DB 'wglCreateContextAttribsARB', 00H
	ORG $+1
$SG4294937612 DB 'wglSwapIntervalEXT', 00H
	ORG $+1
$SG4294937611 DB 'G', 00H, 'L', 00H, 'W', 00H, 'i', 00H, 'n', 00H, 'd', 00H
	DB	'o', 00H, 'w', 00H, 00H, 00H
	ORG $+2
$SG4294937610 DB 'E', 00H, 'R', 00H, 'R', 00H, 'O', 00H, 'R', 00H, 00H, 00H
$SG4294937609 DB 'T', 00H, 'h', 00H, 'e', 00H, 'r', 00H, 'e', 00H, ' ', 00H
	DB	'w', 00H, 'a', 00H, 's', 00H, ' ', 00H, 'a', 00H, 'n', 00H, ' '
	DB	00H, 'e', 00H, 'r', 00H, 'r', 00H, 'o', 00H, 'r', 00H, ' ', 00H
	DB	'w', 00H, 'h', 00H, 'i', 00H, 'l', 00H, 'e', 00H, ' ', 00H, 'd'
	DB	00H, 'e', 00H, 's', 00H, 't', 00H, 'r', 00H, 'o', 00H, 'y', 00H
	DB	'i', 00H, 'n', 00H, 'g', 00H, ' ', 00H, 't', 00H, 'h', 00H, 'e'
	DB	00H, ' ', 00H, 'w', 00H, 'i', 00H, 'n', 00H, 'd', 00H, 'o', 00H
	DB	'w', 00H, 00H, 00H
PUBLIC	?put@?$List@VMouseAction@@$0BA@@@QAEXVMouseAction@@@Z ; List<MouseAction,16>::put
PUBLIC	?put@?$List@VKeyboardAction@@$0BA@@@QAEXVKeyboardAction@@@Z ; List<KeyboardAction,16>::put
PUBLIC	?wndProc@@YGJPAUHWND__@@IIJ@Z			; wndProc
PUBLIC	?destroyWindow@GLWindow@@QAEXXZ			; GLWindow::destroyWindow
PUBLIC	?initWindow@GLWindow@@QAEXXZ			; GLWindow::initWindow
PUBLIC	??1GLWindow@@QAE@XZ				; GLWindow::~GLWindow
PUBLIC	??0GLWindow@@QAE@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@HHPAUHINSTANCE__@@HH@Z ; GLWindow::GLWindow
PUBLIC	?messageBox@GLWindow@@QAEXPB_W0I@Z		; GLWindow::messageBox
PUBLIC	?isOK@GLWindow@@QAE_NXZ				; GLWindow::isOK
PUBLIC	?destroyGL@GLWindow@@QAEXXZ			; GLWindow::destroyGL
PUBLIC	?swapBuffers@GLWindow@@QAEXXZ			; GLWindow::swapBuffers
PUBLIC	?initGL@GLWindow@@QAEXXZ			; GLWindow::initGL
__Tuple_alloc DB 01H DUP (?)
_BSS	ENDS
;	COMDAT ?lpb@?BJ@??wndProc@@YGJPAUHWND__@@IIJ@Z@4PAEA
_BSS	SEGMENT
?lpb@?BJ@??wndProc@@YGJPAUHWND__@@IIJ@Z@4PAEA DB 028H DUP (?) ; `wndProc'::`25'::lpb
	ALIGN	4

_ignore	DB	01H DUP (?)
	ALIGN	4

_allocator_arg DB 01H DUP (?)
	ALIGN	4

_piecewise_construct DB 01H DUP (?)
_BSS	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0GLWindow@@QAE@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@HHPAUHINSTANCE__@@HH@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0GLWindow@@QAE@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@HHPAUHINSTANCE__@@HH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0GLWindow@@QAE@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@HHPAUHINSTANCE__@@HH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0GLWindow@@QAE@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@HHPAUHINSTANCE__@@HH@Z$0
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\window.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\glew.c
; File c:\users\glenn\documents\github\wind\project\wind\wind\window.cpp
;	COMDAT ?initGL@GLWindow@@QAEXXZ
_TEXT	SEGMENT
_attribs$ = -32						; size = 28
__$ArrayPad$ = -4					; size = 4
?initGL@GLWindow@@QAEXXZ PROC				; GLWindow::initGL, COMDAT
; _this$dead$ = ecx

; 130  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	57		 push	 edi
  00011	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?instance@GLWindow@@2PAV1@A ; GLWindow::instance

; 131  : 	if(!(hRC_temp = wglCreateContext(hDC)))

  00017	ff 77 0c	 push	 DWORD PTR [edi+12]
  0001a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wglCreateContext@4
  00020	89 47 14	 mov	 DWORD PTR [edi+20], eax
  00023	85 c0		 test	 eax, eax
  00025	75 18		 jne	 SHORT $LN7@initGL

; 132  : 	{
; 133  : 		OK = false;
; 134  : 		destroyWindow();

  00027	8b cf		 mov	 ecx, edi
  00029	88 07		 mov	 BYTE PTR [edi], al
  0002b	e8 00 00 00 00	 call	 ?destroyWindow@GLWindow@@QAEXXZ ; GLWindow::destroyWindow
  00030	5f		 pop	 edi

; 184  : 		//destroyWindow();
; 185  : 		return;
; 186  : 	}
; 187  : }

  00031	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00034	33 cd		 xor	 ecx, ebp
  00036	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0003b	8b e5		 mov	 esp, ebp
  0003d	5d		 pop	 ebp
  0003e	c3		 ret	 0
$LN7@initGL:
  0003f	53		 push	 ebx

; 135  : 		return;
; 136  : 	}
; 137  : 
; 138  : 	if(!wglMakeCurrent(hDC, hRC_temp))

  00040	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__wglMakeCurrent@8
  00046	50		 push	 eax
  00047	ff 77 0c	 push	 DWORD PTR [edi+12]
  0004a	ff d3		 call	 ebx
  0004c	85 c0		 test	 eax, eax
  0004e	74 2f		 je	 SHORT $LN16@initGL

; 139  : 	{
; 140  : 		OK = false;
; 141  : 		destroyWindow();
; 142  : 		return;
; 143  : 	}
; 144  : 
; 145  : 	ShowWindow(hWnd, SW_SHOW);

  00050	6a 05		 push	 5
  00052	ff 77 08	 push	 DWORD PTR [edi+8]
  00055	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ShowWindow@8

; 146  : 	SetForegroundWindow(hWnd);

  0005b	ff 77 08	 push	 DWORD PTR [edi+8]
  0005e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetForegroundWindow@4

; 147  : 	SetFocus(hWnd);

  00064	ff 77 08	 push	 DWORD PTR [edi+8]
  00067	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetFocus@4
; File c:\users\glenn\documents\github\wind\project\wind\wind\glew.c

; 13482:   r = glewContextInit();

  0006d	e8 00 00 00 00	 call	 _glewContextInit@0

; 13483:   if ( r != 0 ) return r;

  00072	85 c0		 test	 eax, eax
  00074	75 09		 jne	 SHORT $LN16@initGL

; 13484: #if defined(_WIN32)
; 13485:   return wglewContextInit();

  00076	e8 00 00 00 00	 call	 _wglewContextInit@0
; File c:\users\glenn\documents\github\wind\project\wind\wind\window.cpp

; 149  : 	if(glewInit() != GLEW_OK)

  0007b	85 c0		 test	 eax, eax
  0007d	74 1a		 je	 SHORT $LN5@initGL
$LN16@initGL:

; 150  : 	{
; 151  : 		OK = false;
; 152  : 		destroyWindow();

  0007f	8b cf		 mov	 ecx, edi
  00081	c6 07 00	 mov	 BYTE PTR [edi], 0
  00084	e8 00 00 00 00	 call	 ?destroyWindow@GLWindow@@QAEXXZ ; GLWindow::destroyWindow
  00089	5b		 pop	 ebx
  0008a	5f		 pop	 edi

; 184  : 		//destroyWindow();
; 185  : 		return;
; 186  : 	}
; 187  : }

  0008b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0008e	33 cd		 xor	 ecx, ebp
  00090	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00095	8b e5		 mov	 esp, ebp
  00097	5d		 pop	 ebp
  00098	c3		 ret	 0
$LN5@initGL:

; 153  : 		return;
; 154  : 	}
; 155  : 
; 156  : 	if((major_gl_version > 1) | (minor_gl_version > 2))

  00099	8b 57 40	 mov	 edx, DWORD PTR [edi+64]
  0009c	33 c9		 xor	 ecx, ecx
  0009e	56		 push	 esi
  0009f	8b 77 3c	 mov	 esi, DWORD PTR [edi+60]
  000a2	83 fe 01	 cmp	 esi, 1
  000a5	0f 9f c1	 setg	 cl
  000a8	33 c0		 xor	 eax, eax
  000aa	83 fa 02	 cmp	 edx, 2
  000ad	0f 9f c0	 setg	 al
  000b0	0b c8		 or	 ecx, eax
  000b2	75 7f		 jne	 SHORT $LN14@initGL

; 157  : 	{
; 158  : 		return;
; 159  : 	}
; 160  : 
; 161  : 	int attribs[] =
; 162  : 	{
; 163  : 		WGL_CONTEXT_MAJOR_VERSION_ARB, major_gl_version,

  000b4	89 75 e4	 mov	 DWORD PTR _attribs$[ebp+4], esi

; 164  : 		WGL_CONTEXT_MINOR_VERSION_ARB, minor_gl_version,
; 165  : 		WGL_CONTEXT_FLAGS_ARB, 0,
; 166  : 		0
; 167  : 	};
; 168  : 
; 169  : 	wglCreateContextAttribsARB = (PFNWGLCREATECONTEXTATTRIBSARBPROC)wglGetProcAddress((LPCSTR)"wglCreateContextAttribsARB");

  000b7	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__wglGetProcAddress@4
  000bd	68 00 00 00 00	 push	 OFFSET $SG4294937613
  000c2	c7 45 e0 91 20
	00 00		 mov	 DWORD PTR _attribs$[ebp], 8337 ; 00002091H
  000c9	c7 45 e8 92 20
	00 00		 mov	 DWORD PTR _attribs$[ebp+8], 8338 ; 00002092H
  000d0	89 55 ec	 mov	 DWORD PTR _attribs$[ebp+12], edx
  000d3	c7 45 f0 94 20
	00 00		 mov	 DWORD PTR _attribs$[ebp+16], 8340 ; 00002094H
  000da	89 4d f4	 mov	 DWORD PTR _attribs$[ebp+20], ecx
  000dd	89 4d f8	 mov	 DWORD PTR _attribs$[ebp+24], ecx
  000e0	ff d6		 call	 esi

; 170  : 	wglSwapIntervalEXT = (PFNWGLSWAPINTERVALEXTPROC)wglGetProcAddress((LPCSTR)"wglSwapIntervalEXT");

  000e2	68 00 00 00 00	 push	 OFFSET $SG4294937612
  000e7	a3 00 00 00 00	 mov	 DWORD PTR ?wglCreateContextAttribsARB@@3P6GPAUHGLRC__@@PAUHDC__@@PAU1@PBH@ZA, eax ; wglCreateContextAttribsARB
  000ec	ff d6		 call	 esi

; 171  : 
; 172  : 	wglSwapIntervalEXT(0);

  000ee	6a 00		 push	 0
  000f0	a3 00 00 00 00	 mov	 DWORD PTR ?wglSwapIntervalEXT@@3P6GPAUHGLRC__@@H@ZA, eax ; wglSwapIntervalEXT
  000f5	ff d0		 call	 eax

; 173  : 
; 174  : 	if(!(hRC = wglCreateContextAttribsARB(hDC, 0, attribs)))

  000f7	8d 45 e0	 lea	 eax, DWORD PTR _attribs$[ebp]
  000fa	50		 push	 eax
  000fb	6a 00		 push	 0
  000fd	ff 77 0c	 push	 DWORD PTR [edi+12]
  00100	ff 15 00 00 00
	00		 call	 DWORD PTR ?wglCreateContextAttribsARB@@3P6GPAUHGLRC__@@PAUHDC__@@PAU1@PBH@ZA ; wglCreateContextAttribsARB
  00106	89 47 10	 mov	 DWORD PTR [edi+16], eax
  00109	85 c0		 test	 eax, eax
  0010b	74 23		 je	 SHORT $LN1@initGL

; 175  : 	{
; 176  : 		OK = false;
; 177  : 		//destroyWindow();
; 178  : 		return;
; 179  : 	}
; 180  : 
; 181  : 	if(!wglMakeCurrent(NULL, NULL) || !wglDeleteContext(hRC_temp) || !wglMakeCurrent(hDC, hRC))

  0010d	6a 00		 push	 0
  0010f	6a 00		 push	 0
  00111	ff d3		 call	 ebx
  00113	85 c0		 test	 eax, eax
  00115	74 19		 je	 SHORT $LN1@initGL
  00117	ff 77 14	 push	 DWORD PTR [edi+20]
  0011a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wglDeleteContext@4
  00120	85 c0		 test	 eax, eax
  00122	74 0c		 je	 SHORT $LN1@initGL
  00124	ff 77 10	 push	 DWORD PTR [edi+16]
  00127	ff 77 0c	 push	 DWORD PTR [edi+12]
  0012a	ff d3		 call	 ebx
  0012c	85 c0		 test	 eax, eax
  0012e	75 03		 jne	 SHORT $LN14@initGL
$LN1@initGL:

; 182  : 	{
; 183  : 		OK = false;

  00130	c6 07 00	 mov	 BYTE PTR [edi], 0
$LN14@initGL:

; 184  : 		//destroyWindow();
; 185  : 		return;
; 186  : 	}
; 187  : }

  00133	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00136	5e		 pop	 esi
  00137	5b		 pop	 ebx
  00138	33 cd		 xor	 ecx, ebp
  0013a	5f		 pop	 edi
  0013b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00140	8b e5		 mov	 esp, ebp
  00142	5d		 pop	 ebp
  00143	c3		 ret	 0
?initGL@GLWindow@@QAEXXZ ENDP				; GLWindow::initGL
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\window.cpp
;	COMDAT ?swapBuffers@GLWindow@@QAEXXZ
_TEXT	SEGMENT
?swapBuffers@GLWindow@@QAEXXZ PROC			; GLWindow::swapBuffers, COMDAT
; _this$dead$ = ecx

; 191  : 	SwapBuffers(hDC);

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?instance@GLWindow@@2PAV1@A ; GLWindow::instance
  00005	ff 70 0c	 push	 DWORD PTR [eax+12]
  00008	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SwapBuffers@4

; 192  : }

  0000e	c3		 ret	 0
?swapBuffers@GLWindow@@QAEXXZ ENDP			; GLWindow::swapBuffers
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\window.cpp
;	COMDAT ?destroyGL@GLWindow@@QAEXXZ
_TEXT	SEGMENT
?destroyGL@GLWindow@@QAEXXZ PROC			; GLWindow::destroyGL, COMDAT
; _this$dead$ = ecx

; 215  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?instance@GLWindow@@2PAV1@A ; GLWindow::instance

; 216  : 	bool error = false;
; 217  : 
; 218  : 	//glBindVertexArray(0);
; 219  : 
; 220  : 	if(hRC)

  0000b	83 7e 10 00	 cmp	 DWORD PTR [esi+16], 0
  0000f	74 13		 je	 SHORT $LN1@destroyGL

; 221  : 	{
; 222  : 		if(!wglMakeCurrent(NULL, NULL))

  00011	6a 00		 push	 0
  00013	6a 00		 push	 0
  00015	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wglMakeCurrent@8

; 223  : 		{
; 224  : 			error = true;
; 225  : 		}
; 226  : 
; 227  : 		if(!wglDeleteContext(hRC))

  0001b	ff 76 10	 push	 DWORD PTR [esi+16]
  0001e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wglDeleteContext@4
$LN1@destroyGL:
  00024	5e		 pop	 esi

; 228  : 		{
; 229  : 			error = true;
; 230  : 		}
; 231  : 	}
; 232  : }

  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
?destroyGL@GLWindow@@QAEXXZ ENDP			; GLWindow::destroyGL
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\window.cpp
;	COMDAT ?isOK@GLWindow@@QAE_NXZ
_TEXT	SEGMENT
?isOK@GLWindow@@QAE_NXZ PROC				; GLWindow::isOK, COMDAT
; _this$dead$ = ecx

; 201  : 	return OK;

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?instance@GLWindow@@2PAV1@A ; GLWindow::instance
  00005	8a 00		 mov	 al, BYTE PTR [eax]

; 202  : }

  00007	c3		 ret	 0
?isOK@GLWindow@@QAE_NXZ ENDP				; GLWindow::isOK
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\window.cpp
;	COMDAT ?messageBox@GLWindow@@QAEXPB_W0I@Z
_TEXT	SEGMENT
_lpText$ = 8						; size = 4
_lpCaption$dead$ = 12					; size = 4
_uType$dead$ = 16					; size = 4
?messageBox@GLWindow@@QAEXPB_W0I@Z PROC			; GLWindow::messageBox, COMDAT
; _this$dead$ = ecx

; 210  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 211  : 	MessageBox(hWnd, lpText, lpText, uType);

  00003	8b 45 08	 mov	 eax, DWORD PTR _lpText$[ebp]
  00006	6a 10		 push	 16			; 00000010H
  00008	50		 push	 eax
  00009	50		 push	 eax
  0000a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?instance@GLWindow@@2PAV1@A ; GLWindow::instance
  0000f	ff 70 08	 push	 DWORD PTR [eax+8]
  00012	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxW@16

; 212  : }

  00018	5d		 pop	 ebp
  00019	c2 0c 00	 ret	 12			; 0000000cH
?messageBox@GLWindow@@QAEXPB_W0I@Z ENDP			; GLWindow::messageBox
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\window.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\users\glenn\documents\github\wind\project\wind\wind\window.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\users\glenn\documents\github\wind\project\wind\wind\window.cpp
;	COMDAT ??0GLWindow@@QAE@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@HHPAUHINSTANCE__@@HH@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_title$ = 8						; size = 24
_width$dead$ = 32					; size = 4
_height$dead$ = 36					; size = 4
_hInstance$ = 40					; size = 4
_major_gl_version$dead$ = 44				; size = 4
_minor_gl_version$dead$ = 48				; size = 4
??0GLWindow@@QAE@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@HHPAUHINSTANCE__@@HH@Z PROC ; GLWindow::GLWindow, COMDAT
; _this$ = ecx

; 21   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0GLWindow@@QAE@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@HHPAUHINSTANCE__@@HH@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	8b f1		 mov	 esi, ecx
  00025	8b 45 28	 mov	 eax, DWORD PTR _hInstance$[ebp]
  00028	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0002f	89 46 04	 mov	 DWORD PTR [esi+4], eax
  00032	8d 4e 18	 lea	 ecx, DWORD PTR [esi+24]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd

; 347  : 		_Left = _Right;

  00035	33 c0		 xor	 eax, eax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 735  : 		assign(_Right, 0, npos);

  00037	6a ff		 push	 -1

; 2257 : 			{	// copy any leftovers to small buffer and deallocate
; 2258 : 			pointer _Ptr = this->_Bx._Ptr;
; 2259 : 			this->_Getal().destroy(&this->_Bx._Ptr);
; 2260 : 			if (0 < _Newsize)
; 2261 : 				_Traits::copy(this->_Bx._Buf,
; 2262 : 					_STD addressof(*_Ptr), _Newsize);
; 2263 : 			this->_Getal().deallocate(_Ptr, this->_Myres + 1);
; 2264 : 			}
; 2265 : 		this->_Myres = this->_BUF_SIZE - 1;

  00039	c7 41 14 07 00
	00 00		 mov	 DWORD PTR [ecx+20], 7

; 736  : 		}
; 737  : 
; 738  :  #if _HAS_CPP0X
; 739  : 	basic_string(const _Myt& _Right, const _Alloc& _Al)
; 740  : 		: _Mybase(_Al)
; 741  : 		{	// construct by copying with allocator
; 742  : 		_Tidy();
; 743  : 		assign(_Right, 0, npos);
; 744  : 		}
; 745  :  #endif /* _HAS_CPP0X */
; 746  : 
; 747  : 	basic_string()
; 748  : 		: _Mybase()
; 749  : 		{	// construct empty string
; 750  : 		_Tidy();
; 751  : 		}
; 752  : 
; 753  : 	explicit basic_string(const _Alloc& _Al)
; 754  : 		: _Mybase(_Al)
; 755  : 		{	// construct empty string with allocator
; 756  : 		_Tidy();
; 757  : 		}
; 758  : 
; 759  : 	basic_string(const _Myt& _Right, size_type _Roff,
; 760  : 		size_type _Count = npos)
; 761  : 		: _Mybase(_Right._Getal())
; 762  : 		{	// construct from _Right [_Roff, _Roff + _Count)
; 763  : 		_Tidy();
; 764  : 		assign(_Right, _Roff, _Count);
; 765  : 		}
; 766  : 
; 767  : 	basic_string(const _Myt& _Right, size_type _Roff, size_type _Count,
; 768  : 		const _Alloc& _Al)
; 769  : 		: _Mybase(_Al)
; 770  : 		{	// construct from _Right [_Roff, _Roff + _Count) with allocator
; 771  : 		_Tidy();
; 772  : 		assign(_Right, _Roff, _Count);
; 773  : 		}
; 774  : 
; 775  : 	basic_string(const _Elem *_Ptr, size_type _Count)
; 776  : 		: _Mybase()
; 777  : 		{	// construct from [_Ptr, _Ptr + _Count)
; 778  : 		_Tidy();
; 779  : 		assign(_Ptr, _Count);
; 780  : 		}
; 781  : 
; 782  : 	basic_string(const _Elem *_Ptr, size_type _Count, const _Alloc& _Al)
; 783  : 		: _Mybase(_Al)
; 784  : 		{	// construct from [_Ptr, _Ptr + _Count) with allocator
; 785  : 		_Tidy();
; 786  : 		assign(_Ptr, _Count);
; 787  : 		}
; 788  : 
; 789  : 	basic_string(const _Elem *_Ptr)
; 790  : 		: _Mybase()
; 791  : 		{	// construct from [_Ptr, <null>)
; 792  : 		_Tidy();
; 793  : 		assign(_Ptr);
; 794  : 		}
; 795  : 
; 796  : 	basic_string(const _Elem *_Ptr, const _Alloc& _Al)
; 797  : 		: _Mybase(_Al)
; 798  : 		{	// construct from [_Ptr, <null>) with allocator
; 799  : 		_Tidy();
; 800  : 		assign(_Ptr);
; 801  : 		}
; 802  : 
; 803  : 	basic_string(size_type _Count, _Elem _Ch)
; 804  : 		: _Mybase()
; 805  : 		{	// construct from _Count * _Ch
; 806  : 		_Tidy();
; 807  : 		assign(_Count, _Ch);
; 808  : 		}
; 809  : 
; 810  : 	basic_string(size_type _Count, _Elem _Ch, const _Alloc& _Al)
; 811  : 		: _Mybase(_Al)
; 812  : 		{	// construct from _Count * _Ch with allocator
; 813  : 		_Tidy();
; 814  : 		assign(_Count, _Ch);
; 815  : 		}
; 816  : 
; 817  : 	template<class _Iter>
; 818  : 		basic_string(_Iter _First, _Iter _Last,
; 819  : 			typename enable_if<_Is_iterator<_Iter>::value,
; 820  : 				void>::type ** = 0)
; 821  : 		: _Mybase()
; 822  : 		{	// construct from [_First, _Last)
; 823  : 		_Tidy();
; 824  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 825  : 		}
; 826  : 
; 827  : 	template<class _Iter>
; 828  : 		basic_string(_Iter _First, _Iter _Last, const _Alloc& _Al,
; 829  : 			typename enable_if<_Is_iterator<_Iter>::value,
; 830  : 				void>::type ** = 0)
; 831  : 		: _Mybase(_Al)
; 832  : 		{	// construct from [_First, _Last) with allocator
; 833  : 		_Tidy();
; 834  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 835  : 		}
; 836  : 
; 837  : 	template<class _Iter>
; 838  : 		void _Construct(_Iter _First,
; 839  : 			_Iter _Last, input_iterator_tag)
; 840  : 		{	// initialize from [_First, _Last), input iterators
; 841  : 		_TRY_BEGIN
; 842  : 		for (; _First != _Last; ++_First)
; 843  : 			append((size_type)1, (_Elem)*_First);
; 844  : 		_CATCH_ALL
; 845  : 		_Tidy(true);
; 846  : 		_RERAISE;
; 847  : 		_CATCH_END
; 848  : 		}
; 849  : 
; 850  : 	template<class _Iter>
; 851  : 		void _Construct(_Iter _First,
; 852  : 			_Iter _Last, forward_iterator_tag)
; 853  : 		{	// initialize from [_First, _Last), forward iterators
; 854  : 		_DEBUG_RANGE(_First, _Last);
; 855  : 		size_type _Count = 0;
; 856  : 		_Distance(_First, _Last, _Count);
; 857  : 		reserve(_Count);
; 858  : 
; 859  : 		_TRY_BEGIN
; 860  : 		for (; _First != _Last; ++_First)
; 861  : 			append((size_type)1, (_Elem)*_First);
; 862  : 		_CATCH_ALL
; 863  : 		_Tidy(true);
; 864  : 		_RERAISE;
; 865  : 		_CATCH_END
; 866  : 		}
; 867  : 
; 868  : 	basic_string(const_pointer _First, const_pointer _Last)
; 869  : 		: _Mybase()
; 870  : 		{	// construct from [_First, _Last), const pointers
; 871  : 		_DEBUG_RANGE(_First, _Last);
; 872  : 		_Tidy();
; 873  : 		if (_First != _Last)
; 874  : 			assign(&*_First, _Last - _First);
; 875  : 		}
; 876  : 
; 877  : 	basic_string(const_pointer _First, const_pointer _Last,
; 878  : 		const _Alloc& _Al)
; 879  : 		: _Mybase(_Al)
; 880  : 		{	// construct from [_First, _Last), const pointers
; 881  : 		_DEBUG_RANGE(_First, _Last);
; 882  : 		_Tidy();
; 883  : 		if (_First != _Last)
; 884  : 			assign(&*_First, _Last - _First);
; 885  : 		}
; 886  : 
; 887  : 	basic_string(const_iterator _First, const_iterator _Last)
; 888  : 		: _Mybase()
; 889  : 		{	// construct from [_First, _Last), const_iterators
; 890  : 		_DEBUG_RANGE(_First, _Last);
; 891  : 		_Tidy();
; 892  : 		if (_First != _Last)
; 893  : 			assign(&*_First, _Last - _First);
; 894  : 		}
; 895  : 
; 896  : 	basic_string(_Myt&& _Right) _NOEXCEPT
; 897  : 		: _Mybase(_Right._Getal())
; 898  : 		{	// construct by moving _Right
; 899  : 		_Tidy();
; 900  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 901  : 		}
; 902  : 
; 903  : 	basic_string(_Myt&& _Right, const _Alloc& _Al)
; 904  : 		: _Mybase(_Al)
; 905  : 		{	// construct by moving _Right, allocator
; 906  : 		if (this->_Getal() != _Right._Getal())
; 907  : 			assign(_Right.begin(), _Right.end());
; 908  : 		else
; 909  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 910  : 		}
; 911  : 
; 912  : 	_Myt& operator=(_Myt&& _Right) _NOEXCEPT
; 913  : 		{	// assign by moving _Right
; 914  : 		if (this != &_Right)
; 915  : 			{	// different, assign it
; 916  : 			_Tidy(true);
; 917  : 
; 918  :  #if _HAS_CPP0X
; 919  : 			if (this->_Getal() != _Right._Getal()
; 920  : 				&& _Alty::propagate_on_container_move_assignment::value)
; 921  : 				this->_Change_alloc(_Right._Getal());
; 922  :  #endif /* _HAS_CPP0X */
; 923  : 
; 924  : 			if (this->_Getal() != _Right._Getal())
; 925  : 				assign(_Right.begin(), _Right.end());
; 926  : 			else
; 927  : 				_Assign_rv(_STD forward<_Myt>(_Right));
; 928  : 			}
; 929  : 		return (*this);
; 930  : 		}
; 931  : 
; 932  : 	_Myt& assign(_Myt&& _Right) _NOEXCEPT
; 933  : 		{	// assign by moving _Right
; 934  : 		if (this == &_Right)
; 935  : 			;
; 936  : 		else if (get_allocator() != _Right.get_allocator()
; 937  : 			&& this->_BUF_SIZE <= _Right._Myres)
; 938  : 			*this = _Right;
; 939  : 		else
; 940  : 			{	// not same, clear this and steal from _Right
; 941  : 			_Tidy(true);
; 942  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 943  : 			}
; 944  : 		return (*this);
; 945  : 		}
; 946  : 
; 947  : 	void _Assign_rv(_Myt&& _Right)
; 948  : 		{	// assign by moving _Right
; 949  : 		if (_Right._Myres < this->_BUF_SIZE)
; 950  : 			_Traits::move(this->_Bx._Buf, _Right._Bx._Buf,
; 951  : 				_Right._Mysize + 1);
; 952  : 		else
; 953  : 			{	// copy pointer
; 954  : 			this->_Getal().construct(&this->_Bx._Ptr, _Right._Bx._Ptr);
; 955  : 			_Right._Bx._Ptr = pointer();
; 956  : 			}
; 957  : 		this->_Mysize = _Right._Mysize;
; 958  : 		this->_Myres = _Right._Myres;
; 959  : 		_Right._Tidy();
; 960  : 		}
; 961  : 
; 962  : 	~basic_string() _NOEXCEPT
; 963  : 		{	// destroy the string
; 964  : 		_Tidy(true);
; 965  : 		}
; 966  : 
; 967  : 	_PGLOBAL static const size_type npos;	// bad/missing length/position
; 968  : 
; 969  : 	_Myt& operator=(const _Myt& _Right)
; 970  : 		{	// assign _Right
; 971  : 		if (this != &_Right)
; 972  : 			{	// different, assign it
; 973  :  #if _HAS_CPP0X
; 974  : 			if (this->_Getal() != _Right._Getal()
; 975  : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 976  : 				{	// change allocator before copying
; 977  : 				_Tidy(true);
; 978  : 				this->_Change_alloc(_Right._Getal());
; 979  : 				}
; 980  :  #endif /* _HAS_CPP0X */
; 981  : 
; 982  : 			assign(_Right);
; 983  : 			}
; 984  : 		return (*this);
; 985  : 		}
; 986  : 
; 987  : 	_Myt& operator=(const _Elem *_Ptr)
; 988  : 		{	// assign [_Ptr, <null>)
; 989  : 		return (assign(_Ptr));
; 990  : 		}
; 991  : 
; 992  : 	_Myt& operator=(_Elem _Ch)
; 993  : 		{	// assign 1 * _Ch
; 994  : 		return (assign(1, _Ch));
; 995  : 		}
; 996  : 
; 997  : 	_Myt& operator+=(const _Myt& _Right)
; 998  : 		{	// append _Right
; 999  : 		return (append(_Right));
; 1000 : 		}
; 1001 : 
; 1002 : 	_Myt& operator+=(const _Elem *_Ptr)
; 1003 : 		{	// append [_Ptr, <null>)
; 1004 : 		return (append(_Ptr));
; 1005 : 		}
; 1006 : 
; 1007 : 	_Myt& operator+=(_Elem _Ch)
; 1008 : 		{	// append 1 * _Ch
; 1009 : 		return (append((size_type)1, _Ch));
; 1010 : 		}
; 1011 : 
; 1012 : 	_Myt& append(const _Myt& _Right)
; 1013 : 		{	// append _Right
; 1014 : 		return (append(_Right, 0, npos));
; 1015 : 		}
; 1016 : 
; 1017 : 	_Myt& append(const _Myt& _Right,
; 1018 : 		size_type _Roff, size_type _Count)
; 1019 : 		{	// append _Right [_Roff, _Roff + _Count)
; 1020 : 		if (_Right.size() < _Roff)
; 1021 : 			_Xran();	// _Roff off end
; 1022 : 		size_type _Num = _Right.size() - _Roff;
; 1023 : 		if (_Num < _Count)
; 1024 : 			_Count = _Num;	// trim _Count to size
; 1025 : 		if (npos - this->_Mysize <= _Count)
; 1026 : 			_Xlen();	// result too long
; 1027 : 
; 1028 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1029 : 			{	// make room and append new stuff
; 1030 : 			_Traits::copy(this->_Myptr() + this->_Mysize,
; 1031 : 				_Right._Myptr() + _Roff, _Count);
; 1032 : 			_Eos(_Num);
; 1033 : 			}
; 1034 : 		return (*this);
; 1035 : 		}
; 1036 : 
; 1037 : 	_Myt& append(const _Elem *_Ptr, size_type _Count)
; 1038 : 		{	// append [_Ptr, _Ptr + _Count)
; 1039 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1040 : 		if (_Count != 0)
; 1041 : 			_DEBUG_POINTER(_Ptr);
; 1042 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1043 : 
; 1044 : 		if (_Inside(_Ptr))
; 1045 : 			return (append(*this,
; 1046 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1047 : 		if (npos - this->_Mysize <= _Count)
; 1048 : 			_Xlen();	// result too long
; 1049 : 
; 1050 : 		size_type _Num;
; 1051 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1052 : 			{	// make room and append new stuff
; 1053 : 			_Traits::copy(this->_Myptr() + this->_Mysize, _Ptr, _Count);
; 1054 : 			_Eos(_Num);
; 1055 : 			}
; 1056 : 		return (*this);
; 1057 : 		}
; 1058 : 
; 1059 : 	_Myt& append(const _Elem *_Ptr)
; 1060 : 		{	// append [_Ptr, <null>)
; 1061 : 		_DEBUG_POINTER(_Ptr);
; 1062 : 		return (append(_Ptr, _Traits::length(_Ptr)));
; 1063 : 		}
; 1064 : 
; 1065 : 	_Myt& append(size_type _Count, _Elem _Ch)
; 1066 : 		{	// append _Count * _Ch
; 1067 : 		if (npos - this->_Mysize <= _Count)
; 1068 : 			_Xlen();	// result too long
; 1069 : 
; 1070 : 		size_type _Num;
; 1071 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1072 : 			{	// make room and append new stuff using assign
; 1073 : 			_Chassign(this->_Mysize, _Count, _Ch);
; 1074 : 			_Eos(_Num);
; 1075 : 			}
; 1076 : 		return (*this);
; 1077 : 		}
; 1078 : 
; 1079 : 	template<class _Iter>
; 1080 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1081 : 			_Myt&>::type
; 1082 : 		append(_Iter _First, _Iter _Last)
; 1083 : 		{	// append [_First, _Last), input iterators
; 1084 : 		return (replace(end(), end(), _First, _Last));
; 1085 : 		}
; 1086 : 
; 1087 : 	_Myt& append(const_pointer _First, const_pointer _Last)
; 1088 : 		{	// append [_First, _Last), const pointers
; 1089 : 		return (replace(end(), end(), _First, _Last));
; 1090 : 		}
; 1091 : 
; 1092 : 	_Myt& append(const_iterator _First, const_iterator _Last)
; 1093 : 		{	// append [_First, _Last), const_iterators
; 1094 : 		return (replace(end(), end(), _First, _Last));
; 1095 : 		}
; 1096 : 
; 1097 : 	_Myt& assign(const _Myt& _Right)
; 1098 : 		{	// assign _Right
; 1099 : 		return (assign(_Right, 0, npos));
; 1100 : 		}
; 1101 : 
; 1102 : 	_Myt& assign(const _Myt& _Right,
; 1103 : 		size_type _Roff, size_type _Count)
; 1104 : 		{	// assign _Right [_Roff, _Roff + _Count)
; 1105 : 		if (_Right.size() < _Roff)
; 1106 : 			_Xran();	// _Roff off end
; 1107 : 		size_type _Num = _Right.size() - _Roff;
; 1108 : 		if (_Count < _Num)
; 1109 : 			_Num = _Count;	// trim _Num to size
; 1110 : 
; 1111 : 		if (this == &_Right)
; 1112 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring
; 1113 : 		else if (_Grow(_Num))
; 1114 : 			{	// make room and assign new stuff
; 1115 : 			_Traits::copy(this->_Myptr(),
; 1116 : 				_Right._Myptr() + _Roff, _Num);
; 1117 : 			_Eos(_Num);
; 1118 : 			}
; 1119 : 		return (*this);
; 1120 : 		}
; 1121 : 
; 1122 : 	_Myt& assign(const _Elem *_Ptr, size_type _Count)
; 1123 : 		{	// assign [_Ptr, _Ptr + _Count)
; 1124 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1125 : 		if (_Count != 0)
; 1126 : 			_DEBUG_POINTER(_Ptr);
; 1127 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1128 : 
; 1129 : 		if (_Inside(_Ptr))
; 1130 : 			return (assign(*this,
; 1131 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1132 : 
; 1133 : 		if (_Grow(_Count))
; 1134 : 			{	// make room and assign new stuff
; 1135 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);
; 1136 : 			_Eos(_Count);
; 1137 : 			}
; 1138 : 		return (*this);
; 1139 : 		}
; 1140 : 
; 1141 : 	_Myt& assign(const _Elem *_Ptr)
; 1142 : 		{	// assign [_Ptr, <null>)
; 1143 : 		_DEBUG_POINTER(_Ptr);
; 1144 : 		return (assign(_Ptr, _Traits::length(_Ptr)));
; 1145 : 		}
; 1146 : 
; 1147 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1148 : 		{	// assign _Count * _Ch
; 1149 : 		if (_Count == npos)
; 1150 : 			_Xlen();	// result too long
; 1151 : 
; 1152 : 		if (_Grow(_Count))
; 1153 : 			{	// make room and assign new stuff
; 1154 : 			_Chassign(0, _Count, _Ch);
; 1155 : 			_Eos(_Count);
; 1156 : 			}
; 1157 : 		return (*this);
; 1158 : 		}
; 1159 : 
; 1160 : 	template<class _Iter>
; 1161 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1162 : 			_Myt&>::type
; 1163 : 		assign(_Iter _First, _Iter _Last)
; 1164 : 		{	// assign [First, _Last), input iterators
; 1165 : 		return (replace(begin(), end(), _First, _Last));
; 1166 : 		}
; 1167 : 
; 1168 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1169 : 		{	// assign [First, _Last), const pointers
; 1170 : 		return (replace(begin(), end(), _First, _Last));
; 1171 : 		}
; 1172 : 
; 1173 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1174 : 		{	// assign [First, _Last), const_iterators
; 1175 : 		return (replace(begin(), end(), _First, _Last));
; 1176 : 		}
; 1177 : 
; 1178 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1179 : 		{	// insert _Right at _Off
; 1180 : 		return (insert(_Off, _Right, 0, npos));
; 1181 : 		}
; 1182 : 
; 1183 : 	_Myt& insert(size_type _Off,
; 1184 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1185 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1186 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1187 : 			_Xran();	// _Off or _Roff off end
; 1188 : 		size_type _Num = _Right.size() - _Roff;
; 1189 : 		if (_Num < _Count)
; 1190 : 			_Count = _Num;	// trim _Count to size
; 1191 : 		if (npos - this->_Mysize <= _Count)
; 1192 : 			_Xlen();	// result too long
; 1193 : 
; 1194 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1195 : 			{	// make room and insert new stuff
; 1196 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1197 : 				this->_Myptr() + _Off,
; 1198 : 				this->_Mysize - _Off);	// empty out hole
; 1199 : 			if (this == &_Right)
; 1200 : 				_Traits::move(this->_Myptr() + _Off,
; 1201 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1202 : 						_Count);	// substring
; 1203 : 			else
; 1204 : 				_Traits::copy(this->_Myptr() + _Off,
; 1205 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1206 : 			_Eos(_Num);
; 1207 : 			}
; 1208 : 		return (*this);
; 1209 : 		}
; 1210 : 
; 1211 : 	_Myt& insert(size_type _Off,
; 1212 : 		const _Elem *_Ptr, size_type _Count)
; 1213 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1214 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1215 : 		if (_Count != 0)
; 1216 : 			_DEBUG_POINTER(_Ptr);
; 1217 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1218 : 
; 1219 : 		if (_Inside(_Ptr))
; 1220 : 			return (insert(_Off, *this,
; 1221 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1222 : 		if (this->_Mysize < _Off)
; 1223 : 			_Xran();	// _Off off end
; 1224 : 		if (npos - this->_Mysize <= _Count)
; 1225 : 			_Xlen();	// result too long
; 1226 : 		size_type _Num;
; 1227 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1228 : 			{	// make room and insert new stuff
; 1229 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1230 : 				this->_Myptr() + _Off,
; 1231 : 				this->_Mysize - _Off);	// empty out hole
; 1232 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1233 : 			_Eos(_Num);
; 1234 : 			}
; 1235 : 		return (*this);
; 1236 : 		}
; 1237 : 
; 1238 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1239 : 		{	// insert [_Ptr, <null>) at _Off
; 1240 : 		_DEBUG_POINTER(_Ptr);
; 1241 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1242 : 		}
; 1243 : 
; 1244 : 	_Myt& insert(size_type _Off,
; 1245 : 		size_type _Count, _Elem _Ch)
; 1246 : 		{	// insert _Count * _Ch at _Off
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	iterator insert(const_iterator _Where)
; 1264 : 		{	// insert <null> at _Where
; 1265 : 		return (insert(_Where, _Elem()));
; 1266 : 		}
; 1267 : 
; 1268 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1269 : 		{	// insert _Ch at _Where
; 1270 : 		size_type _Off = _Pdif(_Where, begin());
; 1271 : 		insert(_Off, 1, _Ch);
; 1272 : 		return (begin() + _Off);
; 1273 : 		}
; 1274 : 
; 1275 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1276 : 		{	// insert _Count * _Elem at _Where
; 1277 : 		size_type _Off = _Pdif(_Where, begin());
; 1278 : 		insert(_Off, _Count, _Ch);
; 1279 : 		return (begin() + _Off);
; 1280 : 		}
; 1281 : 
; 1282 : 	template<class _Iter>
; 1283 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1284 : 			iterator>::type
; 1285 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1286 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1287 : 		size_type _Off = _Pdif(_Where, begin());
; 1288 : 		replace(_Where, _Where, _First, _Last);
; 1289 : 		return (begin() + _Off);
; 1290 : 		}
; 1291 : 
; 1292 : 	iterator insert(const_iterator _Where,
; 1293 : 		const_pointer _First, const_pointer _Last)
; 1294 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		replace(_Where, _Where, _First, _Last);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where,
; 1301 : 		const_iterator _First, const_iterator _Last)
; 1302 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1303 : 		size_type _Off = _Pdif(_Where, begin());
; 1304 : 		replace(_Where, _Where, _First, _Last);
; 1305 : 		return (begin() + _Off);
; 1306 : 		}
; 1307 : 
; 1308 : 	_Myt& erase(size_type _Off = 0)
; 1309 : 		{	// erase elements [_Off, ...)
; 1310 : 		if (this->_Mysize < _Off)
; 1311 : 			_Xran();	// _Off off end
; 1312 : 		_Eos(_Off);
; 1313 : 		return (*this);
; 1314 : 		}
; 1315 : 
; 1316 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1317 : 		{	// erase elements [_Off, _Off + _Count)
; 1318 : 		if (this->_Mysize < _Off)
; 1319 : 			_Xran();	// _Off off end
; 1320 : 		if (this->_Mysize - _Off <= _Count)
; 1321 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1322 : 		else if (0 < _Count)
; 1323 : 			{	// move elements down
; 1324 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1325 : 			size_type _Newsize = this->_Mysize - _Count;
; 1326 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1327 : 			_Eos(_Newsize);
; 1328 : 			}
; 1329 : 		return (*this);
; 1330 : 		}
; 1331 : 
; 1332 : 	iterator erase(const_iterator _Where)
; 1333 : 		{	// erase element at _Where
; 1334 : 		size_type _Count = _Pdif(_Where, begin());
; 1335 : 		erase(_Count, 1);
; 1336 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1337 : 		}
; 1338 : 
; 1339 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1340 : 		{	// erase substring [_First, _Last)
; 1341 : 		_DEBUG_RANGE(_First, _Last);
; 1342 : 		size_type _Count = _Pdif(_First, begin());
; 1343 : 		erase(_Count, _Pdif(_Last, _First));
; 1344 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1345 : 		}
; 1346 : 
; 1347 : 	void clear() _NOEXCEPT
; 1348 : 		{	// erase all
; 1349 : 		_Eos(0);
; 1350 : 		}
; 1351 : 
; 1352 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1353 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1354 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1355 : 		}
; 1356 : 
; 1357 : 	_Myt& replace(size_type _Off,
; 1358 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1359 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1360 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1361 : 			_Xran();	// _Off or _Roff off end
; 1362 : 		if (this->_Mysize - _Off < _N0)
; 1363 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1364 : 		size_type _Num = _Right.size() - _Roff;
; 1365 : 		if (_Num < _Count)
; 1366 : 			_Count = _Num;	// trim _Count to size
; 1367 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1368 : 			_Xlen();	// result too long
; 1369 : 
; 1370 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1371 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1372 : 		if (this->_Mysize < _Newsize)
; 1373 : 			_Grow(_Newsize);
; 1374 : 
; 1375 : 		if (this != &_Right)
; 1376 : 			{	// no overlap, just move down and copy in new stuff
; 1377 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1378 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1379 : 			_Traits::copy(this->_Myptr() + _Off,
; 1380 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1381 : 			}
; 1382 : 		else if (_Count <= _N0)
; 1383 : 			{	// hole doesn't get larger, just copy in substring
; 1384 : 			_Traits::move(this->_Myptr() + _Off,
; 1385 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1386 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1387 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1388 : 			}
; 1389 : 		else if (_Roff <= _Off)
; 1390 : 			{	// hole gets larger, substring begins before hole
; 1391 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1392 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1393 : 			_Traits::move(this->_Myptr() + _Off,
; 1394 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1395 : 			}
; 1396 : 		else if (_Off + _N0 <= _Roff)
; 1397 : 			{	// hole gets larger, substring begins after hole
; 1398 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1399 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1400 : 			_Traits::move(this->_Myptr() + _Off,
; 1401 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1402 : 				_Count);	// fill hole
; 1403 : 			}
; 1404 : 		else
; 1405 : 			{	// hole gets larger, substring begins in hole
; 1406 : 			_Traits::move(this->_Myptr() + _Off,
; 1407 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1408 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1409 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1410 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1411 : 				this->_Myptr() + _Roff + _Count,
; 1412 : 				_Count - _N0);	// fill rest of new hole
; 1413 : 			}
; 1414 : 
; 1415 : 		_Eos(_Newsize);
; 1416 : 		return (*this);
; 1417 : 		}
; 1418 : 
; 1419 : 	_Myt& replace(size_type _Off,
; 1420 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1421 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1422 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1423 : 		if (_Count != 0)
; 1424 : 			_DEBUG_POINTER(_Ptr);
; 1425 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1426 : 
; 1427 : 		if (_Inside(_Ptr))
; 1428 : 			return (replace(_Off, _N0, *this,
; 1429 : 				_Ptr - this->_Myptr(),
; 1430 : 				_Count));	// substring, replace carefully
; 1431 : 		if (this->_Mysize < _Off)
; 1432 : 			_Xran();	// _Off off end
; 1433 : 		if (this->_Mysize - _Off < _N0)
; 1434 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1435 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1436 : 			_Xlen();	// result too long
; 1437 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1438 : 
; 1439 : 		if (_Count < _N0)
; 1440 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1441 : 				this->_Myptr() + _Off + _N0,
; 1442 : 				_Nm);	// smaller hole, move tail up
; 1443 : 		size_type _Num;
; 1444 : 		if ((0 < _Count || 0 < _N0)
; 1445 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1446 : 			{	// make room and rearrange
; 1447 : 			if (_N0 < _Count)
; 1448 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1449 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1450 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1451 : 			_Eos(_Num);
; 1452 : 			}
; 1453 : 		return (*this);
; 1454 : 		}
; 1455 : 
; 1456 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1457 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1458 : 		_DEBUG_POINTER(_Ptr);
; 1459 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1460 : 		}
; 1461 : 
; 1462 : 	_Myt& replace(size_type _Off,
; 1463 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1464 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1465 : 		if (this->_Mysize < _Off)
; 1466 : 			_Xran();	// _Off off end
; 1467 : 		if (this->_Mysize - _Off < _N0)
; 1468 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1469 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1470 : 			_Xlen();	// result too long
; 1471 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1472 : 
; 1473 : 		if (_Count < _N0)
; 1474 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1475 : 				this->_Myptr() + _Off + _N0,
; 1476 : 				_Nm);	// smaller hole, move tail up
; 1477 : 		size_type _Num;
; 1478 : 		if ((0 < _Count || 0 < _N0)
; 1479 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1480 : 			{	// make room and rearrange
; 1481 : 			if (_N0 < _Count)
; 1482 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1483 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1484 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1485 : 			_Eos(_Num);
; 1486 : 			}
; 1487 : 		return (*this);
; 1488 : 		}
; 1489 : 
; 1490 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1491 : 		const _Myt& _Right)
; 1492 : 		{	// replace [_First, _Last) with _Right
; 1493 : 		return (replace(
; 1494 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1495 : 		}
; 1496 : 
; 1497 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1498 : 		const _Elem *_Ptr, size_type _Count)
; 1499 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1500 : 		return (replace(
; 1501 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1502 : 		}
; 1503 : 
; 1504 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1505 : 		const _Elem *_Ptr)
; 1506 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1507 : 		return (replace(
; 1508 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1509 : 		}
; 1510 : 
; 1511 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1512 : 		size_type _Count, _Elem _Ch)
; 1513 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1514 : 		return (replace(
; 1515 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1516 : 		}
; 1517 : 
; 1518 : 	template<class _Iter>
; 1519 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1520 : 			_Myt&>::type
; 1521 : 		replace(const_iterator _First, const_iterator _Last,
; 1522 : 			_Iter _First2, _Iter _Last2)
; 1523 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1524 : 		_Myt _Right(_First2, _Last2);
; 1525 : 		replace(_First, _Last, _Right);
; 1526 : 		return (*this);
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const_pointer _First2, const_pointer _Last2)
; 1531 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1532 : 		if (_First2 == _Last2)
; 1533 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1534 : 		else
; 1535 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1536 : 				&*_First2, _Last2 - _First2);
; 1537 : 		return (*this);
; 1538 : 		}
; 1539 : 
; 1540 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1541 : 		pointer _First2, pointer _Last2)
; 1542 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1543 : 		if (_First2 == _Last2)
; 1544 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1545 : 		else
; 1546 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1547 : 				&*_First2, _Last2 - _First2);
; 1548 : 		return (*this);
; 1549 : 		}
; 1550 : 
; 1551 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1552 : 		const_iterator _First2, const_iterator _Last2)
; 1553 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1554 : 		if (_First2 == _Last2)
; 1555 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1556 : 		else
; 1557 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1558 : 				&*_First2, _Last2 - _First2);
; 1559 : 		return (*this);
; 1560 : 		}
; 1561 : 
; 1562 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1563 : 		iterator _First2, iterator _Last2)
; 1564 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1565 : 		if (_First2 == _Last2)
; 1566 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1567 : 		else
; 1568 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1569 : 				&*_First2, _Last2 - _First2);
; 1570 : 		return (*this);
; 1571 : 		}
; 1572 : 
; 1573 : 	iterator begin() _NOEXCEPT
; 1574 : 		{	// return iterator for beginning of mutable sequence
; 1575 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1576 : 		}
; 1577 : 
; 1578 : 	const_iterator begin() const _NOEXCEPT
; 1579 : 		{	// return iterator for beginning of nonmutable sequence
; 1580 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1581 : 		}
; 1582 : 
; 1583 : 	iterator end() _NOEXCEPT
; 1584 : 		{	// return iterator for end of mutable sequence
; 1585 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1586 : 		}
; 1587 : 
; 1588 : 	const_iterator end() const _NOEXCEPT
; 1589 : 		{	// return iterator for end of nonmutable sequence
; 1590 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1591 : 		}
; 1592 : 
; 1593 : 	reverse_iterator rbegin() _NOEXCEPT
; 1594 : 		{	// return iterator for beginning of reversed mutable sequence
; 1595 : 		return (reverse_iterator(end()));
; 1596 : 		}
; 1597 : 
; 1598 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1600 : 		return (const_reverse_iterator(end()));
; 1601 : 		}
; 1602 : 
; 1603 : 	reverse_iterator rend() _NOEXCEPT
; 1604 : 		{	// return iterator for end of reversed mutable sequence
; 1605 : 		return (reverse_iterator(begin()));
; 1606 : 		}
; 1607 : 
; 1608 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1609 : 		{	// return iterator for end of reversed nonmutable sequence
; 1610 : 		return (const_reverse_iterator(begin()));
; 1611 : 		}
; 1612 : 
; 1613 :  #if _HAS_CPP0X
; 1614 : 	const_iterator cbegin() const _NOEXCEPT
; 1615 : 		{	// return iterator for beginning of nonmutable sequence
; 1616 : 		return (((const _Myt *)this)->begin());
; 1617 : 		}
; 1618 : 
; 1619 : 	const_iterator cend() const _NOEXCEPT
; 1620 : 		{	// return iterator for end of nonmutable sequence
; 1621 : 		return (((const _Myt *)this)->end());
; 1622 : 		}
; 1623 : 
; 1624 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1625 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1626 : 		return (((const _Myt *)this)->rbegin());
; 1627 : 		}
; 1628 : 
; 1629 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1630 : 		{	// return iterator for end of reversed nonmutable sequence
; 1631 : 		return (((const _Myt *)this)->rend());
; 1632 : 		}
; 1633 : 
; 1634 : 	void shrink_to_fit()
; 1635 : 		{	// reduce capacity
; 1636 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1637 : 			{	// worth shrinking, do it
; 1638 : 			_Myt _Tmp(*this);
; 1639 : 			swap(_Tmp);
; 1640 : 			}
; 1641 : 		}
; 1642 :  #endif /* _HAS_CPP0X */
; 1643 : 
; 1644 : 	reference at(size_type _Off)
; 1645 : 		{	// subscript mutable sequence with checking
; 1646 : 		if (this->_Mysize <= _Off)
; 1647 : 			_Xran();	// _Off off end
; 1648 : 		return (this->_Myptr()[_Off]);
; 1649 : 		}
; 1650 : 
; 1651 : 	const_reference at(size_type _Off) const
; 1652 : 		{	// subscript nonmutable sequence with checking
; 1653 : 		if (this->_Mysize <= _Off)
; 1654 : 			_Xran();	// _Off off end
; 1655 : 		return (this->_Myptr()[_Off]);
; 1656 : 		}
; 1657 : 
; 1658 : 	reference operator[](size_type _Off)
; 1659 : 		{	// subscript mutable sequence
; 1660 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1661 : 		if (this->_Mysize < _Off)	// sic
; 1662 : 			_DEBUG_ERROR("string subscript out of range");
; 1663 : 
; 1664 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1665 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1666 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1667 : 
; 1668 : 		return (this->_Myptr()[_Off]);
; 1669 : 		}
; 1670 : 
; 1671 : 	const_reference operator[](size_type _Off) const
; 1672 : 		{	// subscript nonmutable sequence
; 1673 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1674 : 		if (this->_Mysize < _Off)	// sic
; 1675 : 			_DEBUG_ERROR("string subscript out of range");
; 1676 : 
; 1677 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1678 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1679 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1680 : 
; 1681 : 		return (this->_Myptr()[_Off]);
; 1682 : 		}
; 1683 : 
; 1684 : 	void push_back(_Elem _Ch)
; 1685 : 		{	// insert element at end
; 1686 : 		insert(end(), _Ch);
; 1687 : 		}
; 1688 : 
; 1689 :  #if _HAS_CPP0X
; 1690 : 	void pop_back()
; 1691 : 		{	// erase element at end
; 1692 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1693 : 		}
; 1694 : 
; 1695 : 	reference front()
; 1696 : 		{	// return first element of mutable sequence
; 1697 : 		return (*begin());
; 1698 : 		}
; 1699 : 
; 1700 : 	const_reference front() const
; 1701 : 		{	// return first element of nonmutable sequence
; 1702 : 		return (*begin());
; 1703 : 		}
; 1704 : 
; 1705 : 	reference back()
; 1706 : 		{	// return last element of mutable sequence
; 1707 : 		return (*(end() - 1));
; 1708 : 		}
; 1709 : 
; 1710 : 	const_reference back() const
; 1711 : 		{	// return last element of nonmutable sequence
; 1712 : 		return (*(end() - 1));
; 1713 : 		}
; 1714 :  #endif /* _HAS_CPP0X */
; 1715 : 
; 1716 : 	const _Elem *c_str() const _NOEXCEPT
; 1717 : 		{	// return pointer to null-terminated nonmutable array
; 1718 : 		return (this->_Myptr());
; 1719 : 		}
; 1720 : 
; 1721 : 	const _Elem *data() const _NOEXCEPT
; 1722 : 		{	// return pointer to nonmutable array
; 1723 : 		return (c_str());
; 1724 : 		}
; 1725 : 
; 1726 : 	size_type length() const _NOEXCEPT
; 1727 : 		{	// return length of sequence
; 1728 : 		return (this->_Mysize);
; 1729 : 		}
; 1730 : 
; 1731 : 	size_type size() const _NOEXCEPT
; 1732 : 		{	// return length of sequence
; 1733 : 		return (this->_Mysize);
; 1734 : 		}
; 1735 : 
; 1736 : 	size_type max_size() const _NOEXCEPT
; 1737 : 		{	// return maximum possible length of sequence
; 1738 : 		size_type _Num = this->_Getal().max_size();
; 1739 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1740 : 		}
; 1741 : 
; 1742 : 	void resize(size_type _Newsize)
; 1743 : 		{	// determine new length, padding with null elements as needed
; 1744 : 		resize(_Newsize, _Elem());
; 1745 : 		}
; 1746 : 
; 1747 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1748 : 		{	// determine new length, padding with _Ch elements as needed
; 1749 : 		if (_Newsize <= this->_Mysize)
; 1750 : 			_Eos(_Newsize);
; 1751 : 		else
; 1752 : 			append(_Newsize - this->_Mysize, _Ch);
; 1753 : 		}
; 1754 : 
; 1755 : 	size_type capacity() const _NOEXCEPT
; 1756 : 		{	// return current length of allocated storage
; 1757 : 		return (this->_Myres);
; 1758 : 		}
; 1759 : 
; 1760 : 	void reserve(size_type _Newcap = 0)
; 1761 : 		{	// determine new minimum length of allocated storage
; 1762 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1763 : 			{	// change reservation
; 1764 : 			size_type _Size = this->_Mysize;
; 1765 : 			if (_Grow(_Newcap, true))
; 1766 : 				_Eos(_Size);
; 1767 : 			}
; 1768 : 		}
; 1769 : 
; 1770 : 	bool empty() const _NOEXCEPT
; 1771 : 		{	// test if sequence is empty
; 1772 : 		return (this->_Mysize == 0);
; 1773 : 		}
; 1774 : 
; 1775 : 	_SCL_INSECURE_DEPRECATE
; 1776 : 
; 1777 : 	size_type copy(_Elem *_Ptr,
; 1778 : 		size_type _Count, size_type _Off = 0) const
; 1779 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1780 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1781 : 		if (_Count != 0)
; 1782 : 			_DEBUG_POINTER(_Ptr);
; 1783 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1784 : 
; 1785 : 		if (this->_Mysize < _Off)
; 1786 : 			_Xran();	// _Off off end
; 1787 : 		if (this->_Mysize - _Off < _Count)
; 1788 : 			_Count = this->_Mysize - _Off;
; 1789 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1790 : 		return (_Count);
; 1791 : 		}
; 1792 : 
; 1793 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1794 : 		size_type _Count, size_type _Off = 0) const
; 1795 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1796 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1797 : 		if (_Count != 0)
; 1798 : 			_DEBUG_POINTER(_Dest);
; 1799 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1800 : 
; 1801 : 		if (this->_Mysize < _Off)
; 1802 : 			_Xran();	// _Off off end
; 1803 : 		if (this->_Mysize - _Off < _Count)
; 1804 : 			_Count = this->_Mysize - _Off;
; 1805 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1806 : 		return (_Count);
; 1807 : 		}
; 1808 : 
; 1809 : 	void _Swap_bx(_Myt& _Right)
; 1810 : 		{	// exchange _Bx with _Right._Bx
; 1811 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1812 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1813 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1814 : 			else
; 1815 : 				{	// swap large with small
; 1816 : 				pointer _Ptr = this->_Bx._Ptr;
; 1817 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1818 : 				_Traits::copy(this->_Bx._Buf,
; 1819 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1820 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1821 : 				}
; 1822 : 		else
; 1823 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1824 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1825 : 			else
; 1826 : 				{	// swap small with large
; 1827 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1828 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1829 : 				_Traits::copy(_Right._Bx._Buf,
; 1830 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1831 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1832 : 				}
; 1833 : 		}
; 1834 : 
; 1835 : 	void swap(_Myt& _Right)
; 1836 : 		{	// exchange contents with _Right
; 1837 : 		if (this == &_Right)
; 1838 : 			;	// same object, do nothing
; 1839 : 		else if (this->_Getal() == _Right._Getal())
; 1840 : 			{	// same allocator, swap control information
; 1841 : 			this->_Swap_all(_Right);
; 1842 : 			_Swap_bx(_Right);
; 1843 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1844 : 			_STD swap(this->_Myres, _Right._Myres);
; 1845 : 			}
; 1846 : 
; 1847 :  #if _HAS_CPP0X
; 1848 : 		else if (_Alty::propagate_on_container_swap::value)
; 1849 : 			{	// swap allocators and control information
; 1850 : 			this->_Swap_alloc(_Right);
; 1851 : 			_Swap_bx(_Right);
; 1852 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1853 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1854 : 			_STD swap(this->_Myres, _Right._Myres);
; 1855 : 			}
; 1856 :  #endif /* _HAS_CPP0X */
; 1857 : 
; 1858 : 		else
; 1859 : 			{	// different allocator, do multiple assigns
; 1860 : 			_Myt _Tmp = *this;
; 1861 : 
; 1862 : 			*this = _Right;
; 1863 : 			_Right = _Tmp;
; 1864 : 			}
; 1865 : 		}
; 1866 : 
; 1867 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1868 : 		{	// look for _Right beginning at or after _Off
; 1869 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1870 : 		}
; 1871 : 
; 1872 : 	size_type find(const _Elem *_Ptr,
; 1873 : 		size_type _Off, size_type _Count) const
; 1874 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1875 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1876 : 		if (_Count != 0)
; 1877 : 			_DEBUG_POINTER(_Ptr);
; 1878 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1879 : 
; 1880 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1881 : 			return (_Off);	// null string always matches (if inside string)
; 1882 : 
; 1883 : 		size_type _Nm;
; 1884 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1885 : 			{	// room for match, look for it
; 1886 : 			const _Elem *_Uptr, *_Vptr;
; 1887 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1888 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1889 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1890 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1891 : 					return (_Uptr - this->_Myptr());	// found a match
; 1892 : 			}
; 1893 : 
; 1894 : 		return (npos);	// no match
; 1895 : 		}
; 1896 : 
; 1897 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1898 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1899 : 		_DEBUG_POINTER(_Ptr);
; 1900 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1901 : 		}
; 1902 : 
; 1903 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1904 : 		{	// look for _Ch at or after _Off
; 1905 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1906 : 		}
; 1907 : 
; 1908 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1909 : 		{	// look for _Right beginning before _Off
; 1910 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1911 : 		}
; 1912 : 
; 1913 : 	size_type rfind(const _Elem *_Ptr,
; 1914 : 		size_type _Off, size_type _Count) const
; 1915 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1916 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1917 : 		if (_Count != 0)
; 1918 : 			_DEBUG_POINTER(_Ptr);
; 1919 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1920 : 
; 1921 : 		if (_Count == 0)
; 1922 : 			return (_Off < this->_Mysize ? _Off
; 1923 : 				: this->_Mysize);	// null always matches
; 1924 : 		if (_Count <= this->_Mysize)
; 1925 : 			{	// room for match, look for it
; 1926 : 			const _Elem *_Uptr = this->_Myptr() +
; 1927 : 				(_Off < this->_Mysize - _Count ? _Off
; 1928 : 					: this->_Mysize - _Count);
; 1929 : 			for (; ; --_Uptr)
; 1930 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1931 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1932 : 					return (_Uptr - this->_Myptr());	// found a match
; 1933 : 				else if (_Uptr == this->_Myptr())
; 1934 : 					break;	// at beginning, no more chance for match
; 1935 : 			}
; 1936 : 
; 1937 : 		return (npos);	// no match
; 1938 : 		}
; 1939 : 
; 1940 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1941 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1942 : 		_DEBUG_POINTER(_Ptr);
; 1943 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1944 : 		}
; 1945 : 
; 1946 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1947 : 		{	// look for _Ch before _Off
; 1948 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1949 : 		}
; 1950 : 
; 1951 : 	size_type find_first_of(const _Myt& _Right,
; 1952 : 		size_type _Off = 0) const _NOEXCEPT
; 1953 : 		{	// look for one of _Right at or after _Off
; 1954 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1955 : 		}
; 1956 : 
; 1957 : 	size_type find_first_of(const _Elem *_Ptr,
; 1958 : 		size_type _Off, size_type _Count) const
; 1959 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1960 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1961 : 		if (_Count != 0)
; 1962 : 			_DEBUG_POINTER(_Ptr);
; 1963 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1964 : 
; 1965 : 		if (0 < _Count && _Off < this->_Mysize)
; 1966 : 			{	// room for match, look for it
; 1967 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1968 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1969 : 				_Uptr < _Vptr; ++_Uptr)
; 1970 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1971 : 					return (_Uptr - this->_Myptr());	// found a match
; 1972 : 			}
; 1973 : 
; 1974 : 		return (npos);	// no match
; 1975 : 		}
; 1976 : 
; 1977 : 	size_type find_first_of(const _Elem *_Ptr,
; 1978 : 		size_type _Off = 0) const
; 1979 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1980 : 		_DEBUG_POINTER(_Ptr);
; 1981 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 1982 : 		}
; 1983 : 
; 1984 : 	size_type find_first_of(_Elem _Ch,
; 1985 : 		size_type _Off = 0) const
; 1986 : 		{	// look for _Ch at or after _Off
; 1987 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1988 : 		}
; 1989 : 
; 1990 : 	size_type find_last_of(const _Myt& _Right,
; 1991 : 		size_type _Off = npos) const _NOEXCEPT
; 1992 : 		{	// look for one of _Right before _Off
; 1993 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_last_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off, size_type _Count) const
; 1998 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 1999 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2000 : 		if (_Count != 0)
; 2001 : 			_DEBUG_POINTER(_Ptr);
; 2002 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2003 : 
; 2004 : 		if (0 < _Count && 0 < this->_Mysize)
; 2005 : 			{	// worth searching, do it
; 2006 : 			const _Elem *_Uptr = this->_Myptr()
; 2007 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2008 : 			for (; ; --_Uptr)
; 2009 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2010 : 					return (_Uptr - this->_Myptr());	// found a match
; 2011 : 				else if (_Uptr == this->_Myptr())
; 2012 : 					break;	// at beginning, no more chance for match
; 2013 : 			}
; 2014 : 
; 2015 : 		return (npos);	// no match
; 2016 : 		}
; 2017 : 
; 2018 : 	size_type find_last_of(const _Elem *_Ptr,
; 2019 : 		size_type _Off = npos) const
; 2020 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2021 : 		_DEBUG_POINTER(_Ptr);
; 2022 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2023 : 		}
; 2024 : 
; 2025 : 	size_type find_last_of(_Elem _Ch,
; 2026 : 		size_type _Off = npos) const
; 2027 : 		{	// look for _Ch before _Off
; 2028 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2029 : 		}
; 2030 : 
; 2031 : 	size_type find_first_not_of(const _Myt& _Right,
; 2032 : 		size_type _Off = 0) const _NOEXCEPT
; 2033 : 		{	// look for none of _Right at or after _Off
; 2034 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2035 : 			_Right.size()));
; 2036 : 		}
; 2037 : 
; 2038 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2039 : 		size_type _Off, size_type _Count) const
; 2040 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2041 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2042 : 		if (_Count != 0)
; 2043 : 			_DEBUG_POINTER(_Ptr);
; 2044 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2045 : 
; 2046 : 		if (_Off < this->_Mysize)
; 2047 : 			{	// room for match, look for it
; 2048 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2049 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2050 : 				_Uptr < _Vptr; ++_Uptr)
; 2051 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2052 : 					return (_Uptr - this->_Myptr());
; 2053 : 			}
; 2054 : 		return (npos);
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off = 0) const
; 2059 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2060 : 		_DEBUG_POINTER(_Ptr);
; 2061 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2062 : 		}
; 2063 : 
; 2064 : 	size_type find_first_not_of(_Elem _Ch,
; 2065 : 		size_type _Off = 0) const
; 2066 : 		{	// look for non _Ch at or after _Off
; 2067 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2068 : 		}
; 2069 : 
; 2070 : 	size_type find_last_not_of(const _Myt& _Right,
; 2071 : 		size_type _Off = npos) const _NOEXCEPT
; 2072 : 		{	// look for none of _Right before _Off
; 2073 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off, size_type _Count) const
; 2078 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2079 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2080 : 		if (_Count != 0)
; 2081 : 			_DEBUG_POINTER(_Ptr);
; 2082 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2083 : 
; 2084 : 		if (0 < this->_Mysize)
; 2085 : 			{	// worth searching, do it
; 2086 : 			const _Elem *_Uptr = this->_Myptr()
; 2087 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2088 : 			for (; ; --_Uptr)
; 2089 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2090 : 					return (_Uptr - this->_Myptr());
; 2091 : 				else if (_Uptr == this->_Myptr())
; 2092 : 					break;
; 2093 : 			}
; 2094 : 		return (npos);
; 2095 : 		}
; 2096 : 
; 2097 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2098 : 		size_type _Off = npos) const
; 2099 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2100 : 		_DEBUG_POINTER(_Ptr);
; 2101 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2102 : 		}
; 2103 : 
; 2104 : 	size_type find_last_not_of(_Elem _Ch,
; 2105 : 		size_type _Off = npos) const
; 2106 : 		{	// look for non _Ch before _Off
; 2107 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2108 : 		}
; 2109 : 
; 2110 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2111 : 		{	// return [_Off, _Off + _Count) as new string
; 2112 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2113 : 		}
; 2114 : 
; 2115 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2116 : 		{	// compare [0, _Mysize) with _Right
; 2117 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2118 : 		}
; 2119 : 
; 2120 : 	int compare(size_type _Off, size_type _N0,
; 2121 : 		const _Myt& _Right) const
; 2122 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2123 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2124 : 		}
; 2125 : 
; 2126 : 	int compare(size_type _Off,
; 2127 : 		size_type _N0, const _Myt& _Right,
; 2128 : 		size_type _Roff, size_type _Count) const
; 2129 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2130 : 		if (_Right.size() < _Roff)
; 2131 : 			_Xran();	// _Off off end
; 2132 : 		if (_Right._Mysize - _Roff < _Count)
; 2133 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2134 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2135 : 		}
; 2136 : 
; 2137 : 	int compare(const _Elem *_Ptr) const
; 2138 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2139 : 		_DEBUG_POINTER(_Ptr);
; 2140 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2141 : 		}
; 2142 : 
; 2143 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2144 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2145 : 		_DEBUG_POINTER(_Ptr);
; 2146 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2147 : 		}
; 2148 : 
; 2149 : 	int compare(size_type _Off,
; 2150 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2151 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2152 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2153 : 		if (_Count != 0)
; 2154 : 			_DEBUG_POINTER(_Ptr);
; 2155 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2156 : 
; 2157 : 		if (this->_Mysize < _Off)
; 2158 : 			_Xran();	// _Off off end
; 2159 : 		if (this->_Mysize - _Off < _N0)
; 2160 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2161 : 
; 2162 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2163 : 			_N0 < _Count ? _N0 : _Count);
; 2164 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2165 : 			: _N0 == _Count ? 0 : +1);
; 2166 : 		}
; 2167 : 
; 2168 : 	allocator_type get_allocator() const _NOEXCEPT
; 2169 : 		{	// return allocator object for values
; 2170 : 		return (this->_Getal());
; 2171 : 		}
; 2172 : 
; 2173 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2174 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2175 : 		if (_Count == 1)
; 2176 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2177 : 		else
; 2178 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2179 : 		}
; 2180 : 
; 2181 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2182 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2183 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2184 : 		if (max_size() < _Newres)
; 2185 : 			_Newres = _Newsize;	// undo roundup if too big
; 2186 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2187 : 			;
; 2188 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2189 : 			_Newres = this->_Myres
; 2190 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2191 : 		else
; 2192 : 			_Newres = max_size();	// settle for max_size()
; 2193 : 
; 2194 : 		_Elem *_Ptr;
; 2195 : 		_TRY_BEGIN
; 2196 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2197 : 		_CATCH_ALL
; 2198 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2199 : 			_TRY_BEGIN
; 2200 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2201 : 			_CATCH_ALL
; 2202 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2203 : 			_RERAISE;
; 2204 : 			_CATCH_END
; 2205 : 		_CATCH_END
; 2206 : 
; 2207 : 		if (0 < _Oldlen)
; 2208 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2209 : 				_Oldlen);	// copy existing elements
; 2210 : 		_Tidy(true);
; 2211 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2212 : 		this->_Myres = _Newres;
; 2213 : 		_Eos(_Oldlen);
; 2214 : 		}
; 2215 : 
; 2216 : 	void _Eos(size_type _Newsize)
; 2217 : 		{	// set new length and null terminator
; 2218 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  00040	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 735  : 		assign(_Right, 0, npos);

  00047	50		 push	 eax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd

; 347  : 		_Left = _Right;

  00048	66 89 01	 mov	 WORD PTR [ecx], ax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 735  : 		assign(_Right, 0, npos);

  0004b	8d 45 08	 lea	 eax, DWORD PTR _title$[ebp]
  0004e	50		 push	 eax
  0004f	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign

; 2256 : 		else if (this->_BUF_SIZE <= this->_Myres)

  00054	83 7d 1c 08	 cmp	 DWORD PTR _title$[ebp+20], 8
; File c:\users\glenn\documents\github\wind\project\wind\wind\window.cpp

; 21   : {

  00058	c6 46 30 01	 mov	 BYTE PTR [esi+48], 1
  0005c	c7 46 34 58 02
	00 00		 mov	 DWORD PTR [esi+52], 600	; 00000258H
  00063	c7 46 38 58 02
	00 00		 mov	 DWORD PTR [esi+56], 600	; 00000258H
  0006a	c7 46 3c 03 00
	00 00		 mov	 DWORD PTR [esi+60], 3
  00071	c7 46 40 04 00
	00 00		 mov	 DWORD PTR [esi+64], 4
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 2256 : 		else if (this->_BUF_SIZE <= this->_Myres)

  00078	72 0b		 jb	 SHORT $LN83@GLWindow
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 586  : 		::operator delete(_Ptr);

  0007a	ff 75 08	 push	 DWORD PTR _title$[ebp]
  0007d	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00082	83 c4 04	 add	 esp, 4
$LN83@GLWindow:
; File c:\users\glenn\documents\github\wind\project\wind\wind\window.cpp

; 23   : }

  00085	8b c6		 mov	 eax, esi
  00087	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0008a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00091	59		 pop	 ecx
  00092	5e		 pop	 esi
  00093	8b e5		 mov	 esp, ebp
  00095	5d		 pop	 ebp
  00096	c2 2c 00	 ret	 44			; 0000002cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0GLWindow@@QAE@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@HHPAUHINSTANCE__@@HH@Z$0:
  00000	8d 4d 08	 lea	 ecx, DWORD PTR _title$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
__ehhandler$??0GLWindow@@QAE@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@HHPAUHINSTANCE__@@HH@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0GLWindow@@QAE@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@HHPAUHINSTANCE__@@HH@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0GLWindow@@QAE@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@HHPAUHINSTANCE__@@HH@Z ENDP ; GLWindow::GLWindow
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\window.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
; File c:\users\glenn\documents\github\wind\project\wind\wind\window.cpp
;	COMDAT ??1GLWindow@@QAE@XZ
_TEXT	SEGMENT
??1GLWindow@@QAE@XZ PROC				; GLWindow::~GLWindow, COMDAT
; _this$ = ecx

; 26   : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 27   : 	destroyWindow();

  00003	e8 00 00 00 00	 call	 ?destroyWindow@GLWindow@@QAEXXZ ; GLWindow::destroyWindow
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 2256 : 		else if (this->_BUF_SIZE <= this->_Myres)

  00008	83 7e 2c 08	 cmp	 DWORD PTR [esi+44], 8
  0000c	72 0b		 jb	 SHORT $LN25@GLWindow
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 586  : 		::operator delete(_Ptr);

  0000e	ff 76 18	 push	 DWORD PTR [esi+24]
  00011	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00016	83 c4 04	 add	 esp, 4
$LN25@GLWindow:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 2265 : 		this->_Myres = this->_BUF_SIZE - 1;

  00019	c7 46 2c 07 00
	00 00		 mov	 DWORD PTR [esi+44], 7

; 2218 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  00020	c7 46 28 00 00
	00 00		 mov	 DWORD PTR [esi+40], 0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd

; 347  : 		_Left = _Right;

  00027	33 c0		 xor	 eax, eax
  00029	66 89 46 18	 mov	 WORD PTR [esi+24], ax
  0002d	5e		 pop	 esi
; File c:\users\glenn\documents\github\wind\project\wind\wind\window.cpp

; 28   : }

  0002e	c3		 ret	 0
??1GLWindow@@QAE@XZ ENDP				; GLWindow::~GLWindow
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\window.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\users\glenn\documents\github\wind\project\wind\wind\window.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstddef
; File c:\users\glenn\documents\github\wind\project\wind\wind\window.cpp
;	COMDAT ?initWindow@GLWindow@@QAEXXZ
_TEXT	SEGMENT
_wc$ = -72						; size = 40
_Rid$ = -32						; size = 12
_WindowRect$ = -20					; size = 16
__$ArrayPad$ = -4					; size = 4
?initWindow@GLWindow@@QAEXXZ PROC			; GLWindow::initWindow, COMDAT
; _this$dead$ = ecx

; 31   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi
  00011	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?instance@GLWindow@@2PAV1@A ; GLWindow::instance

; 32   : 	GLuint PixelFormat;
; 33   : 	WNDCLASS wc;
; 34   : 	DWORD dwExStyle;
; 35   : 	DWORD dwStyle;
; 36   : 	RECT WindowRect;
; 37   : 
; 38   : 	WindowRect.left = (long)0;
; 39   : 	WindowRect.right = (long)width;
; 40   : 	WindowRect.top = (long)0;
; 41   : 	WindowRect.bottom = (long)height;
; 42   : 
; 43   : 	OK = false;
; 44   : 
; 45   : 	wc.style = CS_HREDRAW | CS_VREDRAW | CS_OWNDC;
; 46   : 	wc.lpfnWndProc = (WNDPROC)wndProc;
; 47   : 	wc.cbClsExtra = 0;
; 48   : 	wc.cbWndExtra = 0;
; 49   : 	wc.hInstance = hInstance;
; 50   : 	//wc.hIcon = LoadIcon(hInstance, MAKEINTRESOURCE(IDI_ICON1));
; 51   : 	wc.hIcon = LoadIcon(NULL, IDI_APPLICATION);

  00017	68 00 7f 00 00	 push	 32512			; 00007f00H
  0001c	8b 46 34	 mov	 eax, DWORD PTR [esi+52]
  0001f	89 45 f4	 mov	 DWORD PTR _WindowRect$[ebp+8], eax
  00022	8b 46 38	 mov	 eax, DWORD PTR [esi+56]
  00025	89 45 f8	 mov	 DWORD PTR _WindowRect$[ebp+12], eax
  00028	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0002b	6a 00		 push	 0
  0002d	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _WindowRect$[ebp], 0
  00034	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _WindowRect$[ebp+4], 0
  0003b	c6 06 00	 mov	 BYTE PTR [esi], 0
  0003e	c7 45 b8 23 00
	00 00		 mov	 DWORD PTR _wc$[ebp], 35	; 00000023H
  00045	c7 45 bc 00 00
	00 00		 mov	 DWORD PTR _wc$[ebp+4], OFFSET ?wndProc@@YGJPAUHWND__@@IIJ@Z ; wndProc
  0004c	c7 45 c0 00 00
	00 00		 mov	 DWORD PTR _wc$[ebp+8], 0
  00053	c7 45 c4 00 00
	00 00		 mov	 DWORD PTR _wc$[ebp+12], 0
  0005a	89 45 c8	 mov	 DWORD PTR _wc$[ebp+16], eax
  0005d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LoadIconW@8

; 52   : 	wc.hCursor = LoadCursor(NULL, IDC_ARROW);

  00063	68 00 7f 00 00	 push	 32512			; 00007f00H
  00068	6a 00		 push	 0
  0006a	89 45 cc	 mov	 DWORD PTR _wc$[ebp+20], eax
  0006d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LoadCursorW@8
  00073	89 45 d0	 mov	 DWORD PTR _wc$[ebp+24], eax

; 53   : 	wc.hbrBackground = NULL;			
; 54   : 	wc.lpszMenuName	= NULL;		
; 55   : 	wc.lpszClassName = L"GLWindow";
; 56   : 
; 57   : 	if(!RegisterClass(&wc))

  00076	8d 45 b8	 lea	 eax, DWORD PTR _wc$[ebp]
  00079	50		 push	 eax
  0007a	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _wc$[ebp+28], 0
  00081	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _wc$[ebp+32], 0
  00088	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _wc$[ebp+36], OFFSET $SG4294937617
  0008f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegisterClassW@4
  00095	66 85 c0	 test	 ax, ax
  00098	75 25		 jne	 SHORT $LN6@initWindow

; 58   : 	{
; 59   : 		OK = false;
; 60   : 		MessageBox(NULL, L"Could not register window class.", L"Registration error", MB_OK | MB_ICONERROR);

  0009a	6a 10		 push	 16			; 00000010H
  0009c	68 00 00 00 00	 push	 OFFSET $SG4294937616
  000a1	68 00 00 00 00	 push	 OFFSET $SG4294937615
  000a6	6a 00		 push	 0
  000a8	88 06		 mov	 BYTE PTR [esi], al
  000aa	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxW@16

; 121  : 	{
; 122  : 		OK = false;
; 123  : 		return;
; 124  : 	}
; 125  : 
; 126  : 	OK = true;
; 127  : }

  000b0	5e		 pop	 esi
  000b1	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000b4	33 cd		 xor	 ecx, ebp
  000b6	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000bb	8b e5		 mov	 esp, ebp
  000bd	5d		 pop	 ebp
  000be	c3		 ret	 0
$LN6@initWindow:

; 61   : 		return;
; 62   : 	}
; 63   : 
; 64   : 	dwExStyle = WS_EX_APPWINDOW | WS_EX_WINDOWEDGE;
; 65   : 	dwStyle = WS_OVERLAPPEDWINDOW;
; 66   : 
; 67   : 	AdjustWindowRectEx(&WindowRect, dwStyle, false, dwExStyle);

  000bf	68 00 01 04 00	 push	 262400			; 00040100H
  000c4	6a 00		 push	 0
  000c6	68 00 00 cf 00	 push	 13565952		; 00cf0000H
  000cb	8d 45 ec	 lea	 eax, DWORD PTR _WindowRect$[ebp]
  000ce	50		 push	 eax
  000cf	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__AdjustWindowRectEx@16
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 524  : 			: this->_Bx._Buf);

  000d5	83 7e 2c 08	 cmp	 DWORD PTR [esi+44], 8
; File c:\users\glenn\documents\github\wind\project\wind\wind\window.cpp

; 69   : 	hWnd = CreateWindowEx(dwExStyle, L"GLWindow", this->title.c_str(), dwStyle | WS_CLIPSIBLINGS | WS_CLIPCHILDREN, 0, 0, WindowRect.right - WindowRect.left, WindowRect.bottom - WindowRect.top, NULL, NULL, hInstance, NULL);

  000d9	8d 4e 18	 lea	 ecx, DWORD PTR [esi+24]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 524  : 			: this->_Bx._Buf);

  000dc	72 02		 jb	 SHORT $LN14@initWindow
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstddef

; 88   : 		reinterpret_cast<const volatile char&>(_Val)))));

  000de	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN14@initWindow:
; File c:\users\glenn\documents\github\wind\project\wind\wind\window.cpp

; 69   : 	hWnd = CreateWindowEx(dwExStyle, L"GLWindow", this->title.c_str(), dwStyle | WS_CLIPSIBLINGS | WS_CLIPCHILDREN, 0, 0, WindowRect.right - WindowRect.left, WindowRect.bottom - WindowRect.top, NULL, NULL, hInstance, NULL);

  000e0	8b 45 f8	 mov	 eax, DWORD PTR _WindowRect$[ebp+12]
  000e3	2b 45 f0	 sub	 eax, DWORD PTR _WindowRect$[ebp+4]
  000e6	6a 00		 push	 0
  000e8	ff 76 04	 push	 DWORD PTR [esi+4]
  000eb	6a 00		 push	 0
  000ed	6a 00		 push	 0
  000ef	50		 push	 eax
  000f0	8b 45 f4	 mov	 eax, DWORD PTR _WindowRect$[ebp+8]
  000f3	2b 45 ec	 sub	 eax, DWORD PTR _WindowRect$[ebp]
  000f6	50		 push	 eax
  000f7	6a 00		 push	 0
  000f9	6a 00		 push	 0
  000fb	68 00 00 cf 06	 push	 114229248		; 06cf0000H
  00100	51		 push	 ecx
  00101	68 00 00 00 00	 push	 OFFSET $SG4294937614
  00106	68 00 01 04 00	 push	 262400			; 00040100H
  0010b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateWindowExW@48
  00111	89 46 08	 mov	 DWORD PTR [esi+8], eax

; 70   : 	//hWnd = CreateWindow(L"OpenGL", title, dwStyle | WS_CLIPSIBLINGS | WS_CLIPCHILDREN, 0, 0, WindowRect.right - WindowRect.left, WindowRect.bottom - WindowRect.top, NULL, NULL, hInstance, NULL);
; 71   : 
; 72   : 	if(!hWnd)

  00114	85 c0		 test	 eax, eax
  00116	75 16		 jne	 SHORT $LN5@initWindow
$LN17@initWindow:

; 73   : 	{
; 74   : 		destroyWindow();

  00118	8b ce		 mov	 ecx, esi
  0011a	e8 00 00 00 00	 call	 ?destroyWindow@GLWindow@@QAEXXZ ; GLWindow::destroyWindow

; 121  : 	{
; 122  : 		OK = false;
; 123  : 		return;
; 124  : 	}
; 125  : 
; 126  : 	OK = true;
; 127  : }

  0011f	5e		 pop	 esi
  00120	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00123	33 cd		 xor	 ecx, ebp
  00125	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0012a	8b e5		 mov	 esp, ebp
  0012c	5d		 pop	 ebp
  0012d	c3		 ret	 0
$LN5@initWindow:

; 75   : 		return;
; 76   : 	}
; 77   : 
; 78   : 	static PIXELFORMATDESCRIPTOR pfd = {
; 79   : 		sizeof(PIXELFORMATDESCRIPTOR),
; 80   : 		1,
; 81   : 		PFD_DRAW_TO_WINDOW | PFD_SUPPORT_OPENGL | PFD_DOUBLEBUFFER,
; 82   : 		PFD_TYPE_RGBA,
; 83   : 		16,
; 84   : 		0, 0, 0, 0, 0, 0,
; 85   : 		0,
; 86   : 		0,
; 87   : 		0,
; 88   : 		0, 0, 0, 0,
; 89   : 		16, 
; 90   : 		0,
; 91   : 		0,
; 92   : 		PFD_MAIN_PLANE,
; 93   : 		0,
; 94   : 		0, 0, 0
; 95   : 	};
; 96   : 
; 97   : 	if(!(hDC = GetDC(hWnd)))

  0012e	50		 push	 eax
  0012f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDC@4
  00135	89 46 0c	 mov	 DWORD PTR [esi+12], eax
  00138	85 c0		 test	 eax, eax
  0013a	74 dc		 je	 SHORT $LN17@initWindow

; 98   : 	{
; 99   : 		destroyWindow();
; 100  : 		return;
; 101  : 	}
; 102  : 
; 103  : 	if(!(PixelFormat = ChoosePixelFormat(hDC, &pfd)))

  0013c	68 00 00 00 00	 push	 OFFSET ?pfd@?7??initWindow@GLWindow@@QAEXXZ@4UtagPIXELFORMATDESCRIPTOR@@A
  00141	50		 push	 eax
  00142	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ChoosePixelFormat@8
  00148	85 c0		 test	 eax, eax
  0014a	74 cc		 je	 SHORT $LN17@initWindow

; 104  : 	{
; 105  : 		destroyWindow();
; 106  : 		return;
; 107  : 	}
; 108  : 
; 109  : 	if(!SetPixelFormat(hDC, PixelFormat, &pfd))

  0014c	68 00 00 00 00	 push	 OFFSET ?pfd@?7??initWindow@GLWindow@@QAEXXZ@4UtagPIXELFORMATDESCRIPTOR@@A
  00151	50		 push	 eax
  00152	ff 76 0c	 push	 DWORD PTR [esi+12]
  00155	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetPixelFormat@12
  0015b	85 c0		 test	 eax, eax
  0015d	74 b9		 je	 SHORT $LN17@initWindow

; 110  : 	{
; 111  : 		destroyWindow();
; 112  : 		return;
; 113  : 	}
; 114  : 
; 115  : 	RAWINPUTDEVICE Rid[1];
; 116  : 	Rid[0].usUsagePage = HID_USAGE_PAGE_GENERIC;
; 117  : 	Rid[0].usUsage = HID_USAGE_GENERIC_MOUSE;
; 118  : 	Rid[0].dwFlags = RIDEV_INPUTSINK;
; 119  : 	Rid[0].hwndTarget = hWnd;

  0015f	8b 46 08	 mov	 eax, DWORD PTR [esi+8]

; 120  : 	if(!RegisterRawInputDevices(Rid, 1, sizeof(Rid[0])))

  00162	6a 0c		 push	 12			; 0000000cH
  00164	89 45 e8	 mov	 DWORD PTR _Rid$[ebp+8], eax
  00167	6a 01		 push	 1
  00169	8d 45 e0	 lea	 eax, DWORD PTR _Rid$[ebp]
  0016c	50		 push	 eax
  0016d	c7 45 e0 01 00
	02 00		 mov	 DWORD PTR _Rid$[ebp], 131073 ; 00020001H
  00174	c7 45 e4 00 01
	00 00		 mov	 DWORD PTR _Rid$[ebp+4], 256 ; 00000100H
  0017b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegisterRawInputDevices@12

; 121  : 	{
; 122  : 		OK = false;
; 123  : 		return;
; 124  : 	}
; 125  : 
; 126  : 	OK = true;
; 127  : }

  00181	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00184	85 c0		 test	 eax, eax
  00186	0f 95 c0	 setne	 al
  00189	88 06		 mov	 BYTE PTR [esi], al
  0018b	33 cd		 xor	 ecx, ebp
  0018d	5e		 pop	 esi
  0018e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00193	8b e5		 mov	 esp, ebp
  00195	5d		 pop	 ebp
  00196	c3		 ret	 0
?initWindow@GLWindow@@QAEXXZ ENDP			; GLWindow::initWindow
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\window.cpp
;	COMDAT ?destroyWindow@GLWindow@@QAEXXZ
_TEXT	SEGMENT
?destroyWindow@GLWindow@@QAEXXZ PROC			; GLWindow::destroyWindow, COMDAT
; _this$ = ecx

; 235  : {

  00000	53		 push	 ebx
  00001	56		 push	 esi
  00002	8b f1		 mov	 esi, ecx

; 236  : 	bool error = false;

  00004	32 db		 xor	 bl, bl

; 237  : 
; 238  : 	if(hDC && !ReleaseDC(hWnd, hDC))

  00006	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  00009	85 c0		 test	 eax, eax
  0000b	74 13		 je	 SHORT $LN4@destroyWin
  0000d	50		 push	 eax
  0000e	ff 76 08	 push	 DWORD PTR [esi+8]
  00011	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ReleaseDC@8
  00017	85 c0		 test	 eax, eax
  00019	75 05		 jne	 SHORT $LN4@destroyWin

; 239  : 	{
; 240  : 		hDC = NULL;

  0001b	89 46 0c	 mov	 DWORD PTR [esi+12], eax

; 241  : 		error = true;

  0001e	b3 01		 mov	 bl, 1
$LN4@destroyWin:

; 242  : 	}
; 243  : 	if(hWnd && !DestroyWindow(hWnd))

  00020	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00023	85 c0		 test	 eax, eax
  00025	74 10		 je	 SHORT $LN3@destroyWin
  00027	50		 push	 eax
  00028	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DestroyWindow@4
  0002e	85 c0		 test	 eax, eax
  00030	75 05		 jne	 SHORT $LN3@destroyWin

; 244  : 	{
; 245  : 		hWnd = NULL;

  00032	89 46 08	 mov	 DWORD PTR [esi+8], eax

; 246  : 		error = true;

  00035	b3 01		 mov	 bl, 1
$LN3@destroyWin:

; 247  : 	}
; 248  : 	if(!UnregisterClass(L"GLWindow", hInstance))

  00037	ff 76 04	 push	 DWORD PTR [esi+4]
  0003a	68 00 00 00 00	 push	 OFFSET $SG4294937611
  0003f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__UnregisterClassW@8
  00045	85 c0		 test	 eax, eax
  00047	75 05		 jne	 SHORT $LN2@destroyWin

; 249  : 	{
; 250  : 		hInstance = NULL;

  00049	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 251  : 		error = true;
; 252  : 	}
; 253  : 	if(error)

  0004c	eb 04		 jmp	 SHORT $LN7@destroyWin
$LN2@destroyWin:
  0004e	84 db		 test	 bl, bl
  00050	74 14		 je	 SHORT $LN1@destroyWin
$LN7@destroyWin:

; 254  : 	{
; 255  : 		MessageBox(NULL, L"There was an error while destroying the window", L"ERROR", MB_OK | MB_ICONINFORMATION);

  00052	6a 40		 push	 64			; 00000040H
  00054	68 00 00 00 00	 push	 OFFSET $SG4294937610
  00059	68 00 00 00 00	 push	 OFFSET $SG4294937609
  0005e	6a 00		 push	 0
  00060	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxW@16
$LN1@destroyWin:

; 256  : 	}
; 257  : }

  00066	5e		 pop	 esi
  00067	5b		 pop	 ebx
  00068	c3		 ret	 0
?destroyWindow@GLWindow@@QAEXXZ ENDP			; GLWindow::destroyWindow
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\window.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\input.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\window.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\input.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\window.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\input.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\window.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\input.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\window.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\input.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\window.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\input.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\window.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\users\glenn\documents\github\wind\project\wind\wind\input.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\window.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\users\glenn\documents\github\wind\project\wind\wind\input.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\window.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\users\glenn\documents\github\wind\project\wind\wind\input.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\window.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\users\glenn\documents\github\wind\project\wind\wind\input.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\window.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\users\glenn\documents\github\wind\project\wind\wind\window.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\users\glenn\documents\github\wind\project\wind\wind\window.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\input.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\window.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\input.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\window.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\users\glenn\documents\github\wind\project\wind\wind\window.cpp
;	COMDAT ?wndProc@@YGJPAUHWND__@@IIJ@Z
_TEXT	SEGMENT
_sc$1$ = -28						; size = 4
_dwSize$1 = -28						; size = 4
$T2 = -28						; size = 8
$T3 = -28						; size = 8
$T4 = -20						; size = 20
$T5 = -20						; size = 20
$T6 = -20						; size = 20
$T7 = -20						; size = 20
$T8 = -20						; size = 20
$T9 = -20						; size = 20
_hWnd$ = 8						; size = 4
_uMsg$ = 12						; size = 4
_wParam$ = 16						; size = 4
_lParam$ = 20						; size = 4
?wndProc@@YGJPAUHWND__@@IIJ@Z PROC			; wndProc, COMDAT

; 260  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00009	53		 push	 ebx

; 261  : 	switch(uMsg)

  0000a	8b 5d 14	 mov	 ebx, DWORD PTR _lParam$[ebp]
  0000d	56		 push	 esi
  0000e	8b 75 10	 mov	 esi, DWORD PTR _wParam$[ebp]
  00011	57		 push	 edi
  00012	8b 7d 0c	 mov	 edi, DWORD PTR _uMsg$[ebp]
  00015	81 ff 12 01 00
	00		 cmp	 edi, 274		; 00000112H
  0001b	0f 87 7b 01 00
	00		 ja	 $LN25@wndProc
  00021	0f 84 58 01 00
	00		 je	 $LN17@wndProc
  00027	8d 47 fb	 lea	 eax, DWORD PTR [edi-5]
  0002a	3d fc 00 00 00	 cmp	 eax, 252		; 000000fcH
  0002f	0f 87 08 03 00
	00		 ja	 $LN107@wndProc
  00035	0f b6 80 00 00
	00 00		 movzx	 eax, BYTE PTR $LN112@wndProc[eax]
  0003c	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN117@wndProc[eax*4]
$LN20@wndProc:

; 262  : 	{
; 263  : 	case WM_ACTIVATE:
; 264  : 		{
; 265  : 			if(!HIWORD(wParam))

  00043	8b c6		 mov	 eax, esi
  00045	c1 e8 10	 shr	 eax, 16			; 00000010H
  00048	85 c0		 test	 eax, eax
  0004a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?instance@GLWindow@@2PAV1@A ; GLWindow::instance
  0004f	0f 94 c1	 sete	 cl
  00052	88 48 44	 mov	 BYTE PTR [eax+68], cl

; 266  : 			{
; 267  : 				GLWindow::instance->active = true;
; 268  : 			} else
; 269  : 			{
; 270  : 				GLWindow::instance->active = false;
; 271  : 			}
; 272  : 
; 273  : 			break;

  00055	e9 e3 02 00 00	 jmp	 $LN107@wndProc
$LN12@wndProc:

; 287  : 				}
; 288  : 			}
; 289  : 
; 290  : 			break;
; 291  : 		}
; 292  : 	case WM_CLOSE:
; 293  : 		{
; 294  : 			PostQuitMessage(0);

  0005a	6a 00		 push	 0
  0005c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PostQuitMessage@4

; 295  : 			return 0;

  00062	33 c0		 xor	 eax, eax

; 386  : }

  00064	5f		 pop	 edi
  00065	5e		 pop	 esi
  00066	5b		 pop	 ebx
  00067	8b e5		 mov	 esp, ebp
  00069	5d		 pop	 ebp
  0006a	c2 10 00	 ret	 16			; 00000010H
$LN11@wndProc:

; 296  : 		}
; 297  : 	case WM_KEYDOWN:
; 298  : 		{
; 299  : 			Keyboard::setKey(wParam, true);

  0006d	b2 01		 mov	 dl, 1
  0006f	8b ce		 mov	 ecx, esi
  00071	e8 00 00 00 00	 call	 ?setKey@Keyboard@@SAXH_N@Z ; Keyboard::setKey

; 300  : 			Keyboard::mut.lock();

  00076	b9 00 00 00 00	 mov	 ecx, OFFSET ?mut@Keyboard@@2Vmutex@std@@A ; Keyboard::mut
  0007b	e8 00 00 00 00	 call	 ?lock@_Mutex_base@std@@QAEXXZ ; std::_Mutex_base::lock
; File c:\users\glenn\documents\github\wind\project\wind\wind\input.cpp

; 5    : {

  00080	c6 44 24 10 00	 mov	 BYTE PTR $T3[esp+44], 0
; File c:\users\glenn\documents\github\wind\project\wind\wind\window.cpp

; 301  : 			Keyboard::actions.put(KeyboardAction(wParam, false));

  00085	ff 74 24 10	 push	 DWORD PTR $T3[esp+44]
  00089	56		 push	 esi
  0008a	e8 00 00 00 00	 call	 ?put@?$List@VKeyboardAction@@$0BA@@@QAEXVKeyboardAction@@@Z ; List<KeyboardAction,16>::put

; 302  : 			Keyboard::mut.unlock();

  0008f	b9 00 00 00 00	 mov	 ecx, OFFSET ?mut@Keyboard@@2Vmutex@std@@A ; Keyboard::mut
  00094	e8 00 00 00 00	 call	 ?unlock@_Mutex_base@std@@QAEXXZ ; std::_Mutex_base::unlock

; 303  : 			break;

  00099	e9 9f 02 00 00	 jmp	 $LN107@wndProc
$LN10@wndProc:

; 304  : 		}
; 305  : 	case WM_KEYUP:
; 306  : 		{
; 307  : 			Keyboard::setKey(wParam, false);

  0009e	32 d2		 xor	 dl, dl
  000a0	8b ce		 mov	 ecx, esi
  000a2	e8 00 00 00 00	 call	 ?setKey@Keyboard@@SAXH_N@Z ; Keyboard::setKey

; 308  : 			Keyboard::mut.lock();

  000a7	b9 00 00 00 00	 mov	 ecx, OFFSET ?mut@Keyboard@@2Vmutex@std@@A ; Keyboard::mut
  000ac	e8 00 00 00 00	 call	 ?lock@_Mutex_base@std@@QAEXXZ ; std::_Mutex_base::lock
; File c:\users\glenn\documents\github\wind\project\wind\wind\input.cpp

; 5    : {

  000b1	c6 44 24 10 01	 mov	 BYTE PTR $T2[esp+44], 1
; File c:\users\glenn\documents\github\wind\project\wind\wind\window.cpp

; 309  : 			Keyboard::actions.put(KeyboardAction(wParam, true));

  000b6	ff 74 24 10	 push	 DWORD PTR $T2[esp+44]
  000ba	56		 push	 esi
  000bb	e8 00 00 00 00	 call	 ?put@?$List@VKeyboardAction@@$0BA@@@QAEXVKeyboardAction@@@Z ; List<KeyboardAction,16>::put

; 310  : 			Keyboard::mut.unlock();

  000c0	b9 00 00 00 00	 mov	 ecx, OFFSET ?mut@Keyboard@@2Vmutex@std@@A ; Keyboard::mut
  000c5	e8 00 00 00 00	 call	 ?unlock@_Mutex_base@std@@QAEXXZ ; std::_Mutex_base::unlock

; 311  : 			break;

  000ca	e9 6e 02 00 00	 jmp	 $LN107@wndProc
$LN9@wndProc:

; 312  : 		}
; 313  : 	case WM_SIZE:
; 314  : 		{
; 315  : 			GLWindow::instance->rescaled = true;

  000cf	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?instance@GLWindow@@2PAV1@A ; GLWindow::instance

; 316  : 			GLWindow::instance->width = LOWORD(lParam);

  000d5	0f b7 c3	 movzx	 eax, bx
  000d8	89 41 34	 mov	 DWORD PTR [ecx+52], eax

; 317  : 			GLWindow::instance->height = HIWORD(lParam);

  000db	8b c3		 mov	 eax, ebx
  000dd	c1 e8 10	 shr	 eax, 16			; 00000010H
  000e0	c6 41 30 01	 mov	 BYTE PTR [ecx+48], 1
  000e4	89 41 38	 mov	 DWORD PTR [ecx+56], eax

; 318  : 			break;

  000e7	e9 51 02 00 00	 jmp	 $LN107@wndProc
$LN3@wndProc:

; 357  : 			Mouse::mut.unlock();
; 358  : 			break;
; 359  : 		}
; 360  : 	case WM_INPUT:
; 361  : 		{
; 362  : 			UINT dwSize = 40;
; 363  : 			static byte lpb[40];
; 364  : 
; 365  : 			GetRawInputData((HRAWINPUT)lParam, RID_INPUT, lpb, &dwSize, sizeof(RAWINPUTHEADER));

  000ec	6a 10		 push	 16			; 00000010H
  000ee	8d 44 24 10	 lea	 eax, DWORD PTR _dwSize$1[esp+44]
  000f2	50		 push	 eax
  000f3	68 00 00 00 00	 push	 OFFSET ?lpb@?BJ@??wndProc@@YGJPAUHWND__@@IIJ@Z@4PAEA
  000f8	68 03 00 00 10	 push	 268435459		; 10000003H
  000fd	53		 push	 ebx
  000fe	c7 44 24 20 28
	00 00 00	 mov	 DWORD PTR _dwSize$1[esp+60], 40 ; 00000028H
  00106	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetRawInputData@20

; 366  : 
; 367  : 			RAWINPUT* raw = (RAWINPUT*)lpb;
; 368  : 
; 369  : 			if(raw->header.dwType == RIM_TYPEMOUSE)

  0010c	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?lpb@?BJ@??wndProc@@YGJPAUHWND__@@IIJ@Z@4PAEA, 0
  00113	0f 85 24 02 00
	00		 jne	 $LN107@wndProc

; 370  : 			{
; 371  : 				if(raw->data.mouse.lLastX != 0 && raw->data.mouse.lLastY != 0)
; 372  : 				{
; 373  : 					int i = 0;
; 374  : 				}
; 375  : 
; 376  : 				Mouse::mut.lock();

  00119	b9 00 00 00 00	 mov	 ecx, OFFSET ?mut@Mouse@@2Vmutex@std@@A ; Mouse::mut
  0011e	e8 00 00 00 00	 call	 ?lock@_Mutex_base@std@@QAEXXZ ; std::_Mutex_base::lock
; File c:\users\glenn\documents\github\wind\project\wind\wind\input.cpp

; 30   : {

  00123	a1 1c 00 00 00	 mov	 eax, DWORD PTR ?lpb@?BJ@??wndProc@@YGJPAUHWND__@@IIJ@Z@4PAEA+28
  00128	89 44 24 14	 mov	 DWORD PTR $T4[esp+40], eax
  0012c	a1 20 00 00 00	 mov	 eax, DWORD PTR ?lpb@?BJ@??wndProc@@YGJPAUHWND__@@IIJ@Z@4PAEA+32
; File c:\users\glenn\documents\github\wind\project\wind\wind\window.cpp

; 377  : 				Mouse::actions.put(MouseAction(raw->data.mouse.lLastX, raw->data.mouse.lLastY, 0, -1, false));

  00131	83 ec 14	 sub	 esp, 20			; 00000014H
  00134	8b d4		 mov	 edx, esp
; File c:\users\glenn\documents\github\wind\project\wind\wind\input.cpp

; 30   : {

  00136	89 44 24 2c	 mov	 DWORD PTR $T4[esp+64], eax
; File c:\users\glenn\documents\github\wind\project\wind\wind\window.cpp

; 377  : 				Mouse::actions.put(MouseAction(raw->data.mouse.lLastX, raw->data.mouse.lLastY, 0, -1, false));

  0013a	f3 0f 7e 44 24
	28		 movq	 xmm0, QWORD PTR $T4[esp+60]
  00140	66 0f d6 02	 movq	 QWORD PTR [edx], xmm0
; File c:\users\glenn\documents\github\wind\project\wind\wind\input.cpp

; 30   : {

  00144	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR $T4[esp+68], 0
  0014c	c7 44 24 34 ff
	ff ff ff	 mov	 DWORD PTR $T4[esp+72], -1
; File c:\users\glenn\documents\github\wind\project\wind\wind\window.cpp

; 377  : 				Mouse::actions.put(MouseAction(raw->data.mouse.lLastX, raw->data.mouse.lLastY, 0, -1, false));

  00154	f3 0f 7e 44 24
	30		 movq	 xmm0, QWORD PTR $T4[esp+68]
; File c:\users\glenn\documents\github\wind\project\wind\wind\input.cpp

; 30   : {

  0015a	c6 44 24 38 00	 mov	 BYTE PTR $T4[esp+76], 0
; File c:\users\glenn\documents\github\wind\project\wind\wind\window.cpp

; 377  : 				Mouse::actions.put(MouseAction(raw->data.mouse.lLastX, raw->data.mouse.lLastY, 0, -1, false));

  0015f	8b 44 24 38	 mov	 eax, DWORD PTR $T4[esp+76]
  00163	66 0f d6 42 08	 movq	 QWORD PTR [edx+8], xmm0
  00168	89 42 10	 mov	 DWORD PTR [edx+16], eax
  0016b	e8 00 00 00 00	 call	 ?put@?$List@VMouseAction@@$0BA@@@QAEXVMouseAction@@@Z ; List<MouseAction,16>::put

; 378  : 				Mouse::mut.unlock();

  00170	b9 00 00 00 00	 mov	 ecx, OFFSET ?mut@Mouse@@2Vmutex@std@@A ; Mouse::mut
  00175	e8 00 00 00 00	 call	 ?unlock@_Mutex_base@std@@QAEXXZ ; std::_Mutex_base::unlock

; 379  : 			}
; 380  : 			
; 381  : 			break;

  0017a	e9 be 01 00 00	 jmp	 $LN107@wndProc
$LN17@wndProc:

; 274  : 		}
; 275  : 	case WM_SYSCOMMAND:
; 276  : 		{
; 277  : 			switch(wParam)

  0017f	8b c6		 mov	 eax, esi
  00181	2d 40 f1 00 00	 sub	 eax, 61760		; 0000f140H
  00186	74 09		 je	 SHORT $LN14@wndProc
  00188	83 e8 30	 sub	 eax, 48			; 00000030H
  0018b	0f 85 ac 01 00
	00		 jne	 $LN107@wndProc
$LN14@wndProc:

; 278  : 			{
; 279  : 				case SC_SCREENSAVE:
; 280  : 				{
; 281  : 
; 282  : 				}
; 283  : 				
; 284  : 				case SC_MONITORPOWER:
; 285  : 				{
; 286  : 					return 0;

  00191	33 c0		 xor	 eax, eax

; 386  : }

  00193	5f		 pop	 edi
  00194	5e		 pop	 esi
  00195	5b		 pop	 ebx
  00196	8b e5		 mov	 esp, ebp
  00198	5d		 pop	 ebp
  00199	c2 10 00	 ret	 16			; 00000010H
$LN25@wndProc:

; 261  : 	switch(uMsg)

  0019c	8d 87 ff fd ff
	ff		 lea	 eax, DWORD PTR [edi-513]
  001a2	83 f8 09	 cmp	 eax, 9
  001a5	0f 87 92 01 00
	00		 ja	 $LN107@wndProc
  001ab	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN118@wndProc[eax*4]
$LN8@wndProc:

; 319  : 		}
; 320  : 	case WM_LBUTTONDOWN:
; 321  : 		{
; 322  : 			Mouse::setMB(0, true);

  001b2	b2 01		 mov	 dl, 1
  001b4	33 c9		 xor	 ecx, ecx
  001b6	e8 00 00 00 00	 call	 ?setMB@Mouse@@SAXH_N@Z	; Mouse::setMB
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 68   : 	return (_Check_C_return(_Mtx_lock(_Mtx)));

  001bb	68 00 00 00 00	 push	 OFFSET ?mut@Mouse@@2Vmutex@std@@A ; Mouse::mut
  001c0	e8 00 00 00 00	 call	 __Mtx_lock
  001c5	83 c4 04	 add	 esp, 4

; 32   : 	if (_Res != _Thrd_success)

  001c8	85 c0		 test	 eax, eax
  001ca	74 09		 je	 SHORT $LN34@wndProc

; 33   : 		_Throw_C_error(_Res);

  001cc	50		 push	 eax
  001cd	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
  001d2	83 c4 04	 add	 esp, 4
$LN34@wndProc:
; File c:\users\glenn\documents\github\wind\project\wind\wind\input.cpp

; 30   : {

  001d5	c7 44 24 1c 00
	00 00 00	 mov	 DWORD PTR $T9[esp+48], 0
  001dd	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR $T9[esp+52], 0
; File c:\users\glenn\documents\github\wind\project\wind\wind\window.cpp

; 326  : 			break;

  001e5	e9 fe 00 00 00	 jmp	 $LN114@wndProc
$LN7@wndProc:

; 327  : 		}
; 328  : 	case WM_LBUTTONUP:
; 329  : 		{
; 330  : 			Mouse::setMB(0, false);

  001ea	32 d2		 xor	 dl, dl
  001ec	33 c9		 xor	 ecx, ecx
  001ee	e8 00 00 00 00	 call	 ?setMB@Mouse@@SAXH_N@Z	; Mouse::setMB
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 68   : 	return (_Check_C_return(_Mtx_lock(_Mtx)));

  001f3	68 00 00 00 00	 push	 OFFSET ?mut@Mouse@@2Vmutex@std@@A ; Mouse::mut
  001f8	e8 00 00 00 00	 call	 __Mtx_lock
  001fd	83 c4 04	 add	 esp, 4

; 32   : 	if (_Res != _Thrd_success)

  00200	85 c0		 test	 eax, eax
  00202	74 09		 je	 SHORT $LN50@wndProc

; 33   : 		_Throw_C_error(_Res);

  00204	50		 push	 eax
  00205	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
  0020a	83 c4 04	 add	 esp, 4
$LN50@wndProc:
; File c:\users\glenn\documents\github\wind\project\wind\wind\input.cpp

; 30   : {

  0020d	c7 44 24 1c 00
	00 00 00	 mov	 DWORD PTR $T8[esp+48], 0
  00215	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR $T8[esp+52], 0
  0021d	c6 44 24 24 01	 mov	 BYTE PTR $T8[esp+56], 1
; File c:\users\glenn\documents\github\wind\project\wind\wind\window.cpp

; 334  : 			break;

  00222	e9 c6 00 00 00	 jmp	 $LN115@wndProc
$LN6@wndProc:

; 335  : 		}
; 336  : 	case WM_RBUTTONDOWN:
; 337  : 		{
; 338  : 			Mouse::setMB(1, true);

  00227	b2 01		 mov	 dl, 1
  00229	b9 01 00 00 00	 mov	 ecx, 1
  0022e	e8 00 00 00 00	 call	 ?setMB@Mouse@@SAXH_N@Z	; Mouse::setMB
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 68   : 	return (_Check_C_return(_Mtx_lock(_Mtx)));

  00233	68 00 00 00 00	 push	 OFFSET ?mut@Mouse@@2Vmutex@std@@A ; Mouse::mut
  00238	e8 00 00 00 00	 call	 __Mtx_lock
  0023d	83 c4 04	 add	 esp, 4

; 32   : 	if (_Res != _Thrd_success)

  00240	85 c0		 test	 eax, eax
  00242	74 09		 je	 SHORT $LN66@wndProc

; 33   : 		_Throw_C_error(_Res);

  00244	50		 push	 eax
  00245	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
  0024a	83 c4 04	 add	 esp, 4
$LN66@wndProc:
; File c:\users\glenn\documents\github\wind\project\wind\wind\input.cpp

; 30   : {

  0024d	c7 44 24 1c 00
	00 00 00	 mov	 DWORD PTR $T7[esp+48], 0
  00255	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR $T7[esp+52], 1
; File c:\users\glenn\documents\github\wind\project\wind\wind\window.cpp

; 342  : 			break;

  0025d	e9 86 00 00 00	 jmp	 $LN114@wndProc
$LN5@wndProc:

; 343  : 		}
; 344  : 	case WM_RBUTTONUP:
; 345  : 		{
; 346  : 			Mouse::setMB(1, false);

  00262	32 d2		 xor	 dl, dl
  00264	b9 01 00 00 00	 mov	 ecx, 1
  00269	e8 00 00 00 00	 call	 ?setMB@Mouse@@SAXH_N@Z	; Mouse::setMB
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 68   : 	return (_Check_C_return(_Mtx_lock(_Mtx)));

  0026e	68 00 00 00 00	 push	 OFFSET ?mut@Mouse@@2Vmutex@std@@A ; Mouse::mut
  00273	e8 00 00 00 00	 call	 __Mtx_lock
  00278	83 c4 04	 add	 esp, 4

; 32   : 	if (_Res != _Thrd_success)

  0027b	85 c0		 test	 eax, eax
  0027d	74 09		 je	 SHORT $LN82@wndProc

; 33   : 		_Throw_C_error(_Res);

  0027f	50		 push	 eax
  00280	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
  00285	83 c4 04	 add	 esp, 4
$LN82@wndProc:
; File c:\users\glenn\documents\github\wind\project\wind\wind\input.cpp

; 30   : {

  00288	c7 44 24 1c 00
	00 00 00	 mov	 DWORD PTR $T6[esp+48], 0
  00290	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR $T6[esp+52], 1
  00298	c6 44 24 24 01	 mov	 BYTE PTR $T6[esp+56], 1
; File c:\users\glenn\documents\github\wind\project\wind\wind\window.cpp

; 350  : 			break;

  0029d	eb 4e		 jmp	 SHORT $LN115@wndProc
$LN4@wndProc:

; 354  : 			short sc = HIWORD(wParam);

  0029f	8b c6		 mov	 eax, esi
  002a1	c1 e8 10	 shr	 eax, 16			; 00000010H
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 68   : 	return (_Check_C_return(_Mtx_lock(_Mtx)));

  002a4	68 00 00 00 00	 push	 OFFSET ?mut@Mouse@@2Vmutex@std@@A ; Mouse::mut
; File c:\users\glenn\documents\github\wind\project\wind\wind\window.cpp

; 354  : 			short sc = HIWORD(wParam);

  002a9	89 44 24 10	 mov	 DWORD PTR _sc$1$[esp+44], eax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 68   : 	return (_Check_C_return(_Mtx_lock(_Mtx)));

  002ad	e8 00 00 00 00	 call	 __Mtx_lock
  002b2	83 c4 04	 add	 esp, 4

; 32   : 	if (_Res != _Thrd_success)

  002b5	85 c0		 test	 eax, eax
  002b7	74 09		 je	 SHORT $LN98@wndProc

; 33   : 		_Throw_C_error(_Res);

  002b9	50		 push	 eax
  002ba	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
  002bf	83 c4 04	 add	 esp, 4
$LN98@wndProc:
; File c:\users\glenn\documents\github\wind\project\wind\wind\window.cpp

; 356  : 			Mouse::actions.put(MouseAction(0, 0, sc / WHEEL_DELTA, -1, false));

  002c2	8b 44 24 0c	 mov	 eax, DWORD PTR _sc$1$[esp+40]
  002c6	0f bf c8	 movsx	 ecx, ax
  002c9	b8 89 88 88 88	 mov	 eax, -2004318071	; 88888889H
  002ce	f7 e9		 imul	 ecx
  002d0	03 d1		 add	 edx, ecx
  002d2	c1 fa 06	 sar	 edx, 6
  002d5	8b c2		 mov	 eax, edx
  002d7	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  002da	03 c2		 add	 eax, edx
; File c:\users\glenn\documents\github\wind\project\wind\wind\input.cpp

; 30   : {

  002dc	89 44 24 1c	 mov	 DWORD PTR $T5[esp+48], eax
  002e0	c7 44 24 20 ff
	ff ff ff	 mov	 DWORD PTR $T5[esp+52], -1
$LN114@wndProc:
  002e8	c6 44 24 24 00	 mov	 BYTE PTR $T5[esp+56], 0
$LN115@wndProc:
; File c:\users\glenn\documents\github\wind\project\wind\wind\window.cpp

; 356  : 			Mouse::actions.put(MouseAction(0, 0, sc / WHEEL_DELTA, -1, false));

  002ed	8b 44 24 24	 mov	 eax, DWORD PTR $T5[esp+56]
  002f1	83 ec 14	 sub	 esp, 20			; 00000014H
  002f4	8b cc		 mov	 ecx, esp
; File c:\users\glenn\documents\github\wind\project\wind\wind\input.cpp

; 30   : {

  002f6	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR $T5[esp+60], 0
  002fe	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR $T5[esp+64], 0
; File c:\users\glenn\documents\github\wind\project\wind\wind\window.cpp

; 356  : 			Mouse::actions.put(MouseAction(0, 0, sc / WHEEL_DELTA, -1, false));

  00306	f3 0f 7e 44 24
	28		 movq	 xmm0, QWORD PTR $T5[esp+60]
  0030c	66 0f d6 01	 movq	 QWORD PTR [ecx], xmm0
  00310	f3 0f 7e 44 24
	30		 movq	 xmm0, QWORD PTR $T5[esp+68]
  00316	66 0f d6 41 08	 movq	 QWORD PTR [ecx+8], xmm0
  0031b	89 41 10	 mov	 DWORD PTR [ecx+16], eax
  0031e	e8 00 00 00 00	 call	 ?put@?$List@VMouseAction@@$0BA@@@QAEXVMouseAction@@@Z ; List<MouseAction,16>::put
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 83   : 	return (_Check_C_return(_Mtx_unlock(_Mtx)));

  00323	68 00 00 00 00	 push	 OFFSET ?mut@Mouse@@2Vmutex@std@@A ; Mouse::mut
  00328	e8 00 00 00 00	 call	 __Mtx_unlock
  0032d	83 c4 04	 add	 esp, 4

; 32   : 	if (_Res != _Thrd_success)

  00330	85 c0		 test	 eax, eax
  00332	74 09		 je	 SHORT $LN107@wndProc

; 33   : 		_Throw_C_error(_Res);

  00334	50		 push	 eax
  00335	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
  0033a	83 c4 04	 add	 esp, 4
$LN107@wndProc:
; File c:\users\glenn\documents\github\wind\project\wind\wind\window.cpp

; 385  : 	return DefWindowProc(hWnd, uMsg, wParam, lParam);

  0033d	53		 push	 ebx
  0033e	56		 push	 esi
  0033f	57		 push	 edi
  00340	ff 75 08	 push	 DWORD PTR _hWnd$[ebp]
  00343	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DefWindowProcW@16

; 386  : }

  00349	5f		 pop	 edi
  0034a	5e		 pop	 esi
  0034b	5b		 pop	 ebx
  0034c	8b e5		 mov	 esp, ebp
  0034e	5d		 pop	 ebp
  0034f	c2 10 00	 ret	 16			; 00000010H
  00352	8b ff		 npad	 2
$LN117@wndProc:
  00354	00 00 00 00	 DD	 $LN9@wndProc
  00358	00 00 00 00	 DD	 $LN20@wndProc
  0035c	00 00 00 00	 DD	 $LN12@wndProc
  00360	00 00 00 00	 DD	 $LN3@wndProc
  00364	00 00 00 00	 DD	 $LN11@wndProc
  00368	00 00 00 00	 DD	 $LN10@wndProc
  0036c	00 00 00 00	 DD	 $LN107@wndProc
$LN112@wndProc:
  00370	00		 DB	 0
  00371	01		 DB	 1
  00372	06		 DB	 6
  00373	06		 DB	 6
  00374	06		 DB	 6
  00375	06		 DB	 6
  00376	06		 DB	 6
  00377	06		 DB	 6
  00378	06		 DB	 6
  00379	06		 DB	 6
  0037a	06		 DB	 6
  0037b	02		 DB	 2
  0037c	06		 DB	 6
  0037d	06		 DB	 6
  0037e	06		 DB	 6
  0037f	06		 DB	 6
  00380	06		 DB	 6
  00381	06		 DB	 6
  00382	06		 DB	 6
  00383	06		 DB	 6
  00384	06		 DB	 6
  00385	06		 DB	 6
  00386	06		 DB	 6
  00387	06		 DB	 6
  00388	06		 DB	 6
  00389	06		 DB	 6
  0038a	06		 DB	 6
  0038b	06		 DB	 6
  0038c	06		 DB	 6
  0038d	06		 DB	 6
  0038e	06		 DB	 6
  0038f	06		 DB	 6
  00390	06		 DB	 6
  00391	06		 DB	 6
  00392	06		 DB	 6
  00393	06		 DB	 6
  00394	06		 DB	 6
  00395	06		 DB	 6
  00396	06		 DB	 6
  00397	06		 DB	 6
  00398	06		 DB	 6
  00399	06		 DB	 6
  0039a	06		 DB	 6
  0039b	06		 DB	 6
  0039c	06		 DB	 6
  0039d	06		 DB	 6
  0039e	06		 DB	 6
  0039f	06		 DB	 6
  003a0	06		 DB	 6
  003a1	06		 DB	 6
  003a2	06		 DB	 6
  003a3	06		 DB	 6
  003a4	06		 DB	 6
  003a5	06		 DB	 6
  003a6	06		 DB	 6
  003a7	06		 DB	 6
  003a8	06		 DB	 6
  003a9	06		 DB	 6
  003aa	06		 DB	 6
  003ab	06		 DB	 6
  003ac	06		 DB	 6
  003ad	06		 DB	 6
  003ae	06		 DB	 6
  003af	06		 DB	 6
  003b0	06		 DB	 6
  003b1	06		 DB	 6
  003b2	06		 DB	 6
  003b3	06		 DB	 6
  003b4	06		 DB	 6
  003b5	06		 DB	 6
  003b6	06		 DB	 6
  003b7	06		 DB	 6
  003b8	06		 DB	 6
  003b9	06		 DB	 6
  003ba	06		 DB	 6
  003bb	06		 DB	 6
  003bc	06		 DB	 6
  003bd	06		 DB	 6
  003be	06		 DB	 6
  003bf	06		 DB	 6
  003c0	06		 DB	 6
  003c1	06		 DB	 6
  003c2	06		 DB	 6
  003c3	06		 DB	 6
  003c4	06		 DB	 6
  003c5	06		 DB	 6
  003c6	06		 DB	 6
  003c7	06		 DB	 6
  003c8	06		 DB	 6
  003c9	06		 DB	 6
  003ca	06		 DB	 6
  003cb	06		 DB	 6
  003cc	06		 DB	 6
  003cd	06		 DB	 6
  003ce	06		 DB	 6
  003cf	06		 DB	 6
  003d0	06		 DB	 6
  003d1	06		 DB	 6
  003d2	06		 DB	 6
  003d3	06		 DB	 6
  003d4	06		 DB	 6
  003d5	06		 DB	 6
  003d6	06		 DB	 6
  003d7	06		 DB	 6
  003d8	06		 DB	 6
  003d9	06		 DB	 6
  003da	06		 DB	 6
  003db	06		 DB	 6
  003dc	06		 DB	 6
  003dd	06		 DB	 6
  003de	06		 DB	 6
  003df	06		 DB	 6
  003e0	06		 DB	 6
  003e1	06		 DB	 6
  003e2	06		 DB	 6
  003e3	06		 DB	 6
  003e4	06		 DB	 6
  003e5	06		 DB	 6
  003e6	06		 DB	 6
  003e7	06		 DB	 6
  003e8	06		 DB	 6
  003e9	06		 DB	 6
  003ea	06		 DB	 6
  003eb	06		 DB	 6
  003ec	06		 DB	 6
  003ed	06		 DB	 6
  003ee	06		 DB	 6
  003ef	06		 DB	 6
  003f0	06		 DB	 6
  003f1	06		 DB	 6
  003f2	06		 DB	 6
  003f3	06		 DB	 6
  003f4	06		 DB	 6
  003f5	06		 DB	 6
  003f6	06		 DB	 6
  003f7	06		 DB	 6
  003f8	06		 DB	 6
  003f9	06		 DB	 6
  003fa	06		 DB	 6
  003fb	06		 DB	 6
  003fc	06		 DB	 6
  003fd	06		 DB	 6
  003fe	06		 DB	 6
  003ff	06		 DB	 6
  00400	06		 DB	 6
  00401	06		 DB	 6
  00402	06		 DB	 6
  00403	06		 DB	 6
  00404	06		 DB	 6
  00405	06		 DB	 6
  00406	06		 DB	 6
  00407	06		 DB	 6
  00408	06		 DB	 6
  00409	06		 DB	 6
  0040a	06		 DB	 6
  0040b	06		 DB	 6
  0040c	06		 DB	 6
  0040d	06		 DB	 6
  0040e	06		 DB	 6
  0040f	06		 DB	 6
  00410	06		 DB	 6
  00411	06		 DB	 6
  00412	06		 DB	 6
  00413	06		 DB	 6
  00414	06		 DB	 6
  00415	06		 DB	 6
  00416	06		 DB	 6
  00417	06		 DB	 6
  00418	06		 DB	 6
  00419	06		 DB	 6
  0041a	06		 DB	 6
  0041b	06		 DB	 6
  0041c	06		 DB	 6
  0041d	06		 DB	 6
  0041e	06		 DB	 6
  0041f	06		 DB	 6
  00420	06		 DB	 6
  00421	06		 DB	 6
  00422	06		 DB	 6
  00423	06		 DB	 6
  00424	06		 DB	 6
  00425	06		 DB	 6
  00426	06		 DB	 6
  00427	06		 DB	 6
  00428	06		 DB	 6
  00429	06		 DB	 6
  0042a	06		 DB	 6
  0042b	06		 DB	 6
  0042c	06		 DB	 6
  0042d	06		 DB	 6
  0042e	06		 DB	 6
  0042f	06		 DB	 6
  00430	06		 DB	 6
  00431	06		 DB	 6
  00432	06		 DB	 6
  00433	06		 DB	 6
  00434	06		 DB	 6
  00435	06		 DB	 6
  00436	06		 DB	 6
  00437	06		 DB	 6
  00438	06		 DB	 6
  00439	06		 DB	 6
  0043a	06		 DB	 6
  0043b	06		 DB	 6
  0043c	06		 DB	 6
  0043d	06		 DB	 6
  0043e	06		 DB	 6
  0043f	06		 DB	 6
  00440	06		 DB	 6
  00441	06		 DB	 6
  00442	06		 DB	 6
  00443	06		 DB	 6
  00444	06		 DB	 6
  00445	06		 DB	 6
  00446	06		 DB	 6
  00447	06		 DB	 6
  00448	06		 DB	 6
  00449	06		 DB	 6
  0044a	06		 DB	 6
  0044b	06		 DB	 6
  0044c	06		 DB	 6
  0044d	06		 DB	 6
  0044e	06		 DB	 6
  0044f	06		 DB	 6
  00450	06		 DB	 6
  00451	06		 DB	 6
  00452	06		 DB	 6
  00453	06		 DB	 6
  00454	06		 DB	 6
  00455	06		 DB	 6
  00456	06		 DB	 6
  00457	06		 DB	 6
  00458	06		 DB	 6
  00459	06		 DB	 6
  0045a	06		 DB	 6
  0045b	06		 DB	 6
  0045c	06		 DB	 6
  0045d	06		 DB	 6
  0045e	06		 DB	 6
  0045f	06		 DB	 6
  00460	06		 DB	 6
  00461	06		 DB	 6
  00462	06		 DB	 6
  00463	06		 DB	 6
  00464	06		 DB	 6
  00465	06		 DB	 6
  00466	06		 DB	 6
  00467	06		 DB	 6
  00468	06		 DB	 6
  00469	06		 DB	 6
  0046a	03		 DB	 3
  0046b	04		 DB	 4
  0046c	05		 DB	 5
  0046d	8d 49 00	 npad	 3
$LN118@wndProc:
  00470	00 00 00 00	 DD	 $LN8@wndProc
  00474	00 00 00 00	 DD	 $LN7@wndProc
  00478	00 00 00 00	 DD	 $LN107@wndProc
  0047c	00 00 00 00	 DD	 $LN6@wndProc
  00480	00 00 00 00	 DD	 $LN5@wndProc
  00484	00 00 00 00	 DD	 $LN107@wndProc
  00488	00 00 00 00	 DD	 $LN107@wndProc
  0048c	00 00 00 00	 DD	 $LN107@wndProc
  00490	00 00 00 00	 DD	 $LN107@wndProc
  00494	00 00 00 00	 DD	 $LN4@wndProc
?wndProc@@YGJPAUHWND__@@IIJ@Z ENDP			; wndProc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\list.h
;	COMDAT ?put@?$List@VKeyboardAction@@$0BA@@@QAEXVKeyboardAction@@@Z
_TEXT	SEGMENT
_object$ = 8						; size = 8
?put@?$List@VKeyboardAction@@$0BA@@@QAEXVKeyboardAction@@@Z PROC ; List<KeyboardAction,16>::put, COMDAT
; _this$dead$ = ecx

; 23   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 24   : 		if(count < size - 1)

  00003	8b 0d 80 00 00
	00		 mov	 ecx, DWORD PTR ?actions@Keyboard@@2V?$List@VKeyboardAction@@$0BA@@@A+128
  00009	83 f9 0f	 cmp	 ecx, 15			; 0000000fH
  0000c	7d 1f		 jge	 SHORT $LN1@put

; 25   : 		{
; 26   : 			content[count++] = object;

  0000e	8b 45 08	 mov	 eax, DWORD PTR _object$[ebp]
  00011	89 04 cd 00 00
	00 00		 mov	 DWORD PTR ?actions@Keyboard@@2V?$List@VKeyboardAction@@$0BA@@@A[ecx*8], eax
  00018	a1 80 00 00 00	 mov	 eax, DWORD PTR ?actions@Keyboard@@2V?$List@VKeyboardAction@@$0BA@@@A+128
  0001d	8b 4d 0c	 mov	 ecx, DWORD PTR _object$[ebp+4]
  00020	89 0c c5 04 00
	00 00		 mov	 DWORD PTR ?actions@Keyboard@@2V?$List@VKeyboardAction@@$0BA@@@A[eax*8+4], ecx
  00027	ff 05 80 00 00
	00		 inc	 DWORD PTR ?actions@Keyboard@@2V?$List@VKeyboardAction@@$0BA@@@A+128
$LN1@put:

; 27   : 		}
; 28   : 	}

  0002d	5d		 pop	 ebp
  0002e	c2 08 00	 ret	 8
?put@?$List@VKeyboardAction@@$0BA@@@QAEXVKeyboardAction@@@Z ENDP ; List<KeyboardAction,16>::put
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\list.h
;	COMDAT ?put@?$List@VMouseAction@@$0BA@@@QAEXVMouseAction@@@Z
_TEXT	SEGMENT
_object$ = 8						; size = 20
?put@?$List@VMouseAction@@$0BA@@@QAEXVMouseAction@@@Z PROC ; List<MouseAction,16>::put, COMDAT
; _this$dead$ = ecx

; 23   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 24   : 		if(count < size - 1)

  00003	a1 40 01 00 00	 mov	 eax, DWORD PTR ?actions@Mouse@@2V?$List@VMouseAction@@$0BA@@@A+320
  00008	83 f8 0f	 cmp	 eax, 15			; 0000000fH
  0000b	7d 2f		 jge	 SHORT $LN1@put

; 25   : 		{
; 26   : 			content[count++] = object;

  0000d	f3 0f 7e 45 08	 movq	 xmm0, QWORD PTR _object$[ebp]
  00012	8d 0c 80	 lea	 ecx, DWORD PTR [eax+eax*4]
  00015	66 0f d6 04 8d
	00 00 00 00	 movq	 QWORD PTR ?actions@Mouse@@2V?$List@VMouseAction@@$0BA@@@A[ecx*4], xmm0
  0001e	f3 0f 7e 45 10	 movq	 xmm0, QWORD PTR _object$[ebp+8]
  00023	66 0f d6 04 8d
	08 00 00 00	 movq	 QWORD PTR ?actions@Mouse@@2V?$List@VMouseAction@@$0BA@@@A[ecx*4+8], xmm0
  0002c	8b 45 18	 mov	 eax, DWORD PTR _object$[ebp+16]
  0002f	89 04 8d 10 00
	00 00		 mov	 DWORD PTR ?actions@Mouse@@2V?$List@VMouseAction@@$0BA@@@A[ecx*4+16], eax
  00036	ff 05 40 01 00
	00		 inc	 DWORD PTR ?actions@Mouse@@2V?$List@VMouseAction@@$0BA@@@A+320
$LN1@put:

; 27   : 		}
; 28   : 	}

  0003c	5d		 pop	 ebp
  0003d	c2 14 00	 ret	 20			; 00000014H
?put@?$List@VMouseAction@@$0BA@@@QAEXVMouseAction@@@Z ENDP ; List<MouseAction,16>::put
_TEXT	ENDS
END
