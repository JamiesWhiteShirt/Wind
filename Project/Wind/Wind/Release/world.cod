; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.50727.1 

	TITLE	C:\Users\Glenn\Documents\GitHub\Wind\Project\Wind\Wind\world.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@ ; `string'
PUBLIC	??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	??_R2ChunkBase@@8				; ChunkBase::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$_Ref_count@VEmptyChunk@@@std@@8	; std::_Ref_count<EmptyChunk>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@EmptyChunk@@8			; EmptyChunk::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVChunk@@@8				; Chunk `RTTI Type Descriptor'
PUBLIC	??_R1A@?0A@EA@Chunk@@8				; Chunk::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4EmptyChunk@@6B@				; EmptyChunk::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$_Ref_count@VEmptyChunk@@@std@@@8	; std::_Ref_count<EmptyChunk> `RTTI Type Descriptor'
PUBLIC	??_R0?AVChunkBase@@@8				; ChunkBase `RTTI Type Descriptor'
PUBLIC	??_R4?$_Ref_count@VEmptyChunk@@@std@@6B@	; std::_Ref_count<EmptyChunk>::`RTTI Complete Object Locator'
PUBLIC	??_R3EmptyChunk@@8				; EmptyChunk::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R3?$_Ref_count@VEmptyChunk@@@std@@8		; std::_Ref_count<EmptyChunk>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R4ChunkBase@@6B@				; ChunkBase::`RTTI Complete Object Locator'
PUBLIC	??_R2Chunk@@8					; Chunk::`RTTI Base Class Array'
PUBLIC	??_R3Chunk@@8					; Chunk::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R3ChunkBase@@8				; ChunkBase::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_7Chunk@@6B@					; Chunk::`vftable'
PUBLIC	??_R0?AVEmptyChunk@@@8				; EmptyChunk `RTTI Type Descriptor'
PUBLIC	??_7EmptyChunk@@6B@				; EmptyChunk::`vftable'
PUBLIC	??_R2?$_Ref_count@VEmptyChunk@@@std@@8		; std::_Ref_count<EmptyChunk>::`RTTI Base Class Array'
PUBLIC	??_7?$_Ref_count@VEmptyChunk@@@std@@6B@		; std::_Ref_count<EmptyChunk>::`vftable'
PUBLIC	??_R2EmptyChunk@@8				; EmptyChunk::`RTTI Base Class Array'
PUBLIC	??_R4Chunk@@6B@					; Chunk::`RTTI Complete Object Locator'
PUBLIC	??_7ChunkBase@@6B@				; ChunkBase::`vftable'
PUBLIC	??_R1A@?0A@EA@ChunkBase@@8			; ChunkBase::`RTTI Base Class Descriptor at (0,-1,0,64)'
;	COMDAT ??_R1A@?0A@EA@ChunkBase@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@ChunkBase@@8 DD FLAT:??_R0?AVChunkBase@@@8 ; ChunkBase::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3ChunkBase@@8
rdata$r	ENDS
;	COMDAT ??_7ChunkBase@@6B@
CONST	SEGMENT
??_7ChunkBase@@6B@ DD FLAT:??_R4ChunkBase@@6B@		; ChunkBase::`vftable'
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:?shouldRender@ChunkBase@@UAE_NXZ
CONST	ENDS
;	COMDAT ??_R4Chunk@@6B@
rdata$r	SEGMENT
??_R4Chunk@@6B@ DD 00H					; Chunk::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVChunk@@@8
	DD	FLAT:??_R3Chunk@@8
rdata$r	ENDS
;	COMDAT ??_R2EmptyChunk@@8
rdata$r	SEGMENT
??_R2EmptyChunk@@8 DD FLAT:??_R1A@?0A@EA@EmptyChunk@@8	; EmptyChunk::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@ChunkBase@@8
rdata$r	ENDS
;	COMDAT ??_7?$_Ref_count@VEmptyChunk@@@std@@6B@
CONST	SEGMENT
??_7?$_Ref_count@VEmptyChunk@@@std@@6B@ DD FLAT:??_R4?$_Ref_count@VEmptyChunk@@@std@@6B@ ; std::_Ref_count<EmptyChunk>::`vftable'
	DD	FLAT:?_Destroy@?$_Ref_count@VEmptyChunk@@@std@@EAEXXZ
	DD	FLAT:?_Delete_this@?$_Ref_count@VEmptyChunk@@@std@@EAEXXZ
	DD	FLAT:??_E?$_Ref_count@VEmptyChunk@@@std@@UAEPAXI@Z
	DD	FLAT:?_Get_deleter@_Ref_count_base@std@@UBEPAXABVtype_info@@@Z
CONST	ENDS
;	COMDAT ??_R2?$_Ref_count@VEmptyChunk@@@std@@8
rdata$r	SEGMENT
??_R2?$_Ref_count@VEmptyChunk@@@std@@8 DD FLAT:??_R1A@?0A@EA@?$_Ref_count@VEmptyChunk@@@std@@8 ; std::_Ref_count<EmptyChunk>::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@_Ref_count_base@std@@8
rdata$r	ENDS
;	COMDAT ??_7EmptyChunk@@6B@
CONST	SEGMENT
??_7EmptyChunk@@6B@ DD FLAT:??_R4EmptyChunk@@6B@	; EmptyChunk::`vftable'
	DD	FLAT:?getBlock@EmptyChunk@@UAEGHHH@Z
	DD	FLAT:?setBlock@EmptyChunk@@UAEXHHHG@Z
	DD	FLAT:?setBlockRaw@EmptyChunk@@UAEXHHHG@Z
	DD	FLAT:?isEmpty@EmptyChunk@@UAE_NXZ
	DD	FLAT:?shouldRender@EmptyChunk@@UAE_NXZ
CONST	ENDS
;	COMDAT ??_R0?AVEmptyChunk@@@8
_DATA	SEGMENT
??_R0?AVEmptyChunk@@@8 DD FLAT:??_7type_info@@6B@	; EmptyChunk `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVEmptyChunk@@', 00H
_DATA	ENDS
;	COMDAT ??_7Chunk@@6B@
CONST	SEGMENT
??_7Chunk@@6B@ DD FLAT:??_R4Chunk@@6B@			; Chunk::`vftable'
	DD	FLAT:?getBlock@Chunk@@UAEGHHH@Z
	DD	FLAT:?setBlock@Chunk@@UAEXHHHG@Z
	DD	FLAT:?setBlockRaw@Chunk@@UAEXHHHG@Z
	DD	FLAT:?isEmpty@Chunk@@UAE_NXZ
	DD	FLAT:?shouldRender@Chunk@@UAE_NXZ
CONST	ENDS
;	COMDAT ??_R3ChunkBase@@8
rdata$r	SEGMENT
??_R3ChunkBase@@8 DD 00H				; ChunkBase::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2ChunkBase@@8
rdata$r	ENDS
;	COMDAT ??_R3Chunk@@8
rdata$r	SEGMENT
??_R3Chunk@@8 DD 00H					; Chunk::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2Chunk@@8
rdata$r	ENDS
;	COMDAT ??_R2Chunk@@8
rdata$r	SEGMENT
??_R2Chunk@@8 DD FLAT:??_R1A@?0A@EA@Chunk@@8		; Chunk::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@ChunkBase@@8
rdata$r	ENDS
;	COMDAT ??_R4ChunkBase@@6B@
rdata$r	SEGMENT
??_R4ChunkBase@@6B@ DD 00H				; ChunkBase::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVChunkBase@@@8
	DD	FLAT:??_R3ChunkBase@@8
rdata$r	ENDS
;	COMDAT ??_R3?$_Ref_count@VEmptyChunk@@@std@@8
rdata$r	SEGMENT
??_R3?$_Ref_count@VEmptyChunk@@@std@@8 DD 00H		; std::_Ref_count<EmptyChunk>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2?$_Ref_count@VEmptyChunk@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R3EmptyChunk@@8
rdata$r	SEGMENT
??_R3EmptyChunk@@8 DD 00H				; EmptyChunk::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2EmptyChunk@@8
rdata$r	ENDS
;	COMDAT ??_R4?$_Ref_count@VEmptyChunk@@@std@@6B@
rdata$r	SEGMENT
??_R4?$_Ref_count@VEmptyChunk@@@std@@6B@ DD 00H		; std::_Ref_count<EmptyChunk>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$_Ref_count@VEmptyChunk@@@std@@@8
	DD	FLAT:??_R3?$_Ref_count@VEmptyChunk@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVChunkBase@@@8
_DATA	SEGMENT
??_R0?AVChunkBase@@@8 DD FLAT:??_7type_info@@6B@	; ChunkBase `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVChunkBase@@', 00H
_DATA	ENDS
;	COMDAT ??_R0?AV?$_Ref_count@VEmptyChunk@@@std@@@8
_DATA	SEGMENT
??_R0?AV?$_Ref_count@VEmptyChunk@@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_Ref_count<EmptyChunk> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$_Ref_count@VEmptyChunk@@@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4EmptyChunk@@6B@
rdata$r	SEGMENT
??_R4EmptyChunk@@6B@ DD 00H				; EmptyChunk::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVEmptyChunk@@@8
	DD	FLAT:??_R3EmptyChunk@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@Chunk@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@Chunk@@8 DD FLAT:??_R0?AVChunk@@@8	; Chunk::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3Chunk@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVChunk@@@8
_DATA	SEGMENT
??_R0?AVChunk@@@8 DD FLAT:??_7type_info@@6B@		; Chunk `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVChunk@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@EmptyChunk@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@EmptyChunk@@8 DD FLAT:??_R0?AVEmptyChunk@@@8 ; EmptyChunk::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3EmptyChunk@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$_Ref_count@VEmptyChunk@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$_Ref_count@VEmptyChunk@@@std@@8 DD FLAT:??_R0?AV?$_Ref_count@VEmptyChunk@@@std@@@8 ; std::_Ref_count<EmptyChunk>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$_Ref_count@VEmptyChunk@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2ChunkBase@@8
rdata$r	SEGMENT
??_R2ChunkBase@@8 DD FLAT:??_R1A@?0A@EA@ChunkBase@@8	; ChunkBase::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@ DB 'map/set<T> too l'
	DB	'ong', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@
CONST	SEGMENT
??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@ DB 'invalid '
	DB	'map/set<T> iterator', 00H			; `string'
PUBLIC	??$forward@VChunkPosition@@@std@@YA$$QAVChunkPosition@@AAV1@@Z ; std::forward<ChunkPosition>
PUBLIC	??$?0VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@QAE@$$QAU?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@PAPAX@Z ; std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> ><ChunkPosition,std::shared_ptr<ChunkBase> >
PUBLIC	??$forward@_N@std@@YA$$QA_NAA_N@Z		; std::forward<bool>
PUBLIC	??$construct@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@U?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@2@@?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@std@@@std@@QAEXPAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@$$QAU?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z ; std::allocator<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void *> >::construct<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::pair<ChunkPosition,std::shared_ptr<ChunkBase> > >
PUBLIC	??$?0AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@_N@?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@$$QA_NPAPAX@Z ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > &,bool>
PUBLIC	??$?0V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@_N@?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@_N@std@@QAE@$$QAU01@PAPAX@Z ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,bool>
PUBLIC	??$?0V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@_N@?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@$$QA_NPAPAX@Z ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,bool>
PUBLIC	??$_Buynode_if_nil@AAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@1@PAU21@AAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Buynode_if_nil<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > &>
PUBLIC	??$construct@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@U?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@2@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@std@@@1@PAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@$$QAU?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void *> > >::construct<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::pair<ChunkPosition,std::shared_ptr<ChunkBase> > >
PUBLIC	?max_size@?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@std@@@std@@QBEIXZ ; std::allocator<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void *> >::max_size
PUBLIC	?max_size@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@std@@@std@@@std@@SAIABV?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@std@@@2@@Z ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void *> > >::max_size
PUBLIC	?max_size@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@std@@@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void *> > >::max_size
PUBLIC	??F?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::operator--
PUBLIC	?max_size@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::max_size
PUBLIC	??1?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@QAE@XZ ; std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >::~pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >
PUBLIC	??_G?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@QAEPAXI@Z ; std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >::`scalar deleting destructor'
PUBLIC	??$construct@PAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@std@@AAPAU12@@?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@1@AAPAU21@@Z ; std::allocator<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void *> >::construct<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void *> *,std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void *> * &>
PUBLIC	??$destroy@PAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@std@@@?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@1@@Z ; std::allocator<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void *> >::destroy<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void *> *>
PUBLIC	??$destroy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@std@@@std@@QAEXPAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z ; std::allocator<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void *> >::destroy<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >
PUBLIC	??$_Insert_nohint@AAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@PAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@1@@Z ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Insert_nohint<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > &,std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void *> *>
PUBLIC	??$_Insert_at@AAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@_NPAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@1@AAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@1@Z ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Insert_at<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > &,std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void *> *>
PUBLIC	??$forward@AAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@YAAAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@0@AAU10@@Z ; std::forward<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > &>
PUBLIC	??$construct@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@U?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@2@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@std@@@std@@@std@@QAEXPAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@$$QAU?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void *> > >::construct<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::pair<ChunkPosition,std::shared_ptr<ChunkBase> > >
PUBLIC	??$_Resetp0@VEmptyChunk@@@?$shared_ptr@VChunkBase@@@std@@QAEXPAVEmptyChunk@@PAV_Ref_count_base@1@@Z ; std::shared_ptr<ChunkBase>::_Resetp0<EmptyChunk>
PUBLIC	??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >,std::_Iterator_base0>::operator--
PUBLIC	??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >,std::_Iterator_base0>
PUBLIC	??1?$_Ref_count@VEmptyChunk@@@std@@UAE@XZ	; std::_Ref_count<EmptyChunk>::~_Ref_count<EmptyChunk>
PUBLIC	??_G?$_Ref_count@VEmptyChunk@@@std@@UAEPAXI@Z	; std::_Ref_count<EmptyChunk>::`scalar deleting destructor'
PUBLIC	?_Delete_this@?$_Ref_count@VEmptyChunk@@@std@@EAEXXZ ; std::_Ref_count<EmptyChunk>::_Delete_this
PUBLIC	?_Destroy@?$_Ref_count@VEmptyChunk@@@std@@EAEXXZ ; std::_Ref_count<EmptyChunk>::_Destroy
PUBLIC	??0?$_Ref_count@VEmptyChunk@@@std@@QAE@PAVEmptyChunk@@@Z ; std::_Ref_count<EmptyChunk>::_Ref_count<EmptyChunk>
PUBLIC	??F?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::operator--
PUBLIC	??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QAE@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >
PUBLIC	??E?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::operator++
PUBLIC	?_Freenode0@?$_Tree_buy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@2@@Z ; std::_Tree_buy<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::_Freenode0
PUBLIC	?_Buynode0@?$_Tree_buy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@2@XZ ; std::_Tree_buy<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::_Buynode0
PUBLIC	?_Destroy_if_not_nil@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Destroy_if_not_nil
PUBLIC	?size@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::size
PUBLIC	??_GEmptyChunk@@QAEPAXI@Z			; EmptyChunk::`scalar deleting destructor'
PUBLIC	??$forward@V?$_Ptr_base@VChunkBase@@@std@@@std@@YA$$QAV?$_Ptr_base@VChunkBase@@@0@AAV10@@Z ; std::forward<std::_Ptr_base<ChunkBase> >
PUBLIC	??$construct@PAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@std@@AAPAU12@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@std@@@1@PAPAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@1@AAPAU31@@Z ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void *> > >::construct<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void *> *,std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void *> * &>
PUBLIC	??$forward@AAPAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@std@@@std@@YAAAPAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@0@AAPAU10@@Z ; std::forward<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void *> * &>
PUBLIC	??$_Move@AAPAVChunkBase@@@std@@YA$$QAPAVChunkBase@@AAPAV1@@Z ; std::_Move<ChunkBase * &>
PUBLIC	??$destroy@PAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@std@@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@std@@@1@PAPAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@1@@Z ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void *> > >::destroy<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void *> *>
PUBLIC	??$forward@AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@YAAAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@0@AAV10@@Z ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > &>
PUBLIC	??$destroy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@std@@@1@PAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void *> > >::destroy<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >
PUBLIC	??$_Move@AAD@std@@YA$$QADAAD@Z			; std::_Move<char &>
PUBLIC	??$_Distance2@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@I@std@@YAXV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@0@0AAIUbidirectional_iterator_tag@0@@Z ; std::_Distance2<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,unsigned int>
PUBLIC	??$_Iter_cat@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@YA?AUbidirectional_iterator_tag@0@ABV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@0@@Z ; std::_Iter_cat<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > >
PUBLIC	??$forward@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@YA$$QAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@0@AAV10@@Z ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > >
PUBLIC	??$_Insert_hint@AAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@AAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@PAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@1@@Z ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Insert_hint<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > &,std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void *> *>
PUBLIC	??$_Buynode@U?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@?$_Tree_buy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@1@$$QAU?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z ; std::_Tree_buy<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::_Buynode<std::pair<ChunkPosition,std::shared_ptr<ChunkBase> > >
PUBLIC	??$forward@U?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@YA$$QAU?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@0@AAU10@@Z ; std::forward<std::pair<ChunkPosition,std::shared_ptr<ChunkBase> > >
PUBLIC	??$forward@V?$shared_ptr@VChunkBase@@@std@@@std@@YA$$QAV?$shared_ptr@VChunkBase@@@0@AAV10@@Z ; std::forward<std::shared_ptr<ChunkBase> >
PUBLIC	??$forward@ABVChunkPosition@@@std@@YAABVChunkPosition@@ABV1@@Z ; std::forward<ChunkPosition const &>
PUBLIC	??$_Resetp@VEmptyChunk@@@?$shared_ptr@VChunkBase@@@std@@AAEXPAVEmptyChunk@@@Z ; std::shared_ptr<ChunkBase>::_Resetp<EmptyChunk>
PUBLIC	?_Assign_rv@?$_Ptr_base@VChunkBase@@@std@@QAEX$$QAV12@@Z ; std::_Ptr_base<ChunkBase>::_Assign_rv
PUBLIC	??0?$_Ptr_base@VChunkBase@@@std@@QAE@$$QAV01@@Z	; std::_Ptr_base<ChunkBase>::_Ptr_base<ChunkBase>
PUBLIC	??0?$shared_ptr@VChunkBase@@@std@@QAE@$$QAV01@@Z ; std::shared_ptr<ChunkBase>::shared_ptr<ChunkBase>
PUBLIC	??$_Allocate@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@std@@@std@@YAPAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@0@IPAU10@@Z ; std::_Allocate<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void *> >
PUBLIC	??$construct@PAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@std@@AAPAU12@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@1@AAPAU21@@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void *> > >::construct<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void *> *,std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void *> * &>
PUBLIC	??$swap@PAVChunkBase@@@std@@YAXAAPAVChunkBase@@0@Z ; std::swap<ChunkBase *>
PUBLIC	??$destroy@PAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@1@@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void *> > >::destroy<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void *> *>
PUBLIC	??$addressof@PAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@std@@@std@@YAPAPAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@0@AAPAU10@@Z ; std::addressof<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void *> *>
PUBLIC	??$_Kfn@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@SAABVChunkPosition@@ABU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z ; std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0>::_Kfn<ChunkPosition const ,std::shared_ptr<ChunkBase> >
PUBLIC	??$?0AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@AAV01@@?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@V12@@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@0PAPAX@Z ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > >::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > ><std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > &,std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > &>
PUBLIC	??$destroy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@std@@@std@@@std@@QAEXPAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void *> > >::destroy<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >
PUBLIC	??$swap@D@std@@YAXAAD0@Z			; std::swap<char>
PUBLIC	??$addressof@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@YAPAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@0@AAU10@@Z ; std::addressof<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >
PUBLIC	??$_Distance@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@I@std@@YAXV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@0@0AAI@Z ; std::_Distance<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,unsigned int>
PUBLIC	??$?0V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@V01@@?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@V12@@std@@QAE@$$QAU01@PAPAX@Z ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > >::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > ><std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > >
PUBLIC	??$insert@U?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@$$QAU?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::insert<std::pair<ChunkPosition,std::shared_ptr<ChunkBase> > >
PUBLIC	??$?0ABVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@QAE@ABVChunkPosition@@$$QAV?$shared_ptr@VChunkBase@@@1@PAPAX@Z ; std::pair<ChunkPosition,std::shared_ptr<ChunkBase> >::pair<ChunkPosition,std::shared_ptr<ChunkBase> ><ChunkPosition const &,std::shared_ptr<ChunkBase> >
PUBLIC	??$?0VEmptyChunk@@@?$shared_ptr@VChunkBase@@@std@@QAE@PAVEmptyChunk@@@Z ; std::shared_ptr<ChunkBase>::shared_ptr<ChunkBase><EmptyChunk>
PUBLIC	?allocate@?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@2@I@Z ; std::allocator<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void *> >::allocate
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void *> > >::allocate
PUBLIC	??0?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >
PUBLIC	??0?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@std@@@std@@QAE@XZ ; std::allocator<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void *> >::allocator<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void *> >
PUBLIC	?_Buyheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@2@XZ ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::_Buyheadnode
PUBLIC	?deallocate@?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@2@I@Z ; std::allocator<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void *> >::deallocate
PUBLIC	??0?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void *> > >::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void *> > >
PUBLIC	??0?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@1@@Z ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::_Tree_alloc<0,std::_Tree_base_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >
PUBLIC	?_Max@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::_Max
PUBLIC	?_Color@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::_Color
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void *> > >::deallocate
PUBLIC	?_Getal@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@std@@@std@@@2@XZ ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::_Getal
PUBLIC	??0?$_Tree_buy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QAE@ABV?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@1@@Z ; std::_Tree_buy<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::_Tree_buy<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >
PUBLIC	?_Rrotate@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Rrotate
PUBLIC	?_Root@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@2@XZ ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Root
PUBLIC	?_Rmost@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@2@XZ ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Rmost
PUBLIC	?_Lrotate@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Lrotate
PUBLIC	?_Erase@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Erase
PUBLIC	??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QAE?AV01@H@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::operator++
PUBLIC	?_Swap@?$_Ptr_base@VChunkBase@@@std@@QAEXAAV12@@Z ; std::_Ptr_base<ChunkBase>::_Swap
PUBLIC	?_Freeheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@2@@Z ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::_Freeheadnode
PUBLIC	??0?$_Tree_comp@$0A@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@VChunkPosition@@@1@ABV?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@1@@Z ; std::_Tree_comp<0,std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Tree_comp<0,std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >
PUBLIC	?_Kfn@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IBEABVChunkPosition@@ABU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Kfn
PUBLIC	?_Lbound@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@2@ABVChunkPosition@@@Z ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Lbound
PUBLIC	?_Eqrange@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@V12@@2@ABVChunkPosition@@@Z ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Eqrange
PUBLIC	?clear@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::clear
PUBLIC	?erase@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::erase
PUBLIC	?pointer_to@?$pointer_traits@PAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@SAPAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@2@AAU32@@Z ; std::pointer_traits<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > *>::pointer_to
PUBLIC	?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@2@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >,std::_Iterator_base0>::_Mynode
PUBLIC	??D?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QBEAAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::operator*
PUBLIC	?swap@?$shared_ptr@VChunkBase@@@std@@QAEXAAV12@@Z ; std::shared_ptr<ChunkBase>::swap
PUBLIC	??0?$shared_ptr@VChunkBase@@@std@@QAE@XZ	; std::shared_ptr<ChunkBase>::shared_ptr<ChunkBase>
PUBLIC	??1?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@@std@@QAE@XZ ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::~_Tree_alloc<0,std::_Tree_base_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >
PUBLIC	??0?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QAE@XZ ; std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >
PUBLIC	?_Getcomp@?$_Tree_comp@$0A@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QBE?AU?$less@VChunkPosition@@@2@XZ ; std::_Tree_comp<0,std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Getcomp
PUBLIC	??R?$less@VChunkPosition@@@std@@QBE_NABVChunkPosition@@0@Z ; std::less<ChunkPosition>::operator()
PUBLIC	?_Key@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IBEABVChunkPosition@@PAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Key
PUBLIC	?_Tidy@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Tidy
PUBLIC	?equal_range@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@V12@@2@ABVChunkPosition@@@Z ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::equal_range
PUBLIC	?lower_bound@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@ABVChunkPosition@@@Z ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::lower_bound
PUBLIC	?erase@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::erase
PUBLIC	??0?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@VChunkPosition@@@1@ABV?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@1@@Z ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >
PUBLIC	??1?$_Tree_buy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QAE@XZ ; std::_Tree_buy<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::~_Tree_buy<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >
PUBLIC	??1?$_Tree_comp@$0A@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree_comp<0,std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::~_Tree_comp<0,std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >
PUBLIC	??1?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@QAE@XZ ; std::pair<ChunkPosition,std::shared_ptr<ChunkBase> >::~pair<ChunkPosition,std::shared_ptr<ChunkBase> >
PUBLIC	??C?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QBEPAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::operator->
PUBLIC	??4?$shared_ptr@VChunkBase@@@std@@QAEAAV01@ABV01@@Z ; std::shared_ptr<ChunkBase>::operator=
PUBLIC	?find@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@ABVChunkPosition@@@Z ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::find
PUBLIC	?erase@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QAEIABVChunkPosition@@@Z ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::erase
PUBLIC	??1?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::~_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >
PUBLIC	??A?$map@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@@std@@QAEAAV?$shared_ptr@VChunkBase@@@1@ABVChunkPosition@@@Z ; std::map<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::operator[]
PUBLIC	??0?$map@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@@std@@QAE@XZ ; std::map<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::map<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >
PUBLIC	??0?$shared_ptr@VVertexStream@gfxu@@@std@@QAE@$$T@Z ; std::shared_ptr<gfxu::VertexStream>::shared_ptr<gfxu::VertexStream>
PUBLIC	??M@YA_NABVChunkPosition@@0@Z			; operator<
PUBLIC	?setBlock@World@@QAEXHHHG@Z			; World::setBlock
PUBLIC	?getChunkFromBlockCoordinate@World@@QAE?AV?$shared_ptr@VChunkBase@@@std@@HHH@Z ; World::getChunkFromBlockCoordinate
PUBLIC	??1?$map@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@@std@@QAE@XZ ; std::map<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::~map<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >
PUBLIC	?shouldRender@Chunk@@UAE_NXZ			; Chunk::shouldRender
PUBLIC	?isEmpty@Chunk@@UAE_NXZ				; Chunk::isEmpty
PUBLIC	?setBlockRaw@Chunk@@UAEXHHHG@Z			; Chunk::setBlockRaw
PUBLIC	?setBlock@Chunk@@UAEXHHHG@Z			; Chunk::setBlock
PUBLIC	?getBlock@Chunk@@UAEGHHH@Z			; Chunk::getBlock
PUBLIC	??1Chunk@@QAE@XZ				; Chunk::~Chunk
PUBLIC	??0Chunk@@QAE@AAVWorld@@HHH@Z			; Chunk::Chunk
PUBLIC	?shouldRender@EmptyChunk@@UAE_NXZ		; EmptyChunk::shouldRender
PUBLIC	?isEmpty@EmptyChunk@@UAE_NXZ			; EmptyChunk::isEmpty
PUBLIC	?setBlockRaw@EmptyChunk@@UAEXHHHG@Z		; EmptyChunk::setBlockRaw
PUBLIC	?setBlock@EmptyChunk@@UAEXHHHG@Z		; EmptyChunk::setBlock
PUBLIC	?getBlock@EmptyChunk@@UAEGHHH@Z			; EmptyChunk::getBlock
PUBLIC	??1EmptyChunk@@QAE@XZ				; EmptyChunk::~EmptyChunk
PUBLIC	??0EmptyChunk@@QAE@AAVWorld@@HHH@Z		; EmptyChunk::EmptyChunk
PUBLIC	?shouldRender@ChunkBase@@UAE_NXZ		; ChunkBase::shouldRender
PUBLIC	??1ChunkBase@@QAE@XZ				; ChunkBase::~ChunkBase
PUBLIC	??0ChunkBase@@QAE@AAVWorld@@HHH@Z		; ChunkBase::ChunkBase
PUBLIC	?replace@BlockCount@@QAEXGG@Z			; BlockCount::replace
PUBLIC	?place@BlockCount@@QAEXG@Z			; BlockCount::place
PUBLIC	?remove@BlockCount@@QAEXG@Z			; BlockCount::remove
PUBLIC	?isVaried@BlockCount@@QAE_NXZ			; BlockCount::isVaried
PUBLIC	?isAllSolid@BlockCount@@QAE_NXZ			; BlockCount::isAllSolid
PUBLIC	??0BlockCount@@QAE@I@Z				; BlockCount::BlockCount
PUBLIC	??0ChunkPosition@@QAE@HHH@Z			; ChunkPosition::ChunkPosition
PUBLIC	??1World@@QAE@XZ				; World::~World
PUBLIC	??0World@@QAE@XZ				; World::World
PUBLIC	?removeChunk@World@@QAEXVChunkPosition@@@Z	; World::removeChunk
PUBLIC	?addChunk@World@@QAE_NV?$shared_ptr@VChunkBase@@@std@@@Z ; World::addChunk
PUBLIC	?setUnloaded@ChunkBase@@QAEXXZ			; ChunkBase::setUnloaded
PUBLIC	?setLoaded@ChunkBase@@QAEXXZ			; ChunkBase::setLoaded
PUBLIC	?getBlock@World@@QAEGHHH@Z			; World::getBlock
PUBLIC	?getChunk@World@@QAE?AV?$shared_ptr@VChunkBase@@@std@@HHH@Z ; World::getChunk
PUBLIC	?isRenderUpdateNeeded@ChunkBase@@QAE_NXZ	; ChunkBase::isRenderUpdateNeeded
PUBLIC	?setRenderUpdateNeeded@ChunkBase@@QAEX_N@Z	; ChunkBase::setRenderUpdateNeeded
PUBLIC	?isUnloaded@ChunkBase@@QAE_NXZ			; ChunkBase::isUnloaded
PUBLIC	?isLoaded@ChunkBase@@QAE_NXZ			; ChunkBase::isLoaded
EXTRN	??_E?$_Ref_count@VEmptyChunk@@@std@@UAEPAXI@Z:PROC ; std::_Ref_count<EmptyChunk>::`vector deleting destructor'
__Tuple_alloc DB 01H DUP (?)
	ALIGN	4

_ignore	DB	01H DUP (?)
	ALIGN	4

_allocator_arg DB 01H DUP (?)
	ALIGN	4

_piecewise_construct DB 01H DUP (?)
_BSS	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?getChunk@World@@QAE?AV?$shared_ptr@VChunkBase@@@std@@HHH@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?getChunk@World@@QAE?AV?$shared_ptr@VChunkBase@@@std@@HHH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?getChunk@World@@QAE?AV?$shared_ptr@VChunkBase@@@std@@HHH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?getChunk@World@@QAE?AV?$shared_ptr@VChunkBase@@@std@@HHH@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?getBlock@World@@QAEGHHH@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?getBlock@World@@QAEGHHH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?getBlock@World@@QAEGHHH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?getBlock@World@@QAEGHHH@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?addChunk@World@@QAE_NV?$shared_ptr@VChunkBase@@@std@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?addChunk@World@@QAE_NV?$shared_ptr@VChunkBase@@@std@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?addChunk@World@@QAE_NV?$shared_ptr@VChunkBase@@@std@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?addChunk@World@@QAE_NV?$shared_ptr@VChunkBase@@@std@@@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0World@@QAE@XZ DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$??0World@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0World@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0World@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0World@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0World@@QAE@XZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$??0World@@QAE@XZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$??0World@@QAE@XZ$4
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0ChunkBase@@QAE@AAVWorld@@HHH@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0ChunkBase@@QAE@AAVWorld@@HHH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0ChunkBase@@QAE@AAVWorld@@HHH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0ChunkBase@@QAE@AAVWorld@@HHH@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0ChunkBase@@QAE@AAVWorld@@HHH@Z$1
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?shouldRender@Chunk@@UAE_NXZ DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$?shouldRender@Chunk@@UAE_NXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?shouldRender@Chunk@@UAE_NXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?shouldRender@Chunk@@UAE_NXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?shouldRender@Chunk@@UAE_NXZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$?shouldRender@Chunk@@UAE_NXZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$?shouldRender@Chunk@@UAE_NXZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$?shouldRender@Chunk@@UAE_NXZ$4
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?setBlock@World@@QAEXHHHG@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?setBlock@World@@QAEXHHHG@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?setBlock@World@@QAEXHHHG@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?setBlock@World@@QAEXHHHG@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?setBlock@World@@QAEXHHHG@Z$1
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??A?$map@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@@std@@QAEAAV?$shared_ptr@VChunkBase@@@1@ABVChunkPosition@@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??A?$map@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@@std@@QAEAAV?$shared_ptr@VChunkBase@@@1@ABVChunkPosition@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??A?$map@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@@std@@QAEAAV?$shared_ptr@VChunkBase@@@1@ABVChunkPosition@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??A?$map@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@@std@@QAEAAV?$shared_ptr@VChunkBase@@@1@ABVChunkPosition@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??A?$map@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@@std@@QAEAAV?$shared_ptr@VChunkBase@@@1@ABVChunkPosition@@@Z$1
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Resetp@VEmptyChunk@@@?$shared_ptr@VChunkBase@@@std@@AAEXPAVEmptyChunk@@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Resetp@VEmptyChunk@@@?$shared_ptr@VChunkBase@@@std@@AAEXPAVEmptyChunk@@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Resetp@VEmptyChunk@@@?$shared_ptr@VChunkBase@@@std@@AAEXPAVEmptyChunk@@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$_Resetp@VEmptyChunk@@@?$shared_ptr@VChunkBase@@@std@@AAEXPAVEmptyChunk@@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Resetp@VEmptyChunk@@@?$shared_ptr@VChunkBase@@@std@@AAEXPAVEmptyChunk@@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Resetp@VEmptyChunk@@@?$shared_ptr@VChunkBase@@@std@@AAEXPAVEmptyChunk@@@Z$3
__catchsym$??$_Resetp@VEmptyChunk@@@?$shared_ptr@VChunkBase@@@std@@AAEXPAVEmptyChunk@@@Z$3 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Resetp@VEmptyChunk@@@?$shared_ptr@VChunkBase@@@std@@AAEXPAVEmptyChunk@@@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Insert_hint@AAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@AAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@PAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Insert_hint@AAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@AAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@PAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@1@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Insert_hint@AAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@AAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@PAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@1@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$_Insert_hint@AAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@AAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@PAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@1@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Insert_hint@AAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@AAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@PAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@1@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Insert_hint@AAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@AAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@PAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@1@@Z$2
__catchsym$??$_Insert_hint@AAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@AAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@PAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@1@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Insert_hint@AAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@AAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@PAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@1@@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Insert_nohint@AAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@PAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Insert_nohint@AAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@PAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@1@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Insert_nohint@AAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@PAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@1@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$_Insert_nohint@AAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@PAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@1@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Insert_nohint@AAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@PAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@1@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Insert_nohint@AAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@PAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@1@@Z$2
__catchsym$??$_Insert_nohint@AAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@PAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@1@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Insert_nohint@AAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@PAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@1@@Z$0
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
;	COMDAT ?isLoaded@ChunkBase@@QAE_NXZ
_TEXT	SEGMENT
?isLoaded@ChunkBase@@QAE_NXZ PROC			; ChunkBase::isLoaded, COMDAT
; _this$ = ecx

; 65   : 	return loaded;

  00000	8a 41 05	 mov	 al, BYTE PTR [ecx+5]

; 66   : }

  00003	c3		 ret	 0
?isLoaded@ChunkBase@@QAE_NXZ ENDP			; ChunkBase::isLoaded
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
;	COMDAT ?isUnloaded@ChunkBase@@QAE_NXZ
_TEXT	SEGMENT
?isUnloaded@ChunkBase@@QAE_NXZ PROC			; ChunkBase::isUnloaded, COMDAT
; _this$ = ecx

; 75   : 	return unloaded;

  00000	8a 41 06	 mov	 al, BYTE PTR [ecx+6]

; 76   : }

  00003	c3		 ret	 0
?isUnloaded@ChunkBase@@QAE_NXZ ENDP			; ChunkBase::isUnloaded
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
;	COMDAT ?setRenderUpdateNeeded@ChunkBase@@QAEX_N@Z
_TEXT	SEGMENT
_flag$ = 8						; size = 1
?setRenderUpdateNeeded@ChunkBase@@QAEX_N@Z PROC		; ChunkBase::setRenderUpdateNeeded, COMDAT
; _this$ = ecx

; 84   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 85   : 	renderUpdateNeeded = flag;

  00003	8a 45 08	 mov	 al, BYTE PTR _flag$[ebp]
  00006	88 41 04	 mov	 BYTE PTR [ecx+4], al

; 86   : }

  00009	5d		 pop	 ebp
  0000a	c2 04 00	 ret	 4
?setRenderUpdateNeeded@ChunkBase@@QAEX_N@Z ENDP		; ChunkBase::setRenderUpdateNeeded
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
;	COMDAT ?isRenderUpdateNeeded@ChunkBase@@QAE_NXZ
_TEXT	SEGMENT
?isRenderUpdateNeeded@ChunkBase@@QAE_NXZ PROC		; ChunkBase::isRenderUpdateNeeded, COMDAT
; _this$ = ecx

; 90   : 	return renderUpdateNeeded;

  00000	8a 41 04	 mov	 al, BYTE PTR [ecx+4]

; 91   : }

  00003	c3		 ret	 0
?isRenderUpdateNeeded@ChunkBase@@QAE_NXZ ENDP		; ChunkBase::isRenderUpdateNeeded
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
;	COMDAT ?getChunk@World@@QAE?AV?$shared_ptr@VChunkBase@@@std@@HHH@Z
_TEXT	SEGMENT
_cp$ = -28						; size = 12
$T2 = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
$T3 = 12						; size = 4
$T4 = 12						; size = 4
$T5 = 12						; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
_z$ = 20						; size = 4
?getChunk@World@@QAE?AV?$shared_ptr@VChunkBase@@@std@@HHH@Z PROC ; World::getChunk, COMDAT
; _this$ = ecx

; 206  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?getChunk@World@@QAE?AV?$shared_ptr@VChunkBase@@@std@@HHH@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 10	 sub	 esp, 16			; 00000010H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 6    : {

  00028	8b 45 0c	 mov	 eax, DWORD PTR _x$[ebp]
  0002b	8b 5d 10	 mov	 ebx, DWORD PTR _y$[ebp]
  0002e	8b 7d 14	 mov	 edi, DWORD PTR _z$[ebp]
  00031	89 45 e4	 mov	 DWORD PTR _cp$[ebp], eax

; 207  : 	ChunkPosition cp = ChunkPosition(x, y, z);
; 208  : 	auto chunk = chunkMap.find(cp);

  00034	8d 71 04	 lea	 esi, DWORD PTR [ecx+4]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree

; 1572 : 		return (iterator(_Lbound(_Keyval), this));

  00037	8d 45 e4	 lea	 eax, DWORD PTR _cp$[ebp]
  0003a	50		 push	 eax
  0003b	8b ce		 mov	 ecx, esi
  0003d	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T2[ebp], 0
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp

; 6    : {

  00044	89 5d e8	 mov	 DWORD PTR _cp$[ebp+4], ebx
  00047	89 7d ec	 mov	 DWORD PTR _cp$[ebp+8], edi
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree

; 1572 : 		return (iterator(_Lbound(_Keyval), this));

  0004a	e8 00 00 00 00	 call	 ?_Lbound@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@2@ABVChunkPosition@@@Z ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Lbound

; 44   : 		{	// construct with node pointer _Pnode

  0004f	8b 0e		 mov	 ecx, DWORD PTR [esi]
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp

; 296  : 	if(cp1.x < cp2.x)

  00051	8b 75 0c	 mov	 esi, DWORD PTR _x$[ebp]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree

; 336  : 		return (this->_Ptr == _Right._Ptr);

  00054	3b c1		 cmp	 eax, ecx

; 1550 : 					? end() : _Where);

  00056	74 21		 je	 SHORT $LN14@getChunk
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp

; 296  : 	if(cp1.x < cp2.x)

  00058	8b 50 10	 mov	 edx, DWORD PTR [eax+16]
  0005b	3b f2		 cmp	 esi, edx
  0005d	7c 1a		 jl	 SHORT $LN14@getChunk

; 297  : 	{
; 298  : 		return true;
; 299  : 	}
; 300  : 	else if(cp1.x == cp2.x)

  0005f	75 13		 jne	 SHORT $LN101@getChunk

; 301  : 	{
; 302  : 		if(cp1.y < cp2.y)

  00061	8b 50 14	 mov	 edx, DWORD PTR [eax+20]
  00064	3b da		 cmp	 ebx, edx
  00066	7c 11		 jl	 SHORT $LN14@getChunk

; 303  : 		{
; 304  : 			return true;
; 305  : 		}
; 306  : 		else if(cp1.y == cp2.y)

  00068	75 0a		 jne	 SHORT $LN101@getChunk

; 307  : 		{
; 308  : 			return cp1.z < cp2.z;

  0006a	3b 78 18	 cmp	 edi, DWORD PTR [eax+24]
  0006d	0f 9c c2	 setl	 dl
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree

; 1550 : 					? end() : _Where);

  00070	84 d2		 test	 dl, dl
  00072	75 05		 jne	 SHORT $LN14@getChunk
$LN101@getChunk:
  00074	89 45 0c	 mov	 DWORD PTR $T3[ebp], eax
  00077	eb 03		 jmp	 SHORT $LN104@getChunk
$LN14@getChunk:

; 44   : 		{	// construct with node pointer _Pnode

  00079	89 4d 0c	 mov	 DWORD PTR $T4[ebp], ecx
$LN104@getChunk:

; 1550 : 					? end() : _Where);

  0007c	8d 45 0c	 lea	 eax, DWORD PTR $T4[ebp]
  0007f	8b 00		 mov	 eax, DWORD PTR [eax]

; 336  : 		return (this->_Ptr == _Right._Ptr);

  00081	3b c1		 cmp	 eax, ecx
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp

; 209  : 	if(chunk == chunkMap.end())

  00083	75 6a		 jne	 SHORT $LN2@getChunk

; 211  : 		return shared_ptr<ChunkBase>(new EmptyChunk(GlobalThread::world, x, y, z));

  00085	6a 7c		 push	 124			; 0000007cH
  00087	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0008c	8b f8		 mov	 edi, eax
  0008e	83 c4 04	 add	 esp, 4
  00091	89 7d 0c	 mov	 DWORD PTR $T5[ebp], edi
  00094	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0009b	85 ff		 test	 edi, edi
  0009d	74 19		 je	 SHORT $LN5@getChunk

; 7    : 
; 8    : }
; 9    : 
; 10   : BlockCount::BlockCount(unsigned int size)
; 11   : 	: size(size), solids(0), nonsolids(0)
; 12   : {
; 13   : 
; 14   : }
; 15   : 
; 16   : bool BlockCount::isAllAir()
; 17   : {
; 18   : 	return (solids == 0) & (nonsolids == 0);
; 19   : }
; 20   : 
; 21   : bool BlockCount::isAllSolid()
; 22   : {
; 23   : 	return solids == size;
; 24   : }
; 25   : 
; 26   : bool BlockCount::isVaried()
; 27   : {
; 28   : 	return !(((solids == 0) & (nonsolids == 0)) | (solids == 16 * 16 * 16));
; 29   : }
; 30   : 
; 31   : void BlockCount::remove(unsigned short oldBlock)
; 32   : {
; 33   : 	if(oldBlock) solids--;
; 34   : }
; 35   : 
; 36   : void BlockCount::place(unsigned short newBlock)
; 37   : {
; 38   : 	if(newBlock) solids++;
; 39   : }
; 40   : 
; 41   : void BlockCount::replace(unsigned short oldBlock, unsigned short newBlock)
; 42   : {
; 43   : 	remove(oldBlock);
; 44   : 	place(newBlock);
; 45   : }
; 46   : 
; 47   : ChunkBase::ChunkBase(World& world, int xPos, int yPos, int zPos)
; 48   : 	: world(&world), pos(ChunkPosition(xPos, yPos, zPos)), loaded(false), unloaded(false), renderUpdateNeeded(false), renderStream(nullptr), cAll(4096), cWest(256), cEast(256), cDown(256), cUp(256), cSouth(256), cNorth(256)
; 49   : {
; 50   : 
; 51   : }
; 52   : 
; 53   : ChunkBase::~ChunkBase()
; 54   : {
; 55   : 
; 56   : }
; 57   : 
; 58   : void ChunkBase::setLoaded()
; 59   : {
; 60   : 	loaded = true;
; 61   : }
; 62   : 
; 63   : bool ChunkBase::isLoaded()
; 64   : {
; 65   : 	return loaded;
; 66   : }
; 67   : 
; 68   : void ChunkBase::setUnloaded()
; 69   : {
; 70   : 	unloaded = true;
; 71   : }
; 72   : 
; 73   : bool ChunkBase::isUnloaded()
; 74   : {
; 75   : 	return unloaded;
; 76   : }
; 77   : 
; 78   : bool ChunkBase::shouldRender()
; 79   : {
; 80   : 	return false;
; 81   : }
; 82   : 
; 83   : void ChunkBase::setRenderUpdateNeeded(bool flag)
; 84   : {
; 85   : 	renderUpdateNeeded = flag;
; 86   : }
; 87   : 
; 88   : bool ChunkBase::isRenderUpdateNeeded()
; 89   : {
; 90   : 	return renderUpdateNeeded;
; 91   : }
; 92   : 
; 93   : 
; 94   : 
; 95   : EmptyChunk::EmptyChunk(World& world, int xPos, int yPos, int zPos)
; 96   : 	: ChunkBase(world, xPos, yPos, zPos)
; 97   : {

  0009f	ff 75 14	 push	 DWORD PTR _z$[ebp]
  000a2	8b cf		 mov	 ecx, edi
  000a4	53		 push	 ebx
  000a5	56		 push	 esi
  000a6	68 00 00 00 00	 push	 OFFSET ?world@GlobalThread@@3VWorld@@A ; GlobalThread::world
  000ab	e8 00 00 00 00	 call	 ??0ChunkBase@@QAE@AAVWorld@@HHH@Z ; ChunkBase::ChunkBase
  000b0	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], OFFSET ??_7EmptyChunk@@6B@

; 211  : 		return shared_ptr<ChunkBase>(new EmptyChunk(GlobalThread::world, x, y, z));

  000b6	eb 02		 jmp	 SHORT $LN6@getChunk
$LN5@getChunk:
  000b8	33 ff		 xor	 edi, edi
$LN6@getChunk:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 282  : 		{	// construct

  000ba	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp

; 211  : 		return shared_ptr<ChunkBase>(new EmptyChunk(GlobalThread::world, x, y, z));

  000bd	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 487  : 		_Resetp(_Px);

  000c4	57		 push	 edi
  000c5	8b ce		 mov	 ecx, esi

; 282  : 		{	// construct

  000c7	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  000cd	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 487  : 		_Resetp(_Px);

  000d4	e8 00 00 00 00	 call	 ??$_Resetp@VEmptyChunk@@@?$shared_ptr@VChunkBase@@@std@@AAEXPAVEmptyChunk@@@Z ; std::shared_ptr<ChunkBase>::_Resetp<EmptyChunk>
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp

; 211  : 		return shared_ptr<ChunkBase>(new EmptyChunk(GlobalThread::world, x, y, z));

  000d9	8b c6		 mov	 eax, esi

; 216  : 	}
; 217  : }

  000db	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000de	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000e5	59		 pop	 ecx
  000e6	5f		 pop	 edi
  000e7	5e		 pop	 esi
  000e8	5b		 pop	 ebx
  000e9	8b e5		 mov	 esp, ebp
  000eb	5d		 pop	 ebp
  000ec	c2 10 00	 ret	 16			; 00000010H
$LN2@getChunk:

; 212  : 	}
; 213  : 	else
; 214  : 	{
; 215  : 		return chunk->second;

  000ef	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  000f2	83 c0 1c	 add	 eax, 28			; 0000001cH
  000f5	50		 push	 eax
  000f6	e8 00 00 00 00	 call	 ??0?$shared_ptr@VChunkBase@@@std@@QAE@ABV01@@Z ; std::shared_ptr<ChunkBase>::shared_ptr<ChunkBase>
  000fb	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 216  : 	}
; 217  : }

  000fe	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00101	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00108	59		 pop	 ecx
  00109	5f		 pop	 edi
  0010a	5e		 pop	 esi
  0010b	5b		 pop	 ebx
  0010c	8b e5		 mov	 esp, ebp
  0010e	5d		 pop	 ebp
  0010f	c2 10 00	 ret	 16			; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?getChunk@World@@QAE?AV?$shared_ptr@VChunkBase@@@std@@HHH@Z$0:
  00000	8b 45 0c	 mov	 eax, DWORD PTR $T5[ebp]
  00003	50		 push	 eax
  00004	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00009	59		 pop	 ecx
  0000a	c3		 ret	 0
__ehhandler$?getChunk@World@@QAE?AV?$shared_ptr@VChunkBase@@@std@@HHH@Z:
  0000b	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000f	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00012	8b 4a e0	 mov	 ecx, DWORD PTR [edx-32]
  00015	33 c8		 xor	 ecx, eax
  00017	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001c	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?getChunk@World@@QAE?AV?$shared_ptr@VChunkBase@@@std@@HHH@Z
  00021	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?getChunk@World@@QAE?AV?$shared_ptr@VChunkBase@@@std@@HHH@Z ENDP ; World::getChunk
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
;	COMDAT ?getBlock@World@@QAEGHHH@Z
_TEXT	SEGMENT
_chunk$ = -24						; size = 8
__$EHRec$ = -12						; size = 12
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_z$ = 16						; size = 4
?getBlock@World@@QAEGHHH@Z PROC				; World::getBlock, COMDAT
; _this$dead$ = ecx

; 237  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?getBlock@World@@QAEGHHH@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 10	 sub	 esp, 16			; 00000010H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 238  : 	std::shared_ptr<ChunkBase> chunk = getChunkFromBlockCoordinate(x, y, z);

  00028	8b 7d 10	 mov	 edi, DWORD PTR _z$[ebp]
  0002b	8b 5d 0c	 mov	 ebx, DWORD PTR _y$[ebp]
  0002e	57		 push	 edi
  0002f	53		 push	 ebx
  00030	ff 75 08	 push	 DWORD PTR _x$[ebp]
  00033	8d 45 e8	 lea	 eax, DWORD PTR _chunk$[ebp]
  00036	50		 push	 eax
  00037	b9 00 00 00 00	 mov	 ecx, OFFSET ?world@GlobalThread@@3VWorld@@A ; GlobalThread::world
  0003c	e8 00 00 00 00	 call	 ?getChunkFromBlockCoordinate@World@@QAE?AV?$shared_ptr@VChunkBase@@@std@@HHH@Z ; World::getChunkFromBlockCoordinate
  00041	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 239  : 
; 240  : 	if(chunk->isEmpty() || !chunk->isLoaded())

  00048	8b 75 e8	 mov	 esi, DWORD PTR _chunk$[ebp]
  0004b	8b ce		 mov	 ecx, esi
  0004d	8b 06		 mov	 eax, DWORD PTR [esi]
  0004f	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00052	ff d0		 call	 eax
  00054	84 c0		 test	 al, al
  00056	75 21		 jne	 SHORT $LN1@getBlock

; 65   : 	return loaded;

  00058	8a 46 05	 mov	 al, BYTE PTR [esi+5]

; 239  : 
; 240  : 	if(chunk->isEmpty() || !chunk->isLoaded())

  0005b	84 c0		 test	 al, al
  0005d	74 1a		 je	 SHORT $LN1@getBlock

; 245  : 	return chunk->getBlock(x & 0xf, y & 0xf, z & 0xf);

  0005f	8b 4d 08	 mov	 ecx, DWORD PTR _x$[ebp]
  00062	8b 06		 mov	 eax, DWORD PTR [esi]
  00064	83 e7 0f	 and	 edi, 15			; 0000000fH
  00067	57		 push	 edi
  00068	83 e3 0f	 and	 ebx, 15			; 0000000fH
  0006b	83 e1 0f	 and	 ecx, 15			; 0000000fH
  0006e	53		 push	 ebx
  0006f	51		 push	 ecx
  00070	8b ce		 mov	 ecx, esi
  00072	ff 10		 call	 DWORD PTR [eax]
  00074	0f b7 f8	 movzx	 edi, ax
  00077	eb 02		 jmp	 SHORT $LN6@getBlock
$LN1@getBlock:
  00079	33 ff		 xor	 edi, edi
$LN6@getBlock:
  0007b	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  00082	8b 75 ec	 mov	 esi, DWORD PTR _chunk$[ebp+4]
  00085	85 f6		 test	 esi, esi
  00087	74 25		 je	 SHORT $LN34@getBlock

; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  00089	83 cb ff	 or	 ebx, -1
  0008c	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  0008f	8b c3		 mov	 eax, ebx
  00091	f0 0f c1 01	 lock	  xadd	 DWORD PTR [ecx], eax
  00095	75 17		 jne	 SHORT $LN34@getBlock

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  00097	8b 06		 mov	 eax, DWORD PTR [esi]
  00099	8b ce		 mov	 ecx, esi
  0009b	ff 10		 call	 DWORD PTR [eax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  0009d	8d 56 08	 lea	 edx, DWORD PTR [esi+8]
  000a0	f0 0f c1 1a	 lock	  xadd	 DWORD PTR [edx], ebx
  000a4	4b		 dec	 ebx
  000a5	75 07		 jne	 SHORT $LN34@getBlock

; 128  : 			_Delete_this();

  000a7	8b 16		 mov	 edx, DWORD PTR [esi]
  000a9	8b ce		 mov	 ecx, esi
  000ab	ff 52 04	 call	 DWORD PTR [edx+4]
$LN34@getBlock:
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp

; 245  : 	return chunk->getBlock(x & 0xf, y & 0xf, z & 0xf);

  000ae	66 8b c7	 mov	 ax, di

; 246  : }

  000b1	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000b4	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000bb	59		 pop	 ecx
  000bc	5f		 pop	 edi
  000bd	5e		 pop	 esi
  000be	5b		 pop	 ebx
  000bf	8b e5		 mov	 esp, ebp
  000c1	5d		 pop	 ebp
  000c2	c2 0c 00	 ret	 12			; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?getBlock@World@@QAEGHHH@Z$0:
  00000	8d 4d e8	 lea	 ecx, DWORD PTR _chunk$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$shared_ptr@VChunkBase@@@std@@QAE@XZ ; std::shared_ptr<ChunkBase>::~shared_ptr<ChunkBase>
__ehhandler$?getBlock@World@@QAEGHHH@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a e0	 mov	 ecx, DWORD PTR [edx-32]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?getBlock@World@@QAEGHHH@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?getBlock@World@@QAEGHHH@Z ENDP				; World::getBlock
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
;	COMDAT ?setLoaded@ChunkBase@@QAEXXZ
_TEXT	SEGMENT
?setLoaded@ChunkBase@@QAEXXZ PROC			; ChunkBase::setLoaded, COMDAT
; _this$ = ecx

; 60   : 	loaded = true;

  00000	c6 41 05 01	 mov	 BYTE PTR [ecx+5], 1

; 61   : }

  00004	c3		 ret	 0
?setLoaded@ChunkBase@@QAEXXZ ENDP			; ChunkBase::setLoaded
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
;	COMDAT ?setUnloaded@ChunkBase@@QAEXXZ
_TEXT	SEGMENT
?setUnloaded@ChunkBase@@QAEXXZ PROC			; ChunkBase::setUnloaded, COMDAT
; _this$ = ecx

; 70   : 	unloaded = true;

  00000	c6 41 06 01	 mov	 BYTE PTR [ecx+6], 1

; 71   : }

  00004	c3		 ret	 0
?setUnloaded@ChunkBase@@QAEXXZ ENDP			; ChunkBase::setUnloaded
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
;	COMDAT ?addChunk@World@@QAE_NV?$shared_ptr@VChunkBase@@@std@@@Z
_TEXT	SEGMENT
tv622 = -20						; size = 4
$T2 = -20						; size = 4
$T3 = -16						; size = 4
$T4 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_chunk$ = 8						; size = 8
?addChunk@World@@QAE_NV?$shared_ptr@VChunkBase@@@std@@@Z PROC ; World::addChunk, COMDAT
; _this$ = ecx

; 278  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?addChunk@World@@QAE_NV?$shared_ptr@VChunkBase@@@std@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 279  : 	if(chunkMap.find(chunk->pos) != chunkMap.end())

  0002f	8b 5d 08	 mov	 ebx, DWORD PTR _chunk$[ebp]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree

; 44   : 		{	// construct with node pointer _Pnode

  00032	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp

; 279  : 	if(chunkMap.find(chunk->pos) != chunkMap.end())

  00035	83 c1 04	 add	 ecx, 4
  00038	83 c3 0c	 add	 ebx, 12			; 0000000cH
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree

; 1572 : 		return (iterator(_Lbound(_Keyval), this));

  0003b	53		 push	 ebx
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp

; 279  : 	if(chunkMap.find(chunk->pos) != chunkMap.end())

  0003c	89 4d ec	 mov	 DWORD PTR tv622[ebp], ecx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree

; 1572 : 		return (iterator(_Lbound(_Keyval), this));

  0003f	e8 00 00 00 00	 call	 ?_Lbound@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@2@ABVChunkPosition@@@Z ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Lbound

; 45   : 		this->_Adopt(_Plist);
; 46   : 		}
; 47   : 
; 48   : 	reference operator*() const
; 49   : 		{	// return designated value
; 50   : 		return (_Mytree::_Myval(_Ptr));
; 51   : 		}
; 52   : 
; 53   : 	pointer operator->() const
; 54   : 		{	// return pointer to class object
; 55   : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 56   : 		}
; 57   : 
; 58   : 	_Myiter& operator++()
; 59   : 		{	// preincrement
; 60   : 		if (_Mytree::_Isnil(_Ptr))
; 61   : 			;	// end() shouldn't be incremented, don't move
; 62   : 		else if (!_Mytree::_Isnil(_Mytree::_Right(_Ptr)))
; 63   : 			_Ptr = _Mytree::_Min(
; 64   : 				_Mytree::_Right(_Ptr));	// ==> smallest of right subtree
; 65   : 		else
; 66   : 			{	// climb looking for right subtree
; 67   : 			_Nodeptr _Pnode;
; 68   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 69   : 				&& _Ptr == _Mytree::_Right(_Pnode))
; 70   : 				_Ptr = _Pnode;	// ==> parent while right subtree
; 71   : 			_Ptr = _Pnode;	// ==> parent (head if end())
; 72   : 			}
; 73   : 		return (*this);
; 74   : 		}
; 75   : 
; 76   : 	_Myiter operator++(int)
; 77   : 		{	// postincrement
; 78   : 		_Myiter _Tmp = *this;
; 79   : 		++*this;
; 80   : 		return (_Tmp);
; 81   : 		}
; 82   : 
; 83   : 	_Myiter& operator--()
; 84   : 		{	// predecrement
; 85   : 		if (_Mytree::_Isnil(_Ptr))
; 86   : 			_Ptr = _Mytree::_Right(_Ptr);	// end() ==> rightmost
; 87   : 		else if (!_Mytree::_Isnil(_Mytree::_Left(_Ptr)))
; 88   : 			_Ptr = _Mytree::_Max(
; 89   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree
; 90   : 		else
; 91   : 			{	// climb looking for left subtree
; 92   : 			_Nodeptr _Pnode;
; 93   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 94   : 				&& _Ptr == _Mytree::_Left(_Pnode))
; 95   : 				_Ptr = _Pnode;	// ==> parent while left subtree
; 96   : 			if (_Mytree::_Isnil(_Ptr))
; 97   : 				;	// begin() shouldn't be decremented, don't move
; 98   : 			else
; 99   : 				_Ptr = _Pnode;	// ==> parent if not head
; 100  : 			}
; 101  : 		return (*this);
; 102  : 		}
; 103  : 
; 104  : 	_Myiter operator--(int)
; 105  : 		{	// postdecrement
; 106  : 		_Myiter _Tmp = *this;
; 107  : 		--*this;
; 108  : 		return (_Tmp);
; 109  : 		}
; 110  : 
; 111  : 	bool operator==(const _Myiter& _Right) const
; 112  : 		{	// test for iterator equality
; 113  : 		return (_Ptr == _Right._Ptr);
; 114  : 		}
; 115  : 
; 116  : 	bool operator!=(const _Myiter& _Right) const
; 117  : 		{	// test for iterator inequality
; 118  : 		return (!(*this == _Right));
; 119  : 		}
; 120  : 
; 121  : 	_Nodeptr _Mynode() const
; 122  : 		{	// return node pointer
; 123  : 		return (_Ptr);
; 124  : 		}
; 125  : 
; 126  : 	_Nodeptr _Ptr;	// pointer to node
; 127  : 	};
; 128  : 
; 129  : 	// TEMPLATE CLASS _Tree_unchecked_iterator
; 130  : template<class _Mytree>
; 131  : 	class _Tree_unchecked_iterator
; 132  : 		: public _Tree_unchecked_const_iterator<_Mytree>
; 133  : 	{	// unchecked iterator for mutable tree
; 134  : public:
; 135  : 	typedef _Tree_unchecked_iterator<_Mytree> _Myiter;
; 136  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Mybase;
; 137  : 	typedef bidirectional_iterator_tag iterator_category;
; 138  : 
; 139  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 140  : 	typedef typename _Mytree::value_type value_type;
; 141  : 	typedef typename _Mytree::difference_type difference_type;
; 142  : 	typedef typename _Mytree::pointer pointer;
; 143  : 	typedef typename _Mytree::reference reference;
; 144  : 
; 145  : 	_Tree_unchecked_iterator()
; 146  : 		{	// construct with null node
; 147  : 		}
; 148  : 
; 149  : 	_Tree_unchecked_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 150  : 		: _Mybase(_Pnode, _Plist)
; 151  : 		{	// construct with node pointer _Pnode
; 152  : 		}
; 153  : 
; 154  : 	reference operator*() const
; 155  : 		{	// return designated value
; 156  : 		return ((reference)**(_Mybase *)this);
; 157  : 		}
; 158  : 
; 159  : 	pointer operator->() const
; 160  : 		{	// return pointer to class object
; 161  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 162  : 		}
; 163  : 
; 164  : 	_Myiter& operator++()
; 165  : 		{	// preincrement
; 166  : 		++(*(_Mybase *)this);
; 167  : 		return (*this);
; 168  : 		}
; 169  : 
; 170  : 	_Myiter operator++(int)
; 171  : 		{	// postincrement
; 172  : 		_Myiter _Tmp = *this;
; 173  : 		++*this;
; 174  : 		return (_Tmp);
; 175  : 		}
; 176  : 
; 177  : 	_Myiter& operator--()
; 178  : 		{	// predecrement
; 179  : 		--(*(_Mybase *)this);
; 180  : 		return (*this);
; 181  : 		}
; 182  : 
; 183  : 	_Myiter operator--(int)
; 184  : 		{	// postdecrement
; 185  : 		_Myiter _Tmp = *this;
; 186  : 		--*this;
; 187  : 		return (_Tmp);
; 188  : 		}
; 189  : 	};
; 190  : 
; 191  : 	// TEMPLATE CLASS _Tree_const_iterator
; 192  : template<class _Mytree>
; 193  : 	class _Tree_const_iterator
; 194  : 		: public _Tree_unchecked_const_iterator<_Mytree, _Iterator_base>
; 195  : 	{	// iterator for nonmutable tree
; 196  : public:
; 197  : 	typedef _Tree_const_iterator<_Mytree> _Myiter;
; 198  : 	typedef _Tree_unchecked_const_iterator<_Mytree, _Iterator_base> _Mybase;
; 199  : 	typedef bidirectional_iterator_tag iterator_category;
; 200  : 
; 201  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 202  : 	typedef typename _Mytree::value_type value_type;
; 203  : 	typedef typename _Mytree::difference_type difference_type;
; 204  : 	typedef typename _Mytree::const_pointer pointer;
; 205  : 	typedef typename _Mytree::const_reference reference;
; 206  : 
; 207  : 	_Tree_const_iterator()
; 208  : 		: _Mybase()
; 209  : 		{	// construct with null node pointer
; 210  : 		}
; 211  : 
; 212  : 	_Tree_const_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 213  : 		: _Mybase(_Pnode, _Plist)
; 214  : 		{	// construct with node pointer _Pnode
; 215  : 		}
; 216  : 
; 217  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Unchecked_type;
; 218  : 
; 219  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 220  : 		{	// reset from unchecked iterator
; 221  : 		this->_Ptr = _Right._Ptr;
; 222  : 		return (*this);
; 223  : 		}
; 224  : 
; 225  : 	_Unchecked_type _Unchecked() const
; 226  : 		{	// make an unchecked iterator
; 227  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 228  : 		}
; 229  : 
; 230  : 	reference operator*() const
; 231  : 		{	// return designated value
; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		if (this->_Getcont() == 0
; 234  : 			|| this->_Ptr == 0
; 235  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 236  : 			{	// report error
; 237  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 238  : 			_SCL_SECURE_OUT_OF_RANGE;
; 239  : 			}
; 240  : 
; 241  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 242  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 243  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 244  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 245  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 246  : 
; 247  : 		return (_Mytree::_Myval(this->_Ptr));
; 248  : 		}
; 249  : 
; 250  : 	pointer operator->() const
; 251  : 		{	// return pointer to class object
; 252  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 253  : 		}
; 254  : 
; 255  : 	_Myiter& operator++()
; 256  : 		{	// preincrement
; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);
; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);

  00044	3b c6		 cmp	 eax, esi

; 1550 : 					? end() : _Where);

  00046	74 29		 je	 SHORT $LN22@addChunk
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp

; 296  : 	if(cp1.x < cp2.x)

  00048	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  0004a	8b 50 10	 mov	 edx, DWORD PTR [eax+16]
  0004d	3b ca		 cmp	 ecx, edx
  0004f	7c 20		 jl	 SHORT $LN22@addChunk

; 297  : 	{
; 298  : 		return true;
; 299  : 	}
; 300  : 	else if(cp1.x == cp2.x)

  00051	75 19		 jne	 SHORT $LN150@addChunk

; 301  : 	{
; 302  : 		if(cp1.y < cp2.y)

  00053	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  00056	8b 50 14	 mov	 edx, DWORD PTR [eax+20]
  00059	3b ca		 cmp	 ecx, edx
  0005b	7c 14		 jl	 SHORT $LN22@addChunk

; 303  : 		{
; 304  : 			return true;
; 305  : 		}
; 306  : 		else if(cp1.y == cp2.y)

  0005d	75 0d		 jne	 SHORT $LN150@addChunk

; 307  : 		{
; 308  : 			return cp1.z < cp2.z;

  0005f	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]
  00062	3b 48 18	 cmp	 ecx, DWORD PTR [eax+24]
  00065	0f 9c c1	 setl	 cl
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree

; 1550 : 					? end() : _Where);

  00068	84 c9		 test	 cl, cl
  0006a	75 05		 jne	 SHORT $LN22@addChunk
$LN150@addChunk:
  0006c	89 45 f0	 mov	 DWORD PTR $T4[ebp], eax
  0006f	eb 03		 jmp	 SHORT $LN155@addChunk
$LN22@addChunk:

; 44   : 		{	// construct with node pointer _Pnode

  00071	89 75 f0	 mov	 DWORD PTR $T3[ebp], esi
$LN155@addChunk:

; 1550 : 					? end() : _Where);

  00074	8d 45 f0	 lea	 eax, DWORD PTR $T3[ebp]

; 45   : 		this->_Adopt(_Plist);
; 46   : 		}
; 47   : 
; 48   : 	reference operator*() const
; 49   : 		{	// return designated value
; 50   : 		return (_Mytree::_Myval(_Ptr));
; 51   : 		}
; 52   : 
; 53   : 	pointer operator->() const
; 54   : 		{	// return pointer to class object
; 55   : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 56   : 		}
; 57   : 
; 58   : 	_Myiter& operator++()
; 59   : 		{	// preincrement
; 60   : 		if (_Mytree::_Isnil(_Ptr))
; 61   : 			;	// end() shouldn't be incremented, don't move
; 62   : 		else if (!_Mytree::_Isnil(_Mytree::_Right(_Ptr)))
; 63   : 			_Ptr = _Mytree::_Min(
; 64   : 				_Mytree::_Right(_Ptr));	// ==> smallest of right subtree
; 65   : 		else
; 66   : 			{	// climb looking for right subtree
; 67   : 			_Nodeptr _Pnode;
; 68   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 69   : 				&& _Ptr == _Mytree::_Right(_Pnode))
; 70   : 				_Ptr = _Pnode;	// ==> parent while right subtree
; 71   : 			_Ptr = _Pnode;	// ==> parent (head if end())
; 72   : 			}
; 73   : 		return (*this);
; 74   : 		}
; 75   : 
; 76   : 	_Myiter operator++(int)
; 77   : 		{	// postincrement
; 78   : 		_Myiter _Tmp = *this;
; 79   : 		++*this;
; 80   : 		return (_Tmp);
; 81   : 		}
; 82   : 
; 83   : 	_Myiter& operator--()
; 84   : 		{	// predecrement
; 85   : 		if (_Mytree::_Isnil(_Ptr))
; 86   : 			_Ptr = _Mytree::_Right(_Ptr);	// end() ==> rightmost
; 87   : 		else if (!_Mytree::_Isnil(_Mytree::_Left(_Ptr)))
; 88   : 			_Ptr = _Mytree::_Max(
; 89   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree
; 90   : 		else
; 91   : 			{	// climb looking for left subtree
; 92   : 			_Nodeptr _Pnode;
; 93   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 94   : 				&& _Ptr == _Mytree::_Left(_Pnode))
; 95   : 				_Ptr = _Pnode;	// ==> parent while left subtree
; 96   : 			if (_Mytree::_Isnil(_Ptr))
; 97   : 				;	// begin() shouldn't be decremented, don't move
; 98   : 			else
; 99   : 				_Ptr = _Pnode;	// ==> parent if not head
; 100  : 			}
; 101  : 		return (*this);
; 102  : 		}
; 103  : 
; 104  : 	_Myiter operator--(int)
; 105  : 		{	// postdecrement
; 106  : 		_Myiter _Tmp = *this;
; 107  : 		--*this;
; 108  : 		return (_Tmp);
; 109  : 		}
; 110  : 
; 111  : 	bool operator==(const _Myiter& _Right) const
; 112  : 		{	// test for iterator equality
; 113  : 		return (_Ptr == _Right._Ptr);
; 114  : 		}
; 115  : 
; 116  : 	bool operator!=(const _Myiter& _Right) const
; 117  : 		{	// test for iterator inequality
; 118  : 		return (!(*this == _Right));
; 119  : 		}
; 120  : 
; 121  : 	_Nodeptr _Mynode() const
; 122  : 		{	// return node pointer
; 123  : 		return (_Ptr);
; 124  : 		}
; 125  : 
; 126  : 	_Nodeptr _Ptr;	// pointer to node
; 127  : 	};
; 128  : 
; 129  : 	// TEMPLATE CLASS _Tree_unchecked_iterator
; 130  : template<class _Mytree>
; 131  : 	class _Tree_unchecked_iterator
; 132  : 		: public _Tree_unchecked_const_iterator<_Mytree>
; 133  : 	{	// unchecked iterator for mutable tree
; 134  : public:
; 135  : 	typedef _Tree_unchecked_iterator<_Mytree> _Myiter;
; 136  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Mybase;
; 137  : 	typedef bidirectional_iterator_tag iterator_category;
; 138  : 
; 139  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 140  : 	typedef typename _Mytree::value_type value_type;
; 141  : 	typedef typename _Mytree::difference_type difference_type;
; 142  : 	typedef typename _Mytree::pointer pointer;
; 143  : 	typedef typename _Mytree::reference reference;
; 144  : 
; 145  : 	_Tree_unchecked_iterator()
; 146  : 		{	// construct with null node
; 147  : 		}
; 148  : 
; 149  : 	_Tree_unchecked_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 150  : 		: _Mybase(_Pnode, _Plist)
; 151  : 		{	// construct with node pointer _Pnode
; 152  : 		}
; 153  : 
; 154  : 	reference operator*() const
; 155  : 		{	// return designated value
; 156  : 		return ((reference)**(_Mybase *)this);
; 157  : 		}
; 158  : 
; 159  : 	pointer operator->() const
; 160  : 		{	// return pointer to class object
; 161  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 162  : 		}
; 163  : 
; 164  : 	_Myiter& operator++()
; 165  : 		{	// preincrement
; 166  : 		++(*(_Mybase *)this);
; 167  : 		return (*this);
; 168  : 		}
; 169  : 
; 170  : 	_Myiter operator++(int)
; 171  : 		{	// postincrement
; 172  : 		_Myiter _Tmp = *this;
; 173  : 		++*this;
; 174  : 		return (_Tmp);
; 175  : 		}
; 176  : 
; 177  : 	_Myiter& operator--()
; 178  : 		{	// predecrement
; 179  : 		--(*(_Mybase *)this);
; 180  : 		return (*this);
; 181  : 		}
; 182  : 
; 183  : 	_Myiter operator--(int)
; 184  : 		{	// postdecrement
; 185  : 		_Myiter _Tmp = *this;
; 186  : 		--*this;
; 187  : 		return (_Tmp);
; 188  : 		}
; 189  : 	};
; 190  : 
; 191  : 	// TEMPLATE CLASS _Tree_const_iterator
; 192  : template<class _Mytree>
; 193  : 	class _Tree_const_iterator
; 194  : 		: public _Tree_unchecked_const_iterator<_Mytree, _Iterator_base>
; 195  : 	{	// iterator for nonmutable tree
; 196  : public:
; 197  : 	typedef _Tree_const_iterator<_Mytree> _Myiter;
; 198  : 	typedef _Tree_unchecked_const_iterator<_Mytree, _Iterator_base> _Mybase;
; 199  : 	typedef bidirectional_iterator_tag iterator_category;
; 200  : 
; 201  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 202  : 	typedef typename _Mytree::value_type value_type;
; 203  : 	typedef typename _Mytree::difference_type difference_type;
; 204  : 	typedef typename _Mytree::const_pointer pointer;
; 205  : 	typedef typename _Mytree::const_reference reference;
; 206  : 
; 207  : 	_Tree_const_iterator()
; 208  : 		: _Mybase()
; 209  : 		{	// construct with null node pointer
; 210  : 		}
; 211  : 
; 212  : 	_Tree_const_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 213  : 		: _Mybase(_Pnode, _Plist)
; 214  : 		{	// construct with node pointer _Pnode
; 215  : 		}
; 216  : 
; 217  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Unchecked_type;
; 218  : 
; 219  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 220  : 		{	// reset from unchecked iterator
; 221  : 		this->_Ptr = _Right._Ptr;
; 222  : 		return (*this);
; 223  : 		}
; 224  : 
; 225  : 	_Unchecked_type _Unchecked() const
; 226  : 		{	// make an unchecked iterator
; 227  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 228  : 		}
; 229  : 
; 230  : 	reference operator*() const
; 231  : 		{	// return designated value
; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		if (this->_Getcont() == 0
; 234  : 			|| this->_Ptr == 0
; 235  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 236  : 			{	// report error
; 237  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 238  : 			_SCL_SECURE_OUT_OF_RANGE;
; 239  : 			}
; 240  : 
; 241  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 242  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 243  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 244  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 245  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 246  : 
; 247  : 		return (_Mytree::_Myval(this->_Ptr));
; 248  : 		}
; 249  : 
; 250  : 	pointer operator->() const
; 251  : 		{	// return pointer to class object
; 252  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 253  : 		}
; 254  : 
; 255  : 	_Myiter& operator++()
; 256  : 		{	// preincrement
; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);
; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);

  00077	83 cf ff	 or	 edi, -1
  0007a	39 30		 cmp	 DWORD PTR [eax], esi
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp

; 279  : 	if(chunkMap.find(chunk->pos) != chunkMap.end())

  0007c	74 04		 je	 SHORT $LN1@addChunk
  0007e	32 db		 xor	 bl, bl
  00080	eb 56		 jmp	 SHORT $LN5@addChunk
$LN1@addChunk:

; 280  : 	{
; 281  : 		return false;
; 282  : 	}
; 283  : 	
; 284  : 	chunkMap[chunk->pos] = chunk;

  00082	8b 4d ec	 mov	 ecx, DWORD PTR tv622[ebp]
  00085	53		 push	 ebx
  00086	e8 00 00 00 00	 call	 ??A?$map@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@@std@@QAEAAV?$shared_ptr@VChunkBase@@@1@ABVChunkPosition@@@Z ; std::map<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::operator[]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 357  : 		_Reset(_Other._Ptr, _Other._Rep);

  0008b	8b 5d 0c	 mov	 ebx, DWORD PTR _chunk$[ebp+4]
  0008e	8b 4d 08	 mov	 ecx, DWORD PTR _chunk$[ebp]
  00091	89 4d ec	 mov	 DWORD PTR $T2[ebp], ecx

; 358  : 		}
; 359  : 
; 360  : 	template<class _Ty2>
; 361  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, bool _Throw)
; 362  : 		{	// release resource and take ownership from weak_ptr _Other._Ptr
; 363  : 		_Reset(_Other._Ptr, _Other._Rep, _Throw);
; 364  : 		}
; 365  : 
; 366  : 	template<class _Ty2>
; 367  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Static_tag&)
; 368  : 		{	// release resource and take ownership of _Other._Ptr
; 369  : 		_Reset(static_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 370  : 		}
; 371  : 
; 372  : 	template<class _Ty2>
; 373  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Const_tag&)
; 374  : 		{	// release resource and take ownership of _Other._Ptr
; 375  : 		_Reset(const_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 376  : 		}
; 377  : 
; 378  : 	template<class _Ty2>
; 379  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Dynamic_tag&)
; 380  : 		{	// release resource and take ownership of _Other._Ptr
; 381  : 		_Elem *_Ptr = dynamic_cast<_Elem *>(_Other._Ptr);
; 382  : 		if (_Ptr)
; 383  : 			_Reset(_Ptr, _Other._Rep);
; 384  : 		else
; 385  : 			_Reset();
; 386  : 		}
; 387  : 
; 388  : 	template<class _Ty2>
; 389  : 		void _Reset(auto_ptr<_Ty2>&& _Other)
; 390  : 		{	// release resource and take _Other.get()
; 391  : 		_Ty2 *_Px = _Other.get();
; 392  : 		_Reset0(_Px, new _Ref_count<_Elem>(_Px));
; 393  : 		_Other.release();
; 394  : 		_Enable_shared(_Px, _Rep);
; 395  : 		}
; 396  : 
; 397  :  #if _HAS_CPP0X
; 398  : 	template<class _Ty2>
; 399  : 		void _Reset(_Ty *_Ptr, const _Ptr_base<_Ty2>& _Other)
; 400  : 		{	// release resource and alias _Ptr with _Other_rep
; 401  : 		_Reset(_Ptr, _Other._Rep);
; 402  : 		}
; 403  :  #endif /* _HAS_CPP0X */
; 404  : 
; 405  : 	void _Reset(_Ty *_Other_ptr, _Ref_count_base *_Other_rep)
; 406  : 		{	// release resource and take _Other_ptr through _Other_rep
; 407  : 		if (_Other_rep)

  00094	85 db		 test	 ebx, ebx
  00096	74 0f		 je	 SHORT $LN105@addChunk

; 108  : 		_MT_INCR(_Ignored, _Uses);

  00098	8d 4b 04	 lea	 ecx, DWORD PTR [ebx+4]
  0009b	ba 01 00 00 00	 mov	 edx, 1
  000a0	f0 0f c1 11	 lock	  xadd	 DWORD PTR [ecx], edx
  000a4	8b 4d ec	 mov	 ecx, DWORD PTR $T2[ebp]
$LN105@addChunk:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility

; 48   : 	_Left = _Move(_Right);

  000a7	8b 70 04	 mov	 esi, DWORD PTR [eax+4]

; 49   : 	_Right = _Move(_Tmp);

  000aa	89 58 04	 mov	 DWORD PTR [eax+4], ebx
  000ad	89 08		 mov	 DWORD PTR [eax], ecx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  000af	85 f6		 test	 esi, esi
  000b1	74 23		 je	 SHORT $LN136@addChunk

; 109  : 		}
; 110  : 
; 111  : 	void _Incwref()
; 112  : 		{	// increment weak reference count
; 113  : 		_MT_INCR(_Ignored, _Weaks);
; 114  : 		}
; 115  : 
; 116  : 	void _Decref()
; 117  : 		{	// decrement use count
; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  000b3	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  000b6	8b cf		 mov	 ecx, edi
  000b8	f0 0f c1 08	 lock	  xadd	 DWORD PTR [eax], ecx
  000bc	75 18		 jne	 SHORT $LN136@addChunk

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  000be	8b 06		 mov	 eax, DWORD PTR [esi]
  000c0	8b ce		 mov	 ecx, esi
  000c2	ff 10		 call	 DWORD PTR [eax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  000c4	8d 46 08	 lea	 eax, DWORD PTR [esi+8]
  000c7	8b d7		 mov	 edx, edi
  000c9	f0 0f c1 10	 lock	  xadd	 DWORD PTR [eax], edx
  000cd	75 07		 jne	 SHORT $LN136@addChunk

; 128  : 			_Delete_this();

  000cf	8b 06		 mov	 eax, DWORD PTR [esi]
  000d1	8b ce		 mov	 ecx, esi
  000d3	ff 50 04	 call	 DWORD PTR [eax+4]
$LN136@addChunk:
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp

; 286  : 	return true;

  000d6	b3 01		 mov	 bl, 1
$LN5@addChunk:
  000d8	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  000df	8b 75 0c	 mov	 esi, DWORD PTR _chunk$[ebp+4]
  000e2	85 f6		 test	 esi, esi
  000e4	74 22		 je	 SHORT $LN153@addChunk

; 109  : 		}
; 110  : 
; 111  : 	void _Incwref()
; 112  : 		{	// increment weak reference count
; 113  : 		_MT_INCR(_Ignored, _Weaks);
; 114  : 		}
; 115  : 
; 116  : 	void _Decref()
; 117  : 		{	// decrement use count
; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  000e6	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  000e9	8b cf		 mov	 ecx, edi
  000eb	f0 0f c1 08	 lock	  xadd	 DWORD PTR [eax], ecx
  000ef	75 17		 jne	 SHORT $LN153@addChunk

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  000f1	8b 06		 mov	 eax, DWORD PTR [esi]
  000f3	8b ce		 mov	 ecx, esi
  000f5	ff 10		 call	 DWORD PTR [eax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  000f7	8d 56 08	 lea	 edx, DWORD PTR [esi+8]
  000fa	f0 0f c1 3a	 lock	  xadd	 DWORD PTR [edx], edi
  000fe	4f		 dec	 edi
  000ff	75 07		 jne	 SHORT $LN153@addChunk

; 128  : 			_Delete_this();

  00101	8b 16		 mov	 edx, DWORD PTR [esi]
  00103	8b ce		 mov	 ecx, esi
  00105	ff 52 04	 call	 DWORD PTR [edx+4]
$LN153@addChunk:
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp

; 286  : 	return true;

  00108	8a c3		 mov	 al, bl

; 287  : }

  0010a	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0010d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00114	59		 pop	 ecx
  00115	5f		 pop	 edi
  00116	5e		 pop	 esi
  00117	5b		 pop	 ebx
  00118	8b e5		 mov	 esp, ebp
  0011a	5d		 pop	 ebp
  0011b	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?addChunk@World@@QAE_NV?$shared_ptr@VChunkBase@@@std@@@Z$0:
  00000	8d 4d 08	 lea	 ecx, DWORD PTR _chunk$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$shared_ptr@VChunkBase@@@std@@QAE@XZ ; std::shared_ptr<ChunkBase>::~shared_ptr<ChunkBase>
__ehhandler$?addChunk@World@@QAE_NV?$shared_ptr@VChunkBase@@@std@@@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a e4	 mov	 ecx, DWORD PTR [edx-28]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?addChunk@World@@QAE_NV?$shared_ptr@VChunkBase@@@std@@@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?addChunk@World@@QAE_NV?$shared_ptr@VChunkBase@@@std@@@Z ENDP ; World::addChunk
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
;	COMDAT ?removeChunk@World@@QAEXVChunkPosition@@@Z
_TEXT	SEGMENT
$T1 = -12						; size = 8
$T2 = -8						; size = 4
_cp$ = 8						; size = 12
?removeChunk@World@@QAEXVChunkPosition@@@Z PROC		; World::removeChunk, COMDAT
; _this$ = ecx

; 290  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree

; 1592 : 		return (_Eqrange(_Keyval));

  00006	8d 45 08	 lea	 eax, DWORD PTR _cp$[ebp]
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp

; 290  : {

  00009	56		 push	 esi
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree

; 1592 : 		return (_Eqrange(_Keyval));

  0000a	50		 push	 eax
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp

; 291  : 	chunkMap.erase(cp);

  0000b	8d 71 04	 lea	 esi, DWORD PTR [ecx+4]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree

; 1592 : 		return (_Eqrange(_Keyval));

  0000e	8d 45 f4	 lea	 eax, DWORD PTR $T1[ebp]
  00011	50		 push	 eax
  00012	8b ce		 mov	 ecx, esi
  00014	e8 00 00 00 00	 call	 ?_Eqrange@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@V12@@2@ABVChunkPosition@@@Z ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Eqrange

; 1527 : 		erase(_Where.first, _Where.second);

  00019	ff 70 04	 push	 DWORD PTR [eax+4]
  0001c	8b ce		 mov	 ecx, esi
  0001e	ff 30		 push	 DWORD PTR [eax]
  00020	8d 45 f8	 lea	 eax, DWORD PTR $T2[ebp]
  00023	50		 push	 eax
  00024	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::erase
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp

; 292  : }

  00029	5e		 pop	 esi
  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c2 0c 00	 ret	 12			; 0000000cH
?removeChunk@World@@QAEXVChunkPosition@@@Z ENDP		; World::removeChunk
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\queue
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
;	COMDAT ??0World@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0World@@QAE@XZ PROC					; World::World, COMDAT
; _this$ = ecx

; 196  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0World@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	57		 push	 edi
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	8b f1		 mov	 esi, ecx
  00027	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 63   : 	return (_Check_C_return(_Mtx_init(_Mtx, _Type)));

  0002a	6a 02		 push	 2
  0002c	56		 push	 esi
  0002d	e8 00 00 00 00	 call	 __Mtx_init
  00032	83 c4 08	 add	 esp, 8

; 32   : 	if (_Res != _Thrd_success)

  00035	85 c0		 test	 eax, eax
  00037	74 09		 je	 SHORT $LN15@World

; 33   : 		_Throw_C_error(_Res);

  00039	50		 push	 eax
  0003a	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
  0003f	83 c4 04	 add	 esp, 4
$LN15@World:
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp

; 196  : {

  00042	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree

; 573  : 		this->_Myhead = 0;

  00049	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 574  : 		this->_Mysize = 0;

  00050	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0

; 575  : 		}
; 576  : 
; 577  : 	enum _Redbl
; 578  : 		{	// colors for link to parent
; 579  : 		_Red, _Black};
; 580  : 
; 581  : 	static char& _Color(_Nodeptr _Pnode)
; 582  : 		{	// return reference to color in node
; 583  : 		return ((char&)_Pnode->_Color);
; 584  : 		}
; 585  : 
; 586  : 	static char& _Isnil(_Nodeptr _Pnode)
; 587  : 		{	// return reference to nil flag in node
; 588  : 		return ((char&)_Pnode->_Isnil);
; 589  : 		}
; 590  : 
; 591  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 592  : 		{	// return reference to left pointer in node
; 593  : 		return ((_Nodepref)_Pnode->_Left);
; 594  : 		}
; 595  : 
; 596  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 597  : 		{	// return reference to parent pointer in node
; 598  : 		return ((_Nodepref)_Pnode->_Parent);
; 599  : 		}
; 600  : 
; 601  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 602  : 		{	// return reference to right pointer in node
; 603  : 		return ((_Nodepref)_Pnode->_Right);
; 604  : 		}
; 605  : 
; 606  : 	static reference _Myval(_Nodeptr _Pnode)
; 607  : 		{	// return reference to value in node
; 608  : 		return ((reference)_Pnode->_Myval);
; 609  : 		}
; 610  : 
; 611  : 	static _Nodeptr _Max(_Nodeptr _Pnode)
; 612  : 		{	// return rightmost node in subtree at _Pnode
; 613  : 		while (!_Isnil(_Right(_Pnode)))
; 614  : 			_Pnode = _Right(_Pnode);
; 615  : 		return (_Pnode);
; 616  : 		}
; 617  : 
; 618  : 	static _Nodeptr _Min(_Nodeptr _Pnode)
; 619  : 		{	// return leftmost node in subtree at _Pnode
; 620  : 		while (!_Isnil(_Left(_Pnode)))
; 621  : 			_Pnode = _Left(_Pnode);
; 622  : 		return (_Pnode);
; 623  : 		}
; 624  : 
; 625  : 	_Nodeptr _Myhead;	// pointer to head node
; 626  : 	size_type _Mysize;	// number of elements
; 627  : 	};
; 628  : 
; 629  : 		// TEMPLATE CLASS _Tree_alloc
; 630  : template<bool _Al_has_storage,
; 631  : 	class _Alloc_types>
; 632  : 	class _Tree_alloc
; 633  : 		: public _Tree_val<typename _Alloc_types::_Val_types>
; 634  : 	{	// base class for tree to hold allocator with storage
; 635  : public:
; 636  : 	typedef _Tree_alloc<_Al_has_storage, _Alloc_types> _Myt;
; 637  : 	typedef _Tree_val<typename _Alloc_types::_Val_types> _Mybase;
; 638  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 639  : 	typedef typename _Alloc_types::_Alnod_type _Alty;
; 640  : 	typedef typename _Alloc_types::_Node _Node;
; 641  : 	typedef typename _Alloc_types::_Nodeptr _Nodeptr;
; 642  : 
; 643  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 644  : 	_Tree_alloc(const _Alloc& _Al = _Alloc())
; 645  : 		: _Alnod(_Al)
; 646  : 		{	// construct head node, allocator from _Al
; 647  : 		this->_Myhead = _Buyheadnode();
; 648  : 		}
; 649  : 
; 650  : 	~_Tree_alloc() _NOEXCEPT
; 651  : 		{	// destroy head node
; 652  : 		_Freeheadnode(this->_Myhead);
; 653  : 		}
; 654  : 
; 655  : 	void _Change_alloc(const _Alty& _Al)
; 656  : 		{	// replace old allocator
; 657  : 		_Alnod = _Al;
; 658  : 		}
; 659  : 
; 660  : 	void _Swap_alloc(_Myt& _Right)
; 661  : 		{	// swap allocators
; 662  : 		_Swap_adl(_Alnod, _Right._Alnod);
; 663  : 		}
; 664  : 
; 665  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 666  : 	_Tree_alloc(const _Alloc& _Al = _Alloc())
; 667  : 		: _Alnod(_Al)
; 668  : 		{	// construct allocators from _Al
; 669  : 		this->_Myhead = _Buyheadnode();
; 670  : 		_TRY_BEGIN
; 671  : 		_Alloc_proxy();
; 672  : 		_CATCH_ALL
; 673  : 		_Freeheadnode(this->_Myhead);
; 674  : 		_RERAISE;
; 675  : 		_CATCH_END
; 676  : 		}
; 677  : 
; 678  : 	~_Tree_alloc() _NOEXCEPT
; 679  : 		{	// destroy proxy
; 680  : 		_Freeheadnode(this->_Myhead);
; 681  : 		_Free_proxy();
; 682  : 		}
; 683  : 
; 684  : 	void _Change_alloc(const _Alty& _Al)
; 685  : 		{	// replace old allocator
; 686  : 		_Free_proxy();
; 687  : 		_Alnod = _Al;
; 688  : 		_Alloc_proxy();
; 689  : 		}
; 690  : 
; 691  : 	void _Swap_alloc(_Myt& _Right)
; 692  : 		{	// swap allocators
; 693  : 		_Swap_adl(_Alnod, _Right._Alnod);
; 694  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 695  : 		}
; 696  : 
; 697  : 	void _Alloc_proxy()
; 698  : 		{	// construct proxy from _Alnod
; 699  : 		typename _Alty::template rebind<_Container_proxy>::other
; 700  : 			_Alproxy(_Alnod);
; 701  : 		this->_Myproxy = _Alproxy.allocate(1);
; 702  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 703  : 		this->_Myproxy->_Mycont = this;
; 704  : 		}
; 705  : 
; 706  : 	void _Free_proxy()
; 707  : 		{	// destroy proxy
; 708  : 		typename _Alty::template rebind<_Container_proxy>::other
; 709  : 			_Alproxy(_Alnod);
; 710  : 		this->_Orphan_all();
; 711  : 		_Alproxy.destroy(this->_Myproxy);
; 712  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 713  : 		this->_Myproxy = 0;
; 714  : 		}
; 715  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 716  : 
; 717  : 	_Nodeptr _Buyheadnode()
; 718  : 		{	// get head node using current allocator
; 719  : 		_Nodeptr _Pnode = _Alnod.allocate(1);
; 720  : 
; 721  : 		_TRY_BEGIN
; 722  : 		_Alnod.construct(
; 723  : 			_STD addressof(this->_Left(_Pnode)), _Pnode);
; 724  : 		_Alnod.construct(
; 725  : 			_STD addressof(this->_Parent(_Pnode)), _Pnode);
; 726  : 		_Alnod.construct(
; 727  : 			_STD addressof(this->_Right(_Pnode)), _Pnode);
; 728  : 		_CATCH_ALL
; 729  : 		_Alnod.deallocate(_Pnode, 1);
; 730  : 		_RERAISE;
; 731  : 		_CATCH_END
; 732  : 
; 733  : 		this->_Color(_Pnode) = this->_Black;
; 734  : 		this->_Isnil(_Pnode) = true;
; 735  : 		return (_Pnode);
; 736  : 		}
; 737  : 
; 738  : 	void _Freeheadnode(_Nodeptr _Pnode)
; 739  : 		{	// free head node using current allocator
; 740  : 		_Alnod.destroy(
; 741  : 			_STD addressof(this->_Left(_Pnode)));
; 742  : 		_Alnod.destroy(
; 743  : 			_STD addressof(this->_Parent(_Pnode)));
; 744  : 		_Alnod.destroy(
; 745  : 			_STD addressof(this->_Right(_Pnode)));
; 746  : 		_Alnod.deallocate(_Pnode, 1);
; 747  : 		}
; 748  : 
; 749  : 	_Alty& _Getal()
; 750  : 		{	// get reference to allocator
; 751  : 		return (_Alnod);
; 752  : 		}
; 753  : 
; 754  : 	const _Alty& _Getal() const
; 755  : 		{	// get reference to allocator
; 756  : 		return (_Alnod);
; 757  : 		}
; 758  : 
; 759  : 	_Alty _Alnod;	// allocator object for stored elements
; 760  : 	};
; 761  : 
; 762  : 		// TEMPLATE CLASS _Tree_alloc
; 763  : template<class _Alloc_types>
; 764  : 	class _Tree_alloc<false, _Alloc_types>
; 765  : 		: public _Tree_val<typename _Alloc_types::_Val_types>
; 766  : 	{	// base class for tree to hold allocator with no storage
; 767  : public:
; 768  : 	typedef _Tree_alloc<false, _Alloc_types> _Myt;
; 769  : 	typedef _Tree_val<typename _Alloc_types::_Val_types> _Mybase;
; 770  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 771  : 	typedef typename _Alloc_types::_Alnod_type _Alty;
; 772  : 	typedef typename _Alloc_types::_Node _Node;
; 773  : 	typedef typename _Alloc_types::_Nodeptr _Nodeptr;
; 774  : 
; 775  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 776  : 	_Tree_alloc(const _Alloc& = _Alloc())
; 777  : 		{	// construct head node, allocator from _Al
; 778  : 		this->_Myhead = _Buyheadnode();

  00057	e8 00 00 00 00	 call	 ?_Buyheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@2@XZ ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::_Buyheadnode
  0005c	89 46 04	 mov	 DWORD PTR [esi+4], eax
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp

; 196  : {

  0005f	8d 46 0c	 lea	 eax, DWORD PTR [esi+12]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 63   : 	return (_Check_C_return(_Mtx_init(_Mtx, _Type)));

  00062	6a 02		 push	 2
  00064	50		 push	 eax
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp

; 196  : {

  00065	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 63   : 	return (_Check_C_return(_Mtx_init(_Mtx, _Type)));

  00069	e8 00 00 00 00	 call	 __Mtx_init
  0006e	83 c4 08	 add	 esp, 8

; 32   : 	if (_Res != _Thrd_success)

  00071	85 c0		 test	 eax, eax
  00073	74 09		 je	 SHORT $LN42@World

; 33   : 		_Throw_C_error(_Res);

  00075	50		 push	 eax
  00076	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
  0007b	83 c4 04	 add	 esp, 4
$LN42@World:
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp

; 196  : {

  0007e	8d 7e 10	 lea	 edi, DWORD PTR [esi+16]
  00081	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  00085	6a 08		 push	 8
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility

; 79   : 		{	// construct childless container

  00087	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 778  : 		_Map = _Mapptr();

  0008d	c7 47 04 00 00
	00 00		 mov	 DWORD PTR [edi+4], 0

; 779  : 		_Mapsize = 0;

  00094	c7 47 08 00 00
	00 00		 mov	 DWORD PTR [edi+8], 0

; 780  : 		_Myoff = 0;

  0009b	c7 47 0c 00 00
	00 00		 mov	 DWORD PTR [edi+12], 0

; 781  : 		_Mysize = 0;

  000a2	c7 47 10 00 00
	00 00		 mov	 DWORD PTR [edi+16], 0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  000a9	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  000ae	83 c4 04	 add	 esp, 4
  000b1	85 c0		 test	 eax, eax
  000b3	75 05		 jne	 SHORT $LN66@World

; 29   : 		_Xbad_alloc();	// report no memory

  000b5	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN157@World:
$LN66@World:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 900  : 		this->_Myproxy = _Alproxy.allocate(1);

  000ba	89 07		 mov	 DWORD PTR [edi], eax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 617  : _VARIADIC_EXPAND_0X(_ALLOC_MEMBER_CONSTRUCT, , , , )

  000bc	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  000c2	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 902  : 		this->_Myproxy->_Mycont = this;

  000c9	8b 07		 mov	 eax, DWORD PTR [edi]
  000cb	89 38		 mov	 DWORD PTR [eax], edi
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp

; 196  : {

  000cd	8d 46 24	 lea	 eax, DWORD PTR [esi+36]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 63   : 	return (_Check_C_return(_Mtx_init(_Mtx, _Type)));

  000d0	6a 02		 push	 2
  000d2	50		 push	 eax
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp

; 196  : {

  000d3	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 63   : 	return (_Check_C_return(_Mtx_init(_Mtx, _Type)));

  000d7	e8 00 00 00 00	 call	 __Mtx_init
  000dc	83 c4 08	 add	 esp, 8

; 32   : 	if (_Res != _Thrd_success)

  000df	85 c0		 test	 eax, eax
  000e1	74 09		 je	 SHORT $LN102@World

; 33   : 		_Throw_C_error(_Res);

  000e3	50		 push	 eax
  000e4	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
  000e9	83 c4 04	 add	 esp, 4
$LN102@World:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\queue

; 30   : 		{	// construct with empty container

  000ec	8d 7e 28	 lea	 edi, DWORD PTR [esi+40]
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp

; 196  : {

  000ef	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  000f3	6a 08		 push	 8
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility

; 79   : 		{	// construct childless container

  000f5	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 778  : 		_Map = _Mapptr();

  000fb	c7 47 04 00 00
	00 00		 mov	 DWORD PTR [edi+4], 0

; 779  : 		_Mapsize = 0;

  00102	c7 47 08 00 00
	00 00		 mov	 DWORD PTR [edi+8], 0

; 780  : 		_Myoff = 0;

  00109	c7 47 0c 00 00
	00 00		 mov	 DWORD PTR [edi+12], 0

; 781  : 		_Mysize = 0;

  00110	c7 47 10 00 00
	00 00		 mov	 DWORD PTR [edi+16], 0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  00117	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0011c	83 c4 04	 add	 esp, 4
  0011f	85 c0		 test	 eax, eax
  00121	75 05		 jne	 SHORT $LN126@World

; 29   : 		_Xbad_alloc();	// report no memory

  00123	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN158@World:
$LN126@World:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 900  : 		this->_Myproxy = _Alproxy.allocate(1);

  00128	89 07		 mov	 DWORD PTR [edi], eax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 617  : _VARIADIC_EXPAND_0X(_ALLOC_MEMBER_CONSTRUCT, , , , )

  0012a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00130	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 902  : 		this->_Myproxy->_Mycont = this;

  00137	8b 07		 mov	 eax, DWORD PTR [edi]
  00139	89 38		 mov	 DWORD PTR [eax], edi
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp

; 198  : }

  0013b	8b c6		 mov	 eax, esi
  0013d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00140	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00147	59		 pop	 ecx
  00148	5f		 pop	 edi
  00149	5e		 pop	 esi
  0014a	8b e5		 mov	 esp, ebp
  0014c	5d		 pop	 ebp
  0014d	c3		 ret	 0
$LN156@World:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0World@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1mutex@std@@QAE@XZ
__unwindfunclet$??0World@@QAE@XZ$1:
  00008	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000b	83 c1 04	 add	 ecx, 4
  0000e	e9 00 00 00 00	 jmp	 ??1?$map@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@@std@@QAE@XZ
__unwindfunclet$??0World@@QAE@XZ$2:
  00013	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00019	e9 00 00 00 00	 jmp	 ??1mutex@std@@QAE@XZ
__unwindfunclet$??0World@@QAE@XZ$3:
  0001e	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00021	83 c1 10	 add	 ecx, 16			; 00000010H
  00024	e9 00 00 00 00	 jmp	 ??1?$queue@V?$shared_ptr@VChunkBase@@@std@@V?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@2@@std@@QAE@XZ
__unwindfunclet$??0World@@QAE@XZ$4:
  00029	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0002c	83 c1 24	 add	 ecx, 36			; 00000024H
  0002f	e9 00 00 00 00	 jmp	 ??1mutex@std@@QAE@XZ
__ehhandler$??0World@@QAE@XZ:
  00034	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00038	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0003b	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  0003e	33 c8		 xor	 ecx, eax
  00040	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00045	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0World@@QAE@XZ
  0004a	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0World@@QAE@XZ ENDP					; World::World
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\mutex
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\mutex
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\mutex
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\mutex
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\mutex
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\mutex
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
;	COMDAT ??1World@@QAE@XZ
_TEXT	SEGMENT
$T1 = -4						; size = 4
??1World@@QAE@XZ PROC					; World::~World, COMDAT
; _this$ = ecx

; 201  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	57		 push	 edi
  00006	8b f9		 mov	 edi, ecx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 1222 : 		_Tidy();

  00008	8d 4f 28	 lea	 ecx, DWORD PTR [edi+40]
  0000b	e8 00 00 00 00	 call	 ?_Tidy@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IAEXXZ ; std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::_Tidy
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 586  : 		::operator delete(_Ptr);

  00010	ff 77 28	 push	 DWORD PTR [edi+40]
  00013	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\mutex

; 33   : 		_Mtx_destroy(&_Mtx);

  00018	8d 47 24	 lea	 eax, DWORD PTR [edi+36]
  0001b	50		 push	 eax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 912  : 		this->_Myproxy = 0;

  0001c	c7 47 28 00 00
	00 00		 mov	 DWORD PTR [edi+40], 0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\mutex

; 33   : 		_Mtx_destroy(&_Mtx);

  00023	e8 00 00 00 00	 call	 __Mtx_destroy
  00028	83 c4 08	 add	 esp, 8
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 1222 : 		_Tidy();

  0002b	8d 4f 10	 lea	 ecx, DWORD PTR [edi+16]
  0002e	e8 00 00 00 00	 call	 ?_Tidy@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IAEXXZ ; std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::_Tidy
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 586  : 		::operator delete(_Ptr);

  00033	ff 77 10	 push	 DWORD PTR [edi+16]
  00036	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\mutex

; 33   : 		_Mtx_destroy(&_Mtx);

  0003b	8d 47 0c	 lea	 eax, DWORD PTR [edi+12]
  0003e	50		 push	 eax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 912  : 		this->_Myproxy = 0;

  0003f	c7 47 10 00 00
	00 00		 mov	 DWORD PTR [edi+16], 0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\mutex

; 33   : 		_Mtx_destroy(&_Mtx);

  00046	e8 00 00 00 00	 call	 __Mtx_destroy
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree

; 2216 : 		erase(begin(), end());

  0004b	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\mutex

; 33   : 		_Mtx_destroy(&_Mtx);

  0004e	83 c4 08	 add	 esp, 8
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree

; 2216 : 		erase(begin(), end());

  00051	8d 4f 04	 lea	 ecx, DWORD PTR [edi+4]
  00054	50		 push	 eax
  00055	ff 30		 push	 DWORD PTR [eax]
  00057	8d 45 fc	 lea	 eax, DWORD PTR $T1[ebp]
  0005a	50		 push	 eax
  0005b	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::erase
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 586  : 		::operator delete(_Ptr);

  00060	ff 77 04	 push	 DWORD PTR [edi+4]
  00063	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\mutex

; 33   : 		_Mtx_destroy(&_Mtx);

  00068	57		 push	 edi
  00069	e8 00 00 00 00	 call	 __Mtx_destroy
  0006e	83 c4 08	 add	 esp, 8
  00071	5f		 pop	 edi
  00072	5e		 pop	 esi
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp

; 203  : }

  00073	8b e5		 mov	 esp, ebp
  00075	5d		 pop	 ebp
  00076	c3		 ret	 0
??1World@@QAE@XZ ENDP					; World::~World
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
;	COMDAT ??0ChunkPosition@@QAE@HHH@Z
_TEXT	SEGMENT
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_z$ = 16						; size = 4
??0ChunkPosition@@QAE@HHH@Z PROC			; ChunkPosition::ChunkPosition, COMDAT
; _this$ = ecx

; 6    : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR _x$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax
  00008	8b 45 0c	 mov	 eax, DWORD PTR _y$[ebp]
  0000b	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  0000e	8b 45 10	 mov	 eax, DWORD PTR _z$[ebp]
  00011	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 7    : 
; 8    : }

  00014	8b c1		 mov	 eax, ecx
  00016	5d		 pop	 ebp
  00017	c2 0c 00	 ret	 12			; 0000000cH
??0ChunkPosition@@QAE@HHH@Z ENDP			; ChunkPosition::ChunkPosition
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
;	COMDAT ??0BlockCount@@QAE@I@Z
_TEXT	SEGMENT
_size$ = 8						; size = 4
??0BlockCount@@QAE@I@Z PROC				; BlockCount::BlockCount, COMDAT
; _this$ = ecx

; 12   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR _size$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax
  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 13   : 
; 14   : }

  00016	8b c1		 mov	 eax, ecx
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
??0BlockCount@@QAE@I@Z ENDP				; BlockCount::BlockCount
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
;	COMDAT ?isAllSolid@BlockCount@@QAE_NXZ
_TEXT	SEGMENT
?isAllSolid@BlockCount@@QAE_NXZ PROC			; BlockCount::isAllSolid, COMDAT
; _this$ = ecx

; 23   : 	return solids == size;

  00000	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00003	33 c0		 xor	 eax, eax
  00005	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00007	0f 94 c0	 sete	 al

; 24   : }

  0000a	c3		 ret	 0
?isAllSolid@BlockCount@@QAE_NXZ ENDP			; BlockCount::isAllSolid
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
;	COMDAT ?isVaried@BlockCount@@QAE_NXZ
_TEXT	SEGMENT
?isVaried@BlockCount@@QAE_NXZ PROC			; BlockCount::isVaried, COMDAT
; _this$ = ecx

; 28   : 	return !(((solids == 0) & (nonsolids == 0)) | (solids == 16 * 16 * 16));

  00000	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00003	33 c0		 xor	 eax, eax
  00005	39 41 08	 cmp	 DWORD PTR [ecx+8], eax
  00008	0f 94 c0	 sete	 al
  0000b	33 c9		 xor	 ecx, ecx
  0000d	85 d2		 test	 edx, edx
  0000f	0f 94 c1	 sete	 cl
  00012	23 c1		 and	 eax, ecx
  00014	33 c9		 xor	 ecx, ecx
  00016	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  0001c	0f 94 c1	 sete	 cl
  0001f	0b c1		 or	 eax, ecx
  00021	f7 d8		 neg	 eax
  00023	1b c0		 sbb	 eax, eax
  00025	40		 inc	 eax

; 29   : }

  00026	c3		 ret	 0
?isVaried@BlockCount@@QAE_NXZ ENDP			; BlockCount::isVaried
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
;	COMDAT ?remove@BlockCount@@QAEXG@Z
_TEXT	SEGMENT
_oldBlock$ = 8						; size = 2
?remove@BlockCount@@QAEXG@Z PROC			; BlockCount::remove, COMDAT
; _this$ = ecx

; 32   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 33   : 	if(oldBlock) solids--;

  00003	66 83 7d 08 00	 cmp	 WORD PTR _oldBlock$[ebp], 0
  00008	74 03		 je	 SHORT $LN1@remove
  0000a	ff 49 04	 dec	 DWORD PTR [ecx+4]
$LN1@remove:

; 34   : }

  0000d	5d		 pop	 ebp
  0000e	c2 04 00	 ret	 4
?remove@BlockCount@@QAEXG@Z ENDP			; BlockCount::remove
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
;	COMDAT ?place@BlockCount@@QAEXG@Z
_TEXT	SEGMENT
_newBlock$ = 8						; size = 2
?place@BlockCount@@QAEXG@Z PROC				; BlockCount::place, COMDAT
; _this$ = ecx

; 37   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 38   : 	if(newBlock) solids++;

  00003	66 83 7d 08 00	 cmp	 WORD PTR _newBlock$[ebp], 0
  00008	74 03		 je	 SHORT $LN1@place
  0000a	ff 41 04	 inc	 DWORD PTR [ecx+4]
$LN1@place:

; 39   : }

  0000d	5d		 pop	 ebp
  0000e	c2 04 00	 ret	 4
?place@BlockCount@@QAEXG@Z ENDP				; BlockCount::place
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
;	COMDAT ?replace@BlockCount@@QAEXGG@Z
_TEXT	SEGMENT
_oldBlock$ = 8						; size = 2
_newBlock$ = 12						; size = 2
?replace@BlockCount@@QAEXGG@Z PROC			; BlockCount::replace, COMDAT
; _this$ = ecx

; 42   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 33   : 	if(oldBlock) solids--;

  00003	66 83 7d 08 00	 cmp	 WORD PTR _oldBlock$[ebp], 0
  00008	74 03		 je	 SHORT $LN3@replace
  0000a	ff 49 04	 dec	 DWORD PTR [ecx+4]
$LN3@replace:

; 34   : }
; 35   : 
; 36   : void BlockCount::place(unsigned short newBlock)
; 37   : {
; 38   : 	if(newBlock) solids++;

  0000d	66 83 7d 0c 00	 cmp	 WORD PTR _newBlock$[ebp], 0
  00012	74 03		 je	 SHORT $LN6@replace
  00014	ff 41 04	 inc	 DWORD PTR [ecx+4]
$LN6@replace:

; 43   : 	remove(oldBlock);
; 44   : 	place(newBlock);
; 45   : }

  00017	5d		 pop	 ebp
  00018	c2 08 00	 ret	 8
?replace@BlockCount@@QAEXGG@Z ENDP			; BlockCount::replace
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
;	COMDAT ??0ChunkBase@@QAE@AAVWorld@@HHH@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_world$ = 8						; size = 4
_xPos$ = 12						; size = 4
_yPos$ = 16						; size = 4
_zPos$ = 20						; size = 4
??0ChunkBase@@QAE@AAVWorld@@HHH@Z PROC			; ChunkBase::ChunkBase, COMDAT
; _this$ = ecx

; 49   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0ChunkBase@@QAE@AAVWorld@@HHH@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00024	8b f1		 mov	 esi, ecx
  00026	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi
  00029	8b 45 08	 mov	 eax, DWORD PTR _world$[ebp]
  0002c	89 46 08	 mov	 DWORD PTR [esi+8], eax

; 6    : {

  0002f	8b 45 0c	 mov	 eax, DWORD PTR _xPos$[ebp]

; 49   : {

  00032	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7ChunkBase@@6B@
  00038	66 c7 46 04 00
	00		 mov	 WORD PTR [esi+4], 0
  0003e	c6 46 06 00	 mov	 BYTE PTR [esi+6], 0

; 6    : {

  00042	89 46 0c	 mov	 DWORD PTR [esi+12], eax
  00045	8b 45 10	 mov	 eax, DWORD PTR _yPos$[ebp]
  00048	89 46 10	 mov	 DWORD PTR [esi+16], eax
  0004b	8b 45 14	 mov	 eax, DWORD PTR _zPos$[ebp]
  0004e	89 46 14	 mov	 DWORD PTR [esi+20], eax

; 49   : {

  00051	8d 46 18	 lea	 eax, DWORD PTR [esi+24]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 63   : 	return (_Check_C_return(_Mtx_init(_Mtx, _Type)));

  00054	6a 02		 push	 2
  00056	50		 push	 eax
  00057	e8 00 00 00 00	 call	 __Mtx_init
  0005c	83 c4 08	 add	 esp, 8

; 32   : 	if (_Res != _Thrd_success)

  0005f	85 c0		 test	 eax, eax
  00061	74 09		 je	 SHORT $LN14@ChunkBase

; 33   : 		_Throw_C_error(_Res);

  00063	50		 push	 eax
  00064	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
  00069	83 c4 04	 add	 esp, 4
$LN14@ChunkBase:
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp

; 49   : {

  0006c	8d 46 1c	 lea	 eax, DWORD PTR [esi+28]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 63   : 	return (_Check_C_return(_Mtx_init(_Mtx, _Type)));

  0006f	6a 02		 push	 2
  00071	50		 push	 eax
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp

; 49   : {

  00072	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 63   : 	return (_Check_C_return(_Mtx_init(_Mtx, _Type)));

  00079	e8 00 00 00 00	 call	 __Mtx_init
  0007e	83 c4 08	 add	 esp, 8

; 32   : 	if (_Res != _Thrd_success)

  00081	85 c0		 test	 eax, eax
  00083	74 09		 je	 SHORT $LN23@ChunkBase

; 33   : 		_Throw_C_error(_Res);

  00085	50		 push	 eax
  00086	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
  0008b	83 c4 04	 add	 esp, 4
$LN23@ChunkBase:
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp

; 49   : {

  0008e	8d 4e 20	 lea	 ecx, DWORD PTR [esi+32]
  00091	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 501  : 		_Resetp((_Ty *)0);

  00095	6a 00		 push	 0

; 282  : 		{	// construct

  00097	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  0009d	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 501  : 		_Resetp((_Ty *)0);

  000a4	e8 00 00 00 00	 call	 ??$_Resetp@VVertexStream@gfxu@@@?$shared_ptr@VVertexStream@gfxu@@@std@@AAEXPAVVertexStream@gfxu@@@Z ; std::shared_ptr<gfxu::VertexStream>::_Resetp<gfxu::VertexStream>
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp

; 12   : {

  000a9	c7 46 28 00 10
	00 00		 mov	 DWORD PTR [esi+40], 4096 ; 00001000H
  000b0	c7 46 2c 00 00
	00 00		 mov	 DWORD PTR [esi+44], 0
  000b7	c7 46 30 00 00
	00 00		 mov	 DWORD PTR [esi+48], 0
  000be	c7 46 34 00 01
	00 00		 mov	 DWORD PTR [esi+52], 256	; 00000100H
  000c5	c7 46 38 00 00
	00 00		 mov	 DWORD PTR [esi+56], 0
  000cc	c7 46 3c 00 00
	00 00		 mov	 DWORD PTR [esi+60], 0
  000d3	c7 46 40 00 01
	00 00		 mov	 DWORD PTR [esi+64], 256	; 00000100H
  000da	c7 46 44 00 00
	00 00		 mov	 DWORD PTR [esi+68], 0
  000e1	c7 46 48 00 00
	00 00		 mov	 DWORD PTR [esi+72], 0
  000e8	c7 46 4c 00 01
	00 00		 mov	 DWORD PTR [esi+76], 256	; 00000100H
  000ef	c7 46 50 00 00
	00 00		 mov	 DWORD PTR [esi+80], 0
  000f6	c7 46 54 00 00
	00 00		 mov	 DWORD PTR [esi+84], 0
  000fd	c7 46 58 00 01
	00 00		 mov	 DWORD PTR [esi+88], 256	; 00000100H
  00104	c7 46 5c 00 00
	00 00		 mov	 DWORD PTR [esi+92], 0
  0010b	c7 46 60 00 00
	00 00		 mov	 DWORD PTR [esi+96], 0
  00112	c7 46 64 00 01
	00 00		 mov	 DWORD PTR [esi+100], 256 ; 00000100H
  00119	c7 46 68 00 00
	00 00		 mov	 DWORD PTR [esi+104], 0
  00120	c7 46 6c 00 00
	00 00		 mov	 DWORD PTR [esi+108], 0
  00127	c7 46 70 00 01
	00 00		 mov	 DWORD PTR [esi+112], 256 ; 00000100H
  0012e	c7 46 74 00 00
	00 00		 mov	 DWORD PTR [esi+116], 0
  00135	c7 46 78 00 00
	00 00		 mov	 DWORD PTR [esi+120], 0

; 50   : 
; 51   : }

  0013c	8b c6		 mov	 eax, esi
  0013e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00141	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00148	59		 pop	 ecx
  00149	5e		 pop	 esi
  0014a	8b e5		 mov	 esp, ebp
  0014c	5d		 pop	 ebp
  0014d	c2 10 00	 ret	 16			; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0ChunkBase@@QAE@AAVWorld@@HHH@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	83 c1 18	 add	 ecx, 24			; 00000018H
  00006	e9 00 00 00 00	 jmp	 ??1mutex@std@@QAE@XZ
__unwindfunclet$??0ChunkBase@@QAE@AAVWorld@@HHH@Z$1:
  0000b	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	83 c1 1c	 add	 ecx, 28			; 0000001cH
  00011	e9 00 00 00 00	 jmp	 ??1mutex@std@@QAE@XZ
__ehhandler$??0ChunkBase@@QAE@AAVWorld@@HHH@Z:
  00016	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001d	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  00020	33 c8		 xor	 ecx, eax
  00022	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00027	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0ChunkBase@@QAE@AAVWorld@@HHH@Z
  0002c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0ChunkBase@@QAE@AAVWorld@@HHH@Z ENDP			; ChunkBase::ChunkBase
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\mutex
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
;	COMDAT ??1ChunkBase@@QAE@XZ
_TEXT	SEGMENT
??1ChunkBase@@QAE@XZ PROC				; ChunkBase::~ChunkBase, COMDAT
; _this$ = ecx

; 54   : {

  00000	56		 push	 esi
  00001	57		 push	 edi
  00002	8b f9		 mov	 edi, ecx
  00004	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], OFFSET ??_7ChunkBase@@6B@
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  0000a	8b 77 24	 mov	 esi, DWORD PTR [edi+36]
  0000d	85 f6		 test	 esi, esi
  0000f	74 27		 je	 SHORT $LN11@ChunkBase
  00011	53		 push	 ebx

; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  00012	83 cb ff	 or	 ebx, -1
  00015	8d 56 04	 lea	 edx, DWORD PTR [esi+4]
  00018	8b c3		 mov	 eax, ebx
  0001a	f0 0f c1 02	 lock	  xadd	 DWORD PTR [edx], eax
  0001e	75 17		 jne	 SHORT $LN22@ChunkBase

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  00020	8b 06		 mov	 eax, DWORD PTR [esi]
  00022	8b ce		 mov	 ecx, esi
  00024	ff 10		 call	 DWORD PTR [eax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  00026	8d 46 08	 lea	 eax, DWORD PTR [esi+8]
  00029	f0 0f c1 18	 lock	  xadd	 DWORD PTR [eax], ebx
  0002d	4b		 dec	 ebx
  0002e	75 07		 jne	 SHORT $LN22@ChunkBase

; 128  : 			_Delete_this();

  00030	8b 06		 mov	 eax, DWORD PTR [esi]
  00032	8b ce		 mov	 ecx, esi
  00034	ff 50 04	 call	 DWORD PTR [eax+4]
$LN22@ChunkBase:
  00037	5b		 pop	 ebx
$LN11@ChunkBase:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\mutex

; 33   : 		_Mtx_destroy(&_Mtx);

  00038	8d 47 1c	 lea	 eax, DWORD PTR [edi+28]
  0003b	50		 push	 eax
  0003c	e8 00 00 00 00	 call	 __Mtx_destroy
  00041	8d 47 18	 lea	 eax, DWORD PTR [edi+24]
  00044	50		 push	 eax
  00045	e8 00 00 00 00	 call	 __Mtx_destroy
  0004a	83 c4 08	 add	 esp, 8
  0004d	5f		 pop	 edi
  0004e	5e		 pop	 esi
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp

; 56   : }

  0004f	c3		 ret	 0
??1ChunkBase@@QAE@XZ ENDP				; ChunkBase::~ChunkBase
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
;	COMDAT ?shouldRender@ChunkBase@@UAE_NXZ
_TEXT	SEGMENT
?shouldRender@ChunkBase@@UAE_NXZ PROC			; ChunkBase::shouldRender, COMDAT
; _this$ = ecx

; 80   : 	return false;

  00000	32 c0		 xor	 al, al

; 81   : }

  00002	c3		 ret	 0
?shouldRender@ChunkBase@@UAE_NXZ ENDP			; ChunkBase::shouldRender
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
;	COMDAT ??0EmptyChunk@@QAE@AAVWorld@@HHH@Z
_TEXT	SEGMENT
_world$dead$ = 8					; size = 4
_xPos$ = 12						; size = 4
_yPos$ = 16						; size = 4
_zPos$ = 20						; size = 4
??0EmptyChunk@@QAE@AAVWorld@@HHH@Z PROC			; EmptyChunk::EmptyChunk, COMDAT
; _this$ = ecx

; 97   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	ff 75 14	 push	 DWORD PTR _zPos$[ebp]
  00007	8b f1		 mov	 esi, ecx
  00009	ff 75 10	 push	 DWORD PTR _yPos$[ebp]
  0000c	ff 75 0c	 push	 DWORD PTR _xPos$[ebp]
  0000f	68 00 00 00 00	 push	 OFFSET ?world@GlobalThread@@3VWorld@@A ; GlobalThread::world
  00014	e8 00 00 00 00	 call	 ??0ChunkBase@@QAE@AAVWorld@@HHH@Z ; ChunkBase::ChunkBase
  00019	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7EmptyChunk@@6B@

; 98   : 
; 99   : }

  0001f	8b c6		 mov	 eax, esi
  00021	5e		 pop	 esi
  00022	5d		 pop	 ebp
  00023	c2 10 00	 ret	 16			; 00000010H
??0EmptyChunk@@QAE@AAVWorld@@HHH@Z ENDP			; EmptyChunk::EmptyChunk
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\mutex
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
;	COMDAT ??1EmptyChunk@@QAE@XZ
_TEXT	SEGMENT
??1EmptyChunk@@QAE@XZ PROC				; EmptyChunk::~EmptyChunk, COMDAT
; _this$ = ecx

; 102  : {

  00000	56		 push	 esi
  00001	57		 push	 edi
  00002	8b f9		 mov	 edi, ecx

; 54   : {

  00004	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], OFFSET ??_7ChunkBase@@6B@
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  0000a	8b 77 24	 mov	 esi, DWORD PTR [edi+36]
  0000d	85 f6		 test	 esi, esi
  0000f	74 27		 je	 SHORT $LN13@EmptyChunk
  00011	53		 push	 ebx

; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  00012	83 cb ff	 or	 ebx, -1
  00015	8d 56 04	 lea	 edx, DWORD PTR [esi+4]
  00018	8b c3		 mov	 eax, ebx
  0001a	f0 0f c1 02	 lock	  xadd	 DWORD PTR [edx], eax
  0001e	75 17		 jne	 SHORT $LN24@EmptyChunk

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  00020	8b 06		 mov	 eax, DWORD PTR [esi]
  00022	8b ce		 mov	 ecx, esi
  00024	ff 10		 call	 DWORD PTR [eax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  00026	8d 46 08	 lea	 eax, DWORD PTR [esi+8]
  00029	f0 0f c1 18	 lock	  xadd	 DWORD PTR [eax], ebx
  0002d	4b		 dec	 ebx
  0002e	75 07		 jne	 SHORT $LN24@EmptyChunk

; 128  : 			_Delete_this();

  00030	8b 06		 mov	 eax, DWORD PTR [esi]
  00032	8b ce		 mov	 ecx, esi
  00034	ff 50 04	 call	 DWORD PTR [eax+4]
$LN24@EmptyChunk:
  00037	5b		 pop	 ebx
$LN13@EmptyChunk:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\mutex

; 33   : 		_Mtx_destroy(&_Mtx);

  00038	8d 47 1c	 lea	 eax, DWORD PTR [edi+28]
  0003b	50		 push	 eax
  0003c	e8 00 00 00 00	 call	 __Mtx_destroy
  00041	8d 47 18	 lea	 eax, DWORD PTR [edi+24]
  00044	50		 push	 eax
  00045	e8 00 00 00 00	 call	 __Mtx_destroy
  0004a	83 c4 08	 add	 esp, 8
  0004d	5f		 pop	 edi
  0004e	5e		 pop	 esi
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp

; 104  : }

  0004f	c3		 ret	 0
??1EmptyChunk@@QAE@XZ ENDP				; EmptyChunk::~EmptyChunk
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
;	COMDAT ?getBlock@EmptyChunk@@UAEGHHH@Z
_TEXT	SEGMENT
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_z$ = 16						; size = 4
?getBlock@EmptyChunk@@UAEGHHH@Z PROC			; EmptyChunk::getBlock, COMDAT
; _this$ = ecx

; 108  : 	return 0;

  00000	33 c0		 xor	 eax, eax

; 109  : }

  00002	c2 0c 00	 ret	 12			; 0000000cH
?getBlock@EmptyChunk@@UAEGHHH@Z ENDP			; EmptyChunk::getBlock
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
;	COMDAT ?setBlock@EmptyChunk@@UAEXHHHG@Z
_TEXT	SEGMENT
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_z$ = 16						; size = 4
_id$ = 20						; size = 2
?setBlock@EmptyChunk@@UAEXHHHG@Z PROC			; EmptyChunk::setBlock, COMDAT
; _this$ = ecx

; 113  : 
; 114  : }

  00000	c2 10 00	 ret	 16			; 00000010H
?setBlock@EmptyChunk@@UAEXHHHG@Z ENDP			; EmptyChunk::setBlock
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
;	COMDAT ?setBlockRaw@EmptyChunk@@UAEXHHHG@Z
_TEXT	SEGMENT
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_z$ = 16						; size = 4
_id$ = 20						; size = 2
?setBlockRaw@EmptyChunk@@UAEXHHHG@Z PROC		; EmptyChunk::setBlockRaw, COMDAT
; _this$ = ecx

; 118  : 
; 119  : }

  00000	c2 10 00	 ret	 16			; 00000010H
?setBlockRaw@EmptyChunk@@UAEXHHHG@Z ENDP		; EmptyChunk::setBlockRaw
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
;	COMDAT ?isEmpty@EmptyChunk@@UAE_NXZ
_TEXT	SEGMENT
?isEmpty@EmptyChunk@@UAE_NXZ PROC			; EmptyChunk::isEmpty, COMDAT
; _this$ = ecx

; 123  : 	return true;

  00000	b0 01		 mov	 al, 1

; 124  : }

  00002	c3		 ret	 0
?isEmpty@EmptyChunk@@UAE_NXZ ENDP			; EmptyChunk::isEmpty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
;	COMDAT ?shouldRender@EmptyChunk@@UAE_NXZ
_TEXT	SEGMENT
?shouldRender@EmptyChunk@@UAE_NXZ PROC			; EmptyChunk::shouldRender, COMDAT
; _this$ = ecx

; 128  : 	return false;

  00000	32 c0		 xor	 al, al

; 129  : }

  00002	c3		 ret	 0
?shouldRender@EmptyChunk@@UAE_NXZ ENDP			; EmptyChunk::shouldRender
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
;	COMDAT ??0Chunk@@QAE@AAVWorld@@HHH@Z
_TEXT	SEGMENT
_world$ = 8						; size = 4
_xPos$ = 12						; size = 4
_yPos$ = 16						; size = 4
_zPos$ = 20						; size = 4
??0Chunk@@QAE@AAVWorld@@HHH@Z PROC			; Chunk::Chunk, COMDAT
; _this$ = ecx

; 135  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	ff 75 14	 push	 DWORD PTR _zPos$[ebp]
  00007	8b f1		 mov	 esi, ecx
  00009	ff 75 10	 push	 DWORD PTR _yPos$[ebp]
  0000c	ff 75 0c	 push	 DWORD PTR _xPos$[ebp]
  0000f	ff 75 08	 push	 DWORD PTR _world$[ebp]
  00012	e8 00 00 00 00	 call	 ??0ChunkBase@@QAE@AAVWorld@@HHH@Z ; ChunkBase::ChunkBase
  00017	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7Chunk@@6B@
  0001d	c7 46 7c 00 00
	00 00		 mov	 DWORD PTR [esi+124], 0
  00024	c7 86 80 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+128], 0

; 136  : 
; 137  : }

  0002e	8b c6		 mov	 eax, esi
  00030	5e		 pop	 esi
  00031	5d		 pop	 ebp
  00032	c2 10 00	 ret	 16			; 00000010H
??0Chunk@@QAE@AAVWorld@@HHH@Z ENDP			; Chunk::Chunk
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\mutex
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
;	COMDAT ??1Chunk@@QAE@XZ
_TEXT	SEGMENT
??1Chunk@@QAE@XZ PROC					; Chunk::~Chunk, COMDAT
; _this$ = ecx

; 140  : {

  00000	56		 push	 esi
  00001	57		 push	 edi
  00002	8b f9		 mov	 edi, ecx

; 54   : {

  00004	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], OFFSET ??_7ChunkBase@@6B@
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  0000a	8b 77 24	 mov	 esi, DWORD PTR [edi+36]
  0000d	85 f6		 test	 esi, esi
  0000f	74 27		 je	 SHORT $LN13@Chunk
  00011	53		 push	 ebx

; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  00012	83 cb ff	 or	 ebx, -1
  00015	8d 56 04	 lea	 edx, DWORD PTR [esi+4]
  00018	8b c3		 mov	 eax, ebx
  0001a	f0 0f c1 02	 lock	  xadd	 DWORD PTR [edx], eax
  0001e	75 17		 jne	 SHORT $LN24@Chunk

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  00020	8b 06		 mov	 eax, DWORD PTR [esi]
  00022	8b ce		 mov	 ecx, esi
  00024	ff 10		 call	 DWORD PTR [eax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  00026	8d 46 08	 lea	 eax, DWORD PTR [esi+8]
  00029	f0 0f c1 18	 lock	  xadd	 DWORD PTR [eax], ebx
  0002d	4b		 dec	 ebx
  0002e	75 07		 jne	 SHORT $LN24@Chunk

; 128  : 			_Delete_this();

  00030	8b 06		 mov	 eax, DWORD PTR [esi]
  00032	8b ce		 mov	 ecx, esi
  00034	ff 50 04	 call	 DWORD PTR [eax+4]
$LN24@Chunk:
  00037	5b		 pop	 ebx
$LN13@Chunk:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\mutex

; 33   : 		_Mtx_destroy(&_Mtx);

  00038	8d 47 1c	 lea	 eax, DWORD PTR [edi+28]
  0003b	50		 push	 eax
  0003c	e8 00 00 00 00	 call	 __Mtx_destroy
  00041	8d 47 18	 lea	 eax, DWORD PTR [edi+24]
  00044	50		 push	 eax
  00045	e8 00 00 00 00	 call	 __Mtx_destroy
  0004a	83 c4 08	 add	 esp, 8
  0004d	5f		 pop	 edi
  0004e	5e		 pop	 esi
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp

; 142  : }

  0004f	c3		 ret	 0
??1Chunk@@QAE@XZ ENDP					; Chunk::~Chunk
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
;	COMDAT ?getBlock@Chunk@@UAEGHHH@Z
_TEXT	SEGMENT
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_z$ = 16						; size = 4
?getBlock@Chunk@@UAEGHHH@Z PROC				; Chunk::getBlock, COMDAT
; _this$ = ecx

; 145  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 146  : 	return data[x][y][z];

  00003	8b 45 08	 mov	 eax, DWORD PTR _x$[ebp]
  00006	c1 e0 04	 shl	 eax, 4
  00009	03 45 0c	 add	 eax, DWORD PTR _y$[ebp]
  0000c	c1 e0 04	 shl	 eax, 4
  0000f	03 45 10	 add	 eax, DWORD PTR _z$[ebp]
  00012	66 8b 84 41 84
	00 00 00	 mov	 ax, WORD PTR [ecx+eax*2+132]

; 147  : }

  0001a	5d		 pop	 ebp
  0001b	c2 0c 00	 ret	 12			; 0000000cH
?getBlock@Chunk@@UAEGHHH@Z ENDP				; Chunk::getBlock
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
;	COMDAT ?setBlock@Chunk@@UAEXHHHG@Z
_TEXT	SEGMENT
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_z$ = 16						; size = 4
_id$ = 20						; size = 2
?setBlock@Chunk@@UAEXHHHG@Z PROC			; Chunk::setBlock, COMDAT
; _this$ = ecx

; 150  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 151  : 	unsigned short oldBlock = getBlock(x, y, z);

  00004	8b 5d 10	 mov	 ebx, DWORD PTR _z$[ebp]
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	8b 7d 08	 mov	 edi, DWORD PTR _x$[ebp]
  0000c	53		 push	 ebx
  0000d	ff 75 0c	 push	 DWORD PTR _y$[ebp]
  00010	8b f1		 mov	 esi, ecx
  00012	57		 push	 edi
  00013	8b 06		 mov	 eax, DWORD PTR [esi]
  00015	ff 10		 call	 DWORD PTR [eax]
  00017	0f b7 c8	 movzx	 ecx, ax

; 33   : 	if(oldBlock) solids--;

  0001a	66 85 c9	 test	 cx, cx
  0001d	74 03		 je	 SHORT $LN11@setBlock
  0001f	ff 4e 2c	 dec	 DWORD PTR [esi+44]
$LN11@setBlock:

; 34   : }
; 35   : 
; 36   : void BlockCount::place(unsigned short newBlock)
; 37   : {
; 38   : 	if(newBlock) solids++;

  00022	66 8b 45 14	 mov	 ax, WORD PTR _id$[ebp]
  00026	66 85 c0	 test	 ax, ax
  00029	74 03		 je	 SHORT $LN14@setBlock
  0002b	ff 46 2c	 inc	 DWORD PTR [esi+44]
$LN14@setBlock:

; 152  : 	cAll.replace(oldBlock, id);
; 153  : 
; 154  : 	if(x == 0) cWest.replace(oldBlock, id);

  0002e	85 ff		 test	 edi, edi
  00030	75 12		 jne	 SHORT $LN22@setBlock

; 33   : 	if(oldBlock) solids--;

  00032	66 85 c9	 test	 cx, cx
  00035	74 03		 je	 SHORT $LN19@setBlock
  00037	ff 4e 38	 dec	 DWORD PTR [esi+56]
$LN19@setBlock:

; 34   : }
; 35   : 
; 36   : void BlockCount::place(unsigned short newBlock)
; 37   : {
; 38   : 	if(newBlock) solids++;

  0003a	66 85 c0	 test	 ax, ax
  0003d	74 1a		 je	 SHORT $LN30@setBlock
  0003f	ff 46 38	 inc	 DWORD PTR [esi+56]

; 155  : 	if(x == 15) cEast.replace(oldBlock, id);

  00042	eb 15		 jmp	 SHORT $LN30@setBlock
$LN22@setBlock:
  00044	83 ff 0f	 cmp	 edi, 15			; 0000000fH
  00047	75 10		 jne	 SHORT $LN30@setBlock

; 33   : 	if(oldBlock) solids--;

  00049	66 85 c9	 test	 cx, cx
  0004c	74 03		 je	 SHORT $LN27@setBlock
  0004e	ff 4e 44	 dec	 DWORD PTR [esi+68]
$LN27@setBlock:

; 34   : }
; 35   : 
; 36   : void BlockCount::place(unsigned short newBlock)
; 37   : {
; 38   : 	if(newBlock) solids++;

  00051	66 85 c0	 test	 ax, ax
  00054	74 03		 je	 SHORT $LN30@setBlock
  00056	ff 46 44	 inc	 DWORD PTR [esi+68]
$LN30@setBlock:

; 156  : 	if(y == 0) cDown.replace(oldBlock, id);

  00059	8b 55 0c	 mov	 edx, DWORD PTR _y$[ebp]
  0005c	85 d2		 test	 edx, edx
  0005e	75 12		 jne	 SHORT $LN38@setBlock

; 33   : 	if(oldBlock) solids--;

  00060	66 85 c9	 test	 cx, cx
  00063	74 03		 je	 SHORT $LN35@setBlock
  00065	ff 4e 50	 dec	 DWORD PTR [esi+80]
$LN35@setBlock:

; 34   : }
; 35   : 
; 36   : void BlockCount::place(unsigned short newBlock)
; 37   : {
; 38   : 	if(newBlock) solids++;

  00068	66 85 c0	 test	 ax, ax
  0006b	74 1a		 je	 SHORT $LN46@setBlock
  0006d	ff 46 50	 inc	 DWORD PTR [esi+80]

; 157  : 	if(y == 15) cUp.replace(oldBlock, id);

  00070	eb 15		 jmp	 SHORT $LN46@setBlock
$LN38@setBlock:
  00072	83 fa 0f	 cmp	 edx, 15			; 0000000fH
  00075	75 10		 jne	 SHORT $LN46@setBlock

; 33   : 	if(oldBlock) solids--;

  00077	66 85 c9	 test	 cx, cx
  0007a	74 03		 je	 SHORT $LN43@setBlock
  0007c	ff 4e 5c	 dec	 DWORD PTR [esi+92]
$LN43@setBlock:

; 34   : }
; 35   : 
; 36   : void BlockCount::place(unsigned short newBlock)
; 37   : {
; 38   : 	if(newBlock) solids++;

  0007f	66 85 c0	 test	 ax, ax
  00082	74 03		 je	 SHORT $LN46@setBlock
  00084	ff 46 5c	 inc	 DWORD PTR [esi+92]
$LN46@setBlock:

; 158  : 	if(z == 0) cSouth.replace(oldBlock, id);

  00087	85 db		 test	 ebx, ebx
  00089	75 12		 jne	 SHORT $LN54@setBlock

; 33   : 	if(oldBlock) solids--;

  0008b	66 85 c9	 test	 cx, cx
  0008e	74 03		 je	 SHORT $LN51@setBlock
  00090	ff 4e 68	 dec	 DWORD PTR [esi+104]
$LN51@setBlock:

; 34   : }
; 35   : 
; 36   : void BlockCount::place(unsigned short newBlock)
; 37   : {
; 38   : 	if(newBlock) solids++;

  00093	66 85 c0	 test	 ax, ax
  00096	74 1a		 je	 SHORT $LN62@setBlock
  00098	ff 46 68	 inc	 DWORD PTR [esi+104]

; 159  : 	if(z == 15) cNorth.replace(oldBlock, id);

  0009b	eb 15		 jmp	 SHORT $LN62@setBlock
$LN54@setBlock:
  0009d	83 fb 0f	 cmp	 ebx, 15			; 0000000fH
  000a0	75 10		 jne	 SHORT $LN62@setBlock

; 33   : 	if(oldBlock) solids--;

  000a2	66 85 c9	 test	 cx, cx
  000a5	74 03		 je	 SHORT $LN59@setBlock
  000a7	ff 4e 74	 dec	 DWORD PTR [esi+116]
$LN59@setBlock:

; 34   : }
; 35   : 
; 36   : void BlockCount::place(unsigned short newBlock)
; 37   : {
; 38   : 	if(newBlock) solids++;

  000aa	66 85 c0	 test	 ax, ax
  000ad	74 03		 je	 SHORT $LN62@setBlock
  000af	ff 46 74	 inc	 DWORD PTR [esi+116]
$LN62@setBlock:

; 160  : 
; 161  : 	data[x][y][z] = id;

  000b2	c1 e7 04	 shl	 edi, 4
  000b5	03 fa		 add	 edi, edx
  000b7	c1 e7 04	 shl	 edi, 4
  000ba	03 fb		 add	 edi, ebx
  000bc	66 89 84 7e 84
	00 00 00	 mov	 WORD PTR [esi+edi*2+132], ax
  000c4	5f		 pop	 edi
  000c5	5e		 pop	 esi
  000c6	5b		 pop	 ebx

; 162  : }

  000c7	5d		 pop	 ebp
  000c8	c2 10 00	 ret	 16			; 00000010H
?setBlock@Chunk@@UAEXHHHG@Z ENDP			; Chunk::setBlock
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
;	COMDAT ?setBlockRaw@Chunk@@UAEXHHHG@Z
_TEXT	SEGMENT
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_z$ = 16						; size = 4
_id$ = 20						; size = 2
?setBlockRaw@Chunk@@UAEXHHHG@Z PROC			; Chunk::setBlockRaw, COMDAT
; _this$ = ecx

; 165  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 38   : 	if(newBlock) solids++;

  00003	66 8b 55 14	 mov	 dx, WORD PTR _id$[ebp]
  00007	66 85 d2	 test	 dx, dx
  0000a	74 03		 je	 SHORT $LN9@setBlockRa
  0000c	ff 41 2c	 inc	 DWORD PTR [ecx+44]
$LN9@setBlockRa:

; 166  : 	cAll.place(id);
; 167  : 
; 168  : 	if(x == 0) cWest.place(id);

  0000f	8b 45 08	 mov	 eax, DWORD PTR _x$[ebp]
  00012	85 c0		 test	 eax, eax
  00014	75 0a		 jne	 SHORT $LN12@setBlockRa

; 38   : 	if(newBlock) solids++;

  00016	66 85 d2	 test	 dx, dx
  00019	74 12		 je	 SHORT $LN15@setBlockRa
  0001b	ff 41 38	 inc	 DWORD PTR [ecx+56]

; 169  : 	if(x == 15) cEast.place(id);

  0001e	eb 0d		 jmp	 SHORT $LN15@setBlockRa
$LN12@setBlockRa:
  00020	83 f8 0f	 cmp	 eax, 15			; 0000000fH
  00023	75 08		 jne	 SHORT $LN15@setBlockRa

; 38   : 	if(newBlock) solids++;

  00025	66 85 d2	 test	 dx, dx
  00028	74 03		 je	 SHORT $LN15@setBlockRa
  0002a	ff 41 44	 inc	 DWORD PTR [ecx+68]
$LN15@setBlockRa:
  0002d	56		 push	 esi
  0002e	57		 push	 edi

; 170  : 	if(y == 0) cDown.place(id);

  0002f	8b 7d 0c	 mov	 edi, DWORD PTR _y$[ebp]
  00032	85 ff		 test	 edi, edi
  00034	75 0a		 jne	 SHORT $LN18@setBlockRa

; 38   : 	if(newBlock) solids++;

  00036	66 85 d2	 test	 dx, dx
  00039	74 12		 je	 SHORT $LN21@setBlockRa
  0003b	ff 41 50	 inc	 DWORD PTR [ecx+80]

; 171  : 	if(y == 15) cUp.place(id);

  0003e	eb 0d		 jmp	 SHORT $LN21@setBlockRa
$LN18@setBlockRa:
  00040	83 ff 0f	 cmp	 edi, 15			; 0000000fH
  00043	75 08		 jne	 SHORT $LN21@setBlockRa

; 38   : 	if(newBlock) solids++;

  00045	66 85 d2	 test	 dx, dx
  00048	74 03		 je	 SHORT $LN21@setBlockRa
  0004a	ff 41 5c	 inc	 DWORD PTR [ecx+92]
$LN21@setBlockRa:

; 172  : 	if(z == 0) cSouth.place(id);

  0004d	8b 75 10	 mov	 esi, DWORD PTR _z$[ebp]
  00050	85 f6		 test	 esi, esi
  00052	75 0a		 jne	 SHORT $LN24@setBlockRa

; 38   : 	if(newBlock) solids++;

  00054	66 85 d2	 test	 dx, dx
  00057	74 12		 je	 SHORT $LN27@setBlockRa
  00059	ff 41 68	 inc	 DWORD PTR [ecx+104]

; 173  : 	if(z == 15) cNorth.place(id);

  0005c	eb 0d		 jmp	 SHORT $LN27@setBlockRa
$LN24@setBlockRa:
  0005e	83 fe 0f	 cmp	 esi, 15			; 0000000fH
  00061	75 08		 jne	 SHORT $LN27@setBlockRa

; 38   : 	if(newBlock) solids++;

  00063	66 85 d2	 test	 dx, dx
  00066	74 03		 je	 SHORT $LN27@setBlockRa
  00068	ff 41 74	 inc	 DWORD PTR [ecx+116]
$LN27@setBlockRa:

; 174  : 
; 175  : 	data[x][y][z] = id;

  0006b	c1 e0 04	 shl	 eax, 4
  0006e	03 c7		 add	 eax, edi
  00070	c1 e0 04	 shl	 eax, 4
  00073	03 c6		 add	 eax, esi
  00075	5f		 pop	 edi
  00076	66 89 94 41 84
	00 00 00	 mov	 WORD PTR [ecx+eax*2+132], dx
  0007e	5e		 pop	 esi

; 176  : }

  0007f	5d		 pop	 ebp
  00080	c2 10 00	 ret	 16			; 00000010H
?setBlockRaw@Chunk@@UAEXHHHG@Z ENDP			; Chunk::setBlockRaw
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
;	COMDAT ?isEmpty@Chunk@@UAE_NXZ
_TEXT	SEGMENT
?isEmpty@Chunk@@UAE_NXZ PROC				; Chunk::isEmpty, COMDAT
; _this$ = ecx

; 180  : 	return false;

  00000	32 c0		 xor	 al, al

; 181  : }

  00002	c3		 ret	 0
?isEmpty@Chunk@@UAE_NXZ ENDP				; Chunk::isEmpty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
;	COMDAT ?shouldRender@Chunk@@UAE_NXZ
_TEXT	SEGMENT
$T2 = -69						; size = 1
$T3 = -68						; size = 4
$T4 = -64						; size = 8
$T5 = -56						; size = 8
$T6 = -48						; size = 8
$T7 = -40						; size = 8
$T8 = -32						; size = 8
$T9 = -24						; size = 8
__$EHRec$ = -12						; size = 12
?shouldRender@Chunk@@UAE_NXZ PROC			; Chunk::shouldRender, COMDAT
; _this$ = ecx

; 184  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	6a ff		 push	 -1
  00008	68 00 00 00 00	 push	 __ehhandler$?shouldRender@Chunk@@UAE_NXZ
  0000d	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00013	50		 push	 eax
  00014	83 ec 40	 sub	 esp, 64			; 00000040H
  00017	53		 push	 ebx
  00018	56		 push	 esi
  00019	57		 push	 edi
  0001a	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001f	33 c4		 xor	 eax, esp
  00021	50		 push	 eax
  00022	8d 44 24 50	 lea	 eax, DWORD PTR __$EHRec$[esp+92]
  00026	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002c	8b f1		 mov	 esi, ecx
  0002e	33 db		 xor	 ebx, ebx

; 24   : }
; 25   : 
; 26   : bool BlockCount::isVaried()
; 27   : {
; 28   : 	return !(((solids == 0) & (nonsolids == 0)) | (solids == 16 * 16 * 16));

  00030	33 c9		 xor	 ecx, ecx
  00032	89 5c 24 18	 mov	 DWORD PTR $T3[esp+92], ebx
  00036	39 4e 30	 cmp	 DWORD PTR [esi+48], ecx
  00039	8b 56 2c	 mov	 edx, DWORD PTR [esi+44]
  0003c	0f 94 c1	 sete	 cl
  0003f	33 c0		 xor	 eax, eax
  00041	85 d2		 test	 edx, edx
  00043	0f 94 c0	 sete	 al
  00046	23 c8		 and	 ecx, eax
  00048	33 c0		 xor	 eax, eax
  0004a	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  00050	0f 94 c0	 sete	 al
  00053	0b c8		 or	 ecx, eax

; 190  : 		&& world->getChunk(pos.x, pos.y, pos.z + 1)->cSouth.isAllSolid());

  00055	0f 84 2f 01 00
	00		 je	 $LN3@shouldRend
  0005b	ff 76 14	 push	 DWORD PTR [esi+20]
  0005e	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  00061	ff 76 10	 push	 DWORD PTR [esi+16]
  00064	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00067	48		 dec	 eax
  00068	50		 push	 eax
  00069	8d 44 24 50	 lea	 eax, DWORD PTR $T9[esp+104]
  0006d	50		 push	 eax
  0006e	e8 00 00 00 00	 call	 ?getChunk@World@@QAE?AV?$shared_ptr@VChunkBase@@@std@@HHH@Z ; World::getChunk
  00073	89 5c 24 58	 mov	 DWORD PTR __$EHRec$[esp+100], ebx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 335  : 		return (_Ptr);

  00077	8b 08		 mov	 ecx, DWORD PTR [eax]
  00079	bb 01 00 00 00	 mov	 ebx, 1
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp

; 23   : 	return solids == size;

  0007e	8b 41 44	 mov	 eax, DWORD PTR [ecx+68]
  00081	89 5c 24 18	 mov	 DWORD PTR $T3[esp+92], ebx
  00085	3b 41 40	 cmp	 eax, DWORD PTR [ecx+64]

; 190  : 		&& world->getChunk(pos.x, pos.y, pos.z + 1)->cSouth.isAllSolid());

  00088	0f 85 fc 00 00
	00		 jne	 $LN3@shouldRend
  0008e	ff 76 14	 push	 DWORD PTR [esi+20]
  00091	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  00094	ff 76 10	 push	 DWORD PTR [esi+16]
  00097	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0009a	40		 inc	 eax
  0009b	50		 push	 eax
  0009c	8d 44 24 48	 lea	 eax, DWORD PTR $T8[esp+104]
  000a0	50		 push	 eax
  000a1	e8 00 00 00 00	 call	 ?getChunk@World@@QAE?AV?$shared_ptr@VChunkBase@@@std@@HHH@Z ; World::getChunk
  000a6	89 5c 24 58	 mov	 DWORD PTR __$EHRec$[esp+100], ebx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 335  : 		return (_Ptr);

  000aa	8b 08		 mov	 ecx, DWORD PTR [eax]
  000ac	bb 03 00 00 00	 mov	 ebx, 3
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp

; 23   : 	return solids == size;

  000b1	8b 41 38	 mov	 eax, DWORD PTR [ecx+56]
  000b4	89 5c 24 18	 mov	 DWORD PTR $T3[esp+92], ebx
  000b8	3b 41 34	 cmp	 eax, DWORD PTR [ecx+52]

; 190  : 		&& world->getChunk(pos.x, pos.y, pos.z + 1)->cSouth.isAllSolid());

  000bb	0f 85 c9 00 00
	00		 jne	 $LN3@shouldRend
  000c1	ff 76 14	 push	 DWORD PTR [esi+20]
  000c4	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  000c7	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  000ca	48		 dec	 eax
  000cb	50		 push	 eax
  000cc	ff 76 0c	 push	 DWORD PTR [esi+12]
  000cf	8d 44 24 40	 lea	 eax, DWORD PTR $T7[esp+104]
  000d3	50		 push	 eax
  000d4	e8 00 00 00 00	 call	 ?getChunk@World@@QAE?AV?$shared_ptr@VChunkBase@@@std@@HHH@Z ; World::getChunk
  000d9	c7 44 24 58 02
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+100], 2
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 335  : 		return (_Ptr);

  000e1	8b 08		 mov	 ecx, DWORD PTR [eax]
  000e3	bb 07 00 00 00	 mov	 ebx, 7
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp

; 23   : 	return solids == size;

  000e8	8b 41 5c	 mov	 eax, DWORD PTR [ecx+92]
  000eb	89 5c 24 18	 mov	 DWORD PTR $T3[esp+92], ebx
  000ef	3b 41 58	 cmp	 eax, DWORD PTR [ecx+88]

; 190  : 		&& world->getChunk(pos.x, pos.y, pos.z + 1)->cSouth.isAllSolid());

  000f2	0f 85 92 00 00
	00		 jne	 $LN3@shouldRend
  000f8	ff 76 14	 push	 DWORD PTR [esi+20]
  000fb	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  000fe	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00101	40		 inc	 eax
  00102	50		 push	 eax
  00103	ff 76 0c	 push	 DWORD PTR [esi+12]
  00106	8d 44 24 38	 lea	 eax, DWORD PTR $T6[esp+104]
  0010a	50		 push	 eax
  0010b	e8 00 00 00 00	 call	 ?getChunk@World@@QAE?AV?$shared_ptr@VChunkBase@@@std@@HHH@Z ; World::getChunk
  00110	c7 44 24 58 03
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+100], 3
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 335  : 		return (_Ptr);

  00118	8b 08		 mov	 ecx, DWORD PTR [eax]
  0011a	bb 0f 00 00 00	 mov	 ebx, 15			; 0000000fH
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp

; 23   : 	return solids == size;

  0011f	8b 41 50	 mov	 eax, DWORD PTR [ecx+80]
  00122	89 5c 24 18	 mov	 DWORD PTR $T3[esp+92], ebx
  00126	3b 41 4c	 cmp	 eax, DWORD PTR [ecx+76]

; 190  : 		&& world->getChunk(pos.x, pos.y, pos.z + 1)->cSouth.isAllSolid());

  00129	75 5f		 jne	 SHORT $LN3@shouldRend
  0012b	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  0012e	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00131	48		 dec	 eax
  00132	50		 push	 eax
  00133	ff 76 10	 push	 DWORD PTR [esi+16]
  00136	8d 44 24 2c	 lea	 eax, DWORD PTR $T5[esp+100]
  0013a	ff 76 0c	 push	 DWORD PTR [esi+12]
  0013d	50		 push	 eax
  0013e	e8 00 00 00 00	 call	 ?getChunk@World@@QAE?AV?$shared_ptr@VChunkBase@@@std@@HHH@Z ; World::getChunk
  00143	c7 44 24 58 04
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+100], 4
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 335  : 		return (_Ptr);

  0014b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0014d	bb 1f 00 00 00	 mov	 ebx, 31			; 0000001fH
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp

; 23   : 	return solids == size;

  00152	8b 41 74	 mov	 eax, DWORD PTR [ecx+116]
  00155	89 5c 24 18	 mov	 DWORD PTR $T3[esp+92], ebx
  00159	3b 41 70	 cmp	 eax, DWORD PTR [ecx+112]

; 190  : 		&& world->getChunk(pos.x, pos.y, pos.z + 1)->cSouth.isAllSolid());

  0015c	75 2c		 jne	 SHORT $LN3@shouldRend
  0015e	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00161	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00164	40		 inc	 eax
  00165	50		 push	 eax
  00166	ff 76 10	 push	 DWORD PTR [esi+16]
  00169	8d 44 24 24	 lea	 eax, DWORD PTR $T4[esp+100]
  0016d	ff 76 0c	 push	 DWORD PTR [esi+12]
  00170	50		 push	 eax
  00171	e8 00 00 00 00	 call	 ?getChunk@World@@QAE?AV?$shared_ptr@VChunkBase@@@std@@HHH@Z ; World::getChunk
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 335  : 		return (_Ptr);

  00176	8b 08		 mov	 ecx, DWORD PTR [eax]
  00178	bb 3f 00 00 00	 mov	 ebx, 63			; 0000003fH
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp

; 23   : 	return solids == size;

  0017d	8b 41 68	 mov	 eax, DWORD PTR [ecx+104]

; 190  : 		&& world->getChunk(pos.x, pos.y, pos.z + 1)->cSouth.isAllSolid());

  00180	c6 44 24 17 00	 mov	 BYTE PTR $T2[esp+92], 0

; 23   : 	return solids == size;

  00185	3b 41 64	 cmp	 eax, DWORD PTR [ecx+100]

; 190  : 		&& world->getChunk(pos.x, pos.y, pos.z + 1)->cSouth.isAllSolid());

  00188	74 05		 je	 SHORT $LN4@shouldRend
$LN3@shouldRend:
  0018a	c6 44 24 17 01	 mov	 BYTE PTR $T2[esp+92], 1
$LN4@shouldRend:
  0018f	83 ce ff	 or	 esi, -1
  00192	f6 c3 20	 test	 bl, 32			; 00000020H
  00195	74 32		 je	 SHORT $LN69@shouldRend
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  00197	8b 7c 24 20	 mov	 edi, DWORD PTR $T4[esp+96]
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp

; 190  : 		&& world->getChunk(pos.x, pos.y, pos.z + 1)->cSouth.isAllSolid());

  0019b	83 e3 df	 and	 ebx, -33		; ffffffdfH
  0019e	89 5c 24 18	 mov	 DWORD PTR $T3[esp+92], ebx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  001a2	85 ff		 test	 edi, edi
  001a4	74 23		 je	 SHORT $LN69@shouldRend

; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  001a6	8d 47 04	 lea	 eax, DWORD PTR [edi+4]
  001a9	8b ce		 mov	 ecx, esi
  001ab	f0 0f c1 08	 lock	  xadd	 DWORD PTR [eax], ecx
  001af	75 18		 jne	 SHORT $LN69@shouldRend

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  001b1	8b 07		 mov	 eax, DWORD PTR [edi]
  001b3	8b cf		 mov	 ecx, edi
  001b5	ff 10		 call	 DWORD PTR [eax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  001b7	8d 47 08	 lea	 eax, DWORD PTR [edi+8]
  001ba	8b d6		 mov	 edx, esi
  001bc	f0 0f c1 10	 lock	  xadd	 DWORD PTR [eax], edx
  001c0	75 07		 jne	 SHORT $LN69@shouldRend

; 128  : 			_Delete_this();

  001c2	8b 07		 mov	 eax, DWORD PTR [edi]
  001c4	8b cf		 mov	 ecx, edi
  001c6	ff 50 04	 call	 DWORD PTR [eax+4]
$LN69@shouldRend:
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp

; 190  : 		&& world->getChunk(pos.x, pos.y, pos.z + 1)->cSouth.isAllSolid());

  001c9	c7 44 24 58 03
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+100], 3
  001d1	f6 c3 10	 test	 bl, 16			; 00000010H
  001d4	74 32		 je	 SHORT $LN80@shouldRend
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  001d6	8b 7c 24 28	 mov	 edi, DWORD PTR $T5[esp+96]
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp

; 190  : 		&& world->getChunk(pos.x, pos.y, pos.z + 1)->cSouth.isAllSolid());

  001da	83 e3 ef	 and	 ebx, -17		; ffffffefH
  001dd	89 5c 24 18	 mov	 DWORD PTR $T3[esp+92], ebx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  001e1	85 ff		 test	 edi, edi
  001e3	74 23		 je	 SHORT $LN80@shouldRend

; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  001e5	8d 47 04	 lea	 eax, DWORD PTR [edi+4]
  001e8	8b ce		 mov	 ecx, esi
  001ea	f0 0f c1 08	 lock	  xadd	 DWORD PTR [eax], ecx
  001ee	75 18		 jne	 SHORT $LN80@shouldRend

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  001f0	8b 07		 mov	 eax, DWORD PTR [edi]
  001f2	8b cf		 mov	 ecx, edi
  001f4	ff 10		 call	 DWORD PTR [eax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  001f6	8d 47 08	 lea	 eax, DWORD PTR [edi+8]
  001f9	8b d6		 mov	 edx, esi
  001fb	f0 0f c1 10	 lock	  xadd	 DWORD PTR [eax], edx
  001ff	75 07		 jne	 SHORT $LN80@shouldRend

; 128  : 			_Delete_this();

  00201	8b 07		 mov	 eax, DWORD PTR [edi]
  00203	8b cf		 mov	 ecx, edi
  00205	ff 50 04	 call	 DWORD PTR [eax+4]
$LN80@shouldRend:
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp

; 190  : 		&& world->getChunk(pos.x, pos.y, pos.z + 1)->cSouth.isAllSolid());

  00208	c7 44 24 58 02
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+100], 2
  00210	f6 c3 08	 test	 bl, 8
  00213	74 32		 je	 SHORT $LN91@shouldRend
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  00215	8b 7c 24 30	 mov	 edi, DWORD PTR $T6[esp+96]
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp

; 190  : 		&& world->getChunk(pos.x, pos.y, pos.z + 1)->cSouth.isAllSolid());

  00219	83 e3 f7	 and	 ebx, -9			; fffffff7H
  0021c	89 5c 24 18	 mov	 DWORD PTR $T3[esp+92], ebx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  00220	85 ff		 test	 edi, edi
  00222	74 23		 je	 SHORT $LN91@shouldRend

; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  00224	8d 47 04	 lea	 eax, DWORD PTR [edi+4]
  00227	8b ce		 mov	 ecx, esi
  00229	f0 0f c1 08	 lock	  xadd	 DWORD PTR [eax], ecx
  0022d	75 18		 jne	 SHORT $LN91@shouldRend

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  0022f	8b 07		 mov	 eax, DWORD PTR [edi]
  00231	8b cf		 mov	 ecx, edi
  00233	ff 10		 call	 DWORD PTR [eax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  00235	8d 47 08	 lea	 eax, DWORD PTR [edi+8]
  00238	8b d6		 mov	 edx, esi
  0023a	f0 0f c1 10	 lock	  xadd	 DWORD PTR [eax], edx
  0023e	75 07		 jne	 SHORT $LN91@shouldRend

; 128  : 			_Delete_this();

  00240	8b 07		 mov	 eax, DWORD PTR [edi]
  00242	8b cf		 mov	 ecx, edi
  00244	ff 50 04	 call	 DWORD PTR [eax+4]
$LN91@shouldRend:
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp

; 190  : 		&& world->getChunk(pos.x, pos.y, pos.z + 1)->cSouth.isAllSolid());

  00247	c7 44 24 58 01
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+100], 1
  0024f	f6 c3 04	 test	 bl, 4
  00252	74 32		 je	 SHORT $LN102@shouldRend
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  00254	8b 7c 24 38	 mov	 edi, DWORD PTR $T7[esp+96]
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp

; 190  : 		&& world->getChunk(pos.x, pos.y, pos.z + 1)->cSouth.isAllSolid());

  00258	83 e3 fb	 and	 ebx, -5			; fffffffbH
  0025b	89 5c 24 18	 mov	 DWORD PTR $T3[esp+92], ebx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  0025f	85 ff		 test	 edi, edi
  00261	74 23		 je	 SHORT $LN102@shouldRend

; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  00263	8d 47 04	 lea	 eax, DWORD PTR [edi+4]
  00266	8b ce		 mov	 ecx, esi
  00268	f0 0f c1 08	 lock	  xadd	 DWORD PTR [eax], ecx
  0026c	75 18		 jne	 SHORT $LN102@shouldRend

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  0026e	8b 07		 mov	 eax, DWORD PTR [edi]
  00270	8b cf		 mov	 ecx, edi
  00272	ff 10		 call	 DWORD PTR [eax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  00274	8d 47 08	 lea	 eax, DWORD PTR [edi+8]
  00277	8b d6		 mov	 edx, esi
  00279	f0 0f c1 10	 lock	  xadd	 DWORD PTR [eax], edx
  0027d	75 07		 jne	 SHORT $LN102@shouldRend

; 128  : 			_Delete_this();

  0027f	8b 07		 mov	 eax, DWORD PTR [edi]
  00281	8b cf		 mov	 ecx, edi
  00283	ff 50 04	 call	 DWORD PTR [eax+4]
$LN102@shouldRend:
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp

; 190  : 		&& world->getChunk(pos.x, pos.y, pos.z + 1)->cSouth.isAllSolid());

  00286	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+100], 0
  0028e	f6 c3 02	 test	 bl, 2
  00291	74 32		 je	 SHORT $LN113@shouldRend
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  00293	8b 7c 24 40	 mov	 edi, DWORD PTR $T8[esp+96]
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp

; 190  : 		&& world->getChunk(pos.x, pos.y, pos.z + 1)->cSouth.isAllSolid());

  00297	83 e3 fd	 and	 ebx, -3			; fffffffdH
  0029a	89 5c 24 18	 mov	 DWORD PTR $T3[esp+92], ebx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  0029e	85 ff		 test	 edi, edi
  002a0	74 23		 je	 SHORT $LN113@shouldRend

; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  002a2	8d 47 04	 lea	 eax, DWORD PTR [edi+4]
  002a5	8b ce		 mov	 ecx, esi
  002a7	f0 0f c1 08	 lock	  xadd	 DWORD PTR [eax], ecx
  002ab	75 18		 jne	 SHORT $LN113@shouldRend

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  002ad	8b 07		 mov	 eax, DWORD PTR [edi]
  002af	8b cf		 mov	 ecx, edi
  002b1	ff 10		 call	 DWORD PTR [eax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  002b3	8d 47 08	 lea	 eax, DWORD PTR [edi+8]
  002b6	8b d6		 mov	 edx, esi
  002b8	f0 0f c1 10	 lock	  xadd	 DWORD PTR [eax], edx
  002bc	75 07		 jne	 SHORT $LN113@shouldRend

; 128  : 			_Delete_this();

  002be	8b 07		 mov	 eax, DWORD PTR [edi]
  002c0	8b cf		 mov	 ecx, edi
  002c2	ff 50 04	 call	 DWORD PTR [eax+4]
$LN113@shouldRend:
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp

; 190  : 		&& world->getChunk(pos.x, pos.y, pos.z + 1)->cSouth.isAllSolid());

  002c5	c7 44 24 58 ff
	ff ff ff	 mov	 DWORD PTR __$EHRec$[esp+100], -1
  002cd	f6 c3 01	 test	 bl, 1
  002d0	74 2a		 je	 SHORT $LN130@shouldRend
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  002d2	8b 7c 24 48	 mov	 edi, DWORD PTR $T9[esp+96]
  002d6	85 ff		 test	 edi, edi
  002d8	74 22		 je	 SHORT $LN130@shouldRend

; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  002da	8d 47 04	 lea	 eax, DWORD PTR [edi+4]
  002dd	8b ce		 mov	 ecx, esi
  002df	f0 0f c1 08	 lock	  xadd	 DWORD PTR [eax], ecx
  002e3	75 17		 jne	 SHORT $LN130@shouldRend

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  002e5	8b 07		 mov	 eax, DWORD PTR [edi]
  002e7	8b cf		 mov	 ecx, edi
  002e9	ff 10		 call	 DWORD PTR [eax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  002eb	8d 57 08	 lea	 edx, DWORD PTR [edi+8]
  002ee	f0 0f c1 32	 lock	  xadd	 DWORD PTR [edx], esi
  002f2	4e		 dec	 esi
  002f3	75 07		 jne	 SHORT $LN130@shouldRend

; 128  : 			_Delete_this();

  002f5	8b 17		 mov	 edx, DWORD PTR [edi]
  002f7	8b cf		 mov	 ecx, edi
  002f9	ff 52 04	 call	 DWORD PTR [edx+4]
$LN130@shouldRend:
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp

; 190  : 		&& world->getChunk(pos.x, pos.y, pos.z + 1)->cSouth.isAllSolid());

  002fc	8a 44 24 17	 mov	 al, BYTE PTR $T2[esp+92]

; 191  : }

  00300	8b 4c 24 50	 mov	 ecx, DWORD PTR __$EHRec$[esp+92]
  00304	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0030b	59		 pop	 ecx
  0030c	5f		 pop	 edi
  0030d	5e		 pop	 esi
  0030e	5b		 pop	 ebx
  0030f	8b e5		 mov	 esp, ebp
  00311	5d		 pop	 ebp
  00312	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?shouldRender@Chunk@@UAE_NXZ$0:
  00000	8b 45 bc	 mov	 eax, DWORD PTR $T3[ebp]
  00003	83 e0 01	 and	 eax, 1
  00006	0f 84 0c 00 00
	00		 je	 $LN6@shouldRend
  0000c	83 65 bc fe	 and	 DWORD PTR $T3[ebp], -2	; fffffffeH
  00010	8d 4d e8	 lea	 ecx, DWORD PTR $T9[ebp]
  00013	e9 00 00 00 00	 jmp	 ??1?$shared_ptr@VChunkBase@@@std@@QAE@XZ ; std::shared_ptr<ChunkBase>::~shared_ptr<ChunkBase>
$LN6@shouldRend:
  00018	c3		 ret	 0
__unwindfunclet$?shouldRender@Chunk@@UAE_NXZ$1:
  00019	8b 45 bc	 mov	 eax, DWORD PTR $T3[ebp]
  0001c	83 e0 02	 and	 eax, 2
  0001f	0f 84 0c 00 00
	00		 je	 $LN8@shouldRend
  00025	83 65 bc fd	 and	 DWORD PTR $T3[ebp], -3	; fffffffdH
  00029	8d 4d e0	 lea	 ecx, DWORD PTR $T8[ebp]
  0002c	e9 00 00 00 00	 jmp	 ??1?$shared_ptr@VChunkBase@@@std@@QAE@XZ ; std::shared_ptr<ChunkBase>::~shared_ptr<ChunkBase>
$LN8@shouldRend:
  00031	c3		 ret	 0
__unwindfunclet$?shouldRender@Chunk@@UAE_NXZ$2:
  00032	8b 45 bc	 mov	 eax, DWORD PTR $T3[ebp]
  00035	83 e0 04	 and	 eax, 4
  00038	0f 84 0c 00 00
	00		 je	 $LN10@shouldRend
  0003e	83 65 bc fb	 and	 DWORD PTR $T3[ebp], -5	; fffffffbH
  00042	8d 4d d8	 lea	 ecx, DWORD PTR $T7[ebp]
  00045	e9 00 00 00 00	 jmp	 ??1?$shared_ptr@VChunkBase@@@std@@QAE@XZ ; std::shared_ptr<ChunkBase>::~shared_ptr<ChunkBase>
$LN10@shouldRend:
  0004a	c3		 ret	 0
__unwindfunclet$?shouldRender@Chunk@@UAE_NXZ$3:
  0004b	8b 45 bc	 mov	 eax, DWORD PTR $T3[ebp]
  0004e	83 e0 08	 and	 eax, 8
  00051	0f 84 0c 00 00
	00		 je	 $LN12@shouldRend
  00057	83 65 bc f7	 and	 DWORD PTR $T3[ebp], -9	; fffffff7H
  0005b	8d 4d d0	 lea	 ecx, DWORD PTR $T6[ebp]
  0005e	e9 00 00 00 00	 jmp	 ??1?$shared_ptr@VChunkBase@@@std@@QAE@XZ ; std::shared_ptr<ChunkBase>::~shared_ptr<ChunkBase>
$LN12@shouldRend:
  00063	c3		 ret	 0
__unwindfunclet$?shouldRender@Chunk@@UAE_NXZ$4:
  00064	8b 45 bc	 mov	 eax, DWORD PTR $T3[ebp]
  00067	83 e0 10	 and	 eax, 16			; 00000010H
  0006a	0f 84 0c 00 00
	00		 je	 $LN14@shouldRend
  00070	83 65 bc ef	 and	 DWORD PTR $T3[ebp], -17	; ffffffefH
  00074	8d 4d c8	 lea	 ecx, DWORD PTR $T5[ebp]
  00077	e9 00 00 00 00	 jmp	 ??1?$shared_ptr@VChunkBase@@@std@@QAE@XZ ; std::shared_ptr<ChunkBase>::~shared_ptr<ChunkBase>
$LN14@shouldRend:
  0007c	c3		 ret	 0
__ehhandler$?shouldRender@Chunk@@UAE_NXZ:
  0007d	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00081	8d 42 b4	 lea	 eax, DWORD PTR [edx-76]
  00084	8b 4a b0	 mov	 ecx, DWORD PTR [edx-80]
  00087	33 c8		 xor	 ecx, eax
  00089	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0008e	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?shouldRender@Chunk@@UAE_NXZ
  00093	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?shouldRender@Chunk@@UAE_NXZ ENDP			; Chunk::shouldRender
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??1?$map@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@@std@@QAE@XZ
_TEXT	SEGMENT
$T1 = -4						; size = 4
??1?$map@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@@std@@QAE@XZ PROC ; std::map<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::~map<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree

; 2216 : 		erase(begin(), end());

  00007	8b 06		 mov	 eax, DWORD PTR [esi]
  00009	50		 push	 eax
  0000a	ff 30		 push	 DWORD PTR [eax]
  0000c	8d 45 fc	 lea	 eax, DWORD PTR $T1[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::erase
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 586  : 		::operator delete(_Ptr);

  00015	ff 36		 push	 DWORD PTR [esi]
  00017	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0001c	83 c4 04	 add	 esp, 4
  0001f	5e		 pop	 esi
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
??1?$map@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@@std@@QAE@XZ ENDP ; std::map<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::~map<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
;	COMDAT ?getChunkFromBlockCoordinate@World@@QAE?AV?$shared_ptr@VChunkBase@@@std@@HHH@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
_z$ = 20						; size = 4
?getChunkFromBlockCoordinate@World@@QAE?AV?$shared_ptr@VChunkBase@@@std@@HHH@Z PROC ; World::getChunkFromBlockCoordinate, COMDAT
; _this$ = ecx

; 220  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 221  : 	return getChunk(x >> 4, y >> 4, z >> 4);

  00004	8b 45 14	 mov	 eax, DWORD PTR _z$[ebp]
  00007	c1 f8 04	 sar	 eax, 4
  0000a	50		 push	 eax
  0000b	8b 45 10	 mov	 eax, DWORD PTR _y$[ebp]
  0000e	c1 f8 04	 sar	 eax, 4
  00011	50		 push	 eax
  00012	8b 45 0c	 mov	 eax, DWORD PTR _x$[ebp]
  00015	c1 f8 04	 sar	 eax, 4
  00018	50		 push	 eax
  00019	ff 75 08	 push	 DWORD PTR ___$ReturnUdt$[ebp]
  0001c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR $T1[ebp], 0
  00023	e8 00 00 00 00	 call	 ?getChunk@World@@QAE?AV?$shared_ptr@VChunkBase@@@std@@HHH@Z ; World::getChunk
  00028	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 222  : }

  0002b	8b e5		 mov	 esp, ebp
  0002d	5d		 pop	 ebp
  0002e	c2 10 00	 ret	 16			; 00000010H
?getChunkFromBlockCoordinate@World@@QAE?AV?$shared_ptr@VChunkBase@@@std@@HHH@Z ENDP ; World::getChunkFromBlockCoordinate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
;	COMDAT ?setBlock@World@@QAEXHHHG@Z
_TEXT	SEGMENT
_c$2 = -52						; size = 8
_chunk$ = -44						; size = 8
tv521 = -32						; size = 4
tv520 = -28						; size = 4
tv518 = -24						; size = 4
_this$1$ = -20						; size = 4
tv524 = -16						; size = 4
tv519 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_j$1$ = 8						; size = 4
_x$ = 8							; size = 4
_k$1$ = 12						; size = 4
_y$ = 12						; size = 4
_z$ = 16						; size = 4
_i$1$ = 20						; size = 4
_id$ = 20						; size = 2
?setBlock@World@@QAEXHHHG@Z PROC			; World::setBlock, COMDAT
; _this$ = ecx

; 249  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?setBlock@World@@QAEXHHHG@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	8b c1		 mov	 eax, ecx
  0002a	89 45 ec	 mov	 DWORD PTR _this$1$[ebp], eax

; 250  : 	std::shared_ptr<ChunkBase> chunk = getChunkFromBlockCoordinate(x, y, z);

  0002d	ff 75 10	 push	 DWORD PTR _z$[ebp]
  00030	8b 7d 0c	 mov	 edi, DWORD PTR _y$[ebp]
  00033	8b 75 08	 mov	 esi, DWORD PTR _x$[ebp]
  00036	57		 push	 edi
  00037	56		 push	 esi
  00038	8d 4d d4	 lea	 ecx, DWORD PTR _chunk$[ebp]
  0003b	51		 push	 ecx
  0003c	8b c8		 mov	 ecx, eax
  0003e	e8 00 00 00 00	 call	 ?getChunkFromBlockCoordinate@World@@QAE?AV?$shared_ptr@VChunkBase@@@std@@HHH@Z ; World::getChunkFromBlockCoordinate
  00043	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 251  : 
; 252  : 	if(!chunk->isEmpty() && chunk->isLoaded())

  0004a	8b 4d d4	 mov	 ecx, DWORD PTR _chunk$[ebp]
  0004d	8b 01		 mov	 eax, DWORD PTR [ecx]
  0004f	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00052	ff d0		 call	 eax
  00054	83 cb ff	 or	 ebx, -1
  00057	84 c0		 test	 al, al
  00059	0f 85 86 01 00
	00		 jne	 $LN8@setBlock

; 65   : 	return loaded;

  0005f	8b 55 d4	 mov	 edx, DWORD PTR _chunk$[ebp]
  00062	8a 42 05	 mov	 al, BYTE PTR [edx+5]

; 251  : 
; 252  : 	if(!chunk->isEmpty() && chunk->isLoaded())

  00065	84 c0		 test	 al, al
  00067	0f 84 78 01 00
	00		 je	 $LN8@setBlock

; 253  : 	{
; 254  : 		bool sameBlock = chunk->getBlock(x & 0xf, y & 0xf, z & 0xf) == id;

  0006d	8b 4d 10	 mov	 ecx, DWORD PTR _z$[ebp]
  00070	8b 02		 mov	 eax, DWORD PTR [edx]
  00072	83 e1 0f	 and	 ecx, 15			; 0000000fH
  00075	51		 push	 ecx
  00076	83 e7 0f	 and	 edi, 15			; 0000000fH
  00079	57		 push	 edi
  0007a	89 4d f0	 mov	 DWORD PTR tv524[ebp], ecx
  0007d	83 e6 0f	 and	 esi, 15			; 0000000fH
  00080	56		 push	 esi
  00081	8b ca		 mov	 ecx, edx
  00083	ff 10		 call	 DWORD PTR [eax]
  00085	8b 55 14	 mov	 edx, DWORD PTR _id$[ebp]

; 255  : 		chunk->setBlock(x & 0xf, y & 0xf, z & 0xf, id);

  00088	8b 4d d4	 mov	 ecx, DWORD PTR _chunk$[ebp]
  0008b	52		 push	 edx
  0008c	ff 75 f0	 push	 DWORD PTR tv524[ebp]
  0008f	66 3b c2	 cmp	 ax, dx
  00092	8b 01		 mov	 eax, DWORD PTR [ecx]
  00094	57		 push	 edi
  00095	56		 push	 esi
  00096	0f 94 c3	 sete	 bl
  00099	ff 50 04	 call	 DWORD PTR [eax+4]

; 256  : 		if(!sameBlock)

  0009c	84 db		 test	 bl, bl
  0009e	0f 85 3e 01 00
	00		 jne	 $LN98@setBlock

; 257  : 		{
; 258  : 			for(int i = x - 1; i <= x + 1; i++)

  000a4	8b 45 08	 mov	 eax, DWORD PTR _x$[ebp]
  000a7	8d 50 ff	 lea	 edx, DWORD PTR [eax-1]
  000aa	40		 inc	 eax
  000ab	89 55 14	 mov	 DWORD PTR _i$1$[ebp], edx
  000ae	89 45 e0	 mov	 DWORD PTR tv521[ebp], eax
  000b1	3b d0		 cmp	 edx, eax
  000b3	0f 8f 29 01 00
	00		 jg	 $LN98@setBlock
  000b9	8b 45 0c	 mov	 eax, DWORD PTR _y$[ebp]
  000bc	8d 58 ff	 lea	 ebx, DWORD PTR [eax-1]
  000bf	8d 48 01	 lea	 ecx, DWORD PTR [eax+1]
  000c2	89 5d e4	 mov	 DWORD PTR tv520[ebp], ebx
  000c5	89 4d f0	 mov	 DWORD PTR tv519[ebp], ecx
$LL10@setBlock:

; 259  : 			{
; 260  : 				for(int j = y - 1; j <= y + 1; j++)

  000c8	8b c3		 mov	 eax, ebx
  000ca	89 5d 08	 mov	 DWORD PTR _j$1$[ebp], ebx
  000cd	3b c1		 cmp	 eax, ecx
  000cf	0f 8f 00 01 00
	00		 jg	 $LN9@setBlock
  000d5	8b 4d 10	 mov	 ecx, DWORD PTR _z$[ebp]
  000d8	8d 59 ff	 lea	 ebx, DWORD PTR [ecx-1]
  000db	89 5d e8	 mov	 DWORD PTR tv518[ebp], ebx
  000de	41		 inc	 ecx
  000df	90		 npad	 1
$LL7@setBlock:

; 262  : 					for(int k = z - 1; k <= z + 1; k++)

  000e0	89 5d 0c	 mov	 DWORD PTR _k$1$[ebp], ebx
  000e3	3b d9		 cmp	 ebx, ecx
  000e5	0f 8f d4 00 00
	00		 jg	 $LN6@setBlock
  000eb	eb 03 8d 49 00	 npad	 5
$LL4@setBlock:

; 263  : 					{
; 264  : 						std::shared_ptr<ChunkBase> c = getChunkFromBlockCoordinate(i, j, k);

  000f0	8b 4d ec	 mov	 ecx, DWORD PTR _this$1$[ebp]
  000f3	53		 push	 ebx
  000f4	50		 push	 eax
  000f5	52		 push	 edx
  000f6	8d 45 cc	 lea	 eax, DWORD PTR _c$2[ebp]
  000f9	50		 push	 eax
  000fa	e8 00 00 00 00	 call	 ?getChunkFromBlockCoordinate@World@@QAE?AV?$shared_ptr@VChunkBase@@@std@@HHH@Z ; World::getChunkFromBlockCoordinate
  000ff	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1

; 265  : 						if(!c->isEmpty())

  00103	8b 75 cc	 mov	 esi, DWORD PTR _c$2[ebp]
  00106	8b ce		 mov	 ecx, esi
  00108	8b 06		 mov	 eax, DWORD PTR [esi]
  0010a	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  0010d	ff d0		 call	 eax
  0010f	8b 7d d0	 mov	 edi, DWORD PTR _c$2[ebp+4]
  00112	84 c0		 test	 al, al
  00114	75 65		 jne	 SHORT $LN1@setBlock

; 66   : }
; 67   : 
; 68   : void ChunkBase::setUnloaded()
; 69   : {
; 70   : 	unloaded = true;
; 71   : }
; 72   : 
; 73   : bool ChunkBase::isUnloaded()
; 74   : {
; 75   : 	return unloaded;
; 76   : }
; 77   : 
; 78   : bool ChunkBase::shouldRender()
; 79   : {
; 80   : 	return false;
; 81   : }
; 82   : 
; 83   : void ChunkBase::setRenderUpdateNeeded(bool flag)
; 84   : {
; 85   : 	renderUpdateNeeded = flag;

  00116	c6 46 04 01	 mov	 BYTE PTR [esi+4], 1

; 268  : 							requestQuickChunkDraw(c);

  0011a	83 ec 08	 sub	 esp, 8
  0011d	8b f4		 mov	 esi, esp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 282  : 		{	// construct

  0011f	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  00125	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 346  : 			_Rep->_Decref();
; 347  : 		}
; 348  : 
; 349  : 	void _Reset()
; 350  : 		{	// release resource
; 351  : 		_Reset(0, 0);
; 352  : 		}
; 353  : 
; 354  : 	template<class _Ty2>
; 355  : 		void _Reset(const _Ptr_base<_Ty2>& _Other)
; 356  : 		{	// release resource and take ownership of _Other._Ptr
; 357  : 		_Reset(_Other._Ptr, _Other._Rep);
; 358  : 		}
; 359  : 
; 360  : 	template<class _Ty2>
; 361  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, bool _Throw)
; 362  : 		{	// release resource and take ownership from weak_ptr _Other._Ptr
; 363  : 		_Reset(_Other._Ptr, _Other._Rep, _Throw);
; 364  : 		}
; 365  : 
; 366  : 	template<class _Ty2>
; 367  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Static_tag&)
; 368  : 		{	// release resource and take ownership of _Other._Ptr
; 369  : 		_Reset(static_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 370  : 		}
; 371  : 
; 372  : 	template<class _Ty2>
; 373  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Const_tag&)
; 374  : 		{	// release resource and take ownership of _Other._Ptr
; 375  : 		_Reset(const_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 376  : 		}
; 377  : 
; 378  : 	template<class _Ty2>
; 379  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Dynamic_tag&)
; 380  : 		{	// release resource and take ownership of _Other._Ptr
; 381  : 		_Elem *_Ptr = dynamic_cast<_Elem *>(_Other._Ptr);
; 382  : 		if (_Ptr)
; 383  : 			_Reset(_Ptr, _Other._Rep);
; 384  : 		else
; 385  : 			_Reset();
; 386  : 		}
; 387  : 
; 388  : 	template<class _Ty2>
; 389  : 		void _Reset(auto_ptr<_Ty2>&& _Other)
; 390  : 		{	// release resource and take _Other.get()
; 391  : 		_Ty2 *_Px = _Other.get();
; 392  : 		_Reset0(_Px, new _Ref_count<_Elem>(_Px));
; 393  : 		_Other.release();
; 394  : 		_Enable_shared(_Px, _Rep);
; 395  : 		}
; 396  : 
; 397  :  #if _HAS_CPP0X
; 398  : 	template<class _Ty2>
; 399  : 		void _Reset(_Ty *_Ptr, const _Ptr_base<_Ty2>& _Other)
; 400  : 		{	// release resource and alias _Ptr with _Other_rep
; 401  : 		_Reset(_Ptr, _Other._Rep);
; 402  : 		}
; 403  :  #endif /* _HAS_CPP0X */
; 404  : 
; 405  : 	void _Reset(_Ty *_Other_ptr, _Ref_count_base *_Other_rep)
; 406  : 		{	// release resource and take _Other_ptr through _Other_rep
; 407  : 		if (_Other_rep)

  0012c	85 ff		 test	 edi, edi
  0012e	74 0c		 je	 SHORT $LN55@setBlock

; 108  : 		_MT_INCR(_Ignored, _Uses);

  00130	8d 47 04	 lea	 eax, DWORD PTR [edi+4]
  00133	b9 01 00 00 00	 mov	 ecx, 1
  00138	f0 0f c1 08	 lock	  xadd	 DWORD PTR [eax], ecx
$LN55@setBlock:

; 408  : 			_Other_rep->_Incref();
; 409  : 		_Reset0(_Other_ptr, _Other_rep);
; 410  : 		}
; 411  : 
; 412  : 	void _Reset(_Ty *_Other_ptr, _Ref_count_base *_Other_rep, bool _Throw)
; 413  : 		{	// take _Other_ptr through _Other_rep from weak_ptr if not expired
; 414  : 			// otherwise, leave in default state if !_Throw,
; 415  : 			// otherwise throw exception
; 416  : 		if (_Other_rep && _Other_rep->_Incref_nz())
; 417  : 			_Reset0(_Other_ptr, _Other_rep);
; 418  : 		else if (_Throw)
; 419  : 			_THROW_NCEE(bad_weak_ptr, 0);
; 420  : 		}
; 421  : 
; 422  : 	void _Reset0(_Ty *_Other_ptr, _Ref_count_base *_Other_rep)
; 423  : 		{	// release resource and take new resource
; 424  : 		if (_Rep != 0)

  0013c	8b 5e 04	 mov	 ebx, DWORD PTR [esi+4]
  0013f	85 db		 test	 ebx, ebx
  00141	74 25		 je	 SHORT $LN63@setBlock

; 109  : 		}
; 110  : 
; 111  : 	void _Incwref()
; 112  : 		{	// increment weak reference count
; 113  : 		_MT_INCR(_Ignored, _Weaks);
; 114  : 		}
; 115  : 
; 116  : 	void _Decref()
; 117  : 		{	// decrement use count
; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  00143	8d 43 04	 lea	 eax, DWORD PTR [ebx+4]
  00146	83 c9 ff	 or	 ecx, -1
  00149	f0 0f c1 08	 lock	  xadd	 DWORD PTR [eax], ecx
  0014d	75 19		 jne	 SHORT $LN63@setBlock

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  0014f	8b 03		 mov	 eax, DWORD PTR [ebx]
  00151	8b cb		 mov	 ecx, ebx
  00153	ff 10		 call	 DWORD PTR [eax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  00155	8d 43 08	 lea	 eax, DWORD PTR [ebx+8]
  00158	83 ca ff	 or	 edx, -1
  0015b	f0 0f c1 10	 lock	  xadd	 DWORD PTR [eax], edx
  0015f	75 07		 jne	 SHORT $LN63@setBlock

; 128  : 			_Delete_this();

  00161	8b 03		 mov	 eax, DWORD PTR [ebx]
  00163	8b cb		 mov	 ecx, ebx
  00165	ff 50 04	 call	 DWORD PTR [eax+4]
$LN63@setBlock:

; 425  : 			_Rep->_Decref();
; 426  : 		_Rep = _Other_rep;
; 427  : 		_Ptr = _Other_ptr;

  00168	8b 45 cc	 mov	 eax, DWORD PTR _c$2[ebp]
  0016b	89 7e 04	 mov	 DWORD PTR [esi+4], edi
  0016e	89 06		 mov	 DWORD PTR [esi], eax
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp

; 268  : 							requestQuickChunkDraw(c);

  00170	e8 00 00 00 00	 call	 ?requestQuickChunkDraw@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z ; requestQuickChunkDraw
  00175	8b 5d 0c	 mov	 ebx, DWORD PTR _k$1$[ebp]
  00178	83 c4 08	 add	 esp, 8
$LN1@setBlock:

; 269  : 						}
; 270  : 					}

  0017b	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  0017f	85 ff		 test	 edi, edi
  00181	74 26		 je	 SHORT $LN3@setBlock

; 109  : 		}
; 110  : 
; 111  : 	void _Incwref()
; 112  : 		{	// increment weak reference count
; 113  : 		_MT_INCR(_Ignored, _Weaks);
; 114  : 		}
; 115  : 
; 116  : 	void _Decref()
; 117  : 		{	// decrement use count
; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  00183	83 ce ff	 or	 esi, -1
  00186	8d 47 04	 lea	 eax, DWORD PTR [edi+4]
  00189	8b ce		 mov	 ecx, esi
  0018b	f0 0f c1 08	 lock	  xadd	 DWORD PTR [eax], ecx
  0018f	75 18		 jne	 SHORT $LN3@setBlock

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  00191	8b 07		 mov	 eax, DWORD PTR [edi]
  00193	8b cf		 mov	 ecx, edi
  00195	ff 10		 call	 DWORD PTR [eax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  00197	8d 47 08	 lea	 eax, DWORD PTR [edi+8]
  0019a	8b d6		 mov	 edx, esi
  0019c	f0 0f c1 10	 lock	  xadd	 DWORD PTR [eax], edx
  001a0	75 07		 jne	 SHORT $LN3@setBlock

; 128  : 			_Delete_this();

  001a2	8b 07		 mov	 eax, DWORD PTR [edi]
  001a4	8b cf		 mov	 ecx, edi
  001a6	ff 50 04	 call	 DWORD PTR [eax+4]
$LN3@setBlock:
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp

; 262  : 					for(int k = z - 1; k <= z + 1; k++)

  001a9	8b 4d 10	 mov	 ecx, DWORD PTR _z$[ebp]
  001ac	8b 45 08	 mov	 eax, DWORD PTR _j$1$[ebp]
  001af	8b 55 14	 mov	 edx, DWORD PTR _i$1$[ebp]
  001b2	43		 inc	 ebx
  001b3	41		 inc	 ecx
  001b4	89 5d 0c	 mov	 DWORD PTR _k$1$[ebp], ebx
  001b7	3b d9		 cmp	 ebx, ecx
  001b9	0f 8e 31 ff ff
	ff		 jle	 $LL4@setBlock
$LN6@setBlock:

; 259  : 			{
; 260  : 				for(int j = y - 1; j <= y + 1; j++)

  001bf	8b 5d e8	 mov	 ebx, DWORD PTR tv518[ebp]
  001c2	40		 inc	 eax
  001c3	89 45 08	 mov	 DWORD PTR _j$1$[ebp], eax
  001c6	3b 45 f0	 cmp	 eax, DWORD PTR tv519[ebp]
  001c9	0f 8e 11 ff ff
	ff		 jle	 $LL7@setBlock
  001cf	8b 4d f0	 mov	 ecx, DWORD PTR tv519[ebp]
  001d2	8b 5d e4	 mov	 ebx, DWORD PTR tv520[ebp]
$LN9@setBlock:

; 257  : 		{
; 258  : 			for(int i = x - 1; i <= x + 1; i++)

  001d5	42		 inc	 edx
  001d6	89 55 14	 mov	 DWORD PTR _i$1$[ebp], edx
  001d9	3b 55 e0	 cmp	 edx, DWORD PTR tv521[ebp]
  001dc	0f 8e e6 fe ff
	ff		 jle	 $LL10@setBlock
$LN98@setBlock:
  001e2	83 cb ff	 or	 ebx, -1
$LN8@setBlock:

; 275  : }

  001e5	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  001ec	8b 75 d8	 mov	 esi, DWORD PTR _chunk$[ebp+4]
  001ef	85 f6		 test	 esi, esi
  001f1	74 22		 je	 SHORT $LN85@setBlock

; 109  : 		}
; 110  : 
; 111  : 	void _Incwref()
; 112  : 		{	// increment weak reference count
; 113  : 		_MT_INCR(_Ignored, _Weaks);
; 114  : 		}
; 115  : 
; 116  : 	void _Decref()
; 117  : 		{	// decrement use count
; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  001f3	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  001f6	8b cb		 mov	 ecx, ebx
  001f8	f0 0f c1 08	 lock	  xadd	 DWORD PTR [eax], ecx
  001fc	75 17		 jne	 SHORT $LN85@setBlock

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  001fe	8b 06		 mov	 eax, DWORD PTR [esi]
  00200	8b ce		 mov	 ecx, esi
  00202	ff 10		 call	 DWORD PTR [eax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  00204	8d 46 08	 lea	 eax, DWORD PTR [esi+8]
  00207	f0 0f c1 18	 lock	  xadd	 DWORD PTR [eax], ebx
  0020b	4b		 dec	 ebx
  0020c	75 07		 jne	 SHORT $LN85@setBlock

; 128  : 			_Delete_this();

  0020e	8b 06		 mov	 eax, DWORD PTR [esi]
  00210	8b ce		 mov	 ecx, esi
  00212	ff 50 04	 call	 DWORD PTR [eax+4]
$LN85@setBlock:
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp

; 275  : }

  00215	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00218	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0021f	59		 pop	 ecx
  00220	5f		 pop	 edi
  00221	5e		 pop	 esi
  00222	5b		 pop	 ebx
  00223	8b e5		 mov	 esp, ebp
  00225	5d		 pop	 ebp
  00226	c2 10 00	 ret	 16			; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?setBlock@World@@QAEXHHHG@Z$0:
  00000	8d 4d d4	 lea	 ecx, DWORD PTR _chunk$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$shared_ptr@VChunkBase@@@std@@QAE@XZ ; std::shared_ptr<ChunkBase>::~shared_ptr<ChunkBase>
__unwindfunclet$?setBlock@World@@QAEXHHHG@Z$1:
  00008	8d 4d cc	 lea	 ecx, DWORD PTR _c$2[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1?$shared_ptr@VChunkBase@@@std@@QAE@XZ ; std::shared_ptr<ChunkBase>::~shared_ptr<ChunkBase>
__ehhandler$?setBlock@World@@QAEXHHHG@Z:
  00010	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00014	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00017	8b 4a c4	 mov	 ecx, DWORD PTR [edx-60]
  0001a	33 c8		 xor	 ecx, eax
  0001c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00021	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?setBlock@World@@QAEXHHHG@Z
  00026	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?setBlock@World@@QAEXHHHG@Z ENDP			; World::setBlock
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
;	COMDAT ??M@YA_NABVChunkPosition@@0@Z
_TEXT	SEGMENT
??M@YA_NABVChunkPosition@@0@Z PROC			; operator<, COMDAT
; _cp1$ = ecx
; _cp2$ = edx

; 296  : 	if(cp1.x < cp2.x)

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	56		 push	 esi
  00003	8b 32		 mov	 esi, DWORD PTR [edx]
  00005	3b c6		 cmp	 eax, esi
  00007	7d 04		 jge	 SHORT $LN9@operator
$LN11@operator:

; 297  : 	{
; 298  : 		return true;

  00009	b0 01		 mov	 al, 1
  0000b	5e		 pop	 esi

; 313  : }

  0000c	c3		 ret	 0
$LN9@operator:

; 299  : 	}
; 300  : 	else if(cp1.x == cp2.x)

  0000d	75 19		 jne	 SHORT $LN1@operator

; 301  : 	{
; 302  : 		if(cp1.y < cp2.y)

  0000f	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00012	8b 72 04	 mov	 esi, DWORD PTR [edx+4]
  00015	3b c6		 cmp	 eax, esi
  00017	7c f0		 jl	 SHORT $LN11@operator

; 303  : 		{
; 304  : 			return true;
; 305  : 		}
; 306  : 		else if(cp1.y == cp2.y)

  00019	75 0d		 jne	 SHORT $LN1@operator

; 307  : 		{
; 308  : 			return cp1.z < cp2.z;

  0001b	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  0001e	33 c0		 xor	 eax, eax
  00020	3b 4a 08	 cmp	 ecx, DWORD PTR [edx+8]
  00023	5e		 pop	 esi
  00024	0f 9c c0	 setl	 al

; 313  : }

  00027	c3		 ret	 0
$LN1@operator:

; 309  : 		}
; 310  : 	}
; 311  : 
; 312  : 	return false;

  00028	32 c0		 xor	 al, al
  0002a	5e		 pop	 esi

; 313  : }

  0002b	c3		 ret	 0
??M@YA_NABVChunkPosition@@0@Z ENDP			; operator<
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ??0?$shared_ptr@VVertexStream@gfxu@@@std@@QAE@$$T@Z
_TEXT	SEGMENT
___formal$dead$ = 8					; size = 4
??0?$shared_ptr@VVertexStream@gfxu@@@std@@QAE@$$T@Z PROC ; std::shared_ptr<gfxu::VertexStream>::shared_ptr<gfxu::VertexStream>, COMDAT
; _this$ = ecx

; 499  : 	shared_ptr(nullptr_t)

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 500  : 		{	// construct with nullptr
; 501  : 		_Resetp((_Ty *)0);

  00003	6a 00		 push	 0

; 282  : 		{	// construct

  00005	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  0000b	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 500  : 		{	// construct with nullptr
; 501  : 		_Resetp((_Ty *)0);

  00012	e8 00 00 00 00	 call	 ??$_Resetp@VVertexStream@gfxu@@@?$shared_ptr@VVertexStream@gfxu@@@std@@AAEXPAVVertexStream@gfxu@@@Z ; std::shared_ptr<gfxu::VertexStream>::_Resetp<gfxu::VertexStream>

; 502  : 		}

  00017	8b c6		 mov	 eax, esi
  00019	5e		 pop	 esi
  0001a	c2 04 00	 ret	 4
??0?$shared_ptr@VVertexStream@gfxu@@@std@@QAE@$$T@Z ENDP ; std::shared_ptr<gfxu::VertexStream>::shared_ptr<gfxu::VertexStream>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\map
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\map
;	COMDAT ??0?$map@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$map@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@@std@@QAE@XZ PROC ; std::map<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::map<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >, COMDAT
; _this$ = ecx

; 92   : 		{	// construct empty map from defaults

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree

; 573  : 		this->_Myhead = 0;

  00003	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 574  : 		this->_Mysize = 0;

  00009	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 575  : 		}
; 576  : 
; 577  : 	enum _Redbl
; 578  : 		{	// colors for link to parent
; 579  : 		_Red, _Black};
; 580  : 
; 581  : 	static char& _Color(_Nodeptr _Pnode)
; 582  : 		{	// return reference to color in node
; 583  : 		return ((char&)_Pnode->_Color);
; 584  : 		}
; 585  : 
; 586  : 	static char& _Isnil(_Nodeptr _Pnode)
; 587  : 		{	// return reference to nil flag in node
; 588  : 		return ((char&)_Pnode->_Isnil);
; 589  : 		}
; 590  : 
; 591  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 592  : 		{	// return reference to left pointer in node
; 593  : 		return ((_Nodepref)_Pnode->_Left);
; 594  : 		}
; 595  : 
; 596  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 597  : 		{	// return reference to parent pointer in node
; 598  : 		return ((_Nodepref)_Pnode->_Parent);
; 599  : 		}
; 600  : 
; 601  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 602  : 		{	// return reference to right pointer in node
; 603  : 		return ((_Nodepref)_Pnode->_Right);
; 604  : 		}
; 605  : 
; 606  : 	static reference _Myval(_Nodeptr _Pnode)
; 607  : 		{	// return reference to value in node
; 608  : 		return ((reference)_Pnode->_Myval);
; 609  : 		}
; 610  : 
; 611  : 	static _Nodeptr _Max(_Nodeptr _Pnode)
; 612  : 		{	// return rightmost node in subtree at _Pnode
; 613  : 		while (!_Isnil(_Right(_Pnode)))
; 614  : 			_Pnode = _Right(_Pnode);
; 615  : 		return (_Pnode);
; 616  : 		}
; 617  : 
; 618  : 	static _Nodeptr _Min(_Nodeptr _Pnode)
; 619  : 		{	// return leftmost node in subtree at _Pnode
; 620  : 		while (!_Isnil(_Left(_Pnode)))
; 621  : 			_Pnode = _Left(_Pnode);
; 622  : 		return (_Pnode);
; 623  : 		}
; 624  : 
; 625  : 	_Nodeptr _Myhead;	// pointer to head node
; 626  : 	size_type _Mysize;	// number of elements
; 627  : 	};
; 628  : 
; 629  : 		// TEMPLATE CLASS _Tree_alloc
; 630  : template<bool _Al_has_storage,
; 631  : 	class _Alloc_types>
; 632  : 	class _Tree_alloc
; 633  : 		: public _Tree_val<typename _Alloc_types::_Val_types>
; 634  : 	{	// base class for tree to hold allocator with storage
; 635  : public:
; 636  : 	typedef _Tree_alloc<_Al_has_storage, _Alloc_types> _Myt;
; 637  : 	typedef _Tree_val<typename _Alloc_types::_Val_types> _Mybase;
; 638  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 639  : 	typedef typename _Alloc_types::_Alnod_type _Alty;
; 640  : 	typedef typename _Alloc_types::_Node _Node;
; 641  : 	typedef typename _Alloc_types::_Nodeptr _Nodeptr;
; 642  : 
; 643  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 644  : 	_Tree_alloc(const _Alloc& _Al = _Alloc())
; 645  : 		: _Alnod(_Al)
; 646  : 		{	// construct head node, allocator from _Al
; 647  : 		this->_Myhead = _Buyheadnode();
; 648  : 		}
; 649  : 
; 650  : 	~_Tree_alloc() _NOEXCEPT
; 651  : 		{	// destroy head node
; 652  : 		_Freeheadnode(this->_Myhead);
; 653  : 		}
; 654  : 
; 655  : 	void _Change_alloc(const _Alty& _Al)
; 656  : 		{	// replace old allocator
; 657  : 		_Alnod = _Al;
; 658  : 		}
; 659  : 
; 660  : 	void _Swap_alloc(_Myt& _Right)
; 661  : 		{	// swap allocators
; 662  : 		_Swap_adl(_Alnod, _Right._Alnod);
; 663  : 		}
; 664  : 
; 665  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 666  : 	_Tree_alloc(const _Alloc& _Al = _Alloc())
; 667  : 		: _Alnod(_Al)
; 668  : 		{	// construct allocators from _Al
; 669  : 		this->_Myhead = _Buyheadnode();
; 670  : 		_TRY_BEGIN
; 671  : 		_Alloc_proxy();
; 672  : 		_CATCH_ALL
; 673  : 		_Freeheadnode(this->_Myhead);
; 674  : 		_RERAISE;
; 675  : 		_CATCH_END
; 676  : 		}
; 677  : 
; 678  : 	~_Tree_alloc() _NOEXCEPT
; 679  : 		{	// destroy proxy
; 680  : 		_Freeheadnode(this->_Myhead);
; 681  : 		_Free_proxy();
; 682  : 		}
; 683  : 
; 684  : 	void _Change_alloc(const _Alty& _Al)
; 685  : 		{	// replace old allocator
; 686  : 		_Free_proxy();
; 687  : 		_Alnod = _Al;
; 688  : 		_Alloc_proxy();
; 689  : 		}
; 690  : 
; 691  : 	void _Swap_alloc(_Myt& _Right)
; 692  : 		{	// swap allocators
; 693  : 		_Swap_adl(_Alnod, _Right._Alnod);
; 694  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 695  : 		}
; 696  : 
; 697  : 	void _Alloc_proxy()
; 698  : 		{	// construct proxy from _Alnod
; 699  : 		typename _Alty::template rebind<_Container_proxy>::other
; 700  : 			_Alproxy(_Alnod);
; 701  : 		this->_Myproxy = _Alproxy.allocate(1);
; 702  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 703  : 		this->_Myproxy->_Mycont = this;
; 704  : 		}
; 705  : 
; 706  : 	void _Free_proxy()
; 707  : 		{	// destroy proxy
; 708  : 		typename _Alty::template rebind<_Container_proxy>::other
; 709  : 			_Alproxy(_Alnod);
; 710  : 		this->_Orphan_all();
; 711  : 		_Alproxy.destroy(this->_Myproxy);
; 712  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 713  : 		this->_Myproxy = 0;
; 714  : 		}
; 715  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 716  : 
; 717  : 	_Nodeptr _Buyheadnode()
; 718  : 		{	// get head node using current allocator
; 719  : 		_Nodeptr _Pnode = _Alnod.allocate(1);
; 720  : 
; 721  : 		_TRY_BEGIN
; 722  : 		_Alnod.construct(
; 723  : 			_STD addressof(this->_Left(_Pnode)), _Pnode);
; 724  : 		_Alnod.construct(
; 725  : 			_STD addressof(this->_Parent(_Pnode)), _Pnode);
; 726  : 		_Alnod.construct(
; 727  : 			_STD addressof(this->_Right(_Pnode)), _Pnode);
; 728  : 		_CATCH_ALL
; 729  : 		_Alnod.deallocate(_Pnode, 1);
; 730  : 		_RERAISE;
; 731  : 		_CATCH_END
; 732  : 
; 733  : 		this->_Color(_Pnode) = this->_Black;
; 734  : 		this->_Isnil(_Pnode) = true;
; 735  : 		return (_Pnode);
; 736  : 		}
; 737  : 
; 738  : 	void _Freeheadnode(_Nodeptr _Pnode)
; 739  : 		{	// free head node using current allocator
; 740  : 		_Alnod.destroy(
; 741  : 			_STD addressof(this->_Left(_Pnode)));
; 742  : 		_Alnod.destroy(
; 743  : 			_STD addressof(this->_Parent(_Pnode)));
; 744  : 		_Alnod.destroy(
; 745  : 			_STD addressof(this->_Right(_Pnode)));
; 746  : 		_Alnod.deallocate(_Pnode, 1);
; 747  : 		}
; 748  : 
; 749  : 	_Alty& _Getal()
; 750  : 		{	// get reference to allocator
; 751  : 		return (_Alnod);
; 752  : 		}
; 753  : 
; 754  : 	const _Alty& _Getal() const
; 755  : 		{	// get reference to allocator
; 756  : 		return (_Alnod);
; 757  : 		}
; 758  : 
; 759  : 	_Alty _Alnod;	// allocator object for stored elements
; 760  : 	};
; 761  : 
; 762  : 		// TEMPLATE CLASS _Tree_alloc
; 763  : template<class _Alloc_types>
; 764  : 	class _Tree_alloc<false, _Alloc_types>
; 765  : 		: public _Tree_val<typename _Alloc_types::_Val_types>
; 766  : 	{	// base class for tree to hold allocator with no storage
; 767  : public:
; 768  : 	typedef _Tree_alloc<false, _Alloc_types> _Myt;
; 769  : 	typedef _Tree_val<typename _Alloc_types::_Val_types> _Mybase;
; 770  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 771  : 	typedef typename _Alloc_types::_Alnod_type _Alty;
; 772  : 	typedef typename _Alloc_types::_Node _Node;
; 773  : 	typedef typename _Alloc_types::_Nodeptr _Nodeptr;
; 774  : 
; 775  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 776  : 	_Tree_alloc(const _Alloc& = _Alloc())
; 777  : 		{	// construct head node, allocator from _Al
; 778  : 		this->_Myhead = _Buyheadnode();

  00010	e8 00 00 00 00	 call	 ?_Buyheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@2@XZ ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::_Buyheadnode
  00015	89 06		 mov	 DWORD PTR [esi], eax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\map

; 93   : 		}

  00017	8b c6		 mov	 eax, esi
  00019	5e		 pop	 esi
  0001a	c3		 ret	 0
??0?$map@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@@std@@QAE@XZ ENDP ; std::map<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::map<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\map
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\map
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\map
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\map
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\map
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\map
;	COMDAT ??A?$map@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@@std@@QAEAAV?$shared_ptr@VChunkBase@@@1@ABVChunkPosition@@@Z
_TEXT	SEGMENT
$T2 = -44						; size = 20
$T3 = -24						; size = 8
__$EHRec$ = -12						; size = 12
$T4 = 8							; size = 4
__Keyval$ = 8						; size = 4
??A?$map@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@@std@@QAEAAV?$shared_ptr@VChunkBase@@@1@ABVChunkPosition@@@Z PROC ; std::map<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::operator[], COMDAT
; _this$ = ecx

; 191  : 		{	// find element matching _Keyval or insert with default mapped

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??A?$map@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@@std@@QAEAAV?$shared_ptr@VChunkBase@@@1@ABVChunkPosition@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 20	 sub	 esp, 32			; 00000020H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	8b d9		 mov	 ebx, ecx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree

; 1572 : 		return (iterator(_Lbound(_Keyval), this));

  0002a	8b 7d 08	 mov	 edi, DWORD PTR __Keyval$[ebp]
  0002d	57		 push	 edi
  0002e	e8 00 00 00 00	 call	 ?_Lbound@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@2@ABVChunkPosition@@@Z ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Lbound

; 44   : 		{	// construct with node pointer _Pnode

  00033	8b f0		 mov	 esi, eax

; 45   : 		this->_Adopt(_Plist);
; 46   : 		}
; 47   : 
; 48   : 	reference operator*() const
; 49   : 		{	// return designated value
; 50   : 		return (_Mytree::_Myval(_Ptr));
; 51   : 		}
; 52   : 
; 53   : 	pointer operator->() const
; 54   : 		{	// return pointer to class object
; 55   : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 56   : 		}
; 57   : 
; 58   : 	_Myiter& operator++()
; 59   : 		{	// preincrement
; 60   : 		if (_Mytree::_Isnil(_Ptr))
; 61   : 			;	// end() shouldn't be incremented, don't move
; 62   : 		else if (!_Mytree::_Isnil(_Mytree::_Right(_Ptr)))
; 63   : 			_Ptr = _Mytree::_Min(
; 64   : 				_Mytree::_Right(_Ptr));	// ==> smallest of right subtree
; 65   : 		else
; 66   : 			{	// climb looking for right subtree
; 67   : 			_Nodeptr _Pnode;
; 68   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 69   : 				&& _Ptr == _Mytree::_Right(_Pnode))
; 70   : 				_Ptr = _Pnode;	// ==> parent while right subtree
; 71   : 			_Ptr = _Pnode;	// ==> parent (head if end())
; 72   : 			}
; 73   : 		return (*this);
; 74   : 		}
; 75   : 
; 76   : 	_Myiter operator++(int)
; 77   : 		{	// postincrement
; 78   : 		_Myiter _Tmp = *this;
; 79   : 		++*this;
; 80   : 		return (_Tmp);
; 81   : 		}
; 82   : 
; 83   : 	_Myiter& operator--()
; 84   : 		{	// predecrement
; 85   : 		if (_Mytree::_Isnil(_Ptr))
; 86   : 			_Ptr = _Mytree::_Right(_Ptr);	// end() ==> rightmost
; 87   : 		else if (!_Mytree::_Isnil(_Mytree::_Left(_Ptr)))
; 88   : 			_Ptr = _Mytree::_Max(
; 89   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree
; 90   : 		else
; 91   : 			{	// climb looking for left subtree
; 92   : 			_Nodeptr _Pnode;
; 93   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 94   : 				&& _Ptr == _Mytree::_Left(_Pnode))
; 95   : 				_Ptr = _Pnode;	// ==> parent while left subtree
; 96   : 			if (_Mytree::_Isnil(_Ptr))
; 97   : 				;	// begin() shouldn't be decremented, don't move
; 98   : 			else
; 99   : 				_Ptr = _Pnode;	// ==> parent if not head
; 100  : 			}
; 101  : 		return (*this);
; 102  : 		}
; 103  : 
; 104  : 	_Myiter operator--(int)
; 105  : 		{	// postdecrement
; 106  : 		_Myiter _Tmp = *this;
; 107  : 		--*this;
; 108  : 		return (_Tmp);
; 109  : 		}
; 110  : 
; 111  : 	bool operator==(const _Myiter& _Right) const
; 112  : 		{	// test for iterator equality
; 113  : 		return (_Ptr == _Right._Ptr);
; 114  : 		}
; 115  : 
; 116  : 	bool operator!=(const _Myiter& _Right) const
; 117  : 		{	// test for iterator inequality
; 118  : 		return (!(*this == _Right));
; 119  : 		}
; 120  : 
; 121  : 	_Nodeptr _Mynode() const
; 122  : 		{	// return node pointer
; 123  : 		return (_Ptr);
; 124  : 		}
; 125  : 
; 126  : 	_Nodeptr _Ptr;	// pointer to node
; 127  : 	};
; 128  : 
; 129  : 	// TEMPLATE CLASS _Tree_unchecked_iterator
; 130  : template<class _Mytree>
; 131  : 	class _Tree_unchecked_iterator
; 132  : 		: public _Tree_unchecked_const_iterator<_Mytree>
; 133  : 	{	// unchecked iterator for mutable tree
; 134  : public:
; 135  : 	typedef _Tree_unchecked_iterator<_Mytree> _Myiter;
; 136  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Mybase;
; 137  : 	typedef bidirectional_iterator_tag iterator_category;
; 138  : 
; 139  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 140  : 	typedef typename _Mytree::value_type value_type;
; 141  : 	typedef typename _Mytree::difference_type difference_type;
; 142  : 	typedef typename _Mytree::pointer pointer;
; 143  : 	typedef typename _Mytree::reference reference;
; 144  : 
; 145  : 	_Tree_unchecked_iterator()
; 146  : 		{	// construct with null node
; 147  : 		}
; 148  : 
; 149  : 	_Tree_unchecked_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 150  : 		: _Mybase(_Pnode, _Plist)
; 151  : 		{	// construct with node pointer _Pnode
; 152  : 		}
; 153  : 
; 154  : 	reference operator*() const
; 155  : 		{	// return designated value
; 156  : 		return ((reference)**(_Mybase *)this);
; 157  : 		}
; 158  : 
; 159  : 	pointer operator->() const
; 160  : 		{	// return pointer to class object
; 161  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 162  : 		}
; 163  : 
; 164  : 	_Myiter& operator++()
; 165  : 		{	// preincrement
; 166  : 		++(*(_Mybase *)this);
; 167  : 		return (*this);
; 168  : 		}
; 169  : 
; 170  : 	_Myiter operator++(int)
; 171  : 		{	// postincrement
; 172  : 		_Myiter _Tmp = *this;
; 173  : 		++*this;
; 174  : 		return (_Tmp);
; 175  : 		}
; 176  : 
; 177  : 	_Myiter& operator--()
; 178  : 		{	// predecrement
; 179  : 		--(*(_Mybase *)this);
; 180  : 		return (*this);
; 181  : 		}
; 182  : 
; 183  : 	_Myiter operator--(int)
; 184  : 		{	// postdecrement
; 185  : 		_Myiter _Tmp = *this;
; 186  : 		--*this;
; 187  : 		return (_Tmp);
; 188  : 		}
; 189  : 	};
; 190  : 
; 191  : 	// TEMPLATE CLASS _Tree_const_iterator
; 192  : template<class _Mytree>
; 193  : 	class _Tree_const_iterator
; 194  : 		: public _Tree_unchecked_const_iterator<_Mytree, _Iterator_base>
; 195  : 	{	// iterator for nonmutable tree
; 196  : public:
; 197  : 	typedef _Tree_const_iterator<_Mytree> _Myiter;
; 198  : 	typedef _Tree_unchecked_const_iterator<_Mytree, _Iterator_base> _Mybase;
; 199  : 	typedef bidirectional_iterator_tag iterator_category;
; 200  : 
; 201  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 202  : 	typedef typename _Mytree::value_type value_type;
; 203  : 	typedef typename _Mytree::difference_type difference_type;
; 204  : 	typedef typename _Mytree::const_pointer pointer;
; 205  : 	typedef typename _Mytree::const_reference reference;
; 206  : 
; 207  : 	_Tree_const_iterator()
; 208  : 		: _Mybase()
; 209  : 		{	// construct with null node pointer
; 210  : 		}
; 211  : 
; 212  : 	_Tree_const_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 213  : 		: _Mybase(_Pnode, _Plist)
; 214  : 		{	// construct with node pointer _Pnode
; 215  : 		}
; 216  : 
; 217  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Unchecked_type;
; 218  : 
; 219  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 220  : 		{	// reset from unchecked iterator
; 221  : 		this->_Ptr = _Right._Ptr;
; 222  : 		return (*this);
; 223  : 		}
; 224  : 
; 225  : 	_Unchecked_type _Unchecked() const
; 226  : 		{	// make an unchecked iterator
; 227  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 228  : 		}
; 229  : 
; 230  : 	reference operator*() const
; 231  : 		{	// return designated value
; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		if (this->_Getcont() == 0
; 234  : 			|| this->_Ptr == 0
; 235  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 236  : 			{	// report error
; 237  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 238  : 			_SCL_SECURE_OUT_OF_RANGE;
; 239  : 			}
; 240  : 
; 241  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 242  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 243  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 244  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 245  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 246  : 
; 247  : 		return (_Mytree::_Myval(this->_Ptr));
; 248  : 		}
; 249  : 
; 250  : 	pointer operator->() const
; 251  : 		{	// return pointer to class object
; 252  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 253  : 		}
; 254  : 
; 255  : 	_Myiter& operator++()
; 256  : 		{	// preincrement
; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);
; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);

  00035	3b 33		 cmp	 esi, DWORD PTR [ebx]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\map

; 194  : 			|| this->_Getcomp()(_Keyval, this->_Key(_Where._Mynode())))

  00037	74 30		 je	 SHORT $LN1@operator
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp

; 296  : 	if(cp1.x < cp2.x)

  00039	8b 07		 mov	 eax, DWORD PTR [edi]
  0003b	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  0003e	3b c1		 cmp	 eax, ecx
  00040	7c 27		 jl	 SHORT $LN1@operator

; 297  : 	{
; 298  : 		return true;
; 299  : 	}
; 300  : 	else if(cp1.x == cp2.x)

  00042	0f 85 a6 00 00
	00		 jne	 $LN106@operator

; 301  : 	{
; 302  : 		if(cp1.y < cp2.y)

  00048	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0004b	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  0004e	3b c1		 cmp	 eax, ecx
  00050	7c 17		 jl	 SHORT $LN1@operator

; 303  : 		{
; 304  : 			return true;
; 305  : 		}
; 306  : 		else if(cp1.y == cp2.y)

  00052	0f 85 96 00 00
	00		 jne	 $LN106@operator

; 307  : 		{
; 308  : 			return cp1.z < cp2.z;

  00058	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  0005b	3b 46 18	 cmp	 eax, DWORD PTR [esi+24]
  0005e	0f 9c c0	 setl	 al
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\map

; 194  : 			|| this->_Getcomp()(_Keyval, this->_Key(_Where._Mynode())))

  00061	84 c0		 test	 al, al
  00063	0f 84 85 00 00
	00		 je	 $LN106@operator
$LN1@operator:

; 198  : 					mapped_type()));

  00069	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility

; 138  : 		{	// construct from moved values

  00070	f3 0f 7e 07	 movq	 xmm0, QWORD PTR [edi]
  00074	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  00077	66 0f d6 45 d4	 movq	 QWORD PTR $T2[ebp], xmm0
  0007c	89 45 dc	 mov	 DWORD PTR $T2[ebp+8], eax

; 48   : 	_Left = _Move(_Right);

  0007f	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR $T2[ebp+16], 0

; 49   : 	_Right = _Move(_Tmp);

  00086	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR $T3[ebp+4], 0

; 48   : 	_Left = _Move(_Right);

  0008d	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR $T2[ebp+12], 0

; 49   : 	_Right = _Move(_Tmp);

  00094	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR $T3[ebp], 0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree

; 1161 : 		_Nodeptr _Newnode = this->_Buynode(_STD forward<_Valty>(_Val));

  0009b	8d 45 d4	 lea	 eax, DWORD PTR $T2[ebp]
  0009e	50		 push	 eax
  0009f	8b cb		 mov	 ecx, ebx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\map

; 198  : 					mapped_type()));

  000a1	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree

; 1161 : 		_Nodeptr _Newnode = this->_Buynode(_STD forward<_Valty>(_Val));

  000a5	e8 00 00 00 00	 call	 ??$_Buynode@U?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@?$_Tree_buy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@1@$$QAU?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z ; std::_Tree_buy<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::_Buynode<std::pair<ChunkPosition,std::shared_ptr<ChunkBase> > >

; 1162 : 		return (_Insert_hint(_Where,
; 1163 : 			this->_Myval(_Newnode), _Newnode));

  000aa	50		 push	 eax

; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  :  #if _HAS_CPP0X
; 520  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 521  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 522  : 
; 523  :  #else /* _HAS_CPP0X */
; 524  : 	typedef typename _Alloc::template rebind<_Ty>::other _Alty;
; 525  :  #endif /* _HAS_CPP0X */
; 526  : 
; 527  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 528  : 		_Voidptr;
; 529  : 	typedef _Tree_node<typename _Alty::value_type,
; 530  : 		_Voidptr> _Node;
; 531  : 
; 532  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 533  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 534  : 	typedef _Nodeptr& _Nodepref;
; 535  : 
; 536  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 537  : 		_Tree_simple_types<typename _Alty::value_type>,
; 538  : 		_Tree_iter_types<typename _Alty::value_type,
; 539  : 			typename _Alty::size_type,
; 540  : 			typename _Alty::difference_type,
; 541  : 			typename _Alty::pointer,
; 542  : 			typename _Alty::const_pointer,
; 543  : 			typename _Alty::reference,
; 544  : 			typename _Alty::const_reference,
; 545  : 			_Nodeptr> >::type
; 546  : 		_Val_types;
; 547  : 	};
; 548  : 
; 549  : 		// TEMPLATE CLASS _Tree_val
; 550  : template<class _Val_types>
; 551  : 	class _Tree_val
; 552  : 		: public _Container_base
; 553  : 	{	// base class for tree to hold data
; 554  : public:
; 555  : 	typedef _Tree_val<_Val_types> _Myt;
; 556  : 
; 557  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 558  : 	typedef _Nodeptr& _Nodepref;
; 559  : 
; 560  : 	typedef typename _Val_types::value_type value_type;
; 561  : 	typedef typename _Val_types::size_type size_type;
; 562  : 	typedef typename _Val_types::difference_type difference_type;
; 563  : 	typedef typename _Val_types::pointer pointer;
; 564  : 	typedef typename _Val_types::const_pointer const_pointer;
; 565  : 	typedef typename _Val_types::reference reference;
; 566  : 	typedef typename _Val_types::const_reference const_reference;
; 567  : 
; 568  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 569  : 	typedef _Tree_iterator<_Myt> iterator;
; 570  : 
; 571  : 	_Tree_val()
; 572  : 		{	// initialize data
; 573  : 		this->_Myhead = 0;
; 574  : 		this->_Mysize = 0;
; 575  : 		}
; 576  : 
; 577  : 	enum _Redbl
; 578  : 		{	// colors for link to parent
; 579  : 		_Red, _Black};
; 580  : 
; 581  : 	static char& _Color(_Nodeptr _Pnode)
; 582  : 		{	// return reference to color in node
; 583  : 		return ((char&)_Pnode->_Color);
; 584  : 		}
; 585  : 
; 586  : 	static char& _Isnil(_Nodeptr _Pnode)
; 587  : 		{	// return reference to nil flag in node
; 588  : 		return ((char&)_Pnode->_Isnil);
; 589  : 		}
; 590  : 
; 591  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 592  : 		{	// return reference to left pointer in node
; 593  : 		return ((_Nodepref)_Pnode->_Left);
; 594  : 		}
; 595  : 
; 596  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 597  : 		{	// return reference to parent pointer in node
; 598  : 		return ((_Nodepref)_Pnode->_Parent);
; 599  : 		}
; 600  : 
; 601  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 602  : 		{	// return reference to right pointer in node
; 603  : 		return ((_Nodepref)_Pnode->_Right);
; 604  : 		}
; 605  : 
; 606  : 	static reference _Myval(_Nodeptr _Pnode)
; 607  : 		{	// return reference to value in node
; 608  : 		return ((reference)_Pnode->_Myval);

  000ab	83 c0 10	 add	 eax, 16			; 00000010H

; 1162 : 		return (_Insert_hint(_Where,
; 1163 : 			this->_Myval(_Newnode), _Newnode));

  000ae	50		 push	 eax
  000af	56		 push	 esi
  000b0	8d 45 08	 lea	 eax, DWORD PTR $T4[ebp]
  000b3	50		 push	 eax
  000b4	8b cb		 mov	 ecx, ebx
  000b6	e8 00 00 00 00	 call	 ??$_Insert_hint@AAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@AAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@PAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@1@@Z ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Insert_hint<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > &,std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void *> *>
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\map

; 198  : 					mapped_type()));

  000bb	8b 75 08	 mov	 esi, DWORD PTR $T4[ebp]
  000be	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  000c2	8b 7d e4	 mov	 edi, DWORD PTR $T2[ebp+16]
  000c5	85 ff		 test	 edi, edi
  000c7	74 25		 je	 SHORT $LN106@operator

; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  000c9	83 cb ff	 or	 ebx, -1
  000cc	8d 4f 04	 lea	 ecx, DWORD PTR [edi+4]
  000cf	8b c3		 mov	 eax, ebx
  000d1	f0 0f c1 01	 lock	  xadd	 DWORD PTR [ecx], eax
  000d5	75 17		 jne	 SHORT $LN106@operator

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  000d7	8b 07		 mov	 eax, DWORD PTR [edi]
  000d9	8b cf		 mov	 ecx, edi
  000db	ff 10		 call	 DWORD PTR [eax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  000dd	8d 47 08	 lea	 eax, DWORD PTR [edi+8]
  000e0	f0 0f c1 18	 lock	  xadd	 DWORD PTR [eax], ebx
  000e4	4b		 dec	 ebx
  000e5	75 07		 jne	 SHORT $LN106@operator

; 128  : 			_Delete_this();

  000e7	8b 07		 mov	 eax, DWORD PTR [edi]
  000e9	8b cf		 mov	 ecx, edi
  000eb	ff 50 04	 call	 DWORD PTR [eax+4]
$LN106@operator:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\map

; 199  : 		return (_Where->second);

  000ee	8d 46 1c	 lea	 eax, DWORD PTR [esi+28]

; 200  : 		}

  000f1	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000f4	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000fb	59		 pop	 ecx
  000fc	5f		 pop	 edi
  000fd	5e		 pop	 esi
  000fe	5b		 pop	 ebx
  000ff	8b e5		 mov	 esp, ebp
  00101	5d		 pop	 ebp
  00102	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??A?$map@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@@std@@QAEAAV?$shared_ptr@VChunkBase@@@1@ABVChunkPosition@@@Z$0:
  00000	8d 4d e8	 lea	 ecx, DWORD PTR $T3[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$shared_ptr@VChunkBase@@@std@@QAE@XZ ; std::shared_ptr<ChunkBase>::~shared_ptr<ChunkBase>
__unwindfunclet$??A?$map@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@@std@@QAEAAV?$shared_ptr@VChunkBase@@@1@ABVChunkPosition@@@Z$1:
  00008	8d 4d d4	 lea	 ecx, DWORD PTR $T2[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@QAE@XZ
__ehhandler$??A?$map@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@@std@@QAEAAV?$shared_ptr@VChunkBase@@@1@ABVChunkPosition@@@Z:
  00010	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00014	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00017	8b 4a d0	 mov	 ecx, DWORD PTR [edx-48]
  0001a	33 c8		 xor	 ecx, eax
  0001c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00021	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??A?$map@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@@std@@QAEAAV?$shared_ptr@VChunkBase@@@1@ABVChunkPosition@@@Z
  00026	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??A?$map@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@@std@@QAEAAV?$shared_ptr@VChunkBase@@@1@ABVChunkPosition@@@Z ENDP ; std::map<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::operator[]
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
;	COMDAT ??1?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
$T1 = -4						; size = 4
??1?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::~_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >, COMDAT
; _this$ = ecx

; 1188 : 		{	// destroy tree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx

; 1191 : 
; 1192 : 	_Myt& operator=(const _Myt& _Right)
; 1193 : 		{	// replace contents from _Right
; 1194 : 		if (this != &_Right)
; 1195 : 			{	// different, assign it
; 1196 :  #if _HAS_CPP0X
; 1197 : 			clear();
; 1198 : 			if (this->_Getal() != _Right._Getal()
; 1199 : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 1200 : 				this->_Change_alloc(_Right._Getal());
; 1201 :  #endif /* _HAS_CPP0X */
; 1202 : 
; 1203 : 			this->_Setcomp(_Right._Getcomp());
; 1204 : 			_Copy(_Right, false_type());
; 1205 : 			}
; 1206 : 		return (*this);
; 1207 : 		}
; 1208 : 
; 1209 : 	iterator begin() _NOEXCEPT
; 1210 : 		{	// return iterator for beginning of mutable sequence
; 1211 : 		return (iterator(_Lmost(), this));
; 1212 : 		}
; 1213 : 
; 1214 : 	const_iterator begin() const _NOEXCEPT
; 1215 : 		{	// return iterator for beginning of nonmutable sequence
; 1216 : 		return (const_iterator(_Lmost(), this));
; 1217 : 		}
; 1218 : 
; 1219 : 	iterator end() _NOEXCEPT
; 1220 : 		{	// return iterator for end of mutable sequence
; 1221 : 		return (iterator(this->_Myhead, this));
; 1222 : 		}
; 1223 : 
; 1224 : 	const_iterator end() const _NOEXCEPT
; 1225 : 		{	// return iterator for end of nonmutable sequence
; 1226 : 		return (const_iterator(this->_Myhead, this));
; 1227 : 		}
; 1228 : 
; 1229 : 	reverse_iterator rbegin() _NOEXCEPT
; 1230 : 		{	// return iterator for beginning of reversed mutable sequence
; 1231 : 		return (reverse_iterator(end()));
; 1232 : 		}
; 1233 : 
; 1234 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1235 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1236 : 		return (const_reverse_iterator(end()));
; 1237 : 		}
; 1238 : 
; 1239 : 	reverse_iterator rend() _NOEXCEPT
; 1240 : 		{	// return iterator for end of reversed mutable sequence
; 1241 : 		return (reverse_iterator(begin()));
; 1242 : 		}
; 1243 : 
; 1244 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1245 : 		{	// return iterator for end of reversed nonmutable sequence
; 1246 : 		return (const_reverse_iterator(begin()));
; 1247 : 		}
; 1248 : 
; 1249 :  #if _HAS_CPP0X
; 1250 : 	const_iterator cbegin() const _NOEXCEPT
; 1251 : 		{	// return iterator for beginning of nonmutable sequence
; 1252 : 		return (((const _Myt *)this)->begin());
; 1253 : 		}
; 1254 : 
; 1255 : 	const_iterator cend() const _NOEXCEPT
; 1256 : 		{	// return iterator for end of nonmutable sequence
; 1257 : 		return (((const _Myt *)this)->end());
; 1258 : 		}
; 1259 : 
; 1260 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1261 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1262 : 		return (((const _Myt *)this)->rbegin());
; 1263 : 		}
; 1264 : 
; 1265 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1266 : 		{	// return iterator for end of reversed nonmutable sequence
; 1267 : 		return (((const _Myt *)this)->rend());
; 1268 : 		}
; 1269 :  #endif /* _HAS_CPP0X */
; 1270 : 
; 1271 : 	size_type size() const _NOEXCEPT
; 1272 : 		{	// return length of sequence
; 1273 : 		return (this->_Mysize);
; 1274 : 		}
; 1275 : 
; 1276 : 	size_type max_size() const _NOEXCEPT
; 1277 : 		{	// return maximum possible length of sequence
; 1278 : 		return (this->_Getal().max_size());
; 1279 : 		}
; 1280 : 
; 1281 : 	bool empty() const _NOEXCEPT
; 1282 : 		{	// return true only if sequence is empty
; 1283 : 		return (size() == 0);
; 1284 : 		}
; 1285 : 
; 1286 : 	allocator_type get_allocator() const _NOEXCEPT
; 1287 : 		{	// return allocator object for values
; 1288 : 		return (this->_Getal());
; 1289 : 		}
; 1290 : 
; 1291 : 	key_compare key_comp() const
; 1292 : 		{	// return object for comparing keys
; 1293 : 		return (this->_Getcomp());
; 1294 : 		}
; 1295 : 
; 1296 : 	value_compare value_comp() const
; 1297 : 		{	// return object for comparing values
; 1298 : 		return (value_compare(key_comp()));
; 1299 : 		}
; 1300 : 
; 1301 : 	_Pairib insert(const value_type& _Val)
; 1302 : 		{	// try to insert node with value _Val, favoring right side
; 1303 : 		return (_Insert_nohint(false,
; 1304 : 			_Val, _Nil_obj));
; 1305 : 		}
; 1306 : 
; 1307 : 	iterator insert(const_iterator _Where,
; 1308 : 		const value_type& _Val)
; 1309 : 		{	// try to insert node with value _Val using _Where as a hint
; 1310 : 		return (_Insert_hint(_Where,
; 1311 : 			_Val, _Nil_obj));
; 1312 : 		}
; 1313 : 
; 1314 : 	template<class _Iter>
; 1315 : 		void insert(_Iter _First, _Iter _Last)
; 1316 : 		{	// insert [_First, _Last) one at a time
; 1317 : 		_DEBUG_RANGE(_First, _Last);
; 1318 : 		for (; _First != _Last; ++_First)
; 1319 : 			insert(end(), *_First);
; 1320 : 		}
; 1321 : 
; 1322 : 	iterator erase(const_iterator _Where)
; 1323 : 		{	// erase element at _Where
; 1324 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1325 : 		if (_Where._Getcont() != this || this->_Isnil(_Where._Mynode()))
; 1326 : 			_DEBUG_ERROR("map/set erase iterator outside range");
; 1327 : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase
; 1328 : 		++_Where;	// save successor iterator for return
; 1329 : 		_Orphan_ptr(*this, _Erasednode);
; 1330 : 
; 1331 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1332 : 		if (this->_Isnil(_Where._Mynode()))
; 1333 : 			_Xout_of_range("invalid map/set<T> iterator");
; 1334 : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase
; 1335 : 		++_Where;	// save successor iterator for return
; 1336 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1337 : 
; 1338 : 		_Nodeptr _Fixnode;	// the node to recolor as needed
; 1339 : 		_Nodeptr _Fixnodeparent;	// parent of _Fixnode (which may be nil)
; 1340 : 		_Nodeptr _Pnode = _Erasednode;
; 1341 : 
; 1342 : 		if (this->_Isnil(this->_Left(_Pnode)))
; 1343 : 			_Fixnode = this->_Right(_Pnode);	// stitch up right subtree
; 1344 : 		else if (this->_Isnil(this->_Right(_Pnode)))
; 1345 : 			_Fixnode = this->_Left(_Pnode);	// stitch up left subtree
; 1346 : 		else
; 1347 : 			{	// two subtrees, must lift successor node to replace erased
; 1348 : 			_Pnode = _Where._Mynode();	// _Pnode is successor node
; 1349 : 			_Fixnode = this->_Right(_Pnode);	// _Fixnode is only subtree
; 1350 : 			}
; 1351 : 
; 1352 : 		if (_Pnode == _Erasednode)
; 1353 : 			{	// at most one subtree, relink it
; 1354 : 			_Fixnodeparent = this->_Parent(_Erasednode);
; 1355 : 			if (!this->_Isnil(_Fixnode))
; 1356 : 				this->_Parent(_Fixnode) = _Fixnodeparent;	// link up
; 1357 : 
; 1358 : 			if (_Root() == _Erasednode)
; 1359 : 				_Root() = _Fixnode;	// link down from root
; 1360 : 			else if (this->_Left(_Fixnodeparent) == _Erasednode)
; 1361 : 				this->_Left(_Fixnodeparent) = _Fixnode;	// link down to left
; 1362 : 			else
; 1363 : 				this->_Right(_Fixnodeparent) =
; 1364 : 					_Fixnode;	// link down to right
; 1365 : 
; 1366 : 			if (_Lmost() == _Erasednode)
; 1367 : 				_Lmost() = this->_Isnil(_Fixnode)
; 1368 : 					? _Fixnodeparent	// smallest is parent of erased node
; 1369 : 					: this->_Min(_Fixnode);	// smallest in relinked subtree
; 1370 : 
; 1371 : 			if (_Rmost() == _Erasednode)
; 1372 : 				_Rmost() = this->_Isnil(_Fixnode)
; 1373 : 					? _Fixnodeparent	// largest is parent of erased node
; 1374 : 					: this->_Max(_Fixnode);	// largest in relinked subtree
; 1375 : 			}
; 1376 : 		else
; 1377 : 			{	// erased has two subtrees, _Pnode is successor to erased
; 1378 : 			this->_Parent(this->_Left(_Erasednode)) =
; 1379 : 				_Pnode;	// link left up
; 1380 : 			this->_Left(_Pnode) =
; 1381 : 				this->_Left(_Erasednode);	// link successor down
; 1382 : 
; 1383 : 			if (_Pnode == this->_Right(_Erasednode))
; 1384 : 				_Fixnodeparent = _Pnode;	// successor is next to erased
; 1385 : 			else
; 1386 : 				{	// successor further down, link in place of erased
; 1387 : 				_Fixnodeparent =
; 1388 : 					this->_Parent(_Pnode);	// parent is successor's
; 1389 : 				if (!this->_Isnil(_Fixnode))
; 1390 : 					this->_Parent(_Fixnode) = _Fixnodeparent;	// link fix up
; 1391 : 				this->_Left(_Fixnodeparent) = _Fixnode;	// link fix down
; 1392 : 				this->_Right(_Pnode) =
; 1393 : 					this->_Right(_Erasednode);	// link next down
; 1394 : 				this->_Parent(this->_Right(_Erasednode)) =
; 1395 : 					_Pnode;	// right up
; 1396 : 				}
; 1397 : 
; 1398 : 			if (_Root() == _Erasednode)
; 1399 : 				_Root() = _Pnode;	// link down from root
; 1400 : 			else if (this->_Left(this->_Parent(_Erasednode)) == _Erasednode)
; 1401 : 				this->_Left(this->_Parent(_Erasednode)) =
; 1402 : 					_Pnode;	// link down to left
; 1403 : 			else
; 1404 : 				this->_Right(this->_Parent(_Erasednode)) =
; 1405 : 					_Pnode;	// link down to right
; 1406 : 
; 1407 : 			this->_Parent(_Pnode) =
; 1408 : 				this->_Parent(_Erasednode);	// link successor up
; 1409 : 			_STD swap(this->_Color(_Pnode),
; 1410 : 				this->_Color(_Erasednode));	// recolor it
; 1411 : 			}
; 1412 : 
; 1413 : 		if (this->_Color(_Erasednode) == this->_Black)
; 1414 : 			{	// erasing black link, must recolor/rebalance tree
; 1415 : 			for (; _Fixnode != _Root()
; 1416 : 				&& this->_Color(_Fixnode) == this->_Black;
; 1417 : 				_Fixnodeparent = this->_Parent(_Fixnode))
; 1418 : 				if (_Fixnode == this->_Left(_Fixnodeparent))
; 1419 : 					{	// fixup left subtree
; 1420 : 					_Pnode = this->_Right(_Fixnodeparent);
; 1421 : 					if (this->_Color(_Pnode) == this->_Red)
; 1422 : 						{	// rotate red up from right subtree
; 1423 : 						this->_Color(_Pnode) = this->_Black;
; 1424 : 						this->_Color(_Fixnodeparent) = this->_Red;
; 1425 : 						_Lrotate(_Fixnodeparent);
; 1426 : 						_Pnode = this->_Right(_Fixnodeparent);
; 1427 : 						}
; 1428 : 
; 1429 : 					if (this->_Isnil(_Pnode))
; 1430 : 						_Fixnode = _Fixnodeparent;	// shouldn't happen
; 1431 : 					else if (this->_Color(this->_Left(_Pnode)) == this->_Black
; 1432 : 						&& this->_Color(this->_Right(_Pnode)) == this->_Black)
; 1433 : 						{	// redden right subtree with black children
; 1434 : 						this->_Color(_Pnode) = this->_Red;
; 1435 : 						_Fixnode = _Fixnodeparent;
; 1436 : 						}
; 1437 : 					else
; 1438 : 						{	// must rearrange right subtree
; 1439 : 						if (this->_Color(this->_Right(_Pnode))
; 1440 : 							== this->_Black)
; 1441 : 							{	// rotate red up from left sub-subtree
; 1442 : 							this->_Color(this->_Left(_Pnode)) = this->_Black;
; 1443 : 							this->_Color(_Pnode) = this->_Red;
; 1444 : 							_Rrotate(_Pnode);
; 1445 : 							_Pnode = this->_Right(_Fixnodeparent);
; 1446 : 							}
; 1447 : 
; 1448 : 						this->_Color(_Pnode) = this->_Color(_Fixnodeparent);
; 1449 : 						this->_Color(_Fixnodeparent) = this->_Black;
; 1450 : 						this->_Color(this->_Right(_Pnode)) = this->_Black;
; 1451 : 						_Lrotate(_Fixnodeparent);
; 1452 : 						break;	// tree now recolored/rebalanced
; 1453 : 						}
; 1454 : 					}
; 1455 : 				else
; 1456 : 					{	// fixup right subtree
; 1457 : 					_Pnode = this->_Left(_Fixnodeparent);
; 1458 : 					if (this->_Color(_Pnode) == this->_Red)
; 1459 : 						{	// rotate red up from left subtree
; 1460 : 						this->_Color(_Pnode) = this->_Black;
; 1461 : 						this->_Color(_Fixnodeparent) = this->_Red;
; 1462 : 						_Rrotate(_Fixnodeparent);
; 1463 : 						_Pnode = this->_Left(_Fixnodeparent);
; 1464 : 						}
; 1465 : 
; 1466 : 					if (this->_Isnil(_Pnode))
; 1467 : 						_Fixnode = _Fixnodeparent;	// shouldn't happen
; 1468 : 					else if (this->_Color(this->_Right(_Pnode)) ==
; 1469 : 						this->_Black
; 1470 : 						&& this->_Color(this->_Left(_Pnode)) == this->_Black)
; 1471 : 						{	// redden left subtree with black children
; 1472 : 						this->_Color(_Pnode) = this->_Red;
; 1473 : 						_Fixnode = _Fixnodeparent;
; 1474 : 						}
; 1475 : 					else
; 1476 : 						{	// must rearrange left subtree
; 1477 : 						if (this->_Color(this->_Left(_Pnode)) == this->_Black)
; 1478 : 							{	// rotate red up from right sub-subtree
; 1479 : 							this->_Color(this->_Right(_Pnode)) = this->_Black;
; 1480 : 							this->_Color(_Pnode) = this->_Red;
; 1481 : 							_Lrotate(_Pnode);
; 1482 : 							_Pnode = this->_Left(_Fixnodeparent);
; 1483 : 							}
; 1484 : 
; 1485 : 						this->_Color(_Pnode) = this->_Color(_Fixnodeparent);
; 1486 : 						this->_Color(_Fixnodeparent) = this->_Black;
; 1487 : 						this->_Color(this->_Left(_Pnode)) = this->_Black;
; 1488 : 						_Rrotate(_Fixnodeparent);
; 1489 : 						break;	// tree now recolored/rebalanced
; 1490 : 						}
; 1491 : 					}
; 1492 : 
; 1493 : 			this->_Color(_Fixnode) = this->_Black;	// stopping node is black
; 1494 : 			}
; 1495 : 
; 1496 : 		this->_Getal().destroy(
; 1497 : 			_STD addressof(this->_Myval(_Erasednode)));	// delete erased node
; 1498 : 
; 1499 : 		this->_Getal().deallocate(_Erasednode, 1);
; 1500 : 
; 1501 : 		if (0 < this->_Mysize)
; 1502 : 			--this->_Mysize;
; 1503 : 
; 1504 : 		return (iterator(_Where._Ptr, this));	// return successor iterator
; 1505 : 		}
; 1506 : 
; 1507 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1508 : 		{	// erase [_First, _Last)
; 1509 : 		if (_First == begin() && _Last == end())
; 1510 : 			{	// erase all
; 1511 : 			clear();
; 1512 : 			return (begin());
; 1513 : 			}
; 1514 : 		else
; 1515 : 			{	// partial erase, one at a time
; 1516 : 			while (_First != _Last)
; 1517 : 				erase(_First++);
; 1518 : 			return (iterator(_First._Ptr, this));
; 1519 : 			}
; 1520 : 		}
; 1521 : 
; 1522 : 	size_type erase(const key_type& _Keyval)
; 1523 : 		{	// erase and count all that match _Keyval
; 1524 : 		_Pairii _Where = equal_range(_Keyval);
; 1525 : 		size_type _Num = 0;
; 1526 : 		_Distance(_Where.first, _Where.second, _Num);
; 1527 : 		erase(_Where.first, _Where.second);
; 1528 : 		return (_Num);
; 1529 : 		}
; 1530 : 
; 1531 : 	void clear() _NOEXCEPT
; 1532 : 		{	// erase all
; 1533 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1534 : 		this->_Orphan_ptr(*this, 0);
; 1535 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1536 : 
; 1537 : 		_Erase(_Root());
; 1538 : 		_Root() = this->_Myhead;
; 1539 : 		_Lmost() = this->_Myhead;
; 1540 : 		_Rmost() = this->_Myhead;
; 1541 : 		this->_Mysize = 0;
; 1542 : 		}
; 1543 : 
; 1544 : 	iterator find(const key_type& _Keyval)
; 1545 : 		{	// find an element in mutable sequence that matches _Keyval
; 1546 : 		iterator _Where = lower_bound(_Keyval);
; 1547 : 		return (_Where == end()
; 1548 : 			|| _DEBUG_LT_PRED(this->_Getcomp(),
; 1549 : 				_Keyval, this->_Key(_Where._Mynode()))
; 1550 : 					? end() : _Where);
; 1551 : 		}
; 1552 : 
; 1553 : 	const_iterator find(const key_type& _Keyval) const
; 1554 : 		{	// find an element in nonmutable sequence that matches _Keyval
; 1555 : 		const_iterator _Where = lower_bound(_Keyval);
; 1556 : 		return (_Where == end()
; 1557 : 			|| _DEBUG_LT_PRED(this->_Getcomp(),
; 1558 : 				_Keyval, this->_Key(_Where._Mynode()))
; 1559 : 					? end() : _Where);
; 1560 : 		}
; 1561 : 
; 1562 : 	size_type count(const key_type& _Keyval) const
; 1563 : 		{	// count all elements that match _Keyval
; 1564 : 		_Paircc _Ans = equal_range(_Keyval);
; 1565 : 		size_type _Num = 0;
; 1566 : 		_Distance(_Ans.first, _Ans.second, _Num);
; 1567 : 		return (_Num);
; 1568 : 		}
; 1569 : 
; 1570 : 	iterator lower_bound(const key_type& _Keyval)
; 1571 : 		{	// find leftmost node not less than _Keyval in mutable tree
; 1572 : 		return (iterator(_Lbound(_Keyval), this));
; 1573 : 		}
; 1574 : 
; 1575 : 	const_iterator lower_bound(const key_type& _Keyval) const
; 1576 : 		{	// find leftmost node not less than _Keyval in nonmutable tree
; 1577 : 		return (const_iterator(_Lbound(_Keyval), this));
; 1578 : 		}
; 1579 : 
; 1580 : 	iterator upper_bound(const key_type& _Keyval)
; 1581 : 		{	// find leftmost node greater than _Keyval in mutable tree
; 1582 : 		return (iterator(_Ubound(_Keyval), this));
; 1583 : 		}
; 1584 : 
; 1585 : 	const_iterator upper_bound(const key_type& _Keyval) const
; 1586 : 		{	// find leftmost node greater than _Keyval in nonmutable tree
; 1587 : 		return (const_iterator(_Ubound(_Keyval), this));
; 1588 : 		}
; 1589 : 
; 1590 : 	_Pairii equal_range(const key_type& _Keyval)
; 1591 : 		{	// find range equivalent to _Keyval in mutable tree
; 1592 : 		return (_Eqrange(_Keyval));
; 1593 : 		}
; 1594 : 
; 1595 : 	_Paircc equal_range(const key_type& _Keyval) const
; 1596 : 		{	// find range equivalent to _Keyval in nonmutable tree
; 1597 : 		return (_Eqrange(_Keyval));
; 1598 : 		}
; 1599 : 
; 1600 : 	void swap(_Myt& _Right)
; 1601 : 		{	// exchange contents with _Right
; 1602 : 		if (this == &_Right)
; 1603 : 			;	// same object, do nothing
; 1604 : 		else if (this->_Getal() == _Right._Getal())
; 1605 : 			{	// same allocator, swap control information
; 1606 : 			this->_Swap_all(_Right);
; 1607 : 			this->_Swapcomp(_Right._Getcomp());
; 1608 : 			_Swap_adl(this->_Myhead, _Right._Myhead);
; 1609 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1610 : 			}
; 1611 : 
; 1612 :  #if _HAS_CPP0X
; 1613 : 		else if (_Alty::propagate_on_container_swap::value)
; 1614 : 			{	// swap allocators and control information
; 1615 : 			this->_Swap_alloc(_Right);
; 1616 : 			this->_Swapcomp(_Right._Getcomp());
; 1617 : 			_Swap_adl(this->_Myhead, _Right._Myhead);
; 1618 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1619 : 			}
; 1620 :  #endif /* _HAS_CPP0X */
; 1621 : 
; 1622 : 		else
; 1623 : 			{	// different allocator, do multiple copies
; 1624 : 			_Myt _Temp(this->_Getcomp(), get_allocator());
; 1625 : 			_Temp._Copy(*this, true_type());
; 1626 : 
; 1627 : 			this->_Setcomp(_Right._Getcomp());
; 1628 : 			clear();
; 1629 : 			_Copy(_Right, true_type());
; 1630 : 
; 1631 : 			_Right._Setcomp(_Temp._Getcomp());
; 1632 : 			_Right.clear();
; 1633 : 			_Right._Copy(_Temp, true_type());
; 1634 : 			}
; 1635 : 		}
; 1636 : 
; 1637 : protected:
; 1638 : 	template<class _Valty>
; 1639 : 		_Nodeptr _Buynode_if_nil(_Nodeptr _Node, _Valty&&)
; 1640 : 		{	// node exists, just return it
; 1641 : 		return (_Node);
; 1642 : 		}
; 1643 : 
; 1644 : 	template<class _Valty>
; 1645 : 		_Nodeptr _Buynode_if_nil(_Nil, _Valty&& _Val)
; 1646 : 		{	// node doesn't exist, make it
; 1647 : 		return (this->_Buynode(_STD forward<_Valty>(_Val)));
; 1648 : 		}
; 1649 : 
; 1650 : 	void _Destroy_if_not_nil(_Nodeptr _Newnode)
; 1651 : 		{	// node exists, destroy it
; 1652 : 		this->_Getal().destroy(
; 1653 : 			_STD addressof(this->_Myval(_Newnode)));
; 1654 : 
; 1655 : 		this->_Getal().deallocate(_Newnode, 1);
; 1656 : 		}
; 1657 : 
; 1658 : 	void _Destroy_if_not_nil(_Nil)
; 1659 : 		{	// node doesn't exist, do nothing
; 1660 : 		}
; 1661 : 
; 1662 : 	template<class _Valty,
; 1663 : 		class _Nodety>
; 1664 : 		iterator _Insert_hint(const_iterator _Where,
; 1665 : 			_Valty&& _Val, _Nodety _Newnode)
; 1666 : 		{	// try to insert node using _Where as a hint
; 1667 : 		const_iterator _Next;
; 1668 : 		bool _Leftish = false;	// assume nearest point is end of sequence
; 1669 : 
; 1670 : 		_TRY_BEGIN
; 1671 : 
; 1672 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1673 : 		if (_Where._Getcont() != this)
; 1674 : 			_DEBUG_ERROR("map/set insert iterator outside range");
; 1675 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1676 : 
; 1677 : 		if (size() == 0)
; 1678 : 			return (_Insert_at(true, this->_Myhead,
; 1679 : 				_STD forward<_Valty>(_Val), _Newnode));	// empty tree
; 1680 : 		else if (this->_Multi)
; 1681 : 			{	// insert even if duplicate
; 1682 : 			if (_Where == begin())
; 1683 : 				{	// insert at beginning if before first element
; 1684 : 				if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1685 : 					this->_Key(_Where._Mynode()), this->_Kfn(_Val)))
; 1686 : 					return (_Insert_at(true, _Where._Mynode(),
; 1687 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1688 : 				_Leftish = true;	// nearest point is beginning of sequence
; 1689 : 				}
; 1690 : 			else if (_Where == end())
; 1691 : 				{	// insert at end if after last element
; 1692 : 				if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1693 : 					this->_Kfn(_Val), this->_Key(_Rmost())))
; 1694 : 					return (_Insert_at(false, _Rmost(),
; 1695 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1696 : 				}
; 1697 : 			else if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1698 : 				this->_Key(_Where._Mynode()), this->_Kfn(_Val))
; 1699 : 				&& !_DEBUG_LT_PRED(this->_Getcomp(),
; 1700 : 					this->_Kfn(_Val),
; 1701 : 					this->_Key((--(_Next = _Where))._Mynode())))
; 1702 : 				{	// insert before _Where
; 1703 : 				if (this->_Isnil(this->_Right(_Next._Mynode())))
; 1704 : 					return (_Insert_at(false, _Next._Mynode(),
; 1705 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1706 : 				else
; 1707 : 					return (_Insert_at(true, _Where._Mynode(),
; 1708 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1709 : 				}
; 1710 : 			else if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1711 : 				this->_Kfn(_Val), this->_Key(_Where._Mynode()))
; 1712 : 				&& (++(_Next = _Where) == end()
; 1713 : 					|| !_DEBUG_LT_PRED(this->_Getcomp(),
; 1714 : 						this->_Key(_Next._Mynode()), this->_Kfn(_Val))))
; 1715 : 				{	// insert after _Where
; 1716 : 				if (this->_Isnil(this->_Right(_Where._Mynode())))
; 1717 : 					return (_Insert_at(false, _Where._Mynode(),
; 1718 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1719 : 				else
; 1720 : 					return (_Insert_at(true, _Next._Mynode(),
; 1721 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1722 : 				}
; 1723 : 			else
; 1724 : 				_Leftish = true;	// nearest point is beginning of sequence
; 1725 : 			}
; 1726 : 		else
; 1727 : 			{	// insert only if unique
; 1728 : 			if (_Where == begin())
; 1729 : 				{	// insert at beginning if before first element
; 1730 : 				if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1731 : 					this->_Kfn(_Val), this->_Key(_Where._Mynode())))
; 1732 : 					return (_Insert_at(true, _Where._Mynode(),
; 1733 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1734 : 				}
; 1735 : 			else if (_Where == end())
; 1736 : 				{	// insert at end if after last element
; 1737 : 				if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1738 : 					this->_Key(_Rmost()), this->_Kfn(_Val)))
; 1739 : 					return (_Insert_at(false, _Rmost(),
; 1740 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1741 : 				}
; 1742 : 			else if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1743 : 				this->_Kfn(_Val), this->_Key(_Where._Mynode()))
; 1744 : 				&& _DEBUG_LT_PRED(this->_Getcomp(),
; 1745 : 					this->_Key((--(_Next = _Where))._Mynode()),
; 1746 : 					this->_Kfn(_Val)))
; 1747 : 				{	// insert before _Where
; 1748 : 				if (this->_Isnil(this->_Right(_Next._Mynode())))
; 1749 : 					return (_Insert_at(false, _Next._Mynode(),
; 1750 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1751 : 				else
; 1752 : 					return (_Insert_at(true, _Where._Mynode(),
; 1753 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1754 : 				}
; 1755 : 			else if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1756 : 				this->_Key(_Where._Mynode()), this->_Kfn(_Val))
; 1757 : 				&& (++(_Next = _Where) == end()
; 1758 : 					|| _DEBUG_LT_PRED(this->_Getcomp(),
; 1759 : 						this->_Kfn(_Val), this->_Key(_Next._Mynode()))))
; 1760 : 				{	// insert after _Where
; 1761 : 				if (this->_Isnil(this->_Right(_Where._Mynode())))
; 1762 : 					return (_Insert_at(false, _Where._Mynode(),
; 1763 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1764 : 				else
; 1765 : 					return (_Insert_at(true, _Next._Mynode(),
; 1766 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1767 : 				}
; 1768 : 			}
; 1769 : 		_CATCH_ALL
; 1770 : 		_Destroy_if_not_nil(_Newnode);
; 1771 : 		_RERAISE;
; 1772 : 		_CATCH_END
; 1773 : 
; 1774 : 		return (_Insert_nohint(_Leftish,
; 1775 : 			_STD forward<_Valty>(_Val), _Newnode).first);
; 1776 : 		}
; 1777 : 
; 1778 : 	template<class _Valty,
; 1779 : 		class _Nodety>
; 1780 : 		_Pairib _Insert_nohint(bool _Leftish,
; 1781 : 			_Valty&& _Val, _Nodety _Newnode)
; 1782 : 		{	// try to insert node, on left if _Leftish
; 1783 : 		_TRY_BEGIN
; 1784 : 		_Nodeptr _Trynode = _Root();
; 1785 : 		_Nodeptr _Wherenode = this->_Myhead;
; 1786 : 		bool _Addleft = true;	// add to left of head if tree empty
; 1787 : 
; 1788 : 		while (!this->_Isnil(_Trynode))
; 1789 : 			{	// look for leaf to insert before (_Addleft) or after
; 1790 : 			_Wherenode = _Trynode;
; 1791 : 			if (_Leftish)
; 1792 : 				_Addleft = !_DEBUG_LT_PRED(this->_Getcomp(),
; 1793 : 					this->_Key(_Trynode),
; 1794 : 					this->_Kfn(_Val));	// favor left end
; 1795 : 			else
; 1796 : 				_Addleft = _DEBUG_LT_PRED(this->_Getcomp(),
; 1797 : 					this->_Kfn(_Val),
; 1798 : 					this->_Key(_Trynode));	// favor right end
; 1799 : 			_Trynode = _Addleft ? this->_Left(_Trynode)
; 1800 : 				: this->_Right(_Trynode);
; 1801 : 			}
; 1802 : 
; 1803 : 		if (this->_Multi)
; 1804 : 			return (_Pairib(_Insert_at(_Addleft, _Wherenode,
; 1805 : 				_STD forward<_Valty>(_Val), _Newnode), true));
; 1806 : 		else
; 1807 : 			{	// insert only if unique
; 1808 : 			iterator _Where = iterator(_Wherenode, this);
; 1809 : 			if (!_Addleft)
; 1810 : 				;	// need to test if insert after is okay
; 1811 : 			else if (_Where == begin())
; 1812 : 				return (_Pairib(_Insert_at(true, _Wherenode,
; 1813 : 					_STD forward<_Valty>(_Val), _Newnode), true));
; 1814 : 			else
; 1815 : 				--_Where;	// need to test if insert before is okay
; 1816 : 
; 1817 : 			if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1818 : 				this->_Key(_Where._Mynode()),
; 1819 : 				this->_Kfn(_Val)))
; 1820 : 				return (_Pairib(_Insert_at(_Addleft, _Wherenode,
; 1821 : 					_STD forward<_Valty>(_Val), _Newnode), true));
; 1822 : 			else
; 1823 : 				{	// duplicate, don't insert
; 1824 : 				_Destroy_if_not_nil(_Newnode);
; 1825 : 				return (_Pairib(_Where, false));
; 1826 : 				}
; 1827 : 			}
; 1828 : 		_CATCH_ALL
; 1829 : 		_Destroy_if_not_nil(_Newnode);
; 1830 : 		_RERAISE;
; 1831 : 		_CATCH_END
; 1832 : 		}
; 1833 : 
; 1834 : 	template<class _Valty,
; 1835 : 		class _Nodety>
; 1836 : 		iterator _Insert_at(bool _Addleft, _Nodeptr _Wherenode,
; 1837 : 		_Valty&& _Val, _Nodety _Node)
; 1838 : 		{	// add node with value next to _Wherenode, to left if _Addleft
; 1839 : 		if (max_size() - 1 <= this->_Mysize)
; 1840 : 			{	// tree would get too big, fail
; 1841 : 			_Destroy_if_not_nil(_Node);
; 1842 : 			_Xlength_error("map/set<T> too long");
; 1843 : 			}
; 1844 : 		_Nodeptr _Newnode = _Buynode_if_nil(_Node,
; 1845 : 			_STD forward<_Valty>(_Val));
; 1846 : 
; 1847 : 		++this->_Mysize;
; 1848 : 		_Newnode->_Parent = _Wherenode;
; 1849 : 
; 1850 : 		if (_Wherenode == this->_Myhead)
; 1851 : 			{	// first node in tree, just set head values
; 1852 : 			_Root() = _Newnode;
; 1853 : 			_Lmost() = _Newnode;
; 1854 : 			_Rmost() = _Newnode;
; 1855 : 			}
; 1856 : 		else if (_Addleft)
; 1857 : 			{	// add to left of _Wherenode
; 1858 : 			this->_Left(_Wherenode) = _Newnode;
; 1859 : 			if (_Wherenode == _Lmost())
; 1860 : 				_Lmost() = _Newnode;
; 1861 : 			}
; 1862 : 		else
; 1863 : 			{	// add to right of _Wherenode
; 1864 : 			this->_Right(_Wherenode) = _Newnode;
; 1865 : 			if (_Wherenode == _Rmost())
; 1866 : 				_Rmost() = _Newnode;
; 1867 : 			}
; 1868 : 
; 1869 : 		for (_Nodeptr _Pnode = _Newnode;
; 1870 : 			this->_Color(this->_Parent(_Pnode)) == this->_Red; )
; 1871 : 			if (this->_Parent(_Pnode)
; 1872 : 				== this->_Left(this->_Parent(this->_Parent(_Pnode))))
; 1873 : 				{	// fixup red-red in left subtree
; 1874 : 				_Wherenode =
; 1875 : 					this->_Right(this->_Parent(this->_Parent(_Pnode)));
; 1876 : 				if (this->_Color(_Wherenode) == this->_Red)
; 1877 : 					{	// parent has two red children, blacken both
; 1878 : 					this->_Color(this->_Parent(_Pnode)) = this->_Black;
; 1879 : 					this->_Color(_Wherenode) = this->_Black;
; 1880 : 					this->_Color(this->_Parent(this->_Parent(_Pnode)))
; 1881 : 						= this->_Red;
; 1882 : 					_Pnode = this->_Parent(this->_Parent(_Pnode));
; 1883 : 					}
; 1884 : 				else
; 1885 : 					{	// parent has red and black children
; 1886 : 					if (_Pnode == this->_Right(this->_Parent(_Pnode)))
; 1887 : 						{	// rotate right child to left
; 1888 : 						_Pnode = this->_Parent(_Pnode);
; 1889 : 						_Lrotate(_Pnode);
; 1890 : 						}
; 1891 : 					this->_Color(this->_Parent(_Pnode)) =
; 1892 : 						this->_Black;	// propagate red up
; 1893 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1894 : 						this->_Red;
; 1895 : 					_Rrotate(this->_Parent(this->_Parent(_Pnode)));
; 1896 : 					}
; 1897 : 				}
; 1898 : 			else
; 1899 : 				{	// fixup red-red in right subtree
; 1900 : 				_Wherenode =
; 1901 : 					this->_Left(this->_Parent(this->_Parent(_Pnode)));
; 1902 : 				if (this->_Color(_Wherenode) == this->_Red)
; 1903 : 					{	// parent has two red children, blacken both
; 1904 : 					this->_Color(this->_Parent(_Pnode)) = this->_Black;
; 1905 : 					this->_Color(_Wherenode) = this->_Black;
; 1906 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1907 : 						this->_Red;
; 1908 : 					_Pnode = this->_Parent(this->_Parent(_Pnode));
; 1909 : 					}
; 1910 : 				else
; 1911 : 					{	// parent has red and black children
; 1912 : 					if (_Pnode == this->_Left(this->_Parent(_Pnode)))
; 1913 : 						{	// rotate left child to right
; 1914 : 						_Pnode = this->_Parent(_Pnode);
; 1915 : 						_Rrotate(_Pnode);
; 1916 : 						}
; 1917 : 					this->_Color(this->_Parent(_Pnode)) =
; 1918 : 						this->_Black;	// propagate red up
; 1919 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1920 : 						this->_Red;
; 1921 : 					_Lrotate(this->_Parent(this->_Parent(_Pnode)));
; 1922 : 					}
; 1923 : 				}
; 1924 : 
; 1925 : 		this->_Color(_Root()) = this->_Black;	// root is always black
; 1926 : 		return (iterator(_Newnode, this));
; 1927 : 		}
; 1928 : 
; 1929 : 	template<class _Moveit>
; 1930 : 		void _Copy(const _Myt& _Right,
; 1931 : 			_Moveit _Movefl)
; 1932 : 		{	// copy or move entire tree from _Right
; 1933 : 		_Root() = _Copy_nodes(_Right._Root(), this->_Myhead, _Movefl);
; 1934 : 		this->_Mysize = _Right.size();
; 1935 : 		if (!this->_Isnil(_Root()))
; 1936 : 			{	// nonempty tree, look for new smallest and largest
; 1937 : 			_Lmost() = this->_Min(_Root());
; 1938 : 			_Rmost() = this->_Max(_Root());
; 1939 : 			}
; 1940 : 		else
; 1941 : 			{	// empty tree, just tidy head pointers
; 1942 : 			_Lmost() = this->_Myhead;
; 1943 : 			_Rmost() = this->_Myhead;
; 1944 : 			}
; 1945 : 		}
; 1946 : 
; 1947 : template<class _Want_to_move,
; 1948 : 	class _Can_move>
; 1949 : 	_Nodeptr _Copy_or_move(_Nodeptr _Rootnode, _Want_to_move, _Can_move)
; 1950 : 		{	// copy to new node
; 1951 : 		return (this->_Buynode(this->_Myval(_Rootnode)));
; 1952 : 		}
; 1953 : 
; 1954 : 	_Nodeptr _Copy_or_move(_Nodeptr _Rootnode, true_type, true_type)
; 1955 : 		{	// move to new node -- movable
; 1956 : 		return (this->_Buynode(
; 1957 : 			_STD forward<value_type>(this->_Myval(_Rootnode))));
; 1958 : 		}
; 1959 : 
; 1960 : 	template<class _Moveit>
; 1961 : 		_Nodeptr _Copy_nodes(_Nodeptr _Rootnode, _Nodeptr _Wherenode,
; 1962 : 			_Moveit _Movefl)
; 1963 : 		{	// copy entire subtree, recursively
; 1964 : 		_Nodeptr _Newroot = this->_Myhead;	// point at nil node
; 1965 : 
; 1966 : 		if (!this->_Isnil(_Rootnode))
; 1967 : 			{	// copy or move a node, then any subtrees
; 1968 : 			_Nodeptr _Pnode = _Copy_or_move(_Rootnode, _Movefl,
; 1969 : 				typename is_move_constructible<value_type>::type());
; 1970 : 			_Pnode->_Parent = _Wherenode;
; 1971 : 			_Pnode->_Color = this->_Color(_Rootnode);
; 1972 : 			if (this->_Isnil(_Newroot))
; 1973 : 				_Newroot = _Pnode;	// memorize new root
; 1974 : 
; 1975 : 			_TRY_BEGIN
; 1976 : 			this->_Left(_Pnode) =
; 1977 : 				_Copy_nodes(this->_Left(_Rootnode), _Pnode, _Movefl);
; 1978 : 			this->_Right(_Pnode) =
; 1979 : 				_Copy_nodes(this->_Right(_Rootnode), _Pnode, _Movefl);
; 1980 : 			_CATCH_ALL
; 1981 : 			_Erase(_Newroot);	// subtree copy failed, bail out
; 1982 : 			_RERAISE;
; 1983 : 			_CATCH_END
; 1984 : 			}
; 1985 : 
; 1986 : 		return (_Newroot);	// return newly constructed tree
; 1987 : 		}
; 1988 : 
; 1989 : 	_Paircc _Eqrange(const key_type& _Keyval) const
; 1990 : 		{	// find leftmost node not less than _Keyval
; 1991 : 		_Nodeptr _Pnode = _Root();
; 1992 : 		_Nodeptr _Lonode = this->_Myhead;	// end() if search fails
; 1993 : 		_Nodeptr _Hinode = this->_Myhead;	// end() if search fails
; 1994 : 
; 1995 : 		while (!this->_Isnil(_Pnode))
; 1996 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))
; 1997 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 1998 : 			else
; 1999 : 				{	// _Pnode not less than _Keyval, remember it
; 2000 : 				if (this->_Isnil(_Hinode)
; 2001 : 						&& _DEBUG_LT_PRED(this->_Getcomp(), _Keyval,
; 2002 : 						this->_Key(_Pnode)))
; 2003 : 					_Hinode = _Pnode;	// _Pnode greater, remember it
; 2004 : 				_Lonode = _Pnode;
; 2005 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2006 : 				}
; 2007 : 
; 2008 : 		_Pnode = this->_Isnil(_Hinode) ? _Root()
; 2009 : 			: this->_Left(_Hinode);	// continue scan for upper bound
; 2010 : 		while (!this->_Isnil(_Pnode))
; 2011 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), _Keyval, this->_Key(_Pnode)))
; 2012 : 				{	// _Pnode greater than _Keyval, remember it
; 2013 : 				_Hinode = _Pnode;
; 2014 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2015 : 				}
; 2016 : 			else
; 2017 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2018 : 
; 2019 : 		const_iterator _First = const_iterator(_Lonode, this);
; 2020 : 		const_iterator _Last = const_iterator(_Hinode, this);
; 2021 : 		return (_Paircc(_First, _Last));
; 2022 : 		}
; 2023 : 
; 2024 : 	_Pairii _Eqrange(const key_type& _Keyval)
; 2025 : 		{	// find leftmost node not less than _Keyval
; 2026 : 		_Nodeptr _Pnode = _Root();
; 2027 : 		_Nodeptr _Lonode = this->_Myhead;	// end() if search fails
; 2028 : 		_Nodeptr _Hinode = this->_Myhead;	// end() if search fails
; 2029 : 
; 2030 : 		while (!this->_Isnil(_Pnode))
; 2031 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))
; 2032 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2033 : 			else
; 2034 : 				{	// _Pnode not less than _Keyval, remember it
; 2035 : 				if (this->_Isnil(_Hinode)
; 2036 : 						&& _DEBUG_LT_PRED(this->_Getcomp(), _Keyval,
; 2037 : 						 this->_Key(_Pnode)))
; 2038 : 					_Hinode = _Pnode;	// _Pnode greater, remember it
; 2039 : 				_Lonode = _Pnode;
; 2040 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2041 : 				}
; 2042 : 
; 2043 : 		_Pnode = this->_Isnil(_Hinode) ? _Root()
; 2044 : 			: this->_Left(_Hinode);	// continue scan for upper bound
; 2045 : 		while (!this->_Isnil(_Pnode))
; 2046 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), _Keyval, this->_Key(_Pnode)))
; 2047 : 				{	// _Pnode greater than _Keyval, remember it
; 2048 : 				_Hinode = _Pnode;
; 2049 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2050 : 				}
; 2051 : 			else
; 2052 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2053 : 
; 2054 : 		iterator _First = iterator(_Lonode, this);
; 2055 : 		iterator _Last = iterator(_Hinode, this);
; 2056 : 		return (_Pairii(_First, _Last));
; 2057 : 		}
; 2058 : 
; 2059 : 	void _Erase(_Nodeptr _Rootnode)
; 2060 : 		{	// free entire subtree, recursively
; 2061 : 		for (_Nodeptr _Pnode = _Rootnode;
; 2062 : 			!this->_Isnil(_Pnode); _Rootnode = _Pnode)
; 2063 : 			{	// free subtrees, then node
; 2064 : 			_Erase(this->_Right(_Pnode));
; 2065 : 			_Pnode = this->_Left(_Pnode);
; 2066 : 			this->_Getal().destroy(
; 2067 : 				_STD addressof(this->_Myval(_Rootnode)));
; 2068 : 
; 2069 : 			this->_Getal().deallocate(_Rootnode, 1);
; 2070 : 			}
; 2071 : 		}
; 2072 : 
; 2073 : 	_Nodeptr _Lbound(const key_type& _Keyval) const
; 2074 : 		{	// find leftmost node not less than _Keyval
; 2075 : 		_Nodeptr _Pnode = _Root();
; 2076 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails
; 2077 : 
; 2078 : 		while (!this->_Isnil(_Pnode))
; 2079 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))
; 2080 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2081 : 			else
; 2082 : 				{	// _Pnode not less than _Keyval, remember it
; 2083 : 				_Wherenode = _Pnode;
; 2084 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2085 : 				}
; 2086 : 
; 2087 : 		return (_Wherenode);	// return best remembered candidate
; 2088 : 		}
; 2089 : 
; 2090 : 	_Nodeptr _Lbound(const key_type& _Keyval)
; 2091 : 		{	// find leftmost node not less than _Keyval
; 2092 : 		_Nodeptr _Pnode = _Root();
; 2093 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails
; 2094 : 
; 2095 : 		while (!this->_Isnil(_Pnode))
; 2096 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))
; 2097 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2098 : 			else
; 2099 : 				{	// _Pnode not less than _Keyval, remember it
; 2100 : 				_Wherenode = _Pnode;
; 2101 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2102 : 				}
; 2103 : 
; 2104 : 		return (_Wherenode);	// return best remembered candidate
; 2105 : 		}
; 2106 : 
; 2107 : 	_Nodeptr& _Lmost() const
; 2108 : 		{	// return leftmost node in nonmutable tree
; 2109 : 		return (this->_Left(this->_Myhead));
; 2110 : 		}
; 2111 : 
; 2112 : 	void _Lrotate(_Nodeptr _Wherenode)
; 2113 : 		{	// promote right node to root of subtree
; 2114 : 		_Nodeptr _Pnode = this->_Right(_Wherenode);
; 2115 : 		this->_Right(_Wherenode) = this->_Left(_Pnode);
; 2116 : 
; 2117 : 		if (!this->_Isnil(this->_Left(_Pnode)))
; 2118 : 			this->_Parent(this->_Left(_Pnode)) = _Wherenode;
; 2119 : 		this->_Parent(_Pnode) = this->_Parent(_Wherenode);
; 2120 : 
; 2121 : 		if (_Wherenode == _Root())
; 2122 : 			_Root() = _Pnode;
; 2123 : 		else if (_Wherenode == this->_Left(this->_Parent(_Wherenode)))
; 2124 : 			this->_Left(this->_Parent(_Wherenode)) = _Pnode;
; 2125 : 		else
; 2126 : 			this->_Right(this->_Parent(_Wherenode)) = _Pnode;
; 2127 : 
; 2128 : 		this->_Left(_Pnode) = _Wherenode;
; 2129 : 		this->_Parent(_Wherenode) = _Pnode;
; 2130 : 		}
; 2131 : 
; 2132 : 	_Nodeptr& _Rmost() const
; 2133 : 		{	// return rightmost node in nonmutable tree
; 2134 : 		return (this->_Right(this->_Myhead));
; 2135 : 		}
; 2136 : 
; 2137 : 	_Nodeptr& _Root() const
; 2138 : 		{	// return root of nonmutable tree
; 2139 : 		return (this->_Parent(this->_Myhead));
; 2140 : 		}
; 2141 : 
; 2142 : 	void _Rrotate(_Nodeptr _Wherenode)
; 2143 : 		{	// promote left node to root of subtree
; 2144 : 		_Nodeptr _Pnode = this->_Left(_Wherenode);
; 2145 : 		this->_Left(_Wherenode) = this->_Right(_Pnode);
; 2146 : 
; 2147 : 		if (!this->_Isnil(this->_Right(_Pnode)))
; 2148 : 			this->_Parent(this->_Right(_Pnode)) = _Wherenode;
; 2149 : 		this->_Parent(_Pnode) = this->_Parent(_Wherenode);
; 2150 : 
; 2151 : 		if (_Wherenode == _Root())
; 2152 : 			_Root() = _Pnode;
; 2153 : 		else if (_Wherenode == this->_Right(this->_Parent(_Wherenode)))
; 2154 : 			this->_Right(this->_Parent(_Wherenode)) = _Pnode;
; 2155 : 		else
; 2156 : 			this->_Left(this->_Parent(_Wherenode)) = _Pnode;
; 2157 : 
; 2158 : 		this->_Right(_Pnode) = _Wherenode;
; 2159 : 		this->_Parent(_Wherenode) = _Pnode;
; 2160 : 		}
; 2161 : 
; 2162 : 	_Nodeptr _Ubound(const key_type& _Keyval) const
; 2163 : 		{	// find leftmost node greater than _Keyval
; 2164 : 		_Nodeptr _Pnode = _Root();
; 2165 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails
; 2166 : 
; 2167 : 		while (!this->_Isnil(_Pnode))
; 2168 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), _Keyval, this->_Key(_Pnode)))
; 2169 : 				{	// _Pnode greater than _Keyval, remember it
; 2170 : 				_Wherenode = _Pnode;
; 2171 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2172 : 				}
; 2173 : 			else
; 2174 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2175 : 
; 2176 : 		return (_Wherenode);	// return best remembered candidate
; 2177 : 		}
; 2178 : 
; 2179 : 	_Nodeptr _Ubound(const key_type& _Keyval)
; 2180 : 		{	// find leftmost node greater than _Keyval
; 2181 : 		_Nodeptr _Pnode = _Root();
; 2182 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails
; 2183 : 
; 2184 : 		while (!this->_Isnil(_Pnode))
; 2185 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), _Keyval, this->_Key(_Pnode)))
; 2186 : 				{	// _Pnode greater than _Keyval, remember it
; 2187 : 				_Wherenode = _Pnode;
; 2188 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2189 : 				}
; 2190 : 			else
; 2191 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2192 : 
; 2193 : 		return (_Wherenode);	// return best remembered candidate
; 2194 : 		}
; 2195 : 
; 2196 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2197 : 	void _Orphan_ptr(_Myt& _Cont, _Nodeptr _Ptr) const
; 2198 : 		{	// orphan iterators with specified node pointers
; 2199 : 		_Lockit _Lock(_LOCK_DEBUG);
; 2200 : 		const_iterator **_Pnext = (const_iterator **)_Cont._Getpfirst();
; 2201 : 		if (_Pnext != 0)
; 2202 : 			while (*_Pnext != 0)
; 2203 : 				if ((*_Pnext)->_Ptr == this->_Myhead
; 2204 : 					|| _Ptr != 0 && (*_Pnext)->_Ptr != _Ptr)
; 2205 : 					_Pnext = (const_iterator **)(*_Pnext)->_Getpnext();
; 2206 : 				else
; 2207 : 					{	// orphan the iterator
; 2208 : 					(*_Pnext)->_Clrcont();
; 2209 : 					*_Pnext = *(const_iterator **)(*_Pnext)->_Getpnext();
; 2210 : 					}
; 2211 : 		}
; 2212 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2213 : 
; 2214 : 	void _Tidy()
; 2215 : 		{	// free all storage
; 2216 : 		erase(begin(), end());

  00007	8b 06		 mov	 eax, DWORD PTR [esi]
  00009	50		 push	 eax
  0000a	ff 30		 push	 DWORD PTR [eax]
  0000c	8d 45 fc	 lea	 eax, DWORD PTR $T1[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::erase
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 586  : 		::operator delete(_Ptr);

  00015	ff 36		 push	 DWORD PTR [esi]
  00017	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0001c	83 c4 04	 add	 esp, 4
  0001f	5e		 pop	 esi
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree

; 1190 : 		}

  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
??1?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::~_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QAEIABVChunkPosition@@@Z
_TEXT	SEGMENT
$T1 = -12						; size = 8
$T2 = -8						; size = 4
$T3 = 8							; size = 1
__Num$ = 8						; size = 4
__Keyval$ = 8						; size = 4
?erase@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QAEIABVChunkPosition@@@Z PROC ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::erase, COMDAT
; _this$ = ecx

; 1523 : 		{	// erase and count all that match _Keyval

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1530 : 
; 1531 : 	void clear() _NOEXCEPT
; 1532 : 		{	// erase all
; 1533 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1534 : 		this->_Orphan_ptr(*this, 0);
; 1535 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1536 : 
; 1537 : 		_Erase(_Root());
; 1538 : 		_Root() = this->_Myhead;
; 1539 : 		_Lmost() = this->_Myhead;
; 1540 : 		_Rmost() = this->_Myhead;
; 1541 : 		this->_Mysize = 0;
; 1542 : 		}
; 1543 : 
; 1544 : 	iterator find(const key_type& _Keyval)
; 1545 : 		{	// find an element in mutable sequence that matches _Keyval
; 1546 : 		iterator _Where = lower_bound(_Keyval);
; 1547 : 		return (_Where == end()
; 1548 : 			|| _DEBUG_LT_PRED(this->_Getcomp(),
; 1549 : 				_Keyval, this->_Key(_Where._Mynode()))
; 1550 : 					? end() : _Where);
; 1551 : 		}
; 1552 : 
; 1553 : 	const_iterator find(const key_type& _Keyval) const
; 1554 : 		{	// find an element in nonmutable sequence that matches _Keyval
; 1555 : 		const_iterator _Where = lower_bound(_Keyval);
; 1556 : 		return (_Where == end()
; 1557 : 			|| _DEBUG_LT_PRED(this->_Getcomp(),
; 1558 : 				_Keyval, this->_Key(_Where._Mynode()))
; 1559 : 					? end() : _Where);
; 1560 : 		}
; 1561 : 
; 1562 : 	size_type count(const key_type& _Keyval) const
; 1563 : 		{	// count all elements that match _Keyval
; 1564 : 		_Paircc _Ans = equal_range(_Keyval);
; 1565 : 		size_type _Num = 0;
; 1566 : 		_Distance(_Ans.first, _Ans.second, _Num);
; 1567 : 		return (_Num);
; 1568 : 		}
; 1569 : 
; 1570 : 	iterator lower_bound(const key_type& _Keyval)
; 1571 : 		{	// find leftmost node not less than _Keyval in mutable tree
; 1572 : 		return (iterator(_Lbound(_Keyval), this));
; 1573 : 		}
; 1574 : 
; 1575 : 	const_iterator lower_bound(const key_type& _Keyval) const
; 1576 : 		{	// find leftmost node not less than _Keyval in nonmutable tree
; 1577 : 		return (const_iterator(_Lbound(_Keyval), this));
; 1578 : 		}
; 1579 : 
; 1580 : 	iterator upper_bound(const key_type& _Keyval)
; 1581 : 		{	// find leftmost node greater than _Keyval in mutable tree
; 1582 : 		return (iterator(_Ubound(_Keyval), this));
; 1583 : 		}
; 1584 : 
; 1585 : 	const_iterator upper_bound(const key_type& _Keyval) const
; 1586 : 		{	// find leftmost node greater than _Keyval in nonmutable tree
; 1587 : 		return (const_iterator(_Ubound(_Keyval), this));
; 1588 : 		}
; 1589 : 
; 1590 : 	_Pairii equal_range(const key_type& _Keyval)
; 1591 : 		{	// find range equivalent to _Keyval in mutable tree
; 1592 : 		return (_Eqrange(_Keyval));

  00009	ff 75 08	 push	 DWORD PTR __Keyval$[ebp]
  0000c	8d 45 f4	 lea	 eax, DWORD PTR $T1[ebp]
  0000f	50		 push	 eax

; 1523 : 		{	// erase and count all that match _Keyval

  00010	8b d9		 mov	 ebx, ecx

; 1530 : 
; 1531 : 	void clear() _NOEXCEPT
; 1532 : 		{	// erase all
; 1533 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1534 : 		this->_Orphan_ptr(*this, 0);
; 1535 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1536 : 
; 1537 : 		_Erase(_Root());
; 1538 : 		_Root() = this->_Myhead;
; 1539 : 		_Lmost() = this->_Myhead;
; 1540 : 		_Rmost() = this->_Myhead;
; 1541 : 		this->_Mysize = 0;
; 1542 : 		}
; 1543 : 
; 1544 : 	iterator find(const key_type& _Keyval)
; 1545 : 		{	// find an element in mutable sequence that matches _Keyval
; 1546 : 		iterator _Where = lower_bound(_Keyval);
; 1547 : 		return (_Where == end()
; 1548 : 			|| _DEBUG_LT_PRED(this->_Getcomp(),
; 1549 : 				_Keyval, this->_Key(_Where._Mynode()))
; 1550 : 					? end() : _Where);
; 1551 : 		}
; 1552 : 
; 1553 : 	const_iterator find(const key_type& _Keyval) const
; 1554 : 		{	// find an element in nonmutable sequence that matches _Keyval
; 1555 : 		const_iterator _Where = lower_bound(_Keyval);
; 1556 : 		return (_Where == end()
; 1557 : 			|| _DEBUG_LT_PRED(this->_Getcomp(),
; 1558 : 				_Keyval, this->_Key(_Where._Mynode()))
; 1559 : 					? end() : _Where);
; 1560 : 		}
; 1561 : 
; 1562 : 	size_type count(const key_type& _Keyval) const
; 1563 : 		{	// count all elements that match _Keyval
; 1564 : 		_Paircc _Ans = equal_range(_Keyval);
; 1565 : 		size_type _Num = 0;
; 1566 : 		_Distance(_Ans.first, _Ans.second, _Num);
; 1567 : 		return (_Num);
; 1568 : 		}
; 1569 : 
; 1570 : 	iterator lower_bound(const key_type& _Keyval)
; 1571 : 		{	// find leftmost node not less than _Keyval in mutable tree
; 1572 : 		return (iterator(_Lbound(_Keyval), this));
; 1573 : 		}
; 1574 : 
; 1575 : 	const_iterator lower_bound(const key_type& _Keyval) const
; 1576 : 		{	// find leftmost node not less than _Keyval in nonmutable tree
; 1577 : 		return (const_iterator(_Lbound(_Keyval), this));
; 1578 : 		}
; 1579 : 
; 1580 : 	iterator upper_bound(const key_type& _Keyval)
; 1581 : 		{	// find leftmost node greater than _Keyval in mutable tree
; 1582 : 		return (iterator(_Ubound(_Keyval), this));
; 1583 : 		}
; 1584 : 
; 1585 : 	const_iterator upper_bound(const key_type& _Keyval) const
; 1586 : 		{	// find leftmost node greater than _Keyval in nonmutable tree
; 1587 : 		return (const_iterator(_Ubound(_Keyval), this));
; 1588 : 		}
; 1589 : 
; 1590 : 	_Pairii equal_range(const key_type& _Keyval)
; 1591 : 		{	// find range equivalent to _Keyval in mutable tree
; 1592 : 		return (_Eqrange(_Keyval));

  00012	e8 00 00 00 00	 call	 ?_Eqrange@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@V12@@2@ABVChunkPosition@@@Z ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Eqrange
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility

; 182  : 		{	// construct from moved compatible pair

  00017	8b 70 04	 mov	 esi, DWORD PTR [eax+4]
  0001a	8b 38		 mov	 edi, DWORD PTR [eax]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree

; 1525 : 		size_type _Num = 0;

  0001c	c7 45 08 00 00
	00 00		 mov	 DWORD PTR __Num$[ebp], 0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility

; 831  : 	_Distance2(_First, _Last, _Off, _Iter_cat(_First));

  00023	ff 75 08	 push	 DWORD PTR $T3[ebp]
  00026	8d 4d 08	 lea	 ecx, DWORD PTR __Num$[ebp]
  00029	56		 push	 esi
  0002a	57		 push	 edi
  0002b	e8 00 00 00 00	 call	 ??$_Distance2@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@I@std@@YAXV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@0@0AAIUbidirectional_iterator_tag@0@@Z ; std::_Distance2<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,unsigned int>
  00030	83 c4 0c	 add	 esp, 12			; 0000000cH
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree

; 1527 : 		erase(_Where.first, _Where.second);

  00033	8d 45 f8	 lea	 eax, DWORD PTR $T2[ebp]
  00036	56		 push	 esi
  00037	57		 push	 edi
  00038	50		 push	 eax
  00039	8b cb		 mov	 ecx, ebx
  0003b	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::erase

; 1528 : 		return (_Num);

  00040	8b 45 08	 mov	 eax, DWORD PTR __Num$[ebp]

; 1529 : 		}

  00043	5f		 pop	 edi
  00044	5e		 pop	 esi
  00045	5b		 pop	 ebx
  00046	8b e5		 mov	 esp, ebp
  00048	5d		 pop	 ebp
  00049	c2 04 00	 ret	 4
?erase@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QAEIABVChunkPosition@@@Z ENDP ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::erase
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
;	COMDAT ?find@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@ABVChunkPosition@@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
$T1 = 12						; size = 4
$T2 = 12						; size = 4
__Keyval$ = 12						; size = 4
?find@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@ABVChunkPosition@@@Z PROC ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::find, COMDAT
; _this$ = ecx

; 1545 : 		{	// find an element in mutable sequence that matches _Keyval

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi

; 1552 : 
; 1553 : 	const_iterator find(const key_type& _Keyval) const
; 1554 : 		{	// find an element in nonmutable sequence that matches _Keyval
; 1555 : 		const_iterator _Where = lower_bound(_Keyval);
; 1556 : 		return (_Where == end()
; 1557 : 			|| _DEBUG_LT_PRED(this->_Getcomp(),
; 1558 : 				_Keyval, this->_Key(_Where._Mynode()))
; 1559 : 					? end() : _Where);
; 1560 : 		}
; 1561 : 
; 1562 : 	size_type count(const key_type& _Keyval) const
; 1563 : 		{	// count all elements that match _Keyval
; 1564 : 		_Paircc _Ans = equal_range(_Keyval);
; 1565 : 		size_type _Num = 0;
; 1566 : 		_Distance(_Ans.first, _Ans.second, _Num);
; 1567 : 		return (_Num);
; 1568 : 		}
; 1569 : 
; 1570 : 	iterator lower_bound(const key_type& _Keyval)
; 1571 : 		{	// find leftmost node not less than _Keyval in mutable tree
; 1572 : 		return (iterator(_Lbound(_Keyval), this));

  00005	8b 7d 0c	 mov	 edi, DWORD PTR __Keyval$[ebp]
  00008	57		 push	 edi

; 1545 : 		{	// find an element in mutable sequence that matches _Keyval

  00009	8b f1		 mov	 esi, ecx

; 1552 : 
; 1553 : 	const_iterator find(const key_type& _Keyval) const
; 1554 : 		{	// find an element in nonmutable sequence that matches _Keyval
; 1555 : 		const_iterator _Where = lower_bound(_Keyval);
; 1556 : 		return (_Where == end()
; 1557 : 			|| _DEBUG_LT_PRED(this->_Getcomp(),
; 1558 : 				_Keyval, this->_Key(_Where._Mynode()))
; 1559 : 					? end() : _Where);
; 1560 : 		}
; 1561 : 
; 1562 : 	size_type count(const key_type& _Keyval) const
; 1563 : 		{	// count all elements that match _Keyval
; 1564 : 		_Paircc _Ans = equal_range(_Keyval);
; 1565 : 		size_type _Num = 0;
; 1566 : 		_Distance(_Ans.first, _Ans.second, _Num);
; 1567 : 		return (_Num);
; 1568 : 		}
; 1569 : 
; 1570 : 	iterator lower_bound(const key_type& _Keyval)
; 1571 : 		{	// find leftmost node not less than _Keyval in mutable tree
; 1572 : 		return (iterator(_Lbound(_Keyval), this));

  0000b	e8 00 00 00 00	 call	 ?_Lbound@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@2@ABVChunkPosition@@@Z ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Lbound

; 45   : 		this->_Adopt(_Plist);
; 46   : 		}
; 47   : 
; 48   : 	reference operator*() const
; 49   : 		{	// return designated value
; 50   : 		return (_Mytree::_Myval(_Ptr));
; 51   : 		}
; 52   : 
; 53   : 	pointer operator->() const
; 54   : 		{	// return pointer to class object
; 55   : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 56   : 		}
; 57   : 
; 58   : 	_Myiter& operator++()
; 59   : 		{	// preincrement
; 60   : 		if (_Mytree::_Isnil(_Ptr))
; 61   : 			;	// end() shouldn't be incremented, don't move
; 62   : 		else if (!_Mytree::_Isnil(_Mytree::_Right(_Ptr)))
; 63   : 			_Ptr = _Mytree::_Min(
; 64   : 				_Mytree::_Right(_Ptr));	// ==> smallest of right subtree
; 65   : 		else
; 66   : 			{	// climb looking for right subtree
; 67   : 			_Nodeptr _Pnode;
; 68   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 69   : 				&& _Ptr == _Mytree::_Right(_Pnode))
; 70   : 				_Ptr = _Pnode;	// ==> parent while right subtree
; 71   : 			_Ptr = _Pnode;	// ==> parent (head if end())
; 72   : 			}
; 73   : 		return (*this);
; 74   : 		}
; 75   : 
; 76   : 	_Myiter operator++(int)
; 77   : 		{	// postincrement
; 78   : 		_Myiter _Tmp = *this;
; 79   : 		++*this;
; 80   : 		return (_Tmp);
; 81   : 		}
; 82   : 
; 83   : 	_Myiter& operator--()
; 84   : 		{	// predecrement
; 85   : 		if (_Mytree::_Isnil(_Ptr))
; 86   : 			_Ptr = _Mytree::_Right(_Ptr);	// end() ==> rightmost
; 87   : 		else if (!_Mytree::_Isnil(_Mytree::_Left(_Ptr)))
; 88   : 			_Ptr = _Mytree::_Max(
; 89   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree
; 90   : 		else
; 91   : 			{	// climb looking for left subtree
; 92   : 			_Nodeptr _Pnode;
; 93   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 94   : 				&& _Ptr == _Mytree::_Left(_Pnode))
; 95   : 				_Ptr = _Pnode;	// ==> parent while left subtree
; 96   : 			if (_Mytree::_Isnil(_Ptr))
; 97   : 				;	// begin() shouldn't be decremented, don't move
; 98   : 			else
; 99   : 				_Ptr = _Pnode;	// ==> parent if not head
; 100  : 			}
; 101  : 		return (*this);
; 102  : 		}
; 103  : 
; 104  : 	_Myiter operator--(int)
; 105  : 		{	// postdecrement
; 106  : 		_Myiter _Tmp = *this;
; 107  : 		--*this;
; 108  : 		return (_Tmp);
; 109  : 		}
; 110  : 
; 111  : 	bool operator==(const _Myiter& _Right) const
; 112  : 		{	// test for iterator equality
; 113  : 		return (_Ptr == _Right._Ptr);
; 114  : 		}
; 115  : 
; 116  : 	bool operator!=(const _Myiter& _Right) const
; 117  : 		{	// test for iterator inequality
; 118  : 		return (!(*this == _Right));
; 119  : 		}
; 120  : 
; 121  : 	_Nodeptr _Mynode() const
; 122  : 		{	// return node pointer
; 123  : 		return (_Ptr);
; 124  : 		}
; 125  : 
; 126  : 	_Nodeptr _Ptr;	// pointer to node
; 127  : 	};
; 128  : 
; 129  : 	// TEMPLATE CLASS _Tree_unchecked_iterator
; 130  : template<class _Mytree>
; 131  : 	class _Tree_unchecked_iterator
; 132  : 		: public _Tree_unchecked_const_iterator<_Mytree>
; 133  : 	{	// unchecked iterator for mutable tree
; 134  : public:
; 135  : 	typedef _Tree_unchecked_iterator<_Mytree> _Myiter;
; 136  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Mybase;
; 137  : 	typedef bidirectional_iterator_tag iterator_category;
; 138  : 
; 139  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 140  : 	typedef typename _Mytree::value_type value_type;
; 141  : 	typedef typename _Mytree::difference_type difference_type;
; 142  : 	typedef typename _Mytree::pointer pointer;
; 143  : 	typedef typename _Mytree::reference reference;
; 144  : 
; 145  : 	_Tree_unchecked_iterator()
; 146  : 		{	// construct with null node
; 147  : 		}
; 148  : 
; 149  : 	_Tree_unchecked_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 150  : 		: _Mybase(_Pnode, _Plist)
; 151  : 		{	// construct with node pointer _Pnode
; 152  : 		}
; 153  : 
; 154  : 	reference operator*() const
; 155  : 		{	// return designated value
; 156  : 		return ((reference)**(_Mybase *)this);
; 157  : 		}
; 158  : 
; 159  : 	pointer operator->() const
; 160  : 		{	// return pointer to class object
; 161  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 162  : 		}
; 163  : 
; 164  : 	_Myiter& operator++()
; 165  : 		{	// preincrement
; 166  : 		++(*(_Mybase *)this);
; 167  : 		return (*this);
; 168  : 		}
; 169  : 
; 170  : 	_Myiter operator++(int)
; 171  : 		{	// postincrement
; 172  : 		_Myiter _Tmp = *this;
; 173  : 		++*this;
; 174  : 		return (_Tmp);
; 175  : 		}
; 176  : 
; 177  : 	_Myiter& operator--()
; 178  : 		{	// predecrement
; 179  : 		--(*(_Mybase *)this);
; 180  : 		return (*this);
; 181  : 		}
; 182  : 
; 183  : 	_Myiter operator--(int)
; 184  : 		{	// postdecrement
; 185  : 		_Myiter _Tmp = *this;
; 186  : 		--*this;
; 187  : 		return (_Tmp);
; 188  : 		}
; 189  : 	};
; 190  : 
; 191  : 	// TEMPLATE CLASS _Tree_const_iterator
; 192  : template<class _Mytree>
; 193  : 	class _Tree_const_iterator
; 194  : 		: public _Tree_unchecked_const_iterator<_Mytree, _Iterator_base>
; 195  : 	{	// iterator for nonmutable tree
; 196  : public:
; 197  : 	typedef _Tree_const_iterator<_Mytree> _Myiter;
; 198  : 	typedef _Tree_unchecked_const_iterator<_Mytree, _Iterator_base> _Mybase;
; 199  : 	typedef bidirectional_iterator_tag iterator_category;
; 200  : 
; 201  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 202  : 	typedef typename _Mytree::value_type value_type;
; 203  : 	typedef typename _Mytree::difference_type difference_type;
; 204  : 	typedef typename _Mytree::const_pointer pointer;
; 205  : 	typedef typename _Mytree::const_reference reference;
; 206  : 
; 207  : 	_Tree_const_iterator()
; 208  : 		: _Mybase()
; 209  : 		{	// construct with null node pointer
; 210  : 		}
; 211  : 
; 212  : 	_Tree_const_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 213  : 		: _Mybase(_Pnode, _Plist)
; 214  : 		{	// construct with node pointer _Pnode
; 215  : 		}
; 216  : 
; 217  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Unchecked_type;
; 218  : 
; 219  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 220  : 		{	// reset from unchecked iterator
; 221  : 		this->_Ptr = _Right._Ptr;
; 222  : 		return (*this);
; 223  : 		}
; 224  : 
; 225  : 	_Unchecked_type _Unchecked() const
; 226  : 		{	// make an unchecked iterator
; 227  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 228  : 		}
; 229  : 
; 230  : 	reference operator*() const
; 231  : 		{	// return designated value
; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		if (this->_Getcont() == 0
; 234  : 			|| this->_Ptr == 0
; 235  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 236  : 			{	// report error
; 237  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 238  : 			_SCL_SECURE_OUT_OF_RANGE;
; 239  : 			}
; 240  : 
; 241  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 242  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 243  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 244  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 245  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 246  : 
; 247  : 		return (_Mytree::_Myval(this->_Ptr));
; 248  : 		}
; 249  : 
; 250  : 	pointer operator->() const
; 251  : 		{	// return pointer to class object
; 252  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 253  : 		}
; 254  : 
; 255  : 	_Myiter& operator++()
; 256  : 		{	// preincrement
; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);
; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);

  00010	8b 36		 mov	 esi, DWORD PTR [esi]
  00012	3b c6		 cmp	 eax, esi

; 1550 : 					? end() : _Where);

  00014	74 37		 je	 SHORT $LN3@find
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp

; 296  : 	if(cp1.x < cp2.x)

  00016	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00018	8b 50 10	 mov	 edx, DWORD PTR [eax+16]
  0001b	3b ca		 cmp	 ecx, edx
  0001d	7c 2e		 jl	 SHORT $LN3@find

; 297  : 	{
; 298  : 		return true;
; 299  : 	}
; 300  : 	else if(cp1.x == cp2.x)

  0001f	75 19		 jne	 SHORT $LN59@find

; 301  : 	{
; 302  : 		if(cp1.y < cp2.y)

  00021	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  00024	8b 50 14	 mov	 edx, DWORD PTR [eax+20]
  00027	3b ca		 cmp	 ecx, edx
  00029	7c 22		 jl	 SHORT $LN3@find

; 303  : 		{
; 304  : 			return true;
; 305  : 		}
; 306  : 		else if(cp1.y == cp2.y)

  0002b	75 0d		 jne	 SHORT $LN59@find

; 307  : 		{
; 308  : 			return cp1.z < cp2.z;

  0002d	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  00030	3b 48 18	 cmp	 ecx, DWORD PTR [eax+24]
  00033	0f 9c c1	 setl	 cl
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree

; 1550 : 					? end() : _Where);

  00036	84 c9		 test	 cl, cl
  00038	75 13		 jne	 SHORT $LN3@find
$LN59@find:
  0003a	89 45 0c	 mov	 DWORD PTR $T1[ebp], eax
  0003d	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00040	8d 4d 0c	 lea	 ecx, DWORD PTR $T2[ebp]
  00043	5f		 pop	 edi
  00044	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00046	89 08		 mov	 DWORD PTR [eax], ecx
  00048	5e		 pop	 esi

; 1551 : 		}

  00049	5d		 pop	 ebp
  0004a	c2 08 00	 ret	 8
$LN3@find:

; 1550 : 					? end() : _Where);

  0004d	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00050	8d 4d 0c	 lea	 ecx, DWORD PTR $T2[ebp]

; 44   : 		{	// construct with node pointer _Pnode

  00053	89 75 0c	 mov	 DWORD PTR $T2[ebp], esi

; 1550 : 					? end() : _Where);

  00056	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00058	5f		 pop	 edi
  00059	89 08		 mov	 DWORD PTR [eax], ecx
  0005b	5e		 pop	 esi

; 1551 : 		}

  0005c	5d		 pop	 ebp
  0005d	c2 08 00	 ret	 8
?find@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@ABVChunkPosition@@@Z ENDP ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::find
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ??4?$shared_ptr@VChunkBase@@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
$T1 = -12						; size = 8
__Right$ = 8						; size = 4
??4?$shared_ptr@VChunkBase@@@std@@QAEAAV01@ABV01@@Z PROC ; std::shared_ptr<ChunkBase>::operator=, COMDAT
; _this$ = ecx

; 627  : 		{	// assign shared ownership of resource owned by _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 628  : 		shared_ptr(_Right).swap(*this);

  00009	ff 75 08	 push	 DWORD PTR __Right$[ebp]
  0000c	8b f1		 mov	 esi, ecx
  0000e	8d 4d f4	 lea	 ecx, DWORD PTR $T1[ebp]
  00011	e8 00 00 00 00	 call	 ??0?$shared_ptr@VChunkBase@@@std@@QAE@ABV01@@Z ; std::shared_ptr<ChunkBase>::shared_ptr<ChunkBase>
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility

; 48   : 	_Left = _Move(_Right);

  00016	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00019	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0001c	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 49   : 	_Right = _Move(_Tmp);

  0001f	89 56 04	 mov	 DWORD PTR [esi+4], edx

; 48   : 	_Left = _Move(_Right);

  00022	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00024	8b 10		 mov	 edx, DWORD PTR [eax]
  00026	89 08		 mov	 DWORD PTR [eax], ecx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  00028	8b 7d f8	 mov	 edi, DWORD PTR $T1[ebp+4]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility

; 49   : 	_Right = _Move(_Tmp);

  0002b	89 16		 mov	 DWORD PTR [esi], edx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  0002d	85 ff		 test	 edi, edi
  0002f	74 25		 je	 SHORT $LN36@operator

; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  00031	83 cb ff	 or	 ebx, -1
  00034	8d 4f 04	 lea	 ecx, DWORD PTR [edi+4]
  00037	8b c3		 mov	 eax, ebx
  00039	f0 0f c1 01	 lock	  xadd	 DWORD PTR [ecx], eax
  0003d	75 17		 jne	 SHORT $LN36@operator

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  0003f	8b 07		 mov	 eax, DWORD PTR [edi]
  00041	8b cf		 mov	 ecx, edi
  00043	ff 10		 call	 DWORD PTR [eax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  00045	8d 47 08	 lea	 eax, DWORD PTR [edi+8]
  00048	f0 0f c1 18	 lock	  xadd	 DWORD PTR [eax], ebx
  0004c	4b		 dec	 ebx
  0004d	75 07		 jne	 SHORT $LN36@operator

; 128  : 			_Delete_this();

  0004f	8b 07		 mov	 eax, DWORD PTR [edi]
  00051	8b cf		 mov	 ecx, edi
  00053	ff 50 04	 call	 DWORD PTR [eax+4]
$LN36@operator:

; 629  : 		return (*this);
; 630  : 		}

  00056	5f		 pop	 edi
  00057	8b c6		 mov	 eax, esi
  00059	5e		 pop	 esi
  0005a	5b		 pop	 ebx
  0005b	8b e5		 mov	 esp, ebp
  0005d	5d		 pop	 ebp
  0005e	c2 04 00	 ret	 4
??4?$shared_ptr@VChunkBase@@@std@@QAEAAV01@ABV01@@Z ENDP ; std::shared_ptr<ChunkBase>::operator=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
;	COMDAT ??C?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QBEPAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@XZ
_TEXT	SEGMENT
??C?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QBEPAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@XZ PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::operator->, COMDAT
; _this$ = ecx

; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  :  #if _HAS_CPP0X
; 520  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 521  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 522  : 
; 523  :  #else /* _HAS_CPP0X */
; 524  : 	typedef typename _Alloc::template rebind<_Ty>::other _Alty;
; 525  :  #endif /* _HAS_CPP0X */
; 526  : 
; 527  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 528  : 		_Voidptr;
; 529  : 	typedef _Tree_node<typename _Alty::value_type,
; 530  : 		_Voidptr> _Node;
; 531  : 
; 532  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 533  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 534  : 	typedef _Nodeptr& _Nodepref;
; 535  : 
; 536  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 537  : 		_Tree_simple_types<typename _Alty::value_type>,
; 538  : 		_Tree_iter_types<typename _Alty::value_type,
; 539  : 			typename _Alty::size_type,
; 540  : 			typename _Alty::difference_type,
; 541  : 			typename _Alty::pointer,
; 542  : 			typename _Alty::const_pointer,
; 543  : 			typename _Alty::reference,
; 544  : 			typename _Alty::const_reference,
; 545  : 			_Nodeptr> >::type
; 546  : 		_Val_types;
; 547  : 	};
; 548  : 
; 549  : 		// TEMPLATE CLASS _Tree_val
; 550  : template<class _Val_types>
; 551  : 	class _Tree_val
; 552  : 		: public _Container_base
; 553  : 	{	// base class for tree to hold data
; 554  : public:
; 555  : 	typedef _Tree_val<_Val_types> _Myt;
; 556  : 
; 557  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 558  : 	typedef _Nodeptr& _Nodepref;
; 559  : 
; 560  : 	typedef typename _Val_types::value_type value_type;
; 561  : 	typedef typename _Val_types::size_type size_type;
; 562  : 	typedef typename _Val_types::difference_type difference_type;
; 563  : 	typedef typename _Val_types::pointer pointer;
; 564  : 	typedef typename _Val_types::const_pointer const_pointer;
; 565  : 	typedef typename _Val_types::reference reference;
; 566  : 	typedef typename _Val_types::const_reference const_reference;
; 567  : 
; 568  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 569  : 	typedef _Tree_iterator<_Myt> iterator;
; 570  : 
; 571  : 	_Tree_val()
; 572  : 		{	// initialize data
; 573  : 		this->_Myhead = 0;
; 574  : 		this->_Mysize = 0;
; 575  : 		}
; 576  : 
; 577  : 	enum _Redbl
; 578  : 		{	// colors for link to parent
; 579  : 		_Red, _Black};
; 580  : 
; 581  : 	static char& _Color(_Nodeptr _Pnode)
; 582  : 		{	// return reference to color in node
; 583  : 		return ((char&)_Pnode->_Color);
; 584  : 		}
; 585  : 
; 586  : 	static char& _Isnil(_Nodeptr _Pnode)
; 587  : 		{	// return reference to nil flag in node
; 588  : 		return ((char&)_Pnode->_Isnil);
; 589  : 		}
; 590  : 
; 591  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 592  : 		{	// return reference to left pointer in node
; 593  : 		return ((_Nodepref)_Pnode->_Left);
; 594  : 		}
; 595  : 
; 596  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 597  : 		{	// return reference to parent pointer in node
; 598  : 		return ((_Nodepref)_Pnode->_Parent);
; 599  : 		}
; 600  : 
; 601  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 602  : 		{	// return reference to right pointer in node
; 603  : 		return ((_Nodepref)_Pnode->_Right);
; 604  : 		}
; 605  : 
; 606  : 	static reference _Myval(_Nodeptr _Pnode)
; 607  : 		{	// return reference to value in node
; 608  : 		return ((reference)_Pnode->_Myval);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 c0 10	 add	 eax, 16			; 00000010H

; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}

  00005	c3		 ret	 0
??C?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QBEPAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@XZ ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::operator->
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ??1?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@QAE@XZ PROC ; std::pair<ChunkPosition,std::shared_ptr<ChunkBase> >::~pair<ChunkPosition,std::shared_ptr<ChunkBase> >, COMDAT
; _this$ = ecx
  00000	56		 push	 esi

; 345  : 		if (_Rep != 0)

  00001	8b 71 10	 mov	 esi, DWORD PTR [ecx+16]
  00004	85 f6		 test	 esi, esi
  00006	74 29		 je	 SHORT $LN11@pair
  00008	57		 push	 edi

; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  00009	83 cf ff	 or	 edi, -1
  0000c	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  0000f	8b c7		 mov	 eax, edi
  00011	f0 0f c1 01	 lock	  xadd	 DWORD PTR [ecx], eax
  00015	75 19		 jne	 SHORT $LN14@pair

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  00017	8b 06		 mov	 eax, DWORD PTR [esi]
  00019	8b ce		 mov	 ecx, esi
  0001b	ff 10		 call	 DWORD PTR [eax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  0001d	8d 46 08	 lea	 eax, DWORD PTR [esi+8]
  00020	f0 0f c1 38	 lock	  xadd	 DWORD PTR [eax], edi
  00024	4f		 dec	 edi
  00025	75 09		 jne	 SHORT $LN14@pair

; 128  : 			_Delete_this();

  00027	8b 06		 mov	 eax, DWORD PTR [esi]
  00029	5f		 pop	 edi
  0002a	8b ce		 mov	 ecx, esi
  0002c	5e		 pop	 esi
  0002d	ff 60 04	 jmp	 DWORD PTR [eax+4]
$LN14@pair:
  00030	5f		 pop	 edi
$LN11@pair:
  00031	5e		 pop	 esi
  00032	c3		 ret	 0
??1?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@QAE@XZ ENDP ; std::pair<ChunkPosition,std::shared_ptr<ChunkBase> >::~pair<ChunkPosition,std::shared_ptr<ChunkBase> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??1?$_Tree_comp@$0A@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Tree_comp@$0A@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree_comp<0,std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::~_Tree_comp<0,std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >, COMDAT
; _this$ = ecx

; 586  : 		::operator delete(_Ptr);

  00000	ff 31		 push	 DWORD PTR [ecx]
  00002	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00007	59		 pop	 ecx
  00008	c3		 ret	 0
??1?$_Tree_comp@$0A@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree_comp<0,std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::~_Tree_comp<0,std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??1?$_Tree_buy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Tree_buy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QAE@XZ PROC ; std::_Tree_buy<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::~_Tree_buy<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >, COMDAT
; _this$ = ecx

; 586  : 		::operator delete(_Ptr);

  00000	ff 31		 push	 DWORD PTR [ecx]
  00002	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00007	59		 pop	 ecx
  00008	c3		 ret	 0
??1?$_Tree_buy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QAE@XZ ENDP ; std::_Tree_buy<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::~_Tree_buy<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
;	COMDAT ??0?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@VChunkPosition@@@1@ABV?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
__Parg$dead$ = 8					; size = 4
__Al$dead$ = 12						; size = 4
??0?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@VChunkPosition@@@1@ABV?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@1@@Z PROC ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >, COMDAT
; _this$ = ecx

; 1071 : 		{	// construct empty tree

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 573  : 		this->_Myhead = 0;

  00003	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 574  : 		this->_Mysize = 0;

  00009	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 575  : 		}
; 576  : 
; 577  : 	enum _Redbl
; 578  : 		{	// colors for link to parent
; 579  : 		_Red, _Black};
; 580  : 
; 581  : 	static char& _Color(_Nodeptr _Pnode)
; 582  : 		{	// return reference to color in node
; 583  : 		return ((char&)_Pnode->_Color);
; 584  : 		}
; 585  : 
; 586  : 	static char& _Isnil(_Nodeptr _Pnode)
; 587  : 		{	// return reference to nil flag in node
; 588  : 		return ((char&)_Pnode->_Isnil);
; 589  : 		}
; 590  : 
; 591  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 592  : 		{	// return reference to left pointer in node
; 593  : 		return ((_Nodepref)_Pnode->_Left);
; 594  : 		}
; 595  : 
; 596  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 597  : 		{	// return reference to parent pointer in node
; 598  : 		return ((_Nodepref)_Pnode->_Parent);
; 599  : 		}
; 600  : 
; 601  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 602  : 		{	// return reference to right pointer in node
; 603  : 		return ((_Nodepref)_Pnode->_Right);
; 604  : 		}
; 605  : 
; 606  : 	static reference _Myval(_Nodeptr _Pnode)
; 607  : 		{	// return reference to value in node
; 608  : 		return ((reference)_Pnode->_Myval);
; 609  : 		}
; 610  : 
; 611  : 	static _Nodeptr _Max(_Nodeptr _Pnode)
; 612  : 		{	// return rightmost node in subtree at _Pnode
; 613  : 		while (!_Isnil(_Right(_Pnode)))
; 614  : 			_Pnode = _Right(_Pnode);
; 615  : 		return (_Pnode);
; 616  : 		}
; 617  : 
; 618  : 	static _Nodeptr _Min(_Nodeptr _Pnode)
; 619  : 		{	// return leftmost node in subtree at _Pnode
; 620  : 		while (!_Isnil(_Left(_Pnode)))
; 621  : 			_Pnode = _Left(_Pnode);
; 622  : 		return (_Pnode);
; 623  : 		}
; 624  : 
; 625  : 	_Nodeptr _Myhead;	// pointer to head node
; 626  : 	size_type _Mysize;	// number of elements
; 627  : 	};
; 628  : 
; 629  : 		// TEMPLATE CLASS _Tree_alloc
; 630  : template<bool _Al_has_storage,
; 631  : 	class _Alloc_types>
; 632  : 	class _Tree_alloc
; 633  : 		: public _Tree_val<typename _Alloc_types::_Val_types>
; 634  : 	{	// base class for tree to hold allocator with storage
; 635  : public:
; 636  : 	typedef _Tree_alloc<_Al_has_storage, _Alloc_types> _Myt;
; 637  : 	typedef _Tree_val<typename _Alloc_types::_Val_types> _Mybase;
; 638  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 639  : 	typedef typename _Alloc_types::_Alnod_type _Alty;
; 640  : 	typedef typename _Alloc_types::_Node _Node;
; 641  : 	typedef typename _Alloc_types::_Nodeptr _Nodeptr;
; 642  : 
; 643  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 644  : 	_Tree_alloc(const _Alloc& _Al = _Alloc())
; 645  : 		: _Alnod(_Al)
; 646  : 		{	// construct head node, allocator from _Al
; 647  : 		this->_Myhead = _Buyheadnode();
; 648  : 		}
; 649  : 
; 650  : 	~_Tree_alloc() _NOEXCEPT
; 651  : 		{	// destroy head node
; 652  : 		_Freeheadnode(this->_Myhead);
; 653  : 		}
; 654  : 
; 655  : 	void _Change_alloc(const _Alty& _Al)
; 656  : 		{	// replace old allocator
; 657  : 		_Alnod = _Al;
; 658  : 		}
; 659  : 
; 660  : 	void _Swap_alloc(_Myt& _Right)
; 661  : 		{	// swap allocators
; 662  : 		_Swap_adl(_Alnod, _Right._Alnod);
; 663  : 		}
; 664  : 
; 665  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 666  : 	_Tree_alloc(const _Alloc& _Al = _Alloc())
; 667  : 		: _Alnod(_Al)
; 668  : 		{	// construct allocators from _Al
; 669  : 		this->_Myhead = _Buyheadnode();
; 670  : 		_TRY_BEGIN
; 671  : 		_Alloc_proxy();
; 672  : 		_CATCH_ALL
; 673  : 		_Freeheadnode(this->_Myhead);
; 674  : 		_RERAISE;
; 675  : 		_CATCH_END
; 676  : 		}
; 677  : 
; 678  : 	~_Tree_alloc() _NOEXCEPT
; 679  : 		{	// destroy proxy
; 680  : 		_Freeheadnode(this->_Myhead);
; 681  : 		_Free_proxy();
; 682  : 		}
; 683  : 
; 684  : 	void _Change_alloc(const _Alty& _Al)
; 685  : 		{	// replace old allocator
; 686  : 		_Free_proxy();
; 687  : 		_Alnod = _Al;
; 688  : 		_Alloc_proxy();
; 689  : 		}
; 690  : 
; 691  : 	void _Swap_alloc(_Myt& _Right)
; 692  : 		{	// swap allocators
; 693  : 		_Swap_adl(_Alnod, _Right._Alnod);
; 694  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 695  : 		}
; 696  : 
; 697  : 	void _Alloc_proxy()
; 698  : 		{	// construct proxy from _Alnod
; 699  : 		typename _Alty::template rebind<_Container_proxy>::other
; 700  : 			_Alproxy(_Alnod);
; 701  : 		this->_Myproxy = _Alproxy.allocate(1);
; 702  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 703  : 		this->_Myproxy->_Mycont = this;
; 704  : 		}
; 705  : 
; 706  : 	void _Free_proxy()
; 707  : 		{	// destroy proxy
; 708  : 		typename _Alty::template rebind<_Container_proxy>::other
; 709  : 			_Alproxy(_Alnod);
; 710  : 		this->_Orphan_all();
; 711  : 		_Alproxy.destroy(this->_Myproxy);
; 712  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 713  : 		this->_Myproxy = 0;
; 714  : 		}
; 715  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 716  : 
; 717  : 	_Nodeptr _Buyheadnode()
; 718  : 		{	// get head node using current allocator
; 719  : 		_Nodeptr _Pnode = _Alnod.allocate(1);
; 720  : 
; 721  : 		_TRY_BEGIN
; 722  : 		_Alnod.construct(
; 723  : 			_STD addressof(this->_Left(_Pnode)), _Pnode);
; 724  : 		_Alnod.construct(
; 725  : 			_STD addressof(this->_Parent(_Pnode)), _Pnode);
; 726  : 		_Alnod.construct(
; 727  : 			_STD addressof(this->_Right(_Pnode)), _Pnode);
; 728  : 		_CATCH_ALL
; 729  : 		_Alnod.deallocate(_Pnode, 1);
; 730  : 		_RERAISE;
; 731  : 		_CATCH_END
; 732  : 
; 733  : 		this->_Color(_Pnode) = this->_Black;
; 734  : 		this->_Isnil(_Pnode) = true;
; 735  : 		return (_Pnode);
; 736  : 		}
; 737  : 
; 738  : 	void _Freeheadnode(_Nodeptr _Pnode)
; 739  : 		{	// free head node using current allocator
; 740  : 		_Alnod.destroy(
; 741  : 			_STD addressof(this->_Left(_Pnode)));
; 742  : 		_Alnod.destroy(
; 743  : 			_STD addressof(this->_Parent(_Pnode)));
; 744  : 		_Alnod.destroy(
; 745  : 			_STD addressof(this->_Right(_Pnode)));
; 746  : 		_Alnod.deallocate(_Pnode, 1);
; 747  : 		}
; 748  : 
; 749  : 	_Alty& _Getal()
; 750  : 		{	// get reference to allocator
; 751  : 		return (_Alnod);
; 752  : 		}
; 753  : 
; 754  : 	const _Alty& _Getal() const
; 755  : 		{	// get reference to allocator
; 756  : 		return (_Alnod);
; 757  : 		}
; 758  : 
; 759  : 	_Alty _Alnod;	// allocator object for stored elements
; 760  : 	};
; 761  : 
; 762  : 		// TEMPLATE CLASS _Tree_alloc
; 763  : template<class _Alloc_types>
; 764  : 	class _Tree_alloc<false, _Alloc_types>
; 765  : 		: public _Tree_val<typename _Alloc_types::_Val_types>
; 766  : 	{	// base class for tree to hold allocator with no storage
; 767  : public:
; 768  : 	typedef _Tree_alloc<false, _Alloc_types> _Myt;
; 769  : 	typedef _Tree_val<typename _Alloc_types::_Val_types> _Mybase;
; 770  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 771  : 	typedef typename _Alloc_types::_Alnod_type _Alty;
; 772  : 	typedef typename _Alloc_types::_Node _Node;
; 773  : 	typedef typename _Alloc_types::_Nodeptr _Nodeptr;
; 774  : 
; 775  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 776  : 	_Tree_alloc(const _Alloc& = _Alloc())
; 777  : 		{	// construct head node, allocator from _Al
; 778  : 		this->_Myhead = _Buyheadnode();

  00010	e8 00 00 00 00	 call	 ?_Buyheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@2@XZ ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::_Buyheadnode
  00015	89 06		 mov	 DWORD PTR [esi], eax

; 1072 : 		}

  00017	8b c6		 mov	 eax, esi
  00019	5e		 pop	 esi
  0001a	c2 08 00	 ret	 8
??0?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@VChunkPosition@@@1@ABV?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@0@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
?erase@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@0@Z PROC ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::erase, COMDAT
; _this$ = ecx

; 1508 : 		{	// erase [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);

  00004	8b 45 0c	 mov	 eax, DWORD PTR __First$[ebp]

; 1509 : 		if (_First == begin() && _Last == end())

  00007	8b 55 10	 mov	 edx, DWORD PTR __Last$[ebp]
  0000a	56		 push	 esi
  0000b	8b f1		 mov	 esi, ecx

; 589  : 		}
; 590  : 
; 591  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 592  : 		{	// return reference to left pointer in node
; 593  : 		return ((_Nodepref)_Pnode->_Left);

  0000d	8b 0e		 mov	 ecx, DWORD PTR [esi]

; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);

  0000f	3b 01		 cmp	 eax, DWORD PTR [ecx]

; 1509 : 		if (_First == begin() && _Last == end())

  00011	75 33		 jne	 SHORT $LN115@erase

; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);

  00013	3b d1		 cmp	 edx, ecx

; 1509 : 		if (_First == begin() && _Last == end())

  00015	75 2f		 jne	 SHORT $LN115@erase

; 1521 : 
; 1522 : 	size_type erase(const key_type& _Keyval)
; 1523 : 		{	// erase and count all that match _Keyval
; 1524 : 		_Pairii _Where = equal_range(_Keyval);
; 1525 : 		size_type _Num = 0;
; 1526 : 		_Distance(_Where.first, _Where.second, _Num);
; 1527 : 		erase(_Where.first, _Where.second);
; 1528 : 		return (_Num);
; 1529 : 		}
; 1530 : 
; 1531 : 	void clear() _NOEXCEPT
; 1532 : 		{	// erase all
; 1533 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1534 : 		this->_Orphan_ptr(*this, 0);
; 1535 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1536 : 
; 1537 : 		_Erase(_Root());

  00017	ff 71 04	 push	 DWORD PTR [ecx+4]
  0001a	8b ce		 mov	 ecx, esi
  0001c	e8 00 00 00 00	 call	 ?_Erase@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Erase

; 594  : 		}
; 595  : 
; 596  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 597  : 		{	// return reference to parent pointer in node
; 598  : 		return ((_Nodepref)_Pnode->_Parent);

  00021	8b 06		 mov	 eax, DWORD PTR [esi]

; 1538 : 		_Root() = this->_Myhead;

  00023	89 40 04	 mov	 DWORD PTR [eax+4], eax

; 1539 : 		_Lmost() = this->_Myhead;

  00026	8b 06		 mov	 eax, DWORD PTR [esi]
  00028	89 00		 mov	 DWORD PTR [eax], eax

; 599  : 		}
; 600  : 
; 601  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 602  : 		{	// return reference to right pointer in node
; 603  : 		return ((_Nodepref)_Pnode->_Right);

  0002a	8b 06		 mov	 eax, DWORD PTR [esi]

; 1540 : 		_Rmost() = this->_Myhead;

  0002c	89 40 08	 mov	 DWORD PTR [eax+8], eax

; 589  : 		}
; 590  : 
; 591  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 592  : 		{	// return reference to left pointer in node
; 593  : 		return ((_Nodepref)_Pnode->_Left);

  0002f	8b 06		 mov	 eax, DWORD PTR [esi]

; 1541 : 		this->_Mysize = 0;

  00031	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 44   : 		{	// construct with node pointer _Pnode

  00038	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003a	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0003d	5e		 pop	 esi
  0003e	89 08		 mov	 DWORD PTR [eax], ecx

; 1519 : 			}
; 1520 : 		}

  00040	8b e5		 mov	 esp, ebp
  00042	5d		 pop	 ebp
  00043	c2 0c 00	 ret	 12			; 0000000cH
$LN115@erase:

; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);

  00046	3b c2		 cmp	 eax, edx

; 1510 : 			{	// erase all
; 1511 : 			clear();
; 1512 : 			return (begin());
; 1513 : 			}
; 1514 : 		else
; 1515 : 			{	// partial erase, one at a time
; 1516 : 			while (_First != _Last)

  00048	74 65		 je	 SHORT $LN1@erase
  0004a	8d 9b 00 00 00
	00		 npad	 6
$LL2@erase:

; 45   : 		this->_Adopt(_Plist);
; 46   : 		}
; 47   : 
; 48   : 	reference operator*() const
; 49   : 		{	// return designated value
; 50   : 		return (_Mytree::_Myval(_Ptr));
; 51   : 		}
; 52   : 
; 53   : 	pointer operator->() const
; 54   : 		{	// return pointer to class object
; 55   : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 56   : 		}
; 57   : 
; 58   : 	_Myiter& operator++()
; 59   : 		{	// preincrement
; 60   : 		if (_Mytree::_Isnil(_Ptr))

  00050	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0

; 72   : 			}
; 73   : 		return (*this);
; 74   : 		}
; 75   : 
; 76   : 	_Myiter operator++(int)
; 77   : 		{	// postincrement
; 78   : 		_Myiter _Tmp = *this;
; 79   : 		++*this;
; 80   : 		return (_Tmp);
; 81   : 		}
; 82   : 
; 83   : 	_Myiter& operator--()
; 84   : 		{	// predecrement
; 85   : 		if (_Mytree::_Isnil(_Ptr))
; 86   : 			_Ptr = _Mytree::_Right(_Ptr);	// end() ==> rightmost
; 87   : 		else if (!_Mytree::_Isnil(_Mytree::_Left(_Ptr)))
; 88   : 			_Ptr = _Mytree::_Max(
; 89   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree
; 90   : 		else
; 91   : 			{	// climb looking for left subtree
; 92   : 			_Nodeptr _Pnode;
; 93   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 94   : 				&& _Ptr == _Mytree::_Left(_Pnode))
; 95   : 				_Ptr = _Pnode;	// ==> parent while left subtree
; 96   : 			if (_Mytree::_Isnil(_Ptr))
; 97   : 				;	// begin() shouldn't be decremented, don't move
; 98   : 			else
; 99   : 				_Ptr = _Pnode;	// ==> parent if not head
; 100  : 			}
; 101  : 		return (*this);
; 102  : 		}
; 103  : 
; 104  : 	_Myiter operator--(int)
; 105  : 		{	// postdecrement
; 106  : 		_Myiter _Tmp = *this;
; 107  : 		--*this;
; 108  : 		return (_Tmp);
; 109  : 		}
; 110  : 
; 111  : 	bool operator==(const _Myiter& _Right) const
; 112  : 		{	// test for iterator equality
; 113  : 		return (_Ptr == _Right._Ptr);
; 114  : 		}
; 115  : 
; 116  : 	bool operator!=(const _Myiter& _Right) const
; 117  : 		{	// test for iterator inequality
; 118  : 		return (!(*this == _Right));
; 119  : 		}
; 120  : 
; 121  : 	_Nodeptr _Mynode() const
; 122  : 		{	// return node pointer
; 123  : 		return (_Ptr);
; 124  : 		}
; 125  : 
; 126  : 	_Nodeptr _Ptr;	// pointer to node
; 127  : 	};
; 128  : 
; 129  : 	// TEMPLATE CLASS _Tree_unchecked_iterator
; 130  : template<class _Mytree>
; 131  : 	class _Tree_unchecked_iterator
; 132  : 		: public _Tree_unchecked_const_iterator<_Mytree>
; 133  : 	{	// unchecked iterator for mutable tree
; 134  : public:
; 135  : 	typedef _Tree_unchecked_iterator<_Mytree> _Myiter;
; 136  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Mybase;
; 137  : 	typedef bidirectional_iterator_tag iterator_category;
; 138  : 
; 139  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 140  : 	typedef typename _Mytree::value_type value_type;
; 141  : 	typedef typename _Mytree::difference_type difference_type;
; 142  : 	typedef typename _Mytree::pointer pointer;
; 143  : 	typedef typename _Mytree::reference reference;
; 144  : 
; 145  : 	_Tree_unchecked_iterator()
; 146  : 		{	// construct with null node
; 147  : 		}
; 148  : 
; 149  : 	_Tree_unchecked_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 150  : 		: _Mybase(_Pnode, _Plist)
; 151  : 		{	// construct with node pointer _Pnode
; 152  : 		}
; 153  : 
; 154  : 	reference operator*() const
; 155  : 		{	// return designated value
; 156  : 		return ((reference)**(_Mybase *)this);
; 157  : 		}
; 158  : 
; 159  : 	pointer operator->() const
; 160  : 		{	// return pointer to class object
; 161  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 162  : 		}
; 163  : 
; 164  : 	_Myiter& operator++()
; 165  : 		{	// preincrement
; 166  : 		++(*(_Mybase *)this);
; 167  : 		return (*this);
; 168  : 		}
; 169  : 
; 170  : 	_Myiter operator++(int)
; 171  : 		{	// postincrement
; 172  : 		_Myiter _Tmp = *this;
; 173  : 		++*this;
; 174  : 		return (_Tmp);
; 175  : 		}
; 176  : 
; 177  : 	_Myiter& operator--()
; 178  : 		{	// predecrement
; 179  : 		--(*(_Mybase *)this);
; 180  : 		return (*this);
; 181  : 		}
; 182  : 
; 183  : 	_Myiter operator--(int)
; 184  : 		{	// postdecrement
; 185  : 		_Myiter _Tmp = *this;
; 186  : 		--*this;
; 187  : 		return (_Tmp);
; 188  : 		}
; 189  : 	};
; 190  : 
; 191  : 	// TEMPLATE CLASS _Tree_const_iterator
; 192  : template<class _Mytree>
; 193  : 	class _Tree_const_iterator
; 194  : 		: public _Tree_unchecked_const_iterator<_Mytree, _Iterator_base>
; 195  : 	{	// iterator for nonmutable tree
; 196  : public:
; 197  : 	typedef _Tree_const_iterator<_Mytree> _Myiter;
; 198  : 	typedef _Tree_unchecked_const_iterator<_Mytree, _Iterator_base> _Mybase;
; 199  : 	typedef bidirectional_iterator_tag iterator_category;
; 200  : 
; 201  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 202  : 	typedef typename _Mytree::value_type value_type;
; 203  : 	typedef typename _Mytree::difference_type difference_type;
; 204  : 	typedef typename _Mytree::const_pointer pointer;
; 205  : 	typedef typename _Mytree::const_reference reference;
; 206  : 
; 207  : 	_Tree_const_iterator()
; 208  : 		: _Mybase()
; 209  : 		{	// construct with null node pointer
; 210  : 		}
; 211  : 
; 212  : 	_Tree_const_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 213  : 		: _Mybase(_Pnode, _Plist)
; 214  : 		{	// construct with node pointer _Pnode
; 215  : 		}
; 216  : 
; 217  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Unchecked_type;
; 218  : 
; 219  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 220  : 		{	// reset from unchecked iterator
; 221  : 		this->_Ptr = _Right._Ptr;
; 222  : 		return (*this);
; 223  : 		}
; 224  : 
; 225  : 	_Unchecked_type _Unchecked() const
; 226  : 		{	// make an unchecked iterator
; 227  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 228  : 		}
; 229  : 
; 230  : 	reference operator*() const
; 231  : 		{	// return designated value
; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		if (this->_Getcont() == 0
; 234  : 			|| this->_Ptr == 0
; 235  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 236  : 			{	// report error
; 237  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 238  : 			_SCL_SECURE_OUT_OF_RANGE;
; 239  : 			}
; 240  : 
; 241  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 242  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 243  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 244  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 245  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 246  : 
; 247  : 		return (_Mytree::_Myval(this->_Ptr));
; 248  : 		}
; 249  : 
; 250  : 	pointer operator->() const
; 251  : 		{	// return pointer to class object
; 252  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 253  : 		}
; 254  : 
; 255  : 	_Myiter& operator++()
; 256  : 		{	// preincrement
; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);
; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;

  00054	8b c8		 mov	 ecx, eax

; 45   : 		this->_Adopt(_Plist);
; 46   : 		}
; 47   : 
; 48   : 	reference operator*() const
; 49   : 		{	// return designated value
; 50   : 		return (_Mytree::_Myval(_Ptr));
; 51   : 		}
; 52   : 
; 53   : 	pointer operator->() const
; 54   : 		{	// return pointer to class object
; 55   : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 56   : 		}
; 57   : 
; 58   : 	_Myiter& operator++()
; 59   : 		{	// preincrement
; 60   : 		if (_Mytree::_Isnil(_Ptr))

  00056	75 43		 jne	 SHORT $LN77@erase

; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  :  #if _HAS_CPP0X
; 520  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 521  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 522  : 
; 523  :  #else /* _HAS_CPP0X */
; 524  : 	typedef typename _Alloc::template rebind<_Ty>::other _Alty;
; 525  :  #endif /* _HAS_CPP0X */
; 526  : 
; 527  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 528  : 		_Voidptr;
; 529  : 	typedef _Tree_node<typename _Alty::value_type,
; 530  : 		_Voidptr> _Node;
; 531  : 
; 532  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 533  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 534  : 	typedef _Nodeptr& _Nodepref;
; 535  : 
; 536  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 537  : 		_Tree_simple_types<typename _Alty::value_type>,
; 538  : 		_Tree_iter_types<typename _Alty::value_type,
; 539  : 			typename _Alty::size_type,
; 540  : 			typename _Alty::difference_type,
; 541  : 			typename _Alty::pointer,
; 542  : 			typename _Alty::const_pointer,
; 543  : 			typename _Alty::reference,
; 544  : 			typename _Alty::const_reference,
; 545  : 			_Nodeptr> >::type
; 546  : 		_Val_types;
; 547  : 	};
; 548  : 
; 549  : 		// TEMPLATE CLASS _Tree_val
; 550  : template<class _Val_types>
; 551  : 	class _Tree_val
; 552  : 		: public _Container_base
; 553  : 	{	// base class for tree to hold data
; 554  : public:
; 555  : 	typedef _Tree_val<_Val_types> _Myt;
; 556  : 
; 557  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 558  : 	typedef _Nodeptr& _Nodepref;
; 559  : 
; 560  : 	typedef typename _Val_types::value_type value_type;
; 561  : 	typedef typename _Val_types::size_type size_type;
; 562  : 	typedef typename _Val_types::difference_type difference_type;
; 563  : 	typedef typename _Val_types::pointer pointer;
; 564  : 	typedef typename _Val_types::const_pointer const_pointer;
; 565  : 	typedef typename _Val_types::reference reference;
; 566  : 	typedef typename _Val_types::const_reference const_reference;
; 567  : 
; 568  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 569  : 	typedef _Tree_iterator<_Myt> iterator;
; 570  : 
; 571  : 	_Tree_val()
; 572  : 		{	// initialize data
; 573  : 		this->_Myhead = 0;
; 574  : 		this->_Mysize = 0;
; 575  : 		}
; 576  : 
; 577  : 	enum _Redbl
; 578  : 		{	// colors for link to parent
; 579  : 		_Red, _Black};
; 580  : 
; 581  : 	static char& _Color(_Nodeptr _Pnode)
; 582  : 		{	// return reference to color in node
; 583  : 		return ((char&)_Pnode->_Color);
; 584  : 		}
; 585  : 
; 586  : 	static char& _Isnil(_Nodeptr _Pnode)
; 587  : 		{	// return reference to nil flag in node
; 588  : 		return ((char&)_Pnode->_Isnil);

  00058	8b 50 08	 mov	 edx, DWORD PTR [eax+8]

; 61   : 			;	// end() shouldn't be incremented, don't move
; 62   : 		else if (!_Mytree::_Isnil(_Mytree::_Right(_Ptr)))

  0005b	80 7a 0d 00	 cmp	 BYTE PTR [edx+13], 0
  0005f	75 1b		 jne	 SHORT $LN117@erase

; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  :  #if _HAS_CPP0X
; 520  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 521  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 522  : 
; 523  :  #else /* _HAS_CPP0X */
; 524  : 	typedef typename _Alloc::template rebind<_Ty>::other _Alty;
; 525  :  #endif /* _HAS_CPP0X */
; 526  : 
; 527  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 528  : 		_Voidptr;
; 529  : 	typedef _Tree_node<typename _Alty::value_type,
; 530  : 		_Voidptr> _Node;
; 531  : 
; 532  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 533  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 534  : 	typedef _Nodeptr& _Nodepref;
; 535  : 
; 536  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 537  : 		_Tree_simple_types<typename _Alty::value_type>,
; 538  : 		_Tree_iter_types<typename _Alty::value_type,
; 539  : 			typename _Alty::size_type,
; 540  : 			typename _Alty::difference_type,
; 541  : 			typename _Alty::pointer,
; 542  : 			typename _Alty::const_pointer,
; 543  : 			typename _Alty::reference,
; 544  : 			typename _Alty::const_reference,
; 545  : 			_Nodeptr> >::type
; 546  : 		_Val_types;
; 547  : 	};
; 548  : 
; 549  : 		// TEMPLATE CLASS _Tree_val
; 550  : template<class _Val_types>
; 551  : 	class _Tree_val
; 552  : 		: public _Container_base
; 553  : 	{	// base class for tree to hold data
; 554  : public:
; 555  : 	typedef _Tree_val<_Val_types> _Myt;
; 556  : 
; 557  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 558  : 	typedef _Nodeptr& _Nodepref;
; 559  : 
; 560  : 	typedef typename _Val_types::value_type value_type;
; 561  : 	typedef typename _Val_types::size_type size_type;
; 562  : 	typedef typename _Val_types::difference_type difference_type;
; 563  : 	typedef typename _Val_types::pointer pointer;
; 564  : 	typedef typename _Val_types::const_pointer const_pointer;
; 565  : 	typedef typename _Val_types::reference reference;
; 566  : 	typedef typename _Val_types::const_reference const_reference;
; 567  : 
; 568  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 569  : 	typedef _Tree_iterator<_Myt> iterator;
; 570  : 
; 571  : 	_Tree_val()
; 572  : 		{	// initialize data
; 573  : 		this->_Myhead = 0;
; 574  : 		this->_Mysize = 0;
; 575  : 		}
; 576  : 
; 577  : 	enum _Redbl
; 578  : 		{	// colors for link to parent
; 579  : 		_Red, _Black};
; 580  : 
; 581  : 	static char& _Color(_Nodeptr _Pnode)
; 582  : 		{	// return reference to color in node
; 583  : 		return ((char&)_Pnode->_Color);
; 584  : 		}
; 585  : 
; 586  : 	static char& _Isnil(_Nodeptr _Pnode)
; 587  : 		{	// return reference to nil flag in node
; 588  : 		return ((char&)_Pnode->_Isnil);

  00061	8b 02		 mov	 eax, DWORD PTR [edx]

; 604  : 		}
; 605  : 
; 606  : 	static reference _Myval(_Nodeptr _Pnode)
; 607  : 		{	// return reference to value in node
; 608  : 		return ((reference)_Pnode->_Myval);
; 609  : 		}
; 610  : 
; 611  : 	static _Nodeptr _Max(_Nodeptr _Pnode)
; 612  : 		{	// return rightmost node in subtree at _Pnode
; 613  : 		while (!_Isnil(_Right(_Pnode)))
; 614  : 			_Pnode = _Right(_Pnode);
; 615  : 		return (_Pnode);
; 616  : 		}
; 617  : 
; 618  : 	static _Nodeptr _Min(_Nodeptr _Pnode)
; 619  : 		{	// return leftmost node in subtree at _Pnode
; 620  : 		while (!_Isnil(_Left(_Pnode)))

  00063	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00067	75 2f		 jne	 SHORT $LN124@erase
  00069	8d a4 24 00 00
	00 00		 npad	 7
$LL92@erase:

; 621  : 			_Pnode = _Left(_Pnode);

  00070	8b d0		 mov	 edx, eax

; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  :  #if _HAS_CPP0X
; 520  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 521  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 522  : 
; 523  :  #else /* _HAS_CPP0X */
; 524  : 	typedef typename _Alloc::template rebind<_Ty>::other _Alty;
; 525  :  #endif /* _HAS_CPP0X */
; 526  : 
; 527  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 528  : 		_Voidptr;
; 529  : 	typedef _Tree_node<typename _Alty::value_type,
; 530  : 		_Voidptr> _Node;
; 531  : 
; 532  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 533  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 534  : 	typedef _Nodeptr& _Nodepref;
; 535  : 
; 536  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 537  : 		_Tree_simple_types<typename _Alty::value_type>,
; 538  : 		_Tree_iter_types<typename _Alty::value_type,
; 539  : 			typename _Alty::size_type,
; 540  : 			typename _Alty::difference_type,
; 541  : 			typename _Alty::pointer,
; 542  : 			typename _Alty::const_pointer,
; 543  : 			typename _Alty::reference,
; 544  : 			typename _Alty::const_reference,
; 545  : 			_Nodeptr> >::type
; 546  : 		_Val_types;
; 547  : 	};
; 548  : 
; 549  : 		// TEMPLATE CLASS _Tree_val
; 550  : template<class _Val_types>
; 551  : 	class _Tree_val
; 552  : 		: public _Container_base
; 553  : 	{	// base class for tree to hold data
; 554  : public:
; 555  : 	typedef _Tree_val<_Val_types> _Myt;
; 556  : 
; 557  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 558  : 	typedef _Nodeptr& _Nodepref;
; 559  : 
; 560  : 	typedef typename _Val_types::value_type value_type;
; 561  : 	typedef typename _Val_types::size_type size_type;
; 562  : 	typedef typename _Val_types::difference_type difference_type;
; 563  : 	typedef typename _Val_types::pointer pointer;
; 564  : 	typedef typename _Val_types::const_pointer const_pointer;
; 565  : 	typedef typename _Val_types::reference reference;
; 566  : 	typedef typename _Val_types::const_reference const_reference;
; 567  : 
; 568  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 569  : 	typedef _Tree_iterator<_Myt> iterator;
; 570  : 
; 571  : 	_Tree_val()
; 572  : 		{	// initialize data
; 573  : 		this->_Myhead = 0;
; 574  : 		this->_Mysize = 0;
; 575  : 		}
; 576  : 
; 577  : 	enum _Redbl
; 578  : 		{	// colors for link to parent
; 579  : 		_Red, _Black};
; 580  : 
; 581  : 	static char& _Color(_Nodeptr _Pnode)
; 582  : 		{	// return reference to color in node
; 583  : 		return ((char&)_Pnode->_Color);
; 584  : 		}
; 585  : 
; 586  : 	static char& _Isnil(_Nodeptr _Pnode)
; 587  : 		{	// return reference to nil flag in node
; 588  : 		return ((char&)_Pnode->_Isnil);

  00072	8b 02		 mov	 eax, DWORD PTR [edx]

; 604  : 		}
; 605  : 
; 606  : 	static reference _Myval(_Nodeptr _Pnode)
; 607  : 		{	// return reference to value in node
; 608  : 		return ((reference)_Pnode->_Myval);
; 609  : 		}
; 610  : 
; 611  : 	static _Nodeptr _Max(_Nodeptr _Pnode)
; 612  : 		{	// return rightmost node in subtree at _Pnode
; 613  : 		while (!_Isnil(_Right(_Pnode)))
; 614  : 			_Pnode = _Right(_Pnode);
; 615  : 		return (_Pnode);
; 616  : 		}
; 617  : 
; 618  : 	static _Nodeptr _Min(_Nodeptr _Pnode)
; 619  : 		{	// return leftmost node in subtree at _Pnode
; 620  : 		while (!_Isnil(_Left(_Pnode)))

  00074	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00078	74 f6		 je	 SHORT $LL92@erase

; 63   : 			_Ptr = _Mytree::_Min(
; 64   : 				_Mytree::_Right(_Ptr));	// ==> smallest of right subtree
; 65   : 		else

  0007a	eb 1c		 jmp	 SHORT $LN124@erase
$LN117@erase:

; 66   : 			{	// climb looking for right subtree
; 67   : 			_Nodeptr _Pnode;
; 68   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 69   : 				&& _Ptr == _Mytree::_Right(_Pnode))

  0007c	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0007f	80 7a 0d 00	 cmp	 BYTE PTR [edx+13], 0
  00083	75 13		 jne	 SHORT $LN124@erase
$LL76@erase:
  00085	3b 42 08	 cmp	 eax, DWORD PTR [edx+8]
  00088	75 0e		 jne	 SHORT $LN124@erase

; 70   : 				_Ptr = _Pnode;	// ==> parent while right subtree

  0008a	8b c2		 mov	 eax, edx
  0008c	89 45 0c	 mov	 DWORD PTR __First$[ebp], eax
  0008f	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  00092	80 7a 0d 00	 cmp	 BYTE PTR [edx+13], 0
  00096	74 ed		 je	 SHORT $LL76@erase
$LN124@erase:

; 71   : 			_Ptr = _Pnode;	// ==> parent (head if end())

  00098	89 55 0c	 mov	 DWORD PTR __First$[ebp], edx
$LN77@erase:

; 1517 : 				erase(_First++);

  0009b	51		 push	 ecx
  0009c	8d 45 fc	 lea	 eax, DWORD PTR $T1[ebp]
  0009f	50		 push	 eax
  000a0	8b ce		 mov	 ecx, esi
  000a2	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::erase

; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);

  000a7	8b 45 0c	 mov	 eax, DWORD PTR __First$[ebp]
  000aa	3b 45 10	 cmp	 eax, DWORD PTR __Last$[ebp]

; 1510 : 			{	// erase all
; 1511 : 			clear();
; 1512 : 			return (begin());
; 1513 : 			}
; 1514 : 		else
; 1515 : 			{	// partial erase, one at a time
; 1516 : 			while (_First != _Last)

  000ad	75 a1		 jne	 SHORT $LL2@erase
$LN1@erase:

; 44   : 		{	// construct with node pointer _Pnode

  000af	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  000b2	5e		 pop	 esi
  000b3	89 01		 mov	 DWORD PTR [ecx], eax

; 1518 : 			return (iterator(_First._Ptr, this));

  000b5	8b c1		 mov	 eax, ecx

; 1519 : 			}
; 1520 : 		}

  000b7	8b e5		 mov	 esp, ebp
  000b9	5d		 pop	 ebp
  000ba	c2 0c 00	 ret	 12			; 0000000cH
?erase@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@0@Z ENDP ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::erase
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
;	COMDAT ?lower_bound@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@ABVChunkPosition@@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Keyval$ = 12						; size = 4
?lower_bound@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@ABVChunkPosition@@@Z PROC ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::lower_bound, COMDAT
; _this$ = ecx

; 1571 : 		{	// find leftmost node not less than _Keyval in mutable tree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1572 : 		return (iterator(_Lbound(_Keyval), this));

  00003	ff 75 0c	 push	 DWORD PTR __Keyval$[ebp]
  00006	e8 00 00 00 00	 call	 ?_Lbound@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@2@ABVChunkPosition@@@Z ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Lbound

; 44   : 		{	// construct with node pointer _Pnode

  0000b	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0000e	89 01		 mov	 DWORD PTR [ecx], eax

; 1572 : 		return (iterator(_Lbound(_Keyval), this));

  00010	8b c1		 mov	 eax, ecx

; 1573 : 		}

  00012	5d		 pop	 ebp
  00013	c2 08 00	 ret	 8
?lower_bound@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@ABVChunkPosition@@@Z ENDP ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::lower_bound
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
;	COMDAT ?equal_range@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@V12@@2@ABVChunkPosition@@@Z
_TEXT	SEGMENT
$T1 = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__Keyval$ = 12						; size = 4
?equal_range@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@V12@@2@ABVChunkPosition@@@Z PROC ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::equal_range, COMDAT
; _this$ = ecx

; 1591 : 		{	// find range equivalent to _Keyval in mutable tree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 1592 : 		return (_Eqrange(_Keyval));

  00006	8d 45 f8	 lea	 eax, DWORD PTR $T1[ebp]
  00009	ff 75 0c	 push	 DWORD PTR __Keyval$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ?_Eqrange@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@V12@@2@ABVChunkPosition@@@Z ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Eqrange
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility

; 182  : 		{	// construct from moved compatible pair

  00012	8b 55 08	 mov	 edx, DWORD PTR ___$ReturnUdt$[ebp]
  00015	8b 08		 mov	 ecx, DWORD PTR [eax]
  00017	89 0a		 mov	 DWORD PTR [edx], ecx
  00019	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0001c	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree

; 1592 : 		return (_Eqrange(_Keyval));

  0001f	8b c2		 mov	 eax, edx

; 1593 : 		}

  00021	8b e5		 mov	 esp, ebp
  00023	5d		 pop	 ebp
  00024	c2 08 00	 ret	 8
?equal_range@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@V12@@2@ABVChunkPosition@@@Z ENDP ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::equal_range
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
;	COMDAT ?_Tidy@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
$T1 = -4						; size = 4
?_Tidy@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IAEXXZ PROC ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Tidy, COMDAT
; _this$ = ecx

; 2215 : 		{	// free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 2216 : 		erase(begin(), end());

  00004	8b 01		 mov	 eax, DWORD PTR [ecx]
  00006	50		 push	 eax
  00007	ff 30		 push	 DWORD PTR [eax]
  00009	8d 45 fc	 lea	 eax, DWORD PTR $T1[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::erase

; 2217 : 		}

  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
?_Tidy@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\map
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
;	COMDAT ?_Key@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IBEABVChunkPosition@@PAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Key@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IBEABVChunkPosition@@PAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@2@@Z PROC ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Key, COMDAT
; _this$dead$ = ecx

; 2225 : 		{	// return reference to key in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\map

; 56   : 		return (_Val.first);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	83 c0 10	 add	 eax, 16			; 00000010H
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree

; 2227 : 		}

  00009	5d		 pop	 ebp
  0000a	c2 04 00	 ret	 4
?_Key@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IBEABVChunkPosition@@PAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Key
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstddef
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstddef
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstddef
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstddef
;	COMDAT ??R?$less@VChunkPosition@@@std@@QBE_NABVChunkPosition@@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??R?$less@VChunkPosition@@@std@@QBE_NABVChunkPosition@@0@Z PROC ; std::less<ChunkPosition>::operator(), COMDAT
; _this$dead$ = ecx

; 179  : 		{	// apply operator< to operands

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp

; 296  : 	if(cp1.x < cp2.x)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Right$[ebp]
  00009	8b 10		 mov	 edx, DWORD PTR [eax]
  0000b	56		 push	 esi
  0000c	8b 31		 mov	 esi, DWORD PTR [ecx]
  0000e	3b d6		 cmp	 edx, esi
  00010	7d 07		 jge	 SHORT $LN11@operator
$LN13@operator:

; 297  : 	{
; 298  : 		return true;

  00012	b0 01		 mov	 al, 1
  00014	5e		 pop	 esi
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstddef

; 181  : 		}

  00015	5d		 pop	 ebp
  00016	c2 08 00	 ret	 8
$LN11@operator:
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp

; 300  : 	else if(cp1.x == cp2.x)

  00019	75 1a		 jne	 SHORT $LN3@operator

; 301  : 	{
; 302  : 		if(cp1.y < cp2.y)

  0001b	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0001e	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  00021	3b d6		 cmp	 edx, esi
  00023	7c ed		 jl	 SHORT $LN13@operator

; 303  : 		{
; 304  : 			return true;
; 305  : 		}
; 306  : 		else if(cp1.y == cp2.y)

  00025	75 0e		 jne	 SHORT $LN3@operator

; 307  : 		{
; 308  : 			return cp1.z < cp2.z;

  00027	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0002a	3b 41 08	 cmp	 eax, DWORD PTR [ecx+8]
  0002d	5e		 pop	 esi
  0002e	0f 9c c0	 setl	 al
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstddef

; 181  : 		}

  00031	5d		 pop	 ebp
  00032	c2 08 00	 ret	 8
$LN3@operator:
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp

; 312  : 	return false;

  00035	32 c0		 xor	 al, al
  00037	5e		 pop	 esi
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstddef

; 181  : 		}

  00038	5d		 pop	 ebp
  00039	c2 08 00	 ret	 8
??R?$less@VChunkPosition@@@std@@QBE_NABVChunkPosition@@0@Z ENDP ; std::less<ChunkPosition>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
;	COMDAT ?_Getcomp@?$_Tree_comp@$0A@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QBE?AU?$less@VChunkPosition@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?_Getcomp@?$_Tree_comp@$0A@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QBE?AU?$less@VChunkPosition@@@2@XZ PROC ; std::_Tree_comp<0,std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Getcomp, COMDAT
; _this$dead$ = ecx

; 1011 : 		{	// get ordering predicate

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1012 : 		return (key_compare());

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1013 : 		}

  00006	5d		 pop	 ebp
  00007	c2 04 00	 ret	 4
?_Getcomp@?$_Tree_comp@$0A@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QBE?AU?$less@VChunkPosition@@@2@XZ ENDP ; std::_Tree_comp<0,std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Getcomp
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QAE@XZ PROC ; std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >, COMDAT
; _this$ = ecx

; 566  : 		{	// construct default allocator (do nothing)
; 567  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QAE@XZ ENDP ; std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
;	COMDAT ??1?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@@std@@QAE@XZ PROC ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::~_Tree_alloc<0,std::_Tree_base_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 586  : 		::operator delete(_Ptr);

  00000	ff 31		 push	 DWORD PTR [ecx]
  00002	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00007	59		 pop	 ecx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree

; 784  : 		}

  00008	c3		 ret	 0
??1?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@@std@@QAE@XZ ENDP ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::~_Tree_alloc<0,std::_Tree_base_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ??0?$shared_ptr@VChunkBase@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$shared_ptr@VChunkBase@@@std@@QAE@XZ PROC		; std::shared_ptr<ChunkBase>::shared_ptr<ChunkBase>, COMDAT
; _this$ = ecx

; 282  : 		{	// construct

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  00006	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 481  : 		{	// construct empty shared_ptr object
; 482  : 		}

  0000d	8b c1		 mov	 eax, ecx
  0000f	c3		 ret	 0
??0?$shared_ptr@VChunkBase@@@std@@QAE@XZ ENDP		; std::shared_ptr<ChunkBase>::shared_ptr<ChunkBase>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ?swap@?$shared_ptr@VChunkBase@@@std@@QAEXAAV12@@Z
_TEXT	SEGMENT
__Other$ = 8						; size = 4
?swap@?$shared_ptr@VChunkBase@@@std@@QAEXAAV12@@Z PROC	; std::shared_ptr<ChunkBase>::swap, COMDAT
; _this$ = ecx

; 675  : 		{	// swap pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility

; 47   : 	_Ty _Tmp = _Move(_Left);

  00003	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00006	56		 push	 esi
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 318  : 		_STD swap(_Rep, _Right._Rep);

  00007	8b 75 08	 mov	 esi, DWORD PTR __Other$[ebp]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility

; 48   : 	_Left = _Move(_Right);

  0000a	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0000d	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 49   : 	_Right = _Move(_Tmp);

  00010	89 56 04	 mov	 DWORD PTR [esi+4], edx

; 48   : 	_Left = _Move(_Right);

  00013	8b 06		 mov	 eax, DWORD PTR [esi]
  00015	8b 11		 mov	 edx, DWORD PTR [ecx]
  00017	89 01		 mov	 DWORD PTR [ecx], eax

; 49   : 	_Right = _Move(_Tmp);

  00019	89 16		 mov	 DWORD PTR [esi], edx
  0001b	5e		 pop	 esi
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 677  : 		}

  0001c	5d		 pop	 ebp
  0001d	c2 04 00	 ret	 4
?swap@?$shared_ptr@VChunkBase@@@std@@QAEXAAV12@@Z ENDP	; std::shared_ptr<ChunkBase>::swap
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
;	COMDAT ??D?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QBEAAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@XZ
_TEXT	SEGMENT
??D?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QBEAAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@XZ PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::operator*, COMDAT
; _this$ = ecx

; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  :  #if _HAS_CPP0X
; 520  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 521  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 522  : 
; 523  :  #else /* _HAS_CPP0X */
; 524  : 	typedef typename _Alloc::template rebind<_Ty>::other _Alty;
; 525  :  #endif /* _HAS_CPP0X */
; 526  : 
; 527  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 528  : 		_Voidptr;
; 529  : 	typedef _Tree_node<typename _Alty::value_type,
; 530  : 		_Voidptr> _Node;
; 531  : 
; 532  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 533  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 534  : 	typedef _Nodeptr& _Nodepref;
; 535  : 
; 536  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 537  : 		_Tree_simple_types<typename _Alty::value_type>,
; 538  : 		_Tree_iter_types<typename _Alty::value_type,
; 539  : 			typename _Alty::size_type,
; 540  : 			typename _Alty::difference_type,
; 541  : 			typename _Alty::pointer,
; 542  : 			typename _Alty::const_pointer,
; 543  : 			typename _Alty::reference,
; 544  : 			typename _Alty::const_reference,
; 545  : 			_Nodeptr> >::type
; 546  : 		_Val_types;
; 547  : 	};
; 548  : 
; 549  : 		// TEMPLATE CLASS _Tree_val
; 550  : template<class _Val_types>
; 551  : 	class _Tree_val
; 552  : 		: public _Container_base
; 553  : 	{	// base class for tree to hold data
; 554  : public:
; 555  : 	typedef _Tree_val<_Val_types> _Myt;
; 556  : 
; 557  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 558  : 	typedef _Nodeptr& _Nodepref;
; 559  : 
; 560  : 	typedef typename _Val_types::value_type value_type;
; 561  : 	typedef typename _Val_types::size_type size_type;
; 562  : 	typedef typename _Val_types::difference_type difference_type;
; 563  : 	typedef typename _Val_types::pointer pointer;
; 564  : 	typedef typename _Val_types::const_pointer const_pointer;
; 565  : 	typedef typename _Val_types::reference reference;
; 566  : 	typedef typename _Val_types::const_reference const_reference;
; 567  : 
; 568  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 569  : 	typedef _Tree_iterator<_Myt> iterator;
; 570  : 
; 571  : 	_Tree_val()
; 572  : 		{	// initialize data
; 573  : 		this->_Myhead = 0;
; 574  : 		this->_Mysize = 0;
; 575  : 		}
; 576  : 
; 577  : 	enum _Redbl
; 578  : 		{	// colors for link to parent
; 579  : 		_Red, _Black};
; 580  : 
; 581  : 	static char& _Color(_Nodeptr _Pnode)
; 582  : 		{	// return reference to color in node
; 583  : 		return ((char&)_Pnode->_Color);
; 584  : 		}
; 585  : 
; 586  : 	static char& _Isnil(_Nodeptr _Pnode)
; 587  : 		{	// return reference to nil flag in node
; 588  : 		return ((char&)_Pnode->_Isnil);
; 589  : 		}
; 590  : 
; 591  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 592  : 		{	// return reference to left pointer in node
; 593  : 		return ((_Nodepref)_Pnode->_Left);
; 594  : 		}
; 595  : 
; 596  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 597  : 		{	// return reference to parent pointer in node
; 598  : 		return ((_Nodepref)_Pnode->_Parent);
; 599  : 		}
; 600  : 
; 601  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 602  : 		{	// return reference to right pointer in node
; 603  : 		return ((_Nodepref)_Pnode->_Right);
; 604  : 		}
; 605  : 
; 606  : 	static reference _Myval(_Nodeptr _Pnode)
; 607  : 		{	// return reference to value in node
; 608  : 		return ((reference)_Pnode->_Myval);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 c0 10	 add	 eax, 16			; 00000010H

; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}

  00005	c3		 ret	 0
??D?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QBEAAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@XZ ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
;	COMDAT ?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@2@XZ
_TEXT	SEGMENT
?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@2@XZ PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >,std::_Iterator_base0>::_Mynode, COMDAT
; _this$ = ecx

; 123  : 		return (_Ptr);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 124  : 		}

  00002	c3		 ret	 0
?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@2@XZ ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >,std::_Iterator_base0>::_Mynode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?pointer_to@?$pointer_traits@PAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@SAPAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@2@AAU32@@Z
_TEXT	SEGMENT
?pointer_to@?$pointer_traits@PAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@SAPAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@2@AAU32@@Z PROC ; std::pointer_traits<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > *>::pointer_to, COMDAT
; __Val$ = ecx

; 233  : 		return (_STD addressof(_Val));

  00000	8b c1		 mov	 eax, ecx

; 234  : 		}

  00002	c3		 ret	 0
?pointer_to@?$pointer_traits@PAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@SAPAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@2@AAU32@@Z ENDP ; std::pointer_traits<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > *>::pointer_to
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@@Z
_TEXT	SEGMENT
tv908 = -8						; size = 4
tv878 = -8						; size = 4
__Pnode$1$ = -8						; size = 4
__Erasednode$1$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?erase@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::erase, COMDAT
; _this$ = ecx

; 1323 : 		{	// erase element at _Where

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 1324 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1325 : 		if (_Where._Getcont() != this || this->_Isnil(_Where._Mynode()))
; 1326 : 			_DEBUG_ERROR("map/set erase iterator outside range");
; 1327 : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase
; 1328 : 		++_Where;	// save successor iterator for return
; 1329 : 		_Orphan_ptr(*this, _Erasednode);
; 1330 : 
; 1331 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1332 : 		if (this->_Isnil(_Where._Mynode()))

  00006	8b 45 0c	 mov	 eax, DWORD PTR __Where$[ebp]
  00009	53		 push	 ebx
  0000a	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  0000e	8b d9		 mov	 ebx, ecx
  00010	89 45 fc	 mov	 DWORD PTR __Erasednode$1$[ebp], eax
  00013	0f 85 6e 02 00
	00		 jne	 $LN340@erase
  00019	56		 push	 esi
  0001a	57		 push	 edi

; 124  : 		}
; 125  : 
; 126  : 	_Nodeptr _Ptr;	// pointer to node
; 127  : 	};
; 128  : 
; 129  : 	// TEMPLATE CLASS _Tree_unchecked_iterator
; 130  : template<class _Mytree>
; 131  : 	class _Tree_unchecked_iterator
; 132  : 		: public _Tree_unchecked_const_iterator<_Mytree>
; 133  : 	{	// unchecked iterator for mutable tree
; 134  : public:
; 135  : 	typedef _Tree_unchecked_iterator<_Mytree> _Myiter;
; 136  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Mybase;
; 137  : 	typedef bidirectional_iterator_tag iterator_category;
; 138  : 
; 139  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 140  : 	typedef typename _Mytree::value_type value_type;
; 141  : 	typedef typename _Mytree::difference_type difference_type;
; 142  : 	typedef typename _Mytree::pointer pointer;
; 143  : 	typedef typename _Mytree::reference reference;
; 144  : 
; 145  : 	_Tree_unchecked_iterator()
; 146  : 		{	// construct with null node
; 147  : 		}
; 148  : 
; 149  : 	_Tree_unchecked_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 150  : 		: _Mybase(_Pnode, _Plist)
; 151  : 		{	// construct with node pointer _Pnode
; 152  : 		}
; 153  : 
; 154  : 	reference operator*() const
; 155  : 		{	// return designated value
; 156  : 		return ((reference)**(_Mybase *)this);
; 157  : 		}
; 158  : 
; 159  : 	pointer operator->() const
; 160  : 		{	// return pointer to class object
; 161  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 162  : 		}
; 163  : 
; 164  : 	_Myiter& operator++()
; 165  : 		{	// preincrement
; 166  : 		++(*(_Mybase *)this);
; 167  : 		return (*this);
; 168  : 		}
; 169  : 
; 170  : 	_Myiter operator++(int)
; 171  : 		{	// postincrement
; 172  : 		_Myiter _Tmp = *this;
; 173  : 		++*this;
; 174  : 		return (_Tmp);
; 175  : 		}
; 176  : 
; 177  : 	_Myiter& operator--()
; 178  : 		{	// predecrement
; 179  : 		--(*(_Mybase *)this);
; 180  : 		return (*this);
; 181  : 		}
; 182  : 
; 183  : 	_Myiter operator--(int)
; 184  : 		{	// postdecrement
; 185  : 		_Myiter _Tmp = *this;
; 186  : 		--*this;
; 187  : 		return (_Tmp);
; 188  : 		}
; 189  : 	};
; 190  : 
; 191  : 	// TEMPLATE CLASS _Tree_const_iterator
; 192  : template<class _Mytree>
; 193  : 	class _Tree_const_iterator
; 194  : 		: public _Tree_unchecked_const_iterator<_Mytree, _Iterator_base>
; 195  : 	{	// iterator for nonmutable tree
; 196  : public:
; 197  : 	typedef _Tree_const_iterator<_Mytree> _Myiter;
; 198  : 	typedef _Tree_unchecked_const_iterator<_Mytree, _Iterator_base> _Mybase;
; 199  : 	typedef bidirectional_iterator_tag iterator_category;
; 200  : 
; 201  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 202  : 	typedef typename _Mytree::value_type value_type;
; 203  : 	typedef typename _Mytree::difference_type difference_type;
; 204  : 	typedef typename _Mytree::const_pointer pointer;
; 205  : 	typedef typename _Mytree::const_reference reference;
; 206  : 
; 207  : 	_Tree_const_iterator()
; 208  : 		: _Mybase()
; 209  : 		{	// construct with null node pointer
; 210  : 		}
; 211  : 
; 212  : 	_Tree_const_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 213  : 		: _Mybase(_Pnode, _Plist)
; 214  : 		{	// construct with node pointer _Pnode
; 215  : 		}
; 216  : 
; 217  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Unchecked_type;
; 218  : 
; 219  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 220  : 		{	// reset from unchecked iterator
; 221  : 		this->_Ptr = _Right._Ptr;
; 222  : 		return (*this);
; 223  : 		}
; 224  : 
; 225  : 	_Unchecked_type _Unchecked() const
; 226  : 		{	// make an unchecked iterator
; 227  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 228  : 		}
; 229  : 
; 230  : 	reference operator*() const
; 231  : 		{	// return designated value
; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		if (this->_Getcont() == 0
; 234  : 			|| this->_Ptr == 0
; 235  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 236  : 			{	// report error
; 237  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 238  : 			_SCL_SECURE_OUT_OF_RANGE;
; 239  : 			}
; 240  : 
; 241  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 242  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 243  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 244  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 245  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 246  : 
; 247  : 		return (_Mytree::_Myval(this->_Ptr));
; 248  : 		}
; 249  : 
; 250  : 	pointer operator->() const
; 251  : 		{	// return pointer to class object
; 252  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 253  : 		}
; 254  : 
; 255  : 	_Myiter& operator++()
; 256  : 		{	// preincrement
; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);

  0001b	8d 4d 0c	 lea	 ecx, DWORD PTR __Where$[ebp]
  0001e	e8 00 00 00 00	 call	 ??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >,std::_Iterator_base0>::operator++

; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);
; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  :  #if _HAS_CPP0X
; 520  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 521  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 522  : 
; 523  :  #else /* _HAS_CPP0X */
; 524  : 	typedef typename _Alloc::template rebind<_Ty>::other _Alty;
; 525  :  #endif /* _HAS_CPP0X */
; 526  : 
; 527  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 528  : 		_Voidptr;
; 529  : 	typedef _Tree_node<typename _Alty::value_type,
; 530  : 		_Voidptr> _Node;
; 531  : 
; 532  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 533  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 534  : 	typedef _Nodeptr& _Nodepref;
; 535  : 
; 536  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 537  : 		_Tree_simple_types<typename _Alty::value_type>,
; 538  : 		_Tree_iter_types<typename _Alty::value_type,
; 539  : 			typename _Alty::size_type,
; 540  : 			typename _Alty::difference_type,
; 541  : 			typename _Alty::pointer,
; 542  : 			typename _Alty::const_pointer,
; 543  : 			typename _Alty::reference,
; 544  : 			typename _Alty::const_reference,
; 545  : 			_Nodeptr> >::type
; 546  : 		_Val_types;
; 547  : 	};
; 548  : 
; 549  : 		// TEMPLATE CLASS _Tree_val
; 550  : template<class _Val_types>
; 551  : 	class _Tree_val
; 552  : 		: public _Container_base
; 553  : 	{	// base class for tree to hold data
; 554  : public:
; 555  : 	typedef _Tree_val<_Val_types> _Myt;
; 556  : 
; 557  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 558  : 	typedef _Nodeptr& _Nodepref;
; 559  : 
; 560  : 	typedef typename _Val_types::value_type value_type;
; 561  : 	typedef typename _Val_types::size_type size_type;
; 562  : 	typedef typename _Val_types::difference_type difference_type;
; 563  : 	typedef typename _Val_types::pointer pointer;
; 564  : 	typedef typename _Val_types::const_pointer const_pointer;
; 565  : 	typedef typename _Val_types::reference reference;
; 566  : 	typedef typename _Val_types::const_reference const_reference;
; 567  : 
; 568  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 569  : 	typedef _Tree_iterator<_Myt> iterator;
; 570  : 
; 571  : 	_Tree_val()
; 572  : 		{	// initialize data
; 573  : 		this->_Myhead = 0;
; 574  : 		this->_Mysize = 0;
; 575  : 		}
; 576  : 
; 577  : 	enum _Redbl
; 578  : 		{	// colors for link to parent
; 579  : 		_Red, _Black};
; 580  : 
; 581  : 	static char& _Color(_Nodeptr _Pnode)
; 582  : 		{	// return reference to color in node
; 583  : 		return ((char&)_Pnode->_Color);
; 584  : 		}
; 585  : 
; 586  : 	static char& _Isnil(_Nodeptr _Pnode)
; 587  : 		{	// return reference to nil flag in node
; 588  : 		return ((char&)_Pnode->_Isnil);

  00023	8b 55 fc	 mov	 edx, DWORD PTR __Erasednode$1$[ebp]
  00026	8b 32		 mov	 esi, DWORD PTR [edx]

; 1334 : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase
; 1335 : 		++_Where;	// save successor iterator for return
; 1336 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1337 : 
; 1338 : 		_Nodeptr _Fixnode;	// the node to recolor as needed
; 1339 : 		_Nodeptr _Fixnodeparent;	// parent of _Fixnode (which may be nil)
; 1340 : 		_Nodeptr _Pnode = _Erasednode;
; 1341 : 
; 1342 : 		if (this->_Isnil(this->_Left(_Pnode)))

  00028	80 7e 0d 00	 cmp	 BYTE PTR [esi+13], 0
  0002c	74 05		 je	 SHORT $LN39@erase

; 1343 : 			_Fixnode = this->_Right(_Pnode);	// stitch up right subtree

  0002e	8b 7a 08	 mov	 edi, DWORD PTR [edx+8]

; 1344 : 		else if (this->_Isnil(this->_Right(_Pnode)))

  00031	eb 1a		 jmp	 SHORT $LN333@erase
$LN39@erase:
  00033	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00036	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  0003a	74 04		 je	 SHORT $LN37@erase

; 1345 : 			_Fixnode = this->_Left(_Pnode);	// stitch up left subtree

  0003c	8b fe		 mov	 edi, esi

; 1346 : 		else

  0003e	eb 0d		 jmp	 SHORT $LN333@erase
$LN37@erase:

; 45   : 		this->_Adopt(_Plist);
; 46   : 		}
; 47   : 
; 48   : 	reference operator*() const
; 49   : 		{	// return designated value
; 50   : 		return (_Mytree::_Myval(_Ptr));
; 51   : 		}
; 52   : 
; 53   : 	pointer operator->() const
; 54   : 		{	// return pointer to class object
; 55   : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 56   : 		}
; 57   : 
; 58   : 	_Myiter& operator++()
; 59   : 		{	// preincrement
; 60   : 		if (_Mytree::_Isnil(_Ptr))
; 61   : 			;	// end() shouldn't be incremented, don't move
; 62   : 		else if (!_Mytree::_Isnil(_Mytree::_Right(_Ptr)))
; 63   : 			_Ptr = _Mytree::_Min(
; 64   : 				_Mytree::_Right(_Ptr));	// ==> smallest of right subtree
; 65   : 		else
; 66   : 			{	// climb looking for right subtree
; 67   : 			_Nodeptr _Pnode;
; 68   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 69   : 				&& _Ptr == _Mytree::_Right(_Pnode))
; 70   : 				_Ptr = _Pnode;	// ==> parent while right subtree
; 71   : 			_Ptr = _Pnode;	// ==> parent (head if end())
; 72   : 			}
; 73   : 		return (*this);
; 74   : 		}
; 75   : 
; 76   : 	_Myiter operator++(int)
; 77   : 		{	// postincrement
; 78   : 		_Myiter _Tmp = *this;
; 79   : 		++*this;
; 80   : 		return (_Tmp);
; 81   : 		}
; 82   : 
; 83   : 	_Myiter& operator--()
; 84   : 		{	// predecrement
; 85   : 		if (_Mytree::_Isnil(_Ptr))
; 86   : 			_Ptr = _Mytree::_Right(_Ptr);	// end() ==> rightmost
; 87   : 		else if (!_Mytree::_Isnil(_Mytree::_Left(_Ptr)))
; 88   : 			_Ptr = _Mytree::_Max(
; 89   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree
; 90   : 		else
; 91   : 			{	// climb looking for left subtree
; 92   : 			_Nodeptr _Pnode;
; 93   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 94   : 				&& _Ptr == _Mytree::_Left(_Pnode))
; 95   : 				_Ptr = _Pnode;	// ==> parent while left subtree
; 96   : 			if (_Mytree::_Isnil(_Ptr))
; 97   : 				;	// begin() shouldn't be decremented, don't move
; 98   : 			else
; 99   : 				_Ptr = _Pnode;	// ==> parent if not head
; 100  : 			}
; 101  : 		return (*this);
; 102  : 		}
; 103  : 
; 104  : 	_Myiter operator--(int)
; 105  : 		{	// postdecrement
; 106  : 		_Myiter _Tmp = *this;
; 107  : 		--*this;
; 108  : 		return (_Tmp);
; 109  : 		}
; 110  : 
; 111  : 	bool operator==(const _Myiter& _Right) const
; 112  : 		{	// test for iterator equality
; 113  : 		return (_Ptr == _Right._Ptr);
; 114  : 		}
; 115  : 
; 116  : 	bool operator!=(const _Myiter& _Right) const
; 117  : 		{	// test for iterator inequality
; 118  : 		return (!(*this == _Right));
; 119  : 		}
; 120  : 
; 121  : 	_Nodeptr _Mynode() const
; 122  : 		{	// return node pointer
; 123  : 		return (_Ptr);

  00040	8b 4d 0c	 mov	 ecx, DWORD PTR __Where$[ebp]
  00043	89 4d f8	 mov	 DWORD PTR __Pnode$1$[ebp], ecx

; 1347 : 			{	// two subtrees, must lift successor node to replace erased
; 1348 : 			_Pnode = _Where._Mynode();	// _Pnode is successor node
; 1349 : 			_Fixnode = this->_Right(_Pnode);	// _Fixnode is only subtree

  00046	8b 79 08	 mov	 edi, DWORD PTR [ecx+8]

; 1350 : 			}
; 1351 : 
; 1352 : 		if (_Pnode == _Erasednode)

  00049	3b ca		 cmp	 ecx, edx
  0004b	75 78		 jne	 SHORT $LN35@erase
$LN333@erase:

; 1353 : 			{	// at most one subtree, relink it
; 1354 : 			_Fixnodeparent = this->_Parent(_Erasednode);
; 1355 : 			if (!this->_Isnil(_Fixnode))

  0004d	80 7f 0d 00	 cmp	 BYTE PTR [edi+13], 0
  00051	8b 72 04	 mov	 esi, DWORD PTR [edx+4]
  00054	75 03		 jne	 SHORT $LN34@erase

; 1356 : 				this->_Parent(_Fixnode) = _Fixnodeparent;	// link up

  00056	89 77 04	 mov	 DWORD PTR [edi+4], esi
$LN34@erase:

; 594  : 		}
; 595  : 
; 596  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 597  : 		{	// return reference to parent pointer in node
; 598  : 		return ((_Nodepref)_Pnode->_Parent);

  00059	8b 03		 mov	 eax, DWORD PTR [ebx]

; 1357 : 
; 1358 : 			if (_Root() == _Erasednode)

  0005b	39 50 04	 cmp	 DWORD PTR [eax+4], edx
  0005e	75 05		 jne	 SHORT $LN33@erase

; 1359 : 				_Root() = _Fixnode;	// link down from root

  00060	89 78 04	 mov	 DWORD PTR [eax+4], edi

; 1360 : 			else if (this->_Left(_Fixnodeparent) == _Erasednode)

  00063	eb 0b		 jmp	 SHORT $LN30@erase
$LN33@erase:
  00065	39 16		 cmp	 DWORD PTR [esi], edx
  00067	75 04		 jne	 SHORT $LN31@erase

; 1361 : 				this->_Left(_Fixnodeparent) = _Fixnode;	// link down to left

  00069	89 3e		 mov	 DWORD PTR [esi], edi

; 1362 : 			else

  0006b	eb 03		 jmp	 SHORT $LN30@erase
$LN31@erase:

; 1363 : 				this->_Right(_Fixnodeparent) =
; 1364 : 					_Fixnode;	// link down to right

  0006d	89 7e 08	 mov	 DWORD PTR [esi+8], edi
$LN30@erase:

; 589  : 		}
; 590  : 
; 591  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 592  : 		{	// return reference to left pointer in node
; 593  : 		return ((_Nodepref)_Pnode->_Left);

  00070	8b 03		 mov	 eax, DWORD PTR [ebx]

; 1365 : 
; 1366 : 			if (_Lmost() == _Erasednode)

  00072	39 10		 cmp	 DWORD PTR [eax], edx
  00074	75 28		 jne	 SHORT $LN29@erase

; 1367 : 				_Lmost() = this->_Isnil(_Fixnode)
; 1368 : 					? _Fixnodeparent	// smallest is parent of erased node
; 1369 : 					: this->_Min(_Fixnode);	// smallest in relinked subtree

  00076	80 7f 0d 00	 cmp	 BYTE PTR [edi+13], 0
  0007a	74 04		 je	 SHORT $LN43@erase
  0007c	8b ce		 mov	 ecx, esi
  0007e	eb 1c		 jmp	 SHORT $LN44@erase
$LN43@erase:

; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);
; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  :  #if _HAS_CPP0X
; 520  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 521  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 522  : 
; 523  :  #else /* _HAS_CPP0X */
; 524  : 	typedef typename _Alloc::template rebind<_Ty>::other _Alty;
; 525  :  #endif /* _HAS_CPP0X */
; 526  : 
; 527  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 528  : 		_Voidptr;
; 529  : 	typedef _Tree_node<typename _Alty::value_type,
; 530  : 		_Voidptr> _Node;
; 531  : 
; 532  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 533  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 534  : 	typedef _Nodeptr& _Nodepref;
; 535  : 
; 536  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 537  : 		_Tree_simple_types<typename _Alty::value_type>,
; 538  : 		_Tree_iter_types<typename _Alty::value_type,
; 539  : 			typename _Alty::size_type,
; 540  : 			typename _Alty::difference_type,
; 541  : 			typename _Alty::pointer,
; 542  : 			typename _Alty::const_pointer,
; 543  : 			typename _Alty::reference,
; 544  : 			typename _Alty::const_reference,
; 545  : 			_Nodeptr> >::type
; 546  : 		_Val_types;
; 547  : 	};
; 548  : 
; 549  : 		// TEMPLATE CLASS _Tree_val
; 550  : template<class _Val_types>
; 551  : 	class _Tree_val
; 552  : 		: public _Container_base
; 553  : 	{	// base class for tree to hold data
; 554  : public:
; 555  : 	typedef _Tree_val<_Val_types> _Myt;
; 556  : 
; 557  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 558  : 	typedef _Nodeptr& _Nodepref;
; 559  : 
; 560  : 	typedef typename _Val_types::value_type value_type;
; 561  : 	typedef typename _Val_types::size_type size_type;
; 562  : 	typedef typename _Val_types::difference_type difference_type;
; 563  : 	typedef typename _Val_types::pointer pointer;
; 564  : 	typedef typename _Val_types::const_pointer const_pointer;
; 565  : 	typedef typename _Val_types::reference reference;
; 566  : 	typedef typename _Val_types::const_reference const_reference;
; 567  : 
; 568  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 569  : 	typedef _Tree_iterator<_Myt> iterator;
; 570  : 
; 571  : 	_Tree_val()
; 572  : 		{	// initialize data
; 573  : 		this->_Myhead = 0;
; 574  : 		this->_Mysize = 0;
; 575  : 		}
; 576  : 
; 577  : 	enum _Redbl
; 578  : 		{	// colors for link to parent
; 579  : 		_Red, _Black};
; 580  : 
; 581  : 	static char& _Color(_Nodeptr _Pnode)
; 582  : 		{	// return reference to color in node
; 583  : 		return ((char&)_Pnode->_Color);
; 584  : 		}
; 585  : 
; 586  : 	static char& _Isnil(_Nodeptr _Pnode)
; 587  : 		{	// return reference to nil flag in node
; 588  : 		return ((char&)_Pnode->_Isnil);

  00080	8b 07		 mov	 eax, DWORD PTR [edi]

; 1367 : 				_Lmost() = this->_Isnil(_Fixnode)
; 1368 : 					? _Fixnodeparent	// smallest is parent of erased node
; 1369 : 					: this->_Min(_Fixnode);	// smallest in relinked subtree

  00082	8b cf		 mov	 ecx, edi

; 604  : 		}
; 605  : 
; 606  : 	static reference _Myval(_Nodeptr _Pnode)
; 607  : 		{	// return reference to value in node
; 608  : 		return ((reference)_Pnode->_Myval);
; 609  : 		}
; 610  : 
; 611  : 	static _Nodeptr _Max(_Nodeptr _Pnode)
; 612  : 		{	// return rightmost node in subtree at _Pnode
; 613  : 		while (!_Isnil(_Right(_Pnode)))
; 614  : 			_Pnode = _Right(_Pnode);
; 615  : 		return (_Pnode);
; 616  : 		}
; 617  : 
; 618  : 	static _Nodeptr _Min(_Nodeptr _Pnode)
; 619  : 		{	// return leftmost node in subtree at _Pnode
; 620  : 		while (!_Isnil(_Left(_Pnode)))

  00084	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00088	75 10		 jne	 SHORT $LN97@erase
  0008a	8d 9b 00 00 00
	00		 npad	 6
$LL98@erase:

; 621  : 			_Pnode = _Left(_Pnode);

  00090	8b c8		 mov	 ecx, eax

; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);
; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  :  #if _HAS_CPP0X
; 520  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 521  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 522  : 
; 523  :  #else /* _HAS_CPP0X */
; 524  : 	typedef typename _Alloc::template rebind<_Ty>::other _Alty;
; 525  :  #endif /* _HAS_CPP0X */
; 526  : 
; 527  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 528  : 		_Voidptr;
; 529  : 	typedef _Tree_node<typename _Alty::value_type,
; 530  : 		_Voidptr> _Node;
; 531  : 
; 532  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 533  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 534  : 	typedef _Nodeptr& _Nodepref;
; 535  : 
; 536  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 537  : 		_Tree_simple_types<typename _Alty::value_type>,
; 538  : 		_Tree_iter_types<typename _Alty::value_type,
; 539  : 			typename _Alty::size_type,
; 540  : 			typename _Alty::difference_type,
; 541  : 			typename _Alty::pointer,
; 542  : 			typename _Alty::const_pointer,
; 543  : 			typename _Alty::reference,
; 544  : 			typename _Alty::const_reference,
; 545  : 			_Nodeptr> >::type
; 546  : 		_Val_types;
; 547  : 	};
; 548  : 
; 549  : 		// TEMPLATE CLASS _Tree_val
; 550  : template<class _Val_types>
; 551  : 	class _Tree_val
; 552  : 		: public _Container_base
; 553  : 	{	// base class for tree to hold data
; 554  : public:
; 555  : 	typedef _Tree_val<_Val_types> _Myt;
; 556  : 
; 557  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 558  : 	typedef _Nodeptr& _Nodepref;
; 559  : 
; 560  : 	typedef typename _Val_types::value_type value_type;
; 561  : 	typedef typename _Val_types::size_type size_type;
; 562  : 	typedef typename _Val_types::difference_type difference_type;
; 563  : 	typedef typename _Val_types::pointer pointer;
; 564  : 	typedef typename _Val_types::const_pointer const_pointer;
; 565  : 	typedef typename _Val_types::reference reference;
; 566  : 	typedef typename _Val_types::const_reference const_reference;
; 567  : 
; 568  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 569  : 	typedef _Tree_iterator<_Myt> iterator;
; 570  : 
; 571  : 	_Tree_val()
; 572  : 		{	// initialize data
; 573  : 		this->_Myhead = 0;
; 574  : 		this->_Mysize = 0;
; 575  : 		}
; 576  : 
; 577  : 	enum _Redbl
; 578  : 		{	// colors for link to parent
; 579  : 		_Red, _Black};
; 580  : 
; 581  : 	static char& _Color(_Nodeptr _Pnode)
; 582  : 		{	// return reference to color in node
; 583  : 		return ((char&)_Pnode->_Color);
; 584  : 		}
; 585  : 
; 586  : 	static char& _Isnil(_Nodeptr _Pnode)
; 587  : 		{	// return reference to nil flag in node
; 588  : 		return ((char&)_Pnode->_Isnil);

  00092	8b 01		 mov	 eax, DWORD PTR [ecx]

; 604  : 		}
; 605  : 
; 606  : 	static reference _Myval(_Nodeptr _Pnode)
; 607  : 		{	// return reference to value in node
; 608  : 		return ((reference)_Pnode->_Myval);
; 609  : 		}
; 610  : 
; 611  : 	static _Nodeptr _Max(_Nodeptr _Pnode)
; 612  : 		{	// return rightmost node in subtree at _Pnode
; 613  : 		while (!_Isnil(_Right(_Pnode)))
; 614  : 			_Pnode = _Right(_Pnode);
; 615  : 		return (_Pnode);
; 616  : 		}
; 617  : 
; 618  : 	static _Nodeptr _Min(_Nodeptr _Pnode)
; 619  : 		{	// return leftmost node in subtree at _Pnode
; 620  : 		while (!_Isnil(_Left(_Pnode)))

  00094	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00098	74 f6		 je	 SHORT $LL98@erase
$LN97@erase:
  0009a	8b 03		 mov	 eax, DWORD PTR [ebx]
$LN44@erase:

; 1367 : 				_Lmost() = this->_Isnil(_Fixnode)
; 1368 : 					? _Fixnodeparent	// smallest is parent of erased node
; 1369 : 					: this->_Min(_Fixnode);	// smallest in relinked subtree

  0009c	89 08		 mov	 DWORD PTR [eax], ecx
$LN29@erase:

; 599  : 		}
; 600  : 
; 601  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 602  : 		{	// return reference to right pointer in node
; 603  : 		return ((_Nodepref)_Pnode->_Right);

  0009e	8b 03		 mov	 eax, DWORD PTR [ebx]

; 1370 : 
; 1371 : 			if (_Rmost() == _Erasednode)

  000a0	39 50 08	 cmp	 DWORD PTR [eax+8], edx
  000a3	75 7c		 jne	 SHORT $LN175@erase

; 1372 : 				_Rmost() = this->_Isnil(_Fixnode)
; 1373 : 					? _Fixnodeparent	// largest is parent of erased node
; 1374 : 					: this->_Max(_Fixnode);	// largest in relinked subtree

  000a5	80 7f 0d 00	 cmp	 BYTE PTR [edi+13], 0
  000a9	74 09		 je	 SHORT $LN45@erase
  000ab	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  000ad	8b c6		 mov	 eax, esi
  000af	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 1375 : 			}
; 1376 : 		else

  000b2	eb 6d		 jmp	 SHORT $LN175@erase
$LN45@erase:

; 1372 : 				_Rmost() = this->_Isnil(_Fixnode)
; 1373 : 					? _Fixnodeparent	// largest is parent of erased node
; 1374 : 					: this->_Max(_Fixnode);	// largest in relinked subtree

  000b4	8b cf		 mov	 ecx, edi
  000b6	e8 00 00 00 00	 call	 ?_Max@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::_Max
  000bb	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  000bd	8b 55 fc	 mov	 edx, DWORD PTR __Erasednode$1$[ebp]
  000c0	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 1375 : 			}
; 1376 : 		else

  000c3	eb 5c		 jmp	 SHORT $LN175@erase
$LN35@erase:

; 1377 : 			{	// erased has two subtrees, _Pnode is successor to erased
; 1378 : 			this->_Parent(this->_Left(_Erasednode)) =
; 1379 : 				_Pnode;	// link left up

  000c5	89 4e 04	 mov	 DWORD PTR [esi+4], ecx

; 1380 : 			this->_Left(_Pnode) =
; 1381 : 				this->_Left(_Erasednode);	// link successor down

  000c8	8b 02		 mov	 eax, DWORD PTR [edx]
  000ca	89 01		 mov	 DWORD PTR [ecx], eax

; 1382 : 
; 1383 : 			if (_Pnode == this->_Right(_Erasednode))

  000cc	3b 4a 08	 cmp	 ecx, DWORD PTR [edx+8]
  000cf	75 04		 jne	 SHORT $LN26@erase

; 1384 : 				_Fixnodeparent = _Pnode;	// successor is next to erased

  000d1	8b f1		 mov	 esi, ecx

; 1385 : 			else

  000d3	eb 1a		 jmp	 SHORT $LN25@erase
$LN26@erase:

; 1386 : 				{	// successor further down, link in place of erased
; 1387 : 				_Fixnodeparent =
; 1388 : 					this->_Parent(_Pnode);	// parent is successor's
; 1389 : 				if (!this->_Isnil(_Fixnode))

  000d5	80 7f 0d 00	 cmp	 BYTE PTR [edi+13], 0
  000d9	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  000dc	75 03		 jne	 SHORT $LN24@erase

; 1390 : 					this->_Parent(_Fixnode) = _Fixnodeparent;	// link fix up

  000de	89 77 04	 mov	 DWORD PTR [edi+4], esi
$LN24@erase:

; 1391 : 				this->_Left(_Fixnodeparent) = _Fixnode;	// link fix down

  000e1	89 3e		 mov	 DWORD PTR [esi], edi

; 1392 : 				this->_Right(_Pnode) =
; 1393 : 					this->_Right(_Erasednode);	// link next down

  000e3	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  000e6	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 1394 : 				this->_Parent(this->_Right(_Erasednode)) =
; 1395 : 					_Pnode;	// right up

  000e9	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  000ec	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN25@erase:

; 594  : 		}
; 595  : 
; 596  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 597  : 		{	// return reference to parent pointer in node
; 598  : 		return ((_Nodepref)_Pnode->_Parent);

  000ef	8b 03		 mov	 eax, DWORD PTR [ebx]

; 1396 : 				}
; 1397 : 
; 1398 : 			if (_Root() == _Erasednode)

  000f1	39 50 04	 cmp	 DWORD PTR [eax+4], edx
  000f4	75 05		 jne	 SHORT $LN23@erase

; 1399 : 				_Root() = _Pnode;	// link down from root

  000f6	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 1400 : 			else if (this->_Left(this->_Parent(_Erasednode)) == _Erasednode)

  000f9	eb 0e		 jmp	 SHORT $LN20@erase
$LN23@erase:

; 589  : 		}
; 590  : 
; 591  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 592  : 		{	// return reference to left pointer in node
; 593  : 		return ((_Nodepref)_Pnode->_Left);

  000fb	8b 42 04	 mov	 eax, DWORD PTR [edx+4]

; 1400 : 			else if (this->_Left(this->_Parent(_Erasednode)) == _Erasednode)

  000fe	39 10		 cmp	 DWORD PTR [eax], edx
  00100	75 04		 jne	 SHORT $LN21@erase

; 1401 : 				this->_Left(this->_Parent(_Erasednode)) =
; 1402 : 					_Pnode;	// link down to left

  00102	89 08		 mov	 DWORD PTR [eax], ecx

; 1403 : 			else

  00104	eb 03		 jmp	 SHORT $LN20@erase
$LN21@erase:

; 1404 : 				this->_Right(this->_Parent(_Erasednode)) =
; 1405 : 					_Pnode;	// link down to right

  00106	89 48 08	 mov	 DWORD PTR [eax+8], ecx
$LN20@erase:

; 1406 : 
; 1407 : 			this->_Parent(_Pnode) =
; 1408 : 				this->_Parent(_Erasednode);	// link successor up

  00109	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0010c	89 41 04	 mov	 DWORD PTR [ecx+4], eax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility

; 48   : 	_Left = _Move(_Right);

  0010f	8a 42 0c	 mov	 al, BYTE PTR [edx+12]
  00112	8b 55 f8	 mov	 edx, DWORD PTR __Pnode$1$[ebp]
  00115	8a 49 0c	 mov	 cl, BYTE PTR [ecx+12]
  00118	88 42 0c	 mov	 BYTE PTR [edx+12], al

; 49   : 	_Right = _Move(_Tmp);

  0011b	8b 55 fc	 mov	 edx, DWORD PTR __Erasednode$1$[ebp]
  0011e	88 4a 0c	 mov	 BYTE PTR [edx+12], cl
$LN175@erase:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree

; 1413 : 		if (this->_Color(_Erasednode) == this->_Black)

  00121	80 7a 0c 01	 cmp	 BYTE PTR [edx+12], 1
  00125	0f 85 08 01 00
	00		 jne	 $LN19@erase

; 1414 : 			{	// erasing black link, must recolor/rebalance tree
; 1415 : 			for (; _Fixnode != _Root()
; 1416 : 				&& this->_Color(_Fixnode) == this->_Black;
; 1417 : 				_Fixnodeparent = this->_Parent(_Fixnode))

  0012b	8b 03		 mov	 eax, DWORD PTR [ebx]
  0012d	3b 78 04	 cmp	 edi, DWORD PTR [eax+4]
  00130	0f 84 f9 00 00
	00		 je	 $LN16@erase
$LL18@erase:
  00136	80 7f 0c 01	 cmp	 BYTE PTR [edi+12], 1
  0013a	0f 85 ec 00 00
	00		 jne	 $LN336@erase

; 1418 : 				if (_Fixnode == this->_Left(_Fixnodeparent))

  00140	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00142	3b f9		 cmp	 edi, ecx
  00144	75 6c		 jne	 SHORT $LN15@erase

; 1419 : 					{	// fixup left subtree
; 1420 : 					_Pnode = this->_Right(_Fixnodeparent);

  00146	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]

; 1421 : 					if (this->_Color(_Pnode) == this->_Red)

  00149	80 79 0c 00	 cmp	 BYTE PTR [ecx+12], 0
  0014d	75 13		 jne	 SHORT $LN14@erase

; 1422 : 						{	// rotate red up from right subtree
; 1423 : 						this->_Color(_Pnode) = this->_Black;

  0014f	c6 41 0c 01	 mov	 BYTE PTR [ecx+12], 1

; 1424 : 						this->_Color(_Fixnodeparent) = this->_Red;
; 1425 : 						_Lrotate(_Fixnodeparent);

  00153	56		 push	 esi
  00154	8b cb		 mov	 ecx, ebx
  00156	c6 46 0c 00	 mov	 BYTE PTR [esi+12], 0
  0015a	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Lrotate

; 1426 : 						_Pnode = this->_Right(_Fixnodeparent);

  0015f	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
$LN14@erase:

; 1427 : 						}
; 1428 : 
; 1429 : 					if (this->_Isnil(_Pnode))

  00162	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  00166	75 7d		 jne	 SHORT $LN338@erase

; 1430 : 						_Fixnode = _Fixnodeparent;	// shouldn't happen
; 1431 : 					else if (this->_Color(this->_Left(_Pnode)) == this->_Black
; 1432 : 						&& this->_Color(this->_Right(_Pnode)) == this->_Black)

  00168	8b 01		 mov	 eax, DWORD PTR [ecx]
  0016a	80 78 0c 01	 cmp	 BYTE PTR [eax+12], 1
  0016e	75 09		 jne	 SHORT $LN11@erase
  00170	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00173	80 78 0c 01	 cmp	 BYTE PTR [eax+12], 1
  00177	74 68		 je	 SHORT $LN339@erase
$LN11@erase:

; 1433 : 						{	// redden right subtree with black children
; 1434 : 						this->_Color(_Pnode) = this->_Red;
; 1435 : 						_Fixnode = _Fixnodeparent;
; 1436 : 						}
; 1437 : 					else
; 1438 : 						{	// must rearrange right subtree
; 1439 : 						if (this->_Color(this->_Right(_Pnode))
; 1440 : 							== this->_Black)

  00179	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  0017c	80 78 0c 01	 cmp	 BYTE PTR [eax+12], 1
  00180	75 15		 jne	 SHORT $LN9@erase

; 1441 : 							{	// rotate red up from left sub-subtree
; 1442 : 							this->_Color(this->_Left(_Pnode)) = this->_Black;

  00182	8b 01		 mov	 eax, DWORD PTR [ecx]

; 1443 : 							this->_Color(_Pnode) = this->_Red;
; 1444 : 							_Rrotate(_Pnode);

  00184	51		 push	 ecx
  00185	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1
  00189	c6 41 0c 00	 mov	 BYTE PTR [ecx+12], 0
  0018d	8b cb		 mov	 ecx, ebx
  0018f	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Rrotate

; 1445 : 							_Pnode = this->_Right(_Fixnodeparent);

  00194	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
$LN9@erase:

; 1446 : 							}
; 1447 : 
; 1448 : 						this->_Color(_Pnode) = this->_Color(_Fixnodeparent);

  00197	8a 46 0c	 mov	 al, BYTE PTR [esi+12]
  0019a	88 41 0c	 mov	 BYTE PTR [ecx+12], al

; 1449 : 						this->_Color(_Fixnodeparent) = this->_Black;

  0019d	c6 46 0c 01	 mov	 BYTE PTR [esi+12], 1

; 1450 : 						this->_Color(this->_Right(_Pnode)) = this->_Black;

  001a1	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]

; 1451 : 						_Lrotate(_Fixnodeparent);

  001a4	56		 push	 esi
  001a5	8b cb		 mov	 ecx, ebx
  001a7	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1
  001ab	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Lrotate

; 1452 : 						break;	// tree now recolored/rebalanced

  001b0	eb 7a		 jmp	 SHORT $LN336@erase
$LN15@erase:

; 1453 : 						}
; 1454 : 					}
; 1455 : 				else
; 1456 : 					{	// fixup right subtree
; 1457 : 					_Pnode = this->_Left(_Fixnodeparent);
; 1458 : 					if (this->_Color(_Pnode) == this->_Red)

  001b2	80 79 0c 00	 cmp	 BYTE PTR [ecx+12], 0
  001b6	75 12		 jne	 SHORT $LN7@erase

; 1459 : 						{	// rotate red up from left subtree
; 1460 : 						this->_Color(_Pnode) = this->_Black;

  001b8	c6 41 0c 01	 mov	 BYTE PTR [ecx+12], 1

; 1461 : 						this->_Color(_Fixnodeparent) = this->_Red;
; 1462 : 						_Rrotate(_Fixnodeparent);

  001bc	56		 push	 esi
  001bd	8b cb		 mov	 ecx, ebx
  001bf	c6 46 0c 00	 mov	 BYTE PTR [esi+12], 0
  001c3	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Rrotate

; 1463 : 						_Pnode = this->_Left(_Fixnodeparent);

  001c8	8b 0e		 mov	 ecx, DWORD PTR [esi]
$LN7@erase:

; 1464 : 						}
; 1465 : 
; 1466 : 					if (this->_Isnil(_Pnode))

  001ca	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  001ce	75 15		 jne	 SHORT $LN338@erase

; 1467 : 						_Fixnode = _Fixnodeparent;	// shouldn't happen
; 1468 : 					else if (this->_Color(this->_Right(_Pnode)) ==
; 1469 : 						this->_Black
; 1470 : 						&& this->_Color(this->_Left(_Pnode)) == this->_Black)

  001d0	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  001d3	80 78 0c 01	 cmp	 BYTE PTR [eax+12], 1
  001d7	75 1e		 jne	 SHORT $LN4@erase
  001d9	8b 01		 mov	 eax, DWORD PTR [ecx]
  001db	80 78 0c 01	 cmp	 BYTE PTR [eax+12], 1
  001df	75 16		 jne	 SHORT $LN4@erase
$LN339@erase:

; 1471 : 						{	// redden left subtree with black children
; 1472 : 						this->_Color(_Pnode) = this->_Red;

  001e1	c6 41 0c 00	 mov	 BYTE PTR [ecx+12], 0
$LN338@erase:

; 1414 : 			{	// erasing black link, must recolor/rebalance tree
; 1415 : 			for (; _Fixnode != _Root()
; 1416 : 				&& this->_Color(_Fixnode) == this->_Black;
; 1417 : 				_Fixnodeparent = this->_Parent(_Fixnode))

  001e5	8b 03		 mov	 eax, DWORD PTR [ebx]

; 1473 : 						_Fixnode = _Fixnodeparent;

  001e7	8b fe		 mov	 edi, esi
  001e9	8b 76 04	 mov	 esi, DWORD PTR [esi+4]
  001ec	3b 78 04	 cmp	 edi, DWORD PTR [eax+4]
  001ef	0f 85 41 ff ff
	ff		 jne	 $LL18@erase

; 1414 : 			{	// erasing black link, must recolor/rebalance tree
; 1415 : 			for (; _Fixnode != _Root()
; 1416 : 				&& this->_Color(_Fixnode) == this->_Black;
; 1417 : 				_Fixnodeparent = this->_Parent(_Fixnode))

  001f5	eb 35		 jmp	 SHORT $LN336@erase
$LN4@erase:

; 1474 : 						}
; 1475 : 					else
; 1476 : 						{	// must rearrange left subtree
; 1477 : 						if (this->_Color(this->_Left(_Pnode)) == this->_Black)

  001f7	8b 01		 mov	 eax, DWORD PTR [ecx]
  001f9	80 78 0c 01	 cmp	 BYTE PTR [eax+12], 1
  001fd	75 15		 jne	 SHORT $LN2@erase

; 1478 : 							{	// rotate red up from right sub-subtree
; 1479 : 							this->_Color(this->_Right(_Pnode)) = this->_Black;

  001ff	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]

; 1480 : 							this->_Color(_Pnode) = this->_Red;
; 1481 : 							_Lrotate(_Pnode);

  00202	51		 push	 ecx
  00203	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1
  00207	c6 41 0c 00	 mov	 BYTE PTR [ecx+12], 0
  0020b	8b cb		 mov	 ecx, ebx
  0020d	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Lrotate

; 1482 : 							_Pnode = this->_Left(_Fixnodeparent);

  00212	8b 0e		 mov	 ecx, DWORD PTR [esi]
$LN2@erase:

; 1483 : 							}
; 1484 : 
; 1485 : 						this->_Color(_Pnode) = this->_Color(_Fixnodeparent);

  00214	8a 46 0c	 mov	 al, BYTE PTR [esi+12]
  00217	88 41 0c	 mov	 BYTE PTR [ecx+12], al

; 1486 : 						this->_Color(_Fixnodeparent) = this->_Black;

  0021a	c6 46 0c 01	 mov	 BYTE PTR [esi+12], 1

; 1487 : 						this->_Color(this->_Left(_Pnode)) = this->_Black;

  0021e	8b 01		 mov	 eax, DWORD PTR [ecx]

; 1488 : 						_Rrotate(_Fixnodeparent);

  00220	56		 push	 esi
  00221	8b cb		 mov	 ecx, ebx
  00223	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1
  00227	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Rrotate
$LN336@erase:
  0022c	8b 55 fc	 mov	 edx, DWORD PTR __Erasednode$1$[ebp]
$LN16@erase:

; 1489 : 						break;	// tree now recolored/rebalanced
; 1490 : 						}
; 1491 : 					}
; 1492 : 
; 1493 : 			this->_Color(_Fixnode) = this->_Black;	// stopping node is black

  0022f	c6 47 0c 01	 mov	 BYTE PTR [edi+12], 1
$LN19@erase:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  00233	8b 72 20	 mov	 esi, DWORD PTR [edx+32]
  00236	85 f6		 test	 esi, esi
  00238	74 28		 je	 SHORT $LN310@erase

; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  0023a	83 cf ff	 or	 edi, -1
  0023d	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  00240	8b c7		 mov	 eax, edi
  00242	f0 0f c1 01	 lock	  xadd	 DWORD PTR [ecx], eax
  00246	75 1a		 jne	 SHORT $LN310@erase

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  00248	8b 06		 mov	 eax, DWORD PTR [esi]
  0024a	8b ce		 mov	 ecx, esi
  0024c	ff 10		 call	 DWORD PTR [eax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  0024e	8d 46 08	 lea	 eax, DWORD PTR [esi+8]
  00251	f0 0f c1 38	 lock	  xadd	 DWORD PTR [eax], edi
  00255	4f		 dec	 edi
  00256	75 07		 jne	 SHORT $LN335@erase

; 128  : 			_Delete_this();

  00258	8b 06		 mov	 eax, DWORD PTR [esi]
  0025a	8b ce		 mov	 ecx, esi
  0025c	ff 50 04	 call	 DWORD PTR [eax+4]
$LN335@erase:
  0025f	8b 55 fc	 mov	 edx, DWORD PTR __Erasednode$1$[ebp]
$LN310@erase:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 586  : 		::operator delete(_Ptr);

  00262	52		 push	 edx
  00263	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree

; 1501 : 		if (0 < this->_Mysize)

  00268	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 586  : 		::operator delete(_Ptr);

  0026b	83 c4 04	 add	 esp, 4
  0026e	5f		 pop	 edi
  0026f	5e		 pop	 esi
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree

; 1501 : 		if (0 < this->_Mysize)

  00270	85 c0		 test	 eax, eax
  00272	74 04		 je	 SHORT $LN1@erase

; 1502 : 			--this->_Mysize;

  00274	48		 dec	 eax
  00275	89 43 04	 mov	 DWORD PTR [ebx+4], eax
$LN1@erase:

; 44   : 		{	// construct with node pointer _Pnode

  00278	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0027b	8b 4d 0c	 mov	 ecx, DWORD PTR __Where$[ebp]
  0027e	89 08		 mov	 DWORD PTR [eax], ecx
  00280	5b		 pop	 ebx

; 1503 : 
; 1504 : 		return (iterator(_Where._Ptr, this));	// return successor iterator
; 1505 : 		}

  00281	8b e5		 mov	 esp, ebp
  00283	5d		 pop	 ebp
  00284	c2 08 00	 ret	 8
$LN340@erase:

; 1333 : 			_Xout_of_range("invalid map/set<T> iterator");

  00287	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@
  0028c	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN342@erase:
$LN337@erase:
  00291	cc		 int	 3
?erase@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::erase
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
;	COMDAT ?clear@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QAEXXZ PROC ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::clear, COMDAT
; _this$ = ecx

; 1532 : 		{	// erase all

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1533 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1534 : 		this->_Orphan_ptr(*this, 0);
; 1535 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1536 : 
; 1537 : 		_Erase(_Root());

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	ff 70 04	 push	 DWORD PTR [eax+4]
  00008	e8 00 00 00 00	 call	 ?_Erase@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Erase

; 598  : 		return ((_Nodepref)_Pnode->_Parent);

  0000d	8b 06		 mov	 eax, DWORD PTR [esi]

; 1538 : 		_Root() = this->_Myhead;

  0000f	89 40 04	 mov	 DWORD PTR [eax+4], eax

; 1539 : 		_Lmost() = this->_Myhead;

  00012	8b 06		 mov	 eax, DWORD PTR [esi]
  00014	89 00		 mov	 DWORD PTR [eax], eax

; 599  : 		}
; 600  : 
; 601  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 602  : 		{	// return reference to right pointer in node
; 603  : 		return ((_Nodepref)_Pnode->_Right);

  00016	8b 06		 mov	 eax, DWORD PTR [esi]

; 1540 : 		_Rmost() = this->_Myhead;

  00018	89 40 08	 mov	 DWORD PTR [eax+8], eax

; 1541 : 		this->_Mysize = 0;

  0001b	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  00022	5e		 pop	 esi

; 1542 : 		}

  00023	c3		 ret	 0
?clear@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
;	COMDAT ?_Eqrange@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@V12@@2@ABVChunkPosition@@@Z
_TEXT	SEGMENT
__Pnode$2$ = -12					; size = 4
__Lonode$1$ = -8					; size = 4
__Hinode$1$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
__Keyval$ = 12						; size = 4
?_Eqrange@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@V12@@2@ABVChunkPosition@@@Z PROC ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Eqrange, COMDAT
; _this$ = ecx

; 2025 : 		{	// find leftmost node not less than _Keyval

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	53		 push	 ebx
  00007	56		 push	 esi

; 598  : 		return ((_Nodepref)_Pnode->_Parent);

  00008	8b 31		 mov	 esi, DWORD PTR [ecx]

; 2027 : 		_Nodeptr _Lonode = this->_Myhead;	// end() if search fails
; 2028 : 		_Nodeptr _Hinode = this->_Myhead;	// end() if search fails

  0000a	8b ce		 mov	 ecx, esi
  0000c	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  0000f	8b c2		 mov	 eax, edx
  00011	57		 push	 edi

; 2029 : 
; 2030 : 		while (!this->_Isnil(_Pnode))

  00012	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00016	8b 7d 0c	 mov	 edi, DWORD PTR __Keyval$[ebp]

; 598  : 		return ((_Nodepref)_Pnode->_Parent);

  00019	89 75 f8	 mov	 DWORD PTR __Lonode$1$[ebp], esi

; 2026 : 		_Nodeptr _Pnode = _Root();

  0001c	89 55 f4	 mov	 DWORD PTR __Pnode$2$[ebp], edx

; 2027 : 		_Nodeptr _Lonode = this->_Myhead;	// end() if search fails
; 2028 : 		_Nodeptr _Hinode = this->_Myhead;	// end() if search fails

  0001f	89 4d fc	 mov	 DWORD PTR __Hinode$1$[ebp], ecx

; 2029 : 
; 2030 : 		while (!this->_Isnil(_Pnode))

  00022	75 6c		 jne	 SHORT $LN8@Eqrange
  00024	8b 1f		 mov	 ebx, DWORD PTR [edi]
$LL9@Eqrange:
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp

; 296  : 	if(cp1.x < cp2.x)

  00026	8b 70 10	 mov	 esi, DWORD PTR [eax+16]
  00029	3b f3		 cmp	 esi, ebx
  0002b	7c 57		 jl	 SHORT $LN132@Eqrange

; 297  : 	{
; 298  : 		return true;
; 299  : 	}
; 300  : 	else if(cp1.x == cp2.x)

  0002d	75 1a		 jne	 SHORT $LN7@Eqrange

; 301  : 	{
; 302  : 		if(cp1.y < cp2.y)

  0002f	8b 57 04	 mov	 edx, DWORD PTR [edi+4]
  00032	39 50 14	 cmp	 DWORD PTR [eax+20], edx
  00035	7c 4d		 jl	 SHORT $LN132@Eqrange

; 303  : 		{
; 304  : 			return true;
; 305  : 		}
; 306  : 		else if(cp1.y == cp2.y)

  00037	75 10		 jne	 SHORT $LN7@Eqrange

; 307  : 		{
; 308  : 			return cp1.z < cp2.z;

  00039	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  0003c	3b 4f 08	 cmp	 ecx, DWORD PTR [edi+8]
  0003f	0f 9c c1	 setl	 cl
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree

; 2031 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))

  00042	84 c9		 test	 cl, cl
  00044	8b 4d fc	 mov	 ecx, DWORD PTR __Hinode$1$[ebp]
  00047	75 3b		 jne	 SHORT $LN132@Eqrange
$LN7@Eqrange:

; 2036 : 						&& _DEBUG_LT_PRED(this->_Getcomp(), _Keyval,

  00049	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  0004d	74 2e		 je	 SHORT $LN5@Eqrange
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp

; 296  : 	if(cp1.x < cp2.x)

  0004f	3b de		 cmp	 ebx, esi
  00051	7c 1b		 jl	 SHORT $LN133@Eqrange

; 297  : 	{
; 298  : 		return true;
; 299  : 	}
; 300  : 	else if(cp1.x == cp2.x)

  00053	75 28		 jne	 SHORT $LN5@Eqrange

; 301  : 	{
; 302  : 		if(cp1.y < cp2.y)

  00055	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  00058	8b 70 14	 mov	 esi, DWORD PTR [eax+20]
  0005b	3b ce		 cmp	 ecx, esi
  0005d	7c 0f		 jl	 SHORT $LN133@Eqrange

; 303  : 		{
; 304  : 			return true;
; 305  : 		}
; 306  : 		else if(cp1.y == cp2.y)

  0005f	75 19		 jne	 SHORT $LN138@Eqrange

; 307  : 		{
; 308  : 			return cp1.z < cp2.z;

  00061	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  00064	3b 48 18	 cmp	 ecx, DWORD PTR [eax+24]
  00067	0f 9c c1	 setl	 cl
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree

; 2036 : 						&& _DEBUG_LT_PRED(this->_Getcomp(), _Keyval,

  0006a	84 c9		 test	 cl, cl
  0006c	74 0c		 je	 SHORT $LN138@Eqrange
$LN133@Eqrange:

; 2037 : 						 this->_Key(_Pnode)))
; 2038 : 					_Hinode = _Pnode;	// _Pnode greater, remember it

  0006e	8b c8		 mov	 ecx, eax

; 2039 : 				_Lonode = _Pnode;

  00070	89 45 f8	 mov	 DWORD PTR __Lonode$1$[ebp], eax

; 2040 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree

  00073	8b 00		 mov	 eax, DWORD PTR [eax]
  00075	89 4d fc	 mov	 DWORD PTR __Hinode$1$[ebp], ecx
  00078	eb 0d		 jmp	 SHORT $LN6@Eqrange
$LN138@Eqrange:
  0007a	8b 4d fc	 mov	 ecx, DWORD PTR __Hinode$1$[ebp]
$LN5@Eqrange:

; 2039 : 				_Lonode = _Pnode;

  0007d	89 45 f8	 mov	 DWORD PTR __Lonode$1$[ebp], eax

; 2040 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree

  00080	8b 00		 mov	 eax, DWORD PTR [eax]
  00082	eb 03		 jmp	 SHORT $LN6@Eqrange
$LN132@Eqrange:

; 2032 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree

  00084	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
$LN6@Eqrange:

; 2029 : 
; 2030 : 		while (!this->_Isnil(_Pnode))

  00087	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  0008b	74 99		 je	 SHORT $LL9@Eqrange
  0008d	8b 55 f4	 mov	 edx, DWORD PTR __Pnode$2$[ebp]
$LN8@Eqrange:

; 2041 : 				}
; 2042 : 
; 2043 : 		_Pnode = this->_Isnil(_Hinode) ? _Root()
; 2044 : 			: this->_Left(_Hinode);	// continue scan for upper bound

  00090	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  00094	75 02		 jne	 SHORT $LN13@Eqrange
  00096	8b 11		 mov	 edx, DWORD PTR [ecx]
$LN13@Eqrange:

; 2045 : 		while (!this->_Isnil(_Pnode))

  00098	80 7a 0d 00	 cmp	 BYTE PTR [edx+13], 0
  0009c	75 39		 jne	 SHORT $LN3@Eqrange
  0009e	8b 37		 mov	 esi, DWORD PTR [edi]
$LL4@Eqrange:
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp

; 296  : 	if(cp1.x < cp2.x)

  000a0	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  000a3	3b f0		 cmp	 esi, eax
  000a5	7c 23		 jl	 SHORT $LN134@Eqrange

; 297  : 	{
; 298  : 		return true;
; 299  : 	}
; 300  : 	else if(cp1.x == cp2.x)

  000a7	75 1c		 jne	 SHORT $LN2@Eqrange

; 301  : 	{
; 302  : 		if(cp1.y < cp2.y)

  000a9	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  000ac	8b 4a 14	 mov	 ecx, DWORD PTR [edx+20]
  000af	3b c1		 cmp	 eax, ecx
  000b1	7c 17		 jl	 SHORT $LN134@Eqrange

; 303  : 		{
; 304  : 			return true;
; 305  : 		}
; 306  : 		else if(cp1.y == cp2.y)

  000b3	75 0d		 jne	 SHORT $LN135@Eqrange

; 307  : 		{
; 308  : 			return cp1.z < cp2.z;

  000b5	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  000b8	3b 42 18	 cmp	 eax, DWORD PTR [edx+24]
  000bb	0f 9c c0	 setl	 al
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree

; 2046 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), _Keyval, this->_Key(_Pnode)))

  000be	84 c0		 test	 al, al
  000c0	75 08		 jne	 SHORT $LN134@Eqrange
$LN135@Eqrange:
  000c2	8b 4d fc	 mov	 ecx, DWORD PTR __Hinode$1$[ebp]
$LN2@Eqrange:

; 2050 : 				}
; 2051 : 			else
; 2052 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree

  000c5	8b 52 08	 mov	 edx, DWORD PTR [edx+8]
  000c8	eb 07		 jmp	 SHORT $LN1@Eqrange
$LN134@Eqrange:

; 2047 : 				{	// _Pnode greater than _Keyval, remember it
; 2048 : 				_Hinode = _Pnode;

  000ca	8b ca		 mov	 ecx, edx

; 2049 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree

  000cc	8b 12		 mov	 edx, DWORD PTR [edx]
  000ce	89 4d fc	 mov	 DWORD PTR __Hinode$1$[ebp], ecx
$LN1@Eqrange:

; 2045 : 		while (!this->_Isnil(_Pnode))

  000d1	80 7a 0d 00	 cmp	 BYTE PTR [edx+13], 0
  000d5	74 c9		 je	 SHORT $LL4@Eqrange
$LN3@Eqrange:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility

; 182  : 		{	// construct from moved compatible pair

  000d7	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  000da	8b 55 f8	 mov	 edx, DWORD PTR __Lonode$1$[ebp]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree

; 2057 : 		}

  000dd	5f		 pop	 edi
  000de	5e		 pop	 esi
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility

; 182  : 		{	// construct from moved compatible pair

  000df	89 10		 mov	 DWORD PTR [eax], edx
  000e1	89 48 04	 mov	 DWORD PTR [eax+4], ecx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree

; 2057 : 		}

  000e4	5b		 pop	 ebx
  000e5	8b e5		 mov	 esp, ebp
  000e7	5d		 pop	 ebp
  000e8	c2 08 00	 ret	 8
?_Eqrange@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@V12@@2@ABVChunkPosition@@@Z ENDP ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Eqrange
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
;	COMDAT ?_Lbound@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@2@ABVChunkPosition@@@Z
_TEXT	SEGMENT
__Keyval$ = 8						; size = 4
?_Lbound@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@2@ABVChunkPosition@@@Z PROC ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Lbound, COMDAT
; _this$ = ecx

; 2091 : 		{	// find leftmost node not less than _Keyval

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 598  : 		return ((_Nodepref)_Pnode->_Parent);

  00004	8b 31		 mov	 esi, DWORD PTR [ecx]

; 2092 : 		_Nodeptr _Pnode = _Root();

  00006	8b 46 04	 mov	 eax, DWORD PTR [esi+4]

; 2093 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails
; 2094 : 
; 2095 : 		while (!this->_Isnil(_Pnode))

  00009	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  0000d	75 3a		 jne	 SHORT $LN40@Lbound
  0000f	53		 push	 ebx
  00010	8b 5d 08	 mov	 ebx, DWORD PTR __Keyval$[ebp]
  00013	57		 push	 edi
  00014	8b 3b		 mov	 edi, DWORD PTR [ebx]
$LL4@Lbound:
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp

; 296  : 	if(cp1.x < cp2.x)

  00016	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00019	3b cf		 cmp	 ecx, edi
  0001b	7c 21		 jl	 SHORT $LN39@Lbound

; 297  : 	{
; 298  : 		return true;
; 299  : 	}
; 300  : 	else if(cp1.x == cp2.x)

  0001d	75 19		 jne	 SHORT $LN2@Lbound

; 301  : 	{
; 302  : 		if(cp1.y < cp2.y)

  0001f	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00022	8b 53 04	 mov	 edx, DWORD PTR [ebx+4]
  00025	3b ca		 cmp	 ecx, edx
  00027	7c 15		 jl	 SHORT $LN39@Lbound

; 303  : 		{
; 304  : 			return true;
; 305  : 		}
; 306  : 		else if(cp1.y == cp2.y)

  00029	75 0d		 jne	 SHORT $LN2@Lbound

; 307  : 		{
; 308  : 			return cp1.z < cp2.z;

  0002b	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  0002e	3b 4b 08	 cmp	 ecx, DWORD PTR [ebx+8]
  00031	0f 9c c1	 setl	 cl
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree

; 2096 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))

  00034	84 c9		 test	 cl, cl
  00036	75 06		 jne	 SHORT $LN39@Lbound
$LN2@Lbound:

; 2098 : 			else
; 2099 : 				{	// _Pnode not less than _Keyval, remember it
; 2100 : 				_Wherenode = _Pnode;

  00038	8b f0		 mov	 esi, eax

; 2101 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree

  0003a	8b 00		 mov	 eax, DWORD PTR [eax]
  0003c	eb 03		 jmp	 SHORT $LN1@Lbound
$LN39@Lbound:

; 2097 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree

  0003e	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
$LN1@Lbound:

; 2093 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails
; 2094 : 
; 2095 : 		while (!this->_Isnil(_Pnode))

  00041	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00045	74 cf		 je	 SHORT $LL4@Lbound
  00047	5f		 pop	 edi
  00048	5b		 pop	 ebx
$LN40@Lbound:

; 2102 : 				}
; 2103 : 
; 2104 : 		return (_Wherenode);	// return best remembered candidate

  00049	8b c6		 mov	 eax, esi
  0004b	5e		 pop	 esi

; 2105 : 		}

  0004c	5d		 pop	 ebp
  0004d	c2 04 00	 ret	 4
?_Lbound@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@2@ABVChunkPosition@@@Z ENDP ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Lbound
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
;	COMDAT ?_Kfn@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IBEABVChunkPosition@@ABU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@2@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?_Kfn@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IBEABVChunkPosition@@ABU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Kfn, COMDAT
; _this$dead$ = ecx

; 2220 : 		{	// get key from value

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2221 : 		return (_Traits::_Kfn(_Val));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 2222 : 		}

  00006	5d		 pop	 ebp
  00007	c2 04 00	 ret	 4
?_Kfn@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IBEABVChunkPosition@@ABU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Kfn
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
;	COMDAT ??0?$_Tree_comp@$0A@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@VChunkPosition@@@1@ABV?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
___formal$dead$ = 8					; size = 4
__Al$dead$ = 12						; size = 4
??0?$_Tree_comp@$0A@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@VChunkPosition@@@1@ABV?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@1@@Z PROC ; std::_Tree_comp<0,std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Tree_comp<0,std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >, COMDAT
; _this$ = ecx

; 1007 : 		{	// construct ordering predicate

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 573  : 		this->_Myhead = 0;

  00003	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 574  : 		this->_Mysize = 0;

  00009	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 575  : 		}
; 576  : 
; 577  : 	enum _Redbl
; 578  : 		{	// colors for link to parent
; 579  : 		_Red, _Black};
; 580  : 
; 581  : 	static char& _Color(_Nodeptr _Pnode)
; 582  : 		{	// return reference to color in node
; 583  : 		return ((char&)_Pnode->_Color);
; 584  : 		}
; 585  : 
; 586  : 	static char& _Isnil(_Nodeptr _Pnode)
; 587  : 		{	// return reference to nil flag in node
; 588  : 		return ((char&)_Pnode->_Isnil);
; 589  : 		}
; 590  : 
; 591  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 592  : 		{	// return reference to left pointer in node
; 593  : 		return ((_Nodepref)_Pnode->_Left);
; 594  : 		}
; 595  : 
; 596  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 597  : 		{	// return reference to parent pointer in node
; 598  : 		return ((_Nodepref)_Pnode->_Parent);
; 599  : 		}
; 600  : 
; 601  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 602  : 		{	// return reference to right pointer in node
; 603  : 		return ((_Nodepref)_Pnode->_Right);
; 604  : 		}
; 605  : 
; 606  : 	static reference _Myval(_Nodeptr _Pnode)
; 607  : 		{	// return reference to value in node
; 608  : 		return ((reference)_Pnode->_Myval);
; 609  : 		}
; 610  : 
; 611  : 	static _Nodeptr _Max(_Nodeptr _Pnode)
; 612  : 		{	// return rightmost node in subtree at _Pnode
; 613  : 		while (!_Isnil(_Right(_Pnode)))
; 614  : 			_Pnode = _Right(_Pnode);
; 615  : 		return (_Pnode);
; 616  : 		}
; 617  : 
; 618  : 	static _Nodeptr _Min(_Nodeptr _Pnode)
; 619  : 		{	// return leftmost node in subtree at _Pnode
; 620  : 		while (!_Isnil(_Left(_Pnode)))
; 621  : 			_Pnode = _Left(_Pnode);
; 622  : 		return (_Pnode);
; 623  : 		}
; 624  : 
; 625  : 	_Nodeptr _Myhead;	// pointer to head node
; 626  : 	size_type _Mysize;	// number of elements
; 627  : 	};
; 628  : 
; 629  : 		// TEMPLATE CLASS _Tree_alloc
; 630  : template<bool _Al_has_storage,
; 631  : 	class _Alloc_types>
; 632  : 	class _Tree_alloc
; 633  : 		: public _Tree_val<typename _Alloc_types::_Val_types>
; 634  : 	{	// base class for tree to hold allocator with storage
; 635  : public:
; 636  : 	typedef _Tree_alloc<_Al_has_storage, _Alloc_types> _Myt;
; 637  : 	typedef _Tree_val<typename _Alloc_types::_Val_types> _Mybase;
; 638  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 639  : 	typedef typename _Alloc_types::_Alnod_type _Alty;
; 640  : 	typedef typename _Alloc_types::_Node _Node;
; 641  : 	typedef typename _Alloc_types::_Nodeptr _Nodeptr;
; 642  : 
; 643  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 644  : 	_Tree_alloc(const _Alloc& _Al = _Alloc())
; 645  : 		: _Alnod(_Al)
; 646  : 		{	// construct head node, allocator from _Al
; 647  : 		this->_Myhead = _Buyheadnode();
; 648  : 		}
; 649  : 
; 650  : 	~_Tree_alloc() _NOEXCEPT
; 651  : 		{	// destroy head node
; 652  : 		_Freeheadnode(this->_Myhead);
; 653  : 		}
; 654  : 
; 655  : 	void _Change_alloc(const _Alty& _Al)
; 656  : 		{	// replace old allocator
; 657  : 		_Alnod = _Al;
; 658  : 		}
; 659  : 
; 660  : 	void _Swap_alloc(_Myt& _Right)
; 661  : 		{	// swap allocators
; 662  : 		_Swap_adl(_Alnod, _Right._Alnod);
; 663  : 		}
; 664  : 
; 665  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 666  : 	_Tree_alloc(const _Alloc& _Al = _Alloc())
; 667  : 		: _Alnod(_Al)
; 668  : 		{	// construct allocators from _Al
; 669  : 		this->_Myhead = _Buyheadnode();
; 670  : 		_TRY_BEGIN
; 671  : 		_Alloc_proxy();
; 672  : 		_CATCH_ALL
; 673  : 		_Freeheadnode(this->_Myhead);
; 674  : 		_RERAISE;
; 675  : 		_CATCH_END
; 676  : 		}
; 677  : 
; 678  : 	~_Tree_alloc() _NOEXCEPT
; 679  : 		{	// destroy proxy
; 680  : 		_Freeheadnode(this->_Myhead);
; 681  : 		_Free_proxy();
; 682  : 		}
; 683  : 
; 684  : 	void _Change_alloc(const _Alty& _Al)
; 685  : 		{	// replace old allocator
; 686  : 		_Free_proxy();
; 687  : 		_Alnod = _Al;
; 688  : 		_Alloc_proxy();
; 689  : 		}
; 690  : 
; 691  : 	void _Swap_alloc(_Myt& _Right)
; 692  : 		{	// swap allocators
; 693  : 		_Swap_adl(_Alnod, _Right._Alnod);
; 694  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 695  : 		}
; 696  : 
; 697  : 	void _Alloc_proxy()
; 698  : 		{	// construct proxy from _Alnod
; 699  : 		typename _Alty::template rebind<_Container_proxy>::other
; 700  : 			_Alproxy(_Alnod);
; 701  : 		this->_Myproxy = _Alproxy.allocate(1);
; 702  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 703  : 		this->_Myproxy->_Mycont = this;
; 704  : 		}
; 705  : 
; 706  : 	void _Free_proxy()
; 707  : 		{	// destroy proxy
; 708  : 		typename _Alty::template rebind<_Container_proxy>::other
; 709  : 			_Alproxy(_Alnod);
; 710  : 		this->_Orphan_all();
; 711  : 		_Alproxy.destroy(this->_Myproxy);
; 712  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 713  : 		this->_Myproxy = 0;
; 714  : 		}
; 715  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 716  : 
; 717  : 	_Nodeptr _Buyheadnode()
; 718  : 		{	// get head node using current allocator
; 719  : 		_Nodeptr _Pnode = _Alnod.allocate(1);
; 720  : 
; 721  : 		_TRY_BEGIN
; 722  : 		_Alnod.construct(
; 723  : 			_STD addressof(this->_Left(_Pnode)), _Pnode);
; 724  : 		_Alnod.construct(
; 725  : 			_STD addressof(this->_Parent(_Pnode)), _Pnode);
; 726  : 		_Alnod.construct(
; 727  : 			_STD addressof(this->_Right(_Pnode)), _Pnode);
; 728  : 		_CATCH_ALL
; 729  : 		_Alnod.deallocate(_Pnode, 1);
; 730  : 		_RERAISE;
; 731  : 		_CATCH_END
; 732  : 
; 733  : 		this->_Color(_Pnode) = this->_Black;
; 734  : 		this->_Isnil(_Pnode) = true;
; 735  : 		return (_Pnode);
; 736  : 		}
; 737  : 
; 738  : 	void _Freeheadnode(_Nodeptr _Pnode)
; 739  : 		{	// free head node using current allocator
; 740  : 		_Alnod.destroy(
; 741  : 			_STD addressof(this->_Left(_Pnode)));
; 742  : 		_Alnod.destroy(
; 743  : 			_STD addressof(this->_Parent(_Pnode)));
; 744  : 		_Alnod.destroy(
; 745  : 			_STD addressof(this->_Right(_Pnode)));
; 746  : 		_Alnod.deallocate(_Pnode, 1);
; 747  : 		}
; 748  : 
; 749  : 	_Alty& _Getal()
; 750  : 		{	// get reference to allocator
; 751  : 		return (_Alnod);
; 752  : 		}
; 753  : 
; 754  : 	const _Alty& _Getal() const
; 755  : 		{	// get reference to allocator
; 756  : 		return (_Alnod);
; 757  : 		}
; 758  : 
; 759  : 	_Alty _Alnod;	// allocator object for stored elements
; 760  : 	};
; 761  : 
; 762  : 		// TEMPLATE CLASS _Tree_alloc
; 763  : template<class _Alloc_types>
; 764  : 	class _Tree_alloc<false, _Alloc_types>
; 765  : 		: public _Tree_val<typename _Alloc_types::_Val_types>
; 766  : 	{	// base class for tree to hold allocator with no storage
; 767  : public:
; 768  : 	typedef _Tree_alloc<false, _Alloc_types> _Myt;
; 769  : 	typedef _Tree_val<typename _Alloc_types::_Val_types> _Mybase;
; 770  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 771  : 	typedef typename _Alloc_types::_Alnod_type _Alty;
; 772  : 	typedef typename _Alloc_types::_Node _Node;
; 773  : 	typedef typename _Alloc_types::_Nodeptr _Nodeptr;
; 774  : 
; 775  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 776  : 	_Tree_alloc(const _Alloc& = _Alloc())
; 777  : 		{	// construct head node, allocator from _Al
; 778  : 		this->_Myhead = _Buyheadnode();

  00010	e8 00 00 00 00	 call	 ?_Buyheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@2@XZ ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::_Buyheadnode
  00015	89 06		 mov	 DWORD PTR [esi], eax

; 1008 : 		}

  00017	8b c6		 mov	 eax, esi
  00019	5e		 pop	 esi
  0001a	c2 08 00	 ret	 8
??0?$_Tree_comp@$0A@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@VChunkPosition@@@1@ABV?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@1@@Z ENDP ; std::_Tree_comp<0,std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Tree_comp<0,std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
;	COMDAT ?_Freeheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Freeheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@2@@Z PROC ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::_Freeheadnode, COMDAT
; _this$dead$ = ecx

; 862  : 		{	// free head node using current allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 586  : 		::operator delete(_Ptr);

  00003	ff 75 08	 push	 DWORD PTR __Pnode$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	83 c4 04	 add	 esp, 4
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree

; 870  : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 04 00	 ret	 4
?_Freeheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@2@@Z ENDP ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::_Freeheadnode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ?_Swap@?$_Ptr_base@VChunkBase@@@std@@QAEXAAV12@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
?_Swap@?$_Ptr_base@VChunkBase@@@std@@QAEXAAV12@@Z PROC	; std::_Ptr_base<ChunkBase>::_Swap, COMDAT
; _this$ = ecx

; 317  : 		{	// swap pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility

; 47   : 	_Ty _Tmp = _Move(_Left);

  00003	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00006	56		 push	 esi
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 318  : 		_STD swap(_Rep, _Right._Rep);

  00007	8b 75 08	 mov	 esi, DWORD PTR __Right$[ebp]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility

; 48   : 	_Left = _Move(_Right);

  0000a	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0000d	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 49   : 	_Right = _Move(_Tmp);

  00010	89 56 04	 mov	 DWORD PTR [esi+4], edx

; 48   : 	_Left = _Move(_Right);

  00013	8b 06		 mov	 eax, DWORD PTR [esi]
  00015	8b 11		 mov	 edx, DWORD PTR [ecx]
  00017	89 01		 mov	 DWORD PTR [ecx], eax

; 49   : 	_Right = _Move(_Tmp);

  00019	89 16		 mov	 DWORD PTR [esi], edx
  0001b	5e		 pop	 esi
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 320  : 		}

  0001c	5d		 pop	 ebp
  0001d	c2 04 00	 ret	 4
?_Swap@?$_Ptr_base@VChunkBase@@@std@@QAEXAAV12@@Z ENDP	; std::_Ptr_base<ChunkBase>::_Swap
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
;	COMDAT ??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QAE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$dead$ = 12					; size = 4
??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QAE?AV01@H@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::operator++, COMDAT
; _this$ = ecx

; 276  : 		{	// postincrement

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 277  : 		_Myiter _Tmp = *this;

  00003	8b 11		 mov	 edx, DWORD PTR [ecx]
  00005	56		 push	 esi
  00006	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]
  00009	89 16		 mov	 DWORD PTR [esi], edx

; 271  : 		++(*(_Mybase *)this);

  0000b	e8 00 00 00 00	 call	 ??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >,std::_Iterator_base0>::operator++

; 278  : 		++*this;
; 279  : 		return (_Tmp);

  00010	8b c6		 mov	 eax, esi
  00012	5e		 pop	 esi

; 280  : 		}

  00013	5d		 pop	 ebp
  00014	c2 08 00	 ret	 8
??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QAE?AV01@H@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
;	COMDAT ?_Erase@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@2@@Z
_TEXT	SEGMENT
_this$1$ = -4						; size = 4
__Rootnode$ = 8						; size = 4
?_Erase@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@2@@Z PROC ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Erase, COMDAT
; _this$ = ecx

; 2060 : 		{	// free entire subtree, recursively

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx

; 2061 : 		for (_Nodeptr _Pnode = _Rootnode;

  00005	8b 5d 08	 mov	 ebx, DWORD PTR __Rootnode$[ebp]
  00008	8b c1		 mov	 eax, ecx

; 2062 : 			!this->_Isnil(_Pnode); _Rootnode = _Pnode)

  0000a	80 7b 0d 00	 cmp	 BYTE PTR [ebx+13], 0
  0000e	57		 push	 edi
  0000f	89 45 fc	 mov	 DWORD PTR _this$1$[ebp], eax
  00012	8b fb		 mov	 edi, ebx
  00014	75 57		 jne	 SHORT $LN1@Erase
  00016	56		 push	 esi
  00017	eb 07 8d a4 24
	00 00 00 00	 npad	 9
$LL3@Erase:

; 2063 : 			{	// free subtrees, then node
; 2064 : 			_Erase(this->_Right(_Pnode));

  00020	ff 77 08	 push	 DWORD PTR [edi+8]
  00023	8b c8		 mov	 ecx, eax
  00025	e8 00 00 00 00	 call	 ?_Erase@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Erase
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  0002a	8b 73 20	 mov	 esi, DWORD PTR [ebx+32]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree

; 2065 : 			_Pnode = this->_Left(_Pnode);

  0002d	8b 3f		 mov	 edi, DWORD PTR [edi]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  0002f	85 f6		 test	 esi, esi
  00031	74 25		 je	 SHORT $LN37@Erase

; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  00033	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00036	83 c9 ff	 or	 ecx, -1
  00039	f0 0f c1 08	 lock	  xadd	 DWORD PTR [eax], ecx
  0003d	75 19		 jne	 SHORT $LN37@Erase

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  0003f	8b 06		 mov	 eax, DWORD PTR [esi]
  00041	8b ce		 mov	 ecx, esi
  00043	ff 10		 call	 DWORD PTR [eax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  00045	8d 46 08	 lea	 eax, DWORD PTR [esi+8]
  00048	83 c9 ff	 or	 ecx, -1
  0004b	f0 0f c1 08	 lock	  xadd	 DWORD PTR [eax], ecx
  0004f	75 07		 jne	 SHORT $LN37@Erase

; 128  : 			_Delete_this();

  00051	8b 06		 mov	 eax, DWORD PTR [esi]
  00053	8b ce		 mov	 ecx, esi
  00055	ff 50 04	 call	 DWORD PTR [eax+4]
$LN37@Erase:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 586  : 		::operator delete(_Ptr);

  00058	53		 push	 ebx
  00059	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree

; 2062 : 			!this->_Isnil(_Pnode); _Rootnode = _Pnode)

  0005e	8b 45 fc	 mov	 eax, DWORD PTR _this$1$[ebp]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 586  : 		::operator delete(_Ptr);

  00061	83 c4 04	 add	 esp, 4
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree

; 2062 : 			!this->_Isnil(_Pnode); _Rootnode = _Pnode)

  00064	80 7f 0d 00	 cmp	 BYTE PTR [edi+13], 0
  00068	8b df		 mov	 ebx, edi
  0006a	74 b4		 je	 SHORT $LL3@Erase
  0006c	5e		 pop	 esi
$LN1@Erase:
  0006d	5f		 pop	 edi
  0006e	5b		 pop	 ebx

; 2066 : 			this->_Getal().destroy(
; 2067 : 				_STD addressof(this->_Myval(_Rootnode)));
; 2068 : 
; 2069 : 			this->_Getal().deallocate(_Rootnode, 1);
; 2070 : 			}
; 2071 : 		}

  0006f	8b e5		 mov	 esp, ebp
  00071	5d		 pop	 ebp
  00072	c2 04 00	 ret	 4
?_Erase@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Erase
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
;	COMDAT ?_Lrotate@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@2@@Z
_TEXT	SEGMENT
__Wherenode$ = 8					; size = 4
?_Lrotate@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@2@@Z PROC ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Lrotate, COMDAT
; _this$ = ecx

; 2113 : 		{	// promote right node to root of subtree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 599  : 		}
; 600  : 
; 601  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 602  : 		{	// return reference to right pointer in node
; 603  : 		return ((_Nodepref)_Pnode->_Right);

  00003	8b 55 08	 mov	 edx, DWORD PTR __Wherenode$[ebp]
  00006	56		 push	 esi

; 2114 : 		_Nodeptr _Pnode = this->_Right(_Wherenode);

  00007	8b 72 08	 mov	 esi, DWORD PTR [edx+8]

; 2115 : 		this->_Right(_Wherenode) = this->_Left(_Pnode);

  0000a	8b 06		 mov	 eax, DWORD PTR [esi]
  0000c	89 42 08	 mov	 DWORD PTR [edx+8], eax

; 588  : 		return ((char&)_Pnode->_Isnil);

  0000f	8b 06		 mov	 eax, DWORD PTR [esi]

; 2116 : 
; 2117 : 		if (!this->_Isnil(this->_Left(_Pnode)))

  00011	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00015	75 03		 jne	 SHORT $LN5@Lrotate

; 2118 : 			this->_Parent(this->_Left(_Pnode)) = _Wherenode;

  00017	89 50 04	 mov	 DWORD PTR [eax+4], edx
$LN5@Lrotate:

; 2119 : 		this->_Parent(_Pnode) = this->_Parent(_Wherenode);

  0001a	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0001d	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 594  : 		}
; 595  : 
; 596  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 597  : 		{	// return reference to parent pointer in node
; 598  : 		return ((_Nodepref)_Pnode->_Parent);

  00020	8b 01		 mov	 eax, DWORD PTR [ecx]

; 2120 : 
; 2121 : 		if (_Wherenode == _Root())

  00022	3b 50 04	 cmp	 edx, DWORD PTR [eax+4]
  00025	75 0d		 jne	 SHORT $LN4@Lrotate

; 2122 : 			_Root() = _Pnode;

  00027	89 70 04	 mov	 DWORD PTR [eax+4], esi

; 2127 : 
; 2128 : 		this->_Left(_Pnode) = _Wherenode;

  0002a	89 16		 mov	 DWORD PTR [esi], edx

; 2129 : 		this->_Parent(_Wherenode) = _Pnode;

  0002c	89 72 04	 mov	 DWORD PTR [edx+4], esi
  0002f	5e		 pop	 esi

; 2130 : 		}

  00030	5d		 pop	 ebp
  00031	c2 04 00	 ret	 4
$LN4@Lrotate:

; 589  : 		}
; 590  : 
; 591  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 592  : 		{	// return reference to left pointer in node
; 593  : 		return ((_Nodepref)_Pnode->_Left);

  00034	8b 42 04	 mov	 eax, DWORD PTR [edx+4]

; 2123 : 		else if (_Wherenode == this->_Left(this->_Parent(_Wherenode)))

  00037	3b 10		 cmp	 edx, DWORD PTR [eax]
  00039	75 0c		 jne	 SHORT $LN2@Lrotate

; 2124 : 			this->_Left(this->_Parent(_Wherenode)) = _Pnode;

  0003b	89 30		 mov	 DWORD PTR [eax], esi

; 2127 : 
; 2128 : 		this->_Left(_Pnode) = _Wherenode;

  0003d	89 16		 mov	 DWORD PTR [esi], edx

; 2129 : 		this->_Parent(_Wherenode) = _Pnode;

  0003f	89 72 04	 mov	 DWORD PTR [edx+4], esi
  00042	5e		 pop	 esi

; 2130 : 		}

  00043	5d		 pop	 ebp
  00044	c2 04 00	 ret	 4
$LN2@Lrotate:

; 2125 : 		else
; 2126 : 			this->_Right(this->_Parent(_Wherenode)) = _Pnode;

  00047	89 70 08	 mov	 DWORD PTR [eax+8], esi

; 2127 : 
; 2128 : 		this->_Left(_Pnode) = _Wherenode;

  0004a	89 16		 mov	 DWORD PTR [esi], edx

; 2129 : 		this->_Parent(_Wherenode) = _Pnode;

  0004c	89 72 04	 mov	 DWORD PTR [edx+4], esi
  0004f	5e		 pop	 esi

; 2130 : 		}

  00050	5d		 pop	 ebp
  00051	c2 04 00	 ret	 4
?_Lrotate@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Lrotate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
;	COMDAT ?_Rmost@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@2@XZ
_TEXT	SEGMENT
?_Rmost@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@2@XZ PROC ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Rmost, COMDAT
; _this$ = ecx

; 603  : 		return ((_Nodepref)_Pnode->_Right);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 c0 08	 add	 eax, 8

; 2134 : 		return (this->_Right(this->_Myhead));
; 2135 : 		}

  00005	c3		 ret	 0
?_Rmost@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Rmost
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@2@XZ
_TEXT	SEGMENT
?_Root@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@2@XZ PROC ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Root, COMDAT
; _this$ = ecx

; 598  : 		return ((_Nodepref)_Pnode->_Parent);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 c0 04	 add	 eax, 4

; 2139 : 		return (this->_Parent(this->_Myhead));
; 2140 : 		}

  00005	c3		 ret	 0
?_Root@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Root
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
;	COMDAT ?_Rrotate@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@2@@Z
_TEXT	SEGMENT
__Wherenode$ = 8					; size = 4
?_Rrotate@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@2@@Z PROC ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Rrotate, COMDAT
; _this$ = ecx

; 2143 : 		{	// promote left node to root of subtree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2144 : 		_Nodeptr _Pnode = this->_Left(_Wherenode);

  00003	8b 55 08	 mov	 edx, DWORD PTR __Wherenode$[ebp]
  00006	56		 push	 esi
  00007	8b 32		 mov	 esi, DWORD PTR [edx]

; 2145 : 		this->_Left(_Wherenode) = this->_Right(_Pnode);

  00009	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0000c	89 02		 mov	 DWORD PTR [edx], eax

; 588  : 		return ((char&)_Pnode->_Isnil);

  0000e	8b 46 08	 mov	 eax, DWORD PTR [esi+8]

; 2146 : 
; 2147 : 		if (!this->_Isnil(this->_Right(_Pnode)))

  00011	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00015	75 03		 jne	 SHORT $LN5@Rrotate

; 2148 : 			this->_Parent(this->_Right(_Pnode)) = _Wherenode;

  00017	89 50 04	 mov	 DWORD PTR [eax+4], edx
$LN5@Rrotate:

; 2149 : 		this->_Parent(_Pnode) = this->_Parent(_Wherenode);

  0001a	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0001d	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 589  : 		}
; 590  : 
; 591  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 592  : 		{	// return reference to left pointer in node
; 593  : 		return ((_Nodepref)_Pnode->_Left);
; 594  : 		}
; 595  : 
; 596  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 597  : 		{	// return reference to parent pointer in node
; 598  : 		return ((_Nodepref)_Pnode->_Parent);

  00020	8b 01		 mov	 eax, DWORD PTR [ecx]

; 2150 : 
; 2151 : 		if (_Wherenode == _Root())

  00022	3b 50 04	 cmp	 edx, DWORD PTR [eax+4]
  00025	75 0e		 jne	 SHORT $LN4@Rrotate

; 2152 : 			_Root() = _Pnode;

  00027	89 70 04	 mov	 DWORD PTR [eax+4], esi

; 2157 : 
; 2158 : 		this->_Right(_Pnode) = _Wherenode;

  0002a	89 56 08	 mov	 DWORD PTR [esi+8], edx

; 2159 : 		this->_Parent(_Wherenode) = _Pnode;

  0002d	89 72 04	 mov	 DWORD PTR [edx+4], esi
  00030	5e		 pop	 esi

; 2160 : 		}

  00031	5d		 pop	 ebp
  00032	c2 04 00	 ret	 4
$LN4@Rrotate:

; 599  : 		}
; 600  : 
; 601  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 602  : 		{	// return reference to right pointer in node
; 603  : 		return ((_Nodepref)_Pnode->_Right);

  00035	8b 42 04	 mov	 eax, DWORD PTR [edx+4]

; 2153 : 		else if (_Wherenode == this->_Right(this->_Parent(_Wherenode)))

  00038	3b 50 08	 cmp	 edx, DWORD PTR [eax+8]
  0003b	75 0e		 jne	 SHORT $LN2@Rrotate

; 2154 : 			this->_Right(this->_Parent(_Wherenode)) = _Pnode;

  0003d	89 70 08	 mov	 DWORD PTR [eax+8], esi

; 2157 : 
; 2158 : 		this->_Right(_Pnode) = _Wherenode;

  00040	89 56 08	 mov	 DWORD PTR [esi+8], edx

; 2159 : 		this->_Parent(_Wherenode) = _Pnode;

  00043	89 72 04	 mov	 DWORD PTR [edx+4], esi
  00046	5e		 pop	 esi

; 2160 : 		}

  00047	5d		 pop	 ebp
  00048	c2 04 00	 ret	 4
$LN2@Rrotate:

; 2155 : 		else
; 2156 : 			this->_Left(this->_Parent(_Wherenode)) = _Pnode;

  0004b	89 30		 mov	 DWORD PTR [eax], esi

; 2157 : 
; 2158 : 		this->_Right(_Pnode) = _Wherenode;

  0004d	89 56 08	 mov	 DWORD PTR [esi+8], edx

; 2159 : 		this->_Parent(_Wherenode) = _Pnode;

  00050	89 72 04	 mov	 DWORD PTR [edx+4], esi
  00053	5e		 pop	 esi

; 2160 : 		}

  00054	5d		 pop	 ebp
  00055	c2 04 00	 ret	 4
?_Rrotate@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Rrotate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
;	COMDAT ??0?$_Tree_buy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QAE@ABV?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
__Al$dead$ = 8						; size = 4
??0?$_Tree_buy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QAE@ABV?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@1@@Z PROC ; std::_Tree_buy<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::_Tree_buy<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >, COMDAT
; _this$ = ecx

; 893  : 		{	// construct from allocator

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 573  : 		this->_Myhead = 0;

  00003	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 574  : 		this->_Mysize = 0;

  00009	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 575  : 		}
; 576  : 
; 577  : 	enum _Redbl
; 578  : 		{	// colors for link to parent
; 579  : 		_Red, _Black};
; 580  : 
; 581  : 	static char& _Color(_Nodeptr _Pnode)
; 582  : 		{	// return reference to color in node
; 583  : 		return ((char&)_Pnode->_Color);
; 584  : 		}
; 585  : 
; 586  : 	static char& _Isnil(_Nodeptr _Pnode)
; 587  : 		{	// return reference to nil flag in node
; 588  : 		return ((char&)_Pnode->_Isnil);
; 589  : 		}
; 590  : 
; 591  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 592  : 		{	// return reference to left pointer in node
; 593  : 		return ((_Nodepref)_Pnode->_Left);
; 594  : 		}
; 595  : 
; 596  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 597  : 		{	// return reference to parent pointer in node
; 598  : 		return ((_Nodepref)_Pnode->_Parent);
; 599  : 		}
; 600  : 
; 601  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 602  : 		{	// return reference to right pointer in node
; 603  : 		return ((_Nodepref)_Pnode->_Right);
; 604  : 		}
; 605  : 
; 606  : 	static reference _Myval(_Nodeptr _Pnode)
; 607  : 		{	// return reference to value in node
; 608  : 		return ((reference)_Pnode->_Myval);
; 609  : 		}
; 610  : 
; 611  : 	static _Nodeptr _Max(_Nodeptr _Pnode)
; 612  : 		{	// return rightmost node in subtree at _Pnode
; 613  : 		while (!_Isnil(_Right(_Pnode)))
; 614  : 			_Pnode = _Right(_Pnode);
; 615  : 		return (_Pnode);
; 616  : 		}
; 617  : 
; 618  : 	static _Nodeptr _Min(_Nodeptr _Pnode)
; 619  : 		{	// return leftmost node in subtree at _Pnode
; 620  : 		while (!_Isnil(_Left(_Pnode)))
; 621  : 			_Pnode = _Left(_Pnode);
; 622  : 		return (_Pnode);
; 623  : 		}
; 624  : 
; 625  : 	_Nodeptr _Myhead;	// pointer to head node
; 626  : 	size_type _Mysize;	// number of elements
; 627  : 	};
; 628  : 
; 629  : 		// TEMPLATE CLASS _Tree_alloc
; 630  : template<bool _Al_has_storage,
; 631  : 	class _Alloc_types>
; 632  : 	class _Tree_alloc
; 633  : 		: public _Tree_val<typename _Alloc_types::_Val_types>
; 634  : 	{	// base class for tree to hold allocator with storage
; 635  : public:
; 636  : 	typedef _Tree_alloc<_Al_has_storage, _Alloc_types> _Myt;
; 637  : 	typedef _Tree_val<typename _Alloc_types::_Val_types> _Mybase;
; 638  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 639  : 	typedef typename _Alloc_types::_Alnod_type _Alty;
; 640  : 	typedef typename _Alloc_types::_Node _Node;
; 641  : 	typedef typename _Alloc_types::_Nodeptr _Nodeptr;
; 642  : 
; 643  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 644  : 	_Tree_alloc(const _Alloc& _Al = _Alloc())
; 645  : 		: _Alnod(_Al)
; 646  : 		{	// construct head node, allocator from _Al
; 647  : 		this->_Myhead = _Buyheadnode();
; 648  : 		}
; 649  : 
; 650  : 	~_Tree_alloc() _NOEXCEPT
; 651  : 		{	// destroy head node
; 652  : 		_Freeheadnode(this->_Myhead);
; 653  : 		}
; 654  : 
; 655  : 	void _Change_alloc(const _Alty& _Al)
; 656  : 		{	// replace old allocator
; 657  : 		_Alnod = _Al;
; 658  : 		}
; 659  : 
; 660  : 	void _Swap_alloc(_Myt& _Right)
; 661  : 		{	// swap allocators
; 662  : 		_Swap_adl(_Alnod, _Right._Alnod);
; 663  : 		}
; 664  : 
; 665  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 666  : 	_Tree_alloc(const _Alloc& _Al = _Alloc())
; 667  : 		: _Alnod(_Al)
; 668  : 		{	// construct allocators from _Al
; 669  : 		this->_Myhead = _Buyheadnode();
; 670  : 		_TRY_BEGIN
; 671  : 		_Alloc_proxy();
; 672  : 		_CATCH_ALL
; 673  : 		_Freeheadnode(this->_Myhead);
; 674  : 		_RERAISE;
; 675  : 		_CATCH_END
; 676  : 		}
; 677  : 
; 678  : 	~_Tree_alloc() _NOEXCEPT
; 679  : 		{	// destroy proxy
; 680  : 		_Freeheadnode(this->_Myhead);
; 681  : 		_Free_proxy();
; 682  : 		}
; 683  : 
; 684  : 	void _Change_alloc(const _Alty& _Al)
; 685  : 		{	// replace old allocator
; 686  : 		_Free_proxy();
; 687  : 		_Alnod = _Al;
; 688  : 		_Alloc_proxy();
; 689  : 		}
; 690  : 
; 691  : 	void _Swap_alloc(_Myt& _Right)
; 692  : 		{	// swap allocators
; 693  : 		_Swap_adl(_Alnod, _Right._Alnod);
; 694  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 695  : 		}
; 696  : 
; 697  : 	void _Alloc_proxy()
; 698  : 		{	// construct proxy from _Alnod
; 699  : 		typename _Alty::template rebind<_Container_proxy>::other
; 700  : 			_Alproxy(_Alnod);
; 701  : 		this->_Myproxy = _Alproxy.allocate(1);
; 702  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 703  : 		this->_Myproxy->_Mycont = this;
; 704  : 		}
; 705  : 
; 706  : 	void _Free_proxy()
; 707  : 		{	// destroy proxy
; 708  : 		typename _Alty::template rebind<_Container_proxy>::other
; 709  : 			_Alproxy(_Alnod);
; 710  : 		this->_Orphan_all();
; 711  : 		_Alproxy.destroy(this->_Myproxy);
; 712  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 713  : 		this->_Myproxy = 0;
; 714  : 		}
; 715  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 716  : 
; 717  : 	_Nodeptr _Buyheadnode()
; 718  : 		{	// get head node using current allocator
; 719  : 		_Nodeptr _Pnode = _Alnod.allocate(1);
; 720  : 
; 721  : 		_TRY_BEGIN
; 722  : 		_Alnod.construct(
; 723  : 			_STD addressof(this->_Left(_Pnode)), _Pnode);
; 724  : 		_Alnod.construct(
; 725  : 			_STD addressof(this->_Parent(_Pnode)), _Pnode);
; 726  : 		_Alnod.construct(
; 727  : 			_STD addressof(this->_Right(_Pnode)), _Pnode);
; 728  : 		_CATCH_ALL
; 729  : 		_Alnod.deallocate(_Pnode, 1);
; 730  : 		_RERAISE;
; 731  : 		_CATCH_END
; 732  : 
; 733  : 		this->_Color(_Pnode) = this->_Black;
; 734  : 		this->_Isnil(_Pnode) = true;
; 735  : 		return (_Pnode);
; 736  : 		}
; 737  : 
; 738  : 	void _Freeheadnode(_Nodeptr _Pnode)
; 739  : 		{	// free head node using current allocator
; 740  : 		_Alnod.destroy(
; 741  : 			_STD addressof(this->_Left(_Pnode)));
; 742  : 		_Alnod.destroy(
; 743  : 			_STD addressof(this->_Parent(_Pnode)));
; 744  : 		_Alnod.destroy(
; 745  : 			_STD addressof(this->_Right(_Pnode)));
; 746  : 		_Alnod.deallocate(_Pnode, 1);
; 747  : 		}
; 748  : 
; 749  : 	_Alty& _Getal()
; 750  : 		{	// get reference to allocator
; 751  : 		return (_Alnod);
; 752  : 		}
; 753  : 
; 754  : 	const _Alty& _Getal() const
; 755  : 		{	// get reference to allocator
; 756  : 		return (_Alnod);
; 757  : 		}
; 758  : 
; 759  : 	_Alty _Alnod;	// allocator object for stored elements
; 760  : 	};
; 761  : 
; 762  : 		// TEMPLATE CLASS _Tree_alloc
; 763  : template<class _Alloc_types>
; 764  : 	class _Tree_alloc<false, _Alloc_types>
; 765  : 		: public _Tree_val<typename _Alloc_types::_Val_types>
; 766  : 	{	// base class for tree to hold allocator with no storage
; 767  : public:
; 768  : 	typedef _Tree_alloc<false, _Alloc_types> _Myt;
; 769  : 	typedef _Tree_val<typename _Alloc_types::_Val_types> _Mybase;
; 770  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 771  : 	typedef typename _Alloc_types::_Alnod_type _Alty;
; 772  : 	typedef typename _Alloc_types::_Node _Node;
; 773  : 	typedef typename _Alloc_types::_Nodeptr _Nodeptr;
; 774  : 
; 775  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 776  : 	_Tree_alloc(const _Alloc& = _Alloc())
; 777  : 		{	// construct head node, allocator from _Al
; 778  : 		this->_Myhead = _Buyheadnode();

  00010	e8 00 00 00 00	 call	 ?_Buyheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@2@XZ ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::_Buyheadnode
  00015	89 06		 mov	 DWORD PTR [esi], eax

; 894  : 		}

  00017	8b c6		 mov	 eax, esi
  00019	5e		 pop	 esi
  0001a	c2 04 00	 ret	 4
??0?$_Tree_buy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QAE@ABV?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@1@@Z ENDP ; std::_Tree_buy<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::_Tree_buy<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
;	COMDAT ?_Getal@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?_Getal@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@std@@@std@@@2@XZ PROC ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::_Getal, COMDAT
; _this$dead$ = ecx

; 873  : 		{	// get allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 874  : 		return (_Alty());

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 875  : 		}

  00006	5d		 pop	 ebp
  00007	c2 04 00	 ret	 4
?_Getal@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@std@@@std@@@2@XZ ENDP ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@2@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$dead$ = 12					; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@2@I@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void *> > >::deallocate, COMDAT
; _this$dead$ = ecx

; 886  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 586  : 		::operator delete(_Ptr);

  00003	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	83 c4 04	 add	 esp, 4

; 887  : 		_Mybase::deallocate(_Ptr, _Count);
; 888  : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 08 00	 ret	 8
?deallocate@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@2@I@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void *> > >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
;	COMDAT ?_Color@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@2@@Z
_TEXT	SEGMENT
?_Color@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@2@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::_Color, COMDAT
; __Pnode$ = ecx

; 583  : 		return ((char&)_Pnode->_Color);

  00000	8d 41 0c	 lea	 eax, DWORD PTR [ecx+12]

; 584  : 		}

  00003	c3		 ret	 0
?_Color@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@2@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::_Color
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
;	COMDAT ?_Max@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@2@PAU32@@Z
_TEXT	SEGMENT
?_Max@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@2@PAU32@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::_Max, COMDAT
; __Pnode$ = ecx

; 588  : 		return ((char&)_Pnode->_Isnil);

  00000	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]

; 613  : 		while (!_Isnil(_Right(_Pnode)))

  00003	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00007	75 12		 jne	 SHORT $LN14@Max
  00009	8d a4 24 00 00
	00 00		 npad	 7
$LL2@Max:

; 614  : 			_Pnode = _Right(_Pnode);

  00010	8b c8		 mov	 ecx, eax

; 588  : 		return ((char&)_Pnode->_Isnil);

  00012	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]

; 613  : 		while (!_Isnil(_Right(_Pnode)))

  00015	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00019	74 f5		 je	 SHORT $LL2@Max
$LN14@Max:

; 615  : 		return (_Pnode);

  0001b	8b c1		 mov	 eax, ecx

; 616  : 		}

  0001d	c3		 ret	 0
?_Max@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@2@PAU32@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::_Max
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
;	COMDAT ??0?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
___formal$dead$ = 8					; size = 4
??0?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@1@@Z PROC ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::_Tree_alloc<0,std::_Tree_base_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >, COMDAT
; _this$ = ecx

; 776  : 	_Tree_alloc(const _Alloc& = _Alloc())

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 573  : 		this->_Myhead = 0;

  00003	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 574  : 		this->_Mysize = 0;

  00009	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 777  : 		{	// construct head node, allocator from _Al
; 778  : 		this->_Myhead = _Buyheadnode();

  00010	e8 00 00 00 00	 call	 ?_Buyheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@2@XZ ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::_Buyheadnode
  00015	89 06		 mov	 DWORD PTR [esi], eax

; 779  : 		}

  00017	8b c6		 mov	 eax, esi
  00019	5e		 pop	 esi
  0001a	c2 04 00	 ret	 4
??0?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@1@@Z ENDP ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::_Tree_alloc<0,std::_Tree_base_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@std@@@std@@@std@@QAE@XZ PROC ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void *> > >::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void *> > >, COMDAT
; _this$ = ecx

; 831  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@std@@@std@@@std@@QAE@XZ ENDP ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void *> > >::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@2@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$dead$ = 12					; size = 4
?deallocate@?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@2@I@Z PROC ; std::allocator<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void *> >::deallocate, COMDAT
; _this$dead$ = ecx

; 585  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 586  : 		::operator delete(_Ptr);

  00003	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	83 c4 04	 add	 esp, 4

; 587  : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 08 00	 ret	 8
?deallocate@?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@2@I@Z ENDP ; std::allocator<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void *> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
;	COMDAT ?_Buyheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@2@XZ
_TEXT	SEGMENT
?_Buyheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@2@XZ PROC ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::_Buyheadnode, COMDAT
; _this$dead$ = ecx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  00000	6a 24		 push	 36			; 00000024H
  00002	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00007	83 c4 04	 add	 esp, 4
  0000a	85 c0		 test	 eax, eax
  0000c	0f 84 00 00 00
	00		 je	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree

; 598  : 		return ((_Nodepref)_Pnode->_Parent);

  00012	8d 48 04	 lea	 ecx, DWORD PTR [eax+4]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 617  : _VARIADIC_EXPAND_0X(_ALLOC_MEMBER_CONSTRUCT, , , , )

  00015	89 00		 mov	 DWORD PTR [eax], eax
  00017	85 c9		 test	 ecx, ecx
  00019	74 02		 je	 SHORT $LN61@Buyheadnod
  0001b	89 01		 mov	 DWORD PTR [ecx], eax
$LN61@Buyheadnod:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree

; 603  : 		return ((_Nodepref)_Pnode->_Right);

  0001d	8d 48 08	 lea	 ecx, DWORD PTR [eax+8]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 617  : _VARIADIC_EXPAND_0X(_ALLOC_MEMBER_CONSTRUCT, , , , )

  00020	85 c9		 test	 ecx, ecx
  00022	74 02		 je	 SHORT $LN83@Buyheadnod
  00024	89 01		 mov	 DWORD PTR [ecx], eax
$LN83@Buyheadnod:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree

; 856  : 		this->_Color(_Pnode) = this->_Black;

  00026	66 c7 40 0c 01
	01		 mov	 WORD PTR [eax+12], 257	; 00000101H

; 857  : 		this->_Isnil(_Pnode) = true;
; 858  : 		return (_Pnode);
; 859  : 		}

  0002c	c3		 ret	 0
?_Buyheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@2@XZ ENDP ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::_Buyheadnode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@std@@@std@@QAE@XZ PROC ; std::allocator<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void *> >::allocator<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void *> >, COMDAT
; _this$ = ecx

; 566  : 		{	// construct default allocator (do nothing)
; 567  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@std@@@std@@QAE@XZ ENDP ; std::allocator<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void *> >::allocator<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
;	COMDAT ??0?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >, COMDAT
; _this$ = ecx

; 572  : 		{	// initialize data
; 573  : 		this->_Myhead = 0;

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 574  : 		this->_Mysize = 0;

  00006	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 575  : 		}

  0000d	8b c1		 mov	 eax, ecx
  0000f	c3		 ret	 0
??0?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@2@I@Z
_TEXT	SEGMENT
__Count$dead$ = 8					; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@2@I@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void *> > >::allocate, COMDAT
; _this$dead$ = ecx

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  00000	6a 24		 push	 36			; 00000024H
  00002	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00007	83 c4 04	 add	 esp, 4
  0000a	85 c0		 test	 eax, eax
  0000c	74 03		 je	 SHORT $LN15@allocate

; 876  : 		return (_Mybase::allocate(_Count));
; 877  : 		}

  0000e	c2 04 00	 ret	 4
$LN15@allocate:

; 29   : 		_Xbad_alloc();	// report no memory

  00011	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN17@allocate:
$LN14@allocate:
  00016	cc		 int	 3
?allocate@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@2@I@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void *> > >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@2@I@Z
_TEXT	SEGMENT
__Count$dead$ = 8					; size = 4
?allocate@?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@2@I@Z PROC ; std::allocator<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void *> >::allocate, COMDAT
; _this$dead$ = ecx

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  00000	6a 24		 push	 36			; 00000024H
  00002	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00007	83 c4 04	 add	 esp, 4
  0000a	85 c0		 test	 eax, eax
  0000c	74 03		 je	 SHORT $LN12@allocate

; 591  : 		return (_Allocate(_Count, (pointer)0));
; 592  : 		}

  0000e	c2 04 00	 ret	 4
$LN12@allocate:

; 29   : 		_Xbad_alloc();	// report no memory

  00011	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN14@allocate:
$LN11@allocate:
  00016	cc		 int	 3
?allocate@?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@2@I@Z ENDP ; std::allocator<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void *> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ??$?0VEmptyChunk@@@?$shared_ptr@VChunkBase@@@std@@QAE@PAVEmptyChunk@@@Z
_TEXT	SEGMENT
__Px$ = 8						; size = 4
??$?0VEmptyChunk@@@?$shared_ptr@VChunkBase@@@std@@QAE@PAVEmptyChunk@@@Z PROC ; std::shared_ptr<ChunkBase>::shared_ptr<ChunkBase><EmptyChunk>, COMDAT
; _this$ = ecx

; 485  : 		explicit shared_ptr(_Ux *_Px)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 486  : 		{	// construct shared_ptr object that owns _Px
; 487  : 		_Resetp(_Px);

  00004	ff 75 08	 push	 DWORD PTR __Px$[ebp]
  00007	8b f1		 mov	 esi, ecx

; 282  : 		{	// construct

  00009	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  0000f	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 486  : 		{	// construct shared_ptr object that owns _Px
; 487  : 		_Resetp(_Px);

  00016	e8 00 00 00 00	 call	 ??$_Resetp@VEmptyChunk@@@?$shared_ptr@VChunkBase@@@std@@AAEXPAVEmptyChunk@@@Z ; std::shared_ptr<ChunkBase>::_Resetp<EmptyChunk>

; 488  : 		}

  0001b	8b c6		 mov	 eax, esi
  0001d	5e		 pop	 esi
  0001e	5d		 pop	 ebp
  0001f	c2 04 00	 ret	 4
??$?0VEmptyChunk@@@?$shared_ptr@VChunkBase@@@std@@QAE@PAVEmptyChunk@@@Z ENDP ; std::shared_ptr<ChunkBase>::shared_ptr<ChunkBase><EmptyChunk>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
;	COMDAT ??$?0ABVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@QAE@ABVChunkPosition@@$$QAV?$shared_ptr@VChunkBase@@@1@PAPAX@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
___formal$dead$ = 16					; size = 4
??$?0ABVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@QAE@ABVChunkPosition@@$$QAV?$shared_ptr@VChunkBase@@@1@PAPAX@Z PROC ; std::pair<ChunkPosition,std::shared_ptr<ChunkBase> >::pair<ChunkPosition,std::shared_ptr<ChunkBase> ><ChunkPosition const &,std::shared_ptr<ChunkBase> >, COMDAT
; _this$ = ecx

; 138  : 		{	// construct from moved values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Val1$[ebp]
  00006	8b d1		 mov	 edx, ecx
  00008	f3 0f 7e 00	 movq	 xmm0, QWORD PTR [eax]
  0000c	56		 push	 esi
  0000d	66 0f d6 02	 movq	 QWORD PTR [edx], xmm0
  00011	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00014	8d 72 0c	 lea	 esi, DWORD PTR [edx+12]
  00017	57		 push	 edi
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 307  : 		if (this != &_Right)

  00018	8b 7d 0c	 mov	 edi, DWORD PTR __Val2$[ebp]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility

; 138  : 		{	// construct from moved values

  0001b	89 42 08	 mov	 DWORD PTR [edx+8], eax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 287  : 		{	// construct _Ptr_base object that takes resource from _Right

  0001e	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  00024	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 307  : 		if (this != &_Right)

  0002b	3b f7		 cmp	 esi, edi
  0002d	74 15		 je	 SHORT $LN36@shared_ptr
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility

; 48   : 	_Left = _Move(_Right);

  0002f	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00032	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 49   : 	_Right = _Move(_Tmp);

  00035	c7 47 04 00 00
	00 00		 mov	 DWORD PTR [edi+4], 0

; 48   : 	_Left = _Move(_Right);

  0003c	8b 07		 mov	 eax, DWORD PTR [edi]
  0003e	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00040	89 06		 mov	 DWORD PTR [esi], eax

; 49   : 	_Right = _Move(_Tmp);

  00042	89 0f		 mov	 DWORD PTR [edi], ecx
$LN36@shared_ptr:
  00044	5f		 pop	 edi

; 139  : 		}

  00045	8b c2		 mov	 eax, edx
  00047	5e		 pop	 esi
  00048	5d		 pop	 ebp
  00049	c2 0c 00	 ret	 12			; 0000000cH
??$?0ABVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@QAE@ABVChunkPosition@@$$QAV?$shared_ptr@VChunkBase@@@1@PAPAX@Z ENDP ; std::pair<ChunkPosition,std::shared_ptr<ChunkBase> >::pair<ChunkPosition,std::shared_ptr<ChunkBase> ><ChunkPosition const &,std::shared_ptr<ChunkBase> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
;	COMDAT ??$insert@U?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@$$QAU?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Val$ = 16						; size = 4
??$insert@U?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@$$QAU?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z PROC ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::insert<std::pair<ChunkPosition,std::shared_ptr<ChunkBase> > >, COMDAT
; _this$ = ecx

; 1157 : 		typename enable_if<is_convertible<_Valty, value_type>::value,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi

; 1158 : 			iterator>::type
; 1159 : 		insert(const_iterator _Where, _Valty&& _Val)
; 1160 : 		{	// try to insert node with value _Val using _Where as a hint
; 1161 : 		_Nodeptr _Newnode = this->_Buynode(_STD forward<_Valty>(_Val));

  00004	ff 75 10	 push	 DWORD PTR __Val$[ebp]
  00007	8b f9		 mov	 edi, ecx
  00009	e8 00 00 00 00	 call	 ??$_Buynode@U?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@?$_Tree_buy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@1@$$QAU?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z ; std::_Tree_buy<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::_Buynode<std::pair<ChunkPosition,std::shared_ptr<ChunkBase> > >

; 1162 : 		return (_Insert_hint(_Where,
; 1163 : 			this->_Myval(_Newnode), _Newnode));

  0000e	50		 push	 eax

; 608  : 		return ((reference)_Pnode->_Myval);

  0000f	83 c0 10	 add	 eax, 16			; 00000010H

; 1162 : 		return (_Insert_hint(_Where,
; 1163 : 			this->_Myval(_Newnode), _Newnode));

  00012	50		 push	 eax
  00013	ff 75 0c	 push	 DWORD PTR __Where$[ebp]
  00016	8b cf		 mov	 ecx, edi
  00018	ff 75 08	 push	 DWORD PTR ___$ReturnUdt$[ebp]
  0001b	e8 00 00 00 00	 call	 ??$_Insert_hint@AAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@AAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@PAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@1@@Z ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Insert_hint<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > &,std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void *> *>
  00020	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1164 : 		}

  00023	5f		 pop	 edi
  00024	5d		 pop	 ebp
  00025	c2 0c 00	 ret	 12			; 0000000cH
??$insert@U?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@$$QAU?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::insert<std::pair<ChunkPosition,std::shared_ptr<ChunkBase> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
;	COMDAT ??$?0V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@V01@@?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@V12@@std@@QAE@$$QAU01@PAPAX@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
___formal$dead$ = 12					; size = 4
??$?0V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@V01@@?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@V12@@std@@QAE@$$QAU01@PAPAX@Z PROC ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > >::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > ><std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > >, COMDAT
; _this$ = ecx

; 182  : 		{	// construct from moved compatible pair

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 55 08	 mov	 edx, DWORD PTR __Right$[ebp]
  00006	8b 02		 mov	 eax, DWORD PTR [edx]
  00008	89 01		 mov	 DWORD PTR [ecx], eax
  0000a	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0000d	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 183  : 		}

  00010	8b c1		 mov	 eax, ecx
  00012	5d		 pop	 ebp
  00013	c2 08 00	 ret	 8
??$?0V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@V01@@?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@V12@@std@@QAE@$$QAU01@PAPAX@Z ENDP ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > >::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > ><std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??$_Distance@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@I@std@@YAXV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@0@0AAI@Z
_TEXT	SEGMENT
$T1 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$_Distance@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@I@std@@YAXV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@0@0AAI@Z PROC ; std::_Distance<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,unsigned int>, COMDAT
; __Off$ = ecx

; 830  : 	{	// add to _Off distance between iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 831  : 	_Distance2(_First, _Last, _Off, _Iter_cat(_First));

  00004	ff 75 fc	 push	 DWORD PTR $T1[ebp]
  00007	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  0000a	ff 75 08	 push	 DWORD PTR __First$[ebp]
  0000d	e8 00 00 00 00	 call	 ??$_Distance2@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@I@std@@YAXV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@0@0AAIUbidirectional_iterator_tag@0@@Z ; std::_Distance2<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,unsigned int>
  00012	83 c4 0c	 add	 esp, 12			; 0000000cH

; 832  : 	}

  00015	8b e5		 mov	 esp, ebp
  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
??$_Distance@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@I@std@@YAXV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@0@0AAI@Z ENDP ; std::_Distance<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,unsigned int>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstddef
;	COMDAT ??$addressof@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@YAPAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@0@AAU10@@Z
_TEXT	SEGMENT
??$addressof@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@YAPAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@0@AAU10@@Z PROC ; std::addressof<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >, COMDAT
; __Val$ = ecx

; 86   : 	return (reinterpret_cast<_Ty *>(
; 87   : 		(&const_cast<char&>(
; 88   : 		reinterpret_cast<const volatile char&>(_Val)))));

  00000	8b c1		 mov	 eax, ecx

; 89   : 	}

  00002	c3		 ret	 0
??$addressof@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@YAPAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@0@AAU10@@Z ENDP ; std::addressof<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
;	COMDAT ??$swap@D@std@@YAXAAD0@Z
_TEXT	SEGMENT
??$swap@D@std@@YAXAAD0@Z PROC				; std::swap<char>, COMDAT
; __Left$ = ecx
; __Right$ = edx

; 47   : 	_Ty _Tmp = _Move(_Left);
; 48   : 	_Left = _Move(_Right);

  00000	8a 02		 mov	 al, BYTE PTR [edx]
  00002	53		 push	 ebx
  00003	8a 19		 mov	 bl, BYTE PTR [ecx]
  00005	88 01		 mov	 BYTE PTR [ecx], al

; 49   : 	_Right = _Move(_Tmp);

  00007	88 1a		 mov	 BYTE PTR [edx], bl
  00009	5b		 pop	 ebx

; 50   : 	}

  0000a	c3		 ret	 0
??$swap@D@std@@YAXAAD0@Z ENDP				; std::swap<char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@std@@@std@@@std@@QAEXPAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@std@@@std@@@std@@QAEXPAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void *> > >::destroy<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >, COMDAT
; _this$dead$ = ecx

; 907  : 		void destroy(_Ty *_Ptr)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	56		 push	 esi
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  00007	8b 70 10	 mov	 esi, DWORD PTR [eax+16]
  0000a	85 f6		 test	 esi, esi
  0000c	74 27		 je	 SHORT $LN20@destroy
  0000e	57		 push	 edi

; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  0000f	83 cf ff	 or	 edi, -1
  00012	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  00015	8b c7		 mov	 eax, edi
  00017	f0 0f c1 01	 lock	  xadd	 DWORD PTR [ecx], eax
  0001b	75 17		 jne	 SHORT $LN23@destroy

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  0001d	8b 06		 mov	 eax, DWORD PTR [esi]
  0001f	8b ce		 mov	 ecx, esi
  00021	ff 10		 call	 DWORD PTR [eax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  00023	8d 46 08	 lea	 eax, DWORD PTR [esi+8]
  00026	f0 0f c1 38	 lock	  xadd	 DWORD PTR [eax], edi
  0002a	4f		 dec	 edi
  0002b	75 07		 jne	 SHORT $LN23@destroy

; 128  : 			_Delete_this();

  0002d	8b 06		 mov	 eax, DWORD PTR [esi]
  0002f	8b ce		 mov	 ecx, esi
  00031	ff 50 04	 call	 DWORD PTR [eax+4]
$LN23@destroy:
  00034	5f		 pop	 edi
$LN20@destroy:
  00035	5e		 pop	 esi
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 910  : 		}

  00036	5d		 pop	 ebp
  00037	c2 04 00	 ret	 4
??$destroy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@std@@@std@@@std@@QAEXPAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void *> > >::destroy<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
;	COMDAT ??$?0AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@AAV01@@?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@V12@@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@0PAPAX@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
___formal$dead$ = 16					; size = 4
??$?0AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@AAV01@@?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@V12@@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@0PAPAX@Z PROC ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > >::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > ><std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > &,std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > &>, COMDAT
; _this$ = ecx

; 138  : 		{	// construct from moved values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Val1$[ebp]
  00006	8b 00		 mov	 eax, DWORD PTR [eax]
  00008	89 01		 mov	 DWORD PTR [ecx], eax
  0000a	8b 45 0c	 mov	 eax, DWORD PTR __Val2$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 139  : 		}

  00012	8b c1		 mov	 eax, ecx
  00014	5d		 pop	 ebp
  00015	c2 0c 00	 ret	 12			; 0000000cH
??$?0AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@AAV01@@?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@V12@@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@0PAPAX@Z ENDP ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > >::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > ><std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > &,std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\map
;	COMDAT ??$_Kfn@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@SAABVChunkPosition@@ABU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z
_TEXT	SEGMENT
??$_Kfn@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@SAABVChunkPosition@@ABU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z PROC ; std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0>::_Kfn<ChunkPosition const ,std::shared_ptr<ChunkBase> >, COMDAT
; __Val$ = ecx

; 55   : 		{	// extract key from element value
; 56   : 		return (_Val.first);

  00000	8b c1		 mov	 eax, ecx

; 57   : 		}

  00002	c3		 ret	 0
??$_Kfn@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@SAABVChunkPosition@@ABU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z ENDP ; std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0>::_Kfn<ChunkPosition const ,std::shared_ptr<ChunkBase> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstddef
;	COMDAT ??$addressof@PAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@std@@@std@@YAPAPAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@0@AAPAU10@@Z
_TEXT	SEGMENT
??$addressof@PAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@std@@@std@@YAPAPAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@0@AAPAU10@@Z PROC ; std::addressof<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void *> *>, COMDAT
; __Val$ = ecx

; 86   : 	return (reinterpret_cast<_Ty *>(
; 87   : 		(&const_cast<char&>(
; 88   : 		reinterpret_cast<const volatile char&>(_Val)))));

  00000	8b c1		 mov	 eax, ecx

; 89   : 	}

  00002	c3		 ret	 0
??$addressof@PAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@std@@@std@@YAPAPAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@0@AAPAU10@@Z ENDP ; std::addressof<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void *> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@1@@Z
_TEXT	SEGMENT
__Ptr$dead$ = 8						; size = 4
??$destroy@PAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@1@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void *> > >::destroy<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void *> *>, COMDAT
; _this$dead$ = ecx

; 908  : 		{	// destroy object at _Ptr
; 909  : 		_Mytraits::destroy(*this, _Ptr);
; 910  : 		}

  00000	c2 04 00	 ret	 4
??$destroy@PAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void *> > >::destroy<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void *> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
;	COMDAT ??$swap@PAVChunkBase@@@std@@YAXAAPAVChunkBase@@0@Z
_TEXT	SEGMENT
??$swap@PAVChunkBase@@@std@@YAXAAPAVChunkBase@@0@Z PROC	; std::swap<ChunkBase *>, COMDAT
; __Left$ = ecx
; __Right$ = edx

; 47   : 	_Ty _Tmp = _Move(_Left);
; 48   : 	_Left = _Move(_Right);

  00000	8b 02		 mov	 eax, DWORD PTR [edx]
  00002	56		 push	 esi
  00003	8b 31		 mov	 esi, DWORD PTR [ecx]
  00005	89 01		 mov	 DWORD PTR [ecx], eax

; 49   : 	_Right = _Move(_Tmp);

  00007	89 32		 mov	 DWORD PTR [edx], esi
  00009	5e		 pop	 esi

; 50   : 	}

  0000a	c3		 ret	 0
??$swap@PAVChunkBase@@@std@@YAXAAPAVChunkBase@@0@Z ENDP	; std::swap<ChunkBase *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@PAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@std@@AAPAU12@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@1@AAPAU21@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__V0$ = 12						; size = 4
??$construct@PAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@std@@AAPAU12@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@1@AAPAU21@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void *> > >::construct<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void *> *,std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void *> * &>, COMDAT
; _this$dead$ = ecx

; 903  : _VARIADIC_EXPAND_0X(_WRAP_ALLOC_CONSTRUCT, , , , )

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 617  : _VARIADIC_EXPAND_0X(_ALLOC_MEMBER_CONSTRUCT, , , , )

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN11@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR __V0$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 01		 mov	 DWORD PTR [ecx], eax
$LN11@construct:

; 903  : _VARIADIC_EXPAND_0X(_WRAP_ALLOC_CONSTRUCT, , , , )

  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
??$construct@PAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@std@@AAPAU12@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@1@AAPAU21@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void *> > >::construct<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void *> *,std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void *> * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$_Allocate@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@std@@@std@@YAPAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@0@IPAU10@@Z
_TEXT	SEGMENT
??$_Allocate@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@std@@@std@@YAPAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@0@IPAU10@@Z PROC ; std::_Allocate<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void *> >, COMDAT
; __Count$ = ecx

; 23   : 	void *_Ptr = 0;
; 24   : 
; 25   : 	if (_Count == 0)
; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  00000	81 f9 c7 71 1c
	07		 cmp	 ecx, 119304647		; 071c71c7H
  00006	77 13		 ja	 SHORT $LN1@Allocate
  00008	8d 04 c9	 lea	 eax, DWORD PTR [ecx+ecx*8]
  0000b	c1 e0 02	 shl	 eax, 2
  0000e	50		 push	 eax
  0000f	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00014	83 c4 04	 add	 esp, 4
  00017	85 c0		 test	 eax, eax
  00019	75 05		 jne	 SHORT $LN7@Allocate
$LN1@Allocate:

; 29   : 		_Xbad_alloc();	// report no memory

  0001b	e9 00 00 00 00	 jmp	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN7@Allocate:

; 30   : 
; 31   : 	return ((_Ty *)_Ptr);
; 32   : 	}

  00020	c3		 ret	 0
??$_Allocate@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@std@@@std@@YAPAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@0@IPAU10@@Z ENDP ; std::_Allocate<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ??0?$shared_ptr@VChunkBase@@@std@@QAE@$$QAV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$shared_ptr@VChunkBase@@@std@@QAE@$$QAV01@@Z PROC	; std::shared_ptr<ChunkBase>::shared_ptr<ChunkBase>, COMDAT
; _this$ = ecx

; 580  : 		{	// construct shared_ptr object that takes resource from _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b d1		 mov	 edx, ecx
  00005	56		 push	 esi

; 288  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 289  : 		}
; 290  : 
; 291  : 	template<class _Ty2>
; 292  : 		_Ptr_base(_Ptr_base<_Ty2>&& _Right)
; 293  : 		: _Ptr(_Right._Ptr), _Rep(_Right._Rep)
; 294  : 		{	// construct _Ptr_base object that takes resource from _Right
; 295  : 		_Right._Ptr = 0;
; 296  : 		_Right._Rep = 0;
; 297  : 		}
; 298  : 
; 299  : 	_Myt& operator=(_Myt&& _Right)
; 300  : 		{	// construct _Ptr_base object that takes resource from _Right
; 301  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 302  : 		return (*this);
; 303  : 		}
; 304  : 
; 305  : 	void _Assign_rv(_Myt&& _Right)
; 306  : 		{	// assign by moving _Right
; 307  : 		if (this != &_Right)

  00006	8b 75 08	 mov	 esi, DWORD PTR __Right$[ebp]

; 287  : 		{	// construct _Ptr_base object that takes resource from _Right

  00009	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0
  0000f	c7 42 04 00 00
	00 00		 mov	 DWORD PTR [edx+4], 0

; 288  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 289  : 		}
; 290  : 
; 291  : 	template<class _Ty2>
; 292  : 		_Ptr_base(_Ptr_base<_Ty2>&& _Right)
; 293  : 		: _Ptr(_Right._Ptr), _Rep(_Right._Rep)
; 294  : 		{	// construct _Ptr_base object that takes resource from _Right
; 295  : 		_Right._Ptr = 0;
; 296  : 		_Right._Rep = 0;
; 297  : 		}
; 298  : 
; 299  : 	_Myt& operator=(_Myt&& _Right)
; 300  : 		{	// construct _Ptr_base object that takes resource from _Right
; 301  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 302  : 		return (*this);
; 303  : 		}
; 304  : 
; 305  : 	void _Assign_rv(_Myt&& _Right)
; 306  : 		{	// assign by moving _Right
; 307  : 		if (this != &_Right)

  00016	3b d6		 cmp	 edx, esi
  00018	74 15		 je	 SHORT $LN30@shared_ptr
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility

; 48   : 	_Left = _Move(_Right);

  0001a	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0001d	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 49   : 	_Right = _Move(_Tmp);

  00020	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 48   : 	_Left = _Move(_Right);

  00027	8b 06		 mov	 eax, DWORD PTR [esi]
  00029	8b 0a		 mov	 ecx, DWORD PTR [edx]
  0002b	89 02		 mov	 DWORD PTR [edx], eax

; 49   : 	_Right = _Move(_Tmp);

  0002d	89 0e		 mov	 DWORD PTR [esi], ecx
$LN30@shared_ptr:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 581  : 		}

  0002f	8b c2		 mov	 eax, edx
  00031	5e		 pop	 esi
  00032	5d		 pop	 ebp
  00033	c2 04 00	 ret	 4
??0?$shared_ptr@VChunkBase@@@std@@QAE@$$QAV01@@Z ENDP	; std::shared_ptr<ChunkBase>::shared_ptr<ChunkBase>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ??0?$_Ptr_base@VChunkBase@@@std@@QAE@$$QAV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$_Ptr_base@VChunkBase@@@std@@QAE@$$QAV01@@Z PROC	; std::_Ptr_base<ChunkBase>::_Ptr_base<ChunkBase>, COMDAT
; _this$ = ecx

; 287  : 		{	// construct _Ptr_base object that takes resource from _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b d1		 mov	 edx, ecx
  00005	56		 push	 esi

; 290  : 
; 291  : 	template<class _Ty2>
; 292  : 		_Ptr_base(_Ptr_base<_Ty2>&& _Right)
; 293  : 		: _Ptr(_Right._Ptr), _Rep(_Right._Rep)
; 294  : 		{	// construct _Ptr_base object that takes resource from _Right
; 295  : 		_Right._Ptr = 0;
; 296  : 		_Right._Rep = 0;
; 297  : 		}
; 298  : 
; 299  : 	_Myt& operator=(_Myt&& _Right)
; 300  : 		{	// construct _Ptr_base object that takes resource from _Right
; 301  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 302  : 		return (*this);
; 303  : 		}
; 304  : 
; 305  : 	void _Assign_rv(_Myt&& _Right)
; 306  : 		{	// assign by moving _Right
; 307  : 		if (this != &_Right)

  00006	8b 75 08	 mov	 esi, DWORD PTR __Right$[ebp]

; 287  : 		{	// construct _Ptr_base object that takes resource from _Right

  00009	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0
  0000f	c7 42 04 00 00
	00 00		 mov	 DWORD PTR [edx+4], 0

; 290  : 
; 291  : 	template<class _Ty2>
; 292  : 		_Ptr_base(_Ptr_base<_Ty2>&& _Right)
; 293  : 		: _Ptr(_Right._Ptr), _Rep(_Right._Rep)
; 294  : 		{	// construct _Ptr_base object that takes resource from _Right
; 295  : 		_Right._Ptr = 0;
; 296  : 		_Right._Rep = 0;
; 297  : 		}
; 298  : 
; 299  : 	_Myt& operator=(_Myt&& _Right)
; 300  : 		{	// construct _Ptr_base object that takes resource from _Right
; 301  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 302  : 		return (*this);
; 303  : 		}
; 304  : 
; 305  : 	void _Assign_rv(_Myt&& _Right)
; 306  : 		{	// assign by moving _Right
; 307  : 		if (this != &_Right)

  00016	3b d6		 cmp	 edx, esi
  00018	74 15		 je	 SHORT $LN26@Ptr_base
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility

; 48   : 	_Left = _Move(_Right);

  0001a	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0001d	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 49   : 	_Right = _Move(_Tmp);

  00020	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 48   : 	_Left = _Move(_Right);

  00027	8b 06		 mov	 eax, DWORD PTR [esi]
  00029	8b 0a		 mov	 ecx, DWORD PTR [edx]
  0002b	89 02		 mov	 DWORD PTR [edx], eax

; 49   : 	_Right = _Move(_Tmp);

  0002d	89 0e		 mov	 DWORD PTR [esi], ecx
$LN26@Ptr_base:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 289  : 		}

  0002f	8b c2		 mov	 eax, edx
  00031	5e		 pop	 esi
  00032	5d		 pop	 ebp
  00033	c2 04 00	 ret	 4
??0?$_Ptr_base@VChunkBase@@@std@@QAE@$$QAV01@@Z ENDP	; std::_Ptr_base<ChunkBase>::_Ptr_base<ChunkBase>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ?_Assign_rv@?$_Ptr_base@VChunkBase@@@std@@QAEX$$QAV12@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
?_Assign_rv@?$_Ptr_base@VChunkBase@@@std@@QAEX$$QAV12@@Z PROC ; std::_Ptr_base<ChunkBase>::_Assign_rv, COMDAT
; _this$ = ecx

; 306  : 		{	// assign by moving _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi

; 307  : 		if (this != &_Right)

  00005	8b 7d 08	 mov	 edi, DWORD PTR __Right$[ebp]
  00008	8b f1		 mov	 esi, ecx
  0000a	3b f7		 cmp	 esi, edi
  0000c	74 14		 je	 SHORT $LN14@Assign_rv
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility

; 48   : 	_Left = _Move(_Right);

  0000e	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00011	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  00014	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 49   : 	_Right = _Move(_Tmp);

  00017	89 57 04	 mov	 DWORD PTR [edi+4], edx

; 48   : 	_Left = _Move(_Right);

  0001a	8b 07		 mov	 eax, DWORD PTR [edi]
  0001c	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0001e	89 06		 mov	 DWORD PTR [esi], eax

; 49   : 	_Right = _Move(_Tmp);

  00020	89 0f		 mov	 DWORD PTR [edi], ecx
$LN14@Assign_rv:
  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 309  : 		}

  00024	5d		 pop	 ebp
  00025	c2 04 00	 ret	 4
?_Assign_rv@?$_Ptr_base@VChunkBase@@@std@@QAEX$$QAV12@@Z ENDP ; std::_Ptr_base<ChunkBase>::_Assign_rv
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xatomic0.h
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ??$_Resetp@VEmptyChunk@@@?$shared_ptr@VChunkBase@@@std@@AAEXPAVEmptyChunk@@@Z
_TEXT	SEGMENT
_this$1$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Px$ = 8						; size = 4
??$_Resetp@VEmptyChunk@@@?$shared_ptr@VChunkBase@@@std@@AAEXPAVEmptyChunk@@@Z PROC ; std::shared_ptr<ChunkBase>::_Resetp<EmptyChunk>, COMDAT
; _this$ = ecx

; 708  : 		void _Resetp(_Ux *_Px)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Resetp@VEmptyChunk@@@?$shared_ptr@VChunkBase@@@std@@AAEXPAVEmptyChunk@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002b	8b f9		 mov	 edi, ecx
  0002d	89 7d ec	 mov	 DWORD PTR _this$1$[ebp], edi

; 709  : 		{	// release, take ownership of _Px
; 710  : 		_TRY_BEGIN	// allocate control block and reset
; 711  : 		_Resetp0(_Px, new _Ref_count<_Ux>(_Px));

  00030	6a 10		 push	 16			; 00000010H
  00032	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  00039	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new

; 155  : 		{	// construct

  0003e	8b 5d 08	 mov	 ebx, DWORD PTR __Px$[ebp]

; 709  : 		{	// release, take ownership of _Px
; 710  : 		_TRY_BEGIN	// allocate control block and reset
; 711  : 		_Resetp0(_Px, new _Ref_count<_Ux>(_Px));

  00041	8b f0		 mov	 esi, eax
  00043	83 c4 04	 add	 esp, 4
  00046	85 f6		 test	 esi, esi
  00048	74 19		 je	 SHORT $LN4@Resetp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xatomic0.h

; 219  : 	_Counter = _Value;

  0004a	c7 46 04 01 00
	00 00		 mov	 DWORD PTR [esi+4], 1
  00051	c7 46 08 01 00
	00 00		 mov	 DWORD PTR [esi+8], 1
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 155  : 		{	// construct

  00058	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$_Ref_count@VEmptyChunk@@@std@@6B@
  0005e	89 5e 0c	 mov	 DWORD PTR [esi+12], ebx

; 709  : 		{	// release, take ownership of _Px
; 710  : 		_TRY_BEGIN	// allocate control block and reset
; 711  : 		_Resetp0(_Px, new _Ref_count<_Ux>(_Px));

  00061	eb 02		 jmp	 SHORT $LN5@Resetp
$LN4@Resetp:
  00063	33 f6		 xor	 esi, esi
$LN5@Resetp:

; 156  : 		}
; 157  : 
; 158  : private:
; 159  : 	virtual void _Destroy()
; 160  : 		{	// destroy managed resource
; 161  : 		delete _Ptr;
; 162  : 		}
; 163  : 
; 164  : 	virtual void _Delete_this()
; 165  : 		{	// destroy self
; 166  : 		delete this;
; 167  : 		}
; 168  : 
; 169  : 	_Ty * _Ptr;
; 170  : 	};
; 171  : 
; 172  : 	// TEMPLATE CLASS _Ref_count_del
; 173  : template<class _Ty,
; 174  : 	class _Dx>
; 175  : 	class _Ref_count_del
; 176  : 	: public _Ref_count_base
; 177  : 	{	// handle reference counting for object with deleter
; 178  : public:
; 179  : 	_Ref_count_del(_Ty *_Px, _Dx _Dt)
; 180  : 		: _Ref_count_base(), _Ptr(_Px), _Dtor(_Dt)
; 181  : 		{	// construct
; 182  : 		}
; 183  : 
; 184  : 	virtual void *_Get_deleter(const _XSTD2 type_info& _Typeid) const
; 185  : 		{	// return address of deleter object
; 186  : 		return ((void *)(_Typeid == typeid(_Dx) ? &_Dtor : 0));
; 187  : 		}
; 188  : 
; 189  : private:
; 190  : 	virtual void _Destroy()
; 191  : 		{	// destroy managed resource
; 192  : 		_Dtor(_Ptr);
; 193  : 		}
; 194  : 
; 195  : 	virtual void _Delete_this()
; 196  : 		{	// destroy self
; 197  : 		delete this;
; 198  : 		}
; 199  : 
; 200  : 	_Ty * _Ptr;
; 201  : 	_Dx _Dtor;	// the stored destructor for the controlled object
; 202  : 	};
; 203  : 
; 204  : 	// TEMPLATE CLASS _Ref_count_del_alloc
; 205  : template<class _Ty,
; 206  : 	class _Dx,
; 207  : 	class _Alloc>
; 208  : 	class _Ref_count_del_alloc
; 209  : 	: public _Ref_count_base
; 210  : 	{	// handle reference counting for object with deleter and allocator
; 211  : public:
; 212  : 	typedef _Ref_count_del_alloc<_Ty, _Dx, _Alloc> _Myty;
; 213  : 	typedef typename _Alloc::template rebind<_Myty>::other _Myalty;
; 214  : 
; 215  : 	_Ref_count_del_alloc(_Ty *_Px, _Dx _Dt, _Myalty _Al)
; 216  : 		: _Ref_count_base(), _Ptr(_Px), _Dtor(_Dt), _Myal(_Al)
; 217  : 		{	// construct
; 218  : 		}
; 219  : 
; 220  : 	virtual void *_Get_deleter(const _XSTD2 type_info& _Typeid) const
; 221  : 		{	// return address of deleter object
; 222  : 		return ((void *)(_Typeid == typeid(_Dx) ? &_Dtor : 0));
; 223  : 		}
; 224  : 
; 225  : private:
; 226  : 	virtual void _Destroy()
; 227  : 		{	// destroy managed resource
; 228  : 		_Dtor(_Ptr);
; 229  : 		}
; 230  : 
; 231  : 	virtual void _Delete_this()
; 232  : 		{	// destroy self
; 233  : 		_Myalty _Al = _Myal;
; 234  : 		_Al.destroy(this);
; 235  : 		_Al.deallocate(this, 1);
; 236  : 		}
; 237  : 
; 238  : 	_Ty * _Ptr;
; 239  : 	_Dx _Dtor;	// the stored destructor for the controlled object
; 240  : 	_Myalty _Myal;	// the stored allocator for this
; 241  : 	};
; 242  : 
; 243  : 	// DECLARATIONS
; 244  : template<class _Ty>
; 245  : 	class weak_ptr;
; 246  : template<class _Ty>
; 247  : 	class shared_ptr;
; 248  : template<class _Ty>
; 249  : 	class enable_shared_from_this;
; 250  : struct _Static_tag {};
; 251  : struct _Const_tag {};
; 252  : struct _Dynamic_tag {};
; 253  : template<class _Ty1,
; 254  : 	class _Ty2>
; 255  : 	void _Do_enable(_Ty1 *, enable_shared_from_this<_Ty2> *,
; 256  : 		_Ref_count_base *);
; 257  : 
; 258  : template<class _Ty>
; 259  : 	inline void _Enable_shared(_Ty *_Ptr, _Ref_count_base *_Refptr,
; 260  : 		typename _Ty::_EStype * = 0)
; 261  : 	{	// reset internal weak pointer
; 262  : 	if (_Ptr)
; 263  : 		_Do_enable(_Ptr,
; 264  : 			(enable_shared_from_this<typename _Ty::_EStype>*)_Ptr, _Refptr);
; 265  : 	}
; 266  : 
; 267  : inline void _Enable_shared(const volatile void *, const volatile void *)
; 268  : 	{	// not derived from enable_shared_from_this; do nothing
; 269  : 	}
; 270  : 
; 271  : 	// TEMPLATE CLASS _Ptr_base
; 272  : template<class _Ty>
; 273  : 	class _Ptr_base
; 274  : 	{	// base class for shared_ptr and weak_ptr
; 275  : public:
; 276  : 	typedef _Ptr_base<_Ty> _Myt;
; 277  : 	typedef _Ty _Elem;
; 278  : 	typedef _Elem element_type;
; 279  : 
; 280  : 	_Ptr_base()
; 281  : 		: _Ptr(0), _Rep(0)
; 282  : 		{	// construct
; 283  : 		}
; 284  : 
; 285  : 	_Ptr_base(_Myt&& _Right)
; 286  : 		: _Ptr(0), _Rep(0)
; 287  : 		{	// construct _Ptr_base object that takes resource from _Right
; 288  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 289  : 		}
; 290  : 
; 291  : 	template<class _Ty2>
; 292  : 		_Ptr_base(_Ptr_base<_Ty2>&& _Right)
; 293  : 		: _Ptr(_Right._Ptr), _Rep(_Right._Rep)
; 294  : 		{	// construct _Ptr_base object that takes resource from _Right
; 295  : 		_Right._Ptr = 0;
; 296  : 		_Right._Rep = 0;
; 297  : 		}
; 298  : 
; 299  : 	_Myt& operator=(_Myt&& _Right)
; 300  : 		{	// construct _Ptr_base object that takes resource from _Right
; 301  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 302  : 		return (*this);
; 303  : 		}
; 304  : 
; 305  : 	void _Assign_rv(_Myt&& _Right)
; 306  : 		{	// assign by moving _Right
; 307  : 		if (this != &_Right)
; 308  : 			_Swap(_Right);
; 309  : 		}
; 310  : 
; 311  : 	long use_count() const _NOEXCEPT
; 312  : 		{	// return use count
; 313  : 		return (_Rep ? _Rep->_Use_count() : 0);
; 314  : 		}
; 315  : 
; 316  : 	void _Swap(_Ptr_base& _Right)
; 317  : 		{	// swap pointers
; 318  : 		_STD swap(_Rep, _Right._Rep);
; 319  : 		_STD swap(_Ptr, _Right._Ptr);
; 320  : 		}
; 321  : 
; 322  : 	template<class _Ty2>
; 323  : 		bool owner_before(const _Ptr_base<_Ty2>& _Right) const
; 324  : 		{	// compare addresses of manager objects
; 325  : 		return (_Rep < _Right._Rep);
; 326  : 		}
; 327  : 
; 328  : 	void *_Get_deleter(const _XSTD2 type_info& _Typeid) const
; 329  : 		{	// return pointer to deleter object if its type is _Typeid
; 330  : 		return (_Rep ? _Rep->_Get_deleter(_Typeid) : 0);
; 331  : 		}
; 332  : 
; 333  : 	_Ty *_Get() const
; 334  : 		{	// return pointer to resource
; 335  : 		return (_Ptr);
; 336  : 		}
; 337  : 
; 338  : 	bool _Expired() const
; 339  : 		{	// test if expired
; 340  : 		return (!_Rep || _Rep->_Expired());
; 341  : 		}
; 342  : 
; 343  : 	void _Decref()
; 344  : 		{	// decrement reference count
; 345  : 		if (_Rep != 0)
; 346  : 			_Rep->_Decref();
; 347  : 		}
; 348  : 
; 349  : 	void _Reset()
; 350  : 		{	// release resource
; 351  : 		_Reset(0, 0);
; 352  : 		}
; 353  : 
; 354  : 	template<class _Ty2>
; 355  : 		void _Reset(const _Ptr_base<_Ty2>& _Other)
; 356  : 		{	// release resource and take ownership of _Other._Ptr
; 357  : 		_Reset(_Other._Ptr, _Other._Rep);
; 358  : 		}
; 359  : 
; 360  : 	template<class _Ty2>
; 361  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, bool _Throw)
; 362  : 		{	// release resource and take ownership from weak_ptr _Other._Ptr
; 363  : 		_Reset(_Other._Ptr, _Other._Rep, _Throw);
; 364  : 		}
; 365  : 
; 366  : 	template<class _Ty2>
; 367  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Static_tag&)
; 368  : 		{	// release resource and take ownership of _Other._Ptr
; 369  : 		_Reset(static_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 370  : 		}
; 371  : 
; 372  : 	template<class _Ty2>
; 373  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Const_tag&)
; 374  : 		{	// release resource and take ownership of _Other._Ptr
; 375  : 		_Reset(const_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 376  : 		}
; 377  : 
; 378  : 	template<class _Ty2>
; 379  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Dynamic_tag&)
; 380  : 		{	// release resource and take ownership of _Other._Ptr
; 381  : 		_Elem *_Ptr = dynamic_cast<_Elem *>(_Other._Ptr);
; 382  : 		if (_Ptr)
; 383  : 			_Reset(_Ptr, _Other._Rep);
; 384  : 		else
; 385  : 			_Reset();
; 386  : 		}
; 387  : 
; 388  : 	template<class _Ty2>
; 389  : 		void _Reset(auto_ptr<_Ty2>&& _Other)
; 390  : 		{	// release resource and take _Other.get()
; 391  : 		_Ty2 *_Px = _Other.get();
; 392  : 		_Reset0(_Px, new _Ref_count<_Elem>(_Px));
; 393  : 		_Other.release();
; 394  : 		_Enable_shared(_Px, _Rep);
; 395  : 		}
; 396  : 
; 397  :  #if _HAS_CPP0X
; 398  : 	template<class _Ty2>
; 399  : 		void _Reset(_Ty *_Ptr, const _Ptr_base<_Ty2>& _Other)
; 400  : 		{	// release resource and alias _Ptr with _Other_rep
; 401  : 		_Reset(_Ptr, _Other._Rep);
; 402  : 		}
; 403  :  #endif /* _HAS_CPP0X */
; 404  : 
; 405  : 	void _Reset(_Ty *_Other_ptr, _Ref_count_base *_Other_rep)
; 406  : 		{	// release resource and take _Other_ptr through _Other_rep
; 407  : 		if (_Other_rep)
; 408  : 			_Other_rep->_Incref();
; 409  : 		_Reset0(_Other_ptr, _Other_rep);
; 410  : 		}
; 411  : 
; 412  : 	void _Reset(_Ty *_Other_ptr, _Ref_count_base *_Other_rep, bool _Throw)
; 413  : 		{	// take _Other_ptr through _Other_rep from weak_ptr if not expired
; 414  : 			// otherwise, leave in default state if !_Throw,
; 415  : 			// otherwise throw exception
; 416  : 		if (_Other_rep && _Other_rep->_Incref_nz())
; 417  : 			_Reset0(_Other_ptr, _Other_rep);
; 418  : 		else if (_Throw)
; 419  : 			_THROW_NCEE(bad_weak_ptr, 0);
; 420  : 		}
; 421  : 
; 422  : 	void _Reset0(_Ty *_Other_ptr, _Ref_count_base *_Other_rep)
; 423  : 		{	// release resource and take new resource
; 424  : 		if (_Rep != 0)

  00065	8b 7f 04	 mov	 edi, DWORD PTR [edi+4]
  00068	85 ff		 test	 edi, edi
  0006a	74 25		 je	 SHORT $LN29@Resetp

; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  0006c	8d 4f 04	 lea	 ecx, DWORD PTR [edi+4]
  0006f	83 c8 ff	 or	 eax, -1
  00072	f0 0f c1 01	 lock	  xadd	 DWORD PTR [ecx], eax
  00076	75 19		 jne	 SHORT $LN29@Resetp

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  00078	8b 07		 mov	 eax, DWORD PTR [edi]
  0007a	8b cf		 mov	 ecx, edi
  0007c	ff 10		 call	 DWORD PTR [eax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  0007e	8d 47 08	 lea	 eax, DWORD PTR [edi+8]
  00081	83 c9 ff	 or	 ecx, -1
  00084	f0 0f c1 08	 lock	  xadd	 DWORD PTR [eax], ecx
  00088	75 07		 jne	 SHORT $LN29@Resetp

; 128  : 			_Delete_this();

  0008a	8b 07		 mov	 eax, DWORD PTR [edi]
  0008c	8b cf		 mov	 ecx, edi
  0008e	ff 50 04	 call	 DWORD PTR [eax+4]
$LN29@Resetp:

; 425  : 			_Rep->_Decref();
; 426  : 		_Rep = _Other_rep;

  00091	8b 45 ec	 mov	 eax, DWORD PTR _this$1$[ebp]
  00094	89 70 04	 mov	 DWORD PTR [eax+4], esi

; 427  : 		_Ptr = _Other_ptr;

  00097	89 18		 mov	 DWORD PTR [eax], ebx

; 715  : 		_CATCH_END
; 716  : 		}

  00099	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  0009c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000a3	59		 pop	 ecx
  000a4	5f		 pop	 edi
  000a5	5e		 pop	 esi
  000a6	5b		 pop	 ebx
  000a7	8b e5		 mov	 esp, ebp
  000a9	5d		 pop	 ebp
  000aa	c2 04 00	 ret	 4
__catch$??$_Resetp@VEmptyChunk@@@?$shared_ptr@VChunkBase@@@std@@AAEXPAVEmptyChunk@@@Z$0:

; 712  : 		_CATCH_ALL	// allocation failed, delete resource
; 713  : 		delete _Px;

  000ad	8b 4d 08	 mov	 ecx, DWORD PTR __Px$[ebp]
  000b0	85 c9		 test	 ecx, ecx
  000b2	74 06		 je	 SHORT $LN6@Resetp
  000b4	51		 push	 ecx
  000b5	e8 00 00 00 00	 call	 ??_GEmptyChunk@@QAEPAXI@Z
$LN6@Resetp:

; 714  : 		_RERAISE;

  000ba	6a 00		 push	 0
  000bc	6a 00		 push	 0
  000be	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN36@Resetp:
$LN35@Resetp:
  000c3	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Resetp@VEmptyChunk@@@?$shared_ptr@VChunkBase@@@std@@AAEXPAVEmptyChunk@@@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Resetp@VEmptyChunk@@@?$shared_ptr@VChunkBase@@@std@@AAEXPAVEmptyChunk@@@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Resetp@VEmptyChunk@@@?$shared_ptr@VChunkBase@@@std@@AAEXPAVEmptyChunk@@@Z ENDP ; std::shared_ptr<ChunkBase>::_Resetp<EmptyChunk>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\type_traits
;	COMDAT ??$forward@ABVChunkPosition@@@std@@YAABVChunkPosition@@ABV1@@Z
_TEXT	SEGMENT
??$forward@ABVChunkPosition@@@std@@YAABVChunkPosition@@ABV1@@Z PROC ; std::forward<ChunkPosition const &>, COMDAT
; __Arg$ = ecx

; 1776 : 	return (static_cast<_Ty&&>(_Arg));

  00000	8b c1		 mov	 eax, ecx

; 1777 : 	}

  00002	c3		 ret	 0
??$forward@ABVChunkPosition@@@std@@YAABVChunkPosition@@ABV1@@Z ENDP ; std::forward<ChunkPosition const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\type_traits
;	COMDAT ??$forward@V?$shared_ptr@VChunkBase@@@std@@@std@@YA$$QAV?$shared_ptr@VChunkBase@@@0@AAV10@@Z
_TEXT	SEGMENT
??$forward@V?$shared_ptr@VChunkBase@@@std@@@std@@YA$$QAV?$shared_ptr@VChunkBase@@@0@AAV10@@Z PROC ; std::forward<std::shared_ptr<ChunkBase> >, COMDAT
; __Arg$ = ecx

; 1776 : 	return (static_cast<_Ty&&>(_Arg));

  00000	8b c1		 mov	 eax, ecx

; 1777 : 	}

  00002	c3		 ret	 0
??$forward@V?$shared_ptr@VChunkBase@@@std@@@std@@YA$$QAV?$shared_ptr@VChunkBase@@@0@AAV10@@Z ENDP ; std::forward<std::shared_ptr<ChunkBase> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\type_traits
;	COMDAT ??$forward@U?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@YA$$QAU?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@0@AAU10@@Z
_TEXT	SEGMENT
??$forward@U?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@YA$$QAU?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@0@AAU10@@Z PROC ; std::forward<std::pair<ChunkPosition,std::shared_ptr<ChunkBase> > >, COMDAT
; __Arg$ = ecx

; 1776 : 	return (static_cast<_Ty&&>(_Arg));

  00000	8b c1		 mov	 eax, ecx

; 1777 : 	}

  00002	c3		 ret	 0
??$forward@U?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@YA$$QAU?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@0@AAU10@@Z ENDP ; std::forward<std::pair<ChunkPosition,std::shared_ptr<ChunkBase> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
;	COMDAT ??$_Buynode@U?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@?$_Tree_buy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@1@$$QAU?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z
_TEXT	SEGMENT
__V0$ = 8						; size = 4
??$_Buynode@U?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@?$_Tree_buy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@1@$$QAU?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z PROC ; std::_Tree_buy<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::_Buynode<std::pair<ChunkPosition,std::shared_ptr<ChunkBase> > >, COMDAT
; _this$ = ecx

; 945  : _VARIADIC_EXPAND_0X(_TREE_BUYNODE, , , , )

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	e8 00 00 00 00	 call	 ?_Buynode0@?$_Tree_buy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@2@XZ ; std::_Tree_buy<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::_Buynode0
  00009	8b d0		 mov	 edx, eax

; 608  : 		return ((reference)_Pnode->_Myval);

  0000b	8d 72 10	 lea	 esi, DWORD PTR [edx+16]

; 945  : _VARIADIC_EXPAND_0X(_TREE_BUYNODE, , , , )

  0000e	66 c7 42 0c 00
	00		 mov	 WORD PTR [edx+12], 0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 617  : _VARIADIC_EXPAND_0X(_ALLOC_MEMBER_CONSTRUCT, , , , )

  00014	85 f6		 test	 esi, esi
  00016	74 42		 je	 SHORT $LN63@Buynode
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility

; 182  : 		{	// construct from moved compatible pair

  00018	8b 4d 08	 mov	 ecx, DWORD PTR __V0$[ebp]
  0001b	83 c6 0c	 add	 esi, 12			; 0000000cH
  0001e	f3 0f 7e 01	 movq	 xmm0, QWORD PTR [ecx]
  00022	66 0f d6 46 f4	 movq	 QWORD PTR [esi-12], xmm0
  00027	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  0002a	89 46 fc	 mov	 DWORD PTR [esi-4], eax
  0002d	57		 push	 edi
  0002e	8d 79 0c	 lea	 edi, DWORD PTR [ecx+12]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 287  : 		{	// construct _Ptr_base object that takes resource from _Right

  00031	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  00037	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 288  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 289  : 		}
; 290  : 
; 291  : 	template<class _Ty2>
; 292  : 		_Ptr_base(_Ptr_base<_Ty2>&& _Right)
; 293  : 		: _Ptr(_Right._Ptr), _Rep(_Right._Rep)
; 294  : 		{	// construct _Ptr_base object that takes resource from _Right
; 295  : 		_Right._Ptr = 0;
; 296  : 		_Right._Rep = 0;
; 297  : 		}
; 298  : 
; 299  : 	_Myt& operator=(_Myt&& _Right)
; 300  : 		{	// construct _Ptr_base object that takes resource from _Right
; 301  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 302  : 		return (*this);
; 303  : 		}
; 304  : 
; 305  : 	void _Assign_rv(_Myt&& _Right)
; 306  : 		{	// assign by moving _Right
; 307  : 		if (this != &_Right)

  0003e	3b f7		 cmp	 esi, edi
  00040	74 15		 je	 SHORT $LN97@Buynode
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility

; 48   : 	_Left = _Move(_Right);

  00042	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00045	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 49   : 	_Right = _Move(_Tmp);

  00048	c7 47 04 00 00
	00 00		 mov	 DWORD PTR [edi+4], 0

; 48   : 	_Left = _Move(_Right);

  0004f	8b 07		 mov	 eax, DWORD PTR [edi]
  00051	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00053	89 06		 mov	 DWORD PTR [esi], eax

; 49   : 	_Right = _Move(_Tmp);

  00055	89 0f		 mov	 DWORD PTR [edi], ecx
$LN97@Buynode:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree

; 945  : _VARIADIC_EXPAND_0X(_TREE_BUYNODE, , , , )

  00057	8b c2		 mov	 eax, edx
  00059	5f		 pop	 edi
$LN63@Buynode:
  0005a	5e		 pop	 esi
  0005b	5d		 pop	 ebp
  0005c	c2 04 00	 ret	 4
??$_Buynode@U?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@?$_Tree_buy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@1@$$QAU?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z ENDP ; std::_Tree_buy<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::_Buynode<std::pair<ChunkPosition,std::shared_ptr<ChunkBase> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\map
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\map
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\map
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\map
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\map
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
;	COMDAT ??$_Insert_hint@AAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@AAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@PAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@1@@Z
_TEXT	SEGMENT
_this$1$ = -28						; size = 4
$T2 = -24						; size = 8
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Val$ = 16						; size = 4
__Newnode$ = 20						; size = 4
??$_Insert_hint@AAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@AAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@PAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@1@@Z PROC ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Insert_hint<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > &,std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void *> *>, COMDAT
; _this$ = ecx

; 1664 : 		iterator _Insert_hint(const_iterator _Where,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Insert_hint@AAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@AAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@PAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 14	 sub	 esp, 20			; 00000014H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002b	8b d9		 mov	 ebx, ecx
  0002d	89 5d e4	 mov	 DWORD PTR _this$1$[ebp], ebx

; 1665 : 			_Valty&& _Val, _Nodety _Newnode)
; 1666 : 		{	// try to insert node using _Where as a hint
; 1667 : 		const_iterator _Next;
; 1668 : 		bool _Leftish = false;	// assume nearest point is end of sequence
; 1669 : 
; 1670 : 		_TRY_BEGIN

  00030	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 1671 : 
; 1672 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1673 : 		if (_Where._Getcont() != this)
; 1674 : 			_DEBUG_ERROR("map/set insert iterator outside range");
; 1675 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1676 : 
; 1677 : 		if (size() == 0)

  00037	83 7b 04 00	 cmp	 DWORD PTR [ebx+4], 0
  0003b	75 27		 jne	 SHORT $LN33@Insert_hin

; 1678 : 			return (_Insert_at(true, this->_Myhead,
; 1679 : 				_STD forward<_Valty>(_Val), _Newnode));	// empty tree

  0003d	ff 75 14	 push	 DWORD PTR __Newnode$[ebp]
  00040	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]
  00043	51		 push	 ecx
  00044	ff 33		 push	 DWORD PTR [ebx]
  00046	6a 01		 push	 1
  00048	56		 push	 esi
  00049	e8 00 00 00 00	 call	 ??$_Insert_at@AAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@_NPAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@1@AAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@1@Z ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Insert_at<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > &,std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void *> *>
  0004e	8b c6		 mov	 eax, esi

; 1776 : 		}

  00050	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00053	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0005a	59		 pop	 ecx
  0005b	5f		 pop	 edi
  0005c	5e		 pop	 esi
  0005d	5b		 pop	 ebx
  0005e	8b e5		 mov	 esp, ebp
  00060	5d		 pop	 ebp
  00061	c2 10 00	 ret	 16			; 00000010H
$LN33@Insert_hin:

; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  :  #if _HAS_CPP0X
; 520  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 521  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 522  : 
; 523  :  #else /* _HAS_CPP0X */
; 524  : 	typedef typename _Alloc::template rebind<_Ty>::other _Alty;
; 525  :  #endif /* _HAS_CPP0X */
; 526  : 
; 527  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 528  : 		_Voidptr;
; 529  : 	typedef _Tree_node<typename _Alty::value_type,
; 530  : 		_Voidptr> _Node;
; 531  : 
; 532  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 533  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 534  : 	typedef _Nodeptr& _Nodepref;
; 535  : 
; 536  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 537  : 		_Tree_simple_types<typename _Alty::value_type>,
; 538  : 		_Tree_iter_types<typename _Alty::value_type,
; 539  : 			typename _Alty::size_type,
; 540  : 			typename _Alty::difference_type,
; 541  : 			typename _Alty::pointer,
; 542  : 			typename _Alty::const_pointer,
; 543  : 			typename _Alty::reference,
; 544  : 			typename _Alty::const_reference,
; 545  : 			_Nodeptr> >::type
; 546  : 		_Val_types;
; 547  : 	};
; 548  : 
; 549  : 		// TEMPLATE CLASS _Tree_val
; 550  : template<class _Val_types>
; 551  : 	class _Tree_val
; 552  : 		: public _Container_base
; 553  : 	{	// base class for tree to hold data
; 554  : public:
; 555  : 	typedef _Tree_val<_Val_types> _Myt;
; 556  : 
; 557  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 558  : 	typedef _Nodeptr& _Nodepref;
; 559  : 
; 560  : 	typedef typename _Val_types::value_type value_type;
; 561  : 	typedef typename _Val_types::size_type size_type;
; 562  : 	typedef typename _Val_types::difference_type difference_type;
; 563  : 	typedef typename _Val_types::pointer pointer;
; 564  : 	typedef typename _Val_types::const_pointer const_pointer;
; 565  : 	typedef typename _Val_types::reference reference;
; 566  : 	typedef typename _Val_types::const_reference const_reference;
; 567  : 
; 568  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 569  : 	typedef _Tree_iterator<_Myt> iterator;
; 570  : 
; 571  : 	_Tree_val()
; 572  : 		{	// initialize data
; 573  : 		this->_Myhead = 0;
; 574  : 		this->_Mysize = 0;
; 575  : 		}
; 576  : 
; 577  : 	enum _Redbl
; 578  : 		{	// colors for link to parent
; 579  : 		_Red, _Black};
; 580  : 
; 581  : 	static char& _Color(_Nodeptr _Pnode)
; 582  : 		{	// return reference to color in node
; 583  : 		return ((char&)_Pnode->_Color);
; 584  : 		}
; 585  : 
; 586  : 	static char& _Isnil(_Nodeptr _Pnode)
; 587  : 		{	// return reference to nil flag in node
; 588  : 		return ((char&)_Pnode->_Isnil);
; 589  : 		}
; 590  : 
; 591  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 592  : 		{	// return reference to left pointer in node
; 593  : 		return ((_Nodepref)_Pnode->_Left);

  00064	8b 3b		 mov	 edi, DWORD PTR [ebx]

; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);

  00066	8b 75 0c	 mov	 esi, DWORD PTR __Where$[ebp]
  00069	3b 37		 cmp	 esi, DWORD PTR [edi]

; 1680 : 		else if (this->_Multi)
; 1681 : 			{	// insert even if duplicate
; 1682 : 			if (_Where == begin())
; 1683 : 				{	// insert at beginning if before first element
; 1684 : 				if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1685 : 					this->_Key(_Where._Mynode()), this->_Kfn(_Val)))
; 1686 : 					return (_Insert_at(true, _Where._Mynode(),
; 1687 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1688 : 				_Leftish = true;	// nearest point is beginning of sequence
; 1689 : 				}
; 1690 : 			else if (_Where == end())
; 1691 : 				{	// insert at end if after last element
; 1692 : 				if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1693 : 					this->_Kfn(_Val), this->_Key(_Rmost())))
; 1694 : 					return (_Insert_at(false, _Rmost(),
; 1695 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1696 : 				}
; 1697 : 			else if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1698 : 				this->_Key(_Where._Mynode()), this->_Kfn(_Val))
; 1699 : 				&& !_DEBUG_LT_PRED(this->_Getcomp(),
; 1700 : 					this->_Kfn(_Val),
; 1701 : 					this->_Key((--(_Next = _Where))._Mynode())))
; 1702 : 				{	// insert before _Where
; 1703 : 				if (this->_Isnil(this->_Right(_Next._Mynode())))
; 1704 : 					return (_Insert_at(false, _Next._Mynode(),
; 1705 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1706 : 				else
; 1707 : 					return (_Insert_at(true, _Where._Mynode(),
; 1708 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1709 : 				}
; 1710 : 			else if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1711 : 				this->_Kfn(_Val), this->_Key(_Where._Mynode()))
; 1712 : 				&& (++(_Next = _Where) == end()
; 1713 : 					|| !_DEBUG_LT_PRED(this->_Getcomp(),
; 1714 : 						this->_Key(_Next._Mynode()), this->_Kfn(_Val))))
; 1715 : 				{	// insert after _Where
; 1716 : 				if (this->_Isnil(this->_Right(_Where._Mynode())))
; 1717 : 					return (_Insert_at(false, _Where._Mynode(),
; 1718 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1719 : 				else
; 1720 : 					return (_Insert_at(true, _Next._Mynode(),
; 1721 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1722 : 				}
; 1723 : 			else
; 1724 : 				_Leftish = true;	// nearest point is beginning of sequence
; 1725 : 			}
; 1726 : 		else
; 1727 : 			{	// insert only if unique
; 1728 : 			if (_Where == begin())

  0006b	75 5b		 jne	 SHORT $LN14@Insert_hin
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp

; 296  : 	if(cp1.x < cp2.x)

  0006d	8b 7d 10	 mov	 edi, DWORD PTR __Val$[ebp]
  00070	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  00073	8b 07		 mov	 eax, DWORD PTR [edi]
  00075	3b c1		 cmp	 eax, ecx
  00077	7c 27		 jl	 SHORT $LN431@Insert_hin

; 297  : 	{
; 298  : 		return true;
; 299  : 	}
; 300  : 	else if(cp1.x == cp2.x)

  00079	0f 85 ac 01 00
	00		 jne	 $LN1@Insert_hin

; 301  : 	{
; 302  : 		if(cp1.y < cp2.y)

  0007f	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00082	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  00085	3b c1		 cmp	 eax, ecx
  00087	7c 17		 jl	 SHORT $LN431@Insert_hin

; 303  : 		{
; 304  : 			return true;
; 305  : 		}
; 306  : 		else if(cp1.y == cp2.y)

  00089	0f 85 9c 01 00
	00		 jne	 $LN1@Insert_hin

; 307  : 		{
; 308  : 			return cp1.z < cp2.z;

  0008f	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  00092	3b 46 18	 cmp	 eax, DWORD PTR [esi+24]
  00095	0f 9c c0	 setl	 al
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree

; 1730 : 				if (_DEBUG_LT_PRED(this->_Getcomp(),

  00098	84 c0		 test	 al, al
  0009a	0f 84 8b 01 00
	00		 je	 $LN1@Insert_hin
$LN431@Insert_hin:

; 1731 : 					this->_Kfn(_Val), this->_Key(_Where._Mynode())))
; 1732 : 					return (_Insert_at(true, _Where._Mynode(),
; 1733 : 						_STD forward<_Valty>(_Val), _Newnode));

  000a0	ff 75 14	 push	 DWORD PTR __Newnode$[ebp]
  000a3	51		 push	 ecx
  000a4	56		 push	 esi
  000a5	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]
  000a8	6a 01		 push	 1
  000aa	56		 push	 esi
  000ab	8b cb		 mov	 ecx, ebx
  000ad	e8 00 00 00 00	 call	 ??$_Insert_at@AAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@_NPAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@1@AAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@1@Z ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Insert_at<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > &,std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void *> *>
  000b2	8b c6		 mov	 eax, esi

; 1776 : 		}

  000b4	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  000b7	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000be	59		 pop	 ecx
  000bf	5f		 pop	 edi
  000c0	5e		 pop	 esi
  000c1	5b		 pop	 ebx
  000c2	8b e5		 mov	 esp, ebp
  000c4	5d		 pop	 ebp
  000c5	c2 10 00	 ret	 16			; 00000010H
$LN14@Insert_hin:

; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);

  000c8	3b f7		 cmp	 esi, edi

; 1734 : 				}
; 1735 : 			else if (_Where == end())

  000ca	75 40		 jne	 SHORT $LN11@Insert_hin
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\map

; 56   : 		return (_Val.first);

  000cc	8b 77 08	 mov	 esi, DWORD PTR [edi+8]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree

; 1737 : 				if (_DEBUG_LT_PRED(this->_Getcomp(),

  000cf	8b 7d 10	 mov	 edi, DWORD PTR __Val$[ebp]
  000d2	57		 push	 edi
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\map

; 56   : 		return (_Val.first);

  000d3	8d 46 10	 lea	 eax, DWORD PTR [esi+16]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree

; 1737 : 				if (_DEBUG_LT_PRED(this->_Getcomp(),

  000d6	50		 push	 eax
  000d7	e8 00 00 00 00	 call	 ??R?$less@VChunkPosition@@@std@@QBE_NABVChunkPosition@@0@Z ; std::less<ChunkPosition>::operator()
  000dc	84 c0		 test	 al, al
  000de	0f 84 47 01 00
	00		 je	 $LN1@Insert_hin

; 1738 : 					this->_Key(_Rmost()), this->_Kfn(_Val)))
; 1739 : 					return (_Insert_at(false, _Rmost(),
; 1740 : 						_STD forward<_Valty>(_Val), _Newnode));

  000e4	ff 75 14	 push	 DWORD PTR __Newnode$[ebp]
  000e7	51		 push	 ecx
  000e8	56		 push	 esi
  000e9	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]
  000ec	6a 00		 push	 0
  000ee	56		 push	 esi
  000ef	8b cb		 mov	 ecx, ebx
  000f1	e8 00 00 00 00	 call	 ??$_Insert_at@AAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@_NPAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@1@AAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@1@Z ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Insert_at<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > &,std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void *> *>
  000f6	8b c6		 mov	 eax, esi

; 1776 : 		}

  000f8	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  000fb	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00102	59		 pop	 ecx
  00103	5f		 pop	 edi
  00104	5e		 pop	 esi
  00105	5b		 pop	 ebx
  00106	8b e5		 mov	 esp, ebp
  00108	5d		 pop	 ebp
  00109	c2 10 00	 ret	 16			; 00000010H
$LN11@Insert_hin:

; 1744 : 				&& _DEBUG_LT_PRED(this->_Getcomp(),

  0010c	8b 5d 10	 mov	 ebx, DWORD PTR __Val$[ebp]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\map

; 56   : 		return (_Val.first);

  0010f	8d 46 10	 lea	 eax, DWORD PTR [esi+16]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree

; 1744 : 				&& _DEBUG_LT_PRED(this->_Getcomp(),

  00112	50		 push	 eax
  00113	53		 push	 ebx
  00114	e8 00 00 00 00	 call	 ??R?$less@VChunkPosition@@@std@@QBE_NABVChunkPosition@@0@Z ; std::less<ChunkPosition>::operator()
  00119	84 c0		 test	 al, al
  0011b	74 70		 je	 SHORT $LN8@Insert_hin

; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);

  0011d	8d 4d ec	 lea	 ecx, DWORD PTR __Next$[ebp]

; 1744 : 				&& _DEBUG_LT_PRED(this->_Getcomp(),

  00120	89 75 ec	 mov	 DWORD PTR __Next$[ebp], esi

; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);

  00123	e8 00 00 00 00	 call	 ??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >,std::_Iterator_base0>::operator--

; 1744 : 				&& _DEBUG_LT_PRED(this->_Getcomp(),

  00128	53		 push	 ebx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\map

; 56   : 		return (_Val.first);

  00129	8b 5d ec	 mov	 ebx, DWORD PTR __Next$[ebp]
  0012c	8d 43 10	 lea	 eax, DWORD PTR [ebx+16]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree

; 1744 : 				&& _DEBUG_LT_PRED(this->_Getcomp(),

  0012f	50		 push	 eax
  00130	e8 00 00 00 00	 call	 ??R?$less@VChunkPosition@@@std@@QBE_NABVChunkPosition@@0@Z ; std::less<ChunkPosition>::operator()
  00135	84 c0		 test	 al, al
  00137	74 54		 je	 SHORT $LN8@Insert_hin

; 1745 : 					this->_Key((--(_Next = _Where))._Mynode()),
; 1746 : 					this->_Kfn(_Val)))
; 1747 : 				{	// insert before _Where
; 1748 : 				if (this->_Isnil(this->_Right(_Next._Mynode())))

  00139	8b 43 08	 mov	 eax, DWORD PTR [ebx+8]

; 1749 : 					return (_Insert_at(false, _Next._Mynode(),
; 1750 : 						_STD forward<_Valty>(_Val), _Newnode));

  0013c	ff 75 14	 push	 DWORD PTR __Newnode$[ebp]
  0013f	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00143	51		 push	 ecx
  00144	8b 4d e4	 mov	 ecx, DWORD PTR _this$1$[ebp]
  00147	74 22		 je	 SHORT $LN7@Insert_hin
  00149	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]
  0014c	53		 push	 ebx
  0014d	6a 00		 push	 0
  0014f	56		 push	 esi
  00150	e8 00 00 00 00	 call	 ??$_Insert_at@AAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@_NPAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@1@AAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@1@Z ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Insert_at<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > &,std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void *> *>
  00155	8b c6		 mov	 eax, esi

; 1776 : 		}

  00157	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  0015a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00161	59		 pop	 ecx
  00162	5f		 pop	 edi
  00163	5e		 pop	 esi
  00164	5b		 pop	 ebx
  00165	8b e5		 mov	 esp, ebp
  00167	5d		 pop	 ebp
  00168	c2 10 00	 ret	 16			; 00000010H
$LN7@Insert_hin:

; 1751 : 				else
; 1752 : 					return (_Insert_at(true, _Where._Mynode(),
; 1753 : 						_STD forward<_Valty>(_Val), _Newnode));

  0016b	56		 push	 esi
  0016c	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]
  0016f	6a 01		 push	 1
  00171	56		 push	 esi
  00172	e8 00 00 00 00	 call	 ??$_Insert_at@AAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@_NPAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@1@AAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@1@Z ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Insert_at<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > &,std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void *> *>
  00177	8b c6		 mov	 eax, esi

; 1776 : 		}

  00179	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  0017c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00183	59		 pop	 ecx
  00184	5f		 pop	 edi
  00185	5e		 pop	 esi
  00186	5b		 pop	 ebx
  00187	8b e5		 mov	 esp, ebp
  00189	5d		 pop	 ebp
  0018a	c2 10 00	 ret	 16			; 00000010H
$LN8@Insert_hin:

; 1758 : 					|| _DEBUG_LT_PRED(this->_Getcomp(),

  0018d	ff 75 10	 push	 DWORD PTR __Val$[ebp]
  00190	8d 46 10	 lea	 eax, DWORD PTR [esi+16]
  00193	50		 push	 eax
  00194	e8 00 00 00 00	 call	 ??R?$less@VChunkPosition@@@std@@QBE_NABVChunkPosition@@0@Z ; std::less<ChunkPosition>::operator()
  00199	84 c0		 test	 al, al
  0019b	0f 84 87 00 00
	00		 je	 $LN433@Insert_hin

; 271  : 		++(*(_Mybase *)this);

  001a1	8d 4d ec	 lea	 ecx, DWORD PTR __Next$[ebp]

; 1758 : 					|| _DEBUG_LT_PRED(this->_Getcomp(),

  001a4	89 75 ec	 mov	 DWORD PTR __Next$[ebp], esi

; 271  : 		++(*(_Mybase *)this);

  001a7	e8 00 00 00 00	 call	 ??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >,std::_Iterator_base0>::operator++

; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);

  001ac	8b 5d ec	 mov	 ebx, DWORD PTR __Next$[ebp]
  001af	3b df		 cmp	 ebx, edi

; 1758 : 					|| _DEBUG_LT_PRED(this->_Getcomp(),

  001b1	74 10		 je	 SHORT $LN3@Insert_hin
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\map

; 56   : 		return (_Val.first);

  001b3	8d 43 10	 lea	 eax, DWORD PTR [ebx+16]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree

; 1758 : 					|| _DEBUG_LT_PRED(this->_Getcomp(),

  001b6	50		 push	 eax
  001b7	ff 75 10	 push	 DWORD PTR __Val$[ebp]
  001ba	e8 00 00 00 00	 call	 ??R?$less@VChunkPosition@@@std@@QBE_NABVChunkPosition@@0@Z ; std::less<ChunkPosition>::operator()
  001bf	84 c0		 test	 al, al
  001c1	74 65		 je	 SHORT $LN433@Insert_hin
$LN3@Insert_hin:

; 1759 : 						this->_Kfn(_Val), this->_Key(_Next._Mynode()))))
; 1760 : 				{	// insert after _Where
; 1761 : 				if (this->_Isnil(this->_Right(_Where._Mynode())))

  001c3	8b 46 08	 mov	 eax, DWORD PTR [esi+8]

; 1762 : 					return (_Insert_at(false, _Where._Mynode(),
; 1763 : 						_STD forward<_Valty>(_Val), _Newnode));

  001c6	ff 75 14	 push	 DWORD PTR __Newnode$[ebp]
  001c9	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  001cd	51		 push	 ecx
  001ce	8b 4d e4	 mov	 ecx, DWORD PTR _this$1$[ebp]
  001d1	74 22		 je	 SHORT $LN2@Insert_hin
  001d3	56		 push	 esi
  001d4	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]
  001d7	6a 00		 push	 0
  001d9	56		 push	 esi
  001da	e8 00 00 00 00	 call	 ??$_Insert_at@AAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@_NPAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@1@AAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@1@Z ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Insert_at<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > &,std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void *> *>
  001df	8b c6		 mov	 eax, esi

; 1776 : 		}

  001e1	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  001e4	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  001eb	59		 pop	 ecx
  001ec	5f		 pop	 edi
  001ed	5e		 pop	 esi
  001ee	5b		 pop	 ebx
  001ef	8b e5		 mov	 esp, ebp
  001f1	5d		 pop	 ebp
  001f2	c2 10 00	 ret	 16			; 00000010H
$LN2@Insert_hin:

; 1764 : 				else
; 1765 : 					return (_Insert_at(true, _Next._Mynode(),
; 1766 : 						_STD forward<_Valty>(_Val), _Newnode));

  001f5	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]
  001f8	53		 push	 ebx
  001f9	6a 01		 push	 1
  001fb	56		 push	 esi
  001fc	e8 00 00 00 00	 call	 ??$_Insert_at@AAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@_NPAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@1@AAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@1@Z ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Insert_at<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > &,std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void *> *>
  00201	8b c6		 mov	 eax, esi

; 1776 : 		}

  00203	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00206	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0020d	59		 pop	 ecx
  0020e	5f		 pop	 edi
  0020f	5e		 pop	 esi
  00210	5b		 pop	 ebx
  00211	8b e5		 mov	 esp, ebp
  00213	5d		 pop	 ebp
  00214	c2 10 00	 ret	 16			; 00000010H
__catch$??$_Insert_hint@AAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@AAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@PAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@1@@Z$0:

; 1767 : 				}
; 1768 : 			}
; 1769 : 		_CATCH_ALL
; 1770 : 		_Destroy_if_not_nil(_Newnode);

  00217	ff 75 14	 push	 DWORD PTR __Newnode$[ebp]
  0021a	e8 00 00 00 00	 call	 ?_Destroy_if_not_nil@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Destroy_if_not_nil

; 1771 : 		_RERAISE;

  0021f	6a 00		 push	 0
  00221	6a 00		 push	 0
  00223	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN436@Insert_hin:
$LN433@Insert_hin:
  00228	8b 7d 10	 mov	 edi, DWORD PTR __Val$[ebp]
$LN1@Insert_hin:

; 1772 : 		_CATCH_END
; 1773 : 
; 1774 : 		return (_Insert_nohint(_Leftish,
; 1775 : 			_STD forward<_Valty>(_Val), _Newnode).first);

  0022b	ff 75 14	 push	 DWORD PTR __Newnode$[ebp]
  0022e	8d 45 e8	 lea	 eax, DWORD PTR $T2[ebp]
  00231	57		 push	 edi
  00232	51		 push	 ecx
  00233	8b 4d e4	 mov	 ecx, DWORD PTR _this$1$[ebp]
  00236	50		 push	 eax
  00237	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  0023e	e8 00 00 00 00	 call	 ??$_Insert_nohint@AAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@PAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@1@@Z ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Insert_nohint<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > &,std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void *> *>
  00243	8b 08		 mov	 ecx, DWORD PTR [eax]
  00245	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00248	89 08		 mov	 DWORD PTR [eax], ecx

; 1776 : 		}

  0024a	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  0024d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00254	59		 pop	 ecx
  00255	5f		 pop	 edi
  00256	5e		 pop	 esi
  00257	5b		 pop	 ebx
  00258	8b e5		 mov	 esp, ebp
  0025a	5d		 pop	 ebp
  0025b	c2 10 00	 ret	 16			; 00000010H
$LN435@Insert_hin:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Insert_hint@AAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@AAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@PAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@1@@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a dc	 mov	 ecx, DWORD PTR [edx-36]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Insert_hint@AAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@AAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@PAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@1@@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Insert_hint@AAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@AAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@PAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Insert_hint<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > &,std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void *> *>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\type_traits
;	COMDAT ??$forward@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@YA$$QAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
??$forward@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@YA$$QAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@0@AAV10@@Z PROC ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > >, COMDAT
; __Arg$ = ecx

; 1776 : 	return (static_cast<_Ty&&>(_Arg));

  00000	8b c1		 mov	 eax, ecx

; 1777 : 	}

  00002	c3		 ret	 0
??$forward@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@YA$$QAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@0@AAV10@@Z ENDP ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??$_Iter_cat@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@YA?AUbidirectional_iterator_tag@0@ABV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
??$_Iter_cat@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@YA?AUbidirectional_iterator_tag@0@ABV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@0@@Z PROC ; std::_Iter_cat<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > >, COMDAT
; ___$ReturnUdt$ = ecx
; ___formal$dead$ = edx

; 399  : 	typename iterator_traits<_Iter>::iterator_category _Cat;
; 400  : 	return (_Cat);

  00000	8b c1		 mov	 eax, ecx

; 401  : 	}

  00002	c3		 ret	 0
??$_Iter_cat@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@YA?AUbidirectional_iterator_tag@0@ABV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@0@@Z ENDP ; std::_Iter_cat<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??$_Distance2@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@I@std@@YAXV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@0@0AAIUbidirectional_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 1
??$_Distance2@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@I@std@@YAXV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@0@0AAIUbidirectional_iterator_tag@0@@Z PROC ; std::_Distance2<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,unsigned int>, COMDAT
; __Off$ = ecx

; 797  : 	{	// add to _Off distance between bidirectional iterators (redundant)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree

; 336  : 		return (this->_Ptr == _Right._Ptr);

  00003	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00006	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]
  00009	57		 push	 edi
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility

; 797  : 	{	// add to _Off distance between bidirectional iterators (redundant)

  0000a	8b f9		 mov	 edi, ecx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree

; 336  : 		return (this->_Ptr == _Right._Ptr);

  0000c	3b c2		 cmp	 eax, edx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility

; 798  : 	for (; _First != _Last; ++_First)

  0000e	74 54		 je	 SHORT $LN1@Distance2
  00010	56		 push	 esi
  00011	8b 37		 mov	 esi, DWORD PTR [edi]
$LL12@Distance2:

; 799  : 		++_Off;

  00013	46		 inc	 esi
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree

; 60   : 		if (_Mytree::_Isnil(_Ptr))

  00014	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00018	75 43		 jne	 SHORT $LN51@Distance2

; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  :  #if _HAS_CPP0X
; 520  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 521  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 522  : 
; 523  :  #else /* _HAS_CPP0X */
; 524  : 	typedef typename _Alloc::template rebind<_Ty>::other _Alty;
; 525  :  #endif /* _HAS_CPP0X */
; 526  : 
; 527  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 528  : 		_Voidptr;
; 529  : 	typedef _Tree_node<typename _Alty::value_type,
; 530  : 		_Voidptr> _Node;
; 531  : 
; 532  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 533  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 534  : 	typedef _Nodeptr& _Nodepref;
; 535  : 
; 536  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 537  : 		_Tree_simple_types<typename _Alty::value_type>,
; 538  : 		_Tree_iter_types<typename _Alty::value_type,
; 539  : 			typename _Alty::size_type,
; 540  : 			typename _Alty::difference_type,
; 541  : 			typename _Alty::pointer,
; 542  : 			typename _Alty::const_pointer,
; 543  : 			typename _Alty::reference,
; 544  : 			typename _Alty::const_reference,
; 545  : 			_Nodeptr> >::type
; 546  : 		_Val_types;
; 547  : 	};
; 548  : 
; 549  : 		// TEMPLATE CLASS _Tree_val
; 550  : template<class _Val_types>
; 551  : 	class _Tree_val
; 552  : 		: public _Container_base
; 553  : 	{	// base class for tree to hold data
; 554  : public:
; 555  : 	typedef _Tree_val<_Val_types> _Myt;
; 556  : 
; 557  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 558  : 	typedef _Nodeptr& _Nodepref;
; 559  : 
; 560  : 	typedef typename _Val_types::value_type value_type;
; 561  : 	typedef typename _Val_types::size_type size_type;
; 562  : 	typedef typename _Val_types::difference_type difference_type;
; 563  : 	typedef typename _Val_types::pointer pointer;
; 564  : 	typedef typename _Val_types::const_pointer const_pointer;
; 565  : 	typedef typename _Val_types::reference reference;
; 566  : 	typedef typename _Val_types::const_reference const_reference;
; 567  : 
; 568  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 569  : 	typedef _Tree_iterator<_Myt> iterator;
; 570  : 
; 571  : 	_Tree_val()
; 572  : 		{	// initialize data
; 573  : 		this->_Myhead = 0;
; 574  : 		this->_Mysize = 0;
; 575  : 		}
; 576  : 
; 577  : 	enum _Redbl
; 578  : 		{	// colors for link to parent
; 579  : 		_Red, _Black};
; 580  : 
; 581  : 	static char& _Color(_Nodeptr _Pnode)
; 582  : 		{	// return reference to color in node
; 583  : 		return ((char&)_Pnode->_Color);
; 584  : 		}
; 585  : 
; 586  : 	static char& _Isnil(_Nodeptr _Pnode)
; 587  : 		{	// return reference to nil flag in node
; 588  : 		return ((char&)_Pnode->_Isnil);

  0001a	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]

; 61   : 			;	// end() shouldn't be incremented, don't move
; 62   : 		else if (!_Mytree::_Isnil(_Mytree::_Right(_Ptr)))

  0001d	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  00021	75 19		 jne	 SHORT $LN48@Distance2

; 63   : 			_Ptr = _Mytree::_Min(
; 64   : 				_Mytree::_Right(_Ptr));	// ==> smallest of right subtree

  00023	8b c1		 mov	 eax, ecx

; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  :  #if _HAS_CPP0X
; 520  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 521  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 522  : 
; 523  :  #else /* _HAS_CPP0X */
; 524  : 	typedef typename _Alloc::template rebind<_Ty>::other _Alty;
; 525  :  #endif /* _HAS_CPP0X */
; 526  : 
; 527  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 528  : 		_Voidptr;
; 529  : 	typedef _Tree_node<typename _Alty::value_type,
; 530  : 		_Voidptr> _Node;
; 531  : 
; 532  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 533  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 534  : 	typedef _Nodeptr& _Nodepref;
; 535  : 
; 536  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 537  : 		_Tree_simple_types<typename _Alty::value_type>,
; 538  : 		_Tree_iter_types<typename _Alty::value_type,
; 539  : 			typename _Alty::size_type,
; 540  : 			typename _Alty::difference_type,
; 541  : 			typename _Alty::pointer,
; 542  : 			typename _Alty::const_pointer,
; 543  : 			typename _Alty::reference,
; 544  : 			typename _Alty::const_reference,
; 545  : 			_Nodeptr> >::type
; 546  : 		_Val_types;
; 547  : 	};
; 548  : 
; 549  : 		// TEMPLATE CLASS _Tree_val
; 550  : template<class _Val_types>
; 551  : 	class _Tree_val
; 552  : 		: public _Container_base
; 553  : 	{	// base class for tree to hold data
; 554  : public:
; 555  : 	typedef _Tree_val<_Val_types> _Myt;
; 556  : 
; 557  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 558  : 	typedef _Nodeptr& _Nodepref;
; 559  : 
; 560  : 	typedef typename _Val_types::value_type value_type;
; 561  : 	typedef typename _Val_types::size_type size_type;
; 562  : 	typedef typename _Val_types::difference_type difference_type;
; 563  : 	typedef typename _Val_types::pointer pointer;
; 564  : 	typedef typename _Val_types::const_pointer const_pointer;
; 565  : 	typedef typename _Val_types::reference reference;
; 566  : 	typedef typename _Val_types::const_reference const_reference;
; 567  : 
; 568  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 569  : 	typedef _Tree_iterator<_Myt> iterator;
; 570  : 
; 571  : 	_Tree_val()
; 572  : 		{	// initialize data
; 573  : 		this->_Myhead = 0;
; 574  : 		this->_Mysize = 0;
; 575  : 		}
; 576  : 
; 577  : 	enum _Redbl
; 578  : 		{	// colors for link to parent
; 579  : 		_Red, _Black};
; 580  : 
; 581  : 	static char& _Color(_Nodeptr _Pnode)
; 582  : 		{	// return reference to color in node
; 583  : 		return ((char&)_Pnode->_Color);
; 584  : 		}
; 585  : 
; 586  : 	static char& _Isnil(_Nodeptr _Pnode)
; 587  : 		{	// return reference to nil flag in node
; 588  : 		return ((char&)_Pnode->_Isnil);

  00025	8b 08		 mov	 ecx, DWORD PTR [eax]

; 589  : 		}
; 590  : 
; 591  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 592  : 		{	// return reference to left pointer in node
; 593  : 		return ((_Nodepref)_Pnode->_Left);
; 594  : 		}
; 595  : 
; 596  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 597  : 		{	// return reference to parent pointer in node
; 598  : 		return ((_Nodepref)_Pnode->_Parent);
; 599  : 		}
; 600  : 
; 601  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 602  : 		{	// return reference to right pointer in node
; 603  : 		return ((_Nodepref)_Pnode->_Right);
; 604  : 		}
; 605  : 
; 606  : 	static reference _Myval(_Nodeptr _Pnode)
; 607  : 		{	// return reference to value in node
; 608  : 		return ((reference)_Pnode->_Myval);
; 609  : 		}
; 610  : 
; 611  : 	static _Nodeptr _Max(_Nodeptr _Pnode)
; 612  : 		{	// return rightmost node in subtree at _Pnode
; 613  : 		while (!_Isnil(_Right(_Pnode)))
; 614  : 			_Pnode = _Right(_Pnode);
; 615  : 		return (_Pnode);
; 616  : 		}
; 617  : 
; 618  : 	static _Nodeptr _Min(_Nodeptr _Pnode)
; 619  : 		{	// return leftmost node in subtree at _Pnode
; 620  : 		while (!_Isnil(_Left(_Pnode)))

  00027	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  0002b	75 2d		 jne	 SHORT $LN26@Distance2
  0002d	8d 49 00	 npad	 3
$LL27@Distance2:

; 621  : 			_Pnode = _Left(_Pnode);

  00030	8b c1		 mov	 eax, ecx

; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  :  #if _HAS_CPP0X
; 520  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 521  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 522  : 
; 523  :  #else /* _HAS_CPP0X */
; 524  : 	typedef typename _Alloc::template rebind<_Ty>::other _Alty;
; 525  :  #endif /* _HAS_CPP0X */
; 526  : 
; 527  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 528  : 		_Voidptr;
; 529  : 	typedef _Tree_node<typename _Alty::value_type,
; 530  : 		_Voidptr> _Node;
; 531  : 
; 532  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 533  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 534  : 	typedef _Nodeptr& _Nodepref;
; 535  : 
; 536  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 537  : 		_Tree_simple_types<typename _Alty::value_type>,
; 538  : 		_Tree_iter_types<typename _Alty::value_type,
; 539  : 			typename _Alty::size_type,
; 540  : 			typename _Alty::difference_type,
; 541  : 			typename _Alty::pointer,
; 542  : 			typename _Alty::const_pointer,
; 543  : 			typename _Alty::reference,
; 544  : 			typename _Alty::const_reference,
; 545  : 			_Nodeptr> >::type
; 546  : 		_Val_types;
; 547  : 	};
; 548  : 
; 549  : 		// TEMPLATE CLASS _Tree_val
; 550  : template<class _Val_types>
; 551  : 	class _Tree_val
; 552  : 		: public _Container_base
; 553  : 	{	// base class for tree to hold data
; 554  : public:
; 555  : 	typedef _Tree_val<_Val_types> _Myt;
; 556  : 
; 557  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 558  : 	typedef _Nodeptr& _Nodepref;
; 559  : 
; 560  : 	typedef typename _Val_types::value_type value_type;
; 561  : 	typedef typename _Val_types::size_type size_type;
; 562  : 	typedef typename _Val_types::difference_type difference_type;
; 563  : 	typedef typename _Val_types::pointer pointer;
; 564  : 	typedef typename _Val_types::const_pointer const_pointer;
; 565  : 	typedef typename _Val_types::reference reference;
; 566  : 	typedef typename _Val_types::const_reference const_reference;
; 567  : 
; 568  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 569  : 	typedef _Tree_iterator<_Myt> iterator;
; 570  : 
; 571  : 	_Tree_val()
; 572  : 		{	// initialize data
; 573  : 		this->_Myhead = 0;
; 574  : 		this->_Mysize = 0;
; 575  : 		}
; 576  : 
; 577  : 	enum _Redbl
; 578  : 		{	// colors for link to parent
; 579  : 		_Red, _Black};
; 580  : 
; 581  : 	static char& _Color(_Nodeptr _Pnode)
; 582  : 		{	// return reference to color in node
; 583  : 		return ((char&)_Pnode->_Color);
; 584  : 		}
; 585  : 
; 586  : 	static char& _Isnil(_Nodeptr _Pnode)
; 587  : 		{	// return reference to nil flag in node
; 588  : 		return ((char&)_Pnode->_Isnil);

  00032	8b 08		 mov	 ecx, DWORD PTR [eax]

; 589  : 		}
; 590  : 
; 591  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 592  : 		{	// return reference to left pointer in node
; 593  : 		return ((_Nodepref)_Pnode->_Left);
; 594  : 		}
; 595  : 
; 596  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 597  : 		{	// return reference to parent pointer in node
; 598  : 		return ((_Nodepref)_Pnode->_Parent);
; 599  : 		}
; 600  : 
; 601  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 602  : 		{	// return reference to right pointer in node
; 603  : 		return ((_Nodepref)_Pnode->_Right);
; 604  : 		}
; 605  : 
; 606  : 	static reference _Myval(_Nodeptr _Pnode)
; 607  : 		{	// return reference to value in node
; 608  : 		return ((reference)_Pnode->_Myval);
; 609  : 		}
; 610  : 
; 611  : 	static _Nodeptr _Max(_Nodeptr _Pnode)
; 612  : 		{	// return rightmost node in subtree at _Pnode
; 613  : 		while (!_Isnil(_Right(_Pnode)))
; 614  : 			_Pnode = _Right(_Pnode);
; 615  : 		return (_Pnode);
; 616  : 		}
; 617  : 
; 618  : 	static _Nodeptr _Min(_Nodeptr _Pnode)
; 619  : 		{	// return leftmost node in subtree at _Pnode
; 620  : 		while (!_Isnil(_Left(_Pnode)))

  00034	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  00038	74 f6		 je	 SHORT $LL27@Distance2

; 65   : 		else

  0003a	eb 1e		 jmp	 SHORT $LN26@Distance2
$LN48@Distance2:

; 66   : 			{	// climb looking for right subtree
; 67   : 			_Nodeptr _Pnode;
; 68   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 69   : 				&& _Ptr == _Mytree::_Right(_Pnode))

  0003c	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0003f	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  00043	75 13		 jne	 SHORT $LN55@Distance2
$LL11@Distance2:
  00045	3b 41 08	 cmp	 eax, DWORD PTR [ecx+8]
  00048	75 0e		 jne	 SHORT $LN55@Distance2

; 70   : 				_Ptr = _Pnode;	// ==> parent while right subtree

  0004a	8b c1		 mov	 eax, ecx
  0004c	89 45 08	 mov	 DWORD PTR __First$[ebp], eax
  0004f	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00052	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  00056	74 ed		 je	 SHORT $LL11@Distance2
$LN55@Distance2:

; 71   : 			_Ptr = _Pnode;	// ==> parent (head if end())

  00058	8b c1		 mov	 eax, ecx
$LN26@Distance2:
  0005a	89 45 08	 mov	 DWORD PTR __First$[ebp], eax
$LN51@Distance2:

; 336  : 		return (this->_Ptr == _Right._Ptr);

  0005d	3b c2		 cmp	 eax, edx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility

; 798  : 	for (; _First != _Last; ++_First)

  0005f	75 b2		 jne	 SHORT $LL12@Distance2
  00061	89 37		 mov	 DWORD PTR [edi], esi
  00063	5e		 pop	 esi
$LN1@Distance2:
  00064	5f		 pop	 edi

; 800  : 	}

  00065	5d		 pop	 ebp
  00066	c3		 ret	 0
??$_Distance2@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@I@std@@YAXV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@0@0AAIUbidirectional_iterator_tag@0@@Z ENDP ; std::_Distance2<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,unsigned int>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\type_traits
;	COMDAT ??$_Move@AAD@std@@YA$$QADAAD@Z
_TEXT	SEGMENT
??$_Move@AAD@std@@YA$$QADAAD@Z PROC			; std::_Move<char &>, COMDAT
; __Arg$ = ecx

; 1799 : 	return ((typename remove_reference<_Ty>::type&&)_Arg);

  00000	8b c1		 mov	 eax, ecx

; 1800 : 	}

  00002	c3		 ret	 0
??$_Move@AAD@std@@YA$$QADAAD@Z ENDP			; std::_Move<char &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@std@@@1@PAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z
_TEXT	SEGMENT
??$destroy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@std@@@1@PAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z PROC ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void *> > >::destroy<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >, COMDAT
; __Al$dead$ = ecx
; __Ptr$ = edx

; 755  : 		static void destroy(_Alloc& _Al, _Uty *_Ptr)

  00000	56		 push	 esi
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  00001	8b 72 10	 mov	 esi, DWORD PTR [edx+16]
  00004	85 f6		 test	 esi, esi
  00006	74 29		 je	 SHORT $LN18@destroy
  00008	57		 push	 edi

; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  00009	83 cf ff	 or	 edi, -1
  0000c	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  0000f	8b c7		 mov	 eax, edi
  00011	f0 0f c1 01	 lock	  xadd	 DWORD PTR [ecx], eax
  00015	75 19		 jne	 SHORT $LN21@destroy

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  00017	8b 06		 mov	 eax, DWORD PTR [esi]
  00019	8b ce		 mov	 ecx, esi
  0001b	ff 10		 call	 DWORD PTR [eax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  0001d	8d 46 08	 lea	 eax, DWORD PTR [esi+8]
  00020	f0 0f c1 38	 lock	  xadd	 DWORD PTR [eax], edi
  00024	4f		 dec	 edi
  00025	75 09		 jne	 SHORT $LN21@destroy

; 128  : 			_Delete_this();

  00027	8b 06		 mov	 eax, DWORD PTR [esi]
  00029	5f		 pop	 edi
  0002a	8b ce		 mov	 ecx, esi
  0002c	5e		 pop	 esi
  0002d	ff 60 04	 jmp	 DWORD PTR [eax+4]
$LN21@destroy:
  00030	5f		 pop	 edi
$LN18@destroy:
  00031	5e		 pop	 esi
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 758  : 		}

  00032	c3		 ret	 0
??$destroy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@std@@@1@PAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z ENDP ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void *> > >::destroy<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\type_traits
;	COMDAT ??$forward@AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@YAAAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
??$forward@AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@YAAAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@0@AAV10@@Z PROC ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > &>, COMDAT
; __Arg$ = ecx

; 1776 : 	return (static_cast<_Ty&&>(_Arg));

  00000	8b c1		 mov	 eax, ecx

; 1777 : 	}

  00002	c3		 ret	 0
??$forward@AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@YAAAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@0@AAV10@@Z ENDP ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@std@@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@std@@@1@PAPAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@1@@Z
_TEXT	SEGMENT
??$destroy@PAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@std@@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@std@@@1@PAPAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@1@@Z PROC ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void *> > >::destroy<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void *> *>, COMDAT
; __Al$dead$ = ecx
; __Ptr$dead$ = edx

; 756  : 		{	// destroy object at _Ptr
; 757  : 		_Al.destroy(_Ptr);
; 758  : 		}

  00000	c3		 ret	 0
??$destroy@PAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@std@@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@std@@@1@PAPAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@1@@Z ENDP ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void *> > >::destroy<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void *> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\type_traits
;	COMDAT ??$_Move@AAPAVChunkBase@@@std@@YA$$QAPAVChunkBase@@AAPAV1@@Z
_TEXT	SEGMENT
??$_Move@AAPAVChunkBase@@@std@@YA$$QAPAVChunkBase@@AAPAV1@@Z PROC ; std::_Move<ChunkBase * &>, COMDAT
; __Arg$ = ecx

; 1799 : 	return ((typename remove_reference<_Ty>::type&&)_Arg);

  00000	8b c1		 mov	 eax, ecx

; 1800 : 	}

  00002	c3		 ret	 0
??$_Move@AAPAVChunkBase@@@std@@YA$$QAPAVChunkBase@@AAPAV1@@Z ENDP ; std::_Move<ChunkBase * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\type_traits
;	COMDAT ??$forward@AAPAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@std@@@std@@YAAAPAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@0@AAPAU10@@Z
_TEXT	SEGMENT
??$forward@AAPAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@std@@@std@@YAAAPAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@0@AAPAU10@@Z PROC ; std::forward<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void *> * &>, COMDAT
; __Arg$ = ecx

; 1776 : 	return (static_cast<_Ty&&>(_Arg));

  00000	8b c1		 mov	 eax, ecx

; 1777 : 	}

  00002	c3		 ret	 0
??$forward@AAPAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@std@@@std@@YAAAPAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@0@AAPAU10@@Z ENDP ; std::forward<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void *> * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@PAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@std@@AAPAU12@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@std@@@1@PAPAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@1@AAPAU31@@Z
_TEXT	SEGMENT
__V0$ = 8						; size = 4
??$construct@PAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@std@@AAPAU12@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@std@@@1@PAPAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@1@AAPAU31@@Z PROC ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void *> > >::construct<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void *> *,std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void *> * &>, COMDAT
; __Al$dead$ = ecx
; __Ptr$ = edx

; 751  : _VARIADIC_EXPAND_0X(_ALLOC_TRAITS_SPECIAL_CONSTRUCT, , , , )

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 617  : _VARIADIC_EXPAND_0X(_ALLOC_MEMBER_CONSTRUCT, , , , )

  00003	85 d2		 test	 edx, edx
  00005	74 07		 je	 SHORT $LN7@construct
  00007	8b 45 08	 mov	 eax, DWORD PTR __V0$[ebp]
  0000a	8b 00		 mov	 eax, DWORD PTR [eax]
  0000c	89 02		 mov	 DWORD PTR [edx], eax
$LN7@construct:

; 751  : _VARIADIC_EXPAND_0X(_ALLOC_TRAITS_SPECIAL_CONSTRUCT, , , , )

  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
??$construct@PAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@std@@AAPAU12@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@std@@@1@PAPAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@1@AAPAU31@@Z ENDP ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void *> > >::construct<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void *> *,std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void *> * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\type_traits
;	COMDAT ??$forward@V?$_Ptr_base@VChunkBase@@@std@@@std@@YA$$QAV?$_Ptr_base@VChunkBase@@@0@AAV10@@Z
_TEXT	SEGMENT
??$forward@V?$_Ptr_base@VChunkBase@@@std@@@std@@YA$$QAV?$_Ptr_base@VChunkBase@@@0@AAV10@@Z PROC ; std::forward<std::_Ptr_base<ChunkBase> >, COMDAT
; __Arg$ = ecx

; 1776 : 	return (static_cast<_Ty&&>(_Arg));

  00000	8b c1		 mov	 eax, ecx

; 1777 : 	}

  00002	c3		 ret	 0
??$forward@V?$_Ptr_base@VChunkBase@@@std@@@std@@YA$$QAV?$_Ptr_base@VChunkBase@@@0@AAV10@@Z ENDP ; std::forward<std::_Ptr_base<ChunkBase> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\mutex
;	COMDAT ??_GEmptyChunk@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$dead$ = 8					; size = 4
??_GEmptyChunk@@QAEPAXI@Z PROC				; EmptyChunk::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	57		 push	 edi
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp

; 54   : {

  00004	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7ChunkBase@@6B@
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  0000a	8b 7e 24	 mov	 edi, DWORD PTR [esi+36]
  0000d	85 ff		 test	 edi, edi
  0000f	74 27		 je	 SHORT $LN16@scalar
  00011	53		 push	 ebx

; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  00012	83 cb ff	 or	 ebx, -1
  00015	8d 57 04	 lea	 edx, DWORD PTR [edi+4]
  00018	8b c3		 mov	 eax, ebx
  0001a	f0 0f c1 02	 lock	  xadd	 DWORD PTR [edx], eax
  0001e	75 17		 jne	 SHORT $LN27@scalar

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  00020	8b 07		 mov	 eax, DWORD PTR [edi]
  00022	8b cf		 mov	 ecx, edi
  00024	ff 10		 call	 DWORD PTR [eax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  00026	8d 47 08	 lea	 eax, DWORD PTR [edi+8]
  00029	f0 0f c1 18	 lock	  xadd	 DWORD PTR [eax], ebx
  0002d	4b		 dec	 ebx
  0002e	75 07		 jne	 SHORT $LN27@scalar

; 128  : 			_Delete_this();

  00030	8b 07		 mov	 eax, DWORD PTR [edi]
  00032	8b cf		 mov	 ecx, edi
  00034	ff 50 04	 call	 DWORD PTR [eax+4]
$LN27@scalar:
  00037	5b		 pop	 ebx
$LN16@scalar:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\mutex

; 33   : 		_Mtx_destroy(&_Mtx);

  00038	8d 46 1c	 lea	 eax, DWORD PTR [esi+28]
  0003b	50		 push	 eax
  0003c	e8 00 00 00 00	 call	 __Mtx_destroy
  00041	8d 46 18	 lea	 eax, DWORD PTR [esi+24]
  00044	50		 push	 eax
  00045	e8 00 00 00 00	 call	 __Mtx_destroy
  0004a	56		 push	 esi
  0004b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00050	83 c4 0c	 add	 esp, 12			; 0000000cH
  00053	8b c6		 mov	 eax, esi
  00055	5f		 pop	 edi
  00056	5e		 pop	 esi
  00057	c2 04 00	 ret	 4
??_GEmptyChunk@@QAEPAXI@Z ENDP				; EmptyChunk::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
;	COMDAT ?size@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QBEIXZ PROC ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::size, COMDAT
; _this$ = ecx

; 1273 : 		return (this->_Mysize);

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]

; 1274 : 		}

  00003	c3		 ret	 0
?size@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QBEIXZ ENDP ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
;	COMDAT ?_Destroy_if_not_nil@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@2@@Z
_TEXT	SEGMENT
__Newnode$ = 8						; size = 4
?_Destroy_if_not_nil@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@2@@Z PROC ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Destroy_if_not_nil, COMDAT
; _this$dead$ = ecx

; 1651 : 		{	// node exists, destroy it

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi

; 608  : 		return ((reference)_Pnode->_Myval);

  00005	8b 7d 08	 mov	 edi, DWORD PTR __Newnode$[ebp]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  00008	8b 77 20	 mov	 esi, DWORD PTR [edi+32]
  0000b	85 f6		 test	 esi, esi
  0000d	74 27		 je	 SHORT $LN28@Destroy_if
  0000f	53		 push	 ebx

; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  00010	83 cb ff	 or	 ebx, -1
  00013	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  00016	8b c3		 mov	 eax, ebx
  00018	f0 0f c1 01	 lock	  xadd	 DWORD PTR [ecx], eax
  0001c	75 17		 jne	 SHORT $LN37@Destroy_if

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  0001e	8b 06		 mov	 eax, DWORD PTR [esi]
  00020	8b ce		 mov	 ecx, esi
  00022	ff 10		 call	 DWORD PTR [eax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  00024	8d 46 08	 lea	 eax, DWORD PTR [esi+8]
  00027	f0 0f c1 18	 lock	  xadd	 DWORD PTR [eax], ebx
  0002b	4b		 dec	 ebx
  0002c	75 07		 jne	 SHORT $LN37@Destroy_if

; 128  : 			_Delete_this();

  0002e	8b 06		 mov	 eax, DWORD PTR [esi]
  00030	8b ce		 mov	 ecx, esi
  00032	ff 50 04	 call	 DWORD PTR [eax+4]
$LN37@Destroy_if:
  00035	5b		 pop	 ebx
$LN28@Destroy_if:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 586  : 		::operator delete(_Ptr);

  00036	57		 push	 edi
  00037	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0003c	83 c4 04	 add	 esp, 4
  0003f	5f		 pop	 edi
  00040	5e		 pop	 esi
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree

; 1656 : 		}

  00041	5d		 pop	 ebp
  00042	c2 04 00	 ret	 4
?_Destroy_if_not_nil@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Destroy_if_not_nil
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
;	COMDAT ?_Buynode0@?$_Tree_buy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@2@XZ
_TEXT	SEGMENT
?_Buynode0@?$_Tree_buy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@2@XZ PROC ; std::_Tree_buy<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::_Buynode0, COMDAT
; _this$ = ecx

; 897  : 		{	// allocate a non-value node

  00000	56		 push	 esi
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  00001	6a 24		 push	 36			; 00000024H
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree

; 897  : 		{	// allocate a non-value node

  00003	8b f1		 mov	 esi, ecx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  00005	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0000a	8b d0		 mov	 edx, eax
  0000c	83 c4 04	 add	 esp, 4
  0000f	85 d2		 test	 edx, edx
  00011	74 1e		 je	 SHORT $LN96@Buynode0

; 617  : _VARIADIC_EXPAND_0X(_ALLOC_MEMBER_CONSTRUCT, , , , )

  00013	8b 06		 mov	 eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree

; 598  : 		return ((_Nodepref)_Pnode->_Parent);

  00015	8d 4a 04	 lea	 ecx, DWORD PTR [edx+4]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 617  : _VARIADIC_EXPAND_0X(_ALLOC_MEMBER_CONSTRUCT, , , , )

  00018	89 02		 mov	 DWORD PTR [edx], eax
  0001a	85 c9		 test	 ecx, ecx
  0001c	74 04		 je	 SHORT $LN61@Buynode0
  0001e	8b 06		 mov	 eax, DWORD PTR [esi]
  00020	89 01		 mov	 DWORD PTR [ecx], eax
$LN61@Buynode0:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree

; 603  : 		return ((_Nodepref)_Pnode->_Right);

  00022	8d 4a 08	 lea	 ecx, DWORD PTR [edx+8]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 617  : _VARIADIC_EXPAND_0X(_ALLOC_MEMBER_CONSTRUCT, , , , )

  00025	85 c9		 test	 ecx, ecx
  00027	74 04		 je	 SHORT $LN83@Buynode0
  00029	8b 06		 mov	 eax, DWORD PTR [esi]
  0002b	89 01		 mov	 DWORD PTR [ecx], eax
$LN83@Buynode0:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree

; 912  : 		return (_Pnode);

  0002d	8b c2		 mov	 eax, edx
  0002f	5e		 pop	 esi

; 913  : 		}

  00030	c3		 ret	 0
$LN96@Buynode0:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 29   : 		_Xbad_alloc();	// report no memory

  00031	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN98@Buynode0:
$LN95@Buynode0:
  00036	cc		 int	 3
?_Buynode0@?$_Tree_buy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@2@XZ ENDP ; std::_Tree_buy<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::_Buynode0
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
;	COMDAT ?_Freenode0@?$_Tree_buy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Freenode0@?$_Tree_buy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@2@@Z PROC ; std::_Tree_buy<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::_Freenode0, COMDAT
; _this$dead$ = ecx

; 916  : 		{	// free non-value node using current allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 586  : 		::operator delete(_Ptr);

  00003	ff 75 08	 push	 DWORD PTR __Pnode$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	83 c4 04	 add	 esp, 4
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree

; 924  : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 04 00	 ret	 4
?_Freenode0@?$_Tree_buy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@2@@Z ENDP ; std::_Tree_buy<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::_Freenode0
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
;	COMDAT ??E?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::operator++, COMDAT
; _this$ = ecx

; 411  : 		{	// preincrement

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 271  : 		++(*(_Mybase *)this);

  00003	e8 00 00 00 00	 call	 ??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >,std::_Iterator_base0>::operator++

; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);

  00008	8b c6		 mov	 eax, esi
  0000a	5e		 pop	 esi

; 414  : 		}

  0000b	c3		 ret	 0
??E?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
;	COMDAT ??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >, COMDAT
; _this$ = ecx

; 39   : 		{	// construct with null node pointer

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 210  : 		}

  00006	8b c1		 mov	 eax, ecx
  00008	c3		 ret	 0
??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
;	COMDAT ??F?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??F?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::operator--, COMDAT
; _this$ = ecx

; 283  : 		{	// predecrement

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);

  00003	e8 00 00 00 00	 call	 ??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >,std::_Iterator_base0>::operator--

; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);

  00008	8b c6		 mov	 eax, esi
  0000a	5e		 pop	 esi

; 312  : 		}

  0000b	c3		 ret	 0
??F?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::operator--
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xatomic0.h
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ??0?$_Ref_count@VEmptyChunk@@@std@@QAE@PAVEmptyChunk@@@Z
_TEXT	SEGMENT
__Px$ = 8						; size = 4
??0?$_Ref_count@VEmptyChunk@@@std@@QAE@PAVEmptyChunk@@@Z PROC ; std::_Ref_count<EmptyChunk>::_Ref_count<EmptyChunk>, COMDAT
; _this$ = ecx

; 155  : 		{	// construct

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Px$[ebp]
  00006	89 41 0c	 mov	 DWORD PTR [ecx+12], eax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xatomic0.h

; 219  : 	_Counter = _Value;

  00009	c7 41 04 01 00
	00 00		 mov	 DWORD PTR [ecx+4], 1
  00010	c7 41 08 01 00
	00 00		 mov	 DWORD PTR [ecx+8], 1
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 155  : 		{	// construct

  00017	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7?$_Ref_count@VEmptyChunk@@@std@@6B@

; 156  : 		}

  0001d	8b c1		 mov	 eax, ecx
  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
??0?$_Ref_count@VEmptyChunk@@@std@@QAE@PAVEmptyChunk@@@Z ENDP ; std::_Ref_count<EmptyChunk>::_Ref_count<EmptyChunk>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ?_Destroy@?$_Ref_count@VEmptyChunk@@@std@@EAEXXZ
_TEXT	SEGMENT
?_Destroy@?$_Ref_count@VEmptyChunk@@@std@@EAEXXZ PROC	; std::_Ref_count<EmptyChunk>::_Destroy, COMDAT
; _this$ = ecx

; 161  : 		delete _Ptr;

  00000	8b 49 0c	 mov	 ecx, DWORD PTR [ecx+12]
  00003	85 c9		 test	 ecx, ecx
  00005	74 06		 je	 SHORT $LN3@Destroy
  00007	51		 push	 ecx
  00008	e8 00 00 00 00	 call	 ??_GEmptyChunk@@QAEPAXI@Z
$LN3@Destroy:

; 162  : 		}

  0000d	c3		 ret	 0
?_Destroy@?$_Ref_count@VEmptyChunk@@@std@@EAEXXZ ENDP	; std::_Ref_count<EmptyChunk>::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ?_Delete_this@?$_Ref_count@VEmptyChunk@@@std@@EAEXXZ
_TEXT	SEGMENT
?_Delete_this@?$_Ref_count@VEmptyChunk@@@std@@EAEXXZ PROC ; std::_Ref_count<EmptyChunk>::_Delete_this, COMDAT
; _this$ = ecx

; 166  : 		delete this;

  00000	85 c9		 test	 ecx, ecx
  00002	74 07		 je	 SHORT $LN3@Delete_thi
  00004	8b 01		 mov	 eax, DWORD PTR [ecx]
  00006	6a 01		 push	 1
  00008	ff 50 08	 call	 DWORD PTR [eax+8]
$LN3@Delete_thi:

; 167  : 		}

  0000b	c3		 ret	 0
?_Delete_this@?$_Ref_count@VEmptyChunk@@@std@@EAEXXZ ENDP ; std::_Ref_count<EmptyChunk>::_Delete_this
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ??_G?$_Ref_count@VEmptyChunk@@@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$_Ref_count@VEmptyChunk@@@std@@UAEPAXI@Z PROC	; std::_Ref_count<EmptyChunk>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx

; 69   : 		{	// ensure that derived classes can be destroyed properly

  0000a	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7_Ref_count_base@std@@6B@
  00010	74 09		 je	 SHORT $LN8@scalar
  00012	56		 push	 esi
  00013	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00018	83 c4 04	 add	 esp, 4
$LN8@scalar:
  0001b	8b c6		 mov	 eax, esi
  0001d	5e		 pop	 esi
  0001e	5d		 pop	 ebp
  0001f	c2 04 00	 ret	 4
??_G?$_Ref_count@VEmptyChunk@@@std@@UAEPAXI@Z ENDP	; std::_Ref_count<EmptyChunk>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ??1?$_Ref_count@VEmptyChunk@@@std@@UAE@XZ
_TEXT	SEGMENT
??1?$_Ref_count@VEmptyChunk@@@std@@UAE@XZ PROC		; std::_Ref_count<EmptyChunk>::~_Ref_count<EmptyChunk>, COMDAT
; _this$ = ecx

; 69   : 		{	// ensure that derived classes can be destroyed properly

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7_Ref_count_base@std@@6B@
  00006	c3		 ret	 0
??1?$_Ref_count@VEmptyChunk@@@std@@UAE@XZ ENDP		; std::_Ref_count<EmptyChunk>::~_Ref_count<EmptyChunk>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
;	COMDAT ??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@XZ PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >,std::_Iterator_base0>, COMDAT
; _this$ = ecx

; 39   : 		{	// construct with null node pointer

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 40   : 		}

  00006	8b c1		 mov	 eax, ecx
  00008	c3		 ret	 0
??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@XZ ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >,std::_Iterator_base0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
;	COMDAT ??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >,std::_Iterator_base0>::operator--, COMDAT
; _this$ = ecx

; 84   : 		{	// predecrement

  00000	8b d1		 mov	 edx, ecx

; 103  : 
; 104  : 	_Myiter operator--(int)
; 105  : 		{	// postdecrement
; 106  : 		_Myiter _Tmp = *this;
; 107  : 		--*this;
; 108  : 		return (_Tmp);
; 109  : 		}
; 110  : 
; 111  : 	bool operator==(const _Myiter& _Right) const
; 112  : 		{	// test for iterator equality
; 113  : 		return (_Ptr == _Right._Ptr);
; 114  : 		}
; 115  : 
; 116  : 	bool operator!=(const _Myiter& _Right) const
; 117  : 		{	// test for iterator inequality
; 118  : 		return (!(*this == _Right));
; 119  : 		}
; 120  : 
; 121  : 	_Nodeptr _Mynode() const
; 122  : 		{	// return node pointer
; 123  : 		return (_Ptr);
; 124  : 		}
; 125  : 
; 126  : 	_Nodeptr _Ptr;	// pointer to node
; 127  : 	};
; 128  : 
; 129  : 	// TEMPLATE CLASS _Tree_unchecked_iterator
; 130  : template<class _Mytree>
; 131  : 	class _Tree_unchecked_iterator
; 132  : 		: public _Tree_unchecked_const_iterator<_Mytree>
; 133  : 	{	// unchecked iterator for mutable tree
; 134  : public:
; 135  : 	typedef _Tree_unchecked_iterator<_Mytree> _Myiter;
; 136  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Mybase;
; 137  : 	typedef bidirectional_iterator_tag iterator_category;
; 138  : 
; 139  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 140  : 	typedef typename _Mytree::value_type value_type;
; 141  : 	typedef typename _Mytree::difference_type difference_type;
; 142  : 	typedef typename _Mytree::pointer pointer;
; 143  : 	typedef typename _Mytree::reference reference;
; 144  : 
; 145  : 	_Tree_unchecked_iterator()
; 146  : 		{	// construct with null node
; 147  : 		}
; 148  : 
; 149  : 	_Tree_unchecked_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 150  : 		: _Mybase(_Pnode, _Plist)
; 151  : 		{	// construct with node pointer _Pnode
; 152  : 		}
; 153  : 
; 154  : 	reference operator*() const
; 155  : 		{	// return designated value
; 156  : 		return ((reference)**(_Mybase *)this);
; 157  : 		}
; 158  : 
; 159  : 	pointer operator->() const
; 160  : 		{	// return pointer to class object
; 161  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 162  : 		}
; 163  : 
; 164  : 	_Myiter& operator++()
; 165  : 		{	// preincrement
; 166  : 		++(*(_Mybase *)this);
; 167  : 		return (*this);
; 168  : 		}
; 169  : 
; 170  : 	_Myiter operator++(int)
; 171  : 		{	// postincrement
; 172  : 		_Myiter _Tmp = *this;
; 173  : 		++*this;
; 174  : 		return (_Tmp);
; 175  : 		}
; 176  : 
; 177  : 	_Myiter& operator--()
; 178  : 		{	// predecrement
; 179  : 		--(*(_Mybase *)this);
; 180  : 		return (*this);
; 181  : 		}
; 182  : 
; 183  : 	_Myiter operator--(int)
; 184  : 		{	// postdecrement
; 185  : 		_Myiter _Tmp = *this;
; 186  : 		--*this;
; 187  : 		return (_Tmp);
; 188  : 		}
; 189  : 	};
; 190  : 
; 191  : 	// TEMPLATE CLASS _Tree_const_iterator
; 192  : template<class _Mytree>
; 193  : 	class _Tree_const_iterator
; 194  : 		: public _Tree_unchecked_const_iterator<_Mytree, _Iterator_base>
; 195  : 	{	// iterator for nonmutable tree
; 196  : public:
; 197  : 	typedef _Tree_const_iterator<_Mytree> _Myiter;
; 198  : 	typedef _Tree_unchecked_const_iterator<_Mytree, _Iterator_base> _Mybase;
; 199  : 	typedef bidirectional_iterator_tag iterator_category;
; 200  : 
; 201  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 202  : 	typedef typename _Mytree::value_type value_type;
; 203  : 	typedef typename _Mytree::difference_type difference_type;
; 204  : 	typedef typename _Mytree::const_pointer pointer;
; 205  : 	typedef typename _Mytree::const_reference reference;
; 206  : 
; 207  : 	_Tree_const_iterator()
; 208  : 		: _Mybase()
; 209  : 		{	// construct with null node pointer
; 210  : 		}
; 211  : 
; 212  : 	_Tree_const_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 213  : 		: _Mybase(_Pnode, _Plist)
; 214  : 		{	// construct with node pointer _Pnode
; 215  : 		}
; 216  : 
; 217  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Unchecked_type;
; 218  : 
; 219  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 220  : 		{	// reset from unchecked iterator
; 221  : 		this->_Ptr = _Right._Ptr;
; 222  : 		return (*this);
; 223  : 		}
; 224  : 
; 225  : 	_Unchecked_type _Unchecked() const
; 226  : 		{	// make an unchecked iterator
; 227  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 228  : 		}
; 229  : 
; 230  : 	reference operator*() const
; 231  : 		{	// return designated value
; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		if (this->_Getcont() == 0
; 234  : 			|| this->_Ptr == 0
; 235  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 236  : 			{	// report error
; 237  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 238  : 			_SCL_SECURE_OUT_OF_RANGE;
; 239  : 			}
; 240  : 
; 241  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 242  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 243  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 244  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 245  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 246  : 
; 247  : 		return (_Mytree::_Myval(this->_Ptr));
; 248  : 		}
; 249  : 
; 250  : 	pointer operator->() const
; 251  : 		{	// return pointer to class object
; 252  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 253  : 		}
; 254  : 
; 255  : 	_Myiter& operator++()
; 256  : 		{	// preincrement
; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);
; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);
; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  :  #if _HAS_CPP0X
; 520  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 521  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 522  : 
; 523  :  #else /* _HAS_CPP0X */
; 524  : 	typedef typename _Alloc::template rebind<_Ty>::other _Alty;
; 525  :  #endif /* _HAS_CPP0X */
; 526  : 
; 527  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 528  : 		_Voidptr;
; 529  : 	typedef _Tree_node<typename _Alty::value_type,
; 530  : 		_Voidptr> _Node;
; 531  : 
; 532  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 533  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 534  : 	typedef _Nodeptr& _Nodepref;
; 535  : 
; 536  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 537  : 		_Tree_simple_types<typename _Alty::value_type>,
; 538  : 		_Tree_iter_types<typename _Alty::value_type,
; 539  : 			typename _Alty::size_type,
; 540  : 			typename _Alty::difference_type,
; 541  : 			typename _Alty::pointer,
; 542  : 			typename _Alty::const_pointer,
; 543  : 			typename _Alty::reference,
; 544  : 			typename _Alty::const_reference,
; 545  : 			_Nodeptr> >::type
; 546  : 		_Val_types;
; 547  : 	};
; 548  : 
; 549  : 		// TEMPLATE CLASS _Tree_val
; 550  : template<class _Val_types>
; 551  : 	class _Tree_val
; 552  : 		: public _Container_base
; 553  : 	{	// base class for tree to hold data
; 554  : public:
; 555  : 	typedef _Tree_val<_Val_types> _Myt;
; 556  : 
; 557  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 558  : 	typedef _Nodeptr& _Nodepref;
; 559  : 
; 560  : 	typedef typename _Val_types::value_type value_type;
; 561  : 	typedef typename _Val_types::size_type size_type;
; 562  : 	typedef typename _Val_types::difference_type difference_type;
; 563  : 	typedef typename _Val_types::pointer pointer;
; 564  : 	typedef typename _Val_types::const_pointer const_pointer;
; 565  : 	typedef typename _Val_types::reference reference;
; 566  : 	typedef typename _Val_types::const_reference const_reference;
; 567  : 
; 568  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 569  : 	typedef _Tree_iterator<_Myt> iterator;
; 570  : 
; 571  : 	_Tree_val()
; 572  : 		{	// initialize data
; 573  : 		this->_Myhead = 0;
; 574  : 		this->_Mysize = 0;
; 575  : 		}
; 576  : 
; 577  : 	enum _Redbl
; 578  : 		{	// colors for link to parent
; 579  : 		_Red, _Black};
; 580  : 
; 581  : 	static char& _Color(_Nodeptr _Pnode)
; 582  : 		{	// return reference to color in node
; 583  : 		return ((char&)_Pnode->_Color);
; 584  : 		}
; 585  : 
; 586  : 	static char& _Isnil(_Nodeptr _Pnode)
; 587  : 		{	// return reference to nil flag in node
; 588  : 		return ((char&)_Pnode->_Isnil);

  00002	8b 02		 mov	 eax, DWORD PTR [edx]

; 85   : 		if (_Mytree::_Isnil(_Ptr))

  00004	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00008	74 08		 je	 SHORT $LN8@operator

; 86   : 			_Ptr = _Mytree::_Right(_Ptr);	// end() ==> rightmost

  0000a	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0000d	89 02		 mov	 DWORD PTR [edx], eax

; 100  : 			}
; 101  : 		return (*this);

  0000f	8b c2		 mov	 eax, edx

; 102  : 		}

  00011	c3		 ret	 0
$LN8@operator:

; 103  : 
; 104  : 	_Myiter operator--(int)
; 105  : 		{	// postdecrement
; 106  : 		_Myiter _Tmp = *this;
; 107  : 		--*this;
; 108  : 		return (_Tmp);
; 109  : 		}
; 110  : 
; 111  : 	bool operator==(const _Myiter& _Right) const
; 112  : 		{	// test for iterator equality
; 113  : 		return (_Ptr == _Right._Ptr);
; 114  : 		}
; 115  : 
; 116  : 	bool operator!=(const _Myiter& _Right) const
; 117  : 		{	// test for iterator inequality
; 118  : 		return (!(*this == _Right));
; 119  : 		}
; 120  : 
; 121  : 	_Nodeptr _Mynode() const
; 122  : 		{	// return node pointer
; 123  : 		return (_Ptr);
; 124  : 		}
; 125  : 
; 126  : 	_Nodeptr _Ptr;	// pointer to node
; 127  : 	};
; 128  : 
; 129  : 	// TEMPLATE CLASS _Tree_unchecked_iterator
; 130  : template<class _Mytree>
; 131  : 	class _Tree_unchecked_iterator
; 132  : 		: public _Tree_unchecked_const_iterator<_Mytree>
; 133  : 	{	// unchecked iterator for mutable tree
; 134  : public:
; 135  : 	typedef _Tree_unchecked_iterator<_Mytree> _Myiter;
; 136  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Mybase;
; 137  : 	typedef bidirectional_iterator_tag iterator_category;
; 138  : 
; 139  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 140  : 	typedef typename _Mytree::value_type value_type;
; 141  : 	typedef typename _Mytree::difference_type difference_type;
; 142  : 	typedef typename _Mytree::pointer pointer;
; 143  : 	typedef typename _Mytree::reference reference;
; 144  : 
; 145  : 	_Tree_unchecked_iterator()
; 146  : 		{	// construct with null node
; 147  : 		}
; 148  : 
; 149  : 	_Tree_unchecked_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 150  : 		: _Mybase(_Pnode, _Plist)
; 151  : 		{	// construct with node pointer _Pnode
; 152  : 		}
; 153  : 
; 154  : 	reference operator*() const
; 155  : 		{	// return designated value
; 156  : 		return ((reference)**(_Mybase *)this);
; 157  : 		}
; 158  : 
; 159  : 	pointer operator->() const
; 160  : 		{	// return pointer to class object
; 161  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 162  : 		}
; 163  : 
; 164  : 	_Myiter& operator++()
; 165  : 		{	// preincrement
; 166  : 		++(*(_Mybase *)this);
; 167  : 		return (*this);
; 168  : 		}
; 169  : 
; 170  : 	_Myiter operator++(int)
; 171  : 		{	// postincrement
; 172  : 		_Myiter _Tmp = *this;
; 173  : 		++*this;
; 174  : 		return (_Tmp);
; 175  : 		}
; 176  : 
; 177  : 	_Myiter& operator--()
; 178  : 		{	// predecrement
; 179  : 		--(*(_Mybase *)this);
; 180  : 		return (*this);
; 181  : 		}
; 182  : 
; 183  : 	_Myiter operator--(int)
; 184  : 		{	// postdecrement
; 185  : 		_Myiter _Tmp = *this;
; 186  : 		--*this;
; 187  : 		return (_Tmp);
; 188  : 		}
; 189  : 	};
; 190  : 
; 191  : 	// TEMPLATE CLASS _Tree_const_iterator
; 192  : template<class _Mytree>
; 193  : 	class _Tree_const_iterator
; 194  : 		: public _Tree_unchecked_const_iterator<_Mytree, _Iterator_base>
; 195  : 	{	// iterator for nonmutable tree
; 196  : public:
; 197  : 	typedef _Tree_const_iterator<_Mytree> _Myiter;
; 198  : 	typedef _Tree_unchecked_const_iterator<_Mytree, _Iterator_base> _Mybase;
; 199  : 	typedef bidirectional_iterator_tag iterator_category;
; 200  : 
; 201  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 202  : 	typedef typename _Mytree::value_type value_type;
; 203  : 	typedef typename _Mytree::difference_type difference_type;
; 204  : 	typedef typename _Mytree::const_pointer pointer;
; 205  : 	typedef typename _Mytree::const_reference reference;
; 206  : 
; 207  : 	_Tree_const_iterator()
; 208  : 		: _Mybase()
; 209  : 		{	// construct with null node pointer
; 210  : 		}
; 211  : 
; 212  : 	_Tree_const_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 213  : 		: _Mybase(_Pnode, _Plist)
; 214  : 		{	// construct with node pointer _Pnode
; 215  : 		}
; 216  : 
; 217  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Unchecked_type;
; 218  : 
; 219  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 220  : 		{	// reset from unchecked iterator
; 221  : 		this->_Ptr = _Right._Ptr;
; 222  : 		return (*this);
; 223  : 		}
; 224  : 
; 225  : 	_Unchecked_type _Unchecked() const
; 226  : 		{	// make an unchecked iterator
; 227  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 228  : 		}
; 229  : 
; 230  : 	reference operator*() const
; 231  : 		{	// return designated value
; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		if (this->_Getcont() == 0
; 234  : 			|| this->_Ptr == 0
; 235  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 236  : 			{	// report error
; 237  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 238  : 			_SCL_SECURE_OUT_OF_RANGE;
; 239  : 			}
; 240  : 
; 241  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 242  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 243  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 244  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 245  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 246  : 
; 247  : 		return (_Mytree::_Myval(this->_Ptr));
; 248  : 		}
; 249  : 
; 250  : 	pointer operator->() const
; 251  : 		{	// return pointer to class object
; 252  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 253  : 		}
; 254  : 
; 255  : 	_Myiter& operator++()
; 256  : 		{	// preincrement
; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);
; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);
; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  :  #if _HAS_CPP0X
; 520  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 521  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 522  : 
; 523  :  #else /* _HAS_CPP0X */
; 524  : 	typedef typename _Alloc::template rebind<_Ty>::other _Alty;
; 525  :  #endif /* _HAS_CPP0X */
; 526  : 
; 527  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 528  : 		_Voidptr;
; 529  : 	typedef _Tree_node<typename _Alty::value_type,
; 530  : 		_Voidptr> _Node;
; 531  : 
; 532  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 533  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 534  : 	typedef _Nodeptr& _Nodepref;
; 535  : 
; 536  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 537  : 		_Tree_simple_types<typename _Alty::value_type>,
; 538  : 		_Tree_iter_types<typename _Alty::value_type,
; 539  : 			typename _Alty::size_type,
; 540  : 			typename _Alty::difference_type,
; 541  : 			typename _Alty::pointer,
; 542  : 			typename _Alty::const_pointer,
; 543  : 			typename _Alty::reference,
; 544  : 			typename _Alty::const_reference,
; 545  : 			_Nodeptr> >::type
; 546  : 		_Val_types;
; 547  : 	};
; 548  : 
; 549  : 		// TEMPLATE CLASS _Tree_val
; 550  : template<class _Val_types>
; 551  : 	class _Tree_val
; 552  : 		: public _Container_base
; 553  : 	{	// base class for tree to hold data
; 554  : public:
; 555  : 	typedef _Tree_val<_Val_types> _Myt;
; 556  : 
; 557  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 558  : 	typedef _Nodeptr& _Nodepref;
; 559  : 
; 560  : 	typedef typename _Val_types::value_type value_type;
; 561  : 	typedef typename _Val_types::size_type size_type;
; 562  : 	typedef typename _Val_types::difference_type difference_type;
; 563  : 	typedef typename _Val_types::pointer pointer;
; 564  : 	typedef typename _Val_types::const_pointer const_pointer;
; 565  : 	typedef typename _Val_types::reference reference;
; 566  : 	typedef typename _Val_types::const_reference const_reference;
; 567  : 
; 568  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 569  : 	typedef _Tree_iterator<_Myt> iterator;
; 570  : 
; 571  : 	_Tree_val()
; 572  : 		{	// initialize data
; 573  : 		this->_Myhead = 0;
; 574  : 		this->_Mysize = 0;
; 575  : 		}
; 576  : 
; 577  : 	enum _Redbl
; 578  : 		{	// colors for link to parent
; 579  : 		_Red, _Black};
; 580  : 
; 581  : 	static char& _Color(_Nodeptr _Pnode)
; 582  : 		{	// return reference to color in node
; 583  : 		return ((char&)_Pnode->_Color);
; 584  : 		}
; 585  : 
; 586  : 	static char& _Isnil(_Nodeptr _Pnode)
; 587  : 		{	// return reference to nil flag in node
; 588  : 		return ((char&)_Pnode->_Isnil);

  00012	8b 08		 mov	 ecx, DWORD PTR [eax]

; 87   : 		else if (!_Mytree::_Isnil(_Mytree::_Left(_Ptr)))

  00014	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  00018	75 19		 jne	 SHORT $LN40@operator

; 103  : 
; 104  : 	_Myiter operator--(int)
; 105  : 		{	// postdecrement
; 106  : 		_Myiter _Tmp = *this;
; 107  : 		--*this;
; 108  : 		return (_Tmp);
; 109  : 		}
; 110  : 
; 111  : 	bool operator==(const _Myiter& _Right) const
; 112  : 		{	// test for iterator equality
; 113  : 		return (_Ptr == _Right._Ptr);
; 114  : 		}
; 115  : 
; 116  : 	bool operator!=(const _Myiter& _Right) const
; 117  : 		{	// test for iterator inequality
; 118  : 		return (!(*this == _Right));
; 119  : 		}
; 120  : 
; 121  : 	_Nodeptr _Mynode() const
; 122  : 		{	// return node pointer
; 123  : 		return (_Ptr);
; 124  : 		}
; 125  : 
; 126  : 	_Nodeptr _Ptr;	// pointer to node
; 127  : 	};
; 128  : 
; 129  : 	// TEMPLATE CLASS _Tree_unchecked_iterator
; 130  : template<class _Mytree>
; 131  : 	class _Tree_unchecked_iterator
; 132  : 		: public _Tree_unchecked_const_iterator<_Mytree>
; 133  : 	{	// unchecked iterator for mutable tree
; 134  : public:
; 135  : 	typedef _Tree_unchecked_iterator<_Mytree> _Myiter;
; 136  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Mybase;
; 137  : 	typedef bidirectional_iterator_tag iterator_category;
; 138  : 
; 139  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 140  : 	typedef typename _Mytree::value_type value_type;
; 141  : 	typedef typename _Mytree::difference_type difference_type;
; 142  : 	typedef typename _Mytree::pointer pointer;
; 143  : 	typedef typename _Mytree::reference reference;
; 144  : 
; 145  : 	_Tree_unchecked_iterator()
; 146  : 		{	// construct with null node
; 147  : 		}
; 148  : 
; 149  : 	_Tree_unchecked_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 150  : 		: _Mybase(_Pnode, _Plist)
; 151  : 		{	// construct with node pointer _Pnode
; 152  : 		}
; 153  : 
; 154  : 	reference operator*() const
; 155  : 		{	// return designated value
; 156  : 		return ((reference)**(_Mybase *)this);
; 157  : 		}
; 158  : 
; 159  : 	pointer operator->() const
; 160  : 		{	// return pointer to class object
; 161  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 162  : 		}
; 163  : 
; 164  : 	_Myiter& operator++()
; 165  : 		{	// preincrement
; 166  : 		++(*(_Mybase *)this);
; 167  : 		return (*this);
; 168  : 		}
; 169  : 
; 170  : 	_Myiter operator++(int)
; 171  : 		{	// postincrement
; 172  : 		_Myiter _Tmp = *this;
; 173  : 		++*this;
; 174  : 		return (_Tmp);
; 175  : 		}
; 176  : 
; 177  : 	_Myiter& operator--()
; 178  : 		{	// predecrement
; 179  : 		--(*(_Mybase *)this);
; 180  : 		return (*this);
; 181  : 		}
; 182  : 
; 183  : 	_Myiter operator--(int)
; 184  : 		{	// postdecrement
; 185  : 		_Myiter _Tmp = *this;
; 186  : 		--*this;
; 187  : 		return (_Tmp);
; 188  : 		}
; 189  : 	};
; 190  : 
; 191  : 	// TEMPLATE CLASS _Tree_const_iterator
; 192  : template<class _Mytree>
; 193  : 	class _Tree_const_iterator
; 194  : 		: public _Tree_unchecked_const_iterator<_Mytree, _Iterator_base>
; 195  : 	{	// iterator for nonmutable tree
; 196  : public:
; 197  : 	typedef _Tree_const_iterator<_Mytree> _Myiter;
; 198  : 	typedef _Tree_unchecked_const_iterator<_Mytree, _Iterator_base> _Mybase;
; 199  : 	typedef bidirectional_iterator_tag iterator_category;
; 200  : 
; 201  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 202  : 	typedef typename _Mytree::value_type value_type;
; 203  : 	typedef typename _Mytree::difference_type difference_type;
; 204  : 	typedef typename _Mytree::const_pointer pointer;
; 205  : 	typedef typename _Mytree::const_reference reference;
; 206  : 
; 207  : 	_Tree_const_iterator()
; 208  : 		: _Mybase()
; 209  : 		{	// construct with null node pointer
; 210  : 		}
; 211  : 
; 212  : 	_Tree_const_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 213  : 		: _Mybase(_Pnode, _Plist)
; 214  : 		{	// construct with node pointer _Pnode
; 215  : 		}
; 216  : 
; 217  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Unchecked_type;
; 218  : 
; 219  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 220  : 		{	// reset from unchecked iterator
; 221  : 		this->_Ptr = _Right._Ptr;
; 222  : 		return (*this);
; 223  : 		}
; 224  : 
; 225  : 	_Unchecked_type _Unchecked() const
; 226  : 		{	// make an unchecked iterator
; 227  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 228  : 		}
; 229  : 
; 230  : 	reference operator*() const
; 231  : 		{	// return designated value
; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		if (this->_Getcont() == 0
; 234  : 			|| this->_Ptr == 0
; 235  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 236  : 			{	// report error
; 237  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 238  : 			_SCL_SECURE_OUT_OF_RANGE;
; 239  : 			}
; 240  : 
; 241  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 242  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 243  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 244  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 245  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 246  : 
; 247  : 		return (_Mytree::_Myval(this->_Ptr));
; 248  : 		}
; 249  : 
; 250  : 	pointer operator->() const
; 251  : 		{	// return pointer to class object
; 252  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 253  : 		}
; 254  : 
; 255  : 	_Myiter& operator++()
; 256  : 		{	// preincrement
; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);
; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);
; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  :  #if _HAS_CPP0X
; 520  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 521  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 522  : 
; 523  :  #else /* _HAS_CPP0X */
; 524  : 	typedef typename _Alloc::template rebind<_Ty>::other _Alty;
; 525  :  #endif /* _HAS_CPP0X */
; 526  : 
; 527  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 528  : 		_Voidptr;
; 529  : 	typedef _Tree_node<typename _Alty::value_type,
; 530  : 		_Voidptr> _Node;
; 531  : 
; 532  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 533  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 534  : 	typedef _Nodeptr& _Nodepref;
; 535  : 
; 536  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 537  : 		_Tree_simple_types<typename _Alty::value_type>,
; 538  : 		_Tree_iter_types<typename _Alty::value_type,
; 539  : 			typename _Alty::size_type,
; 540  : 			typename _Alty::difference_type,
; 541  : 			typename _Alty::pointer,
; 542  : 			typename _Alty::const_pointer,
; 543  : 			typename _Alty::reference,
; 544  : 			typename _Alty::const_reference,
; 545  : 			_Nodeptr> >::type
; 546  : 		_Val_types;
; 547  : 	};
; 548  : 
; 549  : 		// TEMPLATE CLASS _Tree_val
; 550  : template<class _Val_types>
; 551  : 	class _Tree_val
; 552  : 		: public _Container_base
; 553  : 	{	// base class for tree to hold data
; 554  : public:
; 555  : 	typedef _Tree_val<_Val_types> _Myt;
; 556  : 
; 557  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 558  : 	typedef _Nodeptr& _Nodepref;
; 559  : 
; 560  : 	typedef typename _Val_types::value_type value_type;
; 561  : 	typedef typename _Val_types::size_type size_type;
; 562  : 	typedef typename _Val_types::difference_type difference_type;
; 563  : 	typedef typename _Val_types::pointer pointer;
; 564  : 	typedef typename _Val_types::const_pointer const_pointer;
; 565  : 	typedef typename _Val_types::reference reference;
; 566  : 	typedef typename _Val_types::const_reference const_reference;
; 567  : 
; 568  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 569  : 	typedef _Tree_iterator<_Myt> iterator;
; 570  : 
; 571  : 	_Tree_val()
; 572  : 		{	// initialize data
; 573  : 		this->_Myhead = 0;
; 574  : 		this->_Mysize = 0;
; 575  : 		}
; 576  : 
; 577  : 	enum _Redbl
; 578  : 		{	// colors for link to parent
; 579  : 		_Red, _Black};
; 580  : 
; 581  : 	static char& _Color(_Nodeptr _Pnode)
; 582  : 		{	// return reference to color in node
; 583  : 		return ((char&)_Pnode->_Color);
; 584  : 		}
; 585  : 
; 586  : 	static char& _Isnil(_Nodeptr _Pnode)
; 587  : 		{	// return reference to nil flag in node
; 588  : 		return ((char&)_Pnode->_Isnil);

  0001a	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]

; 589  : 		}
; 590  : 
; 591  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 592  : 		{	// return reference to left pointer in node
; 593  : 		return ((_Nodepref)_Pnode->_Left);
; 594  : 		}
; 595  : 
; 596  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 597  : 		{	// return reference to parent pointer in node
; 598  : 		return ((_Nodepref)_Pnode->_Parent);
; 599  : 		}
; 600  : 
; 601  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 602  : 		{	// return reference to right pointer in node
; 603  : 		return ((_Nodepref)_Pnode->_Right);
; 604  : 		}
; 605  : 
; 606  : 	static reference _Myval(_Nodeptr _Pnode)
; 607  : 		{	// return reference to value in node
; 608  : 		return ((reference)_Pnode->_Myval);
; 609  : 		}
; 610  : 
; 611  : 	static _Nodeptr _Max(_Nodeptr _Pnode)
; 612  : 		{	// return rightmost node in subtree at _Pnode
; 613  : 		while (!_Isnil(_Right(_Pnode)))

  0001d	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00021	75 36		 jne	 SHORT $LN21@operator
$LL22@operator:

; 614  : 			_Pnode = _Right(_Pnode);

  00023	8b c8		 mov	 ecx, eax

; 103  : 
; 104  : 	_Myiter operator--(int)
; 105  : 		{	// postdecrement
; 106  : 		_Myiter _Tmp = *this;
; 107  : 		--*this;
; 108  : 		return (_Tmp);
; 109  : 		}
; 110  : 
; 111  : 	bool operator==(const _Myiter& _Right) const
; 112  : 		{	// test for iterator equality
; 113  : 		return (_Ptr == _Right._Ptr);
; 114  : 		}
; 115  : 
; 116  : 	bool operator!=(const _Myiter& _Right) const
; 117  : 		{	// test for iterator inequality
; 118  : 		return (!(*this == _Right));
; 119  : 		}
; 120  : 
; 121  : 	_Nodeptr _Mynode() const
; 122  : 		{	// return node pointer
; 123  : 		return (_Ptr);
; 124  : 		}
; 125  : 
; 126  : 	_Nodeptr _Ptr;	// pointer to node
; 127  : 	};
; 128  : 
; 129  : 	// TEMPLATE CLASS _Tree_unchecked_iterator
; 130  : template<class _Mytree>
; 131  : 	class _Tree_unchecked_iterator
; 132  : 		: public _Tree_unchecked_const_iterator<_Mytree>
; 133  : 	{	// unchecked iterator for mutable tree
; 134  : public:
; 135  : 	typedef _Tree_unchecked_iterator<_Mytree> _Myiter;
; 136  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Mybase;
; 137  : 	typedef bidirectional_iterator_tag iterator_category;
; 138  : 
; 139  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 140  : 	typedef typename _Mytree::value_type value_type;
; 141  : 	typedef typename _Mytree::difference_type difference_type;
; 142  : 	typedef typename _Mytree::pointer pointer;
; 143  : 	typedef typename _Mytree::reference reference;
; 144  : 
; 145  : 	_Tree_unchecked_iterator()
; 146  : 		{	// construct with null node
; 147  : 		}
; 148  : 
; 149  : 	_Tree_unchecked_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 150  : 		: _Mybase(_Pnode, _Plist)
; 151  : 		{	// construct with node pointer _Pnode
; 152  : 		}
; 153  : 
; 154  : 	reference operator*() const
; 155  : 		{	// return designated value
; 156  : 		return ((reference)**(_Mybase *)this);
; 157  : 		}
; 158  : 
; 159  : 	pointer operator->() const
; 160  : 		{	// return pointer to class object
; 161  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 162  : 		}
; 163  : 
; 164  : 	_Myiter& operator++()
; 165  : 		{	// preincrement
; 166  : 		++(*(_Mybase *)this);
; 167  : 		return (*this);
; 168  : 		}
; 169  : 
; 170  : 	_Myiter operator++(int)
; 171  : 		{	// postincrement
; 172  : 		_Myiter _Tmp = *this;
; 173  : 		++*this;
; 174  : 		return (_Tmp);
; 175  : 		}
; 176  : 
; 177  : 	_Myiter& operator--()
; 178  : 		{	// predecrement
; 179  : 		--(*(_Mybase *)this);
; 180  : 		return (*this);
; 181  : 		}
; 182  : 
; 183  : 	_Myiter operator--(int)
; 184  : 		{	// postdecrement
; 185  : 		_Myiter _Tmp = *this;
; 186  : 		--*this;
; 187  : 		return (_Tmp);
; 188  : 		}
; 189  : 	};
; 190  : 
; 191  : 	// TEMPLATE CLASS _Tree_const_iterator
; 192  : template<class _Mytree>
; 193  : 	class _Tree_const_iterator
; 194  : 		: public _Tree_unchecked_const_iterator<_Mytree, _Iterator_base>
; 195  : 	{	// iterator for nonmutable tree
; 196  : public:
; 197  : 	typedef _Tree_const_iterator<_Mytree> _Myiter;
; 198  : 	typedef _Tree_unchecked_const_iterator<_Mytree, _Iterator_base> _Mybase;
; 199  : 	typedef bidirectional_iterator_tag iterator_category;
; 200  : 
; 201  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 202  : 	typedef typename _Mytree::value_type value_type;
; 203  : 	typedef typename _Mytree::difference_type difference_type;
; 204  : 	typedef typename _Mytree::const_pointer pointer;
; 205  : 	typedef typename _Mytree::const_reference reference;
; 206  : 
; 207  : 	_Tree_const_iterator()
; 208  : 		: _Mybase()
; 209  : 		{	// construct with null node pointer
; 210  : 		}
; 211  : 
; 212  : 	_Tree_const_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 213  : 		: _Mybase(_Pnode, _Plist)
; 214  : 		{	// construct with node pointer _Pnode
; 215  : 		}
; 216  : 
; 217  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Unchecked_type;
; 218  : 
; 219  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 220  : 		{	// reset from unchecked iterator
; 221  : 		this->_Ptr = _Right._Ptr;
; 222  : 		return (*this);
; 223  : 		}
; 224  : 
; 225  : 	_Unchecked_type _Unchecked() const
; 226  : 		{	// make an unchecked iterator
; 227  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 228  : 		}
; 229  : 
; 230  : 	reference operator*() const
; 231  : 		{	// return designated value
; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		if (this->_Getcont() == 0
; 234  : 			|| this->_Ptr == 0
; 235  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 236  : 			{	// report error
; 237  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 238  : 			_SCL_SECURE_OUT_OF_RANGE;
; 239  : 			}
; 240  : 
; 241  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 242  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 243  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 244  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 245  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 246  : 
; 247  : 		return (_Mytree::_Myval(this->_Ptr));
; 248  : 		}
; 249  : 
; 250  : 	pointer operator->() const
; 251  : 		{	// return pointer to class object
; 252  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 253  : 		}
; 254  : 
; 255  : 	_Myiter& operator++()
; 256  : 		{	// preincrement
; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);
; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);
; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  :  #if _HAS_CPP0X
; 520  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 521  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 522  : 
; 523  :  #else /* _HAS_CPP0X */
; 524  : 	typedef typename _Alloc::template rebind<_Ty>::other _Alty;
; 525  :  #endif /* _HAS_CPP0X */
; 526  : 
; 527  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 528  : 		_Voidptr;
; 529  : 	typedef _Tree_node<typename _Alty::value_type,
; 530  : 		_Voidptr> _Node;
; 531  : 
; 532  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 533  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 534  : 	typedef _Nodeptr& _Nodepref;
; 535  : 
; 536  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 537  : 		_Tree_simple_types<typename _Alty::value_type>,
; 538  : 		_Tree_iter_types<typename _Alty::value_type,
; 539  : 			typename _Alty::size_type,
; 540  : 			typename _Alty::difference_type,
; 541  : 			typename _Alty::pointer,
; 542  : 			typename _Alty::const_pointer,
; 543  : 			typename _Alty::reference,
; 544  : 			typename _Alty::const_reference,
; 545  : 			_Nodeptr> >::type
; 546  : 		_Val_types;
; 547  : 	};
; 548  : 
; 549  : 		// TEMPLATE CLASS _Tree_val
; 550  : template<class _Val_types>
; 551  : 	class _Tree_val
; 552  : 		: public _Container_base
; 553  : 	{	// base class for tree to hold data
; 554  : public:
; 555  : 	typedef _Tree_val<_Val_types> _Myt;
; 556  : 
; 557  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 558  : 	typedef _Nodeptr& _Nodepref;
; 559  : 
; 560  : 	typedef typename _Val_types::value_type value_type;
; 561  : 	typedef typename _Val_types::size_type size_type;
; 562  : 	typedef typename _Val_types::difference_type difference_type;
; 563  : 	typedef typename _Val_types::pointer pointer;
; 564  : 	typedef typename _Val_types::const_pointer const_pointer;
; 565  : 	typedef typename _Val_types::reference reference;
; 566  : 	typedef typename _Val_types::const_reference const_reference;
; 567  : 
; 568  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 569  : 	typedef _Tree_iterator<_Myt> iterator;
; 570  : 
; 571  : 	_Tree_val()
; 572  : 		{	// initialize data
; 573  : 		this->_Myhead = 0;
; 574  : 		this->_Mysize = 0;
; 575  : 		}
; 576  : 
; 577  : 	enum _Redbl
; 578  : 		{	// colors for link to parent
; 579  : 		_Red, _Black};
; 580  : 
; 581  : 	static char& _Color(_Nodeptr _Pnode)
; 582  : 		{	// return reference to color in node
; 583  : 		return ((char&)_Pnode->_Color);
; 584  : 		}
; 585  : 
; 586  : 	static char& _Isnil(_Nodeptr _Pnode)
; 587  : 		{	// return reference to nil flag in node
; 588  : 		return ((char&)_Pnode->_Isnil);

  00025	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]

; 589  : 		}
; 590  : 
; 591  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 592  : 		{	// return reference to left pointer in node
; 593  : 		return ((_Nodepref)_Pnode->_Left);
; 594  : 		}
; 595  : 
; 596  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 597  : 		{	// return reference to parent pointer in node
; 598  : 		return ((_Nodepref)_Pnode->_Parent);
; 599  : 		}
; 600  : 
; 601  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 602  : 		{	// return reference to right pointer in node
; 603  : 		return ((_Nodepref)_Pnode->_Right);
; 604  : 		}
; 605  : 
; 606  : 	static reference _Myval(_Nodeptr _Pnode)
; 607  : 		{	// return reference to value in node
; 608  : 		return ((reference)_Pnode->_Myval);
; 609  : 		}
; 610  : 
; 611  : 	static _Nodeptr _Max(_Nodeptr _Pnode)
; 612  : 		{	// return rightmost node in subtree at _Pnode
; 613  : 		while (!_Isnil(_Right(_Pnode)))

  00028	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  0002c	74 f5		 je	 SHORT $LL22@operator

; 97   : 				;	// begin() shouldn't be decremented, don't move
; 98   : 			else
; 99   : 				_Ptr = _Pnode;	// ==> parent if not head

  0002e	89 0a		 mov	 DWORD PTR [edx], ecx

; 100  : 			}
; 101  : 		return (*this);

  00030	8b c2		 mov	 eax, edx

; 102  : 		}

  00032	c3		 ret	 0
$LN40@operator:

; 88   : 			_Ptr = _Mytree::_Max(
; 89   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree
; 90   : 		else
; 91   : 			{	// climb looking for left subtree
; 92   : 			_Nodeptr _Pnode;
; 93   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 94   : 				&& _Ptr == _Mytree::_Left(_Pnode))

  00033	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00036	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  0003a	75 15		 jne	 SHORT $LN3@operator
  0003c	8d 64 24 00	 npad	 4
$LL4@operator:
  00040	8b 02		 mov	 eax, DWORD PTR [edx]
  00042	3b 01		 cmp	 eax, DWORD PTR [ecx]
  00044	75 0b		 jne	 SHORT $LN3@operator

; 95   : 				_Ptr = _Pnode;	// ==> parent while left subtree

  00046	89 0a		 mov	 DWORD PTR [edx], ecx
  00048	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0004b	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  0004f	74 ef		 je	 SHORT $LL4@operator
$LN3@operator:

; 96   : 			if (_Mytree::_Isnil(_Ptr))

  00051	8b 02		 mov	 eax, DWORD PTR [edx]
  00053	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00057	75 02		 jne	 SHORT $LN45@operator
$LN21@operator:

; 97   : 				;	// begin() shouldn't be decremented, don't move
; 98   : 			else
; 99   : 				_Ptr = _Pnode;	// ==> parent if not head

  00059	89 0a		 mov	 DWORD PTR [edx], ecx
$LN45@operator:

; 100  : 			}
; 101  : 		return (*this);

  0005b	8b c2		 mov	 eax, edx

; 102  : 		}

  0005d	c3		 ret	 0
??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >,std::_Iterator_base0>::operator--
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ??$_Resetp0@VEmptyChunk@@@?$shared_ptr@VChunkBase@@@std@@QAEXPAVEmptyChunk@@PAV_Ref_count_base@1@@Z
_TEXT	SEGMENT
__Px$ = 8						; size = 4
__Rx$ = 12						; size = 4
??$_Resetp0@VEmptyChunk@@@?$shared_ptr@VChunkBase@@@std@@QAEXPAVEmptyChunk@@PAV_Ref_count_base@1@@Z PROC ; std::shared_ptr<ChunkBase>::_Resetp0<EmptyChunk>, COMDAT
; _this$ = ecx

; 752  : 		void _Resetp0(_Ux *_Px, _Ref_count_base *_Rx)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	57		 push	 edi

; 129  : 		}
; 130  : 
; 131  : 	long _Use_count() const
; 132  : 		{	// return use count
; 133  : 		return (_Get_uses());
; 134  : 		}
; 135  : 
; 136  : 	bool _Expired() const
; 137  : 		{	// return true if _Uses == 0
; 138  : 		return (_Get_uses() == 0);
; 139  : 		}
; 140  : 
; 141  : 	virtual void *_Get_deleter(const _XSTD2 type_info&) const
; 142  : 		{	// return address of deleter object
; 143  : 		return (0);
; 144  : 		}
; 145  : 	};
; 146  : 
; 147  : 	// TEMPLATE CLASS _Ref_count
; 148  : template<class _Ty>
; 149  : 	class _Ref_count
; 150  : 	: public _Ref_count_base
; 151  : 	{	// handle reference counting for object without deleter
; 152  : public:
; 153  : 	_Ref_count(_Ty *_Px)
; 154  : 		: _Ref_count_base(), _Ptr(_Px)
; 155  : 		{	// construct
; 156  : 		}
; 157  : 
; 158  : private:
; 159  : 	virtual void _Destroy()
; 160  : 		{	// destroy managed resource
; 161  : 		delete _Ptr;
; 162  : 		}
; 163  : 
; 164  : 	virtual void _Delete_this()
; 165  : 		{	// destroy self
; 166  : 		delete this;
; 167  : 		}
; 168  : 
; 169  : 	_Ty * _Ptr;
; 170  : 	};
; 171  : 
; 172  : 	// TEMPLATE CLASS _Ref_count_del
; 173  : template<class _Ty,
; 174  : 	class _Dx>
; 175  : 	class _Ref_count_del
; 176  : 	: public _Ref_count_base
; 177  : 	{	// handle reference counting for object with deleter
; 178  : public:
; 179  : 	_Ref_count_del(_Ty *_Px, _Dx _Dt)
; 180  : 		: _Ref_count_base(), _Ptr(_Px), _Dtor(_Dt)
; 181  : 		{	// construct
; 182  : 		}
; 183  : 
; 184  : 	virtual void *_Get_deleter(const _XSTD2 type_info& _Typeid) const
; 185  : 		{	// return address of deleter object
; 186  : 		return ((void *)(_Typeid == typeid(_Dx) ? &_Dtor : 0));
; 187  : 		}
; 188  : 
; 189  : private:
; 190  : 	virtual void _Destroy()
; 191  : 		{	// destroy managed resource
; 192  : 		_Dtor(_Ptr);
; 193  : 		}
; 194  : 
; 195  : 	virtual void _Delete_this()
; 196  : 		{	// destroy self
; 197  : 		delete this;
; 198  : 		}
; 199  : 
; 200  : 	_Ty * _Ptr;
; 201  : 	_Dx _Dtor;	// the stored destructor for the controlled object
; 202  : 	};
; 203  : 
; 204  : 	// TEMPLATE CLASS _Ref_count_del_alloc
; 205  : template<class _Ty,
; 206  : 	class _Dx,
; 207  : 	class _Alloc>
; 208  : 	class _Ref_count_del_alloc
; 209  : 	: public _Ref_count_base
; 210  : 	{	// handle reference counting for object with deleter and allocator
; 211  : public:
; 212  : 	typedef _Ref_count_del_alloc<_Ty, _Dx, _Alloc> _Myty;
; 213  : 	typedef typename _Alloc::template rebind<_Myty>::other _Myalty;
; 214  : 
; 215  : 	_Ref_count_del_alloc(_Ty *_Px, _Dx _Dt, _Myalty _Al)
; 216  : 		: _Ref_count_base(), _Ptr(_Px), _Dtor(_Dt), _Myal(_Al)
; 217  : 		{	// construct
; 218  : 		}
; 219  : 
; 220  : 	virtual void *_Get_deleter(const _XSTD2 type_info& _Typeid) const
; 221  : 		{	// return address of deleter object
; 222  : 		return ((void *)(_Typeid == typeid(_Dx) ? &_Dtor : 0));
; 223  : 		}
; 224  : 
; 225  : private:
; 226  : 	virtual void _Destroy()
; 227  : 		{	// destroy managed resource
; 228  : 		_Dtor(_Ptr);
; 229  : 		}
; 230  : 
; 231  : 	virtual void _Delete_this()
; 232  : 		{	// destroy self
; 233  : 		_Myalty _Al = _Myal;
; 234  : 		_Al.destroy(this);
; 235  : 		_Al.deallocate(this, 1);
; 236  : 		}
; 237  : 
; 238  : 	_Ty * _Ptr;
; 239  : 	_Dx _Dtor;	// the stored destructor for the controlled object
; 240  : 	_Myalty _Myal;	// the stored allocator for this
; 241  : 	};
; 242  : 
; 243  : 	// DECLARATIONS
; 244  : template<class _Ty>
; 245  : 	class weak_ptr;
; 246  : template<class _Ty>
; 247  : 	class shared_ptr;
; 248  : template<class _Ty>
; 249  : 	class enable_shared_from_this;
; 250  : struct _Static_tag {};
; 251  : struct _Const_tag {};
; 252  : struct _Dynamic_tag {};
; 253  : template<class _Ty1,
; 254  : 	class _Ty2>
; 255  : 	void _Do_enable(_Ty1 *, enable_shared_from_this<_Ty2> *,
; 256  : 		_Ref_count_base *);
; 257  : 
; 258  : template<class _Ty>
; 259  : 	inline void _Enable_shared(_Ty *_Ptr, _Ref_count_base *_Refptr,
; 260  : 		typename _Ty::_EStype * = 0)
; 261  : 	{	// reset internal weak pointer
; 262  : 	if (_Ptr)
; 263  : 		_Do_enable(_Ptr,
; 264  : 			(enable_shared_from_this<typename _Ty::_EStype>*)_Ptr, _Refptr);
; 265  : 	}
; 266  : 
; 267  : inline void _Enable_shared(const volatile void *, const volatile void *)
; 268  : 	{	// not derived from enable_shared_from_this; do nothing
; 269  : 	}
; 270  : 
; 271  : 	// TEMPLATE CLASS _Ptr_base
; 272  : template<class _Ty>
; 273  : 	class _Ptr_base
; 274  : 	{	// base class for shared_ptr and weak_ptr
; 275  : public:
; 276  : 	typedef _Ptr_base<_Ty> _Myt;
; 277  : 	typedef _Ty _Elem;
; 278  : 	typedef _Elem element_type;
; 279  : 
; 280  : 	_Ptr_base()
; 281  : 		: _Ptr(0), _Rep(0)
; 282  : 		{	// construct
; 283  : 		}
; 284  : 
; 285  : 	_Ptr_base(_Myt&& _Right)
; 286  : 		: _Ptr(0), _Rep(0)
; 287  : 		{	// construct _Ptr_base object that takes resource from _Right
; 288  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 289  : 		}
; 290  : 
; 291  : 	template<class _Ty2>
; 292  : 		_Ptr_base(_Ptr_base<_Ty2>&& _Right)
; 293  : 		: _Ptr(_Right._Ptr), _Rep(_Right._Rep)
; 294  : 		{	// construct _Ptr_base object that takes resource from _Right
; 295  : 		_Right._Ptr = 0;
; 296  : 		_Right._Rep = 0;
; 297  : 		}
; 298  : 
; 299  : 	_Myt& operator=(_Myt&& _Right)
; 300  : 		{	// construct _Ptr_base object that takes resource from _Right
; 301  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 302  : 		return (*this);
; 303  : 		}
; 304  : 
; 305  : 	void _Assign_rv(_Myt&& _Right)
; 306  : 		{	// assign by moving _Right
; 307  : 		if (this != &_Right)
; 308  : 			_Swap(_Right);
; 309  : 		}
; 310  : 
; 311  : 	long use_count() const _NOEXCEPT
; 312  : 		{	// return use count
; 313  : 		return (_Rep ? _Rep->_Use_count() : 0);
; 314  : 		}
; 315  : 
; 316  : 	void _Swap(_Ptr_base& _Right)
; 317  : 		{	// swap pointers
; 318  : 		_STD swap(_Rep, _Right._Rep);
; 319  : 		_STD swap(_Ptr, _Right._Ptr);
; 320  : 		}
; 321  : 
; 322  : 	template<class _Ty2>
; 323  : 		bool owner_before(const _Ptr_base<_Ty2>& _Right) const
; 324  : 		{	// compare addresses of manager objects
; 325  : 		return (_Rep < _Right._Rep);
; 326  : 		}
; 327  : 
; 328  : 	void *_Get_deleter(const _XSTD2 type_info& _Typeid) const
; 329  : 		{	// return pointer to deleter object if its type is _Typeid
; 330  : 		return (_Rep ? _Rep->_Get_deleter(_Typeid) : 0);
; 331  : 		}
; 332  : 
; 333  : 	_Ty *_Get() const
; 334  : 		{	// return pointer to resource
; 335  : 		return (_Ptr);
; 336  : 		}
; 337  : 
; 338  : 	bool _Expired() const
; 339  : 		{	// test if expired
; 340  : 		return (!_Rep || _Rep->_Expired());
; 341  : 		}
; 342  : 
; 343  : 	void _Decref()
; 344  : 		{	// decrement reference count
; 345  : 		if (_Rep != 0)
; 346  : 			_Rep->_Decref();
; 347  : 		}
; 348  : 
; 349  : 	void _Reset()
; 350  : 		{	// release resource
; 351  : 		_Reset(0, 0);
; 352  : 		}
; 353  : 
; 354  : 	template<class _Ty2>
; 355  : 		void _Reset(const _Ptr_base<_Ty2>& _Other)
; 356  : 		{	// release resource and take ownership of _Other._Ptr
; 357  : 		_Reset(_Other._Ptr, _Other._Rep);
; 358  : 		}
; 359  : 
; 360  : 	template<class _Ty2>
; 361  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, bool _Throw)
; 362  : 		{	// release resource and take ownership from weak_ptr _Other._Ptr
; 363  : 		_Reset(_Other._Ptr, _Other._Rep, _Throw);
; 364  : 		}
; 365  : 
; 366  : 	template<class _Ty2>
; 367  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Static_tag&)
; 368  : 		{	// release resource and take ownership of _Other._Ptr
; 369  : 		_Reset(static_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 370  : 		}
; 371  : 
; 372  : 	template<class _Ty2>
; 373  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Const_tag&)
; 374  : 		{	// release resource and take ownership of _Other._Ptr
; 375  : 		_Reset(const_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 376  : 		}
; 377  : 
; 378  : 	template<class _Ty2>
; 379  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Dynamic_tag&)
; 380  : 		{	// release resource and take ownership of _Other._Ptr
; 381  : 		_Elem *_Ptr = dynamic_cast<_Elem *>(_Other._Ptr);
; 382  : 		if (_Ptr)
; 383  : 			_Reset(_Ptr, _Other._Rep);
; 384  : 		else
; 385  : 			_Reset();
; 386  : 		}
; 387  : 
; 388  : 	template<class _Ty2>
; 389  : 		void _Reset(auto_ptr<_Ty2>&& _Other)
; 390  : 		{	// release resource and take _Other.get()
; 391  : 		_Ty2 *_Px = _Other.get();
; 392  : 		_Reset0(_Px, new _Ref_count<_Elem>(_Px));
; 393  : 		_Other.release();
; 394  : 		_Enable_shared(_Px, _Rep);
; 395  : 		}
; 396  : 
; 397  :  #if _HAS_CPP0X
; 398  : 	template<class _Ty2>
; 399  : 		void _Reset(_Ty *_Ptr, const _Ptr_base<_Ty2>& _Other)
; 400  : 		{	// release resource and alias _Ptr with _Other_rep
; 401  : 		_Reset(_Ptr, _Other._Rep);
; 402  : 		}
; 403  :  #endif /* _HAS_CPP0X */
; 404  : 
; 405  : 	void _Reset(_Ty *_Other_ptr, _Ref_count_base *_Other_rep)
; 406  : 		{	// release resource and take _Other_ptr through _Other_rep
; 407  : 		if (_Other_rep)
; 408  : 			_Other_rep->_Incref();
; 409  : 		_Reset0(_Other_ptr, _Other_rep);
; 410  : 		}
; 411  : 
; 412  : 	void _Reset(_Ty *_Other_ptr, _Ref_count_base *_Other_rep, bool _Throw)
; 413  : 		{	// take _Other_ptr through _Other_rep from weak_ptr if not expired
; 414  : 			// otherwise, leave in default state if !_Throw,
; 415  : 			// otherwise throw exception
; 416  : 		if (_Other_rep && _Other_rep->_Incref_nz())
; 417  : 			_Reset0(_Other_ptr, _Other_rep);
; 418  : 		else if (_Throw)
; 419  : 			_THROW_NCEE(bad_weak_ptr, 0);
; 420  : 		}
; 421  : 
; 422  : 	void _Reset0(_Ty *_Other_ptr, _Ref_count_base *_Other_rep)
; 423  : 		{	// release resource and take new resource
; 424  : 		if (_Rep != 0)

  00007	8b 7e 04	 mov	 edi, DWORD PTR [esi+4]
  0000a	85 ff		 test	 edi, edi
  0000c	74 38		 je	 SHORT $LN16@Resetp0
  0000e	53		 push	 ebx

; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  0000f	83 cb ff	 or	 ebx, -1
  00012	8d 57 04	 lea	 edx, DWORD PTR [edi+4]
  00015	8b c3		 mov	 eax, ebx
  00017	f0 0f c1 02	 lock	  xadd	 DWORD PTR [edx], eax
  0001b	75 17		 jne	 SHORT $LN15@Resetp0

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  0001d	8b 07		 mov	 eax, DWORD PTR [edi]
  0001f	8b cf		 mov	 ecx, edi
  00021	ff 10		 call	 DWORD PTR [eax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  00023	8d 47 08	 lea	 eax, DWORD PTR [edi+8]
  00026	f0 0f c1 18	 lock	  xadd	 DWORD PTR [eax], ebx
  0002a	4b		 dec	 ebx
  0002b	75 07		 jne	 SHORT $LN15@Resetp0

; 128  : 			_Delete_this();

  0002d	8b 07		 mov	 eax, DWORD PTR [edi]
  0002f	8b cf		 mov	 ecx, edi
  00031	ff 50 04	 call	 DWORD PTR [eax+4]
$LN15@Resetp0:

; 425  : 			_Rep->_Decref();
; 426  : 		_Rep = _Other_rep;

  00034	8b 45 0c	 mov	 eax, DWORD PTR __Rx$[ebp]
  00037	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 427  : 		_Ptr = _Other_ptr;

  0003a	8b 45 08	 mov	 eax, DWORD PTR __Px$[ebp]
  0003d	5b		 pop	 ebx
  0003e	5f		 pop	 edi
  0003f	89 06		 mov	 DWORD PTR [esi], eax
  00041	5e		 pop	 esi

; 753  : 		{	// release resource and take ownership of _Px
; 754  : 		this->_Reset0(_Px, _Rx);
; 755  : 		_Enable_shared(_Px, _Rx);
; 756  : 		}

  00042	5d		 pop	 ebp
  00043	c2 08 00	 ret	 8
$LN16@Resetp0:

; 425  : 			_Rep->_Decref();
; 426  : 		_Rep = _Other_rep;

  00046	8b 45 0c	 mov	 eax, DWORD PTR __Rx$[ebp]
  00049	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 427  : 		_Ptr = _Other_ptr;

  0004c	8b 45 08	 mov	 eax, DWORD PTR __Px$[ebp]
  0004f	5f		 pop	 edi
  00050	89 06		 mov	 DWORD PTR [esi], eax
  00052	5e		 pop	 esi

; 753  : 		{	// release resource and take ownership of _Px
; 754  : 		this->_Reset0(_Px, _Rx);
; 755  : 		_Enable_shared(_Px, _Rx);
; 756  : 		}

  00053	5d		 pop	 ebp
  00054	c2 08 00	 ret	 8
??$_Resetp0@VEmptyChunk@@@?$shared_ptr@VChunkBase@@@std@@QAEXPAVEmptyChunk@@PAV_Ref_count_base@1@@Z ENDP ; std::shared_ptr<ChunkBase>::_Resetp0<EmptyChunk>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@U?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@2@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@std@@@std@@@std@@QAEXPAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@$$QAU?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__V0$ = 12						; size = 4
??$construct@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@U?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@2@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@std@@@std@@@std@@QAEXPAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@$$QAU?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void *> > >::construct<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::pair<ChunkPosition,std::shared_ptr<ChunkBase> > >, COMDAT
; _this$dead$ = ecx

; 903  : _VARIADIC_EXPAND_0X(_WRAP_ALLOC_CONSTRUCT, , , , )

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 617  : _VARIADIC_EXPAND_0X(_ALLOC_MEMBER_CONSTRUCT, , , , )

  00003	8b 55 08	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00006	85 d2		 test	 edx, edx
  00008	74 40		 je	 SHORT $LN44@construct
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility

; 182  : 		{	// construct from moved compatible pair

  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR __V0$[ebp]
  0000d	83 c2 0c	 add	 edx, 12			; 0000000cH
  00010	f3 0f 7e 01	 movq	 xmm0, QWORD PTR [ecx]
  00014	66 0f d6 42 f4	 movq	 QWORD PTR [edx-12], xmm0
  00019	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  0001c	89 42 fc	 mov	 DWORD PTR [edx-4], eax
  0001f	56		 push	 esi
  00020	8d 71 0c	 lea	 esi, DWORD PTR [ecx+12]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 287  : 		{	// construct _Ptr_base object that takes resource from _Right

  00023	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0
  00029	c7 42 04 00 00
	00 00		 mov	 DWORD PTR [edx+4], 0

; 288  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 289  : 		}
; 290  : 
; 291  : 	template<class _Ty2>
; 292  : 		_Ptr_base(_Ptr_base<_Ty2>&& _Right)
; 293  : 		: _Ptr(_Right._Ptr), _Rep(_Right._Rep)
; 294  : 		{	// construct _Ptr_base object that takes resource from _Right
; 295  : 		_Right._Ptr = 0;
; 296  : 		_Right._Rep = 0;
; 297  : 		}
; 298  : 
; 299  : 	_Myt& operator=(_Myt&& _Right)
; 300  : 		{	// construct _Ptr_base object that takes resource from _Right
; 301  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 302  : 		return (*this);
; 303  : 		}
; 304  : 
; 305  : 	void _Assign_rv(_Myt&& _Right)
; 306  : 		{	// assign by moving _Right
; 307  : 		if (this != &_Right)

  00030	3b d6		 cmp	 edx, esi
  00032	74 15		 je	 SHORT $LN52@construct
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility

; 48   : 	_Left = _Move(_Right);

  00034	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00037	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 49   : 	_Right = _Move(_Tmp);

  0003a	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 48   : 	_Left = _Move(_Right);

  00041	8b 06		 mov	 eax, DWORD PTR [esi]
  00043	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00045	89 02		 mov	 DWORD PTR [edx], eax

; 49   : 	_Right = _Move(_Tmp);

  00047	89 0e		 mov	 DWORD PTR [esi], ecx
$LN52@construct:
  00049	5e		 pop	 esi
$LN44@construct:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 903  : _VARIADIC_EXPAND_0X(_WRAP_ALLOC_CONSTRUCT, , , , )

  0004a	5d		 pop	 ebp
  0004b	c2 08 00	 ret	 8
??$construct@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@U?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@2@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@std@@@std@@@std@@QAEXPAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@$$QAU?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void *> > >::construct<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::pair<ChunkPosition,std::shared_ptr<ChunkBase> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\type_traits
;	COMDAT ??$forward@AAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@YAAAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@0@AAU10@@Z
_TEXT	SEGMENT
??$forward@AAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@YAAAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@0@AAU10@@Z PROC ; std::forward<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > &>, COMDAT
; __Arg$ = ecx

; 1776 : 	return (static_cast<_Ty&&>(_Arg));

  00000	8b c1		 mov	 eax, ecx

; 1777 : 	}

  00002	c3		 ret	 0
??$forward@AAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@YAAAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@0@AAU10@@Z ENDP ; std::forward<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
;	COMDAT ??$_Insert_at@AAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@_NPAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@1@AAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@1@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Addleft$ = 12						; size = 1
__Wherenode$ = 16					; size = 4
__Val$dead$ = 20					; size = 4
__Node$ = 24						; size = 4
??$_Insert_at@AAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@_NPAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@1@AAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@1@Z PROC ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Insert_at<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > &,std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void *> *>, COMDAT
; _this$ = ecx

; 1836 : 		iterator _Insert_at(bool _Addleft, _Nodeptr _Wherenode,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 604  : 		}
; 605  : 
; 606  : 	static reference _Myval(_Nodeptr _Pnode)
; 607  : 		{	// return reference to value in node
; 608  : 		return ((reference)_Pnode->_Myval);

  00004	8b 5d 18	 mov	 ebx, DWORD PTR __Node$[ebp]
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1836 : 		iterator _Insert_at(bool _Addleft, _Nodeptr _Wherenode,

  00009	8b f9		 mov	 edi, ecx

; 1837 : 		_Valty&& _Val, _Nodety _Node)
; 1838 : 		{	// add node with value next to _Wherenode, to left if _Addleft
; 1839 : 		if (max_size() - 1 <= this->_Mysize)

  0000b	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0000e	3d c6 71 1c 07	 cmp	 eax, 119304646		; 071c71c6H
  00013	72 36		 jb	 SHORT $LN17@Insert_at
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  00015	8b 73 20	 mov	 esi, DWORD PTR [ebx+32]
  00018	85 f6		 test	 esi, esi
  0001a	0f 84 0d 02 00
	00		 je	 $LN57@Insert_at

; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  00020	83 cf ff	 or	 edi, -1
  00023	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  00026	8b c7		 mov	 eax, edi
  00028	f0 0f c1 01	 lock	  xadd	 DWORD PTR [ecx], eax
  0002c	0f 85 fb 01 00
	00		 jne	 $LN57@Insert_at

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  00032	8b 06		 mov	 eax, DWORD PTR [esi]
  00034	8b ce		 mov	 ecx, esi
  00036	ff 10		 call	 DWORD PTR [eax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  00038	8d 46 08	 lea	 eax, DWORD PTR [esi+8]
  0003b	f0 0f c1 38	 lock	  xadd	 DWORD PTR [eax], edi
  0003f	4f		 dec	 edi
  00040	0f 85 e7 01 00
	00		 jne	 $LN57@Insert_at
  00046	e9 db 01 00 00	 jmp	 $LN417@Insert_at
$LN17@Insert_at:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree

; 1847 : 		++this->_Mysize;

  0004b	40		 inc	 eax
  0004c	89 47 04	 mov	 DWORD PTR [edi+4], eax

; 1848 : 		_Newnode->_Parent = _Wherenode;

  0004f	8b 45 10	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  00052	89 43 04	 mov	 DWORD PTR [ebx+4], eax

; 1849 : 
; 1850 : 		if (_Wherenode == this->_Myhead)

  00055	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00057	3b c1		 cmp	 eax, ecx
  00059	75 0e		 jne	 SHORT $LN16@Insert_at

; 1851 : 			{	// first node in tree, just set head values
; 1852 : 			_Root() = _Newnode;

  0005b	89 59 04	 mov	 DWORD PTR [ecx+4], ebx

; 589  : 		}
; 590  : 
; 591  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 592  : 		{	// return reference to left pointer in node
; 593  : 		return ((_Nodepref)_Pnode->_Left);

  0005e	8b 07		 mov	 eax, DWORD PTR [edi]

; 1853 : 			_Lmost() = _Newnode;

  00060	89 18		 mov	 DWORD PTR [eax], ebx

; 1854 : 			_Rmost() = _Newnode;

  00062	8b 07		 mov	 eax, DWORD PTR [edi]
  00064	89 58 08	 mov	 DWORD PTR [eax+8], ebx
  00067	eb 1f		 jmp	 SHORT $LN11@Insert_at
$LN16@Insert_at:

; 1855 : 			}
; 1856 : 		else if (_Addleft)

  00069	80 7d 0c 00	 cmp	 BYTE PTR __Addleft$[ebp], 0
  0006d	74 0c		 je	 SHORT $LN14@Insert_at

; 1857 : 			{	// add to left of _Wherenode
; 1858 : 			this->_Left(_Wherenode) = _Newnode;

  0006f	89 18		 mov	 DWORD PTR [eax], ebx

; 589  : 		}
; 590  : 
; 591  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 592  : 		{	// return reference to left pointer in node
; 593  : 		return ((_Nodepref)_Pnode->_Left);

  00071	8b 0f		 mov	 ecx, DWORD PTR [edi]

; 1859 : 			if (_Wherenode == _Lmost())

  00073	3b 01		 cmp	 eax, DWORD PTR [ecx]
  00075	75 11		 jne	 SHORT $LN11@Insert_at

; 1860 : 				_Lmost() = _Newnode;

  00077	89 19		 mov	 DWORD PTR [ecx], ebx

; 1861 : 			}
; 1862 : 		else

  00079	eb 0d		 jmp	 SHORT $LN11@Insert_at
$LN14@Insert_at:

; 1863 : 			{	// add to right of _Wherenode
; 1864 : 			this->_Right(_Wherenode) = _Newnode;

  0007b	89 58 08	 mov	 DWORD PTR [eax+8], ebx

; 599  : 		}
; 600  : 
; 601  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 602  : 		{	// return reference to right pointer in node
; 603  : 		return ((_Nodepref)_Pnode->_Right);

  0007e	8b 0f		 mov	 ecx, DWORD PTR [edi]

; 1865 : 			if (_Wherenode == _Rmost())

  00080	3b 41 08	 cmp	 eax, DWORD PTR [ecx+8]
  00083	75 03		 jne	 SHORT $LN11@Insert_at

; 1866 : 				_Rmost() = _Newnode;

  00085	89 59 08	 mov	 DWORD PTR [ecx+8], ebx
$LN11@Insert_at:

; 1867 : 			}
; 1868 : 
; 1869 : 		for (_Nodeptr _Pnode = _Newnode;
; 1870 : 			this->_Color(this->_Parent(_Pnode)) == this->_Red; )

  00088	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  0008b	8b c3		 mov	 eax, ebx
  0008d	80 79 0c 00	 cmp	 BYTE PTR [ecx+12], 0
  00091	0f 85 7a 01 00
	00		 jne	 $LN9@Insert_at
$LL10@Insert_at:

; 594  : 		}
; 595  : 
; 596  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 597  : 		{	// return reference to parent pointer in node
; 598  : 		return ((_Nodepref)_Pnode->_Parent);

  00097	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]

; 589  : 		}
; 590  : 
; 591  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 592  : 		{	// return reference to left pointer in node
; 593  : 		return ((_Nodepref)_Pnode->_Left);

  0009a	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]

; 1871 : 			if (this->_Parent(_Pnode)
; 1872 : 				== this->_Left(this->_Parent(this->_Parent(_Pnode))))

  0009d	8b 16		 mov	 edx, DWORD PTR [esi]
  0009f	3b ca		 cmp	 ecx, edx
  000a1	0f 85 ab 00 00
	00		 jne	 $LN8@Insert_at

; 1873 : 				{	// fixup red-red in left subtree
; 1874 : 				_Wherenode =
; 1875 : 					this->_Right(this->_Parent(this->_Parent(_Pnode)));

  000a7	8b 56 08	 mov	 edx, DWORD PTR [esi+8]

; 1876 : 				if (this->_Color(_Wherenode) == this->_Red)

  000aa	80 7a 0c 00	 cmp	 BYTE PTR [edx+12], 0
  000ae	0f 84 a4 00 00
	00		 je	 $LN416@Insert_at

; 1877 : 					{	// parent has two red children, blacken both
; 1878 : 					this->_Color(this->_Parent(_Pnode)) = this->_Black;
; 1879 : 					this->_Color(_Wherenode) = this->_Black;
; 1880 : 					this->_Color(this->_Parent(this->_Parent(_Pnode)))
; 1881 : 						= this->_Red;
; 1882 : 					_Pnode = this->_Parent(this->_Parent(_Pnode));
; 1883 : 					}
; 1884 : 				else
; 1885 : 					{	// parent has red and black children
; 1886 : 					if (_Pnode == this->_Right(this->_Parent(_Pnode)))

  000b4	3b 41 08	 cmp	 eax, DWORD PTR [ecx+8]
  000b7	75 3a		 jne	 SHORT $LN149@Insert_at

; 1887 : 						{	// rotate right child to left
; 1888 : 						_Pnode = this->_Parent(_Pnode);

  000b9	8b c1		 mov	 eax, ecx

; 1928 : 
; 1929 : 	template<class _Moveit>
; 1930 : 		void _Copy(const _Myt& _Right,
; 1931 : 			_Moveit _Movefl)
; 1932 : 		{	// copy or move entire tree from _Right
; 1933 : 		_Root() = _Copy_nodes(_Right._Root(), this->_Myhead, _Movefl);
; 1934 : 		this->_Mysize = _Right.size();
; 1935 : 		if (!this->_Isnil(_Root()))
; 1936 : 			{	// nonempty tree, look for new smallest and largest
; 1937 : 			_Lmost() = this->_Min(_Root());
; 1938 : 			_Rmost() = this->_Max(_Root());
; 1939 : 			}
; 1940 : 		else
; 1941 : 			{	// empty tree, just tidy head pointers
; 1942 : 			_Lmost() = this->_Myhead;
; 1943 : 			_Rmost() = this->_Myhead;
; 1944 : 			}
; 1945 : 		}
; 1946 : 
; 1947 : template<class _Want_to_move,
; 1948 : 	class _Can_move>
; 1949 : 	_Nodeptr _Copy_or_move(_Nodeptr _Rootnode, _Want_to_move, _Can_move)
; 1950 : 		{	// copy to new node
; 1951 : 		return (this->_Buynode(this->_Myval(_Rootnode)));
; 1952 : 		}
; 1953 : 
; 1954 : 	_Nodeptr _Copy_or_move(_Nodeptr _Rootnode, true_type, true_type)
; 1955 : 		{	// move to new node -- movable
; 1956 : 		return (this->_Buynode(
; 1957 : 			_STD forward<value_type>(this->_Myval(_Rootnode))));
; 1958 : 		}
; 1959 : 
; 1960 : 	template<class _Moveit>
; 1961 : 		_Nodeptr _Copy_nodes(_Nodeptr _Rootnode, _Nodeptr _Wherenode,
; 1962 : 			_Moveit _Movefl)
; 1963 : 		{	// copy entire subtree, recursively
; 1964 : 		_Nodeptr _Newroot = this->_Myhead;	// point at nil node
; 1965 : 
; 1966 : 		if (!this->_Isnil(_Rootnode))
; 1967 : 			{	// copy or move a node, then any subtrees
; 1968 : 			_Nodeptr _Pnode = _Copy_or_move(_Rootnode, _Movefl,
; 1969 : 				typename is_move_constructible<value_type>::type());
; 1970 : 			_Pnode->_Parent = _Wherenode;
; 1971 : 			_Pnode->_Color = this->_Color(_Rootnode);
; 1972 : 			if (this->_Isnil(_Newroot))
; 1973 : 				_Newroot = _Pnode;	// memorize new root
; 1974 : 
; 1975 : 			_TRY_BEGIN
; 1976 : 			this->_Left(_Pnode) =
; 1977 : 				_Copy_nodes(this->_Left(_Rootnode), _Pnode, _Movefl);
; 1978 : 			this->_Right(_Pnode) =
; 1979 : 				_Copy_nodes(this->_Right(_Rootnode), _Pnode, _Movefl);
; 1980 : 			_CATCH_ALL
; 1981 : 			_Erase(_Newroot);	// subtree copy failed, bail out
; 1982 : 			_RERAISE;
; 1983 : 			_CATCH_END
; 1984 : 			}
; 1985 : 
; 1986 : 		return (_Newroot);	// return newly constructed tree
; 1987 : 		}
; 1988 : 
; 1989 : 	_Paircc _Eqrange(const key_type& _Keyval) const
; 1990 : 		{	// find leftmost node not less than _Keyval
; 1991 : 		_Nodeptr _Pnode = _Root();
; 1992 : 		_Nodeptr _Lonode = this->_Myhead;	// end() if search fails
; 1993 : 		_Nodeptr _Hinode = this->_Myhead;	// end() if search fails
; 1994 : 
; 1995 : 		while (!this->_Isnil(_Pnode))
; 1996 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))
; 1997 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 1998 : 			else
; 1999 : 				{	// _Pnode not less than _Keyval, remember it
; 2000 : 				if (this->_Isnil(_Hinode)
; 2001 : 						&& _DEBUG_LT_PRED(this->_Getcomp(), _Keyval,
; 2002 : 						this->_Key(_Pnode)))
; 2003 : 					_Hinode = _Pnode;	// _Pnode greater, remember it
; 2004 : 				_Lonode = _Pnode;
; 2005 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2006 : 				}
; 2007 : 
; 2008 : 		_Pnode = this->_Isnil(_Hinode) ? _Root()
; 2009 : 			: this->_Left(_Hinode);	// continue scan for upper bound
; 2010 : 		while (!this->_Isnil(_Pnode))
; 2011 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), _Keyval, this->_Key(_Pnode)))
; 2012 : 				{	// _Pnode greater than _Keyval, remember it
; 2013 : 				_Hinode = _Pnode;
; 2014 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2015 : 				}
; 2016 : 			else
; 2017 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2018 : 
; 2019 : 		const_iterator _First = const_iterator(_Lonode, this);
; 2020 : 		const_iterator _Last = const_iterator(_Hinode, this);
; 2021 : 		return (_Paircc(_First, _Last));
; 2022 : 		}
; 2023 : 
; 2024 : 	_Pairii _Eqrange(const key_type& _Keyval)
; 2025 : 		{	// find leftmost node not less than _Keyval
; 2026 : 		_Nodeptr _Pnode = _Root();
; 2027 : 		_Nodeptr _Lonode = this->_Myhead;	// end() if search fails
; 2028 : 		_Nodeptr _Hinode = this->_Myhead;	// end() if search fails
; 2029 : 
; 2030 : 		while (!this->_Isnil(_Pnode))
; 2031 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))
; 2032 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2033 : 			else
; 2034 : 				{	// _Pnode not less than _Keyval, remember it
; 2035 : 				if (this->_Isnil(_Hinode)
; 2036 : 						&& _DEBUG_LT_PRED(this->_Getcomp(), _Keyval,
; 2037 : 						 this->_Key(_Pnode)))
; 2038 : 					_Hinode = _Pnode;	// _Pnode greater, remember it
; 2039 : 				_Lonode = _Pnode;
; 2040 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2041 : 				}
; 2042 : 
; 2043 : 		_Pnode = this->_Isnil(_Hinode) ? _Root()
; 2044 : 			: this->_Left(_Hinode);	// continue scan for upper bound
; 2045 : 		while (!this->_Isnil(_Pnode))
; 2046 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), _Keyval, this->_Key(_Pnode)))
; 2047 : 				{	// _Pnode greater than _Keyval, remember it
; 2048 : 				_Hinode = _Pnode;
; 2049 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2050 : 				}
; 2051 : 			else
; 2052 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2053 : 
; 2054 : 		iterator _First = iterator(_Lonode, this);
; 2055 : 		iterator _Last = iterator(_Hinode, this);
; 2056 : 		return (_Pairii(_First, _Last));
; 2057 : 		}
; 2058 : 
; 2059 : 	void _Erase(_Nodeptr _Rootnode)
; 2060 : 		{	// free entire subtree, recursively
; 2061 : 		for (_Nodeptr _Pnode = _Rootnode;
; 2062 : 			!this->_Isnil(_Pnode); _Rootnode = _Pnode)
; 2063 : 			{	// free subtrees, then node
; 2064 : 			_Erase(this->_Right(_Pnode));
; 2065 : 			_Pnode = this->_Left(_Pnode);
; 2066 : 			this->_Getal().destroy(
; 2067 : 				_STD addressof(this->_Myval(_Rootnode)));
; 2068 : 
; 2069 : 			this->_Getal().deallocate(_Rootnode, 1);
; 2070 : 			}
; 2071 : 		}
; 2072 : 
; 2073 : 	_Nodeptr _Lbound(const key_type& _Keyval) const
; 2074 : 		{	// find leftmost node not less than _Keyval
; 2075 : 		_Nodeptr _Pnode = _Root();
; 2076 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails
; 2077 : 
; 2078 : 		while (!this->_Isnil(_Pnode))
; 2079 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))
; 2080 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2081 : 			else
; 2082 : 				{	// _Pnode not less than _Keyval, remember it
; 2083 : 				_Wherenode = _Pnode;
; 2084 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2085 : 				}
; 2086 : 
; 2087 : 		return (_Wherenode);	// return best remembered candidate
; 2088 : 		}
; 2089 : 
; 2090 : 	_Nodeptr _Lbound(const key_type& _Keyval)
; 2091 : 		{	// find leftmost node not less than _Keyval
; 2092 : 		_Nodeptr _Pnode = _Root();
; 2093 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails
; 2094 : 
; 2095 : 		while (!this->_Isnil(_Pnode))
; 2096 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))
; 2097 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2098 : 			else
; 2099 : 				{	// _Pnode not less than _Keyval, remember it
; 2100 : 				_Wherenode = _Pnode;
; 2101 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2102 : 				}
; 2103 : 
; 2104 : 		return (_Wherenode);	// return best remembered candidate
; 2105 : 		}
; 2106 : 
; 2107 : 	_Nodeptr& _Lmost() const
; 2108 : 		{	// return leftmost node in nonmutable tree
; 2109 : 		return (this->_Left(this->_Myhead));
; 2110 : 		}
; 2111 : 
; 2112 : 	void _Lrotate(_Nodeptr _Wherenode)
; 2113 : 		{	// promote right node to root of subtree
; 2114 : 		_Nodeptr _Pnode = this->_Right(_Wherenode);

  000bb	8b 50 08	 mov	 edx, DWORD PTR [eax+8]

; 2115 : 		this->_Right(_Wherenode) = this->_Left(_Pnode);

  000be	8b 0a		 mov	 ecx, DWORD PTR [edx]
  000c0	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 45   : 		this->_Adopt(_Plist);
; 46   : 		}
; 47   : 
; 48   : 	reference operator*() const
; 49   : 		{	// return designated value
; 50   : 		return (_Mytree::_Myval(_Ptr));
; 51   : 		}
; 52   : 
; 53   : 	pointer operator->() const
; 54   : 		{	// return pointer to class object
; 55   : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 56   : 		}
; 57   : 
; 58   : 	_Myiter& operator++()
; 59   : 		{	// preincrement
; 60   : 		if (_Mytree::_Isnil(_Ptr))
; 61   : 			;	// end() shouldn't be incremented, don't move
; 62   : 		else if (!_Mytree::_Isnil(_Mytree::_Right(_Ptr)))
; 63   : 			_Ptr = _Mytree::_Min(
; 64   : 				_Mytree::_Right(_Ptr));	// ==> smallest of right subtree
; 65   : 		else
; 66   : 			{	// climb looking for right subtree
; 67   : 			_Nodeptr _Pnode;
; 68   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 69   : 				&& _Ptr == _Mytree::_Right(_Pnode))
; 70   : 				_Ptr = _Pnode;	// ==> parent while right subtree
; 71   : 			_Ptr = _Pnode;	// ==> parent (head if end())
; 72   : 			}
; 73   : 		return (*this);
; 74   : 		}
; 75   : 
; 76   : 	_Myiter operator++(int)
; 77   : 		{	// postincrement
; 78   : 		_Myiter _Tmp = *this;
; 79   : 		++*this;
; 80   : 		return (_Tmp);
; 81   : 		}
; 82   : 
; 83   : 	_Myiter& operator--()
; 84   : 		{	// predecrement
; 85   : 		if (_Mytree::_Isnil(_Ptr))
; 86   : 			_Ptr = _Mytree::_Right(_Ptr);	// end() ==> rightmost
; 87   : 		else if (!_Mytree::_Isnil(_Mytree::_Left(_Ptr)))
; 88   : 			_Ptr = _Mytree::_Max(
; 89   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree
; 90   : 		else
; 91   : 			{	// climb looking for left subtree
; 92   : 			_Nodeptr _Pnode;
; 93   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 94   : 				&& _Ptr == _Mytree::_Left(_Pnode))
; 95   : 				_Ptr = _Pnode;	// ==> parent while left subtree
; 96   : 			if (_Mytree::_Isnil(_Ptr))
; 97   : 				;	// begin() shouldn't be decremented, don't move
; 98   : 			else
; 99   : 				_Ptr = _Pnode;	// ==> parent if not head
; 100  : 			}
; 101  : 		return (*this);
; 102  : 		}
; 103  : 
; 104  : 	_Myiter operator--(int)
; 105  : 		{	// postdecrement
; 106  : 		_Myiter _Tmp = *this;
; 107  : 		--*this;
; 108  : 		return (_Tmp);
; 109  : 		}
; 110  : 
; 111  : 	bool operator==(const _Myiter& _Right) const
; 112  : 		{	// test for iterator equality
; 113  : 		return (_Ptr == _Right._Ptr);
; 114  : 		}
; 115  : 
; 116  : 	bool operator!=(const _Myiter& _Right) const
; 117  : 		{	// test for iterator inequality
; 118  : 		return (!(*this == _Right));
; 119  : 		}
; 120  : 
; 121  : 	_Nodeptr _Mynode() const
; 122  : 		{	// return node pointer
; 123  : 		return (_Ptr);
; 124  : 		}
; 125  : 
; 126  : 	_Nodeptr _Ptr;	// pointer to node
; 127  : 	};
; 128  : 
; 129  : 	// TEMPLATE CLASS _Tree_unchecked_iterator
; 130  : template<class _Mytree>
; 131  : 	class _Tree_unchecked_iterator
; 132  : 		: public _Tree_unchecked_const_iterator<_Mytree>
; 133  : 	{	// unchecked iterator for mutable tree
; 134  : public:
; 135  : 	typedef _Tree_unchecked_iterator<_Mytree> _Myiter;
; 136  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Mybase;
; 137  : 	typedef bidirectional_iterator_tag iterator_category;
; 138  : 
; 139  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 140  : 	typedef typename _Mytree::value_type value_type;
; 141  : 	typedef typename _Mytree::difference_type difference_type;
; 142  : 	typedef typename _Mytree::pointer pointer;
; 143  : 	typedef typename _Mytree::reference reference;
; 144  : 
; 145  : 	_Tree_unchecked_iterator()
; 146  : 		{	// construct with null node
; 147  : 		}
; 148  : 
; 149  : 	_Tree_unchecked_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 150  : 		: _Mybase(_Pnode, _Plist)
; 151  : 		{	// construct with node pointer _Pnode
; 152  : 		}
; 153  : 
; 154  : 	reference operator*() const
; 155  : 		{	// return designated value
; 156  : 		return ((reference)**(_Mybase *)this);
; 157  : 		}
; 158  : 
; 159  : 	pointer operator->() const
; 160  : 		{	// return pointer to class object
; 161  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 162  : 		}
; 163  : 
; 164  : 	_Myiter& operator++()
; 165  : 		{	// preincrement
; 166  : 		++(*(_Mybase *)this);
; 167  : 		return (*this);
; 168  : 		}
; 169  : 
; 170  : 	_Myiter operator++(int)
; 171  : 		{	// postincrement
; 172  : 		_Myiter _Tmp = *this;
; 173  : 		++*this;
; 174  : 		return (_Tmp);
; 175  : 		}
; 176  : 
; 177  : 	_Myiter& operator--()
; 178  : 		{	// predecrement
; 179  : 		--(*(_Mybase *)this);
; 180  : 		return (*this);
; 181  : 		}
; 182  : 
; 183  : 	_Myiter operator--(int)
; 184  : 		{	// postdecrement
; 185  : 		_Myiter _Tmp = *this;
; 186  : 		--*this;
; 187  : 		return (_Tmp);
; 188  : 		}
; 189  : 	};
; 190  : 
; 191  : 	// TEMPLATE CLASS _Tree_const_iterator
; 192  : template<class _Mytree>
; 193  : 	class _Tree_const_iterator
; 194  : 		: public _Tree_unchecked_const_iterator<_Mytree, _Iterator_base>
; 195  : 	{	// iterator for nonmutable tree
; 196  : public:
; 197  : 	typedef _Tree_const_iterator<_Mytree> _Myiter;
; 198  : 	typedef _Tree_unchecked_const_iterator<_Mytree, _Iterator_base> _Mybase;
; 199  : 	typedef bidirectional_iterator_tag iterator_category;
; 200  : 
; 201  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 202  : 	typedef typename _Mytree::value_type value_type;
; 203  : 	typedef typename _Mytree::difference_type difference_type;
; 204  : 	typedef typename _Mytree::const_pointer pointer;
; 205  : 	typedef typename _Mytree::const_reference reference;
; 206  : 
; 207  : 	_Tree_const_iterator()
; 208  : 		: _Mybase()
; 209  : 		{	// construct with null node pointer
; 210  : 		}
; 211  : 
; 212  : 	_Tree_const_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 213  : 		: _Mybase(_Pnode, _Plist)
; 214  : 		{	// construct with node pointer _Pnode
; 215  : 		}
; 216  : 
; 217  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Unchecked_type;
; 218  : 
; 219  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 220  : 		{	// reset from unchecked iterator
; 221  : 		this->_Ptr = _Right._Ptr;
; 222  : 		return (*this);
; 223  : 		}
; 224  : 
; 225  : 	_Unchecked_type _Unchecked() const
; 226  : 		{	// make an unchecked iterator
; 227  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 228  : 		}
; 229  : 
; 230  : 	reference operator*() const
; 231  : 		{	// return designated value
; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		if (this->_Getcont() == 0
; 234  : 			|| this->_Ptr == 0
; 235  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 236  : 			{	// report error
; 237  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 238  : 			_SCL_SECURE_OUT_OF_RANGE;
; 239  : 			}
; 240  : 
; 241  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 242  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 243  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 244  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 245  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 246  : 
; 247  : 		return (_Mytree::_Myval(this->_Ptr));
; 248  : 		}
; 249  : 
; 250  : 	pointer operator->() const
; 251  : 		{	// return pointer to class object
; 252  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 253  : 		}
; 254  : 
; 255  : 	_Myiter& operator++()
; 256  : 		{	// preincrement
; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);
; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);
; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  :  #if _HAS_CPP0X
; 520  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 521  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 522  : 
; 523  :  #else /* _HAS_CPP0X */
; 524  : 	typedef typename _Alloc::template rebind<_Ty>::other _Alty;
; 525  :  #endif /* _HAS_CPP0X */
; 526  : 
; 527  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 528  : 		_Voidptr;
; 529  : 	typedef _Tree_node<typename _Alty::value_type,
; 530  : 		_Voidptr> _Node;
; 531  : 
; 532  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 533  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 534  : 	typedef _Nodeptr& _Nodepref;
; 535  : 
; 536  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 537  : 		_Tree_simple_types<typename _Alty::value_type>,
; 538  : 		_Tree_iter_types<typename _Alty::value_type,
; 539  : 			typename _Alty::size_type,
; 540  : 			typename _Alty::difference_type,
; 541  : 			typename _Alty::pointer,
; 542  : 			typename _Alty::const_pointer,
; 543  : 			typename _Alty::reference,
; 544  : 			typename _Alty::const_reference,
; 545  : 			_Nodeptr> >::type
; 546  : 		_Val_types;
; 547  : 	};
; 548  : 
; 549  : 		// TEMPLATE CLASS _Tree_val
; 550  : template<class _Val_types>
; 551  : 	class _Tree_val
; 552  : 		: public _Container_base
; 553  : 	{	// base class for tree to hold data
; 554  : public:
; 555  : 	typedef _Tree_val<_Val_types> _Myt;
; 556  : 
; 557  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 558  : 	typedef _Nodeptr& _Nodepref;
; 559  : 
; 560  : 	typedef typename _Val_types::value_type value_type;
; 561  : 	typedef typename _Val_types::size_type size_type;
; 562  : 	typedef typename _Val_types::difference_type difference_type;
; 563  : 	typedef typename _Val_types::pointer pointer;
; 564  : 	typedef typename _Val_types::const_pointer const_pointer;
; 565  : 	typedef typename _Val_types::reference reference;
; 566  : 	typedef typename _Val_types::const_reference const_reference;
; 567  : 
; 568  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 569  : 	typedef _Tree_iterator<_Myt> iterator;
; 570  : 
; 571  : 	_Tree_val()
; 572  : 		{	// initialize data
; 573  : 		this->_Myhead = 0;
; 574  : 		this->_Mysize = 0;
; 575  : 		}
; 576  : 
; 577  : 	enum _Redbl
; 578  : 		{	// colors for link to parent
; 579  : 		_Red, _Black};
; 580  : 
; 581  : 	static char& _Color(_Nodeptr _Pnode)
; 582  : 		{	// return reference to color in node
; 583  : 		return ((char&)_Pnode->_Color);
; 584  : 		}
; 585  : 
; 586  : 	static char& _Isnil(_Nodeptr _Pnode)
; 587  : 		{	// return reference to nil flag in node
; 588  : 		return ((char&)_Pnode->_Isnil);

  000c3	8b 0a		 mov	 ecx, DWORD PTR [edx]

; 2116 : 
; 2117 : 		if (!this->_Isnil(this->_Left(_Pnode)))

  000c5	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  000c9	75 03		 jne	 SHORT $LN148@Insert_at

; 2118 : 			this->_Parent(this->_Left(_Pnode)) = _Wherenode;

  000cb	89 41 04	 mov	 DWORD PTR [ecx+4], eax
$LN148@Insert_at:

; 2119 : 		this->_Parent(_Pnode) = this->_Parent(_Wherenode);

  000ce	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000d1	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 594  : 		}
; 595  : 
; 596  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 597  : 		{	// return reference to parent pointer in node
; 598  : 		return ((_Nodepref)_Pnode->_Parent);

  000d4	8b 0f		 mov	 ecx, DWORD PTR [edi]

; 2120 : 
; 2121 : 		if (_Wherenode == _Root())

  000d6	3b 41 04	 cmp	 eax, DWORD PTR [ecx+4]
  000d9	75 05		 jne	 SHORT $LN147@Insert_at

; 2122 : 			_Root() = _Pnode;

  000db	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 2123 : 		else if (_Wherenode == this->_Left(this->_Parent(_Wherenode)))

  000de	eb 0e		 jmp	 SHORT $LN144@Insert_at
$LN147@Insert_at:

; 589  : 		}
; 590  : 
; 591  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 592  : 		{	// return reference to left pointer in node
; 593  : 		return ((_Nodepref)_Pnode->_Left);

  000e0	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]

; 2123 : 		else if (_Wherenode == this->_Left(this->_Parent(_Wherenode)))

  000e3	3b 01		 cmp	 eax, DWORD PTR [ecx]
  000e5	75 04		 jne	 SHORT $LN145@Insert_at

; 2124 : 			this->_Left(this->_Parent(_Wherenode)) = _Pnode;

  000e7	89 11		 mov	 DWORD PTR [ecx], edx

; 2125 : 		else

  000e9	eb 03		 jmp	 SHORT $LN144@Insert_at
$LN145@Insert_at:

; 2126 : 			this->_Right(this->_Parent(_Wherenode)) = _Pnode;

  000eb	89 51 08	 mov	 DWORD PTR [ecx+8], edx
$LN144@Insert_at:

; 2127 : 
; 2128 : 		this->_Left(_Pnode) = _Wherenode;

  000ee	89 02		 mov	 DWORD PTR [edx], eax

; 2129 : 		this->_Parent(_Wherenode) = _Pnode;

  000f0	89 50 04	 mov	 DWORD PTR [eax+4], edx
$LN149@Insert_at:

; 1889 : 						_Lrotate(_Pnode);
; 1890 : 						}
; 1891 : 					this->_Color(this->_Parent(_Pnode)) =
; 1892 : 						this->_Black;	// propagate red up

  000f3	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000f6	c6 41 0c 01	 mov	 BYTE PTR [ecx+12], 1

; 1893 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1894 : 						this->_Red;

  000fa	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000fd	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00100	c6 41 0c 00	 mov	 BYTE PTR [ecx+12], 0

; 1895 : 					_Rrotate(this->_Parent(this->_Parent(_Pnode)));

  00104	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00107	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]

; 2130 : 		}
; 2131 : 
; 2132 : 	_Nodeptr& _Rmost() const
; 2133 : 		{	// return rightmost node in nonmutable tree
; 2134 : 		return (this->_Right(this->_Myhead));
; 2135 : 		}
; 2136 : 
; 2137 : 	_Nodeptr& _Root() const
; 2138 : 		{	// return root of nonmutable tree
; 2139 : 		return (this->_Parent(this->_Myhead));
; 2140 : 		}
; 2141 : 
; 2142 : 	void _Rrotate(_Nodeptr _Wherenode)
; 2143 : 		{	// promote left node to root of subtree
; 2144 : 		_Nodeptr _Pnode = this->_Left(_Wherenode);

  0010a	8b 32		 mov	 esi, DWORD PTR [edx]

; 2145 : 		this->_Left(_Wherenode) = this->_Right(_Pnode);

  0010c	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0010f	89 0a		 mov	 DWORD PTR [edx], ecx

; 45   : 		this->_Adopt(_Plist);
; 46   : 		}
; 47   : 
; 48   : 	reference operator*() const
; 49   : 		{	// return designated value
; 50   : 		return (_Mytree::_Myval(_Ptr));
; 51   : 		}
; 52   : 
; 53   : 	pointer operator->() const
; 54   : 		{	// return pointer to class object
; 55   : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 56   : 		}
; 57   : 
; 58   : 	_Myiter& operator++()
; 59   : 		{	// preincrement
; 60   : 		if (_Mytree::_Isnil(_Ptr))
; 61   : 			;	// end() shouldn't be incremented, don't move
; 62   : 		else if (!_Mytree::_Isnil(_Mytree::_Right(_Ptr)))
; 63   : 			_Ptr = _Mytree::_Min(
; 64   : 				_Mytree::_Right(_Ptr));	// ==> smallest of right subtree
; 65   : 		else
; 66   : 			{	// climb looking for right subtree
; 67   : 			_Nodeptr _Pnode;
; 68   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 69   : 				&& _Ptr == _Mytree::_Right(_Pnode))
; 70   : 				_Ptr = _Pnode;	// ==> parent while right subtree
; 71   : 			_Ptr = _Pnode;	// ==> parent (head if end())
; 72   : 			}
; 73   : 		return (*this);
; 74   : 		}
; 75   : 
; 76   : 	_Myiter operator++(int)
; 77   : 		{	// postincrement
; 78   : 		_Myiter _Tmp = *this;
; 79   : 		++*this;
; 80   : 		return (_Tmp);
; 81   : 		}
; 82   : 
; 83   : 	_Myiter& operator--()
; 84   : 		{	// predecrement
; 85   : 		if (_Mytree::_Isnil(_Ptr))
; 86   : 			_Ptr = _Mytree::_Right(_Ptr);	// end() ==> rightmost
; 87   : 		else if (!_Mytree::_Isnil(_Mytree::_Left(_Ptr)))
; 88   : 			_Ptr = _Mytree::_Max(
; 89   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree
; 90   : 		else
; 91   : 			{	// climb looking for left subtree
; 92   : 			_Nodeptr _Pnode;
; 93   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 94   : 				&& _Ptr == _Mytree::_Left(_Pnode))
; 95   : 				_Ptr = _Pnode;	// ==> parent while left subtree
; 96   : 			if (_Mytree::_Isnil(_Ptr))
; 97   : 				;	// begin() shouldn't be decremented, don't move
; 98   : 			else
; 99   : 				_Ptr = _Pnode;	// ==> parent if not head
; 100  : 			}
; 101  : 		return (*this);
; 102  : 		}
; 103  : 
; 104  : 	_Myiter operator--(int)
; 105  : 		{	// postdecrement
; 106  : 		_Myiter _Tmp = *this;
; 107  : 		--*this;
; 108  : 		return (_Tmp);
; 109  : 		}
; 110  : 
; 111  : 	bool operator==(const _Myiter& _Right) const
; 112  : 		{	// test for iterator equality
; 113  : 		return (_Ptr == _Right._Ptr);
; 114  : 		}
; 115  : 
; 116  : 	bool operator!=(const _Myiter& _Right) const
; 117  : 		{	// test for iterator inequality
; 118  : 		return (!(*this == _Right));
; 119  : 		}
; 120  : 
; 121  : 	_Nodeptr _Mynode() const
; 122  : 		{	// return node pointer
; 123  : 		return (_Ptr);
; 124  : 		}
; 125  : 
; 126  : 	_Nodeptr _Ptr;	// pointer to node
; 127  : 	};
; 128  : 
; 129  : 	// TEMPLATE CLASS _Tree_unchecked_iterator
; 130  : template<class _Mytree>
; 131  : 	class _Tree_unchecked_iterator
; 132  : 		: public _Tree_unchecked_const_iterator<_Mytree>
; 133  : 	{	// unchecked iterator for mutable tree
; 134  : public:
; 135  : 	typedef _Tree_unchecked_iterator<_Mytree> _Myiter;
; 136  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Mybase;
; 137  : 	typedef bidirectional_iterator_tag iterator_category;
; 138  : 
; 139  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 140  : 	typedef typename _Mytree::value_type value_type;
; 141  : 	typedef typename _Mytree::difference_type difference_type;
; 142  : 	typedef typename _Mytree::pointer pointer;
; 143  : 	typedef typename _Mytree::reference reference;
; 144  : 
; 145  : 	_Tree_unchecked_iterator()
; 146  : 		{	// construct with null node
; 147  : 		}
; 148  : 
; 149  : 	_Tree_unchecked_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 150  : 		: _Mybase(_Pnode, _Plist)
; 151  : 		{	// construct with node pointer _Pnode
; 152  : 		}
; 153  : 
; 154  : 	reference operator*() const
; 155  : 		{	// return designated value
; 156  : 		return ((reference)**(_Mybase *)this);
; 157  : 		}
; 158  : 
; 159  : 	pointer operator->() const
; 160  : 		{	// return pointer to class object
; 161  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 162  : 		}
; 163  : 
; 164  : 	_Myiter& operator++()
; 165  : 		{	// preincrement
; 166  : 		++(*(_Mybase *)this);
; 167  : 		return (*this);
; 168  : 		}
; 169  : 
; 170  : 	_Myiter operator++(int)
; 171  : 		{	// postincrement
; 172  : 		_Myiter _Tmp = *this;
; 173  : 		++*this;
; 174  : 		return (_Tmp);
; 175  : 		}
; 176  : 
; 177  : 	_Myiter& operator--()
; 178  : 		{	// predecrement
; 179  : 		--(*(_Mybase *)this);
; 180  : 		return (*this);
; 181  : 		}
; 182  : 
; 183  : 	_Myiter operator--(int)
; 184  : 		{	// postdecrement
; 185  : 		_Myiter _Tmp = *this;
; 186  : 		--*this;
; 187  : 		return (_Tmp);
; 188  : 		}
; 189  : 	};
; 190  : 
; 191  : 	// TEMPLATE CLASS _Tree_const_iterator
; 192  : template<class _Mytree>
; 193  : 	class _Tree_const_iterator
; 194  : 		: public _Tree_unchecked_const_iterator<_Mytree, _Iterator_base>
; 195  : 	{	// iterator for nonmutable tree
; 196  : public:
; 197  : 	typedef _Tree_const_iterator<_Mytree> _Myiter;
; 198  : 	typedef _Tree_unchecked_const_iterator<_Mytree, _Iterator_base> _Mybase;
; 199  : 	typedef bidirectional_iterator_tag iterator_category;
; 200  : 
; 201  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 202  : 	typedef typename _Mytree::value_type value_type;
; 203  : 	typedef typename _Mytree::difference_type difference_type;
; 204  : 	typedef typename _Mytree::const_pointer pointer;
; 205  : 	typedef typename _Mytree::const_reference reference;
; 206  : 
; 207  : 	_Tree_const_iterator()
; 208  : 		: _Mybase()
; 209  : 		{	// construct with null node pointer
; 210  : 		}
; 211  : 
; 212  : 	_Tree_const_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 213  : 		: _Mybase(_Pnode, _Plist)
; 214  : 		{	// construct with node pointer _Pnode
; 215  : 		}
; 216  : 
; 217  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Unchecked_type;
; 218  : 
; 219  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 220  : 		{	// reset from unchecked iterator
; 221  : 		this->_Ptr = _Right._Ptr;
; 222  : 		return (*this);
; 223  : 		}
; 224  : 
; 225  : 	_Unchecked_type _Unchecked() const
; 226  : 		{	// make an unchecked iterator
; 227  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 228  : 		}
; 229  : 
; 230  : 	reference operator*() const
; 231  : 		{	// return designated value
; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		if (this->_Getcont() == 0
; 234  : 			|| this->_Ptr == 0
; 235  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 236  : 			{	// report error
; 237  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 238  : 			_SCL_SECURE_OUT_OF_RANGE;
; 239  : 			}
; 240  : 
; 241  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 242  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 243  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 244  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 245  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 246  : 
; 247  : 		return (_Mytree::_Myval(this->_Ptr));
; 248  : 		}
; 249  : 
; 250  : 	pointer operator->() const
; 251  : 		{	// return pointer to class object
; 252  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 253  : 		}
; 254  : 
; 255  : 	_Myiter& operator++()
; 256  : 		{	// preincrement
; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);
; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);
; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  :  #if _HAS_CPP0X
; 520  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 521  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 522  : 
; 523  :  #else /* _HAS_CPP0X */
; 524  : 	typedef typename _Alloc::template rebind<_Ty>::other _Alty;
; 525  :  #endif /* _HAS_CPP0X */
; 526  : 
; 527  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 528  : 		_Voidptr;
; 529  : 	typedef _Tree_node<typename _Alty::value_type,
; 530  : 		_Voidptr> _Node;
; 531  : 
; 532  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 533  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 534  : 	typedef _Nodeptr& _Nodepref;
; 535  : 
; 536  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 537  : 		_Tree_simple_types<typename _Alty::value_type>,
; 538  : 		_Tree_iter_types<typename _Alty::value_type,
; 539  : 			typename _Alty::size_type,
; 540  : 			typename _Alty::difference_type,
; 541  : 			typename _Alty::pointer,
; 542  : 			typename _Alty::const_pointer,
; 543  : 			typename _Alty::reference,
; 544  : 			typename _Alty::const_reference,
; 545  : 			_Nodeptr> >::type
; 546  : 		_Val_types;
; 547  : 	};
; 548  : 
; 549  : 		// TEMPLATE CLASS _Tree_val
; 550  : template<class _Val_types>
; 551  : 	class _Tree_val
; 552  : 		: public _Container_base
; 553  : 	{	// base class for tree to hold data
; 554  : public:
; 555  : 	typedef _Tree_val<_Val_types> _Myt;
; 556  : 
; 557  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 558  : 	typedef _Nodeptr& _Nodepref;
; 559  : 
; 560  : 	typedef typename _Val_types::value_type value_type;
; 561  : 	typedef typename _Val_types::size_type size_type;
; 562  : 	typedef typename _Val_types::difference_type difference_type;
; 563  : 	typedef typename _Val_types::pointer pointer;
; 564  : 	typedef typename _Val_types::const_pointer const_pointer;
; 565  : 	typedef typename _Val_types::reference reference;
; 566  : 	typedef typename _Val_types::const_reference const_reference;
; 567  : 
; 568  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 569  : 	typedef _Tree_iterator<_Myt> iterator;
; 570  : 
; 571  : 	_Tree_val()
; 572  : 		{	// initialize data
; 573  : 		this->_Myhead = 0;
; 574  : 		this->_Mysize = 0;
; 575  : 		}
; 576  : 
; 577  : 	enum _Redbl
; 578  : 		{	// colors for link to parent
; 579  : 		_Red, _Black};
; 580  : 
; 581  : 	static char& _Color(_Nodeptr _Pnode)
; 582  : 		{	// return reference to color in node
; 583  : 		return ((char&)_Pnode->_Color);
; 584  : 		}
; 585  : 
; 586  : 	static char& _Isnil(_Nodeptr _Pnode)
; 587  : 		{	// return reference to nil flag in node
; 588  : 		return ((char&)_Pnode->_Isnil);

  00111	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]

; 2146 : 
; 2147 : 		if (!this->_Isnil(this->_Right(_Pnode)))

  00114	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  00118	75 03		 jne	 SHORT $LN211@Insert_at

; 2148 : 			this->_Parent(this->_Right(_Pnode)) = _Wherenode;

  0011a	89 51 04	 mov	 DWORD PTR [ecx+4], edx
$LN211@Insert_at:

; 2149 : 		this->_Parent(_Pnode) = this->_Parent(_Wherenode);

  0011d	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  00120	89 4e 04	 mov	 DWORD PTR [esi+4], ecx

; 594  : 		}
; 595  : 
; 596  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 597  : 		{	// return reference to parent pointer in node
; 598  : 		return ((_Nodepref)_Pnode->_Parent);

  00123	8b 0f		 mov	 ecx, DWORD PTR [edi]

; 2150 : 
; 2151 : 		if (_Wherenode == _Root())

  00125	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  00128	75 0b		 jne	 SHORT $LN210@Insert_at

; 2152 : 			_Root() = _Pnode;

  0012a	89 71 04	 mov	 DWORD PTR [ecx+4], esi

; 2157 : 
; 2158 : 		this->_Right(_Pnode) = _Wherenode;

  0012d	89 56 08	 mov	 DWORD PTR [esi+8], edx

; 1896 : 					}
; 1897 : 				}
; 1898 : 			else

  00130	e9 cc 00 00 00	 jmp	 $LN415@Insert_at
$LN210@Insert_at:

; 599  : 		}
; 600  : 
; 601  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 602  : 		{	// return reference to right pointer in node
; 603  : 		return ((_Nodepref)_Pnode->_Right);

  00135	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]

; 2153 : 		else if (_Wherenode == this->_Right(this->_Parent(_Wherenode)))

  00138	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  0013b	75 0b		 jne	 SHORT $LN208@Insert_at

; 2154 : 			this->_Right(this->_Parent(_Wherenode)) = _Pnode;

  0013d	89 71 08	 mov	 DWORD PTR [ecx+8], esi

; 2157 : 
; 2158 : 		this->_Right(_Pnode) = _Wherenode;

  00140	89 56 08	 mov	 DWORD PTR [esi+8], edx

; 1896 : 					}
; 1897 : 				}
; 1898 : 			else

  00143	e9 b9 00 00 00	 jmp	 $LN415@Insert_at
$LN208@Insert_at:

; 2156 : 			this->_Left(this->_Parent(_Wherenode)) = _Pnode;

  00148	89 31		 mov	 DWORD PTR [ecx], esi

; 2157 : 
; 2158 : 		this->_Right(_Pnode) = _Wherenode;

  0014a	89 56 08	 mov	 DWORD PTR [esi+8], edx

; 1896 : 					}
; 1897 : 				}
; 1898 : 			else

  0014d	e9 af 00 00 00	 jmp	 $LN415@Insert_at
$LN8@Insert_at:

; 1899 : 				{	// fixup red-red in right subtree
; 1900 : 				_Wherenode =
; 1901 : 					this->_Left(this->_Parent(this->_Parent(_Pnode)));
; 1902 : 				if (this->_Color(_Wherenode) == this->_Red)

  00152	80 7a 0c 00	 cmp	 BYTE PTR [edx+12], 0
  00156	75 1d		 jne	 SHORT $LN3@Insert_at
$LN416@Insert_at:

; 1903 : 					{	// parent has two red children, blacken both
; 1904 : 					this->_Color(this->_Parent(_Pnode)) = this->_Black;

  00158	c6 41 0c 01	 mov	 BYTE PTR [ecx+12], 1

; 1905 : 					this->_Color(_Wherenode) = this->_Black;

  0015c	c6 42 0c 01	 mov	 BYTE PTR [edx+12], 1

; 1906 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1907 : 						this->_Red;

  00160	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00163	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00166	c6 41 0c 00	 mov	 BYTE PTR [ecx+12], 0

; 1908 : 					_Pnode = this->_Parent(this->_Parent(_Pnode));

  0016a	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0016d	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]

; 1909 : 					}
; 1910 : 				else

  00170	e9 8f 00 00 00	 jmp	 $LN354@Insert_at
$LN3@Insert_at:

; 1911 : 					{	// parent has red and black children
; 1912 : 					if (_Pnode == this->_Left(this->_Parent(_Pnode)))

  00175	3b 01		 cmp	 eax, DWORD PTR [ecx]
  00177	75 3c		 jne	 SHORT $LN291@Insert_at

; 1913 : 						{	// rotate left child to right
; 1914 : 						_Pnode = this->_Parent(_Pnode);

  00179	8b c1		 mov	 eax, ecx

; 2130 : 		}
; 2131 : 
; 2132 : 	_Nodeptr& _Rmost() const
; 2133 : 		{	// return rightmost node in nonmutable tree
; 2134 : 		return (this->_Right(this->_Myhead));
; 2135 : 		}
; 2136 : 
; 2137 : 	_Nodeptr& _Root() const
; 2138 : 		{	// return root of nonmutable tree
; 2139 : 		return (this->_Parent(this->_Myhead));
; 2140 : 		}
; 2141 : 
; 2142 : 	void _Rrotate(_Nodeptr _Wherenode)
; 2143 : 		{	// promote left node to root of subtree
; 2144 : 		_Nodeptr _Pnode = this->_Left(_Wherenode);

  0017b	8b 10		 mov	 edx, DWORD PTR [eax]

; 2145 : 		this->_Left(_Wherenode) = this->_Right(_Pnode);

  0017d	8b 4a 08	 mov	 ecx, DWORD PTR [edx+8]
  00180	89 08		 mov	 DWORD PTR [eax], ecx

; 45   : 		this->_Adopt(_Plist);
; 46   : 		}
; 47   : 
; 48   : 	reference operator*() const
; 49   : 		{	// return designated value
; 50   : 		return (_Mytree::_Myval(_Ptr));
; 51   : 		}
; 52   : 
; 53   : 	pointer operator->() const
; 54   : 		{	// return pointer to class object
; 55   : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 56   : 		}
; 57   : 
; 58   : 	_Myiter& operator++()
; 59   : 		{	// preincrement
; 60   : 		if (_Mytree::_Isnil(_Ptr))
; 61   : 			;	// end() shouldn't be incremented, don't move
; 62   : 		else if (!_Mytree::_Isnil(_Mytree::_Right(_Ptr)))
; 63   : 			_Ptr = _Mytree::_Min(
; 64   : 				_Mytree::_Right(_Ptr));	// ==> smallest of right subtree
; 65   : 		else
; 66   : 			{	// climb looking for right subtree
; 67   : 			_Nodeptr _Pnode;
; 68   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 69   : 				&& _Ptr == _Mytree::_Right(_Pnode))
; 70   : 				_Ptr = _Pnode;	// ==> parent while right subtree
; 71   : 			_Ptr = _Pnode;	// ==> parent (head if end())
; 72   : 			}
; 73   : 		return (*this);
; 74   : 		}
; 75   : 
; 76   : 	_Myiter operator++(int)
; 77   : 		{	// postincrement
; 78   : 		_Myiter _Tmp = *this;
; 79   : 		++*this;
; 80   : 		return (_Tmp);
; 81   : 		}
; 82   : 
; 83   : 	_Myiter& operator--()
; 84   : 		{	// predecrement
; 85   : 		if (_Mytree::_Isnil(_Ptr))
; 86   : 			_Ptr = _Mytree::_Right(_Ptr);	// end() ==> rightmost
; 87   : 		else if (!_Mytree::_Isnil(_Mytree::_Left(_Ptr)))
; 88   : 			_Ptr = _Mytree::_Max(
; 89   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree
; 90   : 		else
; 91   : 			{	// climb looking for left subtree
; 92   : 			_Nodeptr _Pnode;
; 93   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 94   : 				&& _Ptr == _Mytree::_Left(_Pnode))
; 95   : 				_Ptr = _Pnode;	// ==> parent while left subtree
; 96   : 			if (_Mytree::_Isnil(_Ptr))
; 97   : 				;	// begin() shouldn't be decremented, don't move
; 98   : 			else
; 99   : 				_Ptr = _Pnode;	// ==> parent if not head
; 100  : 			}
; 101  : 		return (*this);
; 102  : 		}
; 103  : 
; 104  : 	_Myiter operator--(int)
; 105  : 		{	// postdecrement
; 106  : 		_Myiter _Tmp = *this;
; 107  : 		--*this;
; 108  : 		return (_Tmp);
; 109  : 		}
; 110  : 
; 111  : 	bool operator==(const _Myiter& _Right) const
; 112  : 		{	// test for iterator equality
; 113  : 		return (_Ptr == _Right._Ptr);
; 114  : 		}
; 115  : 
; 116  : 	bool operator!=(const _Myiter& _Right) const
; 117  : 		{	// test for iterator inequality
; 118  : 		return (!(*this == _Right));
; 119  : 		}
; 120  : 
; 121  : 	_Nodeptr _Mynode() const
; 122  : 		{	// return node pointer
; 123  : 		return (_Ptr);
; 124  : 		}
; 125  : 
; 126  : 	_Nodeptr _Ptr;	// pointer to node
; 127  : 	};
; 128  : 
; 129  : 	// TEMPLATE CLASS _Tree_unchecked_iterator
; 130  : template<class _Mytree>
; 131  : 	class _Tree_unchecked_iterator
; 132  : 		: public _Tree_unchecked_const_iterator<_Mytree>
; 133  : 	{	// unchecked iterator for mutable tree
; 134  : public:
; 135  : 	typedef _Tree_unchecked_iterator<_Mytree> _Myiter;
; 136  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Mybase;
; 137  : 	typedef bidirectional_iterator_tag iterator_category;
; 138  : 
; 139  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 140  : 	typedef typename _Mytree::value_type value_type;
; 141  : 	typedef typename _Mytree::difference_type difference_type;
; 142  : 	typedef typename _Mytree::pointer pointer;
; 143  : 	typedef typename _Mytree::reference reference;
; 144  : 
; 145  : 	_Tree_unchecked_iterator()
; 146  : 		{	// construct with null node
; 147  : 		}
; 148  : 
; 149  : 	_Tree_unchecked_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 150  : 		: _Mybase(_Pnode, _Plist)
; 151  : 		{	// construct with node pointer _Pnode
; 152  : 		}
; 153  : 
; 154  : 	reference operator*() const
; 155  : 		{	// return designated value
; 156  : 		return ((reference)**(_Mybase *)this);
; 157  : 		}
; 158  : 
; 159  : 	pointer operator->() const
; 160  : 		{	// return pointer to class object
; 161  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 162  : 		}
; 163  : 
; 164  : 	_Myiter& operator++()
; 165  : 		{	// preincrement
; 166  : 		++(*(_Mybase *)this);
; 167  : 		return (*this);
; 168  : 		}
; 169  : 
; 170  : 	_Myiter operator++(int)
; 171  : 		{	// postincrement
; 172  : 		_Myiter _Tmp = *this;
; 173  : 		++*this;
; 174  : 		return (_Tmp);
; 175  : 		}
; 176  : 
; 177  : 	_Myiter& operator--()
; 178  : 		{	// predecrement
; 179  : 		--(*(_Mybase *)this);
; 180  : 		return (*this);
; 181  : 		}
; 182  : 
; 183  : 	_Myiter operator--(int)
; 184  : 		{	// postdecrement
; 185  : 		_Myiter _Tmp = *this;
; 186  : 		--*this;
; 187  : 		return (_Tmp);
; 188  : 		}
; 189  : 	};
; 190  : 
; 191  : 	// TEMPLATE CLASS _Tree_const_iterator
; 192  : template<class _Mytree>
; 193  : 	class _Tree_const_iterator
; 194  : 		: public _Tree_unchecked_const_iterator<_Mytree, _Iterator_base>
; 195  : 	{	// iterator for nonmutable tree
; 196  : public:
; 197  : 	typedef _Tree_const_iterator<_Mytree> _Myiter;
; 198  : 	typedef _Tree_unchecked_const_iterator<_Mytree, _Iterator_base> _Mybase;
; 199  : 	typedef bidirectional_iterator_tag iterator_category;
; 200  : 
; 201  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 202  : 	typedef typename _Mytree::value_type value_type;
; 203  : 	typedef typename _Mytree::difference_type difference_type;
; 204  : 	typedef typename _Mytree::const_pointer pointer;
; 205  : 	typedef typename _Mytree::const_reference reference;
; 206  : 
; 207  : 	_Tree_const_iterator()
; 208  : 		: _Mybase()
; 209  : 		{	// construct with null node pointer
; 210  : 		}
; 211  : 
; 212  : 	_Tree_const_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 213  : 		: _Mybase(_Pnode, _Plist)
; 214  : 		{	// construct with node pointer _Pnode
; 215  : 		}
; 216  : 
; 217  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Unchecked_type;
; 218  : 
; 219  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 220  : 		{	// reset from unchecked iterator
; 221  : 		this->_Ptr = _Right._Ptr;
; 222  : 		return (*this);
; 223  : 		}
; 224  : 
; 225  : 	_Unchecked_type _Unchecked() const
; 226  : 		{	// make an unchecked iterator
; 227  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 228  : 		}
; 229  : 
; 230  : 	reference operator*() const
; 231  : 		{	// return designated value
; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		if (this->_Getcont() == 0
; 234  : 			|| this->_Ptr == 0
; 235  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 236  : 			{	// report error
; 237  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 238  : 			_SCL_SECURE_OUT_OF_RANGE;
; 239  : 			}
; 240  : 
; 241  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 242  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 243  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 244  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 245  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 246  : 
; 247  : 		return (_Mytree::_Myval(this->_Ptr));
; 248  : 		}
; 249  : 
; 250  : 	pointer operator->() const
; 251  : 		{	// return pointer to class object
; 252  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 253  : 		}
; 254  : 
; 255  : 	_Myiter& operator++()
; 256  : 		{	// preincrement
; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);
; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);
; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  :  #if _HAS_CPP0X
; 520  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 521  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 522  : 
; 523  :  #else /* _HAS_CPP0X */
; 524  : 	typedef typename _Alloc::template rebind<_Ty>::other _Alty;
; 525  :  #endif /* _HAS_CPP0X */
; 526  : 
; 527  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 528  : 		_Voidptr;
; 529  : 	typedef _Tree_node<typename _Alty::value_type,
; 530  : 		_Voidptr> _Node;
; 531  : 
; 532  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 533  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 534  : 	typedef _Nodeptr& _Nodepref;
; 535  : 
; 536  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 537  : 		_Tree_simple_types<typename _Alty::value_type>,
; 538  : 		_Tree_iter_types<typename _Alty::value_type,
; 539  : 			typename _Alty::size_type,
; 540  : 			typename _Alty::difference_type,
; 541  : 			typename _Alty::pointer,
; 542  : 			typename _Alty::const_pointer,
; 543  : 			typename _Alty::reference,
; 544  : 			typename _Alty::const_reference,
; 545  : 			_Nodeptr> >::type
; 546  : 		_Val_types;
; 547  : 	};
; 548  : 
; 549  : 		// TEMPLATE CLASS _Tree_val
; 550  : template<class _Val_types>
; 551  : 	class _Tree_val
; 552  : 		: public _Container_base
; 553  : 	{	// base class for tree to hold data
; 554  : public:
; 555  : 	typedef _Tree_val<_Val_types> _Myt;
; 556  : 
; 557  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 558  : 	typedef _Nodeptr& _Nodepref;
; 559  : 
; 560  : 	typedef typename _Val_types::value_type value_type;
; 561  : 	typedef typename _Val_types::size_type size_type;
; 562  : 	typedef typename _Val_types::difference_type difference_type;
; 563  : 	typedef typename _Val_types::pointer pointer;
; 564  : 	typedef typename _Val_types::const_pointer const_pointer;
; 565  : 	typedef typename _Val_types::reference reference;
; 566  : 	typedef typename _Val_types::const_reference const_reference;
; 567  : 
; 568  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 569  : 	typedef _Tree_iterator<_Myt> iterator;
; 570  : 
; 571  : 	_Tree_val()
; 572  : 		{	// initialize data
; 573  : 		this->_Myhead = 0;
; 574  : 		this->_Mysize = 0;
; 575  : 		}
; 576  : 
; 577  : 	enum _Redbl
; 578  : 		{	// colors for link to parent
; 579  : 		_Red, _Black};
; 580  : 
; 581  : 	static char& _Color(_Nodeptr _Pnode)
; 582  : 		{	// return reference to color in node
; 583  : 		return ((char&)_Pnode->_Color);
; 584  : 		}
; 585  : 
; 586  : 	static char& _Isnil(_Nodeptr _Pnode)
; 587  : 		{	// return reference to nil flag in node
; 588  : 		return ((char&)_Pnode->_Isnil);

  00182	8b 4a 08	 mov	 ecx, DWORD PTR [edx+8]

; 2146 : 
; 2147 : 		if (!this->_Isnil(this->_Right(_Pnode)))

  00185	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  00189	75 03		 jne	 SHORT $LN290@Insert_at

; 2148 : 			this->_Parent(this->_Right(_Pnode)) = _Wherenode;

  0018b	89 41 04	 mov	 DWORD PTR [ecx+4], eax
$LN290@Insert_at:

; 2149 : 		this->_Parent(_Pnode) = this->_Parent(_Wherenode);

  0018e	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00191	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 594  : 		}
; 595  : 
; 596  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 597  : 		{	// return reference to parent pointer in node
; 598  : 		return ((_Nodepref)_Pnode->_Parent);

  00194	8b 0f		 mov	 ecx, DWORD PTR [edi]

; 2150 : 
; 2151 : 		if (_Wherenode == _Root())

  00196	3b 41 04	 cmp	 eax, DWORD PTR [ecx+4]
  00199	75 05		 jne	 SHORT $LN289@Insert_at

; 2152 : 			_Root() = _Pnode;

  0019b	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 2153 : 		else if (_Wherenode == this->_Right(this->_Parent(_Wherenode)))

  0019e	eb 0f		 jmp	 SHORT $LN286@Insert_at
$LN289@Insert_at:

; 599  : 		}
; 600  : 
; 601  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 602  : 		{	// return reference to right pointer in node
; 603  : 		return ((_Nodepref)_Pnode->_Right);

  001a0	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]

; 2153 : 		else if (_Wherenode == this->_Right(this->_Parent(_Wherenode)))

  001a3	3b 41 08	 cmp	 eax, DWORD PTR [ecx+8]
  001a6	75 05		 jne	 SHORT $LN287@Insert_at

; 2154 : 			this->_Right(this->_Parent(_Wherenode)) = _Pnode;

  001a8	89 51 08	 mov	 DWORD PTR [ecx+8], edx

; 2155 : 		else

  001ab	eb 02		 jmp	 SHORT $LN286@Insert_at
$LN287@Insert_at:

; 2156 : 			this->_Left(this->_Parent(_Wherenode)) = _Pnode;

  001ad	89 11		 mov	 DWORD PTR [ecx], edx
$LN286@Insert_at:

; 2157 : 
; 2158 : 		this->_Right(_Pnode) = _Wherenode;

  001af	89 42 08	 mov	 DWORD PTR [edx+8], eax

; 2159 : 		this->_Parent(_Wherenode) = _Pnode;

  001b2	89 50 04	 mov	 DWORD PTR [eax+4], edx
$LN291@Insert_at:

; 1915 : 						_Rrotate(_Pnode);
; 1916 : 						}
; 1917 : 					this->_Color(this->_Parent(_Pnode)) =
; 1918 : 						this->_Black;	// propagate red up

  001b5	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  001b8	c6 41 0c 01	 mov	 BYTE PTR [ecx+12], 1

; 1919 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1920 : 						this->_Red;

  001bc	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  001bf	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  001c2	c6 41 0c 00	 mov	 BYTE PTR [ecx+12], 0

; 1921 : 					_Lrotate(this->_Parent(this->_Parent(_Pnode)));

  001c6	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  001c9	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]

; 1928 : 
; 1929 : 	template<class _Moveit>
; 1930 : 		void _Copy(const _Myt& _Right,
; 1931 : 			_Moveit _Movefl)
; 1932 : 		{	// copy or move entire tree from _Right
; 1933 : 		_Root() = _Copy_nodes(_Right._Root(), this->_Myhead, _Movefl);
; 1934 : 		this->_Mysize = _Right.size();
; 1935 : 		if (!this->_Isnil(_Root()))
; 1936 : 			{	// nonempty tree, look for new smallest and largest
; 1937 : 			_Lmost() = this->_Min(_Root());
; 1938 : 			_Rmost() = this->_Max(_Root());
; 1939 : 			}
; 1940 : 		else
; 1941 : 			{	// empty tree, just tidy head pointers
; 1942 : 			_Lmost() = this->_Myhead;
; 1943 : 			_Rmost() = this->_Myhead;
; 1944 : 			}
; 1945 : 		}
; 1946 : 
; 1947 : template<class _Want_to_move,
; 1948 : 	class _Can_move>
; 1949 : 	_Nodeptr _Copy_or_move(_Nodeptr _Rootnode, _Want_to_move, _Can_move)
; 1950 : 		{	// copy to new node
; 1951 : 		return (this->_Buynode(this->_Myval(_Rootnode)));
; 1952 : 		}
; 1953 : 
; 1954 : 	_Nodeptr _Copy_or_move(_Nodeptr _Rootnode, true_type, true_type)
; 1955 : 		{	// move to new node -- movable
; 1956 : 		return (this->_Buynode(
; 1957 : 			_STD forward<value_type>(this->_Myval(_Rootnode))));
; 1958 : 		}
; 1959 : 
; 1960 : 	template<class _Moveit>
; 1961 : 		_Nodeptr _Copy_nodes(_Nodeptr _Rootnode, _Nodeptr _Wherenode,
; 1962 : 			_Moveit _Movefl)
; 1963 : 		{	// copy entire subtree, recursively
; 1964 : 		_Nodeptr _Newroot = this->_Myhead;	// point at nil node
; 1965 : 
; 1966 : 		if (!this->_Isnil(_Rootnode))
; 1967 : 			{	// copy or move a node, then any subtrees
; 1968 : 			_Nodeptr _Pnode = _Copy_or_move(_Rootnode, _Movefl,
; 1969 : 				typename is_move_constructible<value_type>::type());
; 1970 : 			_Pnode->_Parent = _Wherenode;
; 1971 : 			_Pnode->_Color = this->_Color(_Rootnode);
; 1972 : 			if (this->_Isnil(_Newroot))
; 1973 : 				_Newroot = _Pnode;	// memorize new root
; 1974 : 
; 1975 : 			_TRY_BEGIN
; 1976 : 			this->_Left(_Pnode) =
; 1977 : 				_Copy_nodes(this->_Left(_Rootnode), _Pnode, _Movefl);
; 1978 : 			this->_Right(_Pnode) =
; 1979 : 				_Copy_nodes(this->_Right(_Rootnode), _Pnode, _Movefl);
; 1980 : 			_CATCH_ALL
; 1981 : 			_Erase(_Newroot);	// subtree copy failed, bail out
; 1982 : 			_RERAISE;
; 1983 : 			_CATCH_END
; 1984 : 			}
; 1985 : 
; 1986 : 		return (_Newroot);	// return newly constructed tree
; 1987 : 		}
; 1988 : 
; 1989 : 	_Paircc _Eqrange(const key_type& _Keyval) const
; 1990 : 		{	// find leftmost node not less than _Keyval
; 1991 : 		_Nodeptr _Pnode = _Root();
; 1992 : 		_Nodeptr _Lonode = this->_Myhead;	// end() if search fails
; 1993 : 		_Nodeptr _Hinode = this->_Myhead;	// end() if search fails
; 1994 : 
; 1995 : 		while (!this->_Isnil(_Pnode))
; 1996 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))
; 1997 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 1998 : 			else
; 1999 : 				{	// _Pnode not less than _Keyval, remember it
; 2000 : 				if (this->_Isnil(_Hinode)
; 2001 : 						&& _DEBUG_LT_PRED(this->_Getcomp(), _Keyval,
; 2002 : 						this->_Key(_Pnode)))
; 2003 : 					_Hinode = _Pnode;	// _Pnode greater, remember it
; 2004 : 				_Lonode = _Pnode;
; 2005 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2006 : 				}
; 2007 : 
; 2008 : 		_Pnode = this->_Isnil(_Hinode) ? _Root()
; 2009 : 			: this->_Left(_Hinode);	// continue scan for upper bound
; 2010 : 		while (!this->_Isnil(_Pnode))
; 2011 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), _Keyval, this->_Key(_Pnode)))
; 2012 : 				{	// _Pnode greater than _Keyval, remember it
; 2013 : 				_Hinode = _Pnode;
; 2014 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2015 : 				}
; 2016 : 			else
; 2017 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2018 : 
; 2019 : 		const_iterator _First = const_iterator(_Lonode, this);
; 2020 : 		const_iterator _Last = const_iterator(_Hinode, this);
; 2021 : 		return (_Paircc(_First, _Last));
; 2022 : 		}
; 2023 : 
; 2024 : 	_Pairii _Eqrange(const key_type& _Keyval)
; 2025 : 		{	// find leftmost node not less than _Keyval
; 2026 : 		_Nodeptr _Pnode = _Root();
; 2027 : 		_Nodeptr _Lonode = this->_Myhead;	// end() if search fails
; 2028 : 		_Nodeptr _Hinode = this->_Myhead;	// end() if search fails
; 2029 : 
; 2030 : 		while (!this->_Isnil(_Pnode))
; 2031 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))
; 2032 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2033 : 			else
; 2034 : 				{	// _Pnode not less than _Keyval, remember it
; 2035 : 				if (this->_Isnil(_Hinode)
; 2036 : 						&& _DEBUG_LT_PRED(this->_Getcomp(), _Keyval,
; 2037 : 						 this->_Key(_Pnode)))
; 2038 : 					_Hinode = _Pnode;	// _Pnode greater, remember it
; 2039 : 				_Lonode = _Pnode;
; 2040 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2041 : 				}
; 2042 : 
; 2043 : 		_Pnode = this->_Isnil(_Hinode) ? _Root()
; 2044 : 			: this->_Left(_Hinode);	// continue scan for upper bound
; 2045 : 		while (!this->_Isnil(_Pnode))
; 2046 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), _Keyval, this->_Key(_Pnode)))
; 2047 : 				{	// _Pnode greater than _Keyval, remember it
; 2048 : 				_Hinode = _Pnode;
; 2049 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2050 : 				}
; 2051 : 			else
; 2052 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2053 : 
; 2054 : 		iterator _First = iterator(_Lonode, this);
; 2055 : 		iterator _Last = iterator(_Hinode, this);
; 2056 : 		return (_Pairii(_First, _Last));
; 2057 : 		}
; 2058 : 
; 2059 : 	void _Erase(_Nodeptr _Rootnode)
; 2060 : 		{	// free entire subtree, recursively
; 2061 : 		for (_Nodeptr _Pnode = _Rootnode;
; 2062 : 			!this->_Isnil(_Pnode); _Rootnode = _Pnode)
; 2063 : 			{	// free subtrees, then node
; 2064 : 			_Erase(this->_Right(_Pnode));
; 2065 : 			_Pnode = this->_Left(_Pnode);
; 2066 : 			this->_Getal().destroy(
; 2067 : 				_STD addressof(this->_Myval(_Rootnode)));
; 2068 : 
; 2069 : 			this->_Getal().deallocate(_Rootnode, 1);
; 2070 : 			}
; 2071 : 		}
; 2072 : 
; 2073 : 	_Nodeptr _Lbound(const key_type& _Keyval) const
; 2074 : 		{	// find leftmost node not less than _Keyval
; 2075 : 		_Nodeptr _Pnode = _Root();
; 2076 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails
; 2077 : 
; 2078 : 		while (!this->_Isnil(_Pnode))
; 2079 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))
; 2080 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2081 : 			else
; 2082 : 				{	// _Pnode not less than _Keyval, remember it
; 2083 : 				_Wherenode = _Pnode;
; 2084 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2085 : 				}
; 2086 : 
; 2087 : 		return (_Wherenode);	// return best remembered candidate
; 2088 : 		}
; 2089 : 
; 2090 : 	_Nodeptr _Lbound(const key_type& _Keyval)
; 2091 : 		{	// find leftmost node not less than _Keyval
; 2092 : 		_Nodeptr _Pnode = _Root();
; 2093 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails
; 2094 : 
; 2095 : 		while (!this->_Isnil(_Pnode))
; 2096 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))
; 2097 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2098 : 			else
; 2099 : 				{	// _Pnode not less than _Keyval, remember it
; 2100 : 				_Wherenode = _Pnode;
; 2101 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2102 : 				}
; 2103 : 
; 2104 : 		return (_Wherenode);	// return best remembered candidate
; 2105 : 		}
; 2106 : 
; 2107 : 	_Nodeptr& _Lmost() const
; 2108 : 		{	// return leftmost node in nonmutable tree
; 2109 : 		return (this->_Left(this->_Myhead));
; 2110 : 		}
; 2111 : 
; 2112 : 	void _Lrotate(_Nodeptr _Wherenode)
; 2113 : 		{	// promote right node to root of subtree
; 2114 : 		_Nodeptr _Pnode = this->_Right(_Wherenode);

  001cc	8b 72 08	 mov	 esi, DWORD PTR [edx+8]

; 2115 : 		this->_Right(_Wherenode) = this->_Left(_Pnode);

  001cf	8b 0e		 mov	 ecx, DWORD PTR [esi]
  001d1	89 4a 08	 mov	 DWORD PTR [edx+8], ecx

; 45   : 		this->_Adopt(_Plist);
; 46   : 		}
; 47   : 
; 48   : 	reference operator*() const
; 49   : 		{	// return designated value
; 50   : 		return (_Mytree::_Myval(_Ptr));
; 51   : 		}
; 52   : 
; 53   : 	pointer operator->() const
; 54   : 		{	// return pointer to class object
; 55   : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 56   : 		}
; 57   : 
; 58   : 	_Myiter& operator++()
; 59   : 		{	// preincrement
; 60   : 		if (_Mytree::_Isnil(_Ptr))
; 61   : 			;	// end() shouldn't be incremented, don't move
; 62   : 		else if (!_Mytree::_Isnil(_Mytree::_Right(_Ptr)))
; 63   : 			_Ptr = _Mytree::_Min(
; 64   : 				_Mytree::_Right(_Ptr));	// ==> smallest of right subtree
; 65   : 		else
; 66   : 			{	// climb looking for right subtree
; 67   : 			_Nodeptr _Pnode;
; 68   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 69   : 				&& _Ptr == _Mytree::_Right(_Pnode))
; 70   : 				_Ptr = _Pnode;	// ==> parent while right subtree
; 71   : 			_Ptr = _Pnode;	// ==> parent (head if end())
; 72   : 			}
; 73   : 		return (*this);
; 74   : 		}
; 75   : 
; 76   : 	_Myiter operator++(int)
; 77   : 		{	// postincrement
; 78   : 		_Myiter _Tmp = *this;
; 79   : 		++*this;
; 80   : 		return (_Tmp);
; 81   : 		}
; 82   : 
; 83   : 	_Myiter& operator--()
; 84   : 		{	// predecrement
; 85   : 		if (_Mytree::_Isnil(_Ptr))
; 86   : 			_Ptr = _Mytree::_Right(_Ptr);	// end() ==> rightmost
; 87   : 		else if (!_Mytree::_Isnil(_Mytree::_Left(_Ptr)))
; 88   : 			_Ptr = _Mytree::_Max(
; 89   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree
; 90   : 		else
; 91   : 			{	// climb looking for left subtree
; 92   : 			_Nodeptr _Pnode;
; 93   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 94   : 				&& _Ptr == _Mytree::_Left(_Pnode))
; 95   : 				_Ptr = _Pnode;	// ==> parent while left subtree
; 96   : 			if (_Mytree::_Isnil(_Ptr))
; 97   : 				;	// begin() shouldn't be decremented, don't move
; 98   : 			else
; 99   : 				_Ptr = _Pnode;	// ==> parent if not head
; 100  : 			}
; 101  : 		return (*this);
; 102  : 		}
; 103  : 
; 104  : 	_Myiter operator--(int)
; 105  : 		{	// postdecrement
; 106  : 		_Myiter _Tmp = *this;
; 107  : 		--*this;
; 108  : 		return (_Tmp);
; 109  : 		}
; 110  : 
; 111  : 	bool operator==(const _Myiter& _Right) const
; 112  : 		{	// test for iterator equality
; 113  : 		return (_Ptr == _Right._Ptr);
; 114  : 		}
; 115  : 
; 116  : 	bool operator!=(const _Myiter& _Right) const
; 117  : 		{	// test for iterator inequality
; 118  : 		return (!(*this == _Right));
; 119  : 		}
; 120  : 
; 121  : 	_Nodeptr _Mynode() const
; 122  : 		{	// return node pointer
; 123  : 		return (_Ptr);
; 124  : 		}
; 125  : 
; 126  : 	_Nodeptr _Ptr;	// pointer to node
; 127  : 	};
; 128  : 
; 129  : 	// TEMPLATE CLASS _Tree_unchecked_iterator
; 130  : template<class _Mytree>
; 131  : 	class _Tree_unchecked_iterator
; 132  : 		: public _Tree_unchecked_const_iterator<_Mytree>
; 133  : 	{	// unchecked iterator for mutable tree
; 134  : public:
; 135  : 	typedef _Tree_unchecked_iterator<_Mytree> _Myiter;
; 136  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Mybase;
; 137  : 	typedef bidirectional_iterator_tag iterator_category;
; 138  : 
; 139  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 140  : 	typedef typename _Mytree::value_type value_type;
; 141  : 	typedef typename _Mytree::difference_type difference_type;
; 142  : 	typedef typename _Mytree::pointer pointer;
; 143  : 	typedef typename _Mytree::reference reference;
; 144  : 
; 145  : 	_Tree_unchecked_iterator()
; 146  : 		{	// construct with null node
; 147  : 		}
; 148  : 
; 149  : 	_Tree_unchecked_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 150  : 		: _Mybase(_Pnode, _Plist)
; 151  : 		{	// construct with node pointer _Pnode
; 152  : 		}
; 153  : 
; 154  : 	reference operator*() const
; 155  : 		{	// return designated value
; 156  : 		return ((reference)**(_Mybase *)this);
; 157  : 		}
; 158  : 
; 159  : 	pointer operator->() const
; 160  : 		{	// return pointer to class object
; 161  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 162  : 		}
; 163  : 
; 164  : 	_Myiter& operator++()
; 165  : 		{	// preincrement
; 166  : 		++(*(_Mybase *)this);
; 167  : 		return (*this);
; 168  : 		}
; 169  : 
; 170  : 	_Myiter operator++(int)
; 171  : 		{	// postincrement
; 172  : 		_Myiter _Tmp = *this;
; 173  : 		++*this;
; 174  : 		return (_Tmp);
; 175  : 		}
; 176  : 
; 177  : 	_Myiter& operator--()
; 178  : 		{	// predecrement
; 179  : 		--(*(_Mybase *)this);
; 180  : 		return (*this);
; 181  : 		}
; 182  : 
; 183  : 	_Myiter operator--(int)
; 184  : 		{	// postdecrement
; 185  : 		_Myiter _Tmp = *this;
; 186  : 		--*this;
; 187  : 		return (_Tmp);
; 188  : 		}
; 189  : 	};
; 190  : 
; 191  : 	// TEMPLATE CLASS _Tree_const_iterator
; 192  : template<class _Mytree>
; 193  : 	class _Tree_const_iterator
; 194  : 		: public _Tree_unchecked_const_iterator<_Mytree, _Iterator_base>
; 195  : 	{	// iterator for nonmutable tree
; 196  : public:
; 197  : 	typedef _Tree_const_iterator<_Mytree> _Myiter;
; 198  : 	typedef _Tree_unchecked_const_iterator<_Mytree, _Iterator_base> _Mybase;
; 199  : 	typedef bidirectional_iterator_tag iterator_category;
; 200  : 
; 201  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 202  : 	typedef typename _Mytree::value_type value_type;
; 203  : 	typedef typename _Mytree::difference_type difference_type;
; 204  : 	typedef typename _Mytree::const_pointer pointer;
; 205  : 	typedef typename _Mytree::const_reference reference;
; 206  : 
; 207  : 	_Tree_const_iterator()
; 208  : 		: _Mybase()
; 209  : 		{	// construct with null node pointer
; 210  : 		}
; 211  : 
; 212  : 	_Tree_const_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 213  : 		: _Mybase(_Pnode, _Plist)
; 214  : 		{	// construct with node pointer _Pnode
; 215  : 		}
; 216  : 
; 217  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Unchecked_type;
; 218  : 
; 219  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 220  : 		{	// reset from unchecked iterator
; 221  : 		this->_Ptr = _Right._Ptr;
; 222  : 		return (*this);
; 223  : 		}
; 224  : 
; 225  : 	_Unchecked_type _Unchecked() const
; 226  : 		{	// make an unchecked iterator
; 227  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 228  : 		}
; 229  : 
; 230  : 	reference operator*() const
; 231  : 		{	// return designated value
; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		if (this->_Getcont() == 0
; 234  : 			|| this->_Ptr == 0
; 235  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 236  : 			{	// report error
; 237  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 238  : 			_SCL_SECURE_OUT_OF_RANGE;
; 239  : 			}
; 240  : 
; 241  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 242  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 243  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 244  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 245  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 246  : 
; 247  : 		return (_Mytree::_Myval(this->_Ptr));
; 248  : 		}
; 249  : 
; 250  : 	pointer operator->() const
; 251  : 		{	// return pointer to class object
; 252  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 253  : 		}
; 254  : 
; 255  : 	_Myiter& operator++()
; 256  : 		{	// preincrement
; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);
; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);
; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  :  #if _HAS_CPP0X
; 520  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 521  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 522  : 
; 523  :  #else /* _HAS_CPP0X */
; 524  : 	typedef typename _Alloc::template rebind<_Ty>::other _Alty;
; 525  :  #endif /* _HAS_CPP0X */
; 526  : 
; 527  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 528  : 		_Voidptr;
; 529  : 	typedef _Tree_node<typename _Alty::value_type,
; 530  : 		_Voidptr> _Node;
; 531  : 
; 532  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 533  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 534  : 	typedef _Nodeptr& _Nodepref;
; 535  : 
; 536  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 537  : 		_Tree_simple_types<typename _Alty::value_type>,
; 538  : 		_Tree_iter_types<typename _Alty::value_type,
; 539  : 			typename _Alty::size_type,
; 540  : 			typename _Alty::difference_type,
; 541  : 			typename _Alty::pointer,
; 542  : 			typename _Alty::const_pointer,
; 543  : 			typename _Alty::reference,
; 544  : 			typename _Alty::const_reference,
; 545  : 			_Nodeptr> >::type
; 546  : 		_Val_types;
; 547  : 	};
; 548  : 
; 549  : 		// TEMPLATE CLASS _Tree_val
; 550  : template<class _Val_types>
; 551  : 	class _Tree_val
; 552  : 		: public _Container_base
; 553  : 	{	// base class for tree to hold data
; 554  : public:
; 555  : 	typedef _Tree_val<_Val_types> _Myt;
; 556  : 
; 557  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 558  : 	typedef _Nodeptr& _Nodepref;
; 559  : 
; 560  : 	typedef typename _Val_types::value_type value_type;
; 561  : 	typedef typename _Val_types::size_type size_type;
; 562  : 	typedef typename _Val_types::difference_type difference_type;
; 563  : 	typedef typename _Val_types::pointer pointer;
; 564  : 	typedef typename _Val_types::const_pointer const_pointer;
; 565  : 	typedef typename _Val_types::reference reference;
; 566  : 	typedef typename _Val_types::const_reference const_reference;
; 567  : 
; 568  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 569  : 	typedef _Tree_iterator<_Myt> iterator;
; 570  : 
; 571  : 	_Tree_val()
; 572  : 		{	// initialize data
; 573  : 		this->_Myhead = 0;
; 574  : 		this->_Mysize = 0;
; 575  : 		}
; 576  : 
; 577  : 	enum _Redbl
; 578  : 		{	// colors for link to parent
; 579  : 		_Red, _Black};
; 580  : 
; 581  : 	static char& _Color(_Nodeptr _Pnode)
; 582  : 		{	// return reference to color in node
; 583  : 		return ((char&)_Pnode->_Color);
; 584  : 		}
; 585  : 
; 586  : 	static char& _Isnil(_Nodeptr _Pnode)
; 587  : 		{	// return reference to nil flag in node
; 588  : 		return ((char&)_Pnode->_Isnil);

  001d4	8b 0e		 mov	 ecx, DWORD PTR [esi]

; 2116 : 
; 2117 : 		if (!this->_Isnil(this->_Left(_Pnode)))

  001d6	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  001da	75 03		 jne	 SHORT $LN353@Insert_at

; 2118 : 			this->_Parent(this->_Left(_Pnode)) = _Wherenode;

  001dc	89 51 04	 mov	 DWORD PTR [ecx+4], edx
$LN353@Insert_at:

; 2119 : 		this->_Parent(_Pnode) = this->_Parent(_Wherenode);

  001df	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  001e2	89 4e 04	 mov	 DWORD PTR [esi+4], ecx

; 594  : 		}
; 595  : 
; 596  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 597  : 		{	// return reference to parent pointer in node
; 598  : 		return ((_Nodepref)_Pnode->_Parent);

  001e5	8b 0f		 mov	 ecx, DWORD PTR [edi]

; 2120 : 
; 2121 : 		if (_Wherenode == _Root())

  001e7	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  001ea	75 05		 jne	 SHORT $LN352@Insert_at

; 2122 : 			_Root() = _Pnode;

  001ec	89 71 04	 mov	 DWORD PTR [ecx+4], esi

; 2123 : 		else if (_Wherenode == this->_Left(this->_Parent(_Wherenode)))

  001ef	eb 0e		 jmp	 SHORT $LN349@Insert_at
$LN352@Insert_at:

; 589  : 		}
; 590  : 
; 591  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 592  : 		{	// return reference to left pointer in node
; 593  : 		return ((_Nodepref)_Pnode->_Left);

  001f1	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]

; 2123 : 		else if (_Wherenode == this->_Left(this->_Parent(_Wherenode)))

  001f4	3b 11		 cmp	 edx, DWORD PTR [ecx]
  001f6	75 04		 jne	 SHORT $LN350@Insert_at

; 2124 : 			this->_Left(this->_Parent(_Wherenode)) = _Pnode;

  001f8	89 31		 mov	 DWORD PTR [ecx], esi

; 2125 : 		else

  001fa	eb 03		 jmp	 SHORT $LN349@Insert_at
$LN350@Insert_at:

; 2126 : 			this->_Right(this->_Parent(_Wherenode)) = _Pnode;

  001fc	89 71 08	 mov	 DWORD PTR [ecx+8], esi
$LN349@Insert_at:

; 2127 : 
; 2128 : 		this->_Left(_Pnode) = _Wherenode;

  001ff	89 16		 mov	 DWORD PTR [esi], edx
$LN415@Insert_at:

; 2129 : 		this->_Parent(_Wherenode) = _Pnode;

  00201	89 72 04	 mov	 DWORD PTR [edx+4], esi
$LN354@Insert_at:

; 1867 : 			}
; 1868 : 
; 1869 : 		for (_Nodeptr _Pnode = _Newnode;
; 1870 : 			this->_Color(this->_Parent(_Pnode)) == this->_Red; )

  00204	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00207	80 79 0c 00	 cmp	 BYTE PTR [ecx+12], 0
  0020b	0f 84 86 fe ff
	ff		 je	 $LL10@Insert_at
$LN9@Insert_at:

; 1922 : 					}
; 1923 : 				}
; 1924 : 
; 1925 : 		this->_Color(_Root()) = this->_Black;	// root is always black

  00211	8b 07		 mov	 eax, DWORD PTR [edi]
  00213	5f		 pop	 edi
  00214	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00217	5e		 pop	 esi
  00218	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1

; 44   : 		{	// construct with node pointer _Pnode

  0021c	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0021f	89 18		 mov	 DWORD PTR [eax], ebx
  00221	5b		 pop	 ebx

; 1926 : 		return (iterator(_Newnode, this));
; 1927 : 		}

  00222	5d		 pop	 ebp
  00223	c2 14 00	 ret	 20			; 00000014H
$LN417@Insert_at:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 128  : 			_Delete_this();

  00226	8b 06		 mov	 eax, DWORD PTR [esi]
  00228	8b ce		 mov	 ecx, esi
  0022a	ff 50 04	 call	 DWORD PTR [eax+4]
$LN57@Insert_at:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 586  : 		::operator delete(_Ptr);

  0022d	53		 push	 ebx
  0022e	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00233	83 c4 04	 add	 esp, 4
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree

; 1842 : 			_Xlength_error("map/set<T> too long");

  00236	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@
  0023b	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN419@Insert_at:
$LN414@Insert_at:
  00240	cc		 int	 3
??$_Insert_at@AAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@_NPAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@1@AAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@1@Z ENDP ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Insert_at<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > &,std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void *> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
;	COMDAT ??$_Insert_nohint@AAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@PAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@1@@Z
_TEXT	SEGMENT
tv690 = -28						; size = 4
$T2 = -28						; size = 4
_this$1$ = -24						; size = 4
__Addleft$3 = -20					; size = 1
__$EHRec$ = -16						; size = 16
___$ReturnUdt$ = 8					; size = 4
__Leftish$dead$ = 12					; size = 1
$T4 = 16						; size = 4
__Where$5 = 16						; size = 4
__Val$ = 16						; size = 4
__Newnode$ = 20						; size = 4
??$_Insert_nohint@AAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@PAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@1@@Z PROC ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Insert_nohint<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > &,std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void *> *>, COMDAT
; _this$ = ecx

; 1780 : 		_Pairib _Insert_nohint(bool _Leftish,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Insert_nohint@AAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@PAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 10	 sub	 esp, 16			; 00000010H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002b	8b c1		 mov	 eax, ecx
  0002d	89 45 e8	 mov	 DWORD PTR _this$1$[ebp], eax

; 1781 : 			_Valty&& _Val, _Nodety _Newnode)
; 1782 : 		{	// try to insert node, on left if _Leftish
; 1783 : 		_TRY_BEGIN

  00030	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  :  #if _HAS_CPP0X
; 520  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 521  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 522  : 
; 523  :  #else /* _HAS_CPP0X */
; 524  : 	typedef typename _Alloc::template rebind<_Ty>::other _Alty;
; 525  :  #endif /* _HAS_CPP0X */
; 526  : 
; 527  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 528  : 		_Voidptr;
; 529  : 	typedef _Tree_node<typename _Alty::value_type,
; 530  : 		_Voidptr> _Node;
; 531  : 
; 532  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 533  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 534  : 	typedef _Nodeptr& _Nodepref;
; 535  : 
; 536  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 537  : 		_Tree_simple_types<typename _Alty::value_type>,
; 538  : 		_Tree_iter_types<typename _Alty::value_type,
; 539  : 			typename _Alty::size_type,
; 540  : 			typename _Alty::difference_type,
; 541  : 			typename _Alty::pointer,
; 542  : 			typename _Alty::const_pointer,
; 543  : 			typename _Alty::reference,
; 544  : 			typename _Alty::const_reference,
; 545  : 			_Nodeptr> >::type
; 546  : 		_Val_types;
; 547  : 	};
; 548  : 
; 549  : 		// TEMPLATE CLASS _Tree_val
; 550  : template<class _Val_types>
; 551  : 	class _Tree_val
; 552  : 		: public _Container_base
; 553  : 	{	// base class for tree to hold data
; 554  : public:
; 555  : 	typedef _Tree_val<_Val_types> _Myt;
; 556  : 
; 557  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 558  : 	typedef _Nodeptr& _Nodepref;
; 559  : 
; 560  : 	typedef typename _Val_types::value_type value_type;
; 561  : 	typedef typename _Val_types::size_type size_type;
; 562  : 	typedef typename _Val_types::difference_type difference_type;
; 563  : 	typedef typename _Val_types::pointer pointer;
; 564  : 	typedef typename _Val_types::const_pointer const_pointer;
; 565  : 	typedef typename _Val_types::reference reference;
; 566  : 	typedef typename _Val_types::const_reference const_reference;
; 567  : 
; 568  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 569  : 	typedef _Tree_iterator<_Myt> iterator;
; 570  : 
; 571  : 	_Tree_val()
; 572  : 		{	// initialize data
; 573  : 		this->_Myhead = 0;
; 574  : 		this->_Mysize = 0;
; 575  : 		}
; 576  : 
; 577  : 	enum _Redbl
; 578  : 		{	// colors for link to parent
; 579  : 		_Red, _Black};
; 580  : 
; 581  : 	static char& _Color(_Nodeptr _Pnode)
; 582  : 		{	// return reference to color in node
; 583  : 		return ((char&)_Pnode->_Color);
; 584  : 		}
; 585  : 
; 586  : 	static char& _Isnil(_Nodeptr _Pnode)
; 587  : 		{	// return reference to nil flag in node
; 588  : 		return ((char&)_Pnode->_Isnil);
; 589  : 		}
; 590  : 
; 591  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 592  : 		{	// return reference to left pointer in node
; 593  : 		return ((_Nodepref)_Pnode->_Left);
; 594  : 		}
; 595  : 
; 596  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 597  : 		{	// return reference to parent pointer in node
; 598  : 		return ((_Nodepref)_Pnode->_Parent);

  00037	8b 08		 mov	 ecx, DWORD PTR [eax]
  00039	8b 7d 10	 mov	 edi, DWORD PTR __Val$[ebp]

; 1784 : 		_Nodeptr _Trynode = _Root();

  0003c	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]

; 1786 : 		bool _Addleft = true;	// add to left of head if tree empty

  0003f	b0 01		 mov	 al, 1

; 1787 : 
; 1788 : 		while (!this->_Isnil(_Trynode))

  00041	80 7a 0d 00	 cmp	 BYTE PTR [edx+13], 0

; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  :  #if _HAS_CPP0X
; 520  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 521  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 522  : 
; 523  :  #else /* _HAS_CPP0X */
; 524  : 	typedef typename _Alloc::template rebind<_Ty>::other _Alty;
; 525  :  #endif /* _HAS_CPP0X */
; 526  : 
; 527  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 528  : 		_Voidptr;
; 529  : 	typedef _Tree_node<typename _Alty::value_type,
; 530  : 		_Voidptr> _Node;
; 531  : 
; 532  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 533  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 534  : 	typedef _Nodeptr& _Nodepref;
; 535  : 
; 536  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 537  : 		_Tree_simple_types<typename _Alty::value_type>,
; 538  : 		_Tree_iter_types<typename _Alty::value_type,
; 539  : 			typename _Alty::size_type,
; 540  : 			typename _Alty::difference_type,
; 541  : 			typename _Alty::pointer,
; 542  : 			typename _Alty::const_pointer,
; 543  : 			typename _Alty::reference,
; 544  : 			typename _Alty::const_reference,
; 545  : 			_Nodeptr> >::type
; 546  : 		_Val_types;
; 547  : 	};
; 548  : 
; 549  : 		// TEMPLATE CLASS _Tree_val
; 550  : template<class _Val_types>
; 551  : 	class _Tree_val
; 552  : 		: public _Container_base
; 553  : 	{	// base class for tree to hold data
; 554  : public:
; 555  : 	typedef _Tree_val<_Val_types> _Myt;
; 556  : 
; 557  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 558  : 	typedef _Nodeptr& _Nodepref;
; 559  : 
; 560  : 	typedef typename _Val_types::value_type value_type;
; 561  : 	typedef typename _Val_types::size_type size_type;
; 562  : 	typedef typename _Val_types::difference_type difference_type;
; 563  : 	typedef typename _Val_types::pointer pointer;
; 564  : 	typedef typename _Val_types::const_pointer const_pointer;
; 565  : 	typedef typename _Val_types::reference reference;
; 566  : 	typedef typename _Val_types::const_reference const_reference;
; 567  : 
; 568  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 569  : 	typedef _Tree_iterator<_Myt> iterator;
; 570  : 
; 571  : 	_Tree_val()
; 572  : 		{	// initialize data
; 573  : 		this->_Myhead = 0;
; 574  : 		this->_Mysize = 0;
; 575  : 		}
; 576  : 
; 577  : 	enum _Redbl
; 578  : 		{	// colors for link to parent
; 579  : 		_Red, _Black};
; 580  : 
; 581  : 	static char& _Color(_Nodeptr _Pnode)
; 582  : 		{	// return reference to color in node
; 583  : 		return ((char&)_Pnode->_Color);
; 584  : 		}
; 585  : 
; 586  : 	static char& _Isnil(_Nodeptr _Pnode)
; 587  : 		{	// return reference to nil flag in node
; 588  : 		return ((char&)_Pnode->_Isnil);
; 589  : 		}
; 590  : 
; 591  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 592  : 		{	// return reference to left pointer in node
; 593  : 		return ((_Nodepref)_Pnode->_Left);
; 594  : 		}
; 595  : 
; 596  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 597  : 		{	// return reference to parent pointer in node
; 598  : 		return ((_Nodepref)_Pnode->_Parent);

  00045	89 4d e4	 mov	 DWORD PTR tv690[ebp], ecx

; 1785 : 		_Nodeptr _Wherenode = this->_Myhead;

  00048	8b d9		 mov	 ebx, ecx

; 1786 : 		bool _Addleft = true;	// add to left of head if tree empty

  0004a	88 45 ec	 mov	 BYTE PTR __Addleft$3[ebp], al

; 1787 : 
; 1788 : 		while (!this->_Isnil(_Trynode))

  0004d	75 45		 jne	 SHORT $LN11@Insert_noh
  0004f	8b 37		 mov	 esi, DWORD PTR [edi]
$LL12@Insert_noh:
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp

; 296  : 	if(cp1.x < cp2.x)

  00051	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree

; 1790 : 			_Wherenode = _Trynode;

  00054	8b da		 mov	 ebx, edx
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp

; 296  : 	if(cp1.x < cp2.x)

  00056	3b f0		 cmp	 esi, eax
  00058	7d 04		 jge	 SHORT $LN195@Insert_noh

; 297  : 	{
; 298  : 		return true;

  0005a	b0 01		 mov	 al, 1
  0005c	eb 1f		 jmp	 SHORT $LN74@Insert_noh
$LN195@Insert_noh:

; 299  : 	}
; 300  : 	else if(cp1.x == cp2.x)

  0005e	75 1b		 jne	 SHORT $LN68@Insert_noh

; 301  : 	{
; 302  : 		if(cp1.y < cp2.y)

  00060	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00063	8b 4a 14	 mov	 ecx, DWORD PTR [edx+20]
  00066	3b c1		 cmp	 eax, ecx
  00068	7d 04		 jge	 SHORT $LN196@Insert_noh

; 303  : 		{
; 304  : 			return true;

  0006a	b0 01		 mov	 al, 1
  0006c	eb 0f		 jmp	 SHORT $LN74@Insert_noh
$LN196@Insert_noh:

; 305  : 		}
; 306  : 		else if(cp1.y == cp2.y)

  0006e	75 0b		 jne	 SHORT $LN68@Insert_noh

; 307  : 		{
; 308  : 			return cp1.z < cp2.z;

  00070	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  00073	3b 42 18	 cmp	 eax, DWORD PTR [edx+24]
  00076	0f 9c c0	 setl	 al
  00079	eb 02		 jmp	 SHORT $LN74@Insert_noh
$LN68@Insert_noh:

; 309  : 		}
; 310  : 	}
; 311  : 
; 312  : 	return false;

  0007b	32 c0		 xor	 al, al
$LN74@Insert_noh:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree

; 1796 : 				_Addleft = _DEBUG_LT_PRED(this->_Getcomp(),

  0007d	88 45 ec	 mov	 BYTE PTR __Addleft$3[ebp], al

; 1797 : 					this->_Kfn(_Val),
; 1798 : 					this->_Key(_Trynode));	// favor right end
; 1799 : 			_Trynode = _Addleft ? this->_Left(_Trynode)
; 1800 : 				: this->_Right(_Trynode);

  00080	84 c0		 test	 al, al
  00082	74 04		 je	 SHORT $LN16@Insert_noh
  00084	8b 12		 mov	 edx, DWORD PTR [edx]
  00086	eb 03		 jmp	 SHORT $LN17@Insert_noh
$LN16@Insert_noh:
  00088	8b 52 08	 mov	 edx, DWORD PTR [edx+8]
$LN17@Insert_noh:

; 1787 : 
; 1788 : 		while (!this->_Isnil(_Trynode))

  0008b	80 7a 0d 00	 cmp	 BYTE PTR [edx+13], 0
  0008f	74 c0		 je	 SHORT $LL12@Insert_noh
  00091	8b 4d e4	 mov	 ecx, DWORD PTR tv690[ebp]
$LN11@Insert_noh:

; 44   : 		{	// construct with node pointer _Pnode

  00094	8b f3		 mov	 esi, ebx
  00096	89 75 10	 mov	 DWORD PTR __Where$5[ebp], esi

; 1801 : 			}
; 1802 : 
; 1803 : 		if (this->_Multi)
; 1804 : 			return (_Pairib(_Insert_at(_Addleft, _Wherenode,
; 1805 : 				_STD forward<_Valty>(_Val), _Newnode), true));
; 1806 : 		else
; 1807 : 			{	// insert only if unique
; 1808 : 			iterator _Where = iterator(_Wherenode, this);
; 1809 : 			if (!_Addleft)

  00099	84 c0		 test	 al, al
  0009b	74 41		 je	 SHORT $LN134@Insert_noh

; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);

  0009d	3b 19		 cmp	 ebx, DWORD PTR [ecx]

; 1810 : 				;	// need to test if insert after is okay
; 1811 : 			else if (_Where == begin())

  0009f	75 32		 jne	 SHORT $LN4@Insert_noh

; 1812 : 				return (_Pairib(_Insert_at(true, _Wherenode,

  000a1	ff 75 14	 push	 DWORD PTR __Newnode$[ebp]
  000a4	8d 45 10	 lea	 eax, DWORD PTR $T4[ebp]
  000a7	51		 push	 ecx
  000a8	53		 push	 ebx
  000a9	6a 01		 push	 1
$LN197@Insert_noh:

; 1818 : 				this->_Key(_Where._Mynode()),
; 1819 : 				this->_Kfn(_Val)))
; 1820 : 				return (_Pairib(_Insert_at(_Addleft, _Wherenode,

  000ab	8b 4d e8	 mov	 ecx, DWORD PTR _this$1$[ebp]
  000ae	50		 push	 eax
  000af	e8 00 00 00 00	 call	 ??$_Insert_at@AAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@_NPAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@1@AAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@1@Z ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Insert_at<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > &,std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void *> *>
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility

; 182  : 		{	// construct from moved compatible pair

  000b4	8b 08		 mov	 ecx, DWORD PTR [eax]
  000b6	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  000b9	89 08		 mov	 DWORD PTR [eax], ecx
  000bb	c6 40 04 01	 mov	 BYTE PTR [eax+4], 1
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree

; 1832 : 		}

  000bf	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  000c2	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000c9	59		 pop	 ecx
  000ca	5f		 pop	 edi
  000cb	5e		 pop	 esi
  000cc	5b		 pop	 ebx
  000cd	8b e5		 mov	 esp, ebp
  000cf	5d		 pop	 ebp
  000d0	c2 10 00	 ret	 16			; 00000010H
$LN4@Insert_noh:

; 45   : 		this->_Adopt(_Plist);
; 46   : 		}
; 47   : 
; 48   : 	reference operator*() const
; 49   : 		{	// return designated value
; 50   : 		return (_Mytree::_Myval(_Ptr));
; 51   : 		}
; 52   : 
; 53   : 	pointer operator->() const
; 54   : 		{	// return pointer to class object
; 55   : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 56   : 		}
; 57   : 
; 58   : 	_Myiter& operator++()
; 59   : 		{	// preincrement
; 60   : 		if (_Mytree::_Isnil(_Ptr))
; 61   : 			;	// end() shouldn't be incremented, don't move
; 62   : 		else if (!_Mytree::_Isnil(_Mytree::_Right(_Ptr)))
; 63   : 			_Ptr = _Mytree::_Min(
; 64   : 				_Mytree::_Right(_Ptr));	// ==> smallest of right subtree
; 65   : 		else
; 66   : 			{	// climb looking for right subtree
; 67   : 			_Nodeptr _Pnode;
; 68   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 69   : 				&& _Ptr == _Mytree::_Right(_Pnode))
; 70   : 				_Ptr = _Pnode;	// ==> parent while right subtree
; 71   : 			_Ptr = _Pnode;	// ==> parent (head if end())
; 72   : 			}
; 73   : 		return (*this);
; 74   : 		}
; 75   : 
; 76   : 	_Myiter operator++(int)
; 77   : 		{	// postincrement
; 78   : 		_Myiter _Tmp = *this;
; 79   : 		++*this;
; 80   : 		return (_Tmp);
; 81   : 		}
; 82   : 
; 83   : 	_Myiter& operator--()
; 84   : 		{	// predecrement
; 85   : 		if (_Mytree::_Isnil(_Ptr))
; 86   : 			_Ptr = _Mytree::_Right(_Ptr);	// end() ==> rightmost
; 87   : 		else if (!_Mytree::_Isnil(_Mytree::_Left(_Ptr)))
; 88   : 			_Ptr = _Mytree::_Max(
; 89   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree
; 90   : 		else
; 91   : 			{	// climb looking for left subtree
; 92   : 			_Nodeptr _Pnode;
; 93   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 94   : 				&& _Ptr == _Mytree::_Left(_Pnode))
; 95   : 				_Ptr = _Pnode;	// ==> parent while left subtree
; 96   : 			if (_Mytree::_Isnil(_Ptr))
; 97   : 				;	// begin() shouldn't be decremented, don't move
; 98   : 			else
; 99   : 				_Ptr = _Pnode;	// ==> parent if not head
; 100  : 			}
; 101  : 		return (*this);
; 102  : 		}
; 103  : 
; 104  : 	_Myiter operator--(int)
; 105  : 		{	// postdecrement
; 106  : 		_Myiter _Tmp = *this;
; 107  : 		--*this;
; 108  : 		return (_Tmp);
; 109  : 		}
; 110  : 
; 111  : 	bool operator==(const _Myiter& _Right) const
; 112  : 		{	// test for iterator equality
; 113  : 		return (_Ptr == _Right._Ptr);
; 114  : 		}
; 115  : 
; 116  : 	bool operator!=(const _Myiter& _Right) const
; 117  : 		{	// test for iterator inequality
; 118  : 		return (!(*this == _Right));
; 119  : 		}
; 120  : 
; 121  : 	_Nodeptr _Mynode() const
; 122  : 		{	// return node pointer
; 123  : 		return (_Ptr);
; 124  : 		}
; 125  : 
; 126  : 	_Nodeptr _Ptr;	// pointer to node
; 127  : 	};
; 128  : 
; 129  : 	// TEMPLATE CLASS _Tree_unchecked_iterator
; 130  : template<class _Mytree>
; 131  : 	class _Tree_unchecked_iterator
; 132  : 		: public _Tree_unchecked_const_iterator<_Mytree>
; 133  : 	{	// unchecked iterator for mutable tree
; 134  : public:
; 135  : 	typedef _Tree_unchecked_iterator<_Mytree> _Myiter;
; 136  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Mybase;
; 137  : 	typedef bidirectional_iterator_tag iterator_category;
; 138  : 
; 139  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 140  : 	typedef typename _Mytree::value_type value_type;
; 141  : 	typedef typename _Mytree::difference_type difference_type;
; 142  : 	typedef typename _Mytree::pointer pointer;
; 143  : 	typedef typename _Mytree::reference reference;
; 144  : 
; 145  : 	_Tree_unchecked_iterator()
; 146  : 		{	// construct with null node
; 147  : 		}
; 148  : 
; 149  : 	_Tree_unchecked_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 150  : 		: _Mybase(_Pnode, _Plist)
; 151  : 		{	// construct with node pointer _Pnode
; 152  : 		}
; 153  : 
; 154  : 	reference operator*() const
; 155  : 		{	// return designated value
; 156  : 		return ((reference)**(_Mybase *)this);
; 157  : 		}
; 158  : 
; 159  : 	pointer operator->() const
; 160  : 		{	// return pointer to class object
; 161  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 162  : 		}
; 163  : 
; 164  : 	_Myiter& operator++()
; 165  : 		{	// preincrement
; 166  : 		++(*(_Mybase *)this);
; 167  : 		return (*this);
; 168  : 		}
; 169  : 
; 170  : 	_Myiter operator++(int)
; 171  : 		{	// postincrement
; 172  : 		_Myiter _Tmp = *this;
; 173  : 		++*this;
; 174  : 		return (_Tmp);
; 175  : 		}
; 176  : 
; 177  : 	_Myiter& operator--()
; 178  : 		{	// predecrement
; 179  : 		--(*(_Mybase *)this);
; 180  : 		return (*this);
; 181  : 		}
; 182  : 
; 183  : 	_Myiter operator--(int)
; 184  : 		{	// postdecrement
; 185  : 		_Myiter _Tmp = *this;
; 186  : 		--*this;
; 187  : 		return (_Tmp);
; 188  : 		}
; 189  : 	};
; 190  : 
; 191  : 	// TEMPLATE CLASS _Tree_const_iterator
; 192  : template<class _Mytree>
; 193  : 	class _Tree_const_iterator
; 194  : 		: public _Tree_unchecked_const_iterator<_Mytree, _Iterator_base>
; 195  : 	{	// iterator for nonmutable tree
; 196  : public:
; 197  : 	typedef _Tree_const_iterator<_Mytree> _Myiter;
; 198  : 	typedef _Tree_unchecked_const_iterator<_Mytree, _Iterator_base> _Mybase;
; 199  : 	typedef bidirectional_iterator_tag iterator_category;
; 200  : 
; 201  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 202  : 	typedef typename _Mytree::value_type value_type;
; 203  : 	typedef typename _Mytree::difference_type difference_type;
; 204  : 	typedef typename _Mytree::const_pointer pointer;
; 205  : 	typedef typename _Mytree::const_reference reference;
; 206  : 
; 207  : 	_Tree_const_iterator()
; 208  : 		: _Mybase()
; 209  : 		{	// construct with null node pointer
; 210  : 		}
; 211  : 
; 212  : 	_Tree_const_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 213  : 		: _Mybase(_Pnode, _Plist)
; 214  : 		{	// construct with node pointer _Pnode
; 215  : 		}
; 216  : 
; 217  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Unchecked_type;
; 218  : 
; 219  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 220  : 		{	// reset from unchecked iterator
; 221  : 		this->_Ptr = _Right._Ptr;
; 222  : 		return (*this);
; 223  : 		}
; 224  : 
; 225  : 	_Unchecked_type _Unchecked() const
; 226  : 		{	// make an unchecked iterator
; 227  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 228  : 		}
; 229  : 
; 230  : 	reference operator*() const
; 231  : 		{	// return designated value
; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		if (this->_Getcont() == 0
; 234  : 			|| this->_Ptr == 0
; 235  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 236  : 			{	// report error
; 237  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 238  : 			_SCL_SECURE_OUT_OF_RANGE;
; 239  : 			}
; 240  : 
; 241  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 242  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 243  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 244  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 245  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 246  : 
; 247  : 		return (_Mytree::_Myval(this->_Ptr));
; 248  : 		}
; 249  : 
; 250  : 	pointer operator->() const
; 251  : 		{	// return pointer to class object
; 252  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 253  : 		}
; 254  : 
; 255  : 	_Myiter& operator++()
; 256  : 		{	// preincrement
; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);
; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);

  000d3	8d 4d 10	 lea	 ecx, DWORD PTR __Where$5[ebp]
  000d6	e8 00 00 00 00	 call	 ??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >,std::_Iterator_base0>::operator--
  000db	8b 75 10	 mov	 esi, DWORD PTR __Where$5[ebp]
$LN134@Insert_noh:
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp

; 296  : 	if(cp1.x < cp2.x)

  000de	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  000e1	8b 0f		 mov	 ecx, DWORD PTR [edi]
  000e3	3b c1		 cmp	 eax, ecx
  000e5	7c 40		 jl	 SHORT $LN191@Insert_noh

; 299  : 	}
; 300  : 	else if(cp1.x == cp2.x)

  000e7	75 19		 jne	 SHORT $LN2@Insert_noh

; 301  : 	{
; 302  : 		if(cp1.y < cp2.y)

  000e9	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  000ec	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  000ef	3b c1		 cmp	 eax, ecx
  000f1	7c 34		 jl	 SHORT $LN191@Insert_noh

; 305  : 		}
; 306  : 		else if(cp1.y == cp2.y)

  000f3	75 0d		 jne	 SHORT $LN2@Insert_noh

; 307  : 		{
; 308  : 			return cp1.z < cp2.z;

  000f5	8b 46 18	 mov	 eax, DWORD PTR [esi+24]
  000f8	3b 47 08	 cmp	 eax, DWORD PTR [edi+8]
  000fb	0f 9c c0	 setl	 al
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree

; 1817 : 			if (_DEBUG_LT_PRED(this->_Getcomp(),

  000fe	84 c0		 test	 al, al
  00100	75 25		 jne	 SHORT $LN191@Insert_noh
$LN2@Insert_noh:

; 1821 : 					_STD forward<_Valty>(_Val), _Newnode), true));
; 1822 : 			else
; 1823 : 				{	// duplicate, don't insert
; 1824 : 				_Destroy_if_not_nil(_Newnode);

  00102	ff 75 14	 push	 DWORD PTR __Newnode$[ebp]
  00105	e8 00 00 00 00	 call	 ?_Destroy_if_not_nil@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Destroy_if_not_nil
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility

; 182  : 		{	// construct from moved compatible pair

  0010a	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0010d	89 30		 mov	 DWORD PTR [eax], esi
  0010f	c6 40 04 00	 mov	 BYTE PTR [eax+4], 0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree

; 1832 : 		}

  00113	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00116	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0011d	59		 pop	 ecx
  0011e	5f		 pop	 edi
  0011f	5e		 pop	 esi
  00120	5b		 pop	 ebx
  00121	8b e5		 mov	 esp, ebp
  00123	5d		 pop	 ebp
  00124	c2 10 00	 ret	 16			; 00000010H
$LN191@Insert_noh:

; 1818 : 				this->_Key(_Where._Mynode()),
; 1819 : 				this->_Kfn(_Val)))
; 1820 : 				return (_Pairib(_Insert_at(_Addleft, _Wherenode,

  00127	ff 75 14	 push	 DWORD PTR __Newnode$[ebp]
  0012a	8d 45 e4	 lea	 eax, DWORD PTR $T2[ebp]
  0012d	51		 push	 ecx
  0012e	53		 push	 ebx
  0012f	ff 75 ec	 push	 DWORD PTR __Addleft$3[ebp]
  00132	e9 74 ff ff ff	 jmp	 $LN197@Insert_noh
__catch$??$_Insert_nohint@AAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@PAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@1@@Z$0:

; 1825 : 				return (_Pairib(_Where, false));
; 1826 : 				}
; 1827 : 			}
; 1828 : 		_CATCH_ALL
; 1829 : 		_Destroy_if_not_nil(_Newnode);

  00137	ff 75 14	 push	 DWORD PTR __Newnode$[ebp]
  0013a	e8 00 00 00 00	 call	 ?_Destroy_if_not_nil@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Destroy_if_not_nil

; 1830 : 		_RERAISE;

  0013f	6a 00		 push	 0
  00141	6a 00		 push	 0
  00143	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN198@Insert_noh:
$LN194@Insert_noh:
  00148	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Insert_nohint@AAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@PAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@1@@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a e0	 mov	 ecx, DWORD PTR [edx-32]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Insert_nohint@AAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@PAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@1@@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Insert_nohint@AAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@PAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Insert_nohint<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > &,std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void *> *>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@std@@@std@@QAEXPAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@std@@@std@@QAEXPAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z PROC ; std::allocator<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void *> >::destroy<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >, COMDAT
; _this$dead$ = ecx

; 621  : 		void destroy(_Uty *_Ptr)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	56		 push	 esi
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  00007	8b 70 10	 mov	 esi, DWORD PTR [eax+16]
  0000a	85 f6		 test	 esi, esi
  0000c	74 27		 je	 SHORT $LN16@destroy
  0000e	57		 push	 edi

; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  0000f	83 cf ff	 or	 edi, -1
  00012	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  00015	8b c7		 mov	 eax, edi
  00017	f0 0f c1 01	 lock	  xadd	 DWORD PTR [ecx], eax
  0001b	75 17		 jne	 SHORT $LN19@destroy

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  0001d	8b 06		 mov	 eax, DWORD PTR [esi]
  0001f	8b ce		 mov	 ecx, esi
  00021	ff 10		 call	 DWORD PTR [eax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  00023	8d 46 08	 lea	 eax, DWORD PTR [esi+8]
  00026	f0 0f c1 38	 lock	  xadd	 DWORD PTR [eax], edi
  0002a	4f		 dec	 edi
  0002b	75 07		 jne	 SHORT $LN19@destroy

; 128  : 			_Delete_this();

  0002d	8b 06		 mov	 eax, DWORD PTR [esi]
  0002f	8b ce		 mov	 ecx, esi
  00031	ff 50 04	 call	 DWORD PTR [eax+4]
$LN19@destroy:
  00034	5f		 pop	 edi
$LN16@destroy:
  00035	5e		 pop	 esi
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 624  : 		}

  00036	5d		 pop	 ebp
  00037	c2 04 00	 ret	 4
??$destroy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@std@@@std@@QAEXPAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z ENDP ; std::allocator<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void *> >::destroy<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@std@@@?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@1@@Z
_TEXT	SEGMENT
__Ptr$dead$ = 8						; size = 4
??$destroy@PAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@std@@@?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@1@@Z PROC ; std::allocator<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void *> >::destroy<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void *> *>, COMDAT
; _this$dead$ = ecx

; 622  : 		{	// destroy object at _Ptr
; 623  : 		_Ptr->~_Uty();
; 624  : 		}

  00000	c2 04 00	 ret	 4
??$destroy@PAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@std@@@?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@1@@Z ENDP ; std::allocator<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void *> >::destroy<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void *> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@PAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@std@@AAPAU12@@?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@1@AAPAU21@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__V0$ = 12						; size = 4
??$construct@PAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@std@@AAPAU12@@?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@1@AAPAU21@@Z PROC ; std::allocator<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void *> >::construct<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void *> *,std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void *> * &>, COMDAT
; _this$dead$ = ecx

; 617  : _VARIADIC_EXPAND_0X(_ALLOC_MEMBER_CONSTRUCT, , , , )

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN3@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR __V0$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 01		 mov	 DWORD PTR [ecx], eax
$LN3@construct:
  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
??$construct@PAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@std@@AAPAU12@@?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@1@AAPAU21@@Z ENDP ; std::allocator<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void *> >::construct<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void *> *,std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void *> * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ??_G?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$dead$ = 8					; size = 4
??_G?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@QAEPAXI@Z PROC ; std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	57		 push	 edi

; 345  : 		if (_Rep != 0)

  00004	8b 7e 10	 mov	 edi, DWORD PTR [esi+16]
  00007	85 ff		 test	 edi, edi
  00009	74 2e		 je	 SHORT $LN19@scalar
  0000b	53		 push	 ebx

; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  0000c	83 cb ff	 or	 ebx, -1
  0000f	8d 57 04	 lea	 edx, DWORD PTR [edi+4]
  00012	8b c3		 mov	 eax, ebx
  00014	f0 0f c1 02	 lock	  xadd	 DWORD PTR [edx], eax
  00018	75 17		 jne	 SHORT $LN18@scalar

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  0001a	8b 07		 mov	 eax, DWORD PTR [edi]
  0001c	8b cf		 mov	 ecx, edi
  0001e	ff 10		 call	 DWORD PTR [eax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  00020	8d 47 08	 lea	 eax, DWORD PTR [edi+8]
  00023	f0 0f c1 18	 lock	  xadd	 DWORD PTR [eax], ebx
  00027	4b		 dec	 ebx
  00028	75 07		 jne	 SHORT $LN18@scalar

; 128  : 			_Delete_this();

  0002a	8b 07		 mov	 eax, DWORD PTR [edi]
  0002c	8b cf		 mov	 ecx, edi
  0002e	ff 50 04	 call	 DWORD PTR [eax+4]
$LN18@scalar:
  00031	5b		 pop	 ebx
  00032	5f		 pop	 edi
  00033	8b c6		 mov	 eax, esi
  00035	5e		 pop	 esi
  00036	c2 04 00	 ret	 4
$LN19@scalar:
  00039	5f		 pop	 edi
  0003a	8b c6		 mov	 eax, esi
  0003c	5e		 pop	 esi
  0003d	c2 04 00	 ret	 4
??_G?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@QAEPAXI@Z ENDP ; std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ??1?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@QAE@XZ PROC ; std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >::~pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >, COMDAT
; _this$ = ecx
  00000	56		 push	 esi

; 345  : 		if (_Rep != 0)

  00001	8b 71 10	 mov	 esi, DWORD PTR [ecx+16]
  00004	85 f6		 test	 esi, esi
  00006	74 29		 je	 SHORT $LN11@pair
  00008	57		 push	 edi

; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  00009	83 cf ff	 or	 edi, -1
  0000c	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  0000f	8b c7		 mov	 eax, edi
  00011	f0 0f c1 01	 lock	  xadd	 DWORD PTR [ecx], eax
  00015	75 19		 jne	 SHORT $LN14@pair

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  00017	8b 06		 mov	 eax, DWORD PTR [esi]
  00019	8b ce		 mov	 ecx, esi
  0001b	ff 10		 call	 DWORD PTR [eax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  0001d	8d 46 08	 lea	 eax, DWORD PTR [esi+8]
  00020	f0 0f c1 38	 lock	  xadd	 DWORD PTR [eax], edi
  00024	4f		 dec	 edi
  00025	75 09		 jne	 SHORT $LN14@pair

; 128  : 			_Delete_this();

  00027	8b 06		 mov	 eax, DWORD PTR [esi]
  00029	5f		 pop	 edi
  0002a	8b ce		 mov	 ecx, esi
  0002c	5e		 pop	 esi
  0002d	ff 60 04	 jmp	 DWORD PTR [eax+4]
$LN14@pair:
  00030	5f		 pop	 edi
$LN11@pair:
  00031	5e		 pop	 esi
  00032	c3		 ret	 0
??1?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@QAE@XZ ENDP ; std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >::~pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
;	COMDAT ?max_size@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QBEIXZ PROC ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::max_size, COMDAT
; _this$dead$ = ecx

; 1278 : 		return (this->_Getal().max_size());

  00000	b8 c7 71 1c 07	 mov	 eax, 119304647		; 071c71c7H

; 1279 : 		}

  00005	c3		 ret	 0
?max_size@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QBEIXZ ENDP ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
;	COMDAT ??F?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??F?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::operator--, COMDAT
; _this$ = ecx

; 424  : 		{	// predecrement

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 308  : 		--(*(_Mybase *)this);

  00003	e8 00 00 00 00	 call	 ??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >,std::_Iterator_base0>::operator--

; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);

  00008	8b c6		 mov	 eax, esi
  0000a	5e		 pop	 esi

; 427  : 		}

  0000b	c3		 ret	 0
??F?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::operator--
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@std@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@std@@@std@@@std@@QBEIXZ PROC ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void *> > >::max_size, COMDAT
; _this$dead$ = ecx

; 914  : 		return (_Mytraits::max_size(*this));

  00000	b8 c7 71 1c 07	 mov	 eax, 119304647		; 071c71c7H

; 915  : 		}

  00005	c3		 ret	 0
?max_size@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@std@@@std@@@std@@QBEIXZ ENDP ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void *> > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@std@@@std@@@std@@SAIABV?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@std@@@2@@Z
_TEXT	SEGMENT
?max_size@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@std@@@std@@@std@@SAIABV?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@std@@@2@@Z PROC ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void *> > >::max_size, COMDAT
; __Al$dead$ = ecx

; 762  : 		return (_Al.max_size());

  00000	b8 c7 71 1c 07	 mov	 eax, 119304647		; 071c71c7H

; 763  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@std@@@std@@@std@@SAIABV?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@std@@@2@@Z ENDP ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void *> > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@std@@@std@@QBEIXZ PROC ; std::allocator<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void *> >::max_size, COMDAT
; _this$dead$ = ecx

; 628  : 		return ((size_t)(-1) / sizeof (_Ty));

  00000	b8 c7 71 1c 07	 mov	 eax, 119304647		; 071c71c7H

; 629  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@std@@@std@@QBEIXZ ENDP ; std::allocator<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void *> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@U?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@2@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@std@@@1@PAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@$$QAU?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z
_TEXT	SEGMENT
__V0$ = 8						; size = 4
??$construct@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@U?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@2@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@std@@@1@PAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@$$QAU?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z PROC ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void *> > >::construct<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::pair<ChunkPosition,std::shared_ptr<ChunkBase> > >, COMDAT
; __Al$dead$ = ecx
; __Ptr$ = edx

; 751  : _VARIADIC_EXPAND_0X(_ALLOC_TRAITS_SPECIAL_CONSTRUCT, , , , )

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 617  : _VARIADIC_EXPAND_0X(_ALLOC_MEMBER_CONSTRUCT, , , , )

  00003	85 d2		 test	 edx, edx
  00005	74 40		 je	 SHORT $LN40@construct
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility

; 182  : 		{	// construct from moved compatible pair

  00007	8b 4d 08	 mov	 ecx, DWORD PTR __V0$[ebp]
  0000a	83 c2 0c	 add	 edx, 12			; 0000000cH
  0000d	f3 0f 7e 01	 movq	 xmm0, QWORD PTR [ecx]
  00011	66 0f d6 42 f4	 movq	 QWORD PTR [edx-12], xmm0
  00016	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00019	89 42 fc	 mov	 DWORD PTR [edx-4], eax
  0001c	56		 push	 esi
  0001d	8d 71 0c	 lea	 esi, DWORD PTR [ecx+12]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 287  : 		{	// construct _Ptr_base object that takes resource from _Right

  00020	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0
  00026	c7 42 04 00 00
	00 00		 mov	 DWORD PTR [edx+4], 0

; 288  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 289  : 		}
; 290  : 
; 291  : 	template<class _Ty2>
; 292  : 		_Ptr_base(_Ptr_base<_Ty2>&& _Right)
; 293  : 		: _Ptr(_Right._Ptr), _Rep(_Right._Rep)
; 294  : 		{	// construct _Ptr_base object that takes resource from _Right
; 295  : 		_Right._Ptr = 0;
; 296  : 		_Right._Rep = 0;
; 297  : 		}
; 298  : 
; 299  : 	_Myt& operator=(_Myt&& _Right)
; 300  : 		{	// construct _Ptr_base object that takes resource from _Right
; 301  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 302  : 		return (*this);
; 303  : 		}
; 304  : 
; 305  : 	void _Assign_rv(_Myt&& _Right)
; 306  : 		{	// assign by moving _Right
; 307  : 		if (this != &_Right)

  0002d	3b d6		 cmp	 edx, esi
  0002f	74 15		 je	 SHORT $LN48@construct
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility

; 48   : 	_Left = _Move(_Right);

  00031	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00034	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 49   : 	_Right = _Move(_Tmp);

  00037	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 48   : 	_Left = _Move(_Right);

  0003e	8b 06		 mov	 eax, DWORD PTR [esi]
  00040	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00042	89 02		 mov	 DWORD PTR [edx], eax

; 49   : 	_Right = _Move(_Tmp);

  00044	89 0e		 mov	 DWORD PTR [esi], ecx
$LN48@construct:
  00046	5e		 pop	 esi
$LN40@construct:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 751  : _VARIADIC_EXPAND_0X(_ALLOC_TRAITS_SPECIAL_CONSTRUCT, , , , )

  00047	5d		 pop	 ebp
  00048	c3		 ret	 0
??$construct@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@U?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@2@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@std@@@1@PAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@$$QAU?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z ENDP ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void *> > >::construct<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::pair<ChunkPosition,std::shared_ptr<ChunkBase> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
;	COMDAT ??$_Buynode_if_nil@AAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@1@PAU21@AAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z
_TEXT	SEGMENT
__Node$ = 8						; size = 4
___formal$dead$ = 12					; size = 4
??$_Buynode_if_nil@AAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@1@PAU21@AAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z PROC ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Buynode_if_nil<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > &>, COMDAT
; _this$dead$ = ecx

; 1639 : 		_Nodeptr _Buynode_if_nil(_Nodeptr _Node, _Valty&&)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1640 : 		{	// node exists, just return it
; 1641 : 		return (_Node);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Node$[ebp]

; 1642 : 		}

  00006	5d		 pop	 ebp
  00007	c2 08 00	 ret	 8
??$_Buynode_if_nil@AAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@1@PAU21@AAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Buynode_if_nil<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
;	COMDAT ??$?0V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@_N@?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@$$QA_NPAPAX@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
___formal$dead$ = 16					; size = 4
??$?0V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@_N@?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@$$QA_NPAPAX@Z PROC ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,bool>, COMDAT
; _this$ = ecx

; 138  : 		{	// construct from moved values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Val1$[ebp]
  00006	8b 00		 mov	 eax, DWORD PTR [eax]
  00008	89 01		 mov	 DWORD PTR [ecx], eax
  0000a	8b 45 0c	 mov	 eax, DWORD PTR __Val2$[ebp]
  0000d	8a 00		 mov	 al, BYTE PTR [eax]
  0000f	88 41 04	 mov	 BYTE PTR [ecx+4], al

; 139  : 		}

  00012	8b c1		 mov	 eax, ecx
  00014	5d		 pop	 ebp
  00015	c2 0c 00	 ret	 12			; 0000000cH
??$?0V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@_N@?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@$$QA_NPAPAX@Z ENDP ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,bool>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
;	COMDAT ??$?0V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@_N@?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@_N@std@@QAE@$$QAU01@PAPAX@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
___formal$dead$ = 12					; size = 4
??$?0V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@_N@?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@_N@std@@QAE@$$QAU01@PAPAX@Z PROC ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,bool>, COMDAT
; _this$ = ecx

; 182  : 		{	// construct from moved compatible pair

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 55 08	 mov	 edx, DWORD PTR __Right$[ebp]
  00006	8b 02		 mov	 eax, DWORD PTR [edx]
  00008	89 01		 mov	 DWORD PTR [ecx], eax
  0000a	8a 42 04	 mov	 al, BYTE PTR [edx+4]
  0000d	88 41 04	 mov	 BYTE PTR [ecx+4], al

; 183  : 		}

  00010	8b c1		 mov	 eax, ecx
  00012	5d		 pop	 ebp
  00013	c2 08 00	 ret	 8
??$?0V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@_N@?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@_N@std@@QAE@$$QAU01@PAPAX@Z ENDP ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,bool>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
;	COMDAT ??$?0AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@_N@?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@$$QA_NPAPAX@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
___formal$dead$ = 16					; size = 4
??$?0AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@_N@?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@$$QA_NPAPAX@Z PROC ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > &,bool>, COMDAT
; _this$ = ecx

; 138  : 		{	// construct from moved values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Val1$[ebp]
  00006	8b 00		 mov	 eax, DWORD PTR [eax]
  00008	89 01		 mov	 DWORD PTR [ecx], eax
  0000a	8b 45 0c	 mov	 eax, DWORD PTR __Val2$[ebp]
  0000d	8a 00		 mov	 al, BYTE PTR [eax]
  0000f	88 41 04	 mov	 BYTE PTR [ecx+4], al

; 139  : 		}

  00012	8b c1		 mov	 eax, ecx
  00014	5d		 pop	 ebp
  00015	c2 0c 00	 ret	 12			; 0000000cH
??$?0AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@_N@?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@$$QA_NPAPAX@Z ENDP ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > &,bool>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@U?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@2@@?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@std@@@std@@QAEXPAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@$$QAU?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__V0$ = 12						; size = 4
??$construct@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@U?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@2@@?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@std@@@std@@QAEXPAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@$$QAU?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z PROC ; std::allocator<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void *> >::construct<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::pair<ChunkPosition,std::shared_ptr<ChunkBase> > >, COMDAT
; _this$dead$ = ecx

; 617  : _VARIADIC_EXPAND_0X(_ALLOC_MEMBER_CONSTRUCT, , , , )

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 55 08	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00006	85 d2		 test	 edx, edx
  00008	74 40		 je	 SHORT $LN36@construct
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility

; 182  : 		{	// construct from moved compatible pair

  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR __V0$[ebp]
  0000d	83 c2 0c	 add	 edx, 12			; 0000000cH
  00010	f3 0f 7e 01	 movq	 xmm0, QWORD PTR [ecx]
  00014	66 0f d6 42 f4	 movq	 QWORD PTR [edx-12], xmm0
  00019	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  0001c	89 42 fc	 mov	 DWORD PTR [edx-4], eax
  0001f	56		 push	 esi
  00020	8d 71 0c	 lea	 esi, DWORD PTR [ecx+12]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 287  : 		{	// construct _Ptr_base object that takes resource from _Right

  00023	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0
  00029	c7 42 04 00 00
	00 00		 mov	 DWORD PTR [edx+4], 0

; 288  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 289  : 		}
; 290  : 
; 291  : 	template<class _Ty2>
; 292  : 		_Ptr_base(_Ptr_base<_Ty2>&& _Right)
; 293  : 		: _Ptr(_Right._Ptr), _Rep(_Right._Rep)
; 294  : 		{	// construct _Ptr_base object that takes resource from _Right
; 295  : 		_Right._Ptr = 0;
; 296  : 		_Right._Rep = 0;
; 297  : 		}
; 298  : 
; 299  : 	_Myt& operator=(_Myt&& _Right)
; 300  : 		{	// construct _Ptr_base object that takes resource from _Right
; 301  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 302  : 		return (*this);
; 303  : 		}
; 304  : 
; 305  : 	void _Assign_rv(_Myt&& _Right)
; 306  : 		{	// assign by moving _Right
; 307  : 		if (this != &_Right)

  00030	3b d6		 cmp	 edx, esi
  00032	74 15		 je	 SHORT $LN44@construct
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility

; 48   : 	_Left = _Move(_Right);

  00034	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00037	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 49   : 	_Right = _Move(_Tmp);

  0003a	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 48   : 	_Left = _Move(_Right);

  00041	8b 06		 mov	 eax, DWORD PTR [esi]
  00043	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00045	89 02		 mov	 DWORD PTR [edx], eax

; 49   : 	_Right = _Move(_Tmp);

  00047	89 0e		 mov	 DWORD PTR [esi], ecx
$LN44@construct:
  00049	5e		 pop	 esi
$LN36@construct:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 617  : _VARIADIC_EXPAND_0X(_ALLOC_MEMBER_CONSTRUCT, , , , )

  0004a	5d		 pop	 ebp
  0004b	c2 08 00	 ret	 8
??$construct@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@U?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@2@@?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PAX@std@@@std@@QAEXPAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@$$QAU?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z ENDP ; std::allocator<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void *> >::construct<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::pair<ChunkPosition,std::shared_ptr<ChunkBase> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\type_traits
;	COMDAT ??$forward@_N@std@@YA$$QA_NAA_N@Z
_TEXT	SEGMENT
??$forward@_N@std@@YA$$QA_NAA_N@Z PROC			; std::forward<bool>, COMDAT
; __Arg$ = ecx

; 1776 : 	return (static_cast<_Ty&&>(_Arg));

  00000	8b c1		 mov	 eax, ecx

; 1777 : 	}

  00002	c3		 ret	 0
??$forward@_N@std@@YA$$QA_NAA_N@Z ENDP			; std::forward<bool>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
;	COMDAT ??$?0VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@QAE@$$QAU?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@PAPAX@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
___formal$dead$ = 12					; size = 4
??$?0VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@QAE@$$QAU?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@PAPAX@Z PROC ; std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> ><ChunkPosition,std::shared_ptr<ChunkBase> >, COMDAT
; _this$ = ecx

; 182  : 		{	// construct from moved compatible pair

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 55 08	 mov	 edx, DWORD PTR __Right$[ebp]
  00006	56		 push	 esi
  00007	f3 0f 7e 02	 movq	 xmm0, QWORD PTR [edx]
  0000b	8b f1		 mov	 esi, ecx
  0000d	57		 push	 edi
  0000e	66 0f d6 06	 movq	 QWORD PTR [esi], xmm0
  00012	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00015	8d 7a 0c	 lea	 edi, DWORD PTR [edx+12]
  00018	8d 56 0c	 lea	 edx, DWORD PTR [esi+12]
  0001b	89 46 08	 mov	 DWORD PTR [esi+8], eax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 287  : 		{	// construct _Ptr_base object that takes resource from _Right

  0001e	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0
  00024	c7 42 04 00 00
	00 00		 mov	 DWORD PTR [edx+4], 0

; 288  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 289  : 		}
; 290  : 
; 291  : 	template<class _Ty2>
; 292  : 		_Ptr_base(_Ptr_base<_Ty2>&& _Right)
; 293  : 		: _Ptr(_Right._Ptr), _Rep(_Right._Rep)
; 294  : 		{	// construct _Ptr_base object that takes resource from _Right
; 295  : 		_Right._Ptr = 0;
; 296  : 		_Right._Rep = 0;
; 297  : 		}
; 298  : 
; 299  : 	_Myt& operator=(_Myt&& _Right)
; 300  : 		{	// construct _Ptr_base object that takes resource from _Right
; 301  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 302  : 		return (*this);
; 303  : 		}
; 304  : 
; 305  : 	void _Assign_rv(_Myt&& _Right)
; 306  : 		{	// assign by moving _Right
; 307  : 		if (this != &_Right)

  0002b	3b d7		 cmp	 edx, edi
  0002d	74 15		 je	 SHORT $LN36@shared_ptr
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility

; 48   : 	_Left = _Move(_Right);

  0002f	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00032	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 49   : 	_Right = _Move(_Tmp);

  00035	c7 47 04 00 00
	00 00		 mov	 DWORD PTR [edi+4], 0

; 48   : 	_Left = _Move(_Right);

  0003c	8b 07		 mov	 eax, DWORD PTR [edi]
  0003e	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00040	89 02		 mov	 DWORD PTR [edx], eax

; 49   : 	_Right = _Move(_Tmp);

  00042	89 0f		 mov	 DWORD PTR [edi], ecx
$LN36@shared_ptr:
  00044	5f		 pop	 edi

; 183  : 		}

  00045	8b c6		 mov	 eax, esi
  00047	5e		 pop	 esi
  00048	5d		 pop	 ebp
  00049	c2 08 00	 ret	 8
??$?0VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@QAE@$$QAU?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@PAPAX@Z ENDP ; std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> ><ChunkPosition,std::shared_ptr<ChunkBase> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\type_traits
;	COMDAT ??$forward@VChunkPosition@@@std@@YA$$QAVChunkPosition@@AAV1@@Z
_TEXT	SEGMENT
??$forward@VChunkPosition@@@std@@YA$$QAVChunkPosition@@AAV1@@Z PROC ; std::forward<ChunkPosition>, COMDAT
; __Arg$ = ecx

; 1776 : 	return (static_cast<_Ty&&>(_Arg));

  00000	8b c1		 mov	 eax, ecx

; 1777 : 	}

  00002	c3		 ret	 0
??$forward@VChunkPosition@@@std@@YA$$QAVChunkPosition@@AAV1@@Z ENDP ; std::forward<ChunkPosition>
_TEXT	ENDS
END
