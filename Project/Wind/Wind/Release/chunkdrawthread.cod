; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.50727.1 

	TITLE	C:\Users\Glenn\Documents\GitHub\Wind\Project\Wind\Wind\chunkdrawthread.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0BC@KBDMBKEH@deque?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	?drawerThread@@3HA				; drawerThread
PUBLIC	?_STATE_DEFER_DELETE@_CancellationTokenRegistration@details@Concurrency@@0JB ; Concurrency::details::_CancellationTokenRegistration::_STATE_DEFER_DELETE
PUBLIC	?_S_structured@_TaskCollectionBase@details@Concurrency@@1HB ; Concurrency::details::_TaskCollectionBase::_S_structured
PUBLIC	?_S_localCancel@_TaskCollectionBase@details@Concurrency@@1HB ; Concurrency::details::_TaskCollectionBase::_S_localCancel
PUBLIC	?_S_reserved@_TaskCollectionBase@details@Concurrency@@1HB ; Concurrency::details::_TaskCollectionBase::_S_reserved
PUBLIC	?_STATE_SYNCHRONIZE@_CancellationTokenRegistration@details@Concurrency@@0JB ; Concurrency::details::_CancellationTokenRegistration::_STATE_SYNCHRONIZE
PUBLIC	?_S_cancelDeferredShootdownOwner@_TaskCollectionBase@details@Concurrency@@1IB ; Concurrency::details::_TaskCollectionBase::_S_cancelDeferredShootdownOwner
PUBLIC	?_STATE_CLEAR@_CancellationTokenRegistration@details@Concurrency@@0JB ; Concurrency::details::_CancellationTokenRegistration::_STATE_CLEAR
PUBLIC	?_S_cancelStarted@_TaskCollectionBase@details@Concurrency@@1IB ; Concurrency::details::_TaskCollectionBase::_S_cancelStarted
PUBLIC	?_S_cancelBitsMask@_TaskCollectionBase@details@Concurrency@@1IB ; Concurrency::details::_TaskCollectionBase::_S_cancelBitsMask
PUBLIC	?_S_nonNull@_TaskCollectionBase@details@Concurrency@@1IB ; Concurrency::details::_TaskCollectionBase::_S_nonNull
PUBLIC	?_S_cancelShotdownOwner@_TaskCollectionBase@details@Concurrency@@1IB ; Concurrency::details::_TaskCollectionBase::_S_cancelShotdownOwner
PUBLIC	?_S_cancelException@_TaskCollectionBase@details@Concurrency@@1IB ; Concurrency::details::_TaskCollectionBase::_S_cancelException
PUBLIC	?_S_cancelNone@_TaskCollectionBase@details@Concurrency@@1IB ; Concurrency::details::_TaskCollectionBase::_S_cancelNone
PUBLIC	?_S_notInlined@_TaskCollectionBase@details@Concurrency@@1HB ; Concurrency::details::_TaskCollectionBase::_S_notInlined
PUBLIC	?_STATE_CALLED@_CancellationTokenRegistration@details@Concurrency@@0JB ; Concurrency::details::_CancellationTokenRegistration::_STATE_CALLED
PUBLIC	_PPLParallelInvokeEventGuid
PUBLIC	_ChoreEventGuid
PUBLIC	_ScheduleGroupEventGuid
PUBLIC	_SchedulerEventGuid
PUBLIC	_VirtualProcessorEventGuid
PUBLIC	_ContextEventGuid
PUBLIC	_ConcRTEventGuid
PUBLIC	_PPLParallelForeachEventGuid
PUBLIC	_PPLParallelForEventGuid
PUBLIC	_AgentEventGuid
PUBLIC	_ConcRT_ProviderGuid
PUBLIC	_ResourceManagerEventGuid
PUBLIC	_LockEventGuid
PUBLIC	??_R4?$_Ref_count@VVertexStream@gfxu@@@std@@6B@	; std::_Ref_count<gfxu::VertexStream>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$_Ref_count@VVertexStream@gfxu@@@std@@@8 ; std::_Ref_count<gfxu::VertexStream> `RTTI Type Descriptor'
PUBLIC	??_R0?AV_Ref_count_base@std@@@8			; std::_Ref_count_base `RTTI Type Descriptor'
PUBLIC	??_R4_Ref_count_base@std@@6B@			; std::_Ref_count_base::`RTTI Complete Object Locator'
PUBLIC	??_7_Ref_count_base@std@@6B@			; std::_Ref_count_base::`vftable'
PUBLIC	??_R2_Ref_count_base@std@@8			; std::_Ref_count_base::`RTTI Base Class Array'
PUBLIC	??_R3?$_Ref_count@VVertexStream@gfxu@@@std@@8	; std::_Ref_count<gfxu::VertexStream>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$_Ref_count@VVertexStream@gfxu@@@std@@8	; std::_Ref_count<gfxu::VertexStream>::`RTTI Base Class Array'
PUBLIC	??_R3_Ref_count_base@std@@8			; std::_Ref_count_base::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R1A@?0A@EA@_Ref_count_base@std@@8		; std::_Ref_count_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_7?$_Ref_count@VVertexStream@gfxu@@@std@@6B@	; std::_Ref_count<gfxu::VertexStream>::`vftable'
PUBLIC	??_R1A@?0A@EA@?$_Ref_count@VVertexStream@gfxu@@@std@@8 ; std::_Ref_count<gfxu::VertexStream>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?digits@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits
PUBLIC	?num@?$ratio@$00$00@std@@2_JB			; std::ratio<1,1>::num
PUBLIC	?value@?$_GcdX@$00$00@std@@2_JB			; std::_GcdX<1,1>::value
PUBLIC	?digits10@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits10
PUBLIC	?_G2@?$_Ratio_multiply2@U?$ratio@$0GE@$00@std@@U?$ratio@$00$0DLJKMKAA@@2@@std@@2_JB ; std::_Ratio_multiply2<std::ratio<100,1>,std::ratio<1,1000000000> >::_G2
PUBLIC	?is_bounded@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_bounded
PUBLIC	?is_bounded@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_bounded
PUBLIC	?value@?$_Abs@$00@std@@2_JB			; std::_Abs<1>::value
PUBLIC	?min_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent
PUBLIC	?is_integer@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_integer
PUBLIC	?digits@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits
PUBLIC	?traps@_Num_base@std@@2_NB			; std::_Num_base::traps
PUBLIC	?value@?$integral_constant@_N$00@std@@2_NB	; std::integral_constant<bool,1>::value
PUBLIC	?num@?$ratio@$00$0JIJGIA@@std@@2_JB		; std::ratio<1,10000000>::num
PUBLIC	?value@?$integral_constant@H$0A@@std@@2HB	; std::integral_constant<int,0>::value
PUBLIC	?is_specialized@_Num_base@std@@2_NB		; std::_Num_base::is_specialized
PUBLIC	?max_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent10
PUBLIC	?digits@_Num_base@std@@2HB			; std::_Num_base::digits
PUBLIC	?is_modulo@_Num_base@std@@2_NB			; std::_Num_base::is_modulo
PUBLIC	?has_infinity@_Num_float_base@std@@2_NB		; std::_Num_float_base::has_infinity
PUBLIC	?value@?$_GcdX@$00$0JIJGIA@@std@@2_JB		; std::_GcdX<1,10000000>::value
PUBLIC	?max_exponent@_Num_base@std@@2HB		; std::_Num_base::max_exponent
PUBLIC	?is_signed@?$numeric_limits@_J@std@@2_NB	; std::numeric_limits<__int64>::is_signed
PUBLIC	?round_style@_Num_base@std@@2W4float_round_style@2@B ; std::_Num_base::round_style
PUBLIC	?is_signed@?$numeric_limits@K@std@@2_NB		; std::numeric_limits<unsigned long>::is_signed
PUBLIC	?digits10@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits10
PUBLIC	?is_exact@_Num_base@std@@2_NB			; std::_Num_base::is_exact
PUBLIC	?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?_G2@?$_Ratio_multiply2@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$0JIJGIA@$00@2@@std@@2_JB ; std::_Ratio_multiply2<std::ratio<1,10000000>,std::ratio<10000000,1> >::_G2
PUBLIC	?digits10@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits10
PUBLIC	?digits@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits
PUBLIC	?digits@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits
PUBLIC	?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B ; std::_Num_base::has_denorm
PUBLIC	?_G1@?$_Ratio_multiply2@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$0JIJGIA@$00@2@@std@@2_JB ; std::_Ratio_multiply2<std::ratio<1,10000000>,std::ratio<10000000,1> >::_G1
PUBLIC	?digits@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits
PUBLIC	?is_specialized@_Num_float_base@std@@2_NB	; std::_Num_float_base::is_specialized
PUBLIC	?max_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent
PUBLIC	?digits10@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits10
PUBLIC	?is_signed@?$numeric_limits@G@std@@2_NB		; std::numeric_limits<unsigned short>::is_signed
PUBLIC	?value@?$_Gcd@$0JIJGIA@$0JIJGIA@@std@@2_JB	; std::_Gcd<10000000,10000000>::value
PUBLIC	?digits10@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits10
PUBLIC	?has_quiet_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_quiet_NaN
PUBLIC	?is_signed@?$numeric_limits@I@std@@2_NB		; std::numeric_limits<unsigned int>::is_signed
PUBLIC	?is_signed@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_signed
PUBLIC	?digits10@_Num_base@std@@2HB			; std::_Num_base::digits10
PUBLIC	?is_signed@?$numeric_limits@D@std@@2_NB		; std::numeric_limits<char>::is_signed
PUBLIC	?has_denorm_loss@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_denorm_loss
PUBLIC	?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B ; std::_Num_float_base::has_denorm
PUBLIC	?is_signed@?$numeric_limits@J@std@@2_NB		; std::numeric_limits<long>::is_signed
PUBLIC	?digits@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits
PUBLIC	?value@?$_GcdX@$00$0A@@std@@2_JB		; std::_GcdX<1,0>::value
PUBLIC	?is_signed@_Num_base@std@@2_NB			; std::_Num_base::is_signed
PUBLIC	?max_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent10
PUBLIC	?is_steady@system_clock@chrono@std@@2_NB	; std::chrono::system_clock::is_steady
PUBLIC	?is_monotonic@steady_clock@chrono@std@@2_NB	; std::chrono::steady_clock::is_monotonic
PUBLIC	?is_monotonic@system_clock@chrono@std@@2_NB	; std::chrono::system_clock::is_monotonic
PUBLIC	?is_steady@steady_clock@chrono@std@@2_NB	; std::chrono::steady_clock::is_steady
PUBLIC	?value@?$_Is_ratio@U?$ratio@$00$0JIJGIA@@std@@@chrono@std@@2_NB ; std::chrono::_Is_ratio<std::ratio<1,10000000> >::value
PUBLIC	?digits10@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits10
PUBLIC	?is_signed@?$numeric_limits@_W@std@@2_NB	; std::numeric_limits<wchar_t>::is_signed
PUBLIC	?is_modulo@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_modulo
PUBLIC	?is_bounded@_Num_base@std@@2_NB			; std::_Num_base::is_bounded
PUBLIC	?value@?$_Gcd@$00$00@std@@2_JB			; std::_Gcd<1,1>::value
PUBLIC	?_G1@?$_Ratio_multiply2@U?$ratio@$0GE@$00@std@@U?$ratio@$00$0DLJKMKAA@@2@@std@@2_JB ; std::_Ratio_multiply2<std::ratio<100,1>,std::ratio<1,1000000000> >::_G1
PUBLIC	?value@?$integral_constant@I$0A@@std@@2IB	; std::integral_constant<unsigned int,0>::value
PUBLIC	?has_signaling_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_signaling_NaN
PUBLIC	?digits@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits
PUBLIC	?is_exact@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_exact
PUBLIC	?max_exponent10@_Num_base@std@@2HB		; std::_Num_base::max_exponent10
PUBLIC	?value@?$_Abs@$0DLJKMKAA@@std@@2_JB		; std::_Abs<1000000000>::value
PUBLIC	?min_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent10
PUBLIC	?value@?$_Abs@$0GE@@std@@2_JB			; std::_Abs<100>::value
PUBLIC	?digits10@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits10
PUBLIC	?value@?$integral_constant@_N$0A@@std@@2_NB	; std::integral_constant<bool,0>::value
PUBLIC	?digits10@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits10
PUBLIC	?digits10@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits10
PUBLIC	?radix@_Num_float_base@std@@2HB			; std::_Num_float_base::radix
PUBLIC	?value@?$_GcdX@$0GE@$0A@@std@@2_JB		; std::_GcdX<100,0>::value
PUBLIC	?value@?$_Abs@$0JIJGIA@@std@@2_JB		; std::_Abs<10000000>::value
PUBLIC	?value@?$_GcdX@$0GE@$0DLJKMKAA@@std@@2_JB	; std::_GcdX<100,1000000000>::value
PUBLIC	?has_denorm_loss@_Num_base@std@@2_NB		; std::_Num_base::has_denorm_loss
PUBLIC	?min_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent10
PUBLIC	?min_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent
PUBLIC	?is_iec559@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_iec559
PUBLIC	?min_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent
PUBLIC	?tinyness_before@_Num_base@std@@2_NB		; std::_Num_base::tinyness_before
PUBLIC	?max_digits10@_Num_base@std@@2HB		; std::_Num_base::max_digits10
PUBLIC	?digits10@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits10
PUBLIC	?is_specialized@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_specialized
PUBLIC	?has_infinity@_Num_base@std@@2_NB		; std::_Num_base::has_infinity
PUBLIC	?is_signed@?$numeric_limits@_K@std@@2_NB	; std::numeric_limits<unsigned __int64>::is_signed
PUBLIC	?max_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent
PUBLIC	?digits10@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits10
PUBLIC	?is_signed@?$numeric_limits@C@std@@2_NB		; std::numeric_limits<signed char>::is_signed
PUBLIC	?digits10@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits10
PUBLIC	?digits@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits
PUBLIC	?tinyness_before@_Num_float_base@std@@2_NB	; std::_Num_float_base::tinyness_before
PUBLIC	?is_modulo@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_modulo
PUBLIC	?is_signed@?$numeric_limits@F@std@@2_NB		; std::numeric_limits<short>::is_signed
PUBLIC	?den@?$ratio@$00$0JIJGIA@@std@@2_JB		; std::ratio<1,10000000>::den
PUBLIC	?value@?$_GcdX@$0DLJKMKAA@$0GE@@std@@2_JB	; std::_GcdX<1000000000,100>::value
PUBLIC	?digits@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits
PUBLIC	?digits@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits
PUBLIC	?radix@_Num_int_base@std@@2HB			; std::_Num_int_base::radix
PUBLIC	?value@?$_Gcd@$0GE@$0DLJKMKAA@@std@@2_JB	; std::_Gcd<100,1000000000>::value
PUBLIC	?max_digits10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent
PUBLIC	?is_integer@_Num_base@std@@2_NB			; std::_Num_base::is_integer
PUBLIC	?max_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent10
PUBLIC	?is_modulo@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_modulo
PUBLIC	?digits@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits
PUBLIC	?is_exact@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_exact
PUBLIC	?min_exponent@_Num_base@std@@2HB		; std::_Num_base::min_exponent
PUBLIC	?digits@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits
PUBLIC	?min_exponent10@_Num_base@std@@2HB		; std::_Num_base::min_exponent10
PUBLIC	?value@?$_GcdX@$0JIJGIA@$0JIJGIA@@std@@2_JB	; std::_GcdX<10000000,10000000>::value
PUBLIC	?digits@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits
PUBLIC	?digits@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits
PUBLIC	?value@?$_GcdX@$0JIJGIA@$00@std@@2_JB		; std::_GcdX<10000000,1>::value
PUBLIC	?den@?$ratio@$00$00@std@@2_JB			; std::ratio<1,1>::den
PUBLIC	?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?has_signaling_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_signaling_NaN
PUBLIC	?round_style@_Num_float_base@std@@2W4float_round_style@2@B ; std::_Num_float_base::round_style
PUBLIC	?max_digits10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_digits10
PUBLIC	?traps@_Num_float_base@std@@2_NB		; std::_Num_float_base::traps
PUBLIC	?radix@_Num_base@std@@2HB			; std::_Num_base::radix
PUBLIC	?digits10@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits10
PUBLIC	?is_signed@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_signed
PUBLIC	?is_integer@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_integer
PUBLIC	?digits@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits
PUBLIC	?digits10@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits10
PUBLIC	?digits10@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits10
PUBLIC	?is_signed@?$numeric_limits@E@std@@2_NB		; std::numeric_limits<unsigned char>::is_signed
PUBLIC	?min_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent10
PUBLIC	?is_signed@?$numeric_limits@H@std@@2_NB		; std::numeric_limits<int>::is_signed
PUBLIC	?has_quiet_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_quiet_NaN
PUBLIC	?digits@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits
PUBLIC	?value@?$_GcdX@$0JIJGIA@$0A@@std@@2_JB		; std::_GcdX<10000000,0>::value
PUBLIC	?value@?$_Gcd@$00$0JIJGIA@@std@@2_JB		; std::_Gcd<1,10000000>::value
PUBLIC	?digits10@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits10
PUBLIC	?is_iec559@_Num_base@std@@2_NB			; std::_Num_base::is_iec559
PUBLIC	?max_digits10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_digits10
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	__Mtx_lock:PROC
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	__purecall:PROC
EXTRN	__Mtx_unlock:PROC
EXTRN	_memmove:PROC
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
EXTRN	??0_Lockit@std@@QAE@H@Z:PROC			; std::_Lockit::_Lockit
EXTRN	??1_Lockit@std@@QAE@XZ:PROC			; std::_Lockit::~_Lockit
EXTRN	?_Xbad_alloc@std@@YAXXZ:PROC			; std::_Xbad_alloc
EXTRN	?_Throw_C_error@std@@YAXH@Z:PROC		; std::_Throw_C_error
EXTRN	@__security_check_cookie@4:PROC
?drawerThread@@3HA DD 01H DUP (?)			; drawerThread
_BSS	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@M@std@@2HB DD 09H	; std::numeric_limits<float>::max_digits10
CONST	ENDS
;	COMDAT ?is_iec559@_Num_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_iec559
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@E@std@@2HB DD 02H		; std::numeric_limits<unsigned char>::digits10
CONST	ENDS
;	COMDAT ?value@?$_Gcd@$00$0JIJGIA@@std@@2_JB
CONST	SEGMENT
?value@?$_Gcd@$00$0JIJGIA@@std@@2_JB DQ 0000000000000001H ; std::_Gcd<1,10000000>::value
CONST	ENDS
;	COMDAT ?value@?$_GcdX@$0JIJGIA@$0A@@std@@2_JB
CONST	SEGMENT
?value@?$_GcdX@$0JIJGIA@$0A@@std@@2_JB DQ 0000000000989680H ; std::_GcdX<10000000,0>::value
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@F@std@@2HB DD 0fH		; std::numeric_limits<short>::digits
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@H@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@H@std@@2_NB DB 01H		; std::numeric_limits<int>::is_signed
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@O@std@@2HB DD 0fffffecdH ; std::numeric_limits<long double>::min_exponent10
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@E@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@E@std@@2_NB DB 00H		; std::numeric_limits<unsigned char>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@G@std@@2HB DD 04H		; std::numeric_limits<unsigned short>::digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_N@std@@2HB DD 00H		; std::numeric_limits<bool>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_N@std@@2HB DD 01H		; std::numeric_limits<bool>::digits
CONST	ENDS
;	COMDAT ?is_integer@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_integer
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@F@std@@2HB DD 04H		; std::numeric_limits<short>::digits10
CONST	ENDS
;	COMDAT ?radix@_Num_base@std@@2HB
CONST	SEGMENT
?radix@_Num_base@std@@2HB DD 00H			; std::_Num_base::radix
CONST	ENDS
;	COMDAT ?traps@_Num_float_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_float_base@std@@2_NB DB 00H			; std::_Num_float_base::traps
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@N@std@@2HB DD 011H	; std::numeric_limits<double>::max_digits10
CONST	ENDS
;	COMDAT ?round_style@_Num_float_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_float_base@std@@2W4float_round_style@2@B DD 01H ; std::_Num_float_base::round_style
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB
CONST	SEGMENT
?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB DD 01H ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
;	COMDAT ?den@?$ratio@$00$00@std@@2_JB
CONST	SEGMENT
?den@?$ratio@$00$00@std@@2_JB DQ 0000000000000001H	; std::ratio<1,1>::den
CONST	ENDS
;	COMDAT ?value@?$_GcdX@$0JIJGIA@$00@std@@2_JB
CONST	SEGMENT
?value@?$_GcdX@$0JIJGIA@$00@std@@2_JB DQ 0000000000000001H ; std::_GcdX<10000000,1>::value
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@N@std@@2HB DD 035H		; std::numeric_limits<double>::digits
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@I@std@@2HB DD 020H		; std::numeric_limits<unsigned int>::digits
CONST	ENDS
;	COMDAT ?value@?$_GcdX@$0JIJGIA@$0JIJGIA@@std@@2_JB
CONST	SEGMENT
?value@?$_GcdX@$0JIJGIA@$0JIJGIA@@std@@2_JB DQ 0000000000989680H ; std::_GcdX<10000000,10000000>::value
CONST	ENDS
;	COMDAT ?min_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::min_exponent10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@E@std@@2HB DD 08H		; std::numeric_limits<unsigned char>::digits
CONST	ENDS
;	COMDAT ?min_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::min_exponent
CONST	ENDS
;	COMDAT ?is_exact@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_exact
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@C@std@@2HB DD 07H		; std::numeric_limits<signed char>::digits
CONST	ENDS
;	COMDAT ?is_modulo@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_modulo@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_modulo
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@N@std@@2HB DD 0134H	; std::numeric_limits<double>::max_exponent10
CONST	ENDS
;	COMDAT ?is_integer@_Num_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_integer
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@N@std@@2HB DD 0400H	; std::numeric_limits<double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@O@std@@2HB DD 011H	; std::numeric_limits<long double>::max_digits10
CONST	ENDS
;	COMDAT ?value@?$_Gcd@$0GE@$0DLJKMKAA@@std@@2_JB
CONST	SEGMENT
?value@?$_Gcd@$0GE@$0DLJKMKAA@@std@@2_JB DQ 0000000000000064H ; std::_Gcd<100,1000000000>::value
CONST	ENDS
;	COMDAT ?radix@_Num_int_base@std@@2HB
CONST	SEGMENT
?radix@_Num_int_base@std@@2HB DD 02H			; std::_Num_int_base::radix
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_W@std@@2HB DD 010H		; std::numeric_limits<wchar_t>::digits
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@O@std@@2HB DD 035H		; std::numeric_limits<long double>::digits
CONST	ENDS
;	COMDAT ?value@?$_GcdX@$0DLJKMKAA@$0GE@@std@@2_JB
CONST	SEGMENT
?value@?$_GcdX@$0DLJKMKAA@$0GE@@std@@2_JB DQ 0000000000000064H ; std::_GcdX<1000000000,100>::value
CONST	ENDS
;	COMDAT ?den@?$ratio@$00$0JIJGIA@@std@@2_JB
CONST	SEGMENT
?den@?$ratio@$00$0JIJGIA@@std@@2_JB DQ 0000000000989680H ; std::ratio<1,10000000>::den
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@F@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@F@std@@2_NB DB 01H		; std::numeric_limits<short>::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_modulo
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_float_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::tinyness_before
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_K@std@@2HB DD 040H		; std::numeric_limits<unsigned __int64>::digits
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@M@std@@2HB DD 06H		; std::numeric_limits<float>::digits10
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@C@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@C@std@@2_NB DB 01H		; std::numeric_limits<signed char>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_K@std@@2HB DD 013H		; std::numeric_limits<unsigned __int64>::digits10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@M@std@@2HB DD 080H	; std::numeric_limits<float>::max_exponent
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_K@std@@2_NB DB 00H		; std::numeric_limits<unsigned __int64>::is_signed
CONST	ENDS
;	COMDAT ?has_infinity@_Num_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_infinity
CONST	ENDS
;	COMDAT ?is_specialized@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_specialized
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@D@std@@2HB DD 02H		; std::numeric_limits<char>::digits10
CONST	ENDS
;	COMDAT ?max_digits10@_Num_base@std@@2HB
CONST	SEGMENT
?max_digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_digits10
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_base@std@@2_NB DB 00H		; std::_Num_base::tinyness_before
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@M@std@@2HB DD 0ffffff83H	; std::numeric_limits<float>::min_exponent
CONST	ENDS
;	COMDAT ?is_iec559@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_iec559
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@N@std@@2HB DD 0fffffc03H	; std::numeric_limits<double>::min_exponent
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@M@std@@2HB DD 0ffffffdbH ; std::numeric_limits<float>::min_exponent10
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?value@?$_GcdX@$0GE@$0DLJKMKAA@@std@@2_JB
CONST	SEGMENT
?value@?$_GcdX@$0GE@$0DLJKMKAA@@std@@2_JB DQ 0000000000000064H ; std::_GcdX<100,1000000000>::value
CONST	ENDS
;	COMDAT ?value@?$_Abs@$0JIJGIA@@std@@2_JB
CONST	SEGMENT
?value@?$_Abs@$0JIJGIA@@std@@2_JB DQ 0000000000989680H	; std::_Abs<10000000>::value
CONST	ENDS
;	COMDAT ?value@?$_GcdX@$0GE@$0A@@std@@2_JB
CONST	SEGMENT
?value@?$_GcdX@$0GE@$0A@@std@@2_JB DQ 0000000000000064H	; std::_GcdX<100,0>::value
CONST	ENDS
;	COMDAT ?radix@_Num_float_base@std@@2HB
CONST	SEGMENT
?radix@_Num_float_base@std@@2HB DD 02H			; std::_Num_float_base::radix
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_W@std@@2HB DD 04H		; std::numeric_limits<wchar_t>::digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@I@std@@2HB DD 09H		; std::numeric_limits<unsigned int>::digits10
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$0A@@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$0A@@std@@2_NB DB 00H	; std::integral_constant<bool,0>::value
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@C@std@@2HB DD 02H		; std::numeric_limits<signed char>::digits10
CONST	ENDS
;	COMDAT ?value@?$_Abs@$0GE@@std@@2_JB
CONST	SEGMENT
?value@?$_Abs@$0GE@@std@@2_JB DQ 0000000000000064H	; std::_Abs<100>::value
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@N@std@@2HB DD 0fffffecdH ; std::numeric_limits<double>::min_exponent10
CONST	ENDS
;	COMDAT ?value@?$_Abs@$0DLJKMKAA@@std@@2_JB
CONST	SEGMENT
?value@?$_Abs@$0DLJKMKAA@@std@@2_JB DQ 000000003b9aca00H ; std::_Abs<1000000000>::value
CONST	ENDS
;	COMDAT ?max_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::max_exponent10
CONST	ENDS
;	COMDAT ?is_exact@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_exact
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@J@std@@2HB DD 01fH		; std::numeric_limits<long>::digits
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?value@?$integral_constant@I$0A@@std@@2IB
CONST	SEGMENT
?value@?$integral_constant@I$0A@@std@@2IB DD 00H	; std::integral_constant<unsigned int,0>::value
CONST	ENDS
;	COMDAT ?_G1@?$_Ratio_multiply2@U?$ratio@$0GE@$00@std@@U?$ratio@$00$0DLJKMKAA@@2@@std@@2_JB
CONST	SEGMENT
?_G1@?$_Ratio_multiply2@U?$ratio@$0GE@$00@std@@U?$ratio@$00$0DLJKMKAA@@2@@std@@2_JB DQ 0000000000000064H ; std::_Ratio_multiply2<std::ratio<100,1>,std::ratio<1,1000000000> >::_G1
CONST	ENDS
;	COMDAT ?value@?$_Gcd@$00$00@std@@2_JB
CONST	SEGMENT
?value@?$_Gcd@$00$00@std@@2_JB DQ 0000000000000001H	; std::_Gcd<1,1>::value
CONST	ENDS
;	COMDAT ?is_bounded@_Num_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_bounded
CONST	ENDS
;	COMDAT ?is_modulo@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_modulo
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_W@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_W@std@@2_NB DB 00H		; std::numeric_limits<wchar_t>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@H@std@@2HB DD 09H		; std::numeric_limits<int>::digits10
CONST	ENDS
;	COMDAT ?value@?$_Is_ratio@U?$ratio@$00$0JIJGIA@@std@@@chrono@std@@2_NB
CONST	SEGMENT
?value@?$_Is_ratio@U?$ratio@$00$0JIJGIA@@std@@@chrono@std@@2_NB DB 01H ; std::chrono::_Is_ratio<std::ratio<1,10000000> >::value
CONST	ENDS
;	COMDAT ?is_steady@steady_clock@chrono@std@@2_NB
CONST	SEGMENT
?is_steady@steady_clock@chrono@std@@2_NB DB 01H		; std::chrono::steady_clock::is_steady
CONST	ENDS
;	COMDAT ?is_monotonic@system_clock@chrono@std@@2_NB
CONST	SEGMENT
?is_monotonic@system_clock@chrono@std@@2_NB DB 00H	; std::chrono::system_clock::is_monotonic
CONST	ENDS
;	COMDAT ?is_monotonic@steady_clock@chrono@std@@2_NB
CONST	SEGMENT
?is_monotonic@steady_clock@chrono@std@@2_NB DB 01H	; std::chrono::steady_clock::is_monotonic
CONST	ENDS
;	COMDAT ?is_steady@system_clock@chrono@std@@2_NB
CONST	SEGMENT
?is_steady@system_clock@chrono@std@@2_NB DB 00H		; std::chrono::system_clock::is_steady
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@O@std@@2HB DD 0134H	; std::numeric_limits<long double>::max_exponent10
CONST	ENDS
;	COMDAT ?is_signed@_Num_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_signed
CONST	ENDS
;	COMDAT ?value@?$_GcdX@$00$0A@@std@@2_JB
CONST	SEGMENT
?value@?$_GcdX@$00$0A@@std@@2_JB DQ 0000000000000001H	; std::_GcdX<1,0>::value
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@G@std@@2HB DD 010H		; std::numeric_limits<unsigned short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@J@std@@2_NB DB 01H		; std::numeric_limits<long>::is_signed
CONST	ENDS
;	COMDAT ?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B DD 01H ; std::_Num_float_base::has_denorm
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@D@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@D@std@@2_NB DB 01H		; std::numeric_limits<char>::is_signed
CONST	ENDS
;	COMDAT ?digits10@_Num_base@std@@2HB
CONST	SEGMENT
?digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits10
CONST	ENDS
;	COMDAT ?is_signed@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_signed
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@I@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@I@std@@2_NB DB 00H		; std::numeric_limits<unsigned int>::is_signed
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@J@std@@2HB DD 09H		; std::numeric_limits<long>::digits10
CONST	ENDS
;	COMDAT ?value@?$_Gcd@$0JIJGIA@$0JIJGIA@@std@@2_JB
CONST	SEGMENT
?value@?$_Gcd@$0JIJGIA@$0JIJGIA@@std@@2_JB DQ 0000000000989680H ; std::_Gcd<10000000,10000000>::value
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@G@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@G@std@@2_NB DB 00H		; std::numeric_limits<unsigned short>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_J@std@@2HB DD 012H		; std::numeric_limits<__int64>::digits10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@O@std@@2HB DD 0400H	; std::numeric_limits<long double>::max_exponent
CONST	ENDS
;	COMDAT ?is_specialized@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::is_specialized
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@K@std@@2HB DD 020H		; std::numeric_limits<unsigned long>::digits
CONST	ENDS
;	COMDAT ?_G1@?$_Ratio_multiply2@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$0JIJGIA@$00@2@@std@@2_JB
CONST	SEGMENT
?_G1@?$_Ratio_multiply2@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$0JIJGIA@$00@2@@std@@2_JB DQ 0000000000000001H ; std::_Ratio_multiply2<std::ratio<1,10000000>,std::ratio<10000000,1> >::_G1
CONST	ENDS
;	COMDAT ?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B DD 00H ; std::_Num_base::has_denorm
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@M@std@@2HB DD 018H		; std::numeric_limits<float>::digits
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@D@std@@2HB DD 07H		; std::numeric_limits<char>::digits
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@O@std@@2HB DD 0fH		; std::numeric_limits<long double>::digits10
CONST	ENDS
;	COMDAT ?_G2@?$_Ratio_multiply2@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$0JIJGIA@$00@2@@std@@2_JB
CONST	SEGMENT
?_G2@?$_Ratio_multiply2@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$0JIJGIA@$00@2@@std@@2_JB DQ 0000000000989680H ; std::_Ratio_multiply2<std::ratio<1,10000000>,std::ratio<10000000,1> >::_G2
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB
CONST	SEGMENT
?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB DD 00H ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
;	COMDAT ?is_exact@_Num_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_exact
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@N@std@@2HB DD 0fH		; std::numeric_limits<double>::digits10
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@K@std@@2_NB DB 00H		; std::numeric_limits<unsigned long>::is_signed
CONST	ENDS
;	COMDAT ?round_style@_Num_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_base@std@@2W4float_round_style@2@B DD 00H ; std::_Num_base::round_style
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_J@std@@2_NB DB 01H		; std::numeric_limits<__int64>::is_signed
CONST	ENDS
;	COMDAT ?max_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_exponent
CONST	ENDS
;	COMDAT ?value@?$_GcdX@$00$0JIJGIA@@std@@2_JB
CONST	SEGMENT
?value@?$_GcdX@$00$0JIJGIA@@std@@2_JB DQ 0000000000000001H ; std::_GcdX<1,10000000>::value
CONST	ENDS
;	COMDAT ?has_infinity@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_infinity
CONST	ENDS
;	COMDAT ?is_modulo@_Num_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_modulo
CONST	ENDS
;	COMDAT ?digits@_Num_base@std@@2HB
CONST	SEGMENT
?digits@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@M@std@@2HB DD 026H	; std::numeric_limits<float>::max_exponent10
CONST	ENDS
;	COMDAT ?is_specialized@_Num_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_base@std@@2_NB DB 00H		; std::_Num_base::is_specialized
CONST	ENDS
;	COMDAT ?value@?$integral_constant@H$0A@@std@@2HB
CONST	SEGMENT
?value@?$integral_constant@H$0A@@std@@2HB DD 00H	; std::integral_constant<int,0>::value
CONST	ENDS
;	COMDAT ?num@?$ratio@$00$0JIJGIA@@std@@2_JB
CONST	SEGMENT
?num@?$ratio@$00$0JIJGIA@@std@@2_JB DQ 0000000000000001H ; std::ratio<1,10000000>::num
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$00@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$00@std@@2_NB DB 01H	; std::integral_constant<bool,1>::value
CONST	ENDS
;	COMDAT ?traps@_Num_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_base@std@@2_NB DB 00H			; std::_Num_base::traps
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@H@std@@2HB DD 01fH		; std::numeric_limits<int>::digits
CONST	ENDS
;	COMDAT ?is_integer@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_integer
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@O@std@@2HB DD 0fffffc03H	; std::numeric_limits<long double>::min_exponent
CONST	ENDS
;	COMDAT ?value@?$_Abs@$00@std@@2_JB
CONST	SEGMENT
?value@?$_Abs@$00@std@@2_JB DQ 0000000000000001H	; std::_Abs<1>::value
CONST	ENDS
;	COMDAT ?is_bounded@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_bounded
CONST	ENDS
;	COMDAT ?is_bounded@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_bounded
CONST	ENDS
;	COMDAT ?_G2@?$_Ratio_multiply2@U?$ratio@$0GE@$00@std@@U?$ratio@$00$0DLJKMKAA@@2@@std@@2_JB
CONST	SEGMENT
?_G2@?$_Ratio_multiply2@U?$ratio@$0GE@$00@std@@U?$ratio@$00$0DLJKMKAA@@2@@std@@2_JB DQ 0000000000000001H ; std::_Ratio_multiply2<std::ratio<100,1>,std::ratio<1,1000000000> >::_G2
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@K@std@@2HB DD 09H		; std::numeric_limits<unsigned long>::digits10
CONST	ENDS
;	COMDAT ?value@?$_GcdX@$00$00@std@@2_JB
CONST	SEGMENT
?value@?$_GcdX@$00$00@std@@2_JB DQ 0000000000000001H	; std::_GcdX<1,1>::value
CONST	ENDS
;	COMDAT ?num@?$ratio@$00$00@std@@2_JB
CONST	SEGMENT
?num@?$ratio@$00$00@std@@2_JB DQ 0000000000000001H	; std::ratio<1,1>::num
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_J@std@@2HB DD 03fH		; std::numeric_limits<__int64>::digits
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@?$_Ref_count@VVertexStream@gfxu@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$_Ref_count@VVertexStream@gfxu@@@std@@8 DD FLAT:??_R0?AV?$_Ref_count@VVertexStream@gfxu@@@std@@@8 ; std::_Ref_count<gfxu::VertexStream>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$_Ref_count@VVertexStream@gfxu@@@std@@8
rdata$r	ENDS
;	COMDAT ??_7?$_Ref_count@VVertexStream@gfxu@@@std@@6B@
CONST	SEGMENT
??_7?$_Ref_count@VVertexStream@gfxu@@@std@@6B@ DD FLAT:??_R4?$_Ref_count@VVertexStream@gfxu@@@std@@6B@ ; std::_Ref_count<gfxu::VertexStream>::`vftable'
	DD	FLAT:?_Destroy@?$_Ref_count@VVertexStream@gfxu@@@std@@EAEXXZ
	DD	FLAT:?_Delete_this@?$_Ref_count@VVertexStream@gfxu@@@std@@EAEXXZ
	DD	FLAT:??_E?$_Ref_count@VVertexStream@gfxu@@@std@@UAEPAXI@Z
	DD	FLAT:?_Get_deleter@_Ref_count_base@std@@UBEPAXABVtype_info@@@Z
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@_Ref_count_base@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_Ref_count_base@std@@8 DD FLAT:??_R0?AV_Ref_count_base@std@@@8 ; std::_Ref_count_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_Ref_count_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_Ref_count_base@std@@8
rdata$r	SEGMENT
??_R3_Ref_count_base@std@@8 DD 00H			; std::_Ref_count_base::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2_Ref_count_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$_Ref_count@VVertexStream@gfxu@@@std@@8
rdata$r	SEGMENT
??_R2?$_Ref_count@VVertexStream@gfxu@@@std@@8 DD FLAT:??_R1A@?0A@EA@?$_Ref_count@VVertexStream@gfxu@@@std@@8 ; std::_Ref_count<gfxu::VertexStream>::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@_Ref_count_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$_Ref_count@VVertexStream@gfxu@@@std@@8
rdata$r	SEGMENT
??_R3?$_Ref_count@VVertexStream@gfxu@@@std@@8 DD 00H	; std::_Ref_count<gfxu::VertexStream>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2?$_Ref_count@VVertexStream@gfxu@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_Ref_count_base@std@@8
rdata$r	SEGMENT
??_R2_Ref_count_base@std@@8 DD FLAT:??_R1A@?0A@EA@_Ref_count_base@std@@8 ; std::_Ref_count_base::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_7_Ref_count_base@std@@6B@
CONST	SEGMENT
??_7_Ref_count_base@std@@6B@ DD FLAT:??_R4_Ref_count_base@std@@6B@ ; std::_Ref_count_base::`vftable'
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:??_E_Ref_count_base@std@@UAEPAXI@Z
	DD	FLAT:?_Get_deleter@_Ref_count_base@std@@UBEPAXABVtype_info@@@Z
CONST	ENDS
;	COMDAT ??_R4_Ref_count_base@std@@6B@
rdata$r	SEGMENT
??_R4_Ref_count_base@std@@6B@ DD 00H			; std::_Ref_count_base::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_Ref_count_base@std@@@8
	DD	FLAT:??_R3_Ref_count_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_Ref_count_base@std@@@8
_DATA	SEGMENT
??_R0?AV_Ref_count_base@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_Ref_count_base `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_Ref_count_base@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R0?AV?$_Ref_count@VVertexStream@gfxu@@@std@@@8
_DATA	SEGMENT
??_R0?AV?$_Ref_count@VVertexStream@gfxu@@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_Ref_count<gfxu::VertexStream> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$_Ref_count@VVertexStream@gfxu@@@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4?$_Ref_count@VVertexStream@gfxu@@@std@@6B@
rdata$r	SEGMENT
??_R4?$_Ref_count@VVertexStream@gfxu@@@std@@6B@ DD 00H	; std::_Ref_count<gfxu::VertexStream>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$_Ref_count@VVertexStream@gfxu@@@std@@@8
	DD	FLAT:??_R3?$_Ref_count@VVertexStream@gfxu@@@std@@8
rdata$r	ENDS
;	COMDAT _LockEventGuid
CONST	SEGMENT
_LockEventGuid DD 079a60dc6H
	DW	05fc8H
	DW	04952H
	DB	0a4H
	DB	01cH
	DB	011H
	DB	063H
	DB	0aeH
	DB	0ecH
	DB	05eH
	DB	0b8H
CONST	ENDS
;	COMDAT _ResourceManagerEventGuid
CONST	SEGMENT
_ResourceManagerEventGuid DD 02718d25bH
	DW	05bf5H
	DW	04479H
	DB	08eH
	DB	088H
	DB	0baH
	DB	0bcH
	DB	064H
	DB	0bdH
	DB	0bfH
	DB	0caH
CONST	ENDS
;	COMDAT _ConcRT_ProviderGuid
CONST	SEGMENT
_ConcRT_ProviderGuid DD 0f7b697a3H
	DW	04db5H
	DW	04d3bH
	DB	0beH
	DB	071H
	DB	0c4H
	DB	0d2H
	DB	084H
	DB	0e6H
	DB	059H
	DB	02fH
CONST	ENDS
;	COMDAT _AgentEventGuid
CONST	SEGMENT
_AgentEventGuid DD 0b9b5b78cH
	DW	0713H
	DW	04898H
	DB	0a2H
	DB	01aH
	DB	0c6H
	DB	079H
	DB	049H
	DB	0dcH
	DB	0edH
	DB	07H
CONST	ENDS
;	COMDAT _PPLParallelForEventGuid
CONST	SEGMENT
_PPLParallelForEventGuid DD 031c8da6bH
	DW	06165H
	DW	04042H
	DB	08bH
	DB	092H
	DB	094H
	DB	09eH
	DB	031H
	DB	05fH
	DB	04dH
	DB	084H
CONST	ENDS
;	COMDAT _PPLParallelForeachEventGuid
CONST	SEGMENT
_PPLParallelForeachEventGuid DD 05cb7d785H
	DW	09d66H
	DW	0465dH
	DB	0baH
	DB	0e1H
	DB	046H
	DB	011H
	DB	06H
	DB	01bH
	DB	054H
	DB	034H
CONST	ENDS
;	COMDAT _ConcRTEventGuid
CONST	SEGMENT
_ConcRTEventGuid DD 072b14a7dH
	DW	0704cH
	DW	0423eH
	DB	092H
	DB	0f8H
	DB	07eH
	DB	06dH
	DB	064H
	DB	0bcH
	DB	0b9H
	DB	02aH
CONST	ENDS
;	COMDAT _ContextEventGuid
CONST	SEGMENT
_ContextEventGuid DD 05727a00fH
	DW	050beH
	DW	04519H
	DB	082H
	DB	056H
	DB	0f7H
	DB	069H
	DB	098H
	DB	071H
	DB	0feH
	DB	0cbH
CONST	ENDS
;	COMDAT _VirtualProcessorEventGuid
CONST	SEGMENT
_VirtualProcessorEventGuid DD 02f27805fH
	DW	01676H
	DW	04eccH
	DB	096H
	DB	0faH
	DB	07eH
	DB	0b0H
	DB	09dH
	DB	044H
	DB	030H
	DB	02fH
CONST	ENDS
;	COMDAT _SchedulerEventGuid
CONST	SEGMENT
_SchedulerEventGuid DD 0e2091f8aH
	DW	01e0aH
	DW	04731H
	DB	084H
	DB	0a2H
	DB	0dH
	DB	0d5H
	DB	07cH
	DB	08aH
	DB	052H
	DB	061H
CONST	ENDS
;	COMDAT _ScheduleGroupEventGuid
CONST	SEGMENT
_ScheduleGroupEventGuid DD 0e8a3bf1fH
	DW	0a86bH
	DW	04390H
	DB	09cH
	DB	060H
	DB	053H
	DB	090H
	DB	0b9H
	DB	069H
	DB	0d2H
	DB	02cH
CONST	ENDS
;	COMDAT _ChoreEventGuid
CONST	SEGMENT
_ChoreEventGuid DD 07e854ec7H
	DW	0cdc4H
	DW	0405aH
	DB	0b5H
	DB	0b2H
	DB	0aaH
	DB	0f7H
	DB	0c9H
	DB	0e7H
	DB	0d4H
	DB	0cH
CONST	ENDS
;	COMDAT _PPLParallelInvokeEventGuid
CONST	SEGMENT
_PPLParallelInvokeEventGuid DD 0d1b5b133H
	DW	0ec3dH
	DW	049f4H
	DB	098H
	DB	0a3H
	DB	046H
	DB	04dH
	DB	01aH
	DB	09eH
	DB	046H
	DB	082H
CONST	ENDS
;	COMDAT ?_STATE_CALLED@_CancellationTokenRegistration@details@Concurrency@@0JB
CONST	SEGMENT
?_STATE_CALLED@_CancellationTokenRegistration@details@Concurrency@@0JB DD 03H ; Concurrency::details::_CancellationTokenRegistration::_STATE_CALLED
CONST	ENDS
;	COMDAT ?_S_notInlined@_TaskCollectionBase@details@Concurrency@@1HB
CONST	SEGMENT
?_S_notInlined@_TaskCollectionBase@details@Concurrency@@1HB DD 0ffffffffH ; Concurrency::details::_TaskCollectionBase::_S_notInlined
CONST	ENDS
;	COMDAT ?_S_cancelNone@_TaskCollectionBase@details@Concurrency@@1IB
CONST	SEGMENT
?_S_cancelNone@_TaskCollectionBase@details@Concurrency@@1IB DD 00H ; Concurrency::details::_TaskCollectionBase::_S_cancelNone
CONST	ENDS
;	COMDAT ?_S_cancelException@_TaskCollectionBase@details@Concurrency@@1IB
CONST	SEGMENT
?_S_cancelException@_TaskCollectionBase@details@Concurrency@@1IB DD 0cH ; Concurrency::details::_TaskCollectionBase::_S_cancelException
CONST	ENDS
;	COMDAT ?_S_cancelShotdownOwner@_TaskCollectionBase@details@Concurrency@@1IB
CONST	SEGMENT
?_S_cancelShotdownOwner@_TaskCollectionBase@details@Concurrency@@1IB DD 03H ; Concurrency::details::_TaskCollectionBase::_S_cancelShotdownOwner
CONST	ENDS
;	COMDAT ?_S_nonNull@_TaskCollectionBase@details@Concurrency@@1IB
CONST	SEGMENT
?_S_nonNull@_TaskCollectionBase@details@Concurrency@@1IB DD 08H ; Concurrency::details::_TaskCollectionBase::_S_nonNull
CONST	ENDS
;	COMDAT ?_S_cancelBitsMask@_TaskCollectionBase@details@Concurrency@@1IB
CONST	SEGMENT
?_S_cancelBitsMask@_TaskCollectionBase@details@Concurrency@@1IB DD 03H ; Concurrency::details::_TaskCollectionBase::_S_cancelBitsMask
CONST	ENDS
;	COMDAT ?_S_cancelStarted@_TaskCollectionBase@details@Concurrency@@1IB
CONST	SEGMENT
?_S_cancelStarted@_TaskCollectionBase@details@Concurrency@@1IB DD 01H ; Concurrency::details::_TaskCollectionBase::_S_cancelStarted
CONST	ENDS
;	COMDAT ?_STATE_CLEAR@_CancellationTokenRegistration@details@Concurrency@@0JB
CONST	SEGMENT
?_STATE_CLEAR@_CancellationTokenRegistration@details@Concurrency@@0JB DD 00H ; Concurrency::details::_CancellationTokenRegistration::_STATE_CLEAR
CONST	ENDS
;	COMDAT ?_S_cancelDeferredShootdownOwner@_TaskCollectionBase@details@Concurrency@@1IB
CONST	SEGMENT
?_S_cancelDeferredShootdownOwner@_TaskCollectionBase@details@Concurrency@@1IB DD 02H ; Concurrency::details::_TaskCollectionBase::_S_cancelDeferredShootdownOwner
CONST	ENDS
;	COMDAT ?_STATE_SYNCHRONIZE@_CancellationTokenRegistration@details@Concurrency@@0JB
CONST	SEGMENT
?_STATE_SYNCHRONIZE@_CancellationTokenRegistration@details@Concurrency@@0JB DD 02H ; Concurrency::details::_CancellationTokenRegistration::_STATE_SYNCHRONIZE
CONST	ENDS
;	COMDAT ?_S_reserved@_TaskCollectionBase@details@Concurrency@@1HB
CONST	SEGMENT
?_S_reserved@_TaskCollectionBase@details@Concurrency@@1HB DD 0cH ; Concurrency::details::_TaskCollectionBase::_S_reserved
CONST	ENDS
;	COMDAT ?_S_localCancel@_TaskCollectionBase@details@Concurrency@@1HB
CONST	SEGMENT
?_S_localCancel@_TaskCollectionBase@details@Concurrency@@1HB DD 02H ; Concurrency::details::_TaskCollectionBase::_S_localCancel
CONST	ENDS
;	COMDAT ?_S_structured@_TaskCollectionBase@details@Concurrency@@1HB
CONST	SEGMENT
?_S_structured@_TaskCollectionBase@details@Concurrency@@1HB DD 01H ; Concurrency::details::_TaskCollectionBase::_S_structured
CONST	ENDS
;	COMDAT ?_STATE_DEFER_DELETE@_CancellationTokenRegistration@details@Concurrency@@0JB
CONST	SEGMENT
?_STATE_DEFER_DELETE@_CancellationTokenRegistration@details@Concurrency@@0JB DD 01H ; Concurrency::details::_CancellationTokenRegistration::_STATE_DEFER_DELETE
CONST	ENDS
;	COMDAT ??_C@_0BC@KBDMBKEH@deque?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BC@KBDMBKEH@deque?$DMT?$DO?5too?5long?$AA@ DB 'deque<T> too long', 00H ; `string'
CONST	ENDS
PUBLIC	??_G?$shared_ptr@VChunkBase@@@std@@QAEPAXI@Z	; std::shared_ptr<ChunkBase>::`scalar deleting destructor'
PUBLIC	??$_Fill_n@PAPAV?$shared_ptr@VChunkBase@@@std@@IPAV12@@std@@YAPAPAV?$shared_ptr@VChunkBase@@@0@PAPAV10@IABQAV10@@Z ; std::_Fill_n<std::shared_ptr<ChunkBase> * *,unsigned int,std::shared_ptr<ChunkBase> *>
PUBLIC	??$destroy@V?$shared_ptr@VChunkBase@@@std@@@?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@QAEXPAV?$shared_ptr@VChunkBase@@@1@@Z ; std::allocator<std::shared_ptr<ChunkBase> >::destroy<std::shared_ptr<ChunkBase> >
PUBLIC	??$_Resetp0@VVertexStream@gfxu@@@?$shared_ptr@VVertexStream@gfxu@@@std@@QAEXPAVVertexStream@gfxu@@PAV_Ref_count_base@1@@Z ; std::shared_ptr<gfxu::VertexStream>::_Resetp0<gfxu::VertexStream>
PUBLIC	??1?$_Ref_count@VVertexStream@gfxu@@@std@@UAE@XZ ; std::_Ref_count<gfxu::VertexStream>::~_Ref_count<gfxu::VertexStream>
PUBLIC	??_G?$_Ref_count@VVertexStream@gfxu@@@std@@UAEPAXI@Z ; std::_Ref_count<gfxu::VertexStream>::`scalar deleting destructor'
PUBLIC	?_Delete_this@?$_Ref_count@VVertexStream@gfxu@@@std@@EAEXXZ ; std::_Ref_count<gfxu::VertexStream>::_Delete_this
PUBLIC	?_Destroy@?$_Ref_count@VVertexStream@gfxu@@@std@@EAEXXZ ; std::_Ref_count<gfxu::VertexStream>::_Destroy
PUBLIC	??0?$_Ref_count@VVertexStream@gfxu@@@std@@QAE@PAVVertexStream@gfxu@@@Z ; std::_Ref_count<gfxu::VertexStream>::_Ref_count<gfxu::VertexStream>
PUBLIC	?construct@?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@QAEXPAV?$shared_ptr@VChunkBase@@@2@ABV32@@Z ; std::allocator<std::shared_ptr<ChunkBase> >::construct
PUBLIC	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAV?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@YAXPAPAV?$shared_ptr@VChunkBase@@@0@0AAU?$_Wrap_alloc@V?$allocator@PAV?$shared_ptr@VChunkBase@@@std@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> *> > >
PUBLIC	??$_Uninit_def_fill_n@PAV?$shared_ptr@VChunkBase@@@std@@IPAV12@@std@@YAXPAPAV?$shared_ptr@VChunkBase@@@0@IAAU?$_Wrap_alloc@V?$allocator@PAV?$shared_ptr@VChunkBase@@@std@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_def_fill_n<std::shared_ptr<ChunkBase> *,unsigned int,std::shared_ptr<ChunkBase> *>
PUBLIC	??$_Val_type@PAPAV?$shared_ptr@VChunkBase@@@std@@@std@@YAPAPAV?$shared_ptr@VChunkBase@@@0@PAPAV10@@Z ; std::_Val_type<std::shared_ptr<ChunkBase> * *>
PUBLIC	??$_Uninit_copy@PAV?$shared_ptr@VChunkBase@@@std@@PAV12@@std@@YAPAPAV?$shared_ptr@VChunkBase@@@0@PAPAV10@00AAU?$_Wrap_alloc@V?$allocator@PAV?$shared_ptr@VChunkBase@@@std@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<std::shared_ptr<ChunkBase> *,std::shared_ptr<ChunkBase> *>
PUBLIC	??$_Ptr_cat@PAV?$shared_ptr@VChunkBase@@@std@@PAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAV?$shared_ptr@VChunkBase@@@0@0@Z ; std::_Ptr_cat<std::shared_ptr<ChunkBase> *,std::shared_ptr<ChunkBase> *>
PUBLIC	??$?0V?$shared_ptr@VChunkBase@@@std@@@?$allocator@PAV?$shared_ptr@VChunkBase@@@std@@@std@@QAE@ABV?$allocator@V?$shared_ptr@VChunkBase@@@std@@@1@@Z ; std::allocator<std::shared_ptr<ChunkBase> *>::allocator<std::shared_ptr<ChunkBase> *><std::shared_ptr<ChunkBase> >
PUBLIC	??$_Move@AAPAVVertexStream@gfxu@@@std@@YA$$QAPAVVertexStream@gfxu@@AAPAV12@@Z ; std::_Move<gfxu::VertexStream * &>
PUBLIC	??$_Move@AAPAV_Ref_count_base@std@@@std@@YA$$QAPAV_Ref_count_base@0@AAPAV10@@Z ; std::_Move<std::_Ref_count_base * &>
PUBLIC	??$construct@V?$shared_ptr@VChunkBase@@@std@@ABV12@@?$allocator_traits@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@SAXAAV?$allocator@V?$shared_ptr@VChunkBase@@@std@@@1@PAV?$shared_ptr@VChunkBase@@@1@ABV31@@Z ; std::allocator_traits<std::allocator<std::shared_ptr<ChunkBase> > >::construct<std::shared_ptr<ChunkBase>,std::shared_ptr<ChunkBase> const &>
PUBLIC	??$forward@ABV?$shared_ptr@VChunkBase@@@std@@@std@@YAABV?$shared_ptr@VChunkBase@@@0@ABV10@@Z ; std::forward<std::shared_ptr<ChunkBase> const &>
PUBLIC	??$destroy@V?$shared_ptr@VChunkBase@@@std@@@?$allocator_traits@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@SAXAAV?$allocator@V?$shared_ptr@VChunkBase@@@std@@@1@PAV?$shared_ptr@VChunkBase@@@1@@Z ; std::allocator_traits<std::allocator<std::shared_ptr<ChunkBase> > >::destroy<std::shared_ptr<ChunkBase> >
PUBLIC	??$_Resetp@VVertexStream@gfxu@@@?$shared_ptr@VVertexStream@gfxu@@@std@@AAEXPAVVertexStream@gfxu@@@Z ; std::shared_ptr<gfxu::VertexStream>::_Resetp<gfxu::VertexStream>
PUBLIC	?_Reset0@?$_Ptr_base@VChunkBase@@@std@@QAEXPAVChunkBase@@PAV_Ref_count_base@2@@Z ; std::_Ptr_base<ChunkBase>::_Reset0
PUBLIC	?_Reset0@?$_Ptr_base@VVertexStream@gfxu@@@std@@QAEXPAVVertexStream@gfxu@@PAV_Ref_count_base@2@@Z ; std::_Ptr_base<gfxu::VertexStream>::_Reset0
PUBLIC	?_Reset@?$_Ptr_base@VChunkBase@@@std@@QAEXPAVChunkBase@@PAV_Ref_count_base@2@@Z ; std::_Ptr_base<ChunkBase>::_Reset
PUBLIC	?_Reset@?$_Ptr_base@VVertexStream@gfxu@@@std@@QAEXPAVVertexStream@gfxu@@PAV_Ref_count_base@2@@Z ; std::_Ptr_base<gfxu::VertexStream>::_Reset
PUBLIC	??$_Allocate@PAV?$shared_ptr@VChunkBase@@@std@@@std@@YAPAPAV?$shared_ptr@VChunkBase@@@0@IPAPAV10@@Z ; std::_Allocate<std::shared_ptr<ChunkBase> *>
PUBLIC	??$_Allocate@V?$shared_ptr@VChunkBase@@@std@@@std@@YAPAV?$shared_ptr@VChunkBase@@@0@IPAV10@@Z ; std::_Allocate<std::shared_ptr<ChunkBase> >
PUBLIC	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAV?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@YAXPAPAV?$shared_ptr@VChunkBase@@@0@0AAU?$_Wrap_alloc@V?$allocator@PAV?$shared_ptr@VChunkBase@@@std@@@std@@@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> *> > >
PUBLIC	??$_Uninitialized_default_fill_n@PAPAV?$shared_ptr@VChunkBase@@@std@@IU?$_Wrap_alloc@V?$allocator@PAV?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@YAXPAPAV?$shared_ptr@VChunkBase@@@0@IAAU?$_Wrap_alloc@V?$allocator@PAV?$shared_ptr@VChunkBase@@@std@@@std@@@0@@Z ; std::_Uninitialized_default_fill_n<std::shared_ptr<ChunkBase> * *,unsigned int,std::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> *> > >
PUBLIC	??$_Uninitialized_copy@PAPAV?$shared_ptr@VChunkBase@@@std@@PAPAV12@U?$_Wrap_alloc@V?$allocator@PAV?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@YAPAPAV?$shared_ptr@VChunkBase@@@0@PAPAV10@00AAU?$_Wrap_alloc@V?$allocator@PAV?$shared_ptr@VChunkBase@@@std@@@std@@@0@@Z ; std::_Uninitialized_copy<std::shared_ptr<ChunkBase> * *,std::shared_ptr<ChunkBase> * *,std::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> *> > >
PUBLIC	??$?0U?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@?$_Wrap_alloc@V?$allocator@PAV?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QAE@ABU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@1@@Z ; std::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> *> >::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> *> ><std::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> > > >
PUBLIC	??$swap@PAVVertexStream@gfxu@@@std@@YAXAAPAVVertexStream@gfxu@@0@Z ; std::swap<gfxu::VertexStream *>
PUBLIC	??$swap@PAV_Ref_count_base@std@@@std@@YAXAAPAV_Ref_count_base@0@0@Z ; std::swap<std::_Ref_count_base *>
PUBLIC	??$construct@V?$shared_ptr@VChunkBase@@@std@@ABV12@@?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QAEXPAV?$shared_ptr@VChunkBase@@@1@ABV21@@Z ; std::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> > >::construct<std::shared_ptr<ChunkBase>,std::shared_ptr<ChunkBase> const &>
PUBLIC	??$destroy@V?$shared_ptr@VChunkBase@@@std@@@?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QAEXPAV?$shared_ptr@VChunkBase@@@1@@Z ; std::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> > >::destroy<std::shared_ptr<ChunkBase> >
PUBLIC	??$_Reset@VVertexStream@gfxu@@@?$_Ptr_base@VVertexStream@gfxu@@@std@@QAEXABV01@@Z ; std::_Ptr_base<gfxu::VertexStream>::_Reset<gfxu::VertexStream>
PUBLIC	??$_Reset@VChunkBase@@@?$_Ptr_base@VChunkBase@@@std@@QAEXABV01@@Z ; std::_Ptr_base<ChunkBase>::_Reset<ChunkBase>
PUBLIC	??$?0VVertexStream@gfxu@@@?$shared_ptr@VVertexStream@gfxu@@@std@@QAE@PAVVertexStream@gfxu@@@Z ; std::shared_ptr<gfxu::VertexStream>::shared_ptr<gfxu::VertexStream><gfxu::VertexStream>
PUBLIC	?max_size@?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@QBEIXZ ; std::allocator<std::shared_ptr<ChunkBase> >::max_size
PUBLIC	?_Setcont@?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@QAEXPBV?$_Deque_val@U?$_Deque_simple_types@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@Z ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<std::shared_ptr<ChunkBase> > > >::_Setcont
PUBLIC	?max_size@?$allocator_traits@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@SAIABV?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@Z ; std::allocator_traits<std::allocator<std::shared_ptr<ChunkBase> > >::max_size
PUBLIC	??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<std::shared_ptr<ChunkBase> > > >::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<std::shared_ptr<ChunkBase> > > >
PUBLIC	?allocate@?$allocator@PAV?$shared_ptr@VChunkBase@@@std@@@std@@QAEPAPAV?$shared_ptr@VChunkBase@@@2@I@Z ; std::allocator<std::shared_ptr<ChunkBase> *>::allocate
PUBLIC	?deallocate@?$allocator@PAV?$shared_ptr@VChunkBase@@@std@@@std@@QAEXPAPAV?$shared_ptr@VChunkBase@@@2@I@Z ; std::allocator<std::shared_ptr<ChunkBase> *>::deallocate
PUBLIC	?max_size@?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> > >::max_size
PUBLIC	??0?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@QAE@XZ ; std::allocator<std::shared_ptr<ChunkBase> >::allocator<std::shared_ptr<ChunkBase> >
PUBLIC	??D?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@QBEABV?$shared_ptr@VChunkBase@@@1@XZ ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<std::shared_ptr<ChunkBase> > > >::operator*
PUBLIC	??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<std::shared_ptr<ChunkBase> > > >::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<std::shared_ptr<ChunkBase> > > >
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@PAV?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QAEXPAPAV?$shared_ptr@VChunkBase@@@2@I@Z ; std::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> *> >::deallocate
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@PAV?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QAEPAPAV?$shared_ptr@VChunkBase@@@2@I@Z ; std::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> *> >::allocate
PUBLIC	??0?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> > >::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> > >
PUBLIC	?allocate@?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@QAEPAV?$shared_ptr@VChunkBase@@@2@I@Z ; std::allocator<std::shared_ptr<ChunkBase> >::allocate
PUBLIC	?_Xlen@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IBEXXZ ; std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::_Xlen
PUBLIC	?max_size@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QBEIXZ ; std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::max_size
PUBLIC	??D?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@QBEAAV?$shared_ptr@VChunkBase@@@1@XZ ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<std::shared_ptr<ChunkBase> > > >::operator*
PUBLIC	?_Getblock@?$_Deque_val@U?$_Deque_simple_types@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QBEII@Z ; std::_Deque_val<std::_Deque_simple_types<std::shared_ptr<ChunkBase> > >::_Getblock
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QAEPAV?$shared_ptr@VChunkBase@@@2@I@Z ; std::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> > >::allocate
PUBLIC	?_Getal@?$_Deque_alloc@$0A@U?$_Deque_base_types@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@XZ ; std::_Deque_alloc<0,std::_Deque_base_types<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > > >::_Getal
PUBLIC	?_Growmap@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IAEXI@Z ; std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::_Growmap
PUBLIC	?empty@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QBE_NXZ ; std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::empty
PUBLIC	?begin@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@2@XZ ; std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::begin
PUBLIC	?_Swap@?$_Ptr_base@VVertexStream@gfxu@@@std@@QAEXAAV12@@Z ; std::_Ptr_base<gfxu::VertexStream>::_Swap
PUBLIC	??0?$_Ptr_base@VVertexStream@gfxu@@@std@@QAE@XZ	; std::_Ptr_base<gfxu::VertexStream>::_Ptr_base<gfxu::VertexStream>
PUBLIC	??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@QAE@XZ ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<std::shared_ptr<ChunkBase> > > >::~_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<std::shared_ptr<ChunkBase> > > >
PUBLIC	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@QAE@XZ ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<std::shared_ptr<ChunkBase> > > >::~_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<std::shared_ptr<ChunkBase> > > >
PUBLIC	?_Decref@?$_Ptr_base@VChunkBase@@@std@@QAEXXZ	; std::_Ptr_base<ChunkBase>::_Decref
PUBLIC	?_Get@?$_Ptr_base@VChunkBase@@@std@@QBEPAVChunkBase@@XZ ; std::_Ptr_base<ChunkBase>::_Get
PUBLIC	??0?$_Ptr_base@VChunkBase@@@std@@QAE@XZ		; std::_Ptr_base<ChunkBase>::_Ptr_base<ChunkBase>
PUBLIC	?push_back@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QAEXABV?$shared_ptr@VChunkBase@@@2@@Z ; std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::push_back
PUBLIC	?pop_front@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QAEXXZ ; std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::pop_front
PUBLIC	?front@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QAEAAV?$shared_ptr@VChunkBase@@@2@XZ ; std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::front
PUBLIC	?size@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QBEIXZ ; std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::size
PUBLIC	?_Decref@?$_Ptr_base@VVertexStream@gfxu@@@std@@QAEXXZ ; std::_Ptr_base<gfxu::VertexStream>::_Decref
PUBLIC	?swap@?$shared_ptr@VVertexStream@gfxu@@@std@@QAEXAAV12@@Z ; std::shared_ptr<gfxu::VertexStream>::swap
PUBLIC	??0?$shared_ptr@VVertexStream@gfxu@@@std@@QAE@ABV01@@Z ; std::shared_ptr<gfxu::VertexStream>::shared_ptr<gfxu::VertexStream>
PUBLIC	??C?$shared_ptr@VChunkBase@@@std@@QBEPAVChunkBase@@XZ ; std::shared_ptr<ChunkBase>::operator->
PUBLIC	??1?$shared_ptr@VChunkBase@@@std@@QAE@XZ	; std::shared_ptr<ChunkBase>::~shared_ptr<ChunkBase>
PUBLIC	??0?$shared_ptr@VChunkBase@@@std@@QAE@ABV01@@Z	; std::shared_ptr<ChunkBase>::shared_ptr<ChunkBase>
PUBLIC	?pop@?$queue@V?$shared_ptr@VChunkBase@@@std@@V?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@2@@std@@QAEXXZ ; std::queue<std::shared_ptr<ChunkBase>,std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > > >::pop
PUBLIC	?push@?$queue@V?$shared_ptr@VChunkBase@@@std@@V?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@2@@std@@QAEXABV?$shared_ptr@VChunkBase@@@2@@Z ; std::queue<std::shared_ptr<ChunkBase>,std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > > >::push
PUBLIC	?front@?$queue@V?$shared_ptr@VChunkBase@@@std@@V?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@2@@std@@QAEAAV?$shared_ptr@VChunkBase@@@2@XZ ; std::queue<std::shared_ptr<ChunkBase>,std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > > >::front
PUBLIC	?size@?$queue@V?$shared_ptr@VChunkBase@@@std@@V?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@2@@std@@QBEIXZ ; std::queue<std::shared_ptr<ChunkBase>,std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > > >::size
PUBLIC	??4?$shared_ptr@VVertexStream@gfxu@@@std@@QAEAAV01@ABV01@@Z ; std::shared_ptr<gfxu::VertexStream>::operator=
PUBLIC	??1?$shared_ptr@VVertexStream@gfxu@@@std@@QAE@XZ ; std::shared_ptr<gfxu::VertexStream>::~shared_ptr<gfxu::VertexStream>
PUBLIC	?requestLateChunkDraw@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z ; requestLateChunkDraw
PUBLIC	?requestChunkDraw@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z ; requestChunkDraw
PUBLIC	?requestQuickChunkDraw@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z ; requestQuickChunkDraw
PUBLIC	?tick@ChunkDrawThread@@EAE_NXZ			; ChunkDrawThread::tick
PUBLIC	?renderFirstPossible@@YA_NAAV?$queue@V?$shared_ptr@VChunkBase@@@std@@V?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@2@@std@@@Z ; renderFirstPossible
PUBLIC	?renderChunk@@YA_NV?$shared_ptr@VChunkBase@@@std@@@Z ; renderChunk
PUBLIC	?_Enable_shared@std@@YAXPDX0@Z			; std::_Enable_shared
PUBLIC	??_G_Ref_count_base@std@@UAEPAXI@Z		; std::_Ref_count_base::`scalar deleting destructor'
PUBLIC	?_Get_deleter@_Ref_count_base@std@@UBEPAXABVtype_info@@@Z ; std::_Ref_count_base::_Get_deleter
PUBLIC	?_Decwref@_Ref_count_base@std@@QAEXXZ		; std::_Ref_count_base::_Decwref
PUBLIC	?_Decref@_Ref_count_base@std@@QAEXXZ		; std::_Ref_count_base::_Decref
PUBLIC	?_Incref@_Ref_count_base@std@@QAEXXZ		; std::_Ref_count_base::_Incref
PUBLIC	??1_Ref_count_base@std@@UAE@XZ			; std::_Ref_count_base::~_Ref_count_base
PUBLIC	??0_Ref_count_base@std@@IAE@XZ			; std::_Ref_count_base::_Ref_count_base
PUBLIC	?unlock@_Mutex_base@std@@QAEXXZ			; std::_Mutex_base::unlock
PUBLIC	?lock@_Mutex_base@std@@QAEXXZ			; std::_Mutex_base::lock
PUBLIC	?_Mtx_unlockX@std@@YAHPAPAU_Mtx_internal_imp_t@@@Z ; std::_Mtx_unlockX
PUBLIC	?_Mtx_lockX@std@@YAHPAPAU_Mtx_internal_imp_t@@@Z ; std::_Mtx_lockX
PUBLIC	?_Check_C_return@std@@YAHH@Z			; std::_Check_C_return
PUBLIC	??0_Ignore@std@@QAE@XZ				; std::_Ignore::_Ignore
PUBLIC	?_Init_atomic_counter@std@@YAXAAKK@Z		; std::_Init_atomic_counter
PUBLIC	?_Orphan_all@_Container_base12@std@@QAEXXZ	; std::_Container_base12::_Orphan_all
PUBLIC	?_Orphan_me@_Iterator_base12@std@@QAEXXZ	; std::_Iterator_base12::_Orphan_me
PUBLIC	?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont
PUBLIC	?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z ; std::_Iterator_base12::_Adopt
PUBLIC	??1_Iterator_base12@std@@QAE@XZ			; std::_Iterator_base12::~_Iterator_base12
PUBLIC	??0_Iterator_base12@std@@QAE@XZ			; std::_Iterator_base12::_Iterator_base12
PUBLIC	??2@YAPAXIPAX@Z					; operator new
PUBLIC	__real@00000000
PUBLIC	__real@3d800000
PUBLIC	__real@3dcccccd
PUBLIC	__real@3ecccccd
PUBLIC	__real@3f000000
PUBLIC	__real@3f800000
PUBLIC	__real@3fe0000000000000
PUBLIC	__real@3ff0000000000000
PUBLIC	__real@40000000
PUBLIC	__real@4000000000000000
PUBLIC	__real@400921fb54442d18
PUBLIC	__real@40200000
PUBLIC	__real@40400000
PUBLIC	__real@4066800000000000
PUBLIC	__real@4076800000000000
PUBLIC	__real@42c00000
PUBLIC	__real@437f0000
PUBLIC	__xmm@41f00000000000000000000000000000
PUBLIC	__xmm@80000000800000008000000080000000
EXTRN	??_E?$_Ref_count@VVertexStream@gfxu@@@std@@UAEPAXI@Z:PROC ; std::_Ref_count<gfxu::VertexStream>::`vector deleting destructor'
EXTRN	??_E_Ref_count_base@std@@UAEPAXI@Z:PROC		; std::_Ref_count_base::`vector deleting destructor'
EXTRN	__CxxThrowException@8:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	__alldiv:PROC
EXTRN	__allmul:PROC
EXTRN	__libm_sse2_cos_precise:PROC
EXTRN	__libm_sse2_sin_precise:PROC
EXTRN	__libm_sse2_tan_precise:PROC
EXTRN	_floor:PROC
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
__Tuple_alloc DB 01H DUP (?)
	ALIGN	4

_ignore	DB	01H DUP (?)
	ALIGN	4

_allocator_arg DB 01H DUP (?)
	ALIGN	4

_piecewise_construct DB 01H DUP (?)
_BSS	ENDS
;	COMDAT __xmm@80000000800000008000000080000000
CONST	SEGMENT
__xmm@80000000800000008000000080000000 DB 00H, 00H, 00H, 080H, 00H, 00H, 00H
	DB	080H, 00H, 00H, 00H, 080H, 00H, 00H, 00H, 080H
CONST	ENDS
;	COMDAT __xmm@41f00000000000000000000000000000
CONST	SEGMENT
__xmm@41f00000000000000000000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 00H, 00H, 00H, 00H, 00H, 00H, 0f0H, 'A'
CONST	ENDS
;	COMDAT __real@437f0000
CONST	SEGMENT
__real@437f0000 DD 0437f0000r			; 255
CONST	ENDS
;	COMDAT __real@42c00000
CONST	SEGMENT
__real@42c00000 DD 042c00000r			; 96
CONST	ENDS
;	COMDAT __real@4076800000000000
CONST	SEGMENT
__real@4076800000000000 DQ 04076800000000000r	; 360
CONST	ENDS
;	COMDAT __real@4066800000000000
CONST	SEGMENT
__real@4066800000000000 DQ 04066800000000000r	; 180
CONST	ENDS
;	COMDAT __real@40400000
CONST	SEGMENT
__real@40400000 DD 040400000r			; 3
CONST	ENDS
;	COMDAT __real@40200000
CONST	SEGMENT
__real@40200000 DD 040200000r			; 2.5
CONST	ENDS
;	COMDAT __real@400921fb54442d18
CONST	SEGMENT
__real@400921fb54442d18 DQ 0400921fb54442d18r	; 3.14159
CONST	ENDS
;	COMDAT __real@4000000000000000
CONST	SEGMENT
__real@4000000000000000 DQ 04000000000000000r	; 2
CONST	ENDS
;	COMDAT __real@40000000
CONST	SEGMENT
__real@40000000 DD 040000000r			; 2
CONST	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT __real@3fe0000000000000
CONST	SEGMENT
__real@3fe0000000000000 DQ 03fe0000000000000r	; 0.5
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT __real@3ecccccd
CONST	SEGMENT
__real@3ecccccd DD 03ecccccdr			; 0.4
CONST	ENDS
;	COMDAT __real@3dcccccd
CONST	SEGMENT
__real@3dcccccd DD 03dcccccdr			; 0.1
CONST	ENDS
;	COMDAT __real@3d800000
CONST	SEGMENT
__real@3d800000 DD 03d800000r			; 0.0625
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?renderChunk@@YA_NV?$shared_ptr@VChunkBase@@@std@@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?renderChunk@@YA_NV?$shared_ptr@VChunkBase@@@std@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?renderChunk@@YA_NV?$shared_ptr@VChunkBase@@@std@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?renderChunk@@YA_NV?$shared_ptr@VChunkBase@@@std@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?renderChunk@@YA_NV?$shared_ptr@VChunkBase@@@std@@@Z$1
	DD	00H
	DD	FLAT:__unwindfunclet$?renderChunk@@YA_NV?$shared_ptr@VChunkBase@@@std@@@Z$2
	DD	00H
	DD	FLAT:__unwindfunclet$?renderChunk@@YA_NV?$shared_ptr@VChunkBase@@@std@@@Z$3
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?renderFirstPossible@@YA_NAAV?$queue@V?$shared_ptr@VChunkBase@@@std@@V?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@2@@std@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?renderFirstPossible@@YA_NAAV?$queue@V?$shared_ptr@VChunkBase@@@std@@V?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@2@@std@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?renderFirstPossible@@YA_NAAV?$queue@V?$shared_ptr@VChunkBase@@@std@@V?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@2@@std@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?renderFirstPossible@@YA_NAAV?$queue@V?$shared_ptr@VChunkBase@@@std@@V?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@2@@std@@@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?requestQuickChunkDraw@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?requestQuickChunkDraw@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?requestQuickChunkDraw@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?requestQuickChunkDraw@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?requestChunkDraw@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?requestChunkDraw@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?requestChunkDraw@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?requestChunkDraw@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?requestLateChunkDraw@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?requestLateChunkDraw@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?requestLateChunkDraw@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?requestLateChunkDraw@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Resetp@VVertexStream@gfxu@@@?$shared_ptr@VVertexStream@gfxu@@@std@@AAEXPAVVertexStream@gfxu@@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Resetp@VVertexStream@gfxu@@@?$shared_ptr@VVertexStream@gfxu@@@std@@AAEXPAVVertexStream@gfxu@@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Resetp@VVertexStream@gfxu@@@?$shared_ptr@VVertexStream@gfxu@@@std@@AAEXPAVVertexStream@gfxu@@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$_Resetp@VVertexStream@gfxu@@@?$shared_ptr@VVertexStream@gfxu@@@std@@AAEXPAVVertexStream@gfxu@@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Resetp@VVertexStream@gfxu@@@?$shared_ptr@VVertexStream@gfxu@@@std@@AAEXPAVVertexStream@gfxu@@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Resetp@VVertexStream@gfxu@@@?$shared_ptr@VVertexStream@gfxu@@@std@@AAEXPAVVertexStream@gfxu@@@Z$3
__catchsym$??$_Resetp@VVertexStream@gfxu@@@?$shared_ptr@VVertexStream@gfxu@@@std@@AAEXPAVVertexStream@gfxu@@@Z$3 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Resetp@VVertexStream@gfxu@@@?$shared_ptr@VVertexStream@gfxu@@@std@@AAEXPAVVertexStream@gfxu@@@Z$0
xdata$x	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\new
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 59   : 	{	// construct array with placement at _Where

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 60   : 	return (_Where);

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Where$[ebp]

; 61   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??0_Iterator_base12@std@@QAE@XZ
_TEXT	SEGMENT
??0_Iterator_base12@std@@QAE@XZ PROC			; std::_Iterator_base12::_Iterator_base12, COMDAT
; _this$ = ecx

; 113  : 		{	// construct orphaned iterator

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  00006	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 114  : 		}

  0000d	8b c1		 mov	 eax, ecx
  0000f	c3		 ret	 0
??0_Iterator_base12@std@@QAE@XZ ENDP			; std::_Iterator_base12::_Iterator_base12
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??1_Iterator_base12@std@@QAE@XZ
_TEXT	SEGMENT
??1_Iterator_base12@std@@QAE@XZ PROC			; std::_Iterator_base12::~_Iterator_base12, COMDAT
; _this$dead$ = ecx

; 138  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 139  : 		_Lockit _Lock(_LOCK_DEBUG);
; 140  : 		_Orphan_me();
; 141  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 142  : 		}

  00000	c3		 ret	 0
??1_Iterator_base12@std@@QAE@XZ ENDP			; std::_Iterator_base12::~_Iterator_base12
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z
_TEXT	SEGMENT
__Lock$1 = -4						; size = 4
?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z PROC ; std::_Iterator_base12::_Adopt, COMDAT
; _this$ = ecx

; 145  : 		{	// adopt this iterator by parent

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 146  : 		if (_Parent == 0)
; 147  : 			{	// no future parent, just disown current parent
; 148  : 			_Lockit _Lock(_LOCK_DEBUG);

  00004	6a 03		 push	 3
  00006	8d 4d fc	 lea	 ecx, DWORD PTR __Lock$1[ebp]
  00009	e8 00 00 00 00	 call	 ??0_Lockit@std@@QAE@H@Z	; std::_Lockit::_Lockit

; 149  : 			_Orphan_me();
; 150  : 			}

  0000e	8d 4d fc	 lea	 ecx, DWORD PTR __Lock$1[ebp]
  00011	e8 00 00 00 00	 call	 ??1_Lockit@std@@QAE@XZ	; std::_Lockit::~_Lockit

; 151  : 		else
; 152  : 			{	// have a parent, do adoption
; 153  : 			_Container_proxy *_Parent_proxy = _Parent->_Myproxy;
; 154  : 
; 155  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 156  : 			if (_Myproxy != _Parent_proxy)
; 157  : 				{	// change parentage
; 158  : 				_Lockit _Lock(_LOCK_DEBUG);
; 159  : 				_Orphan_me();
; 160  : 				_Mynextiter = _Parent_proxy->_Myfirstiter;
; 161  : 				_Parent_proxy->_Myfirstiter = this;
; 162  : 				_Myproxy = _Parent_proxy;
; 163  : 				}
; 164  : 
; 165  :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 166  : 			_Myproxy = _Parent_proxy;
; 167  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 168  : 			}
; 169  : 		}

  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z ENDP ; std::_Iterator_base12::_Adopt
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ
_TEXT	SEGMENT
?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ PROC ; std::_Iterator_base12::_Getcont, COMDAT
; _this$ = ecx

; 178  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	85 c0		 test	 eax, eax
  00004	75 01		 jne	 SHORT $LN3@Getcont

; 179  : 		}

  00006	c3		 ret	 0
$LN3@Getcont:

; 178  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

  00007	8b 00		 mov	 eax, DWORD PTR [eax]

; 179  : 		}

  00009	c3		 ret	 0
?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ENDP ; std::_Iterator_base12::_Getcont
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ?_Orphan_me@_Iterator_base12@std@@QAEXXZ
_TEXT	SEGMENT
?_Orphan_me@_Iterator_base12@std@@QAEXXZ PROC		; std::_Iterator_base12::_Orphan_me, COMDAT
; _this$dead$ = ecx

; 188  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 189  : 		if (_Myproxy != 0)
; 190  : 			{	// adopted, remove self from list
; 191  : 			_Iterator_base12 **_Pnext = &_Myproxy->_Myfirstiter;
; 192  : 			while (*_Pnext != 0 && *_Pnext != this)
; 193  : 				_Pnext = &(*_Pnext)->_Mynextiter;
; 194  : 
; 195  : 			if (*_Pnext == 0)
; 196  : 				_DEBUG_ERROR("ITERATOR LIST CORRUPTED!");
; 197  : 			*_Pnext = _Mynextiter;
; 198  : 			_Myproxy = 0;
; 199  : 			}
; 200  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 201  : 		}

  00000	c3		 ret	 0
?_Orphan_me@_Iterator_base12@std@@QAEXXZ ENDP		; std::_Iterator_base12::_Orphan_me
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ?_Orphan_all@_Container_base12@std@@QAEXXZ
_TEXT	SEGMENT
?_Orphan_all@_Container_base12@std@@QAEXXZ PROC		; std::_Container_base12::_Orphan_all, COMDAT
; _this$dead$ = ecx

; 210  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 211  : 	if (_Myproxy != 0)
; 212  : 		{	// proxy allocated, drain it
; 213  : 		_Lockit _Lock(_LOCK_DEBUG);
; 214  : 
; 215  : 		for (_Iterator_base12 **_Pnext = &_Myproxy->_Myfirstiter;
; 216  : 			*_Pnext != 0; *_Pnext = (*_Pnext)->_Mynextiter)
; 217  : 			(*_Pnext)->_Myproxy = 0;
; 218  : 		_Myproxy->_Myfirstiter = 0;
; 219  : 		}
; 220  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 221  : 	}

  00000	c3		 ret	 0
?_Orphan_all@_Container_base12@std@@QAEXXZ ENDP		; std::_Container_base12::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xatomic0.h
;	COMDAT ?_Init_atomic_counter@std@@YAXAAKK@Z
_TEXT	SEGMENT
__Counter$ = 8						; size = 4
__Value$ = 12						; size = 4
?_Init_atomic_counter@std@@YAXAAKK@Z PROC		; std::_Init_atomic_counter, COMDAT

; 218  : 	{	// non-atomically initialize counter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 219  : 	_Counter = _Value;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Counter$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Value$[ebp]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 220  : 	}

  0000b	5d		 pop	 ebp
  0000c	c3		 ret	 0
?_Init_atomic_counter@std@@YAXAAKK@Z ENDP		; std::_Init_atomic_counter
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\tuple
;	COMDAT ??0_Ignore@std@@QAE@XZ
_TEXT	SEGMENT
??0_Ignore@std@@QAE@XZ PROC				; std::_Ignore::_Ignore, COMDAT
; _this$ = ecx

; 121  : 		{	// construct
; 122  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0_Ignore@std@@QAE@XZ ENDP				; std::_Ignore::_Ignore
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
;	COMDAT ?_Check_C_return@std@@YAHH@Z
_TEXT	SEGMENT
__Res$ = 8						; size = 4
?_Check_C_return@std@@YAHH@Z PROC			; std::_Check_C_return, COMDAT

; 31   : 	{	// throw exception on failure

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 32   : 	if (_Res != _Thrd_success)

  00004	8b 75 08	 mov	 esi, DWORD PTR __Res$[ebp]
  00007	85 f6		 test	 esi, esi
  00009	74 09		 je	 SHORT $LN4@Check_C_re

; 33   : 		_Throw_C_error(_Res);

  0000b	56		 push	 esi
  0000c	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
  00011	83 c4 04	 add	 esp, 4
$LN4@Check_C_re:

; 34   : 	return (_Res);

  00014	8b c6		 mov	 eax, esi
  00016	5e		 pop	 esi

; 35   : 	}

  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
?_Check_C_return@std@@YAHH@Z ENDP			; std::_Check_C_return
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
;	COMDAT ?_Mtx_lockX@std@@YAHPAPAU_Mtx_internal_imp_t@@@Z
_TEXT	SEGMENT
__Mtx$ = 8						; size = 4
?_Mtx_lockX@std@@YAHPAPAU_Mtx_internal_imp_t@@@Z PROC	; std::_Mtx_lockX, COMDAT

; 67   : 	{	// throw exception on failure

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 68   : 	return (_Check_C_return(_Mtx_lock(_Mtx)));

  00004	ff 75 08	 push	 DWORD PTR __Mtx$[ebp]
  00007	e8 00 00 00 00	 call	 __Mtx_lock
  0000c	8b f0		 mov	 esi, eax
  0000e	83 c4 04	 add	 esp, 4

; 32   : 	if (_Res != _Thrd_success)

  00011	85 f6		 test	 esi, esi
  00013	74 0b		 je	 SHORT $LN3@Mtx_lockX

; 33   : 		_Throw_C_error(_Res);

  00015	56		 push	 esi
  00016	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
  0001b	83 c4 04	 add	 esp, 4

; 68   : 	return (_Check_C_return(_Mtx_lock(_Mtx)));

  0001e	8b c6		 mov	 eax, esi
$LN3@Mtx_lockX:
  00020	5e		 pop	 esi

; 69   : 	}

  00021	5d		 pop	 ebp
  00022	c3		 ret	 0
?_Mtx_lockX@std@@YAHPAPAU_Mtx_internal_imp_t@@@Z ENDP	; std::_Mtx_lockX
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
;	COMDAT ?_Mtx_unlockX@std@@YAHPAPAU_Mtx_internal_imp_t@@@Z
_TEXT	SEGMENT
__Mtx$ = 8						; size = 4
?_Mtx_unlockX@std@@YAHPAPAU_Mtx_internal_imp_t@@@Z PROC	; std::_Mtx_unlockX, COMDAT

; 82   : 	{	// throw exception on failure

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 83   : 	return (_Check_C_return(_Mtx_unlock(_Mtx)));

  00004	ff 75 08	 push	 DWORD PTR __Mtx$[ebp]
  00007	e8 00 00 00 00	 call	 __Mtx_unlock
  0000c	8b f0		 mov	 esi, eax
  0000e	83 c4 04	 add	 esp, 4

; 32   : 	if (_Res != _Thrd_success)

  00011	85 f6		 test	 esi, esi
  00013	74 0b		 je	 SHORT $LN3@Mtx_unlock

; 33   : 		_Throw_C_error(_Res);

  00015	56		 push	 esi
  00016	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
  0001b	83 c4 04	 add	 esp, 4

; 83   : 	return (_Check_C_return(_Mtx_unlock(_Mtx)));

  0001e	8b c6		 mov	 eax, esi
$LN3@Mtx_unlock:
  00020	5e		 pop	 esi

; 84   : 	}

  00021	5d		 pop	 ebp
  00022	c3		 ret	 0
?_Mtx_unlockX@std@@YAHPAPAU_Mtx_internal_imp_t@@@Z ENDP	; std::_Mtx_unlockX
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\mutex
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\mutex
;	COMDAT ?lock@_Mutex_base@std@@QAEXXZ
_TEXT	SEGMENT
?lock@_Mutex_base@std@@QAEXXZ PROC			; std::_Mutex_base::lock, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 68   : 	return (_Check_C_return(_Mtx_lock(_Mtx)));

  00000	51		 push	 ecx
  00001	e8 00 00 00 00	 call	 __Mtx_lock
  00006	83 c4 04	 add	 esp, 4

; 32   : 	if (_Res != _Thrd_success)

  00009	85 c0		 test	 eax, eax
  0000b	74 07		 je	 SHORT $LN5@lock

; 33   : 		_Throw_C_error(_Res);

  0000d	50		 push	 eax
  0000e	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
  00013	59		 pop	 ecx
$LN5@lock:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\mutex

; 44   : 		}

  00014	c3		 ret	 0
?lock@_Mutex_base@std@@QAEXXZ ENDP			; std::_Mutex_base::lock
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\mutex
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\mutex
;	COMDAT ?unlock@_Mutex_base@std@@QAEXXZ
_TEXT	SEGMENT
?unlock@_Mutex_base@std@@QAEXXZ PROC			; std::_Mutex_base::unlock, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 83   : 	return (_Check_C_return(_Mtx_unlock(_Mtx)));

  00000	51		 push	 ecx
  00001	e8 00 00 00 00	 call	 __Mtx_unlock
  00006	83 c4 04	 add	 esp, 4

; 32   : 	if (_Res != _Thrd_success)

  00009	85 c0		 test	 eax, eax
  0000b	74 07		 je	 SHORT $LN5@unlock

; 33   : 		_Throw_C_error(_Res);

  0000d	50		 push	 eax
  0000e	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
  00013	59		 pop	 ecx
$LN5@unlock:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\mutex

; 54   : 		}

  00014	c3		 ret	 0
?unlock@_Mutex_base@std@@QAEXXZ ENDP			; std::_Mutex_base::unlock
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xatomic0.h
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ??0_Ref_count_base@std@@IAE@XZ
_TEXT	SEGMENT
??0_Ref_count_base@std@@IAE@XZ PROC			; std::_Ref_count_base::_Ref_count_base, COMDAT
; _this$ = ecx

; 61   : 	_Ref_count_base()

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7_Ref_count_base@std@@6B@
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xatomic0.h

; 219  : 	_Counter = _Value;

  00006	c7 41 04 01 00
	00 00		 mov	 DWORD PTR [ecx+4], 1
  0000d	c7 41 08 01 00
	00 00		 mov	 DWORD PTR [ecx+8], 1
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 65   : 		}

  00014	8b c1		 mov	 eax, ecx
  00016	c3		 ret	 0
??0_Ref_count_base@std@@IAE@XZ ENDP			; std::_Ref_count_base::_Ref_count_base
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ??1_Ref_count_base@std@@UAE@XZ
_TEXT	SEGMENT
??1_Ref_count_base@std@@UAE@XZ PROC			; std::_Ref_count_base::~_Ref_count_base, COMDAT
; _this$ = ecx

; 69   : 		{	// ensure that derived classes can be destroyed properly

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7_Ref_count_base@std@@6B@

; 70   : 		}

  00006	c3		 ret	 0
??1_Ref_count_base@std@@UAE@XZ ENDP			; std::_Ref_count_base::~_Ref_count_base
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ?_Incref@_Ref_count_base@std@@QAEXXZ
_TEXT	SEGMENT
?_Incref@_Ref_count_base@std@@QAEXXZ PROC		; std::_Ref_count_base::_Incref, COMDAT
; _this$ = ecx

; 108  : 		_MT_INCR(_Ignored, _Uses);

  00000	83 c1 04	 add	 ecx, 4
  00003	b8 01 00 00 00	 mov	 eax, 1
  00008	f0 0f c1 01	 lock	  xadd	 DWORD PTR [ecx], eax

; 109  : 		}

  0000c	c3		 ret	 0
?_Incref@_Ref_count_base@std@@QAEXXZ ENDP		; std::_Ref_count_base::_Incref
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ?_Decref@_Ref_count_base@std@@QAEXXZ
_TEXT	SEGMENT
?_Decref@_Ref_count_base@std@@QAEXXZ PROC		; std::_Ref_count_base::_Decref, COMDAT
; _this$ = ecx

; 117  : 		{	// decrement use count

  00000	56		 push	 esi
  00001	57		 push	 edi
  00002	8b f1		 mov	 esi, ecx

; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  00004	83 cf ff	 or	 edi, -1
  00007	8d 56 04	 lea	 edx, DWORD PTR [esi+4]
  0000a	8b c7		 mov	 eax, edi
  0000c	f0 0f c1 02	 lock	  xadd	 DWORD PTR [edx], eax
  00010	75 17		 jne	 SHORT $LN4@Decref

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  00012	8b 06		 mov	 eax, DWORD PTR [esi]
  00014	ff 10		 call	 DWORD PTR [eax]

; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  00016	8d 46 08	 lea	 eax, DWORD PTR [esi+8]
  00019	f0 0f c1 38	 lock	  xadd	 DWORD PTR [eax], edi
  0001d	4f		 dec	 edi
  0001e	75 09		 jne	 SHORT $LN4@Decref

; 128  : 			_Delete_this();

  00020	8b 06		 mov	 eax, DWORD PTR [esi]
  00022	5f		 pop	 edi
  00023	8b ce		 mov	 ecx, esi
  00025	5e		 pop	 esi
  00026	ff 60 04	 jmp	 DWORD PTR [eax+4]
$LN4@Decref:
  00029	5f		 pop	 edi
  0002a	5e		 pop	 esi

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}

  0002b	c3		 ret	 0
?_Decref@_Ref_count_base@std@@QAEXXZ ENDP		; std::_Ref_count_base::_Decref
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ?_Decwref@_Ref_count_base@std@@QAEXXZ
_TEXT	SEGMENT
?_Decwref@_Ref_count_base@std@@QAEXXZ PROC		; std::_Ref_count_base::_Decwref, COMDAT
; _this$ = ecx

; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  00000	8d 41 08	 lea	 eax, DWORD PTR [ecx+8]
  00003	83 ca ff	 or	 edx, -1
  00006	f0 0f c1 10	 lock	  xadd	 DWORD PTR [eax], edx
  0000a	75 05		 jne	 SHORT $LN1@Decwref

; 128  : 			_Delete_this();

  0000c	8b 01		 mov	 eax, DWORD PTR [ecx]
  0000e	ff 60 04	 jmp	 DWORD PTR [eax+4]
$LN1@Decwref:

; 129  : 		}

  00011	c3		 ret	 0
?_Decwref@_Ref_count_base@std@@QAEXXZ ENDP		; std::_Ref_count_base::_Decwref
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ?_Get_deleter@_Ref_count_base@std@@UBEPAXABVtype_info@@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?_Get_deleter@_Ref_count_base@std@@UBEPAXABVtype_info@@@Z PROC ; std::_Ref_count_base::_Get_deleter, COMDAT
; _this$ = ecx

; 143  : 		return (0);

  00000	33 c0		 xor	 eax, eax

; 144  : 		}

  00002	c2 04 00	 ret	 4
?_Get_deleter@_Ref_count_base@std@@UBEPAXABVtype_info@@@Z ENDP ; std::_Ref_count_base::_Get_deleter
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ??_G_Ref_count_base@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G_Ref_count_base@std@@UAEPAXI@Z PROC			; std::_Ref_count_base::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx

; 69   : 		{	// ensure that derived classes can be destroyed properly

  0000a	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7_Ref_count_base@std@@6B@
  00010	74 09		 je	 SHORT $LN6@scalar
  00012	56		 push	 esi
  00013	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00018	83 c4 04	 add	 esp, 4
$LN6@scalar:
  0001b	8b c6		 mov	 eax, esi
  0001d	5e		 pop	 esi
  0001e	5d		 pop	 ebp
  0001f	c2 04 00	 ret	 4
??_G_Ref_count_base@std@@UAEPAXI@Z ENDP			; std::_Ref_count_base::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ?_Enable_shared@std@@YAXPDX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?_Enable_shared@std@@YAXPDX0@Z PROC			; std::_Enable_shared, COMDAT

; 269  : 	}

  00000	c3		 ret	 0
?_Enable_shared@std@@YAXPDX0@Z ENDP			; std::_Enable_shared
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\mutex
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\mutex
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\mutex
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\mutex
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\mutex
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp
;	COMDAT ?renderChunk@@YA_NV?$shared_ptr@VChunkBase@@@std@@@Z
_TEXT	SEGMENT
_vertexStream$ = -96					; size = 8
_c$2 = -96						; size = 8
_cx$1$ = -92						; size = 4
$T3 = -92						; size = 4
_f3$1$ = -88						; size = 4
_f2$1$ = -88						; size = 4
_f2$1$ = -88						; size = 4
_f3$1$ = -88						; size = 4
_f1$1$ = -88						; size = 4
tv4892 = -88						; size = 4
tv4835 = -88						; size = 4
tv4778 = -88						; size = 4
tv4720 = -88						; size = 4
tv4659 = -88						; size = 4
_cy$1$ = -84						; size = 4
_f2$1$ = -80						; size = 4
tv5124 = -80						; size = 4
tv5115 = -80						; size = 4
tv5114 = -80						; size = 4
tv4898 = -80						; size = 4
tv4841 = -80						; size = 4
tv4784 = -80						; size = 4
tv4726 = -80						; size = 4
tv4664 = -80						; size = 4
tv4594 = -80						; size = 4
tv5125 = -76						; size = 4
tv5123 = -76						; size = 4
tv5122 = -76						; size = 4
tv5119 = -76						; size = 4
tv4906 = -76						; size = 4
tv4849 = -76						; size = 4
tv4791 = -76						; size = 4
tv4734 = -76						; size = 4
tv4672 = -76						; size = 4
tv4599 = -76						; size = 4
_cz$1$ = -72						; size = 4
_i4$1$ = -68						; size = 4
tv5105 = -68						; size = 4
tv4903 = -68						; size = 4
tv4607 = -68						; size = 4
tv5128 = -64						; size = 4
_i$1$ = -64						; size = 4
tv5127 = -60						; size = 4
_i4$1$ = -56						; size = 4
_i4$1$ = -56						; size = 4
_i4$1$ = -56						; size = 4
_i4$1$ = -56						; size = 4
_i1$1$ = -56						; size = 4
_i1$1$ = -56						; size = 4
tv4905 = -56						; size = 4
tv4848 = -56						; size = 4
tv4792 = -56						; size = 4
tv4735 = -56						; size = 4
tv4674 = -56						; size = 4
tv4609 = -56						; size = 4
_i1$1$ = -52						; size = 4
_i3$1$ = -52						; size = 4
_i3$1$ = -52						; size = 4
_i4$1$ = -52						; size = 4
tv5120 = -52						; size = 4
tv5118 = -52						; size = 4
tv4907 = -52						; size = 4
tv4846 = -52						; size = 4
tv4788 = -52						; size = 4
tv4731 = -52						; size = 4
tv4669 = -52						; size = 4
tv4604 = -52						; size = 4
_f2$1$ = -48						; size = 4
_i2$1$ = -48						; size = 4
_i2$1$ = -48						; size = 4
_i3$1$ = -48						; size = 4
tv5117 = -48						; size = 4
tv5116 = -48						; size = 4
tv4850 = -48						; size = 4
tv4793 = -48						; size = 4
tv4736 = -48						; size = 4
tv4673 = -48						; size = 4
tv4608 = -48						; size = 4
_f4$1$ = -44						; size = 4
_f4$1$ = -44						; size = 4
_f1$1$ = -44						; size = 4
_f3$1$ = -44						; size = 4
_f4$1$ = -44						; size = 4
_i3$1$ = -44						; size = 4
_i1$1$ = -44						; size = 4
_i2$1$ = -44						; size = 4
tv5112 = -44						; size = 4
tv5111 = -44						; size = 4
_i$1$ = -40						; size = 4
_j$1$ = -36						; size = 4
_k$1$ = -32						; size = 4
_f1$1$ = -28						; size = 4
_f2$1$ = -28						; size = 4
_f2$1$ = -28						; size = 4
_f3$1$ = -28						; size = 4
_i1$1$ = -28						; size = 4
_i2$1$ = -28						; size = 4
_i2$1$ = -28						; size = 4
tv5110 = -28						; size = 4
_f3$1$ = -24						; size = 4
_f3$1$ = -24						; size = 4
_i1$1$ = -24						; size = 4
_i2$1$ = -24						; size = 4
_i3$1$ = -24						; size = 4
_i3$1$ = -24						; size = 4
tv5121 = -24						; size = 4
tv5113 = -24						; size = 4
tv5129 = -20						; size = 4
$T4 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_chunk$ = 8						; size = 8
?renderChunk@@YA_NV?$shared_ptr@VChunkBase@@@std@@@Z PROC ; renderChunk, COMDAT

; 6    : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?renderChunk@@YA_NV?$shared_ptr@VChunkBase@@@std@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 54	 sub	 esp, 84			; 00000054H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\mutex

; 43   : 		_Mtx_lockX(&_Mtx);

  0002f	8b 45 08	 mov	 eax, DWORD PTR _chunk$[ebp]
  00032	83 c0 18	 add	 eax, 24			; 00000018H
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 68   : 	return (_Check_C_return(_Mtx_lock(_Mtx)));

  00035	50		 push	 eax
  00036	e8 00 00 00 00	 call	 __Mtx_lock
  0003b	83 c4 04	 add	 esp, 4

; 32   : 	if (_Res != _Thrd_success)

  0003e	85 c0		 test	 eax, eax
  00040	74 09		 je	 SHORT $LN95@renderChun

; 33   : 		_Throw_C_error(_Res);

  00042	50		 push	 eax
  00043	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
  00048	83 c4 04	 add	 esp, 4
$LN95@renderChun:
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp

; 8    : 	if(!chunk->shouldRender() || !chunk->isRenderUpdateNeeded() || chunk->isUnloaded())

  0004b	8b 4d 08	 mov	 ecx, DWORD PTR _chunk$[ebp]
  0004e	8b 01		 mov	 eax, DWORD PTR [ecx]
  00050	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  00053	ff d0		 call	 eax
  00055	8b 4d 08	 mov	 ecx, DWORD PTR _chunk$[ebp]
  00058	83 cf ff	 or	 edi, -1
  0005b	84 c0		 test	 al, al
  0005d	0f 84 65 1a 00
	00		 je	 $LN75@renderChun
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp

; 90   : 	return renderUpdateNeeded;

  00063	8a 41 04	 mov	 al, BYTE PTR [ecx+4]
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp

; 8    : 	if(!chunk->shouldRender() || !chunk->isRenderUpdateNeeded() || chunk->isUnloaded())

  00066	84 c0		 test	 al, al
  00068	0f 84 5a 1a 00
	00		 je	 $LN75@renderChun
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp

; 75   : 	return unloaded;

  0006e	8a 41 06	 mov	 al, BYTE PTR [ecx+6]
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp

; 8    : 	if(!chunk->shouldRender() || !chunk->isRenderUpdateNeeded() || chunk->isUnloaded())

  00071	84 c0		 test	 al, al
  00073	0f 85 4f 1a 00
	00		 jne	 $LN75@renderChun
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp

; 85   : 	renderUpdateNeeded = flag;

  00079	88 41 04	 mov	 BYTE PTR [ecx+4], al
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\mutex

; 53   : 		_Mtx_unlockX(&_Mtx);

  0007c	8b 45 08	 mov	 eax, DWORD PTR _chunk$[ebp]
  0007f	83 c0 18	 add	 eax, 24			; 00000018H
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 83   : 	return (_Check_C_return(_Mtx_unlock(_Mtx)));

  00082	50		 push	 eax
  00083	e8 00 00 00 00	 call	 __Mtx_unlock
  00088	83 c4 04	 add	 esp, 4

; 32   : 	if (_Res != _Thrd_success)

  0008b	85 c0		 test	 eax, eax
  0008d	74 09		 je	 SHORT $LN139@renderChun

; 33   : 		_Throw_C_error(_Res);

  0008f	50		 push	 eax
  00090	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
  00095	83 c4 04	 add	 esp, 4
$LN139@renderChun:
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp

; 16   : 	for(int i = -1; i < 2; i++)

  00098	83 ca ff	 or	 edx, -1
  0009b	89 55 c0	 mov	 DWORD PTR _i$1$[ebp], edx
  0009e	8b ff		 npad	 2
$LL74@renderChun:

; 17   : 	{
; 18   : 		for(int j = -1; j < 2; j++)

  000a0	83 cb ff	 or	 ebx, -1
$LL71@renderChun:

; 20   : 			for(int k = -1; k < 2; k++)

  000a3	83 cf ff	 or	 edi, -1
$LL68@renderChun:

; 21   : 			{
; 22   : 				std::shared_ptr<ChunkBase> c = GlobalThread::world.getChunk(chunk->pos.x + i, chunk->pos.y + j, chunk->pos.z + k);

  000a6	8b 4d 08	 mov	 ecx, DWORD PTR _chunk$[ebp]
  000a9	8b 41 14	 mov	 eax, DWORD PTR [ecx+20]
  000ac	03 c7		 add	 eax, edi
  000ae	50		 push	 eax
  000af	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  000b2	03 c3		 add	 eax, ebx
  000b4	50		 push	 eax
  000b5	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  000b8	03 c2		 add	 eax, edx
  000ba	50		 push	 eax
  000bb	8d 45 a0	 lea	 eax, DWORD PTR _c$2[ebp]
  000be	50		 push	 eax
  000bf	b9 00 00 00 00	 mov	 ecx, OFFSET ?world@GlobalThread@@3VWorld@@A ; GlobalThread::world
  000c4	e8 00 00 00 00	 call	 ?getChunk@World@@QAE?AV?$shared_ptr@VChunkBase@@@std@@HHH@Z ; World::getChunk
  000c9	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1

; 23   : 				if(!c->isEmpty() && !c->isLoaded())

  000cd	8b 75 a0	 mov	 esi, DWORD PTR _c$2[ebp]
  000d0	8b ce		 mov	 ecx, esi
  000d2	8b 06		 mov	 eax, DWORD PTR [esi]
  000d4	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  000d7	ff d0		 call	 eax
  000d9	84 c0		 test	 al, al
  000db	75 07		 jne	 SHORT $LN65@renderChun
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp

; 65   : 	return loaded;

  000dd	8a 46 05	 mov	 al, BYTE PTR [esi+5]
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp

; 23   : 				if(!c->isEmpty() && !c->isLoaded())

  000e0	84 c0		 test	 al, al
  000e2	74 6e		 je	 SHORT $LN693@renderChun
$LN65@renderChun:

; 26   : 				}
; 27   : 			}

  000e4	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  000e8	8b 75 a4	 mov	 esi, DWORD PTR _c$2[ebp+4]
  000eb	85 f6		 test	 esi, esi
  000ed	74 25		 je	 SHORT $LN67@renderChun

; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  000ef	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  000f2	83 c9 ff	 or	 ecx, -1
  000f5	f0 0f c1 08	 lock	  xadd	 DWORD PTR [eax], ecx
  000f9	75 19		 jne	 SHORT $LN67@renderChun

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  000fb	8b 06		 mov	 eax, DWORD PTR [esi]
  000fd	8b ce		 mov	 ecx, esi
  000ff	ff 10		 call	 DWORD PTR [eax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  00101	8d 46 08	 lea	 eax, DWORD PTR [esi+8]
  00104	83 ca ff	 or	 edx, -1
  00107	f0 0f c1 10	 lock	  xadd	 DWORD PTR [eax], edx
  0010b	75 07		 jne	 SHORT $LN67@renderChun

; 128  : 			_Delete_this();

  0010d	8b 06		 mov	 eax, DWORD PTR [esi]
  0010f	8b ce		 mov	 ecx, esi
  00111	ff 50 04	 call	 DWORD PTR [eax+4]
$LN67@renderChun:
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp

; 20   : 			for(int k = -1; k < 2; k++)

  00114	8b 55 c0	 mov	 edx, DWORD PTR _i$1$[ebp]
  00117	47		 inc	 edi
  00118	83 ff 02	 cmp	 edi, 2
  0011b	7c 89		 jl	 SHORT $LL68@renderChun

; 17   : 	{
; 18   : 		for(int j = -1; j < 2; j++)

  0011d	43		 inc	 ebx
  0011e	83 fb 02	 cmp	 ebx, 2
  00121	7c 80		 jl	 SHORT $LL71@renderChun

; 16   : 	for(int i = -1; i < 2; i++)

  00123	42		 inc	 edx
  00124	89 55 c0	 mov	 DWORD PTR _i$1$[ebp], edx
  00127	83 fa 02	 cmp	 edx, 2
  0012a	0f 8c 70 ff ff
	ff		 jl	 $LL74@renderChun

; 31   : 	gfxu::VertexStream* vStream = new gfxu::VertexStream(8192);

  00130	6a 38		 push	 56			; 00000038H
  00132	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00137	83 c4 04	 add	 esp, 4
  0013a	89 45 a4	 mov	 DWORD PTR $T3[ebp], eax
  0013d	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  00141	85 c0		 test	 eax, eax
  00143	74 45		 je	 SHORT $LN79@renderChun
  00145	51		 push	 ecx
  00146	8b c8		 mov	 ecx, eax
  00148	e8 00 00 00 00	 call	 ??0VertexStream@gfxu@@QAE@H@Z ; gfxu::VertexStream::VertexStream
  0014d	89 45 f0	 mov	 DWORD PTR $T4[ebp], eax
  00150	eb 3d		 jmp	 SHORT $LN80@renderChun
$LN693@renderChun:

; 24   : 				{
; 25   : 					return false;

  00152	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  00156	8b 75 a4	 mov	 esi, DWORD PTR _c$2[ebp+4]

; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  00159	83 cf ff	 or	 edi, -1

; 345  : 		if (_Rep != 0)

  0015c	85 f6		 test	 esi, esi
  0015e	74 23		 je	 SHORT $LN172@renderChun

; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  00160	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00163	8b cf		 mov	 ecx, edi
  00165	f0 0f c1 08	 lock	  xadd	 DWORD PTR [eax], ecx
  00169	75 18		 jne	 SHORT $LN172@renderChun

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  0016b	8b 06		 mov	 eax, DWORD PTR [esi]
  0016d	8b ce		 mov	 ecx, esi
  0016f	ff 10		 call	 DWORD PTR [eax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  00171	8d 46 08	 lea	 eax, DWORD PTR [esi+8]
  00174	8b d7		 mov	 edx, edi
  00176	f0 0f c1 10	 lock	  xadd	 DWORD PTR [eax], edx
  0017a	75 07		 jne	 SHORT $LN172@renderChun

; 128  : 			_Delete_this();

  0017c	8b 06		 mov	 eax, DWORD PTR [esi]
  0017e	8b ce		 mov	 ecx, esi
  00180	ff 50 04	 call	 DWORD PTR [eax+4]
$LN172@renderChun:
  00183	32 db		 xor	 bl, bl
  00185	e9 59 19 00 00	 jmp	 $LN673@renderChun
$LN79@renderChun:
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp

; 31   : 	gfxu::VertexStream* vStream = new gfxu::VertexStream(8192);

  0018a	33 f6		 xor	 esi, esi
  0018c	89 75 f0	 mov	 DWORD PTR $T4[ebp], esi
$LN80@renderChun:
  0018f	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0

; 32   : 	int cx = chunk->pos.x * 16;

  00193	8b 45 08	 mov	 eax, DWORD PTR _chunk$[ebp]
  00196	8b 78 0c	 mov	 edi, DWORD PTR [eax+12]

; 33   : 	int cy = chunk->pos.y * 16;

  00199	8b 70 10	 mov	 esi, DWORD PTR [eax+16]

; 34   : 	int cz = chunk->pos.z * 16;

  0019c	8b 50 14	 mov	 edx, DWORD PTR [eax+20]
  0019f	c1 e7 04	 shl	 edi, 4
  001a2	c1 e6 04	 shl	 esi, 4
  001a5	c1 e2 04	 shl	 edx, 4

; 35   : 				
; 36   : 	for(unsigned int i = 0; i < 16; i++)

  001a8	33 c0		 xor	 eax, eax
  001aa	89 7d a4	 mov	 DWORD PTR _cx$1$[ebp], edi
  001ad	89 75 ac	 mov	 DWORD PTR _cy$1$[ebp], esi
  001b0	89 55 b8	 mov	 DWORD PTR _cz$1$[ebp], edx
  001b3	89 45 d8	 mov	 DWORD PTR _i$1$[ebp], eax
$LL64@renderChun:

; 37   : 	{
; 38   : 		for(unsigned int j = 0; j < 16; j++)

  001b6	33 c9		 xor	 ecx, ecx
  001b8	8b d8		 mov	 ebx, eax
  001ba	0b df		 or	 ebx, edi
  001bc	89 4d dc	 mov	 DWORD PTR _j$1$[ebp], ecx
  001bf	89 5d c4	 mov	 DWORD PTR tv5127[ebp], ebx
$LL61@renderChun:

; 40   : 			for(unsigned int k = 0; k < 16; k++)

  001c2	33 c0		 xor	 eax, eax
  001c4	8b f9		 mov	 edi, ecx
  001c6	0b fe		 or	 edi, esi
  001c8	89 45 e0	 mov	 DWORD PTR _k$1$[ebp], eax
  001cb	89 7d c0	 mov	 DWORD PTR tv5128[ebp], edi
  001ce	8b ff		 npad	 2
$LL58@renderChun:

; 41   : 			{
; 42   : 				if(GlobalThread::world.getBlock(i | cx, j | cy, k | cz))

  001d0	8b f0		 mov	 esi, eax
  001d2	0b f2		 or	 esi, edx
  001d4	56		 push	 esi
  001d5	57		 push	 edi
  001d6	53		 push	 ebx
  001d7	89 75 ec	 mov	 DWORD PTR tv5129[ebp], esi
  001da	e8 00 00 00 00	 call	 ?getBlock@World@@QAEGHHH@Z ; World::getBlock
  001df	66 85 c0	 test	 ax, ax
  001e2	0f 84 84 17 00
	00		 je	 $LN57@renderChun

; 43   : 				{
; 44   : 					if(!GlobalThread::world.getBlock(i | cx, j | cy, (k | cz) - 1))

  001e8	4e		 dec	 esi
  001e9	56		 push	 esi
  001ea	57		 push	 edi
  001eb	53		 push	 ebx
  001ec	e8 00 00 00 00	 call	 ?getBlock@World@@QAEGHHH@Z ; World::getBlock
  001f1	66 85 c0	 test	 ax, ax
  001f4	0f 85 c6 03 00
	00		 jne	 $LN256@renderChun

; 45   : 					{
; 46   : 						int i1 = 0;

  001fa	33 c0		 xor	 eax, eax

; 47   : 						int i2 = 0;
; 48   : 						int i3 = 0;
; 49   : 						int i4 = 0;
; 50   : 
; 51   : 						if(GlobalThread::world.getBlock((i | cx) - 1, j | cy, (k | cz) - 1))

  001fc	56		 push	 esi
  001fd	89 45 c8	 mov	 DWORD PTR _i1$1$[ebp], eax
  00200	89 45 e4	 mov	 DWORD PTR _i2$1$[ebp], eax
  00203	89 45 e8	 mov	 DWORD PTR _i3$1$[ebp], eax
  00206	89 45 bc	 mov	 DWORD PTR _i4$1$[ebp], eax
  00209	8d 43 ff	 lea	 eax, DWORD PTR [ebx-1]
  0020c	57		 push	 edi
  0020d	50		 push	 eax
  0020e	89 45 b4	 mov	 DWORD PTR tv5125[ebp], eax
  00211	e8 00 00 00 00	 call	 ?getBlock@World@@QAEGHHH@Z ; World::getBlock
  00216	66 85 c0	 test	 ax, ax
  00219	74 0e		 je	 SHORT $LN53@renderChun

; 52   : 						{
; 53   : 							i1++;

  0021b	c7 45 c8 01 00
	00 00		 mov	 DWORD PTR _i1$1$[ebp], 1

; 54   : 							i4++;

  00222	c7 45 bc 01 00
	00 00		 mov	 DWORD PTR _i4$1$[ebp], 1
$LN53@renderChun:

; 55   : 						}
; 56   : 
; 57   : 						if(GlobalThread::world.getBlock(i | cx, (j | cy) - 1, (k | cz) - 1))

  00229	8d 47 ff	 lea	 eax, DWORD PTR [edi-1]
  0022c	56		 push	 esi
  0022d	50		 push	 eax
  0022e	53		 push	 ebx
  0022f	89 45 cc	 mov	 DWORD PTR tv5120[ebp], eax
  00232	e8 00 00 00 00	 call	 ?getBlock@World@@QAEGHHH@Z ; World::getBlock
  00237	66 85 c0	 test	 ax, ax
  0023a	74 0a		 je	 SHORT $LN52@renderChun

; 58   : 						{
; 59   : 							i1++;

  0023c	ff 45 c8	 inc	 DWORD PTR _i1$1$[ebp]

; 60   : 							i2++;

  0023f	c7 45 e4 01 00
	00 00		 mov	 DWORD PTR _i2$1$[ebp], 1
$LN52@renderChun:

; 61   : 						}
; 62   : 
; 63   : 						if(GlobalThread::world.getBlock((i | cx) + 1, j | cy, (k | cz) - 1))

  00246	56		 push	 esi
  00247	8d 43 01	 lea	 eax, DWORD PTR [ebx+1]
  0024a	57		 push	 edi
  0024b	50		 push	 eax
  0024c	89 45 d0	 mov	 DWORD PTR tv5117[ebp], eax
  0024f	e8 00 00 00 00	 call	 ?getBlock@World@@QAEGHHH@Z ; World::getBlock
  00254	66 85 c0	 test	 ax, ax
  00257	74 0a		 je	 SHORT $LN51@renderChun

; 64   : 						{
; 65   : 							i2++;

  00259	ff 45 e4	 inc	 DWORD PTR _i2$1$[ebp]

; 66   : 							i3++;

  0025c	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR _i3$1$[ebp], 1
$LN51@renderChun:

; 67   : 						}
; 68   : 
; 69   : 						if(GlobalThread::world.getBlock(i | cx, (j | cy) + 1, (k | cz) - 1))

  00263	8d 47 01	 lea	 eax, DWORD PTR [edi+1]
  00266	56		 push	 esi
  00267	50		 push	 eax
  00268	53		 push	 ebx
  00269	89 45 d4	 mov	 DWORD PTR tv5112[ebp], eax
  0026c	e8 00 00 00 00	 call	 ?getBlock@World@@QAEGHHH@Z ; World::getBlock

; 70   : 						{
; 71   : 							i3++;
; 72   : 							i4++;

  00271	8b 5d bc	 mov	 ebx, DWORD PTR _i4$1$[ebp]
  00274	66 85 c0	 test	 ax, ax
  00277	74 04		 je	 SHORT $LN50@renderChun
  00279	ff 45 e8	 inc	 DWORD PTR _i3$1$[ebp]
  0027c	43		 inc	 ebx
$LN50@renderChun:

; 73   : 						}
; 74   : 
; 75   : 						if(i1 < 2 && GlobalThread::world.getBlock((i | cx) - 1, (j | cy) - 1, (k | cz) - 1))

  0027d	8b 7d c8	 mov	 edi, DWORD PTR _i1$1$[ebp]
  00280	83 ff 02	 cmp	 edi, 2
  00283	7d 12		 jge	 SHORT $LN49@renderChun
  00285	56		 push	 esi
  00286	ff 75 cc	 push	 DWORD PTR tv5120[ebp]
  00289	ff 75 b4	 push	 DWORD PTR tv5125[ebp]
  0028c	e8 00 00 00 00	 call	 ?getBlock@World@@QAEGHHH@Z ; World::getBlock
  00291	66 85 c0	 test	 ax, ax
  00294	74 01		 je	 SHORT $LN49@renderChun

; 76   : 						{
; 77   : 							i1++;

  00296	47		 inc	 edi
$LN49@renderChun:

; 78   : 						}
; 79   : 
; 80   : 						if(i2 < 2 && GlobalThread::world.getBlock((i | cx) + 1, (j | cy) - 1, (k | cz) - 1))

  00297	83 7d e4 02	 cmp	 DWORD PTR _i2$1$[ebp], 2
  0029b	7d 14		 jge	 SHORT $LN48@renderChun
  0029d	56		 push	 esi
  0029e	ff 75 cc	 push	 DWORD PTR tv5120[ebp]
  002a1	ff 75 d0	 push	 DWORD PTR tv5117[ebp]
  002a4	e8 00 00 00 00	 call	 ?getBlock@World@@QAEGHHH@Z ; World::getBlock
  002a9	66 85 c0	 test	 ax, ax
  002ac	74 03		 je	 SHORT $LN48@renderChun

; 81   : 						{
; 82   : 							i2++;

  002ae	ff 45 e4	 inc	 DWORD PTR _i2$1$[ebp]
$LN48@renderChun:

; 83   : 						}
; 84   : 								
; 85   : 						if(i3 < 2 && GlobalThread::world.getBlock((i | cx) + 1, (j | cy) + 1, (k | cz) - 1))

  002b1	83 7d e8 02	 cmp	 DWORD PTR _i3$1$[ebp], 2
  002b5	7d 14		 jge	 SHORT $LN47@renderChun
  002b7	56		 push	 esi
  002b8	ff 75 d4	 push	 DWORD PTR tv5112[ebp]
  002bb	ff 75 d0	 push	 DWORD PTR tv5117[ebp]
  002be	e8 00 00 00 00	 call	 ?getBlock@World@@QAEGHHH@Z ; World::getBlock
  002c3	66 85 c0	 test	 ax, ax
  002c6	74 03		 je	 SHORT $LN47@renderChun

; 86   : 						{
; 87   : 							i3++;

  002c8	ff 45 e8	 inc	 DWORD PTR _i3$1$[ebp]
$LN47@renderChun:

; 88   : 						}
; 89   : 								
; 90   : 						if(i4 < 2 && GlobalThread::world.getBlock((i | cx) - 1, (j | cy) + 1, (k | cz) - 1))

  002cb	83 fb 02	 cmp	 ebx, 2
  002ce	7d 12		 jge	 SHORT $LN46@renderChun
  002d0	56		 push	 esi
  002d1	ff 75 d4	 push	 DWORD PTR tv5112[ebp]
  002d4	ff 75 b4	 push	 DWORD PTR tv5125[ebp]
  002d7	e8 00 00 00 00	 call	 ?getBlock@World@@QAEGHHH@Z ; World::getBlock
  002dc	66 85 c0	 test	 ax, ax
  002df	74 01		 je	 SHORT $LN46@renderChun

; 91   : 						{
; 92   : 							i4++;

  002e1	43		 inc	 ebx
$LN46@renderChun:

; 93   : 						}
; 94   : 
; 95   : 						float f1 = 1.0F - i1 * 0.1f;

  002e2	f3 0f 10 25 00
	00 00 00	 movss	 xmm4, DWORD PTR __real@3dcccccd
  002ea	f3 0f 10 1d 00
	00 00 00	 movss	 xmm3, DWORD PTR __real@3f800000
  002f2	66 0f 6e c7	 movd	 xmm0, edi
  002f6	0f 5b c0	 cvtdq2ps xmm0, xmm0
  002f9	0f 28 cb	 movaps	 xmm1, xmm3
  002fc	f3 0f 59 c4	 mulss	 xmm0, xmm4

; 96   : 						float f2 = 1.0F - i2 * 0.1f;

  00300	0f 28 d3	 movaps	 xmm2, xmm3

; 100  : 						vStream->put(gfxu::VertexUVRGBA(i + 0.0f, j + 0.0f, k + 0.0f, 0.0f, 0.0f, f1, f1, f1, 1.0f));

  00303	8b 45 d8	 mov	 eax, DWORD PTR _i$1$[ebp]
  00306	f3 0f 5c c8	 subss	 xmm1, xmm0
  0030a	66 0f 6e 45 e4	 movd	 xmm0, DWORD PTR _i2$1$[ebp]
  0030f	0f 5b c0	 cvtdq2ps xmm0, xmm0
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp

; 70   : {}

  00312	f3 0f 59 0d 00
	00 00 00	 mulss	 xmm1, DWORD PTR __real@437f0000
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp

; 96   : 						float f2 = 1.0F - i2 * 0.1f;

  0031a	f3 0f 59 c4	 mulss	 xmm0, xmm4
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp

; 162  : 	vertex.u = u;

  0031e	8b 4d f0	 mov	 ecx, DWORD PTR $T4[ebp]
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp

; 96   : 						float f2 = 1.0F - i2 * 0.1f;

  00321	f3 0f 5c d0	 subss	 xmm2, xmm0
  00325	66 0f 6e 45 e8	 movd	 xmm0, DWORD PTR _i3$1$[ebp]

; 97   : 						float f3 = 1.0F - i3 * 0.1f;

  0032a	0f 5b c0	 cvtdq2ps xmm0, xmm0
  0032d	f3 0f 11 55 b0	 movss	 DWORD PTR _f2$1$[ebp], xmm2
  00332	f3 0f 59 c4	 mulss	 xmm0, xmm4
  00336	0f 28 d3	 movaps	 xmm2, xmm3
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp

; 108  : 	vertex.x = x;

  00339	8d 79 10	 lea	 edi, DWORD PTR [ecx+16]
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp

; 97   : 						float f3 = 1.0F - i3 * 0.1f;

  0033c	f3 0f 5c d0	 subss	 xmm2, xmm0
  00340	66 0f 6e c3	 movd	 xmm0, ebx

; 98   : 						float f4 = 1.0F - i4 * 0.1f;

  00344	0f 5b c0	 cvtdq2ps xmm0, xmm0
  00347	f3 0f 11 55 e4	 movss	 DWORD PTR _f3$1$[ebp], xmm2
  0034c	f3 0f 59 c4	 mulss	 xmm0, xmm4
  00350	0f 28 d3	 movaps	 xmm2, xmm3
  00353	0f 57 e4	 xorps	 xmm4, xmm4
  00356	f3 0f 5c d0	 subss	 xmm2, xmm0
  0035a	66 0f 6e c0	 movd	 xmm0, eax

; 100  : 						vStream->put(gfxu::VertexUVRGBA(i + 0.0f, j + 0.0f, k + 0.0f, 0.0f, 0.0f, f1, f1, f1, 1.0f));

  0035e	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  00362	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00365	f3 0f 11 55 d4	 movss	 DWORD PTR _f4$1$[ebp], xmm2
  0036a	f2 0f 58 04 c5
	00 00 00 00	 addsd	 xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
  00373	8b 45 dc	 mov	 eax, DWORD PTR _j$1$[ebp]
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp

; 112  : 	vertices.push_back(vertex);

  00376	8d 71 04	 lea	 esi, DWORD PTR [ecx+4]

; 162  : 	vertex.u = u;

  00379	c7 41 1c 00 00
	00 00		 mov	 DWORD PTR [ecx+28], 0

; 163  : 	vertex.v = v;

  00380	c7 41 20 00 00
	00 00		 mov	 DWORD PTR [ecx+32], 0
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp

; 100  : 						vStream->put(gfxu::VertexUVRGBA(i + 0.0f, j + 0.0f, k + 0.0f, 0.0f, 0.0f, f1, f1, f1, 1.0f));

  00387	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp

; 112  : 	vertices.push_back(vertex);

  0038b	57		 push	 edi
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp

; 100  : 						vStream->put(gfxu::VertexUVRGBA(i + 0.0f, j + 0.0f, k + 0.0f, 0.0f, 0.0f, f1, f1, f1, 1.0f));

  0038c	0f 28 d8	 movaps	 xmm3, xmm0
  0038f	f3 0f 11 45 cc	 movss	 DWORD PTR tv4604[ebp], xmm0
  00394	66 0f 6e c0	 movd	 xmm0, eax
  00398	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  0039c	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0039f	f3 0f 58 dc	 addss	 xmm3, xmm4
  003a3	f2 0f 58 04 c5
	00 00 00 00	 addsd	 xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
  003ac	8b 45 e0	 mov	 eax, DWORD PTR _k$1$[ebp]
  003af	f3 0f 11 5d bc	 movss	 DWORD PTR tv4607[ebp], xmm3
  003b4	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp

; 108  : 	vertex.x = x;

  003b8	f3 0f 11 1f	 movss	 DWORD PTR [edi], xmm3
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp

; 100  : 						vStream->put(gfxu::VertexUVRGBA(i + 0.0f, j + 0.0f, k + 0.0f, 0.0f, 0.0f, f1, f1, f1, 1.0f));

  003bc	0f 28 d0	 movaps	 xmm2, xmm0
  003bf	f3 0f 11 45 d0	 movss	 DWORD PTR tv4608[ebp], xmm0
  003c4	66 0f 6e c0	 movd	 xmm0, eax
  003c8	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  003cc	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  003cf	f3 0f 58 d4	 addss	 xmm2, xmm4
  003d3	f2 0f 58 04 c5
	00 00 00 00	 addsd	 xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp

; 70   : {}

  003dc	f3 0f 2c c1	 cvttss2si eax, xmm1
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp

; 100  : 						vStream->put(gfxu::VertexUVRGBA(i + 0.0f, j + 0.0f, k + 0.0f, 0.0f, 0.0f, f1, f1, f1, 1.0f));

  003e0	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp

; 156  : 	vertex.r = r;

  003e4	88 41 24	 mov	 BYTE PTR [ecx+36], al
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp

; 100  : 						vStream->put(gfxu::VertexUVRGBA(i + 0.0f, j + 0.0f, k + 0.0f, 0.0f, 0.0f, f1, f1, f1, 1.0f));

  003e7	f3 0f 58 c4	 addss	 xmm0, xmm4
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp

; 157  : 	vertex.g = g;

  003eb	88 41 25	 mov	 BYTE PTR [ecx+37], al

; 158  : 	vertex.b = b;

  003ee	88 41 26	 mov	 BYTE PTR [ecx+38], al

; 109  : 	vertex.y = y;

  003f1	f3 0f 11 51 14	 movss	 DWORD PTR [ecx+20], xmm2
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp

; 100  : 						vStream->put(gfxu::VertexUVRGBA(i + 0.0f, j + 0.0f, k + 0.0f, 0.0f, 0.0f, f1, f1, f1, 1.0f));

  003f6	f3 0f 11 55 b4	 movss	 DWORD PTR tv4599[ebp], xmm2
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp

; 110  : 	vertex.z = z;

  003fb	f3 0f 11 41 18	 movss	 DWORD PTR [ecx+24], xmm0

; 112  : 	vertices.push_back(vertex);

  00400	8b ce		 mov	 ecx, esi
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp

; 100  : 						vStream->put(gfxu::VertexUVRGBA(i + 0.0f, j + 0.0f, k + 0.0f, 0.0f, 0.0f, f1, f1, f1, 1.0f));

  00402	f3 0f 11 45 c8	 movss	 DWORD PTR tv4609[ebp], xmm0
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp

; 112  : 	vertices.push_back(vertex);

  00407	e8 00 00 00 00	 call	 ?push_back@?$vector@VVertexUVRGBA@gfxu@@V?$allocator@VVertexUVRGBA@gfxu@@@std@@@std@@QAEXABVVertexUVRGBA@gfxu@@@Z ; std::vector<gfxu::VertexUVRGBA,std::allocator<gfxu::VertexUVRGBA> >::push_back

; 70   : {}

  0040c	f3 0f 10 45 b0	 movss	 xmm0, DWORD PTR _f2$1$[ebp]
  00411	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp

; 101  : 						vStream->put(gfxu::VertexUVRGBA(i + 1.0f, j + 0.0f, k + 0.0f, 1.0f, 0.0f, f2, f2, f2, 1.0f));

  00419	f3 0f 10 4d cc	 movss	 xmm1, DWORD PTR tv4604[ebp]
  0041e	f3 0f 58 0d 00
	00 00 00	 addss	 xmm1, DWORD PTR __real@3f800000
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp

; 162  : 	vertex.u = u;

  00426	8b 45 f0	 mov	 eax, DWORD PTR $T4[ebp]

; 114  : 	vs++;

  00429	ff 05 00 00 00
	00		 inc	 DWORD PTR ?vs@@3HA	; vs

; 70   : {}

  0042f	f3 0f 2c d8	 cvttss2si ebx, xmm0
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp

; 101  : 						vStream->put(gfxu::VertexUVRGBA(i + 1.0f, j + 0.0f, k + 0.0f, 1.0f, 0.0f, f2, f2, f2, 1.0f));

  00433	f3 0f 11 4d cc	 movss	 DWORD PTR tv4604[ebp], xmm1
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp

; 162  : 	vertex.u = u;

  00438	c7 40 1c 00 00
	80 3f		 mov	 DWORD PTR [eax+28], 1065353216 ; 3f800000H

; 163  : 	vertex.v = v;

  0043f	c7 40 20 00 00
	00 00		 mov	 DWORD PTR [eax+32], 0

; 156  : 	vertex.r = r;

  00446	88 58 24	 mov	 BYTE PTR [eax+36], bl

; 109  : 	vertex.y = y;

  00449	f3 0f 10 45 b4	 movss	 xmm0, DWORD PTR tv4599[ebp]
  0044e	f3 0f 11 40 14	 movss	 DWORD PTR [eax+20], xmm0

; 110  : 	vertex.z = z;

  00453	f3 0f 10 45 c8	 movss	 xmm0, DWORD PTR tv4609[ebp]

; 112  : 	vertices.push_back(vertex);

  00458	57		 push	 edi
  00459	8b ce		 mov	 ecx, esi

; 157  : 	vertex.g = g;

  0045b	88 58 25	 mov	 BYTE PTR [eax+37], bl

; 158  : 	vertex.b = b;

  0045e	88 58 26	 mov	 BYTE PTR [eax+38], bl

; 108  : 	vertex.x = x;

  00461	f3 0f 11 0f	 movss	 DWORD PTR [edi], xmm1

; 110  : 	vertex.z = z;

  00465	f3 0f 11 40 18	 movss	 DWORD PTR [eax+24], xmm0

; 112  : 	vertices.push_back(vertex);

  0046a	e8 00 00 00 00	 call	 ?push_back@?$vector@VVertexUVRGBA@gfxu@@V?$allocator@VVertexUVRGBA@gfxu@@@std@@@std@@QAEXABVVertexUVRGBA@gfxu@@@Z ; std::vector<gfxu::VertexUVRGBA,std::allocator<gfxu::VertexUVRGBA> >::push_back

; 70   : {}

  0046f	f3 0f 10 45 d4	 movss	 xmm0, DWORD PTR _f4$1$[ebp]
  00474	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp

; 102  : 						vStream->put(gfxu::VertexUVRGBA(i + 0.0f, j + 1.0f, k + 0.0f, 0.0f, 1.0f, f4, f4, f4, 1.0f));

  0047c	f3 0f 10 4d d0	 movss	 xmm1, DWORD PTR tv4608[ebp]
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp

; 162  : 	vertex.u = u;

  00481	8b 4d f0	 mov	 ecx, DWORD PTR $T4[ebp]
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp

; 102  : 						vStream->put(gfxu::VertexUVRGBA(i + 0.0f, j + 1.0f, k + 0.0f, 0.0f, 1.0f, f4, f4, f4, 1.0f));

  00484	f3 0f 58 0d 00
	00 00 00	 addss	 xmm1, DWORD PTR __real@3f800000
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp

; 114  : 	vs++;

  0048c	ff 05 00 00 00
	00		 inc	 DWORD PTR ?vs@@3HA	; vs

; 70   : {}

  00492	f3 0f 2c c0	 cvttss2si eax, xmm0

; 108  : 	vertex.x = x;

  00496	f3 0f 10 45 bc	 movss	 xmm0, DWORD PTR tv4607[ebp]
  0049b	f3 0f 11 07	 movss	 DWORD PTR [edi], xmm0

; 110  : 	vertex.z = z;

  0049f	f3 0f 10 45 c8	 movss	 xmm0, DWORD PTR tv4609[ebp]

; 162  : 	vertex.u = u;

  004a4	c7 41 1c 00 00
	00 00		 mov	 DWORD PTR [ecx+28], 0

; 163  : 	vertex.v = v;

  004ab	c7 41 20 00 00
	80 3f		 mov	 DWORD PTR [ecx+32], 1065353216 ; 3f800000H

; 156  : 	vertex.r = r;

  004b2	88 41 24	 mov	 BYTE PTR [ecx+36], al

; 157  : 	vertex.g = g;

  004b5	88 41 25	 mov	 BYTE PTR [ecx+37], al

; 158  : 	vertex.b = b;

  004b8	88 41 26	 mov	 BYTE PTR [ecx+38], al

; 109  : 	vertex.y = y;

  004bb	f3 0f 11 49 14	 movss	 DWORD PTR [ecx+20], xmm1

; 110  : 	vertex.z = z;

  004c0	f3 0f 11 41 18	 movss	 DWORD PTR [ecx+24], xmm0

; 112  : 	vertices.push_back(vertex);

  004c5	57		 push	 edi
  004c6	8b ce		 mov	 ecx, esi
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp

; 102  : 						vStream->put(gfxu::VertexUVRGBA(i + 0.0f, j + 1.0f, k + 0.0f, 0.0f, 1.0f, f4, f4, f4, 1.0f));

  004c8	f3 0f 11 4d d0	 movss	 DWORD PTR tv4608[ebp], xmm1
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp

; 70   : {}

  004cd	89 45 b0	 mov	 DWORD PTR tv4594[ebp], eax

; 112  : 	vertices.push_back(vertex);

  004d0	e8 00 00 00 00	 call	 ?push_back@?$vector@VVertexUVRGBA@gfxu@@V?$allocator@VVertexUVRGBA@gfxu@@@std@@@std@@QAEXABVVertexUVRGBA@gfxu@@@Z ; std::vector<gfxu::VertexUVRGBA,std::allocator<gfxu::VertexUVRGBA> >::push_back

; 162  : 	vertex.u = u;

  004d5	8b 45 f0	 mov	 eax, DWORD PTR $T4[ebp]

; 108  : 	vertex.x = x;

  004d8	f3 0f 10 45 cc	 movss	 xmm0, DWORD PTR tv4604[ebp]

; 114  : 	vs++;

  004dd	ff 05 00 00 00
	00		 inc	 DWORD PTR ?vs@@3HA	; vs

; 156  : 	vertex.r = r;

  004e3	88 58 24	 mov	 BYTE PTR [eax+36], bl

; 157  : 	vertex.g = g;

  004e6	88 58 25	 mov	 BYTE PTR [eax+37], bl

; 158  : 	vertex.b = b;

  004e9	88 58 26	 mov	 BYTE PTR [eax+38], bl

; 108  : 	vertex.x = x;

  004ec	f3 0f 11 07	 movss	 DWORD PTR [edi], xmm0

; 109  : 	vertex.y = y;

  004f0	f3 0f 10 45 b4	 movss	 xmm0, DWORD PTR tv4599[ebp]
  004f5	8b d8		 mov	 ebx, eax

; 112  : 	vertices.push_back(vertex);

  004f7	57		 push	 edi
  004f8	f3 0f 11 43 14	 movss	 DWORD PTR [ebx+20], xmm0
  004fd	f3 0f 10 45 c8	 movss	 xmm0, DWORD PTR tv4609[ebp]
  00502	8b ce		 mov	 ecx, esi

; 162  : 	vertex.u = u;

  00504	c7 40 1c 00 00
	80 3f		 mov	 DWORD PTR [eax+28], 1065353216 ; 3f800000H

; 163  : 	vertex.v = v;

  0050b	c7 40 20 00 00
	00 00		 mov	 DWORD PTR [eax+32], 0

; 110  : 	vertex.z = z;

  00512	f3 0f 11 43 18	 movss	 DWORD PTR [ebx+24], xmm0

; 112  : 	vertices.push_back(vertex);

  00517	e8 00 00 00 00	 call	 ?push_back@?$vector@VVertexUVRGBA@gfxu@@V?$allocator@VVertexUVRGBA@gfxu@@@std@@@std@@QAEXABVVertexUVRGBA@gfxu@@@Z ; std::vector<gfxu::VertexUVRGBA,std::allocator<gfxu::VertexUVRGBA> >::push_back

; 70   : {}

  0051c	f3 0f 10 45 e4	 movss	 xmm0, DWORD PTR _f3$1$[ebp]
  00521	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000

; 114  : 	vs++;

  00529	ff 05 00 00 00
	00		 inc	 DWORD PTR ?vs@@3HA	; vs

; 112  : 	vertices.push_back(vertex);

  0052f	57		 push	 edi

; 70   : {}

  00530	f3 0f 2c c0	 cvttss2si eax, xmm0

; 108  : 	vertex.x = x;

  00534	f3 0f 10 45 cc	 movss	 xmm0, DWORD PTR tv4604[ebp]
  00539	f3 0f 11 07	 movss	 DWORD PTR [edi], xmm0

; 109  : 	vertex.y = y;

  0053d	f3 0f 10 45 d0	 movss	 xmm0, DWORD PTR tv4608[ebp]
  00542	f3 0f 11 43 14	 movss	 DWORD PTR [ebx+20], xmm0

; 110  : 	vertex.z = z;

  00547	f3 0f 10 45 c8	 movss	 xmm0, DWORD PTR tv4609[ebp]

; 112  : 	vertices.push_back(vertex);

  0054c	8b ce		 mov	 ecx, esi

; 162  : 	vertex.u = u;

  0054e	c7 43 1c 00 00
	80 3f		 mov	 DWORD PTR [ebx+28], 1065353216 ; 3f800000H

; 163  : 	vertex.v = v;

  00555	c7 43 20 00 00
	80 3f		 mov	 DWORD PTR [ebx+32], 1065353216 ; 3f800000H

; 156  : 	vertex.r = r;

  0055c	88 43 24	 mov	 BYTE PTR [ebx+36], al

; 157  : 	vertex.g = g;

  0055f	88 43 25	 mov	 BYTE PTR [ebx+37], al

; 158  : 	vertex.b = b;

  00562	88 43 26	 mov	 BYTE PTR [ebx+38], al

; 110  : 	vertex.z = z;

  00565	f3 0f 11 43 18	 movss	 DWORD PTR [ebx+24], xmm0

; 112  : 	vertices.push_back(vertex);

  0056a	e8 00 00 00 00	 call	 ?push_back@?$vector@VVertexUVRGBA@gfxu@@V?$allocator@VVertexUVRGBA@gfxu@@@std@@@std@@QAEXABVVertexUVRGBA@gfxu@@@Z ; std::vector<gfxu::VertexUVRGBA,std::allocator<gfxu::VertexUVRGBA> >::push_back

; 108  : 	vertex.x = x;

  0056f	f3 0f 10 45 bc	 movss	 xmm0, DWORD PTR tv4607[ebp]

; 156  : 	vertex.r = r;

  00574	8b 45 b0	 mov	 eax, DWORD PTR tv4594[ebp]

; 114  : 	vs++;

  00577	ff 05 00 00 00
	00		 inc	 DWORD PTR ?vs@@3HA	; vs

; 108  : 	vertex.x = x;

  0057d	f3 0f 11 07	 movss	 DWORD PTR [edi], xmm0

; 109  : 	vertex.y = y;

  00581	f3 0f 10 45 d0	 movss	 xmm0, DWORD PTR tv4608[ebp]
  00586	f3 0f 11 43 14	 movss	 DWORD PTR [ebx+20], xmm0

; 110  : 	vertex.z = z;

  0058b	f3 0f 10 45 c8	 movss	 xmm0, DWORD PTR tv4609[ebp]

; 162  : 	vertex.u = u;

  00590	c7 43 1c 00 00
	00 00		 mov	 DWORD PTR [ebx+28], 0

; 163  : 	vertex.v = v;

  00597	c7 43 20 00 00
	80 3f		 mov	 DWORD PTR [ebx+32], 1065353216 ; 3f800000H

; 156  : 	vertex.r = r;

  0059e	88 43 24	 mov	 BYTE PTR [ebx+36], al

; 157  : 	vertex.g = g;

  005a1	88 43 25	 mov	 BYTE PTR [ebx+37], al

; 158  : 	vertex.b = b;

  005a4	88 43 26	 mov	 BYTE PTR [ebx+38], al

; 110  : 	vertex.z = z;

  005a7	f3 0f 11 43 18	 movss	 DWORD PTR [ebx+24], xmm0

; 112  : 	vertices.push_back(vertex);

  005ac	57		 push	 edi
  005ad	8b ce		 mov	 ecx, esi
  005af	e8 00 00 00 00	 call	 ?push_back@?$vector@VVertexUVRGBA@gfxu@@V?$allocator@VVertexUVRGBA@gfxu@@@std@@@std@@QAEXABVVertexUVRGBA@gfxu@@@Z ; std::vector<gfxu::VertexUVRGBA,std::allocator<gfxu::VertexUVRGBA> >::push_back

; 114  : 	vs++;

  005b4	ff 05 00 00 00
	00		 inc	 DWORD PTR ?vs@@3HA	; vs
  005ba	8b 5d c4	 mov	 ebx, DWORD PTR tv5127[ebp]
  005bd	8b 7d c0	 mov	 edi, DWORD PTR tv5128[ebp]
$LN256@renderChun:
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp

; 108  : 					if(!GlobalThread::world.getBlock(i | cx, j | cy, (k | cz) + 1))

  005c0	8b 75 ec	 mov	 esi, DWORD PTR tv5129[ebp]
  005c3	46		 inc	 esi
  005c4	56		 push	 esi
  005c5	57		 push	 edi
  005c6	53		 push	 ebx
  005c7	89 75 bc	 mov	 DWORD PTR tv5105[ebp], esi
  005ca	e8 00 00 00 00	 call	 ?getBlock@World@@QAEGHHH@Z ; World::getBlock
  005cf	66 85 c0	 test	 ax, ax
  005d2	0f 85 ca 03 00
	00		 jne	 $LN316@renderChun

; 109  : 					{
; 110  : 						int i1 = 0;

  005d8	33 c0		 xor	 eax, eax

; 111  : 						int i2 = 0;
; 112  : 						int i3 = 0;
; 113  : 						int i4 = 0;
; 114  : 
; 115  : 						if(GlobalThread::world.getBlock((i | cx) - 1, j | cy, (k | cz) + 1))

  005da	56		 push	 esi
  005db	89 45 c8	 mov	 DWORD PTR _i1$1$[ebp], eax
  005de	89 45 e4	 mov	 DWORD PTR _i2$1$[ebp], eax
  005e1	89 45 e8	 mov	 DWORD PTR _i3$1$[ebp], eax
  005e4	89 45 cc	 mov	 DWORD PTR _i4$1$[ebp], eax
  005e7	8d 43 ff	 lea	 eax, DWORD PTR [ebx-1]
  005ea	57		 push	 edi
  005eb	50		 push	 eax
  005ec	89 45 b0	 mov	 DWORD PTR tv5124[ebp], eax
  005ef	e8 00 00 00 00	 call	 ?getBlock@World@@QAEGHHH@Z ; World::getBlock
  005f4	66 85 c0	 test	 ax, ax
  005f7	74 0e		 je	 SHORT $LN44@renderChun

; 116  : 						{
; 117  : 							i1++;

  005f9	c7 45 c8 01 00
	00 00		 mov	 DWORD PTR _i1$1$[ebp], 1

; 118  : 							i4++;

  00600	c7 45 cc 01 00
	00 00		 mov	 DWORD PTR _i4$1$[ebp], 1
$LN44@renderChun:

; 119  : 						}
; 120  : 
; 121  : 						if(GlobalThread::world.getBlock(i | cx, (j | cy) - 1, (k | cz) + 1))

  00607	8d 47 ff	 lea	 eax, DWORD PTR [edi-1]
  0060a	56		 push	 esi
  0060b	50		 push	 eax
  0060c	53		 push	 ebx
  0060d	89 45 b4	 mov	 DWORD PTR tv5119[ebp], eax
  00610	e8 00 00 00 00	 call	 ?getBlock@World@@QAEGHHH@Z ; World::getBlock
  00615	66 85 c0	 test	 ax, ax
  00618	74 0a		 je	 SHORT $LN43@renderChun

; 122  : 						{
; 123  : 							i1++;

  0061a	ff 45 c8	 inc	 DWORD PTR _i1$1$[ebp]

; 124  : 							i2++;

  0061d	c7 45 e4 01 00
	00 00		 mov	 DWORD PTR _i2$1$[ebp], 1
$LN43@renderChun:

; 125  : 						}
; 126  : 
; 127  : 						if(GlobalThread::world.getBlock((i | cx) + 1, j | cy, (k | cz) + 1))

  00624	56		 push	 esi
  00625	8d 43 01	 lea	 eax, DWORD PTR [ebx+1]
  00628	57		 push	 edi
  00629	50		 push	 eax
  0062a	89 45 d0	 mov	 DWORD PTR tv5116[ebp], eax
  0062d	e8 00 00 00 00	 call	 ?getBlock@World@@QAEGHHH@Z ; World::getBlock
  00632	66 85 c0	 test	 ax, ax
  00635	74 0a		 je	 SHORT $LN42@renderChun

; 128  : 						{
; 129  : 							i2++;

  00637	ff 45 e4	 inc	 DWORD PTR _i2$1$[ebp]

; 130  : 							i3++;

  0063a	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR _i3$1$[ebp], 1
$LN42@renderChun:

; 131  : 						}
; 132  : 
; 133  : 						if(GlobalThread::world.getBlock(i | cx, (j | cy) + 1, (k | cz) + 1))

  00641	8d 47 01	 lea	 eax, DWORD PTR [edi+1]
  00644	56		 push	 esi
  00645	50		 push	 eax
  00646	53		 push	 ebx
  00647	89 45 d4	 mov	 DWORD PTR tv5111[ebp], eax
  0064a	e8 00 00 00 00	 call	 ?getBlock@World@@QAEGHHH@Z ; World::getBlock

; 134  : 						{
; 135  : 							i3++;
; 136  : 							i4++;

  0064f	8b 5d cc	 mov	 ebx, DWORD PTR _i4$1$[ebp]
  00652	66 85 c0	 test	 ax, ax
  00655	74 04		 je	 SHORT $LN41@renderChun
  00657	ff 45 e8	 inc	 DWORD PTR _i3$1$[ebp]
  0065a	43		 inc	 ebx
$LN41@renderChun:

; 137  : 						}
; 138  : 
; 139  : 						if(i1 < 2 && GlobalThread::world.getBlock((i | cx) - 1, (j | cy) - 1, (k | cz) + 1))

  0065b	8b 7d c8	 mov	 edi, DWORD PTR _i1$1$[ebp]
  0065e	83 ff 02	 cmp	 edi, 2
  00661	7d 12		 jge	 SHORT $LN40@renderChun
  00663	56		 push	 esi
  00664	ff 75 b4	 push	 DWORD PTR tv5119[ebp]
  00667	ff 75 b0	 push	 DWORD PTR tv5124[ebp]
  0066a	e8 00 00 00 00	 call	 ?getBlock@World@@QAEGHHH@Z ; World::getBlock
  0066f	66 85 c0	 test	 ax, ax
  00672	74 01		 je	 SHORT $LN40@renderChun

; 140  : 						{
; 141  : 							i1++;

  00674	47		 inc	 edi
$LN40@renderChun:

; 142  : 						}
; 143  : 
; 144  : 						if(i2 < 2 && GlobalThread::world.getBlock((i | cx) + 1, (j | cy) - 1, (k | cz) + 1))

  00675	83 7d e4 02	 cmp	 DWORD PTR _i2$1$[ebp], 2
  00679	7d 14		 jge	 SHORT $LN39@renderChun
  0067b	56		 push	 esi
  0067c	ff 75 b4	 push	 DWORD PTR tv5119[ebp]
  0067f	ff 75 d0	 push	 DWORD PTR tv5116[ebp]
  00682	e8 00 00 00 00	 call	 ?getBlock@World@@QAEGHHH@Z ; World::getBlock
  00687	66 85 c0	 test	 ax, ax
  0068a	74 03		 je	 SHORT $LN39@renderChun

; 145  : 						{
; 146  : 							i2++;

  0068c	ff 45 e4	 inc	 DWORD PTR _i2$1$[ebp]
$LN39@renderChun:

; 147  : 						}
; 148  : 								
; 149  : 						if(i3 < 2 && GlobalThread::world.getBlock((i | cx) + 1, (j | cy) + 1, (k | cz) + 1))

  0068f	83 7d e8 02	 cmp	 DWORD PTR _i3$1$[ebp], 2
  00693	7d 14		 jge	 SHORT $LN38@renderChun
  00695	56		 push	 esi
  00696	ff 75 d4	 push	 DWORD PTR tv5111[ebp]
  00699	ff 75 d0	 push	 DWORD PTR tv5116[ebp]
  0069c	e8 00 00 00 00	 call	 ?getBlock@World@@QAEGHHH@Z ; World::getBlock
  006a1	66 85 c0	 test	 ax, ax
  006a4	74 03		 je	 SHORT $LN38@renderChun

; 150  : 						{
; 151  : 							i3++;

  006a6	ff 45 e8	 inc	 DWORD PTR _i3$1$[ebp]
$LN38@renderChun:

; 152  : 						}
; 153  : 								
; 154  : 						if(i4 < 2 && GlobalThread::world.getBlock((i | cx) - 1, (j | cy) + 1, (k | cz) + 1))

  006a9	83 fb 02	 cmp	 ebx, 2
  006ac	7d 12		 jge	 SHORT $LN37@renderChun
  006ae	56		 push	 esi
  006af	ff 75 d4	 push	 DWORD PTR tv5111[ebp]
  006b2	ff 75 b0	 push	 DWORD PTR tv5124[ebp]
  006b5	e8 00 00 00 00	 call	 ?getBlock@World@@QAEGHHH@Z ; World::getBlock
  006ba	66 85 c0	 test	 ax, ax
  006bd	74 01		 je	 SHORT $LN37@renderChun

; 155  : 						{
; 156  : 							i4++;

  006bf	43		 inc	 ebx
$LN37@renderChun:

; 159  : 						float f1 = 1.0F - i1 * 0.1f;

  006c0	f3 0f 10 15 00
	00 00 00	 movss	 xmm2, DWORD PTR __real@3dcccccd
  006c8	f3 0f 10 25 00
	00 00 00	 movss	 xmm4, DWORD PTR __real@3f800000
  006d0	66 0f 6e c7	 movd	 xmm0, edi
  006d4	0f 5b c0	 cvtdq2ps xmm0, xmm0
  006d7	0f 28 cc	 movaps	 xmm1, xmm4
  006da	f3 0f 59 c2	 mulss	 xmm0, xmm2

; 164  : 						vStream->put(gfxu::VertexUVRGBA(i + 0.0f, j + 1.0f, k + 1.0f, 1.0f, 1.0f, f4, f4, f4, 1.0f));

  006de	8b 45 d8	 mov	 eax, DWORD PTR _i$1$[ebp]
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp

; 162  : 	vertex.u = u;

  006e1	8b 4d f0	 mov	 ecx, DWORD PTR $T4[ebp]
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp

; 159  : 						float f1 = 1.0F - i1 * 0.1f;

  006e4	f3 0f 5c c8	 subss	 xmm1, xmm0
  006e8	66 0f 6e 45 e4	 movd	 xmm0, DWORD PTR _i2$1$[ebp]

; 160  : 						float f2 = 1.0F - i2 * 0.1f;

  006ed	0f 5b c0	 cvtdq2ps xmm0, xmm0
  006f0	f3 0f 11 4d a8	 movss	 DWORD PTR _f1$1$[ebp], xmm1
  006f5	f3 0f 59 c2	 mulss	 xmm0, xmm2
  006f9	0f 28 cc	 movaps	 xmm1, xmm4
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp

; 108  : 	vertex.x = x;

  006fc	8d 79 10	 lea	 edi, DWORD PTR [ecx+16]
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp

; 160  : 						float f2 = 1.0F - i2 * 0.1f;

  006ff	f3 0f 5c c8	 subss	 xmm1, xmm0
  00703	66 0f 6e 45 e8	 movd	 xmm0, DWORD PTR _i3$1$[ebp]

; 161  : 						float f3 = 1.0F - i3 * 0.1f;

  00708	0f 5b c0	 cvtdq2ps xmm0, xmm0
  0070b	f3 0f 11 4d e4	 movss	 DWORD PTR _f2$1$[ebp], xmm1
  00710	f3 0f 59 c2	 mulss	 xmm0, xmm2
  00714	0f 28 cc	 movaps	 xmm1, xmm4
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp

; 112  : 	vertices.push_back(vertex);

  00717	8d 71 04	 lea	 esi, DWORD PTR [ecx+4]
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp

; 161  : 						float f3 = 1.0F - i3 * 0.1f;

  0071a	f3 0f 5c c8	 subss	 xmm1, xmm0
  0071e	66 0f 6e c3	 movd	 xmm0, ebx

; 162  : 						float f4 = 1.0F - i4 * 0.1f;

  00722	0f 5b c0	 cvtdq2ps xmm0, xmm0
  00725	f3 0f 11 4d d4	 movss	 DWORD PTR _f3$1$[ebp], xmm1
  0072a	f3 0f 59 c2	 mulss	 xmm0, xmm2
  0072e	0f 28 cc	 movaps	 xmm1, xmm4
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp

; 162  : 	vertex.u = u;

  00731	c7 41 1c 00 00
	80 3f		 mov	 DWORD PTR [ecx+28], 1065353216 ; 3f800000H
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp

; 162  : 						float f4 = 1.0F - i4 * 0.1f;

  00738	f3 0f 5c c8	 subss	 xmm1, xmm0
  0073c	66 0f 6e c0	 movd	 xmm0, eax

; 164  : 						vStream->put(gfxu::VertexUVRGBA(i + 0.0f, j + 1.0f, k + 1.0f, 1.0f, 1.0f, f4, f4, f4, 1.0f));

  00740	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  00744	c1 e8 1f	 shr	 eax, 31			; 0000001fH
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp

; 70   : {}

  00747	f3 0f 59 0d 00
	00 00 00	 mulss	 xmm1, DWORD PTR __real@437f0000
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp

; 164  : 						vStream->put(gfxu::VertexUVRGBA(i + 0.0f, j + 1.0f, k + 1.0f, 1.0f, 1.0f, f4, f4, f4, 1.0f));

  0074f	f2 0f 58 04 c5
	00 00 00 00	 addsd	 xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
  00758	8b 45 dc	 mov	 eax, DWORD PTR _j$1$[ebp]
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp

; 163  : 	vertex.v = v;

  0075b	c7 41 20 00 00
	80 3f		 mov	 DWORD PTR [ecx+32], 1065353216 ; 3f800000H

; 112  : 	vertices.push_back(vertex);

  00762	57		 push	 edi
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp

; 164  : 						vStream->put(gfxu::VertexUVRGBA(i + 0.0f, j + 1.0f, k + 1.0f, 1.0f, 1.0f, f4, f4, f4, 1.0f));

  00763	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  00767	0f 28 d8	 movaps	 xmm3, xmm0
  0076a	f3 0f 11 45 cc	 movss	 DWORD PTR tv4669[ebp], xmm0
  0076f	66 0f 6e c0	 movd	 xmm0, eax
  00773	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  00777	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0077a	f3 0f 58 1d 00
	00 00 00	 addss	 xmm3, DWORD PTR __real@00000000
  00782	f2 0f 58 04 c5
	00 00 00 00	 addsd	 xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
  0078b	8b 45 e0	 mov	 eax, DWORD PTR _k$1$[ebp]
  0078e	f3 0f 11 5d b4	 movss	 DWORD PTR tv4672[ebp], xmm3
  00793	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp

; 108  : 	vertex.x = x;

  00797	f3 0f 11 1f	 movss	 DWORD PTR [edi], xmm3
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp

; 164  : 						vStream->put(gfxu::VertexUVRGBA(i + 0.0f, j + 1.0f, k + 1.0f, 1.0f, 1.0f, f4, f4, f4, 1.0f));

  0079b	0f 28 d0	 movaps	 xmm2, xmm0
  0079e	f3 0f 11 45 d0	 movss	 DWORD PTR tv4673[ebp], xmm0
  007a3	66 0f 6e c0	 movd	 xmm0, eax
  007a7	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  007ab	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  007ae	f3 0f 58 d4	 addss	 xmm2, xmm4
  007b2	f2 0f 58 04 c5
	00 00 00 00	 addsd	 xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp

; 70   : {}

  007bb	f3 0f 2c c1	 cvttss2si eax, xmm1
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp

; 164  : 						vStream->put(gfxu::VertexUVRGBA(i + 0.0f, j + 1.0f, k + 1.0f, 1.0f, 1.0f, f4, f4, f4, 1.0f));

  007bf	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp

; 156  : 	vertex.r = r;

  007c3	88 41 24	 mov	 BYTE PTR [ecx+36], al
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp

; 164  : 						vStream->put(gfxu::VertexUVRGBA(i + 0.0f, j + 1.0f, k + 1.0f, 1.0f, 1.0f, f4, f4, f4, 1.0f));

  007c6	f3 0f 58 c4	 addss	 xmm0, xmm4
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp

; 157  : 	vertex.g = g;

  007ca	88 41 25	 mov	 BYTE PTR [ecx+37], al

; 158  : 	vertex.b = b;

  007cd	88 41 26	 mov	 BYTE PTR [ecx+38], al

; 109  : 	vertex.y = y;

  007d0	f3 0f 11 51 14	 movss	 DWORD PTR [ecx+20], xmm2
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp

; 164  : 						vStream->put(gfxu::VertexUVRGBA(i + 0.0f, j + 1.0f, k + 1.0f, 1.0f, 1.0f, f4, f4, f4, 1.0f));

  007d5	f3 0f 11 55 b0	 movss	 DWORD PTR tv4664[ebp], xmm2
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp

; 110  : 	vertex.z = z;

  007da	f3 0f 11 41 18	 movss	 DWORD PTR [ecx+24], xmm0

; 112  : 	vertices.push_back(vertex);

  007df	8b ce		 mov	 ecx, esi
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp

; 164  : 						vStream->put(gfxu::VertexUVRGBA(i + 0.0f, j + 1.0f, k + 1.0f, 1.0f, 1.0f, f4, f4, f4, 1.0f));

  007e1	f3 0f 11 45 c8	 movss	 DWORD PTR tv4674[ebp], xmm0
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp

; 112  : 	vertices.push_back(vertex);

  007e6	e8 00 00 00 00	 call	 ?push_back@?$vector@VVertexUVRGBA@gfxu@@V?$allocator@VVertexUVRGBA@gfxu@@@std@@@std@@QAEXABVVertexUVRGBA@gfxu@@@Z ; std::vector<gfxu::VertexUVRGBA,std::allocator<gfxu::VertexUVRGBA> >::push_back

; 70   : {}

  007eb	f3 0f 10 45 d4	 movss	 xmm0, DWORD PTR _f3$1$[ebp]
  007f0	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp

; 165  : 						vStream->put(gfxu::VertexUVRGBA(i + 1.0f, j + 1.0f, k + 1.0f, 0.0f, 1.0f, f3, f3, f3, 1.0f));

  007f8	f3 0f 10 4d cc	 movss	 xmm1, DWORD PTR tv4669[ebp]
  007fd	f3 0f 58 0d 00
	00 00 00	 addss	 xmm1, DWORD PTR __real@3f800000
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp

; 162  : 	vertex.u = u;

  00805	8b 45 f0	 mov	 eax, DWORD PTR $T4[ebp]

; 114  : 	vs++;

  00808	ff 05 00 00 00
	00		 inc	 DWORD PTR ?vs@@3HA	; vs

; 70   : {}

  0080e	f3 0f 2c d8	 cvttss2si ebx, xmm0
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp

; 165  : 						vStream->put(gfxu::VertexUVRGBA(i + 1.0f, j + 1.0f, k + 1.0f, 0.0f, 1.0f, f3, f3, f3, 1.0f));

  00812	f3 0f 11 4d cc	 movss	 DWORD PTR tv4669[ebp], xmm1
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp

; 162  : 	vertex.u = u;

  00817	c7 40 1c 00 00
	00 00		 mov	 DWORD PTR [eax+28], 0

; 163  : 	vertex.v = v;

  0081e	c7 40 20 00 00
	80 3f		 mov	 DWORD PTR [eax+32], 1065353216 ; 3f800000H

; 156  : 	vertex.r = r;

  00825	88 58 24	 mov	 BYTE PTR [eax+36], bl

; 157  : 	vertex.g = g;

  00828	88 58 25	 mov	 BYTE PTR [eax+37], bl

; 109  : 	vertex.y = y;

  0082b	f3 0f 10 45 b0	 movss	 xmm0, DWORD PTR tv4664[ebp]
  00830	f3 0f 11 40 14	 movss	 DWORD PTR [eax+20], xmm0

; 110  : 	vertex.z = z;

  00835	f3 0f 10 45 c8	 movss	 xmm0, DWORD PTR tv4674[ebp]

; 112  : 	vertices.push_back(vertex);

  0083a	57		 push	 edi
  0083b	8b ce		 mov	 ecx, esi

; 158  : 	vertex.b = b;

  0083d	88 58 26	 mov	 BYTE PTR [eax+38], bl

; 108  : 	vertex.x = x;

  00840	f3 0f 11 0f	 movss	 DWORD PTR [edi], xmm1

; 110  : 	vertex.z = z;

  00844	f3 0f 11 40 18	 movss	 DWORD PTR [eax+24], xmm0

; 112  : 	vertices.push_back(vertex);

  00849	e8 00 00 00 00	 call	 ?push_back@?$vector@VVertexUVRGBA@gfxu@@V?$allocator@VVertexUVRGBA@gfxu@@@std@@@std@@QAEXABVVertexUVRGBA@gfxu@@@Z ; std::vector<gfxu::VertexUVRGBA,std::allocator<gfxu::VertexUVRGBA> >::push_back

; 70   : {}

  0084e	f3 0f 10 45 a8	 movss	 xmm0, DWORD PTR _f1$1$[ebp]
  00853	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp

; 166  : 						vStream->put(gfxu::VertexUVRGBA(i + 0.0f, j + 0.0f, k + 1.0f, 1.0f, 0.0f, f1, f1, f1, 1.0f));

  0085b	f3 0f 10 4d d0	 movss	 xmm1, DWORD PTR tv4673[ebp]
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp

; 162  : 	vertex.u = u;

  00860	8b 4d f0	 mov	 ecx, DWORD PTR $T4[ebp]
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp

; 166  : 						vStream->put(gfxu::VertexUVRGBA(i + 0.0f, j + 0.0f, k + 1.0f, 1.0f, 0.0f, f1, f1, f1, 1.0f));

  00863	f3 0f 58 0d 00
	00 00 00	 addss	 xmm1, DWORD PTR __real@00000000
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp

; 114  : 	vs++;

  0086b	ff 05 00 00 00
	00		 inc	 DWORD PTR ?vs@@3HA	; vs

; 70   : {}

  00871	f3 0f 2c c0	 cvttss2si eax, xmm0

; 108  : 	vertex.x = x;

  00875	f3 0f 10 45 b4	 movss	 xmm0, DWORD PTR tv4672[ebp]
  0087a	f3 0f 11 07	 movss	 DWORD PTR [edi], xmm0

; 110  : 	vertex.z = z;

  0087e	f3 0f 10 45 c8	 movss	 xmm0, DWORD PTR tv4674[ebp]

; 162  : 	vertex.u = u;

  00883	c7 41 1c 00 00
	80 3f		 mov	 DWORD PTR [ecx+28], 1065353216 ; 3f800000H

; 163  : 	vertex.v = v;

  0088a	c7 41 20 00 00
	00 00		 mov	 DWORD PTR [ecx+32], 0

; 156  : 	vertex.r = r;

  00891	88 41 24	 mov	 BYTE PTR [ecx+36], al

; 157  : 	vertex.g = g;

  00894	88 41 25	 mov	 BYTE PTR [ecx+37], al

; 158  : 	vertex.b = b;

  00897	88 41 26	 mov	 BYTE PTR [ecx+38], al

; 109  : 	vertex.y = y;

  0089a	f3 0f 11 49 14	 movss	 DWORD PTR [ecx+20], xmm1

; 110  : 	vertex.z = z;

  0089f	f3 0f 11 41 18	 movss	 DWORD PTR [ecx+24], xmm0

; 112  : 	vertices.push_back(vertex);

  008a4	57		 push	 edi
  008a5	8b ce		 mov	 ecx, esi
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp

; 166  : 						vStream->put(gfxu::VertexUVRGBA(i + 0.0f, j + 0.0f, k + 1.0f, 1.0f, 0.0f, f1, f1, f1, 1.0f));

  008a7	f3 0f 11 4d d0	 movss	 DWORD PTR tv4673[ebp], xmm1
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp

; 70   : {}

  008ac	89 45 a8	 mov	 DWORD PTR tv4659[ebp], eax

; 112  : 	vertices.push_back(vertex);

  008af	e8 00 00 00 00	 call	 ?push_back@?$vector@VVertexUVRGBA@gfxu@@V?$allocator@VVertexUVRGBA@gfxu@@@std@@@std@@QAEXABVVertexUVRGBA@gfxu@@@Z ; std::vector<gfxu::VertexUVRGBA,std::allocator<gfxu::VertexUVRGBA> >::push_back

; 162  : 	vertex.u = u;

  008b4	8b 45 f0	 mov	 eax, DWORD PTR $T4[ebp]

; 108  : 	vertex.x = x;

  008b7	f3 0f 10 45 cc	 movss	 xmm0, DWORD PTR tv4669[ebp]

; 114  : 	vs++;

  008bc	ff 05 00 00 00
	00		 inc	 DWORD PTR ?vs@@3HA	; vs

; 156  : 	vertex.r = r;

  008c2	88 58 24	 mov	 BYTE PTR [eax+36], bl

; 157  : 	vertex.g = g;

  008c5	88 58 25	 mov	 BYTE PTR [eax+37], bl

; 158  : 	vertex.b = b;

  008c8	88 58 26	 mov	 BYTE PTR [eax+38], bl

; 108  : 	vertex.x = x;

  008cb	f3 0f 11 07	 movss	 DWORD PTR [edi], xmm0

; 109  : 	vertex.y = y;

  008cf	f3 0f 10 45 b0	 movss	 xmm0, DWORD PTR tv4664[ebp]
  008d4	8b d8		 mov	 ebx, eax

; 112  : 	vertices.push_back(vertex);

  008d6	57		 push	 edi
  008d7	f3 0f 11 43 14	 movss	 DWORD PTR [ebx+20], xmm0
  008dc	f3 0f 10 45 c8	 movss	 xmm0, DWORD PTR tv4674[ebp]
  008e1	8b ce		 mov	 ecx, esi

; 162  : 	vertex.u = u;

  008e3	c7 40 1c 00 00
	00 00		 mov	 DWORD PTR [eax+28], 0

; 163  : 	vertex.v = v;

  008ea	c7 40 20 00 00
	80 3f		 mov	 DWORD PTR [eax+32], 1065353216 ; 3f800000H

; 110  : 	vertex.z = z;

  008f1	f3 0f 11 43 18	 movss	 DWORD PTR [ebx+24], xmm0

; 112  : 	vertices.push_back(vertex);

  008f6	e8 00 00 00 00	 call	 ?push_back@?$vector@VVertexUVRGBA@gfxu@@V?$allocator@VVertexUVRGBA@gfxu@@@std@@@std@@QAEXABVVertexUVRGBA@gfxu@@@Z ; std::vector<gfxu::VertexUVRGBA,std::allocator<gfxu::VertexUVRGBA> >::push_back

; 70   : {}

  008fb	f3 0f 10 45 e4	 movss	 xmm0, DWORD PTR _f2$1$[ebp]
  00900	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000

; 114  : 	vs++;

  00908	ff 05 00 00 00
	00		 inc	 DWORD PTR ?vs@@3HA	; vs

; 112  : 	vertices.push_back(vertex);

  0090e	57		 push	 edi

; 70   : {}

  0090f	f3 0f 2c c0	 cvttss2si eax, xmm0

; 108  : 	vertex.x = x;

  00913	f3 0f 10 45 cc	 movss	 xmm0, DWORD PTR tv4669[ebp]
  00918	f3 0f 11 07	 movss	 DWORD PTR [edi], xmm0

; 109  : 	vertex.y = y;

  0091c	f3 0f 10 45 d0	 movss	 xmm0, DWORD PTR tv4673[ebp]
  00921	f3 0f 11 43 14	 movss	 DWORD PTR [ebx+20], xmm0

; 110  : 	vertex.z = z;

  00926	f3 0f 10 45 c8	 movss	 xmm0, DWORD PTR tv4674[ebp]

; 112  : 	vertices.push_back(vertex);

  0092b	8b ce		 mov	 ecx, esi

; 162  : 	vertex.u = u;

  0092d	c7 43 1c 00 00
	00 00		 mov	 DWORD PTR [ebx+28], 0

; 163  : 	vertex.v = v;

  00934	c7 43 20 00 00
	00 00		 mov	 DWORD PTR [ebx+32], 0

; 156  : 	vertex.r = r;

  0093b	88 43 24	 mov	 BYTE PTR [ebx+36], al

; 157  : 	vertex.g = g;

  0093e	88 43 25	 mov	 BYTE PTR [ebx+37], al

; 158  : 	vertex.b = b;

  00941	88 43 26	 mov	 BYTE PTR [ebx+38], al

; 110  : 	vertex.z = z;

  00944	f3 0f 11 43 18	 movss	 DWORD PTR [ebx+24], xmm0

; 112  : 	vertices.push_back(vertex);

  00949	e8 00 00 00 00	 call	 ?push_back@?$vector@VVertexUVRGBA@gfxu@@V?$allocator@VVertexUVRGBA@gfxu@@@std@@@std@@QAEXABVVertexUVRGBA@gfxu@@@Z ; std::vector<gfxu::VertexUVRGBA,std::allocator<gfxu::VertexUVRGBA> >::push_back

; 108  : 	vertex.x = x;

  0094e	f3 0f 10 45 b4	 movss	 xmm0, DWORD PTR tv4672[ebp]

; 156  : 	vertex.r = r;

  00953	8b 45 a8	 mov	 eax, DWORD PTR tv4659[ebp]

; 114  : 	vs++;

  00956	ff 05 00 00 00
	00		 inc	 DWORD PTR ?vs@@3HA	; vs

; 108  : 	vertex.x = x;

  0095c	f3 0f 11 07	 movss	 DWORD PTR [edi], xmm0

; 109  : 	vertex.y = y;

  00960	f3 0f 10 45 d0	 movss	 xmm0, DWORD PTR tv4673[ebp]
  00965	f3 0f 11 43 14	 movss	 DWORD PTR [ebx+20], xmm0

; 110  : 	vertex.z = z;

  0096a	f3 0f 10 45 c8	 movss	 xmm0, DWORD PTR tv4674[ebp]

; 162  : 	vertex.u = u;

  0096f	c7 43 1c 00 00
	80 3f		 mov	 DWORD PTR [ebx+28], 1065353216 ; 3f800000H

; 163  : 	vertex.v = v;

  00976	c7 43 20 00 00
	00 00		 mov	 DWORD PTR [ebx+32], 0

; 156  : 	vertex.r = r;

  0097d	88 43 24	 mov	 BYTE PTR [ebx+36], al

; 157  : 	vertex.g = g;

  00980	88 43 25	 mov	 BYTE PTR [ebx+37], al

; 158  : 	vertex.b = b;

  00983	88 43 26	 mov	 BYTE PTR [ebx+38], al

; 110  : 	vertex.z = z;

  00986	f3 0f 11 43 18	 movss	 DWORD PTR [ebx+24], xmm0

; 112  : 	vertices.push_back(vertex);

  0098b	57		 push	 edi
  0098c	8b ce		 mov	 ecx, esi
  0098e	e8 00 00 00 00	 call	 ?push_back@?$vector@VVertexUVRGBA@gfxu@@V?$allocator@VVertexUVRGBA@gfxu@@@std@@@std@@QAEXABVVertexUVRGBA@gfxu@@@Z ; std::vector<gfxu::VertexUVRGBA,std::allocator<gfxu::VertexUVRGBA> >::push_back

; 114  : 	vs++;

  00993	ff 05 00 00 00
	00		 inc	 DWORD PTR ?vs@@3HA	; vs
  00999	8b 5d c4	 mov	 ebx, DWORD PTR tv5127[ebp]
  0099c	8b 75 bc	 mov	 esi, DWORD PTR tv5105[ebp]
  0099f	8b 7d c0	 mov	 edi, DWORD PTR tv5128[ebp]
$LN316@renderChun:
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp

; 172  : 					if(!GlobalThread::world.getBlock(i | cx, (j | cy) - 1, k | cz))

  009a2	ff 75 ec	 push	 DWORD PTR tv5129[ebp]
  009a5	8d 47 ff	 lea	 eax, DWORD PTR [edi-1]
  009a8	50		 push	 eax
  009a9	53		 push	 ebx
  009aa	89 45 cc	 mov	 DWORD PTR tv5118[ebp], eax
  009ad	e8 00 00 00 00	 call	 ?getBlock@World@@QAEGHHH@Z ; World::getBlock
  009b2	66 85 c0	 test	 ax, ax
  009b5	0f 85 d2 03 00
	00		 jne	 $LN376@renderChun

; 173  : 					{
; 174  : 						int i1 = 0;
; 175  : 						int i2 = 0;
; 176  : 						int i3 = 0;
; 177  : 						int i4 = 0;
; 178  : 
; 179  : 						if(GlobalThread::world.getBlock((i | cx) - 1, (j | cy) - 1, k | cz))

  009bb	ff 75 ec	 push	 DWORD PTR tv5129[ebp]
  009be	33 c0		 xor	 eax, eax
  009c0	ff 75 cc	 push	 DWORD PTR tv5118[ebp]
  009c3	89 45 d0	 mov	 DWORD PTR _i3$1$[ebp], eax
  009c6	89 45 c8	 mov	 DWORD PTR _i4$1$[ebp], eax
  009c9	8d 43 ff	 lea	 eax, DWORD PTR [ebx-1]
  009cc	50		 push	 eax
  009cd	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _i1$1$[ebp], 0
  009d4	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _i2$1$[ebp], 0
  009db	89 45 b4	 mov	 DWORD PTR tv5123[ebp], eax
  009de	e8 00 00 00 00	 call	 ?getBlock@World@@QAEGHHH@Z ; World::getBlock
  009e3	66 85 c0	 test	 ax, ax
  009e6	74 0e		 je	 SHORT $LN35@renderChun

; 180  : 						{
; 181  : 							i1++;

  009e8	c7 45 e4 01 00
	00 00		 mov	 DWORD PTR _i1$1$[ebp], 1

; 182  : 							i4++;

  009ef	c7 45 c8 01 00
	00 00		 mov	 DWORD PTR _i4$1$[ebp], 1
$LN35@renderChun:

; 183  : 						}
; 184  : 
; 185  : 						if(GlobalThread::world.getBlock(i | cx, (j | cy) - 1, (k | cz) - 1))

  009f6	8b 7d ec	 mov	 edi, DWORD PTR tv5129[ebp]
  009f9	4f		 dec	 edi
  009fa	57		 push	 edi
  009fb	ff 75 cc	 push	 DWORD PTR tv5118[ebp]
  009fe	53		 push	 ebx
  009ff	e8 00 00 00 00	 call	 ?getBlock@World@@QAEGHHH@Z ; World::getBlock
  00a04	66 85 c0	 test	 ax, ax
  00a07	74 0a		 je	 SHORT $LN34@renderChun

; 186  : 						{
; 187  : 							i1++;

  00a09	ff 45 e4	 inc	 DWORD PTR _i1$1$[ebp]

; 188  : 							i2++;

  00a0c	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR _i2$1$[ebp], 1
$LN34@renderChun:

; 189  : 						}
; 190  : 
; 191  : 						if(GlobalThread::world.getBlock((i | cx) + 1, (j | cy) - 1, k | cz))

  00a13	ff 75 ec	 push	 DWORD PTR tv5129[ebp]
  00a16	8d 43 01	 lea	 eax, DWORD PTR [ebx+1]
  00a19	ff 75 cc	 push	 DWORD PTR tv5118[ebp]
  00a1c	89 45 b0	 mov	 DWORD PTR tv5115[ebp], eax
  00a1f	50		 push	 eax
  00a20	e8 00 00 00 00	 call	 ?getBlock@World@@QAEGHHH@Z ; World::getBlock
  00a25	66 85 c0	 test	 ax, ax
  00a28	74 0a		 je	 SHORT $LN33@renderChun

; 192  : 						{
; 193  : 							i2++;

  00a2a	ff 45 e8	 inc	 DWORD PTR _i2$1$[ebp]

; 194  : 							i3++;

  00a2d	c7 45 d0 01 00
	00 00		 mov	 DWORD PTR _i3$1$[ebp], 1
$LN33@renderChun:

; 195  : 						}
; 196  : 
; 197  : 						if(GlobalThread::world.getBlock(i | cx, (j | cy) - 1, (k | cz) + 1))

  00a34	56		 push	 esi
  00a35	ff 75 cc	 push	 DWORD PTR tv5118[ebp]
  00a38	53		 push	 ebx
  00a39	e8 00 00 00 00	 call	 ?getBlock@World@@QAEGHHH@Z ; World::getBlock
  00a3e	66 85 c0	 test	 ax, ax
  00a41	74 06		 je	 SHORT $LN32@renderChun

; 198  : 						{
; 199  : 							i3++;

  00a43	ff 45 d0	 inc	 DWORD PTR _i3$1$[ebp]

; 200  : 							i4++;

  00a46	ff 45 c8	 inc	 DWORD PTR _i4$1$[ebp]
$LN32@renderChun:

; 201  : 						}
; 202  : 
; 203  : 						if(i1 < 2 && GlobalThread::world.getBlock((i | cx) - 1, (j | cy) - 1, (k | cz) - 1))

  00a49	83 7d e4 02	 cmp	 DWORD PTR _i1$1$[ebp], 2
  00a4d	8b 5d cc	 mov	 ebx, DWORD PTR tv5118[ebp]
  00a50	7d 12		 jge	 SHORT $LN31@renderChun
  00a52	57		 push	 edi
  00a53	53		 push	 ebx
  00a54	ff 75 b4	 push	 DWORD PTR tv5123[ebp]
  00a57	e8 00 00 00 00	 call	 ?getBlock@World@@QAEGHHH@Z ; World::getBlock
  00a5c	66 85 c0	 test	 ax, ax
  00a5f	74 03		 je	 SHORT $LN31@renderChun

; 204  : 						{
; 205  : 							i1++;

  00a61	ff 45 e4	 inc	 DWORD PTR _i1$1$[ebp]
$LN31@renderChun:

; 206  : 						}
; 207  : 
; 208  : 						if(i2 < 2 && GlobalThread::world.getBlock((i | cx) + 1, (j | cy) - 1, (k | cz) - 1))

  00a64	83 7d e8 02	 cmp	 DWORD PTR _i2$1$[ebp], 2
  00a68	7d 12		 jge	 SHORT $LN30@renderChun
  00a6a	57		 push	 edi
  00a6b	53		 push	 ebx
  00a6c	ff 75 b0	 push	 DWORD PTR tv5115[ebp]
  00a6f	e8 00 00 00 00	 call	 ?getBlock@World@@QAEGHHH@Z ; World::getBlock
  00a74	66 85 c0	 test	 ax, ax
  00a77	74 03		 je	 SHORT $LN30@renderChun

; 209  : 						{
; 210  : 							i2++;

  00a79	ff 45 e8	 inc	 DWORD PTR _i2$1$[ebp]
$LN30@renderChun:

; 211  : 						}
; 212  : 								
; 213  : 						if(i3 < 2 && GlobalThread::world.getBlock((i | cx) + 1, (j | cy) - 1, (k | cz) + 1))

  00a7c	8b 7d d0	 mov	 edi, DWORD PTR _i3$1$[ebp]
  00a7f	83 ff 02	 cmp	 edi, 2
  00a82	7d 13		 jge	 SHORT $LN29@renderChun
  00a84	56		 push	 esi
  00a85	53		 push	 ebx
  00a86	ff 75 b0	 push	 DWORD PTR tv5115[ebp]
  00a89	e8 00 00 00 00	 call	 ?getBlock@World@@QAEGHHH@Z ; World::getBlock
  00a8e	66 85 c0	 test	 ax, ax
  00a91	74 04		 je	 SHORT $LN29@renderChun

; 214  : 						{
; 215  : 							i3++;

  00a93	47		 inc	 edi
  00a94	89 7d d0	 mov	 DWORD PTR _i3$1$[ebp], edi
$LN29@renderChun:

; 216  : 						}
; 217  : 								
; 218  : 						if(i4 < 2 && GlobalThread::world.getBlock((i | cx) - 1, (j | cy) - 1, (k | cz) + 1))

  00a97	8b 7d c8	 mov	 edi, DWORD PTR _i4$1$[ebp]
  00a9a	83 ff 02	 cmp	 edi, 2
  00a9d	7d 10		 jge	 SHORT $LN28@renderChun
  00a9f	56		 push	 esi
  00aa0	53		 push	 ebx
  00aa1	ff 75 b4	 push	 DWORD PTR tv5123[ebp]
  00aa4	e8 00 00 00 00	 call	 ?getBlock@World@@QAEGHHH@Z ; World::getBlock
  00aa9	66 85 c0	 test	 ax, ax
  00aac	74 01		 je	 SHORT $LN28@renderChun

; 219  : 						{
; 220  : 							i4++;

  00aae	47		 inc	 edi
$LN28@renderChun:
  00aaf	66 0f 6e 45 e4	 movd	 xmm0, DWORD PTR _i1$1$[ebp]

; 223  : 						float f1 = 1.0F - i1 * 0.1f;

  00ab4	f3 0f 10 15 00
	00 00 00	 movss	 xmm2, DWORD PTR __real@3dcccccd
  00abc	f3 0f 10 25 00
	00 00 00	 movss	 xmm4, DWORD PTR __real@3f800000
  00ac4	0f 5b c0	 cvtdq2ps xmm0, xmm0

; 225  : 						float f3 = 1.0F - i3 * 0.1f;

  00ac7	8b 45 d0	 mov	 eax, DWORD PTR _i3$1$[ebp]
  00aca	f3 0f 59 c2	 mulss	 xmm0, xmm2
  00ace	0f 28 cc	 movaps	 xmm1, xmm4
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp

; 162  : 	vertex.u = u;

  00ad1	8b 4d f0	 mov	 ecx, DWORD PTR $T4[ebp]
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp

; 223  : 						float f1 = 1.0F - i1 * 0.1f;

  00ad4	f3 0f 5c c8	 subss	 xmm1, xmm0
  00ad8	66 0f 6e 45 e8	 movd	 xmm0, DWORD PTR _i2$1$[ebp]

; 224  : 						float f2 = 1.0F - i2 * 0.1f;

  00add	0f 5b c0	 cvtdq2ps xmm0, xmm0
  00ae0	f3 0f 11 4d d4	 movss	 DWORD PTR _f1$1$[ebp], xmm1
  00ae5	f3 0f 59 c2	 mulss	 xmm0, xmm2
  00ae9	0f 28 cc	 movaps	 xmm1, xmm4
  00aec	0f 57 ed	 xorps	 xmm5, xmm5
  00aef	f3 0f 5c c8	 subss	 xmm1, xmm0
  00af3	66 0f 6e c0	 movd	 xmm0, eax

; 225  : 						float f3 = 1.0F - i3 * 0.1f;

  00af7	0f 5b c0	 cvtdq2ps xmm0, xmm0

; 228  : 						vStream->put(gfxu::VertexUVRGBA(i + 0.0f, j + 0.0f, k + 1.0f, 0.0f, 0.0f, f4, f4, f4, 1.0f));

  00afa	8b 45 d8	 mov	 eax, DWORD PTR _i$1$[ebp]
  00afd	f3 0f 59 c2	 mulss	 xmm0, xmm2
  00b01	f3 0f 11 4d e4	 movss	 DWORD PTR _f2$1$[ebp], xmm1
  00b06	0f 28 cc	 movaps	 xmm1, xmm4
  00b09	f3 0f 5c c8	 subss	 xmm1, xmm0
  00b0d	66 0f 6e c7	 movd	 xmm0, edi
  00b11	0f 5b c0	 cvtdq2ps xmm0, xmm0
  00b14	f3 0f 11 4d a8	 movss	 DWORD PTR _f3$1$[ebp], xmm1
  00b19	f3 0f 59 c2	 mulss	 xmm0, xmm2
  00b1d	0f 28 cc	 movaps	 xmm1, xmm4
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp

; 108  : 	vertex.x = x;

  00b20	8d 79 10	 lea	 edi, DWORD PTR [ecx+16]
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp

; 226  : 						float f4 = 1.0F - i4 * 0.1f;

  00b23	f3 0f 5c c8	 subss	 xmm1, xmm0
  00b27	66 0f 6e c0	 movd	 xmm0, eax

; 228  : 						vStream->put(gfxu::VertexUVRGBA(i + 0.0f, j + 0.0f, k + 1.0f, 0.0f, 0.0f, f4, f4, f4, 1.0f));

  00b2b	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  00b2f	c1 e8 1f	 shr	 eax, 31			; 0000001fH
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp

; 70   : {}

  00b32	f3 0f 59 0d 00
	00 00 00	 mulss	 xmm1, DWORD PTR __real@437f0000
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp

; 228  : 						vStream->put(gfxu::VertexUVRGBA(i + 0.0f, j + 0.0f, k + 1.0f, 0.0f, 0.0f, f4, f4, f4, 1.0f));

  00b3a	f2 0f 58 04 c5
	00 00 00 00	 addsd	 xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
  00b43	8b 45 dc	 mov	 eax, DWORD PTR _j$1$[ebp]
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp

; 112  : 	vertices.push_back(vertex);

  00b46	8d 71 04	 lea	 esi, DWORD PTR [ecx+4]

; 162  : 	vertex.u = u;

  00b49	c7 41 1c 00 00
	00 00		 mov	 DWORD PTR [ecx+28], 0

; 163  : 	vertex.v = v;

  00b50	c7 41 20 00 00
	00 00		 mov	 DWORD PTR [ecx+32], 0
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp

; 228  : 						vStream->put(gfxu::VertexUVRGBA(i + 0.0f, j + 0.0f, k + 1.0f, 0.0f, 0.0f, f4, f4, f4, 1.0f));

  00b57	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp

; 112  : 	vertices.push_back(vertex);

  00b5b	57		 push	 edi
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp

; 228  : 						vStream->put(gfxu::VertexUVRGBA(i + 0.0f, j + 0.0f, k + 1.0f, 0.0f, 0.0f, f4, f4, f4, 1.0f));

  00b5c	0f 28 d8	 movaps	 xmm3, xmm0
  00b5f	f3 0f 11 45 cc	 movss	 DWORD PTR tv4731[ebp], xmm0
  00b64	66 0f 6e c0	 movd	 xmm0, eax
  00b68	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  00b6c	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00b6f	f3 0f 58 dd	 addss	 xmm3, xmm5
  00b73	f2 0f 58 04 c5
	00 00 00 00	 addsd	 xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
  00b7c	8b 45 e0	 mov	 eax, DWORD PTR _k$1$[ebp]
  00b7f	f3 0f 11 5d b4	 movss	 DWORD PTR tv4734[ebp], xmm3
  00b84	66 0f 5a d0	 cvtpd2ps xmm2, xmm0
  00b88	66 0f 6e c0	 movd	 xmm0, eax
  00b8c	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  00b90	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00b93	f3 0f 58 d5	 addss	 xmm2, xmm5
  00b97	f2 0f 58 04 c5
	00 00 00 00	 addsd	 xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp

; 70   : {}

  00ba0	f3 0f 2c c1	 cvttss2si eax, xmm1
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp

; 228  : 						vStream->put(gfxu::VertexUVRGBA(i + 0.0f, j + 0.0f, k + 1.0f, 0.0f, 0.0f, f4, f4, f4, 1.0f));

  00ba4	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp

; 156  : 	vertex.r = r;

  00ba8	88 41 24	 mov	 BYTE PTR [ecx+36], al
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp

; 228  : 						vStream->put(gfxu::VertexUVRGBA(i + 0.0f, j + 0.0f, k + 1.0f, 0.0f, 0.0f, f4, f4, f4, 1.0f));

  00bab	f3 0f 11 45 d0	 movss	 DWORD PTR tv4736[ebp], xmm0
  00bb0	f3 0f 58 c4	 addss	 xmm0, xmm4
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp

; 157  : 	vertex.g = g;

  00bb4	88 41 25	 mov	 BYTE PTR [ecx+37], al

; 158  : 	vertex.b = b;

  00bb7	88 41 26	 mov	 BYTE PTR [ecx+38], al

; 109  : 	vertex.y = y;

  00bba	f3 0f 11 51 14	 movss	 DWORD PTR [ecx+20], xmm2
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp

; 228  : 						vStream->put(gfxu::VertexUVRGBA(i + 0.0f, j + 0.0f, k + 1.0f, 0.0f, 0.0f, f4, f4, f4, 1.0f));

  00bbf	f3 0f 11 55 c8	 movss	 DWORD PTR tv4735[ebp], xmm2
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp

; 110  : 	vertex.z = z;

  00bc4	f3 0f 11 41 18	 movss	 DWORD PTR [ecx+24], xmm0

; 112  : 	vertices.push_back(vertex);

  00bc9	8b ce		 mov	 ecx, esi
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp

; 228  : 						vStream->put(gfxu::VertexUVRGBA(i + 0.0f, j + 0.0f, k + 1.0f, 0.0f, 0.0f, f4, f4, f4, 1.0f));

  00bcb	f3 0f 11 45 b0	 movss	 DWORD PTR tv4726[ebp], xmm0
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp

; 108  : 	vertex.x = x;

  00bd0	f3 0f 11 1f	 movss	 DWORD PTR [edi], xmm3

; 112  : 	vertices.push_back(vertex);

  00bd4	e8 00 00 00 00	 call	 ?push_back@?$vector@VVertexUVRGBA@gfxu@@V?$allocator@VVertexUVRGBA@gfxu@@@std@@@std@@QAEXABVVertexUVRGBA@gfxu@@@Z ; std::vector<gfxu::VertexUVRGBA,std::allocator<gfxu::VertexUVRGBA> >::push_back

; 70   : {}

  00bd9	f3 0f 10 45 a8	 movss	 xmm0, DWORD PTR _f3$1$[ebp]
  00bde	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp

; 229  : 						vStream->put(gfxu::VertexUVRGBA(i + 1.0f, j + 0.0f, k + 1.0f, 1.0f, 0.0f, f3, f3, f3, 1.0f));

  00be6	f3 0f 10 4d cc	 movss	 xmm1, DWORD PTR tv4731[ebp]
  00beb	f3 0f 58 0d 00
	00 00 00	 addss	 xmm1, DWORD PTR __real@3f800000
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp

; 162  : 	vertex.u = u;

  00bf3	8b 45 f0	 mov	 eax, DWORD PTR $T4[ebp]

; 114  : 	vs++;

  00bf6	ff 05 00 00 00
	00		 inc	 DWORD PTR ?vs@@3HA	; vs

; 70   : {}

  00bfc	f3 0f 2c d8	 cvttss2si ebx, xmm0
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp

; 229  : 						vStream->put(gfxu::VertexUVRGBA(i + 1.0f, j + 0.0f, k + 1.0f, 1.0f, 0.0f, f3, f3, f3, 1.0f));

  00c00	f3 0f 11 4d cc	 movss	 DWORD PTR tv4731[ebp], xmm1
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp

; 162  : 	vertex.u = u;

  00c05	c7 40 1c 00 00
	80 3f		 mov	 DWORD PTR [eax+28], 1065353216 ; 3f800000H

; 163  : 	vertex.v = v;

  00c0c	c7 40 20 00 00
	00 00		 mov	 DWORD PTR [eax+32], 0

; 156  : 	vertex.r = r;

  00c13	88 58 24	 mov	 BYTE PTR [eax+36], bl

; 109  : 	vertex.y = y;

  00c16	f3 0f 10 45 c8	 movss	 xmm0, DWORD PTR tv4735[ebp]
  00c1b	f3 0f 11 40 14	 movss	 DWORD PTR [eax+20], xmm0

; 110  : 	vertex.z = z;

  00c20	f3 0f 10 45 b0	 movss	 xmm0, DWORD PTR tv4726[ebp]

; 112  : 	vertices.push_back(vertex);

  00c25	57		 push	 edi
  00c26	8b ce		 mov	 ecx, esi

; 157  : 	vertex.g = g;

  00c28	88 58 25	 mov	 BYTE PTR [eax+37], bl

; 158  : 	vertex.b = b;

  00c2b	88 58 26	 mov	 BYTE PTR [eax+38], bl

; 108  : 	vertex.x = x;

  00c2e	f3 0f 11 0f	 movss	 DWORD PTR [edi], xmm1

; 110  : 	vertex.z = z;

  00c32	f3 0f 11 40 18	 movss	 DWORD PTR [eax+24], xmm0

; 112  : 	vertices.push_back(vertex);

  00c37	e8 00 00 00 00	 call	 ?push_back@?$vector@VVertexUVRGBA@gfxu@@V?$allocator@VVertexUVRGBA@gfxu@@@std@@@std@@QAEXABVVertexUVRGBA@gfxu@@@Z ; std::vector<gfxu::VertexUVRGBA,std::allocator<gfxu::VertexUVRGBA> >::push_back

; 70   : {}

  00c3c	f3 0f 10 45 d4	 movss	 xmm0, DWORD PTR _f1$1$[ebp]
  00c41	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp

; 230  : 						vStream->put(gfxu::VertexUVRGBA(i + 0.0f, j + 0.0f, k + 0.0f, 0.0f, 1.0f, f1, f1, f1, 1.0f));

  00c49	f3 0f 10 4d d0	 movss	 xmm1, DWORD PTR tv4736[ebp]
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp

; 162  : 	vertex.u = u;

  00c4e	8b 4d f0	 mov	 ecx, DWORD PTR $T4[ebp]
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp

; 230  : 						vStream->put(gfxu::VertexUVRGBA(i + 0.0f, j + 0.0f, k + 0.0f, 0.0f, 1.0f, f1, f1, f1, 1.0f));

  00c51	f3 0f 58 0d 00
	00 00 00	 addss	 xmm1, DWORD PTR __real@00000000
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp

; 114  : 	vs++;

  00c59	ff 05 00 00 00
	00		 inc	 DWORD PTR ?vs@@3HA	; vs

; 70   : {}

  00c5f	f3 0f 2c c0	 cvttss2si eax, xmm0

; 108  : 	vertex.x = x;

  00c63	f3 0f 10 45 b4	 movss	 xmm0, DWORD PTR tv4734[ebp]
  00c68	f3 0f 11 07	 movss	 DWORD PTR [edi], xmm0

; 109  : 	vertex.y = y;

  00c6c	f3 0f 10 45 c8	 movss	 xmm0, DWORD PTR tv4735[ebp]

; 162  : 	vertex.u = u;

  00c71	c7 41 1c 00 00
	00 00		 mov	 DWORD PTR [ecx+28], 0

; 163  : 	vertex.v = v;

  00c78	c7 41 20 00 00
	80 3f		 mov	 DWORD PTR [ecx+32], 1065353216 ; 3f800000H

; 156  : 	vertex.r = r;

  00c7f	88 41 24	 mov	 BYTE PTR [ecx+36], al

; 157  : 	vertex.g = g;

  00c82	88 41 25	 mov	 BYTE PTR [ecx+37], al

; 158  : 	vertex.b = b;

  00c85	88 41 26	 mov	 BYTE PTR [ecx+38], al

; 109  : 	vertex.y = y;

  00c88	f3 0f 11 41 14	 movss	 DWORD PTR [ecx+20], xmm0

; 110  : 	vertex.z = z;

  00c8d	f3 0f 11 49 18	 movss	 DWORD PTR [ecx+24], xmm1

; 112  : 	vertices.push_back(vertex);

  00c92	57		 push	 edi
  00c93	8b ce		 mov	 ecx, esi
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp

; 230  : 						vStream->put(gfxu::VertexUVRGBA(i + 0.0f, j + 0.0f, k + 0.0f, 0.0f, 1.0f, f1, f1, f1, 1.0f));

  00c95	f3 0f 11 4d d0	 movss	 DWORD PTR tv4736[ebp], xmm1
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp

; 70   : {}

  00c9a	89 45 a8	 mov	 DWORD PTR tv4720[ebp], eax

; 112  : 	vertices.push_back(vertex);

  00c9d	e8 00 00 00 00	 call	 ?push_back@?$vector@VVertexUVRGBA@gfxu@@V?$allocator@VVertexUVRGBA@gfxu@@@std@@@std@@QAEXABVVertexUVRGBA@gfxu@@@Z ; std::vector<gfxu::VertexUVRGBA,std::allocator<gfxu::VertexUVRGBA> >::push_back

; 162  : 	vertex.u = u;

  00ca2	8b 45 f0	 mov	 eax, DWORD PTR $T4[ebp]

; 108  : 	vertex.x = x;

  00ca5	f3 0f 10 45 cc	 movss	 xmm0, DWORD PTR tv4731[ebp]

; 114  : 	vs++;

  00caa	ff 05 00 00 00
	00		 inc	 DWORD PTR ?vs@@3HA	; vs

; 156  : 	vertex.r = r;

  00cb0	88 58 24	 mov	 BYTE PTR [eax+36], bl

; 157  : 	vertex.g = g;

  00cb3	88 58 25	 mov	 BYTE PTR [eax+37], bl

; 158  : 	vertex.b = b;

  00cb6	88 58 26	 mov	 BYTE PTR [eax+38], bl

; 108  : 	vertex.x = x;

  00cb9	f3 0f 11 07	 movss	 DWORD PTR [edi], xmm0

; 109  : 	vertex.y = y;

  00cbd	f3 0f 10 45 c8	 movss	 xmm0, DWORD PTR tv4735[ebp]
  00cc2	8b d8		 mov	 ebx, eax

; 112  : 	vertices.push_back(vertex);

  00cc4	57		 push	 edi
  00cc5	f3 0f 11 43 14	 movss	 DWORD PTR [ebx+20], xmm0
  00cca	f3 0f 10 45 b0	 movss	 xmm0, DWORD PTR tv4726[ebp]
  00ccf	8b ce		 mov	 ecx, esi

; 162  : 	vertex.u = u;

  00cd1	c7 40 1c 00 00
	80 3f		 mov	 DWORD PTR [eax+28], 1065353216 ; 3f800000H

; 163  : 	vertex.v = v;

  00cd8	c7 40 20 00 00
	00 00		 mov	 DWORD PTR [eax+32], 0

; 110  : 	vertex.z = z;

  00cdf	f3 0f 11 43 18	 movss	 DWORD PTR [ebx+24], xmm0

; 112  : 	vertices.push_back(vertex);

  00ce4	e8 00 00 00 00	 call	 ?push_back@?$vector@VVertexUVRGBA@gfxu@@V?$allocator@VVertexUVRGBA@gfxu@@@std@@@std@@QAEXABVVertexUVRGBA@gfxu@@@Z ; std::vector<gfxu::VertexUVRGBA,std::allocator<gfxu::VertexUVRGBA> >::push_back

; 70   : {}

  00ce9	f3 0f 10 45 e4	 movss	 xmm0, DWORD PTR _f2$1$[ebp]
  00cee	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000

; 114  : 	vs++;

  00cf6	ff 05 00 00 00
	00		 inc	 DWORD PTR ?vs@@3HA	; vs

; 112  : 	vertices.push_back(vertex);

  00cfc	57		 push	 edi

; 70   : {}

  00cfd	f3 0f 2c c0	 cvttss2si eax, xmm0

; 108  : 	vertex.x = x;

  00d01	f3 0f 10 45 cc	 movss	 xmm0, DWORD PTR tv4731[ebp]
  00d06	f3 0f 11 07	 movss	 DWORD PTR [edi], xmm0

; 109  : 	vertex.y = y;

  00d0a	f3 0f 10 45 c8	 movss	 xmm0, DWORD PTR tv4735[ebp]
  00d0f	f3 0f 11 43 14	 movss	 DWORD PTR [ebx+20], xmm0

; 110  : 	vertex.z = z;

  00d14	f3 0f 10 45 d0	 movss	 xmm0, DWORD PTR tv4736[ebp]

; 112  : 	vertices.push_back(vertex);

  00d19	8b ce		 mov	 ecx, esi

; 162  : 	vertex.u = u;

  00d1b	c7 43 1c 00 00
	80 3f		 mov	 DWORD PTR [ebx+28], 1065353216 ; 3f800000H

; 163  : 	vertex.v = v;

  00d22	c7 43 20 00 00
	80 3f		 mov	 DWORD PTR [ebx+32], 1065353216 ; 3f800000H

; 156  : 	vertex.r = r;

  00d29	88 43 24	 mov	 BYTE PTR [ebx+36], al

; 157  : 	vertex.g = g;

  00d2c	88 43 25	 mov	 BYTE PTR [ebx+37], al

; 158  : 	vertex.b = b;

  00d2f	88 43 26	 mov	 BYTE PTR [ebx+38], al

; 110  : 	vertex.z = z;

  00d32	f3 0f 11 43 18	 movss	 DWORD PTR [ebx+24], xmm0

; 112  : 	vertices.push_back(vertex);

  00d37	e8 00 00 00 00	 call	 ?push_back@?$vector@VVertexUVRGBA@gfxu@@V?$allocator@VVertexUVRGBA@gfxu@@@std@@@std@@QAEXABVVertexUVRGBA@gfxu@@@Z ; std::vector<gfxu::VertexUVRGBA,std::allocator<gfxu::VertexUVRGBA> >::push_back

; 108  : 	vertex.x = x;

  00d3c	f3 0f 10 45 b4	 movss	 xmm0, DWORD PTR tv4734[ebp]

; 156  : 	vertex.r = r;

  00d41	8b 45 a8	 mov	 eax, DWORD PTR tv4720[ebp]

; 114  : 	vs++;

  00d44	ff 05 00 00 00
	00		 inc	 DWORD PTR ?vs@@3HA	; vs

; 108  : 	vertex.x = x;

  00d4a	f3 0f 11 07	 movss	 DWORD PTR [edi], xmm0

; 109  : 	vertex.y = y;

  00d4e	f3 0f 10 45 c8	 movss	 xmm0, DWORD PTR tv4735[ebp]
  00d53	f3 0f 11 43 14	 movss	 DWORD PTR [ebx+20], xmm0

; 110  : 	vertex.z = z;

  00d58	f3 0f 10 45 d0	 movss	 xmm0, DWORD PTR tv4736[ebp]

; 162  : 	vertex.u = u;

  00d5d	c7 43 1c 00 00
	00 00		 mov	 DWORD PTR [ebx+28], 0

; 163  : 	vertex.v = v;

  00d64	c7 43 20 00 00
	80 3f		 mov	 DWORD PTR [ebx+32], 1065353216 ; 3f800000H

; 156  : 	vertex.r = r;

  00d6b	88 43 24	 mov	 BYTE PTR [ebx+36], al

; 157  : 	vertex.g = g;

  00d6e	88 43 25	 mov	 BYTE PTR [ebx+37], al

; 158  : 	vertex.b = b;

  00d71	88 43 26	 mov	 BYTE PTR [ebx+38], al

; 110  : 	vertex.z = z;

  00d74	f3 0f 11 43 18	 movss	 DWORD PTR [ebx+24], xmm0

; 112  : 	vertices.push_back(vertex);

  00d79	57		 push	 edi
  00d7a	8b ce		 mov	 ecx, esi
  00d7c	e8 00 00 00 00	 call	 ?push_back@?$vector@VVertexUVRGBA@gfxu@@V?$allocator@VVertexUVRGBA@gfxu@@@std@@@std@@QAEXABVVertexUVRGBA@gfxu@@@Z ; std::vector<gfxu::VertexUVRGBA,std::allocator<gfxu::VertexUVRGBA> >::push_back

; 114  : 	vs++;

  00d81	ff 05 00 00 00
	00		 inc	 DWORD PTR ?vs@@3HA	; vs
  00d87	8b 5d c4	 mov	 ebx, DWORD PTR tv5127[ebp]
  00d8a	8b 7d c0	 mov	 edi, DWORD PTR tv5128[ebp]
$LN376@renderChun:
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp

; 236  : 					if(!GlobalThread::world.getBlock(i | cx, (j | cy) + 1, k | cz))

  00d8d	8b 75 ec	 mov	 esi, DWORD PTR tv5129[ebp]
  00d90	8d 47 01	 lea	 eax, DWORD PTR [edi+1]
  00d93	56		 push	 esi
  00d94	50		 push	 eax
  00d95	53		 push	 ebx
  00d96	89 45 e4	 mov	 DWORD PTR tv5110[ebp], eax
  00d99	e8 00 00 00 00	 call	 ?getBlock@World@@QAEGHHH@Z ; World::getBlock
  00d9e	66 85 c0	 test	 ax, ax
  00da1	0f 85 d3 03 00
	00		 jne	 $LN436@renderChun

; 237  : 					{
; 238  : 						int i1 = 0;
; 239  : 						int i2 = 0;
; 240  : 						int i3 = 0;

  00da7	33 c0		 xor	 eax, eax

; 241  : 						int i4 = 0;
; 242  : 
; 243  : 						if(GlobalThread::world.getBlock((i | cx) - 1, (j | cy) + 1, k | cz))

  00da9	56		 push	 esi
  00daa	ff 75 e4	 push	 DWORD PTR tv5110[ebp]
  00dad	89 45 cc	 mov	 DWORD PTR _i3$1$[ebp], eax
  00db0	89 45 c8	 mov	 DWORD PTR _i4$1$[ebp], eax
  00db3	8d 43 ff	 lea	 eax, DWORD PTR [ebx-1]
  00db6	50		 push	 eax
  00db7	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _i1$1$[ebp], 0
  00dbe	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _i2$1$[ebp], 0
  00dc5	89 45 b4	 mov	 DWORD PTR tv5122[ebp], eax
  00dc8	e8 00 00 00 00	 call	 ?getBlock@World@@QAEGHHH@Z ; World::getBlock
  00dcd	66 85 c0	 test	 ax, ax
  00dd0	74 0e		 je	 SHORT $LN26@renderChun

; 244  : 						{
; 245  : 							i1++;

  00dd2	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR _i1$1$[ebp], 1

; 246  : 							i4++;

  00dd9	c7 45 c8 01 00
	00 00		 mov	 DWORD PTR _i4$1$[ebp], 1
$LN26@renderChun:

; 247  : 						}
; 248  : 
; 249  : 						if(GlobalThread::world.getBlock(i | cx, (j | cy) + 1, (k | cz) - 1))

  00de0	8d 7e ff	 lea	 edi, DWORD PTR [esi-1]
  00de3	57		 push	 edi
  00de4	ff 75 e4	 push	 DWORD PTR tv5110[ebp]
  00de7	53		 push	 ebx
  00de8	e8 00 00 00 00	 call	 ?getBlock@World@@QAEGHHH@Z ; World::getBlock
  00ded	66 85 c0	 test	 ax, ax
  00df0	74 0a		 je	 SHORT $LN25@renderChun

; 250  : 						{
; 251  : 							i1++;

  00df2	ff 45 e8	 inc	 DWORD PTR _i1$1$[ebp]

; 252  : 							i2++;

  00df5	c7 45 d4 01 00
	00 00		 mov	 DWORD PTR _i2$1$[ebp], 1
$LN25@renderChun:

; 253  : 						}
; 254  : 
; 255  : 						if(GlobalThread::world.getBlock((i | cx) + 1, (j | cy) + 1, k | cz))

  00dfc	56		 push	 esi
  00dfd	ff 75 e4	 push	 DWORD PTR tv5110[ebp]
  00e00	8d 43 01	 lea	 eax, DWORD PTR [ebx+1]
  00e03	50		 push	 eax
  00e04	89 45 b0	 mov	 DWORD PTR tv5114[ebp], eax
  00e07	e8 00 00 00 00	 call	 ?getBlock@World@@QAEGHHH@Z ; World::getBlock
  00e0c	66 85 c0	 test	 ax, ax
  00e0f	74 0a		 je	 SHORT $LN24@renderChun

; 256  : 						{
; 257  : 							i2++;

  00e11	ff 45 d4	 inc	 DWORD PTR _i2$1$[ebp]

; 258  : 							i3++;

  00e14	c7 45 cc 01 00
	00 00		 mov	 DWORD PTR _i3$1$[ebp], 1
$LN24@renderChun:

; 259  : 						}
; 260  : 
; 261  : 						if(GlobalThread::world.getBlock(i | cx, (j | cy) + 1, (k | cz) + 1))

  00e1b	8b 75 bc	 mov	 esi, DWORD PTR tv5105[ebp]
  00e1e	56		 push	 esi
  00e1f	ff 75 e4	 push	 DWORD PTR tv5110[ebp]
  00e22	53		 push	 ebx
  00e23	e8 00 00 00 00	 call	 ?getBlock@World@@QAEGHHH@Z ; World::getBlock
  00e28	66 85 c0	 test	 ax, ax
  00e2b	74 06		 je	 SHORT $LN23@renderChun

; 262  : 						{
; 263  : 							i3++;

  00e2d	ff 45 cc	 inc	 DWORD PTR _i3$1$[ebp]

; 264  : 							i4++;

  00e30	ff 45 c8	 inc	 DWORD PTR _i4$1$[ebp]
$LN23@renderChun:

; 265  : 						}
; 266  : 
; 267  : 						if(i1 < 2 && GlobalThread::world.getBlock((i | cx) - 1, (j | cy) + 1, (k | cz) - 1))

  00e33	83 7d e8 02	 cmp	 DWORD PTR _i1$1$[ebp], 2
  00e37	8b 5d e4	 mov	 ebx, DWORD PTR tv5110[ebp]
  00e3a	7d 12		 jge	 SHORT $LN22@renderChun
  00e3c	57		 push	 edi
  00e3d	53		 push	 ebx
  00e3e	ff 75 b4	 push	 DWORD PTR tv5122[ebp]
  00e41	e8 00 00 00 00	 call	 ?getBlock@World@@QAEGHHH@Z ; World::getBlock
  00e46	66 85 c0	 test	 ax, ax
  00e49	74 03		 je	 SHORT $LN22@renderChun

; 268  : 						{
; 269  : 							i1++;

  00e4b	ff 45 e8	 inc	 DWORD PTR _i1$1$[ebp]
$LN22@renderChun:

; 270  : 						}
; 271  : 
; 272  : 						if(i2 < 2 && GlobalThread::world.getBlock((i | cx) + 1, (j | cy) + 1, (k | cz) - 1))

  00e4e	83 7d d4 02	 cmp	 DWORD PTR _i2$1$[ebp], 2
  00e52	7d 12		 jge	 SHORT $LN21@renderChun
  00e54	57		 push	 edi
  00e55	53		 push	 ebx
  00e56	ff 75 b0	 push	 DWORD PTR tv5114[ebp]
  00e59	e8 00 00 00 00	 call	 ?getBlock@World@@QAEGHHH@Z ; World::getBlock
  00e5e	66 85 c0	 test	 ax, ax
  00e61	74 03		 je	 SHORT $LN21@renderChun

; 273  : 						{
; 274  : 							i2++;

  00e63	ff 45 d4	 inc	 DWORD PTR _i2$1$[ebp]
$LN21@renderChun:

; 275  : 						}
; 276  : 								
; 277  : 						if(i3 < 2 && GlobalThread::world.getBlock((i | cx) + 1, (j | cy) + 1, (k | cz) + 1))

  00e66	8b 7d cc	 mov	 edi, DWORD PTR _i3$1$[ebp]
  00e69	83 ff 02	 cmp	 edi, 2
  00e6c	7d 13		 jge	 SHORT $LN20@renderChun
  00e6e	56		 push	 esi
  00e6f	53		 push	 ebx
  00e70	ff 75 b0	 push	 DWORD PTR tv5114[ebp]
  00e73	e8 00 00 00 00	 call	 ?getBlock@World@@QAEGHHH@Z ; World::getBlock
  00e78	66 85 c0	 test	 ax, ax
  00e7b	74 04		 je	 SHORT $LN20@renderChun

; 278  : 						{
; 279  : 							i3++;

  00e7d	47		 inc	 edi
  00e7e	89 7d cc	 mov	 DWORD PTR _i3$1$[ebp], edi
$LN20@renderChun:

; 280  : 						}
; 281  : 								
; 282  : 						if(i4 < 2 && GlobalThread::world.getBlock((i | cx) - 1, (j | cy) + 1, (k | cz) + 1))

  00e81	8b 7d c8	 mov	 edi, DWORD PTR _i4$1$[ebp]
  00e84	83 ff 02	 cmp	 edi, 2
  00e87	7d 10		 jge	 SHORT $LN19@renderChun
  00e89	56		 push	 esi
  00e8a	53		 push	 ebx
  00e8b	ff 75 b4	 push	 DWORD PTR tv5122[ebp]
  00e8e	e8 00 00 00 00	 call	 ?getBlock@World@@QAEGHHH@Z ; World::getBlock
  00e93	66 85 c0	 test	 ax, ax
  00e96	74 01		 je	 SHORT $LN19@renderChun

; 283  : 						{
; 284  : 							i4++;

  00e98	47		 inc	 edi
$LN19@renderChun:
  00e99	66 0f 6e 45 e8	 movd	 xmm0, DWORD PTR _i1$1$[ebp]

; 285  : 						}
; 286  : 
; 287  : 						float f1 = 1.0F - i1 * 0.1f;

  00e9e	f3 0f 10 1d 00
	00 00 00	 movss	 xmm3, DWORD PTR __real@3dcccccd
  00ea6	f3 0f 10 25 00
	00 00 00	 movss	 xmm4, DWORD PTR __real@3f800000
  00eae	0f 5b c0	 cvtdq2ps xmm0, xmm0

; 289  : 						float f3 = 1.0F - i3 * 0.1f;

  00eb1	8b 45 cc	 mov	 eax, DWORD PTR _i3$1$[ebp]
  00eb4	f3 0f 59 c3	 mulss	 xmm0, xmm3
  00eb8	0f 28 cc	 movaps	 xmm1, xmm4
  00ebb	0f 28 d4	 movaps	 xmm2, xmm4
  00ebe	f3 0f 5c c8	 subss	 xmm1, xmm0
  00ec2	66 0f 6e 45 d4	 movd	 xmm0, DWORD PTR _i2$1$[ebp]
  00ec7	0f 5b c0	 cvtdq2ps xmm0, xmm0
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp

; 70   : {}

  00eca	f3 0f 59 0d 00
	00 00 00	 mulss	 xmm1, DWORD PTR __real@437f0000
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp

; 288  : 						float f2 = 1.0F - i2 * 0.1f;

  00ed2	f3 0f 59 c3	 mulss	 xmm0, xmm3
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp

; 162  : 	vertex.u = u;

  00ed6	8b 4d f0	 mov	 ecx, DWORD PTR $T4[ebp]
  00ed9	0f 57 ed	 xorps	 xmm5, xmm5
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp

; 288  : 						float f2 = 1.0F - i2 * 0.1f;

  00edc	f3 0f 5c d0	 subss	 xmm2, xmm0
  00ee0	66 0f 6e c0	 movd	 xmm0, eax

; 289  : 						float f3 = 1.0F - i3 * 0.1f;

  00ee4	0f 5b c0	 cvtdq2ps xmm0, xmm0

; 292  : 						vStream->put(gfxu::VertexUVRGBA(i + 0.0f, j + 1.0f, k + 0.0f, 0.0f, 0.0f, f1, f1, f1, 1.0f));

  00ee7	8b 45 d8	 mov	 eax, DWORD PTR _i$1$[ebp]
  00eea	f3 0f 59 c3	 mulss	 xmm0, xmm3
  00eee	f3 0f 11 55 a8	 movss	 DWORD PTR _f2$1$[ebp], xmm2
  00ef3	0f 28 d4	 movaps	 xmm2, xmm4
  00ef6	f3 0f 5c d0	 subss	 xmm2, xmm0
  00efa	66 0f 6e c7	 movd	 xmm0, edi
  00efe	0f 5b c0	 cvtdq2ps xmm0, xmm0
  00f01	f3 0f 11 55 e8	 movss	 DWORD PTR _f3$1$[ebp], xmm2
  00f06	f3 0f 59 c3	 mulss	 xmm0, xmm3
  00f0a	0f 28 d4	 movaps	 xmm2, xmm4
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp

; 108  : 	vertex.x = x;

  00f0d	8d 79 10	 lea	 edi, DWORD PTR [ecx+16]
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp

; 290  : 						float f4 = 1.0F - i4 * 0.1f;

  00f10	f3 0f 5c d0	 subss	 xmm2, xmm0
  00f14	66 0f 6e c0	 movd	 xmm0, eax

; 292  : 						vStream->put(gfxu::VertexUVRGBA(i + 0.0f, j + 1.0f, k + 0.0f, 0.0f, 0.0f, f1, f1, f1, 1.0f));

  00f18	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  00f1c	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00f1f	f3 0f 11 55 d4	 movss	 DWORD PTR _f4$1$[ebp], xmm2
  00f24	f2 0f 58 04 c5
	00 00 00 00	 addsd	 xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
  00f2d	8b 45 dc	 mov	 eax, DWORD PTR _j$1$[ebp]
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp

; 112  : 	vertices.push_back(vertex);

  00f30	8d 71 04	 lea	 esi, DWORD PTR [ecx+4]

; 162  : 	vertex.u = u;

  00f33	c7 41 1c 00 00
	00 00		 mov	 DWORD PTR [ecx+28], 0

; 163  : 	vertex.v = v;

  00f3a	c7 41 20 00 00
	00 00		 mov	 DWORD PTR [ecx+32], 0
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp

; 292  : 						vStream->put(gfxu::VertexUVRGBA(i + 0.0f, j + 1.0f, k + 0.0f, 0.0f, 0.0f, f1, f1, f1, 1.0f));

  00f41	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp

; 112  : 	vertices.push_back(vertex);

  00f45	57		 push	 edi
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp

; 292  : 						vStream->put(gfxu::VertexUVRGBA(i + 0.0f, j + 1.0f, k + 0.0f, 0.0f, 0.0f, f1, f1, f1, 1.0f));

  00f46	0f 28 d8	 movaps	 xmm3, xmm0
  00f49	f3 0f 11 45 cc	 movss	 DWORD PTR tv4788[ebp], xmm0
  00f4e	66 0f 6e c0	 movd	 xmm0, eax
  00f52	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  00f56	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00f59	f3 0f 58 dd	 addss	 xmm3, xmm5
  00f5d	f2 0f 58 04 c5
	00 00 00 00	 addsd	 xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
  00f66	8b 45 e0	 mov	 eax, DWORD PTR _k$1$[ebp]
  00f69	f3 0f 11 5d b4	 movss	 DWORD PTR tv4791[ebp], xmm3
  00f6e	66 0f 5a d0	 cvtpd2ps xmm2, xmm0
  00f72	66 0f 6e c0	 movd	 xmm0, eax
  00f76	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  00f7a	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00f7d	f3 0f 58 d4	 addss	 xmm2, xmm4
  00f81	f2 0f 58 04 c5
	00 00 00 00	 addsd	 xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp

; 70   : {}

  00f8a	f3 0f 2c c1	 cvttss2si eax, xmm1
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp

; 292  : 						vStream->put(gfxu::VertexUVRGBA(i + 0.0f, j + 1.0f, k + 0.0f, 0.0f, 0.0f, f1, f1, f1, 1.0f));

  00f8e	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp

; 156  : 	vertex.r = r;

  00f92	88 41 24	 mov	 BYTE PTR [ecx+36], al
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp

; 292  : 						vStream->put(gfxu::VertexUVRGBA(i + 0.0f, j + 1.0f, k + 0.0f, 0.0f, 0.0f, f1, f1, f1, 1.0f));

  00f95	f3 0f 11 45 d0	 movss	 DWORD PTR tv4793[ebp], xmm0
  00f9a	f3 0f 58 c5	 addss	 xmm0, xmm5
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp

; 157  : 	vertex.g = g;

  00f9e	88 41 25	 mov	 BYTE PTR [ecx+37], al

; 158  : 	vertex.b = b;

  00fa1	88 41 26	 mov	 BYTE PTR [ecx+38], al

; 109  : 	vertex.y = y;

  00fa4	f3 0f 11 51 14	 movss	 DWORD PTR [ecx+20], xmm2
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp

; 292  : 						vStream->put(gfxu::VertexUVRGBA(i + 0.0f, j + 1.0f, k + 0.0f, 0.0f, 0.0f, f1, f1, f1, 1.0f));

  00fa9	f3 0f 11 55 c8	 movss	 DWORD PTR tv4792[ebp], xmm2
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp

; 110  : 	vertex.z = z;

  00fae	f3 0f 11 41 18	 movss	 DWORD PTR [ecx+24], xmm0

; 112  : 	vertices.push_back(vertex);

  00fb3	8b ce		 mov	 ecx, esi
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp

; 292  : 						vStream->put(gfxu::VertexUVRGBA(i + 0.0f, j + 1.0f, k + 0.0f, 0.0f, 0.0f, f1, f1, f1, 1.0f));

  00fb5	f3 0f 11 45 b0	 movss	 DWORD PTR tv4784[ebp], xmm0
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp

; 108  : 	vertex.x = x;

  00fba	f3 0f 11 1f	 movss	 DWORD PTR [edi], xmm3

; 112  : 	vertices.push_back(vertex);

  00fbe	e8 00 00 00 00	 call	 ?push_back@?$vector@VVertexUVRGBA@gfxu@@V?$allocator@VVertexUVRGBA@gfxu@@@std@@@std@@QAEXABVVertexUVRGBA@gfxu@@@Z ; std::vector<gfxu::VertexUVRGBA,std::allocator<gfxu::VertexUVRGBA> >::push_back

; 70   : {}

  00fc3	f3 0f 10 45 a8	 movss	 xmm0, DWORD PTR _f2$1$[ebp]
  00fc8	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp

; 293  : 						vStream->put(gfxu::VertexUVRGBA(i + 1.0f, j + 1.0f, k + 0.0f, 1.0f, 0.0f, f2, f2, f2, 1.0f));

  00fd0	f3 0f 10 4d cc	 movss	 xmm1, DWORD PTR tv4788[ebp]
  00fd5	f3 0f 58 0d 00
	00 00 00	 addss	 xmm1, DWORD PTR __real@3f800000
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp

; 162  : 	vertex.u = u;

  00fdd	8b 45 f0	 mov	 eax, DWORD PTR $T4[ebp]

; 114  : 	vs++;

  00fe0	ff 05 00 00 00
	00		 inc	 DWORD PTR ?vs@@3HA	; vs

; 70   : {}

  00fe6	f3 0f 2c d8	 cvttss2si ebx, xmm0
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp

; 293  : 						vStream->put(gfxu::VertexUVRGBA(i + 1.0f, j + 1.0f, k + 0.0f, 1.0f, 0.0f, f2, f2, f2, 1.0f));

  00fea	f3 0f 11 4d cc	 movss	 DWORD PTR tv4788[ebp], xmm1
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp

; 162  : 	vertex.u = u;

  00fef	c7 40 1c 00 00
	80 3f		 mov	 DWORD PTR [eax+28], 1065353216 ; 3f800000H

; 163  : 	vertex.v = v;

  00ff6	c7 40 20 00 00
	00 00		 mov	 DWORD PTR [eax+32], 0

; 156  : 	vertex.r = r;

  00ffd	88 58 24	 mov	 BYTE PTR [eax+36], bl

; 109  : 	vertex.y = y;

  01000	f3 0f 10 45 c8	 movss	 xmm0, DWORD PTR tv4792[ebp]
  01005	f3 0f 11 40 14	 movss	 DWORD PTR [eax+20], xmm0

; 110  : 	vertex.z = z;

  0100a	f3 0f 10 45 b0	 movss	 xmm0, DWORD PTR tv4784[ebp]

; 112  : 	vertices.push_back(vertex);

  0100f	57		 push	 edi
  01010	8b ce		 mov	 ecx, esi

; 157  : 	vertex.g = g;

  01012	88 58 25	 mov	 BYTE PTR [eax+37], bl

; 158  : 	vertex.b = b;

  01015	88 58 26	 mov	 BYTE PTR [eax+38], bl

; 108  : 	vertex.x = x;

  01018	f3 0f 11 0f	 movss	 DWORD PTR [edi], xmm1

; 110  : 	vertex.z = z;

  0101c	f3 0f 11 40 18	 movss	 DWORD PTR [eax+24], xmm0

; 112  : 	vertices.push_back(vertex);

  01021	e8 00 00 00 00	 call	 ?push_back@?$vector@VVertexUVRGBA@gfxu@@V?$allocator@VVertexUVRGBA@gfxu@@@std@@@std@@QAEXABVVertexUVRGBA@gfxu@@@Z ; std::vector<gfxu::VertexUVRGBA,std::allocator<gfxu::VertexUVRGBA> >::push_back

; 70   : {}

  01026	f3 0f 10 45 d4	 movss	 xmm0, DWORD PTR _f4$1$[ebp]
  0102b	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp

; 294  : 						vStream->put(gfxu::VertexUVRGBA(i + 0.0f, j + 1.0f, k + 1.0f, 0.0f, 1.0f, f4, f4, f4, 1.0f));

  01033	f3 0f 10 4d d0	 movss	 xmm1, DWORD PTR tv4793[ebp]
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp

; 162  : 	vertex.u = u;

  01038	8b 4d f0	 mov	 ecx, DWORD PTR $T4[ebp]
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp

; 294  : 						vStream->put(gfxu::VertexUVRGBA(i + 0.0f, j + 1.0f, k + 1.0f, 0.0f, 1.0f, f4, f4, f4, 1.0f));

  0103b	f3 0f 58 0d 00
	00 00 00	 addss	 xmm1, DWORD PTR __real@3f800000
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp

; 114  : 	vs++;

  01043	ff 05 00 00 00
	00		 inc	 DWORD PTR ?vs@@3HA	; vs

; 70   : {}

  01049	f3 0f 2c c0	 cvttss2si eax, xmm0

; 108  : 	vertex.x = x;

  0104d	f3 0f 10 45 b4	 movss	 xmm0, DWORD PTR tv4791[ebp]
  01052	f3 0f 11 07	 movss	 DWORD PTR [edi], xmm0

; 109  : 	vertex.y = y;

  01056	f3 0f 10 45 c8	 movss	 xmm0, DWORD PTR tv4792[ebp]

; 162  : 	vertex.u = u;

  0105b	c7 41 1c 00 00
	00 00		 mov	 DWORD PTR [ecx+28], 0

; 163  : 	vertex.v = v;

  01062	c7 41 20 00 00
	80 3f		 mov	 DWORD PTR [ecx+32], 1065353216 ; 3f800000H

; 156  : 	vertex.r = r;

  01069	88 41 24	 mov	 BYTE PTR [ecx+36], al

; 157  : 	vertex.g = g;

  0106c	88 41 25	 mov	 BYTE PTR [ecx+37], al

; 158  : 	vertex.b = b;

  0106f	88 41 26	 mov	 BYTE PTR [ecx+38], al

; 109  : 	vertex.y = y;

  01072	f3 0f 11 41 14	 movss	 DWORD PTR [ecx+20], xmm0

; 110  : 	vertex.z = z;

  01077	f3 0f 11 49 18	 movss	 DWORD PTR [ecx+24], xmm1

; 112  : 	vertices.push_back(vertex);

  0107c	57		 push	 edi
  0107d	8b ce		 mov	 ecx, esi
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp

; 294  : 						vStream->put(gfxu::VertexUVRGBA(i + 0.0f, j + 1.0f, k + 1.0f, 0.0f, 1.0f, f4, f4, f4, 1.0f));

  0107f	f3 0f 11 4d d0	 movss	 DWORD PTR tv4793[ebp], xmm1
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp

; 70   : {}

  01084	89 45 a8	 mov	 DWORD PTR tv4778[ebp], eax

; 112  : 	vertices.push_back(vertex);

  01087	e8 00 00 00 00	 call	 ?push_back@?$vector@VVertexUVRGBA@gfxu@@V?$allocator@VVertexUVRGBA@gfxu@@@std@@@std@@QAEXABVVertexUVRGBA@gfxu@@@Z ; std::vector<gfxu::VertexUVRGBA,std::allocator<gfxu::VertexUVRGBA> >::push_back

; 162  : 	vertex.u = u;

  0108c	8b 45 f0	 mov	 eax, DWORD PTR $T4[ebp]

; 108  : 	vertex.x = x;

  0108f	f3 0f 10 45 cc	 movss	 xmm0, DWORD PTR tv4788[ebp]

; 114  : 	vs++;

  01094	ff 05 00 00 00
	00		 inc	 DWORD PTR ?vs@@3HA	; vs

; 156  : 	vertex.r = r;

  0109a	88 58 24	 mov	 BYTE PTR [eax+36], bl

; 157  : 	vertex.g = g;

  0109d	88 58 25	 mov	 BYTE PTR [eax+37], bl

; 158  : 	vertex.b = b;

  010a0	88 58 26	 mov	 BYTE PTR [eax+38], bl

; 108  : 	vertex.x = x;

  010a3	f3 0f 11 07	 movss	 DWORD PTR [edi], xmm0

; 109  : 	vertex.y = y;

  010a7	f3 0f 10 45 c8	 movss	 xmm0, DWORD PTR tv4792[ebp]
  010ac	8b d8		 mov	 ebx, eax

; 112  : 	vertices.push_back(vertex);

  010ae	57		 push	 edi
  010af	f3 0f 11 43 14	 movss	 DWORD PTR [ebx+20], xmm0
  010b4	f3 0f 10 45 b0	 movss	 xmm0, DWORD PTR tv4784[ebp]
  010b9	8b ce		 mov	 ecx, esi

; 162  : 	vertex.u = u;

  010bb	c7 40 1c 00 00
	80 3f		 mov	 DWORD PTR [eax+28], 1065353216 ; 3f800000H

; 163  : 	vertex.v = v;

  010c2	c7 40 20 00 00
	00 00		 mov	 DWORD PTR [eax+32], 0

; 110  : 	vertex.z = z;

  010c9	f3 0f 11 43 18	 movss	 DWORD PTR [ebx+24], xmm0

; 112  : 	vertices.push_back(vertex);

  010ce	e8 00 00 00 00	 call	 ?push_back@?$vector@VVertexUVRGBA@gfxu@@V?$allocator@VVertexUVRGBA@gfxu@@@std@@@std@@QAEXABVVertexUVRGBA@gfxu@@@Z ; std::vector<gfxu::VertexUVRGBA,std::allocator<gfxu::VertexUVRGBA> >::push_back

; 70   : {}

  010d3	f3 0f 10 45 e8	 movss	 xmm0, DWORD PTR _f3$1$[ebp]
  010d8	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000

; 114  : 	vs++;

  010e0	ff 05 00 00 00
	00		 inc	 DWORD PTR ?vs@@3HA	; vs

; 112  : 	vertices.push_back(vertex);

  010e6	57		 push	 edi

; 70   : {}

  010e7	f3 0f 2c c0	 cvttss2si eax, xmm0

; 108  : 	vertex.x = x;

  010eb	f3 0f 10 45 cc	 movss	 xmm0, DWORD PTR tv4788[ebp]
  010f0	f3 0f 11 07	 movss	 DWORD PTR [edi], xmm0

; 109  : 	vertex.y = y;

  010f4	f3 0f 10 45 c8	 movss	 xmm0, DWORD PTR tv4792[ebp]
  010f9	f3 0f 11 43 14	 movss	 DWORD PTR [ebx+20], xmm0

; 110  : 	vertex.z = z;

  010fe	f3 0f 10 45 d0	 movss	 xmm0, DWORD PTR tv4793[ebp]

; 112  : 	vertices.push_back(vertex);

  01103	8b ce		 mov	 ecx, esi

; 162  : 	vertex.u = u;

  01105	c7 43 1c 00 00
	80 3f		 mov	 DWORD PTR [ebx+28], 1065353216 ; 3f800000H

; 163  : 	vertex.v = v;

  0110c	c7 43 20 00 00
	80 3f		 mov	 DWORD PTR [ebx+32], 1065353216 ; 3f800000H

; 156  : 	vertex.r = r;

  01113	88 43 24	 mov	 BYTE PTR [ebx+36], al

; 157  : 	vertex.g = g;

  01116	88 43 25	 mov	 BYTE PTR [ebx+37], al

; 158  : 	vertex.b = b;

  01119	88 43 26	 mov	 BYTE PTR [ebx+38], al

; 110  : 	vertex.z = z;

  0111c	f3 0f 11 43 18	 movss	 DWORD PTR [ebx+24], xmm0

; 112  : 	vertices.push_back(vertex);

  01121	e8 00 00 00 00	 call	 ?push_back@?$vector@VVertexUVRGBA@gfxu@@V?$allocator@VVertexUVRGBA@gfxu@@@std@@@std@@QAEXABVVertexUVRGBA@gfxu@@@Z ; std::vector<gfxu::VertexUVRGBA,std::allocator<gfxu::VertexUVRGBA> >::push_back

; 108  : 	vertex.x = x;

  01126	f3 0f 10 45 b4	 movss	 xmm0, DWORD PTR tv4791[ebp]

; 156  : 	vertex.r = r;

  0112b	8b 45 a8	 mov	 eax, DWORD PTR tv4778[ebp]

; 114  : 	vs++;

  0112e	ff 05 00 00 00
	00		 inc	 DWORD PTR ?vs@@3HA	; vs

; 108  : 	vertex.x = x;

  01134	f3 0f 11 07	 movss	 DWORD PTR [edi], xmm0

; 109  : 	vertex.y = y;

  01138	f3 0f 10 45 c8	 movss	 xmm0, DWORD PTR tv4792[ebp]
  0113d	f3 0f 11 43 14	 movss	 DWORD PTR [ebx+20], xmm0

; 110  : 	vertex.z = z;

  01142	f3 0f 10 45 d0	 movss	 xmm0, DWORD PTR tv4793[ebp]

; 162  : 	vertex.u = u;

  01147	c7 43 1c 00 00
	00 00		 mov	 DWORD PTR [ebx+28], 0

; 163  : 	vertex.v = v;

  0114e	c7 43 20 00 00
	80 3f		 mov	 DWORD PTR [ebx+32], 1065353216 ; 3f800000H

; 156  : 	vertex.r = r;

  01155	88 43 24	 mov	 BYTE PTR [ebx+36], al

; 157  : 	vertex.g = g;

  01158	88 43 25	 mov	 BYTE PTR [ebx+37], al

; 158  : 	vertex.b = b;

  0115b	88 43 26	 mov	 BYTE PTR [ebx+38], al

; 110  : 	vertex.z = z;

  0115e	f3 0f 11 43 18	 movss	 DWORD PTR [ebx+24], xmm0

; 112  : 	vertices.push_back(vertex);

  01163	57		 push	 edi
  01164	8b ce		 mov	 ecx, esi
  01166	e8 00 00 00 00	 call	 ?push_back@?$vector@VVertexUVRGBA@gfxu@@V?$allocator@VVertexUVRGBA@gfxu@@@std@@@std@@QAEXABVVertexUVRGBA@gfxu@@@Z ; std::vector<gfxu::VertexUVRGBA,std::allocator<gfxu::VertexUVRGBA> >::push_back

; 114  : 	vs++;

  0116b	ff 05 00 00 00
	00		 inc	 DWORD PTR ?vs@@3HA	; vs
  01171	8b 5d c4	 mov	 ebx, DWORD PTR tv5127[ebp]
  01174	8b 7d c0	 mov	 edi, DWORD PTR tv5128[ebp]
  01177	8b 75 ec	 mov	 esi, DWORD PTR tv5129[ebp]
$LN436@renderChun:
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp

; 300  : 					if(!GlobalThread::world.getBlock((i | cx) - 1, j | cy, k | cz))

  0117a	56		 push	 esi
  0117b	8d 43 ff	 lea	 eax, DWORD PTR [ebx-1]
  0117e	57		 push	 edi
  0117f	50		 push	 eax
  01180	89 45 e8	 mov	 DWORD PTR tv5121[ebp], eax
  01183	e8 00 00 00 00	 call	 ?getBlock@World@@QAEGHHH@Z ; World::getBlock
  01188	66 85 c0	 test	 ax, ax
  0118b	0f 85 e3 03 00
	00		 jne	 $LN496@renderChun

; 301  : 					{
; 302  : 						int i1 = 0;
; 303  : 						int i2 = 0;
; 304  : 						int i3 = 0;
; 305  : 						int i4 = 0;
; 306  : 
; 307  : 						if(GlobalThread::world.getBlock((i | cx) - 1, (j | cy) - 1, k | cz))

  01191	56		 push	 esi
  01192	8d 47 ff	 lea	 eax, DWORD PTR [edi-1]
  01195	50		 push	 eax
  01196	ff 75 e8	 push	 DWORD PTR tv5121[ebp]
  01199	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _i1$1$[ebp], 0
  011a0	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR _i2$1$[ebp], 0
  011a7	c7 45 cc 00 00
	00 00		 mov	 DWORD PTR _i3$1$[ebp], 0
  011ae	c7 45 c8 00 00
	00 00		 mov	 DWORD PTR _i4$1$[ebp], 0
  011b5	e8 00 00 00 00	 call	 ?getBlock@World@@QAEGHHH@Z ; World::getBlock
  011ba	66 85 c0	 test	 ax, ax
  011bd	74 0e		 je	 SHORT $LN17@renderChun

; 308  : 						{
; 309  : 							i1++;

  011bf	c7 45 d4 01 00
	00 00		 mov	 DWORD PTR _i1$1$[ebp], 1

; 310  : 							i4++;

  011c6	c7 45 c8 01 00
	00 00		 mov	 DWORD PTR _i4$1$[ebp], 1
$LN17@renderChun:

; 311  : 						}
; 312  : 
; 313  : 						if(GlobalThread::world.getBlock((i | cx) - 1, j | cy, (k | cz) - 1))

  011cd	8b 5d ec	 mov	 ebx, DWORD PTR tv5129[ebp]
  011d0	8d 73 ff	 lea	 esi, DWORD PTR [ebx-1]
  011d3	56		 push	 esi
  011d4	57		 push	 edi
  011d5	ff 75 e8	 push	 DWORD PTR tv5121[ebp]
  011d8	e8 00 00 00 00	 call	 ?getBlock@World@@QAEGHHH@Z ; World::getBlock
  011dd	66 85 c0	 test	 ax, ax
  011e0	74 0a		 je	 SHORT $LN16@renderChun

; 314  : 						{
; 315  : 							i1++;

  011e2	ff 45 d4	 inc	 DWORD PTR _i1$1$[ebp]

; 316  : 							i2++;

  011e5	c7 45 d0 01 00
	00 00		 mov	 DWORD PTR _i2$1$[ebp], 1
$LN16@renderChun:

; 317  : 						}
; 318  : 
; 319  : 						if(GlobalThread::world.getBlock((i | cx) - 1, (j | cy) + 1, k | cz))

  011ec	53		 push	 ebx
  011ed	8d 47 01	 lea	 eax, DWORD PTR [edi+1]
  011f0	50		 push	 eax
  011f1	ff 75 e8	 push	 DWORD PTR tv5121[ebp]
  011f4	e8 00 00 00 00	 call	 ?getBlock@World@@QAEGHHH@Z ; World::getBlock
  011f9	66 85 c0	 test	 ax, ax
  011fc	74 0a		 je	 SHORT $LN15@renderChun

; 320  : 						{
; 321  : 							i2++;

  011fe	ff 45 d0	 inc	 DWORD PTR _i2$1$[ebp]

; 322  : 							i3++;

  01201	c7 45 cc 01 00
	00 00		 mov	 DWORD PTR _i3$1$[ebp], 1
$LN15@renderChun:

; 323  : 						}
; 324  : 
; 325  : 						if(GlobalThread::world.getBlock((i | cx) - 1, j | cy, (k | cz) + 1))

  01208	8b 5d bc	 mov	 ebx, DWORD PTR tv5105[ebp]
  0120b	53		 push	 ebx
  0120c	57		 push	 edi
  0120d	ff 75 e8	 push	 DWORD PTR tv5121[ebp]
  01210	e8 00 00 00 00	 call	 ?getBlock@World@@QAEGHHH@Z ; World::getBlock
  01215	66 85 c0	 test	 ax, ax
  01218	74 06		 je	 SHORT $LN14@renderChun

; 326  : 						{
; 327  : 							i3++;

  0121a	ff 45 cc	 inc	 DWORD PTR _i3$1$[ebp]

; 328  : 							i4++;

  0121d	ff 45 c8	 inc	 DWORD PTR _i4$1$[ebp]
$LN14@renderChun:

; 329  : 						}
; 330  : 
; 331  : 						if(i1 < 2 && GlobalThread::world.getBlock((i | cx) - 1, (j | cy) - 1, (k | cz) - 1))

  01220	83 7d d4 02	 cmp	 DWORD PTR _i1$1$[ebp], 2
  01224	7d 15		 jge	 SHORT $LN13@renderChun
  01226	56		 push	 esi
  01227	8d 47 ff	 lea	 eax, DWORD PTR [edi-1]
  0122a	50		 push	 eax
  0122b	ff 75 e8	 push	 DWORD PTR tv5121[ebp]
  0122e	e8 00 00 00 00	 call	 ?getBlock@World@@QAEGHHH@Z ; World::getBlock
  01233	66 85 c0	 test	 ax, ax
  01236	74 03		 je	 SHORT $LN13@renderChun

; 332  : 						{
; 333  : 							i1++;

  01238	ff 45 d4	 inc	 DWORD PTR _i1$1$[ebp]
$LN13@renderChun:

; 334  : 						}
; 335  : 
; 336  : 						if(i2 < 2 && GlobalThread::world.getBlock((i | cx) - 1, (j | cy) + 1, (k | cz) - 1))

  0123b	83 7d d0 02	 cmp	 DWORD PTR _i2$1$[ebp], 2
  0123f	7d 17		 jge	 SHORT $LN712@renderChun
  01241	56		 push	 esi
  01242	8d 77 01	 lea	 esi, DWORD PTR [edi+1]
  01245	56		 push	 esi
  01246	ff 75 e8	 push	 DWORD PTR tv5121[ebp]
  01249	e8 00 00 00 00	 call	 ?getBlock@World@@QAEGHHH@Z ; World::getBlock
  0124e	66 85 c0	 test	 ax, ax
  01251	74 08		 je	 SHORT $LN12@renderChun

; 337  : 						{
; 338  : 							i2++;

  01253	ff 45 d0	 inc	 DWORD PTR _i2$1$[ebp]
  01256	eb 03		 jmp	 SHORT $LN12@renderChun
$LN712@renderChun:
  01258	8b 75 e4	 mov	 esi, DWORD PTR tv5110[ebp]
$LN12@renderChun:

; 339  : 						}
; 340  : 								
; 341  : 						if(i3 < 2 && GlobalThread::world.getBlock((i | cx) - 1, (j | cy) + 1, (k | cz) + 1))

  0125b	83 7d cc 02	 cmp	 DWORD PTR _i3$1$[ebp], 2
  0125f	7d 15		 jge	 SHORT $LN717@renderChun
  01261	53		 push	 ebx
  01262	56		 push	 esi
  01263	8b 75 e8	 mov	 esi, DWORD PTR tv5121[ebp]
  01266	56		 push	 esi
  01267	e8 00 00 00 00	 call	 ?getBlock@World@@QAEGHHH@Z ; World::getBlock
  0126c	66 85 c0	 test	 ax, ax
  0126f	74 08		 je	 SHORT $LN11@renderChun

; 342  : 						{
; 343  : 							i3++;

  01271	ff 45 cc	 inc	 DWORD PTR _i3$1$[ebp]
  01274	eb 03		 jmp	 SHORT $LN11@renderChun
$LN717@renderChun:
  01276	8b 75 e8	 mov	 esi, DWORD PTR tv5121[ebp]
$LN11@renderChun:

; 344  : 						}
; 345  : 								
; 346  : 						if(i4 < 2 && GlobalThread::world.getBlock((i | cx) - 1, (j | cy) - 1, (k | cz) + 1))

  01279	8b 45 c8	 mov	 eax, DWORD PTR _i4$1$[ebp]
  0127c	83 f8 02	 cmp	 eax, 2
  0127f	7d 14		 jge	 SHORT $LN10@renderChun
  01281	53		 push	 ebx
  01282	8d 47 ff	 lea	 eax, DWORD PTR [edi-1]
  01285	50		 push	 eax
  01286	56		 push	 esi
  01287	e8 00 00 00 00	 call	 ?getBlock@World@@QAEGHHH@Z ; World::getBlock
  0128c	66 85 c0	 test	 ax, ax

; 347  : 						{
; 348  : 							i4++;

  0128f	8b 45 c8	 mov	 eax, DWORD PTR _i4$1$[ebp]
  01292	74 01		 je	 SHORT $LN10@renderChun
  01294	40		 inc	 eax
$LN10@renderChun:
  01295	66 0f 6e 45 d4	 movd	 xmm0, DWORD PTR _i1$1$[ebp]

; 351  : 						float f1 = 1.0F - i1 * 0.1f;

  0129a	f3 0f 10 25 00
	00 00 00	 movss	 xmm4, DWORD PTR __real@3dcccccd
  012a2	f3 0f 10 1d 00
	00 00 00	 movss	 xmm3, DWORD PTR __real@3f800000
  012aa	0f 5b c0	 cvtdq2ps xmm0, xmm0
  012ad	0f 28 cb	 movaps	 xmm1, xmm3
  012b0	f3 0f 59 c4	 mulss	 xmm0, xmm4

; 352  : 						float f2 = 1.0F - i2 * 0.1f;

  012b4	0f 28 d3	 movaps	 xmm2, xmm3
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp

; 162  : 	vertex.u = u;

  012b7	8b 4d f0	 mov	 ecx, DWORD PTR $T4[ebp]
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp

; 351  : 						float f1 = 1.0F - i1 * 0.1f;

  012ba	f3 0f 5c c8	 subss	 xmm1, xmm0
  012be	66 0f 6e 45 d0	 movd	 xmm0, DWORD PTR _i2$1$[ebp]

; 352  : 						float f2 = 1.0F - i2 * 0.1f;

  012c3	0f 5b c0	 cvtdq2ps xmm0, xmm0
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp

; 70   : {}

  012c6	f3 0f 59 0d 00
	00 00 00	 mulss	 xmm1, DWORD PTR __real@437f0000
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp

; 352  : 						float f2 = 1.0F - i2 * 0.1f;

  012ce	f3 0f 59 c4	 mulss	 xmm0, xmm4
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp

; 108  : 	vertex.x = x;

  012d2	8d 79 10	 lea	 edi, DWORD PTR [ecx+16]

; 112  : 	vertices.push_back(vertex);

  012d5	8d 71 04	 lea	 esi, DWORD PTR [ecx+4]
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp

; 352  : 						float f2 = 1.0F - i2 * 0.1f;

  012d8	f3 0f 5c d0	 subss	 xmm2, xmm0
  012dc	66 0f 6e 45 cc	 movd	 xmm0, DWORD PTR _i3$1$[ebp]

; 353  : 						float f3 = 1.0F - i3 * 0.1f;

  012e1	0f 5b c0	 cvtdq2ps xmm0, xmm0
  012e4	f3 0f 11 55 a8	 movss	 DWORD PTR _f2$1$[ebp], xmm2
  012e9	f3 0f 59 c4	 mulss	 xmm0, xmm4
  012ed	0f 28 d3	 movaps	 xmm2, xmm3
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp

; 162  : 	vertex.u = u;

  012f0	c7 41 1c 00 00
	80 3f		 mov	 DWORD PTR [ecx+28], 1065353216 ; 3f800000H
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp

; 353  : 						float f3 = 1.0F - i3 * 0.1f;

  012f7	f3 0f 5c d0	 subss	 xmm2, xmm0
  012fb	66 0f 6e c0	 movd	 xmm0, eax

; 356  : 						vStream->put(gfxu::VertexUVRGBA(i + 0.0f, j + 0.0f, k + 0.0f, 1.0f, 0.0f, f1, f1, f1, 1.0f));

  012ff	8b 45 d8	 mov	 eax, DWORD PTR _i$1$[ebp]
  01302	0f 5b c0	 cvtdq2ps xmm0, xmm0
  01305	f3 0f 11 55 e8	 movss	 DWORD PTR _f3$1$[ebp], xmm2
  0130a	f3 0f 59 c4	 mulss	 xmm0, xmm4
  0130e	0f 28 d3	 movaps	 xmm2, xmm3
  01311	0f 57 e4	 xorps	 xmm4, xmm4
  01314	f3 0f 5c d0	 subss	 xmm2, xmm0
  01318	66 0f 6e c0	 movd	 xmm0, eax
  0131c	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  01320	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  01323	f3 0f 11 55 d4	 movss	 DWORD PTR _f4$1$[ebp], xmm2
  01328	f2 0f 58 04 c5
	00 00 00 00	 addsd	 xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
  01331	8b 45 dc	 mov	 eax, DWORD PTR _j$1$[ebp]
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp

; 163  : 	vertex.v = v;

  01334	c7 41 20 00 00
	00 00		 mov	 DWORD PTR [ecx+32], 0

; 112  : 	vertices.push_back(vertex);

  0133b	57		 push	 edi
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp

; 356  : 						vStream->put(gfxu::VertexUVRGBA(i + 0.0f, j + 0.0f, k + 0.0f, 1.0f, 0.0f, f1, f1, f1, 1.0f));

  0133c	66 0f 5a d8	 cvtpd2ps xmm3, xmm0
  01340	66 0f 6e c0	 movd	 xmm0, eax
  01344	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  01348	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0134b	f3 0f 58 dc	 addss	 xmm3, xmm4
  0134f	f2 0f 58 04 c5
	00 00 00 00	 addsd	 xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
  01358	8b 45 e0	 mov	 eax, DWORD PTR _k$1$[ebp]
  0135b	f3 0f 11 5d c8	 movss	 DWORD PTR tv4848[ebp], xmm3
  01360	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp

; 108  : 	vertex.x = x;

  01364	f3 0f 11 1f	 movss	 DWORD PTR [edi], xmm3
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp

; 356  : 						vStream->put(gfxu::VertexUVRGBA(i + 0.0f, j + 0.0f, k + 0.0f, 1.0f, 0.0f, f1, f1, f1, 1.0f));

  01368	0f 28 d0	 movaps	 xmm2, xmm0
  0136b	f3 0f 11 45 cc	 movss	 DWORD PTR tv4846[ebp], xmm0
  01370	66 0f 6e c0	 movd	 xmm0, eax
  01374	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  01378	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0137b	f3 0f 58 d4	 addss	 xmm2, xmm4
  0137f	f2 0f 58 04 c5
	00 00 00 00	 addsd	 xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp

; 70   : {}

  01388	f3 0f 2c c1	 cvttss2si eax, xmm1
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp

; 356  : 						vStream->put(gfxu::VertexUVRGBA(i + 0.0f, j + 0.0f, k + 0.0f, 1.0f, 0.0f, f1, f1, f1, 1.0f));

  0138c	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp

; 156  : 	vertex.r = r;

  01390	88 41 24	 mov	 BYTE PTR [ecx+36], al
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp

; 356  : 						vStream->put(gfxu::VertexUVRGBA(i + 0.0f, j + 0.0f, k + 0.0f, 1.0f, 0.0f, f1, f1, f1, 1.0f));

  01393	f3 0f 11 45 d0	 movss	 DWORD PTR tv4850[ebp], xmm0
  01398	f3 0f 58 c4	 addss	 xmm0, xmm4
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp

; 157  : 	vertex.g = g;

  0139c	88 41 25	 mov	 BYTE PTR [ecx+37], al

; 158  : 	vertex.b = b;

  0139f	88 41 26	 mov	 BYTE PTR [ecx+38], al

; 109  : 	vertex.y = y;

  013a2	f3 0f 11 51 14	 movss	 DWORD PTR [ecx+20], xmm2
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp

; 356  : 						vStream->put(gfxu::VertexUVRGBA(i + 0.0f, j + 0.0f, k + 0.0f, 1.0f, 0.0f, f1, f1, f1, 1.0f));

  013a7	f3 0f 11 55 b4	 movss	 DWORD PTR tv4849[ebp], xmm2
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp

; 110  : 	vertex.z = z;

  013ac	f3 0f 11 41 18	 movss	 DWORD PTR [ecx+24], xmm0

; 112  : 	vertices.push_back(vertex);

  013b1	8b ce		 mov	 ecx, esi
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp

; 356  : 						vStream->put(gfxu::VertexUVRGBA(i + 0.0f, j + 0.0f, k + 0.0f, 1.0f, 0.0f, f1, f1, f1, 1.0f));

  013b3	f3 0f 11 45 b0	 movss	 DWORD PTR tv4841[ebp], xmm0
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp

; 112  : 	vertices.push_back(vertex);

  013b8	e8 00 00 00 00	 call	 ?push_back@?$vector@VVertexUVRGBA@gfxu@@V?$allocator@VVertexUVRGBA@gfxu@@@std@@@std@@QAEXABVVertexUVRGBA@gfxu@@@Z ; std::vector<gfxu::VertexUVRGBA,std::allocator<gfxu::VertexUVRGBA> >::push_back

; 70   : {}

  013bd	f3 0f 10 45 a8	 movss	 xmm0, DWORD PTR _f2$1$[ebp]
  013c2	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp

; 357  : 						vStream->put(gfxu::VertexUVRGBA(i + 0.0f, j + 1.0f, k + 0.0f, 1.0f, 1.0f, f2, f2, f2, 1.0f));

  013ca	f3 0f 10 4d cc	 movss	 xmm1, DWORD PTR tv4846[ebp]
  013cf	f3 0f 58 0d 00
	00 00 00	 addss	 xmm1, DWORD PTR __real@3f800000
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp

; 162  : 	vertex.u = u;

  013d7	8b 45 f0	 mov	 eax, DWORD PTR $T4[ebp]

; 114  : 	vs++;

  013da	ff 05 00 00 00
	00		 inc	 DWORD PTR ?vs@@3HA	; vs

; 70   : {}

  013e0	f3 0f 2c d8	 cvttss2si ebx, xmm0
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp

; 357  : 						vStream->put(gfxu::VertexUVRGBA(i + 0.0f, j + 1.0f, k + 0.0f, 1.0f, 1.0f, f2, f2, f2, 1.0f));

  013e4	f3 0f 11 4d cc	 movss	 DWORD PTR tv4846[ebp], xmm1
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp

; 162  : 	vertex.u = u;

  013e9	c7 40 1c 00 00
	80 3f		 mov	 DWORD PTR [eax+28], 1065353216 ; 3f800000H

; 163  : 	vertex.v = v;

  013f0	c7 40 20 00 00
	80 3f		 mov	 DWORD PTR [eax+32], 1065353216 ; 3f800000H

; 156  : 	vertex.r = r;

  013f7	88 58 24	 mov	 BYTE PTR [eax+36], bl

; 157  : 	vertex.g = g;

  013fa	88 58 25	 mov	 BYTE PTR [eax+37], bl

; 108  : 	vertex.x = x;

  013fd	f3 0f 10 45 c8	 movss	 xmm0, DWORD PTR tv4848[ebp]
  01402	f3 0f 11 07	 movss	 DWORD PTR [edi], xmm0

; 110  : 	vertex.z = z;

  01406	f3 0f 10 45 b0	 movss	 xmm0, DWORD PTR tv4841[ebp]

; 112  : 	vertices.push_back(vertex);

  0140b	57		 push	 edi
  0140c	8b ce		 mov	 ecx, esi

; 158  : 	vertex.b = b;

  0140e	88 58 26	 mov	 BYTE PTR [eax+38], bl

; 109  : 	vertex.y = y;

  01411	f3 0f 11 48 14	 movss	 DWORD PTR [eax+20], xmm1

; 110  : 	vertex.z = z;

  01416	f3 0f 11 40 18	 movss	 DWORD PTR [eax+24], xmm0

; 112  : 	vertices.push_back(vertex);

  0141b	e8 00 00 00 00	 call	 ?push_back@?$vector@VVertexUVRGBA@gfxu@@V?$allocator@VVertexUVRGBA@gfxu@@@std@@@std@@QAEXABVVertexUVRGBA@gfxu@@@Z ; std::vector<gfxu::VertexUVRGBA,std::allocator<gfxu::VertexUVRGBA> >::push_back

; 70   : {}

  01420	f3 0f 10 45 d4	 movss	 xmm0, DWORD PTR _f4$1$[ebp]
  01425	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp

; 358  : 						vStream->put(gfxu::VertexUVRGBA(i + 0.0f, j + 0.0f, k + 1.0f, 0.0f, 0.0f, f4, f4, f4, 1.0f));

  0142d	f3 0f 10 4d d0	 movss	 xmm1, DWORD PTR tv4850[ebp]
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp

; 162  : 	vertex.u = u;

  01432	8b 4d f0	 mov	 ecx, DWORD PTR $T4[ebp]
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp

; 358  : 						vStream->put(gfxu::VertexUVRGBA(i + 0.0f, j + 0.0f, k + 1.0f, 0.0f, 0.0f, f4, f4, f4, 1.0f));

  01435	f3 0f 58 0d 00
	00 00 00	 addss	 xmm1, DWORD PTR __real@3f800000
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp

; 114  : 	vs++;

  0143d	ff 05 00 00 00
	00		 inc	 DWORD PTR ?vs@@3HA	; vs

; 70   : {}

  01443	f3 0f 2c c0	 cvttss2si eax, xmm0

; 108  : 	vertex.x = x;

  01447	f3 0f 10 45 c8	 movss	 xmm0, DWORD PTR tv4848[ebp]
  0144c	f3 0f 11 07	 movss	 DWORD PTR [edi], xmm0

; 109  : 	vertex.y = y;

  01450	f3 0f 10 45 b4	 movss	 xmm0, DWORD PTR tv4849[ebp]

; 162  : 	vertex.u = u;

  01455	c7 41 1c 00 00
	00 00		 mov	 DWORD PTR [ecx+28], 0

; 163  : 	vertex.v = v;

  0145c	c7 41 20 00 00
	00 00		 mov	 DWORD PTR [ecx+32], 0

; 156  : 	vertex.r = r;

  01463	88 41 24	 mov	 BYTE PTR [ecx+36], al

; 157  : 	vertex.g = g;

  01466	88 41 25	 mov	 BYTE PTR [ecx+37], al

; 158  : 	vertex.b = b;

  01469	88 41 26	 mov	 BYTE PTR [ecx+38], al

; 109  : 	vertex.y = y;

  0146c	f3 0f 11 41 14	 movss	 DWORD PTR [ecx+20], xmm0

; 110  : 	vertex.z = z;

  01471	f3 0f 11 49 18	 movss	 DWORD PTR [ecx+24], xmm1

; 112  : 	vertices.push_back(vertex);

  01476	57		 push	 edi
  01477	8b ce		 mov	 ecx, esi
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp

; 358  : 						vStream->put(gfxu::VertexUVRGBA(i + 0.0f, j + 0.0f, k + 1.0f, 0.0f, 0.0f, f4, f4, f4, 1.0f));

  01479	f3 0f 11 4d d0	 movss	 DWORD PTR tv4850[ebp], xmm1
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp

; 70   : {}

  0147e	89 45 a8	 mov	 DWORD PTR tv4835[ebp], eax

; 112  : 	vertices.push_back(vertex);

  01481	e8 00 00 00 00	 call	 ?push_back@?$vector@VVertexUVRGBA@gfxu@@V?$allocator@VVertexUVRGBA@gfxu@@@std@@@std@@QAEXABVVertexUVRGBA@gfxu@@@Z ; std::vector<gfxu::VertexUVRGBA,std::allocator<gfxu::VertexUVRGBA> >::push_back

; 162  : 	vertex.u = u;

  01486	8b 45 f0	 mov	 eax, DWORD PTR $T4[ebp]

; 108  : 	vertex.x = x;

  01489	f3 0f 10 45 c8	 movss	 xmm0, DWORD PTR tv4848[ebp]

; 114  : 	vs++;

  0148e	ff 05 00 00 00
	00		 inc	 DWORD PTR ?vs@@3HA	; vs

; 156  : 	vertex.r = r;

  01494	88 58 24	 mov	 BYTE PTR [eax+36], bl

; 157  : 	vertex.g = g;

  01497	88 58 25	 mov	 BYTE PTR [eax+37], bl

; 158  : 	vertex.b = b;

  0149a	88 58 26	 mov	 BYTE PTR [eax+38], bl

; 108  : 	vertex.x = x;

  0149d	f3 0f 11 07	 movss	 DWORD PTR [edi], xmm0

; 109  : 	vertex.y = y;

  014a1	f3 0f 10 45 cc	 movss	 xmm0, DWORD PTR tv4846[ebp]
  014a6	8b d8		 mov	 ebx, eax

; 112  : 	vertices.push_back(vertex);

  014a8	57		 push	 edi
  014a9	f3 0f 11 43 14	 movss	 DWORD PTR [ebx+20], xmm0
  014ae	f3 0f 10 45 b0	 movss	 xmm0, DWORD PTR tv4841[ebp]
  014b3	8b ce		 mov	 ecx, esi

; 162  : 	vertex.u = u;

  014b5	c7 40 1c 00 00
	80 3f		 mov	 DWORD PTR [eax+28], 1065353216 ; 3f800000H

; 163  : 	vertex.v = v;

  014bc	c7 40 20 00 00
	80 3f		 mov	 DWORD PTR [eax+32], 1065353216 ; 3f800000H

; 110  : 	vertex.z = z;

  014c3	f3 0f 11 43 18	 movss	 DWORD PTR [ebx+24], xmm0

; 112  : 	vertices.push_back(vertex);

  014c8	e8 00 00 00 00	 call	 ?push_back@?$vector@VVertexUVRGBA@gfxu@@V?$allocator@VVertexUVRGBA@gfxu@@@std@@@std@@QAEXABVVertexUVRGBA@gfxu@@@Z ; std::vector<gfxu::VertexUVRGBA,std::allocator<gfxu::VertexUVRGBA> >::push_back

; 70   : {}

  014cd	f3 0f 10 45 e8	 movss	 xmm0, DWORD PTR _f3$1$[ebp]
  014d2	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000

; 114  : 	vs++;

  014da	ff 05 00 00 00
	00		 inc	 DWORD PTR ?vs@@3HA	; vs

; 112  : 	vertices.push_back(vertex);

  014e0	57		 push	 edi

; 70   : {}

  014e1	f3 0f 2c c0	 cvttss2si eax, xmm0

; 108  : 	vertex.x = x;

  014e5	f3 0f 10 45 c8	 movss	 xmm0, DWORD PTR tv4848[ebp]
  014ea	f3 0f 11 07	 movss	 DWORD PTR [edi], xmm0

; 109  : 	vertex.y = y;

  014ee	f3 0f 10 45 cc	 movss	 xmm0, DWORD PTR tv4846[ebp]
  014f3	f3 0f 11 43 14	 movss	 DWORD PTR [ebx+20], xmm0

; 110  : 	vertex.z = z;

  014f8	f3 0f 10 45 d0	 movss	 xmm0, DWORD PTR tv4850[ebp]

; 112  : 	vertices.push_back(vertex);

  014fd	8b ce		 mov	 ecx, esi

; 162  : 	vertex.u = u;

  014ff	c7 43 1c 00 00
	00 00		 mov	 DWORD PTR [ebx+28], 0

; 163  : 	vertex.v = v;

  01506	c7 43 20 00 00
	80 3f		 mov	 DWORD PTR [ebx+32], 1065353216 ; 3f800000H

; 156  : 	vertex.r = r;

  0150d	88 43 24	 mov	 BYTE PTR [ebx+36], al

; 157  : 	vertex.g = g;

  01510	88 43 25	 mov	 BYTE PTR [ebx+37], al

; 158  : 	vertex.b = b;

  01513	88 43 26	 mov	 BYTE PTR [ebx+38], al

; 110  : 	vertex.z = z;

  01516	f3 0f 11 43 18	 movss	 DWORD PTR [ebx+24], xmm0

; 112  : 	vertices.push_back(vertex);

  0151b	e8 00 00 00 00	 call	 ?push_back@?$vector@VVertexUVRGBA@gfxu@@V?$allocator@VVertexUVRGBA@gfxu@@@std@@@std@@QAEXABVVertexUVRGBA@gfxu@@@Z ; std::vector<gfxu::VertexUVRGBA,std::allocator<gfxu::VertexUVRGBA> >::push_back

; 108  : 	vertex.x = x;

  01520	f3 0f 10 45 c8	 movss	 xmm0, DWORD PTR tv4848[ebp]

; 156  : 	vertex.r = r;

  01525	8b 45 a8	 mov	 eax, DWORD PTR tv4835[ebp]

; 114  : 	vs++;

  01528	ff 05 00 00 00
	00		 inc	 DWORD PTR ?vs@@3HA	; vs

; 108  : 	vertex.x = x;

  0152e	f3 0f 11 07	 movss	 DWORD PTR [edi], xmm0

; 109  : 	vertex.y = y;

  01532	f3 0f 10 45 b4	 movss	 xmm0, DWORD PTR tv4849[ebp]
  01537	f3 0f 11 43 14	 movss	 DWORD PTR [ebx+20], xmm0

; 110  : 	vertex.z = z;

  0153c	f3 0f 10 45 d0	 movss	 xmm0, DWORD PTR tv4850[ebp]

; 162  : 	vertex.u = u;

  01541	c7 43 1c 00 00
	00 00		 mov	 DWORD PTR [ebx+28], 0

; 163  : 	vertex.v = v;

  01548	c7 43 20 00 00
	00 00		 mov	 DWORD PTR [ebx+32], 0

; 156  : 	vertex.r = r;

  0154f	88 43 24	 mov	 BYTE PTR [ebx+36], al

; 157  : 	vertex.g = g;

  01552	88 43 25	 mov	 BYTE PTR [ebx+37], al

; 158  : 	vertex.b = b;

  01555	88 43 26	 mov	 BYTE PTR [ebx+38], al

; 110  : 	vertex.z = z;

  01558	f3 0f 11 43 18	 movss	 DWORD PTR [ebx+24], xmm0

; 112  : 	vertices.push_back(vertex);

  0155d	57		 push	 edi
  0155e	8b ce		 mov	 ecx, esi
  01560	e8 00 00 00 00	 call	 ?push_back@?$vector@VVertexUVRGBA@gfxu@@V?$allocator@VVertexUVRGBA@gfxu@@@std@@@std@@QAEXABVVertexUVRGBA@gfxu@@@Z ; std::vector<gfxu::VertexUVRGBA,std::allocator<gfxu::VertexUVRGBA> >::push_back

; 114  : 	vs++;

  01565	ff 05 00 00 00
	00		 inc	 DWORD PTR ?vs@@3HA	; vs
  0156b	8b 5d c4	 mov	 ebx, DWORD PTR tv5127[ebp]
  0156e	8b 7d c0	 mov	 edi, DWORD PTR tv5128[ebp]
  01571	8b 75 ec	 mov	 esi, DWORD PTR tv5129[ebp]
$LN496@renderChun:
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp

; 364  : 					if(!GlobalThread::world.getBlock((i | cx) + 1, j | cy, k | cz))

  01574	56		 push	 esi
  01575	8d 43 01	 lea	 eax, DWORD PTR [ebx+1]
  01578	57		 push	 edi
  01579	50		 push	 eax
  0157a	89 45 e8	 mov	 DWORD PTR tv5113[ebp], eax
  0157d	e8 00 00 00 00	 call	 ?getBlock@World@@QAEGHHH@Z ; World::getBlock
  01582	66 85 c0	 test	 ax, ax
  01585	0f 85 e1 03 00
	00		 jne	 $LN57@renderChun

; 365  : 					{
; 366  : 						int i1 = 0;
; 367  : 						int i2 = 0;
; 368  : 						int i3 = 0;
; 369  : 						int i4 = 0;
; 370  : 
; 371  : 						if(GlobalThread::world.getBlock((i | cx) + 1, (j | cy) - 1, k | cz))

  0158b	56		 push	 esi
  0158c	8d 47 ff	 lea	 eax, DWORD PTR [edi-1]
  0158f	50		 push	 eax
  01590	ff 75 e8	 push	 DWORD PTR tv5113[ebp]
  01593	c7 45 cc 00 00
	00 00		 mov	 DWORD PTR _i1$1$[ebp], 0
  0159a	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR _i2$1$[ebp], 0
  015a1	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _i3$1$[ebp], 0
  015a8	c7 45 c8 00 00
	00 00		 mov	 DWORD PTR _i4$1$[ebp], 0
  015af	e8 00 00 00 00	 call	 ?getBlock@World@@QAEGHHH@Z ; World::getBlock
  015b4	66 85 c0	 test	 ax, ax
  015b7	74 0e		 je	 SHORT $LN8@renderChun

; 372  : 						{
; 373  : 							i1++;

  015b9	c7 45 cc 01 00
	00 00		 mov	 DWORD PTR _i1$1$[ebp], 1

; 374  : 							i4++;

  015c0	c7 45 c8 01 00
	00 00		 mov	 DWORD PTR _i4$1$[ebp], 1
$LN8@renderChun:

; 375  : 						}
; 376  : 
; 377  : 						if(GlobalThread::world.getBlock((i | cx) + 1, j | cy, (k | cz) - 1))

  015c7	8b 5d ec	 mov	 ebx, DWORD PTR tv5129[ebp]
  015ca	8d 73 ff	 lea	 esi, DWORD PTR [ebx-1]
  015cd	56		 push	 esi
  015ce	57		 push	 edi
  015cf	ff 75 e8	 push	 DWORD PTR tv5113[ebp]
  015d2	e8 00 00 00 00	 call	 ?getBlock@World@@QAEGHHH@Z ; World::getBlock
  015d7	66 85 c0	 test	 ax, ax
  015da	74 0a		 je	 SHORT $LN7@renderChun

; 378  : 						{
; 379  : 							i1++;

  015dc	ff 45 cc	 inc	 DWORD PTR _i1$1$[ebp]

; 380  : 							i2++;

  015df	c7 45 d0 01 00
	00 00		 mov	 DWORD PTR _i2$1$[ebp], 1
$LN7@renderChun:

; 381  : 						}
; 382  : 
; 383  : 						if(GlobalThread::world.getBlock((i | cx) + 1, (j | cy) + 1, k | cz))

  015e6	53		 push	 ebx
  015e7	8d 47 01	 lea	 eax, DWORD PTR [edi+1]
  015ea	50		 push	 eax
  015eb	ff 75 e8	 push	 DWORD PTR tv5113[ebp]
  015ee	e8 00 00 00 00	 call	 ?getBlock@World@@QAEGHHH@Z ; World::getBlock
  015f3	66 85 c0	 test	 ax, ax
  015f6	74 0a		 je	 SHORT $LN6@renderChun

; 384  : 						{
; 385  : 							i2++;

  015f8	ff 45 d0	 inc	 DWORD PTR _i2$1$[ebp]

; 386  : 							i3++;

  015fb	c7 45 d4 01 00
	00 00		 mov	 DWORD PTR _i3$1$[ebp], 1
$LN6@renderChun:

; 387  : 						}
; 388  : 
; 389  : 						if(GlobalThread::world.getBlock((i | cx) + 1, j | cy, (k | cz) + 1))

  01602	8b 5d bc	 mov	 ebx, DWORD PTR tv5105[ebp]
  01605	53		 push	 ebx
  01606	57		 push	 edi
  01607	ff 75 e8	 push	 DWORD PTR tv5113[ebp]
  0160a	e8 00 00 00 00	 call	 ?getBlock@World@@QAEGHHH@Z ; World::getBlock
  0160f	66 85 c0	 test	 ax, ax
  01612	74 06		 je	 SHORT $LN5@renderChun

; 390  : 						{
; 391  : 							i3++;

  01614	ff 45 d4	 inc	 DWORD PTR _i3$1$[ebp]

; 392  : 							i4++;

  01617	ff 45 c8	 inc	 DWORD PTR _i4$1$[ebp]
$LN5@renderChun:

; 393  : 						}
; 394  : 
; 395  : 						if(i1 < 2 && GlobalThread::world.getBlock((i | cx) + 1, (j | cy) - 1, (k | cz) - 1))

  0161a	83 7d cc 02	 cmp	 DWORD PTR _i1$1$[ebp], 2
  0161e	7d 15		 jge	 SHORT $LN4@renderChun
  01620	56		 push	 esi
  01621	8d 47 ff	 lea	 eax, DWORD PTR [edi-1]
  01624	50		 push	 eax
  01625	ff 75 e8	 push	 DWORD PTR tv5113[ebp]
  01628	e8 00 00 00 00	 call	 ?getBlock@World@@QAEGHHH@Z ; World::getBlock
  0162d	66 85 c0	 test	 ax, ax
  01630	74 03		 je	 SHORT $LN4@renderChun

; 396  : 						{
; 397  : 							i1++;

  01632	ff 45 cc	 inc	 DWORD PTR _i1$1$[ebp]
$LN4@renderChun:

; 398  : 						}
; 399  : 
; 400  : 						if(i2 < 2 && GlobalThread::world.getBlock((i | cx) + 1, (j | cy) + 1, (k | cz) - 1))

  01635	83 7d d0 02	 cmp	 DWORD PTR _i2$1$[ebp], 2
  01639	7d 17		 jge	 SHORT $LN713@renderChun
  0163b	56		 push	 esi
  0163c	8d 77 01	 lea	 esi, DWORD PTR [edi+1]
  0163f	56		 push	 esi
  01640	ff 75 e8	 push	 DWORD PTR tv5113[ebp]
  01643	e8 00 00 00 00	 call	 ?getBlock@World@@QAEGHHH@Z ; World::getBlock
  01648	66 85 c0	 test	 ax, ax
  0164b	74 08		 je	 SHORT $LN3@renderChun

; 401  : 						{
; 402  : 							i2++;

  0164d	ff 45 d0	 inc	 DWORD PTR _i2$1$[ebp]
  01650	eb 03		 jmp	 SHORT $LN3@renderChun
$LN713@renderChun:
  01652	8b 75 e4	 mov	 esi, DWORD PTR tv5110[ebp]
$LN3@renderChun:

; 403  : 						}
; 404  : 								
; 405  : 						if(i3 < 2 && GlobalThread::world.getBlock((i | cx) + 1, (j | cy) + 1, (k | cz) + 1))

  01655	83 7d d4 02	 cmp	 DWORD PTR _i3$1$[ebp], 2
  01659	7d 15		 jge	 SHORT $LN716@renderChun
  0165b	53		 push	 ebx
  0165c	56		 push	 esi
  0165d	8b 75 e8	 mov	 esi, DWORD PTR tv5113[ebp]
  01660	56		 push	 esi
  01661	e8 00 00 00 00	 call	 ?getBlock@World@@QAEGHHH@Z ; World::getBlock
  01666	66 85 c0	 test	 ax, ax
  01669	74 08		 je	 SHORT $LN2@renderChun

; 406  : 						{
; 407  : 							i3++;

  0166b	ff 45 d4	 inc	 DWORD PTR _i3$1$[ebp]
  0166e	eb 03		 jmp	 SHORT $LN2@renderChun
$LN716@renderChun:
  01670	8b 75 e8	 mov	 esi, DWORD PTR tv5113[ebp]
$LN2@renderChun:

; 408  : 						}
; 409  : 								
; 410  : 						if(i4 < 2 && GlobalThread::world.getBlock((i | cx) + 1, (j | cy) - 1, (k | cz) + 1))

  01673	8b 45 c8	 mov	 eax, DWORD PTR _i4$1$[ebp]
  01676	83 f8 02	 cmp	 eax, 2
  01679	7d 14		 jge	 SHORT $LN1@renderChun
  0167b	53		 push	 ebx
  0167c	8d 47 ff	 lea	 eax, DWORD PTR [edi-1]
  0167f	50		 push	 eax
  01680	56		 push	 esi
  01681	e8 00 00 00 00	 call	 ?getBlock@World@@QAEGHHH@Z ; World::getBlock
  01686	66 85 c0	 test	 ax, ax

; 411  : 						{
; 412  : 							i4++;

  01689	8b 45 c8	 mov	 eax, DWORD PTR _i4$1$[ebp]
  0168c	74 01		 je	 SHORT $LN1@renderChun
  0168e	40		 inc	 eax
$LN1@renderChun:
  0168f	66 0f 6e 45 cc	 movd	 xmm0, DWORD PTR _i1$1$[ebp]

; 415  : 						float f1 = 1.0F - i1 * 0.1f;

  01694	f3 0f 10 15 00
	00 00 00	 movss	 xmm2, DWORD PTR __real@3dcccccd
  0169c	f3 0f 10 25 00
	00 00 00	 movss	 xmm4, DWORD PTR __real@3f800000
  016a4	0f 5b c0	 cvtdq2ps xmm0, xmm0
  016a7	0f 28 cc	 movaps	 xmm1, xmm4
  016aa	f3 0f 59 c2	 mulss	 xmm0, xmm2
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp

; 162  : 	vertex.u = u;

  016ae	8b 4d f0	 mov	 ecx, DWORD PTR $T4[ebp]
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp

; 415  : 						float f1 = 1.0F - i1 * 0.1f;

  016b1	f3 0f 5c c8	 subss	 xmm1, xmm0
  016b5	66 0f 6e 45 d0	 movd	 xmm0, DWORD PTR _i2$1$[ebp]

; 416  : 						float f2 = 1.0F - i2 * 0.1f;

  016ba	0f 5b c0	 cvtdq2ps xmm0, xmm0
  016bd	f3 0f 11 4d e4	 movss	 DWORD PTR _f1$1$[ebp], xmm1
  016c2	f3 0f 59 c2	 mulss	 xmm0, xmm2
  016c6	0f 28 cc	 movaps	 xmm1, xmm4
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp

; 108  : 	vertex.x = x;

  016c9	8d 79 10	 lea	 edi, DWORD PTR [ecx+16]
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp

; 416  : 						float f2 = 1.0F - i2 * 0.1f;

  016cc	f3 0f 5c c8	 subss	 xmm1, xmm0
  016d0	66 0f 6e 45 d4	 movd	 xmm0, DWORD PTR _i3$1$[ebp]

; 417  : 						float f3 = 1.0F - i3 * 0.1f;

  016d5	0f 5b c0	 cvtdq2ps xmm0, xmm0
  016d8	f3 0f 11 4d d0	 movss	 DWORD PTR _f2$1$[ebp], xmm1
  016dd	f3 0f 59 c2	 mulss	 xmm0, xmm2
  016e1	0f 28 cc	 movaps	 xmm1, xmm4
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp

; 112  : 	vertices.push_back(vertex);

  016e4	8d 71 04	 lea	 esi, DWORD PTR [ecx+4]
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp

; 417  : 						float f3 = 1.0F - i3 * 0.1f;

  016e7	f3 0f 5c c8	 subss	 xmm1, xmm0
  016eb	66 0f 6e c0	 movd	 xmm0, eax

; 420  : 						vStream->put(gfxu::VertexUVRGBA(i + 1.0f, j + 0.0f, k + 1.0f, 1.0f, 0.0f, f4, f4, f4, 1.0f));

  016ef	8b 45 d8	 mov	 eax, DWORD PTR _i$1$[ebp]
  016f2	0f 5b c0	 cvtdq2ps xmm0, xmm0
  016f5	f3 0f 11 4d a8	 movss	 DWORD PTR _f3$1$[ebp], xmm1
  016fa	f3 0f 59 c2	 mulss	 xmm0, xmm2
  016fe	0f 28 cc	 movaps	 xmm1, xmm4
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp

; 162  : 	vertex.u = u;

  01701	c7 41 1c 00 00
	80 3f		 mov	 DWORD PTR [ecx+28], 1065353216 ; 3f800000H
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp

; 418  : 						float f4 = 1.0F - i4 * 0.1f;

  01708	f3 0f 5c c8	 subss	 xmm1, xmm0
  0170c	66 0f 6e c0	 movd	 xmm0, eax

; 420  : 						vStream->put(gfxu::VertexUVRGBA(i + 1.0f, j + 0.0f, k + 1.0f, 1.0f, 0.0f, f4, f4, f4, 1.0f));

  01710	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  01714	c1 e8 1f	 shr	 eax, 31			; 0000001fH
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp

; 70   : {}

  01717	f3 0f 59 0d 00
	00 00 00	 mulss	 xmm1, DWORD PTR __real@437f0000
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp

; 420  : 						vStream->put(gfxu::VertexUVRGBA(i + 1.0f, j + 0.0f, k + 1.0f, 1.0f, 0.0f, f4, f4, f4, 1.0f));

  0171f	f2 0f 58 04 c5
	00 00 00 00	 addsd	 xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
  01728	8b 45 dc	 mov	 eax, DWORD PTR _j$1$[ebp]
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp

; 163  : 	vertex.v = v;

  0172b	c7 41 20 00 00
	00 00		 mov	 DWORD PTR [ecx+32], 0

; 112  : 	vertices.push_back(vertex);

  01732	57		 push	 edi
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp

; 420  : 						vStream->put(gfxu::VertexUVRGBA(i + 1.0f, j + 0.0f, k + 1.0f, 1.0f, 0.0f, f4, f4, f4, 1.0f));

  01733	66 0f 5a d8	 cvtpd2ps xmm3, xmm0
  01737	66 0f 6e c0	 movd	 xmm0, eax
  0173b	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  0173f	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  01742	f3 0f 58 dc	 addss	 xmm3, xmm4
  01746	f2 0f 58 04 c5
	00 00 00 00	 addsd	 xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
  0174f	8b 45 e0	 mov	 eax, DWORD PTR _k$1$[ebp]
  01752	f3 0f 11 5d c8	 movss	 DWORD PTR tv4905[ebp], xmm3
  01757	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp

; 108  : 	vertex.x = x;

  0175b	f3 0f 11 1f	 movss	 DWORD PTR [edi], xmm3
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp

; 420  : 						vStream->put(gfxu::VertexUVRGBA(i + 1.0f, j + 0.0f, k + 1.0f, 1.0f, 0.0f, f4, f4, f4, 1.0f));

  0175f	0f 28 d0	 movaps	 xmm2, xmm0
  01762	f3 0f 58 15 00
	00 00 00	 addss	 xmm2, DWORD PTR __real@00000000
  0176a	f3 0f 11 45 bc	 movss	 DWORD PTR tv4903[ebp], xmm0
  0176f	66 0f 6e c0	 movd	 xmm0, eax
  01773	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  01777	c1 e8 1f	 shr	 eax, 31			; 0000001fH
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp

; 109  : 	vertex.y = y;

  0177a	f3 0f 11 51 14	 movss	 DWORD PTR [ecx+20], xmm2
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp

; 420  : 						vStream->put(gfxu::VertexUVRGBA(i + 1.0f, j + 0.0f, k + 1.0f, 1.0f, 0.0f, f4, f4, f4, 1.0f));

  0177f	f2 0f 58 04 c5
	00 00 00 00	 addsd	 xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp

; 70   : {}

  01788	f3 0f 2c c1	 cvttss2si eax, xmm1
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp

; 420  : 						vStream->put(gfxu::VertexUVRGBA(i + 1.0f, j + 0.0f, k + 1.0f, 1.0f, 0.0f, f4, f4, f4, 1.0f));

  0178c	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp

; 156  : 	vertex.r = r;

  01790	88 41 24	 mov	 BYTE PTR [ecx+36], al
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp

; 420  : 						vStream->put(gfxu::VertexUVRGBA(i + 1.0f, j + 0.0f, k + 1.0f, 1.0f, 0.0f, f4, f4, f4, 1.0f));

  01793	f3 0f 11 45 cc	 movss	 DWORD PTR tv4907[ebp], xmm0
  01798	f3 0f 58 c4	 addss	 xmm0, xmm4
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp

; 157  : 	vertex.g = g;

  0179c	88 41 25	 mov	 BYTE PTR [ecx+37], al

; 158  : 	vertex.b = b;

  0179f	88 41 26	 mov	 BYTE PTR [ecx+38], al
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp

; 420  : 						vStream->put(gfxu::VertexUVRGBA(i + 1.0f, j + 0.0f, k + 1.0f, 1.0f, 0.0f, f4, f4, f4, 1.0f));

  017a2	f3 0f 11 55 b4	 movss	 DWORD PTR tv4906[ebp], xmm2
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp

; 110  : 	vertex.z = z;

  017a7	f3 0f 11 41 18	 movss	 DWORD PTR [ecx+24], xmm0

; 112  : 	vertices.push_back(vertex);

  017ac	8b ce		 mov	 ecx, esi
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp

; 420  : 						vStream->put(gfxu::VertexUVRGBA(i + 1.0f, j + 0.0f, k + 1.0f, 1.0f, 0.0f, f4, f4, f4, 1.0f));

  017ae	f3 0f 11 45 b0	 movss	 DWORD PTR tv4898[ebp], xmm0
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp

; 112  : 	vertices.push_back(vertex);

  017b3	e8 00 00 00 00	 call	 ?push_back@?$vector@VVertexUVRGBA@gfxu@@V?$allocator@VVertexUVRGBA@gfxu@@@std@@@std@@QAEXABVVertexUVRGBA@gfxu@@@Z ; std::vector<gfxu::VertexUVRGBA,std::allocator<gfxu::VertexUVRGBA> >::push_back

; 70   : {}

  017b8	f3 0f 10 45 a8	 movss	 xmm0, DWORD PTR _f3$1$[ebp]
  017bd	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp

; 421  : 						vStream->put(gfxu::VertexUVRGBA(i + 1.0f, j + 1.0f, k + 1.0f, 1.0f, 1.0f, f3, f3, f3, 1.0f));

  017c5	f3 0f 10 4d bc	 movss	 xmm1, DWORD PTR tv4903[ebp]
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp

; 162  : 	vertex.u = u;

  017ca	8b 45 f0	 mov	 eax, DWORD PTR $T4[ebp]
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp

; 421  : 						vStream->put(gfxu::VertexUVRGBA(i + 1.0f, j + 1.0f, k + 1.0f, 1.0f, 1.0f, f3, f3, f3, 1.0f));

  017cd	f3 0f 58 0d 00
	00 00 00	 addss	 xmm1, DWORD PTR __real@3f800000
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp

; 114  : 	vs++;

  017d5	ff 05 00 00 00
	00		 inc	 DWORD PTR ?vs@@3HA	; vs

; 70   : {}

  017db	f3 0f 2c d8	 cvttss2si ebx, xmm0
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp

; 421  : 						vStream->put(gfxu::VertexUVRGBA(i + 1.0f, j + 1.0f, k + 1.0f, 1.0f, 1.0f, f3, f3, f3, 1.0f));

  017df	f3 0f 11 4d bc	 movss	 DWORD PTR tv4903[ebp], xmm1
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp

; 162  : 	vertex.u = u;

  017e4	c7 40 1c 00 00
	80 3f		 mov	 DWORD PTR [eax+28], 1065353216 ; 3f800000H

; 163  : 	vertex.v = v;

  017eb	c7 40 20 00 00
	80 3f		 mov	 DWORD PTR [eax+32], 1065353216 ; 3f800000H

; 156  : 	vertex.r = r;

  017f2	88 58 24	 mov	 BYTE PTR [eax+36], bl

; 157  : 	vertex.g = g;

  017f5	88 58 25	 mov	 BYTE PTR [eax+37], bl

; 158  : 	vertex.b = b;

  017f8	88 58 26	 mov	 BYTE PTR [eax+38], bl

; 108  : 	vertex.x = x;

  017fb	f3 0f 10 45 c8	 movss	 xmm0, DWORD PTR tv4905[ebp]
  01800	f3 0f 11 07	 movss	 DWORD PTR [edi], xmm0

; 110  : 	vertex.z = z;

  01804	f3 0f 10 45 b0	 movss	 xmm0, DWORD PTR tv4898[ebp]

; 112  : 	vertices.push_back(vertex);

  01809	57		 push	 edi
  0180a	8b ce		 mov	 ecx, esi
  0180c	f3 0f 11 48 14	 movss	 DWORD PTR [eax+20], xmm1
  01811	f3 0f 11 40 18	 movss	 DWORD PTR [eax+24], xmm0
  01816	e8 00 00 00 00	 call	 ?push_back@?$vector@VVertexUVRGBA@gfxu@@V?$allocator@VVertexUVRGBA@gfxu@@@std@@@std@@QAEXABVVertexUVRGBA@gfxu@@@Z ; std::vector<gfxu::VertexUVRGBA,std::allocator<gfxu::VertexUVRGBA> >::push_back

; 70   : {}

  0181b	f3 0f 10 45 e4	 movss	 xmm0, DWORD PTR _f1$1$[ebp]
  01820	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp

; 422  : 						vStream->put(gfxu::VertexUVRGBA(i + 1.0f, j + 0.0f, k + 0.0f, 0.0f, 0.0f, f1, f1, f1, 1.0f));

  01828	f3 0f 10 4d cc	 movss	 xmm1, DWORD PTR tv4907[ebp]
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp

; 162  : 	vertex.u = u;

  0182d	8b 4d f0	 mov	 ecx, DWORD PTR $T4[ebp]
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp

; 422  : 						vStream->put(gfxu::VertexUVRGBA(i + 1.0f, j + 0.0f, k + 0.0f, 0.0f, 0.0f, f1, f1, f1, 1.0f));

  01830	f3 0f 58 0d 00
	00 00 00	 addss	 xmm1, DWORD PTR __real@00000000
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp

; 114  : 	vs++;

  01838	ff 05 00 00 00
	00		 inc	 DWORD PTR ?vs@@3HA	; vs

; 70   : {}

  0183e	f3 0f 2c c0	 cvttss2si eax, xmm0

; 108  : 	vertex.x = x;

  01842	f3 0f 10 45 c8	 movss	 xmm0, DWORD PTR tv4905[ebp]
  01847	f3 0f 11 07	 movss	 DWORD PTR [edi], xmm0

; 109  : 	vertex.y = y;

  0184b	f3 0f 10 45 b4	 movss	 xmm0, DWORD PTR tv4906[ebp]

; 162  : 	vertex.u = u;

  01850	c7 41 1c 00 00
	00 00		 mov	 DWORD PTR [ecx+28], 0

; 163  : 	vertex.v = v;

  01857	c7 41 20 00 00
	00 00		 mov	 DWORD PTR [ecx+32], 0

; 156  : 	vertex.r = r;

  0185e	88 41 24	 mov	 BYTE PTR [ecx+36], al

; 157  : 	vertex.g = g;

  01861	88 41 25	 mov	 BYTE PTR [ecx+37], al

; 158  : 	vertex.b = b;

  01864	88 41 26	 mov	 BYTE PTR [ecx+38], al

; 109  : 	vertex.y = y;

  01867	f3 0f 11 41 14	 movss	 DWORD PTR [ecx+20], xmm0

; 110  : 	vertex.z = z;

  0186c	f3 0f 11 49 18	 movss	 DWORD PTR [ecx+24], xmm1

; 112  : 	vertices.push_back(vertex);

  01871	57		 push	 edi
  01872	8b ce		 mov	 ecx, esi
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp

; 422  : 						vStream->put(gfxu::VertexUVRGBA(i + 1.0f, j + 0.0f, k + 0.0f, 0.0f, 0.0f, f1, f1, f1, 1.0f));

  01874	f3 0f 11 4d cc	 movss	 DWORD PTR tv4907[ebp], xmm1
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp

; 70   : {}

  01879	89 45 a8	 mov	 DWORD PTR tv4892[ebp], eax

; 112  : 	vertices.push_back(vertex);

  0187c	e8 00 00 00 00	 call	 ?push_back@?$vector@VVertexUVRGBA@gfxu@@V?$allocator@VVertexUVRGBA@gfxu@@@std@@@std@@QAEXABVVertexUVRGBA@gfxu@@@Z ; std::vector<gfxu::VertexUVRGBA,std::allocator<gfxu::VertexUVRGBA> >::push_back

; 162  : 	vertex.u = u;

  01881	8b 45 f0	 mov	 eax, DWORD PTR $T4[ebp]

; 108  : 	vertex.x = x;

  01884	f3 0f 10 45 c8	 movss	 xmm0, DWORD PTR tv4905[ebp]

; 114  : 	vs++;

  01889	ff 05 00 00 00
	00		 inc	 DWORD PTR ?vs@@3HA	; vs

; 156  : 	vertex.r = r;

  0188f	88 58 24	 mov	 BYTE PTR [eax+36], bl

; 157  : 	vertex.g = g;

  01892	88 58 25	 mov	 BYTE PTR [eax+37], bl

; 158  : 	vertex.b = b;

  01895	88 58 26	 mov	 BYTE PTR [eax+38], bl

; 108  : 	vertex.x = x;

  01898	f3 0f 11 07	 movss	 DWORD PTR [edi], xmm0

; 109  : 	vertex.y = y;

  0189c	f3 0f 10 45 bc	 movss	 xmm0, DWORD PTR tv4903[ebp]
  018a1	8b d8		 mov	 ebx, eax

; 112  : 	vertices.push_back(vertex);

  018a3	57		 push	 edi
  018a4	f3 0f 11 43 14	 movss	 DWORD PTR [ebx+20], xmm0
  018a9	f3 0f 10 45 b0	 movss	 xmm0, DWORD PTR tv4898[ebp]
  018ae	8b ce		 mov	 ecx, esi

; 162  : 	vertex.u = u;

  018b0	c7 40 1c 00 00
	80 3f		 mov	 DWORD PTR [eax+28], 1065353216 ; 3f800000H

; 163  : 	vertex.v = v;

  018b7	c7 40 20 00 00
	80 3f		 mov	 DWORD PTR [eax+32], 1065353216 ; 3f800000H

; 110  : 	vertex.z = z;

  018be	f3 0f 11 43 18	 movss	 DWORD PTR [ebx+24], xmm0

; 112  : 	vertices.push_back(vertex);

  018c3	e8 00 00 00 00	 call	 ?push_back@?$vector@VVertexUVRGBA@gfxu@@V?$allocator@VVertexUVRGBA@gfxu@@@std@@@std@@QAEXABVVertexUVRGBA@gfxu@@@Z ; std::vector<gfxu::VertexUVRGBA,std::allocator<gfxu::VertexUVRGBA> >::push_back

; 70   : {}

  018c8	f3 0f 10 45 d0	 movss	 xmm0, DWORD PTR _f2$1$[ebp]
  018cd	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000

; 114  : 	vs++;

  018d5	ff 05 00 00 00
	00		 inc	 DWORD PTR ?vs@@3HA	; vs

; 112  : 	vertices.push_back(vertex);

  018db	57		 push	 edi

; 70   : {}

  018dc	f3 0f 2c c0	 cvttss2si eax, xmm0

; 108  : 	vertex.x = x;

  018e0	f3 0f 10 45 c8	 movss	 xmm0, DWORD PTR tv4905[ebp]
  018e5	f3 0f 11 07	 movss	 DWORD PTR [edi], xmm0

; 109  : 	vertex.y = y;

  018e9	f3 0f 10 45 bc	 movss	 xmm0, DWORD PTR tv4903[ebp]
  018ee	f3 0f 11 43 14	 movss	 DWORD PTR [ebx+20], xmm0

; 110  : 	vertex.z = z;

  018f3	f3 0f 10 45 cc	 movss	 xmm0, DWORD PTR tv4907[ebp]

; 112  : 	vertices.push_back(vertex);

  018f8	8b ce		 mov	 ecx, esi

; 162  : 	vertex.u = u;

  018fa	c7 43 1c 00 00
	00 00		 mov	 DWORD PTR [ebx+28], 0

; 163  : 	vertex.v = v;

  01901	c7 43 20 00 00
	80 3f		 mov	 DWORD PTR [ebx+32], 1065353216 ; 3f800000H

; 156  : 	vertex.r = r;

  01908	88 43 24	 mov	 BYTE PTR [ebx+36], al

; 157  : 	vertex.g = g;

  0190b	88 43 25	 mov	 BYTE PTR [ebx+37], al

; 158  : 	vertex.b = b;

  0190e	88 43 26	 mov	 BYTE PTR [ebx+38], al

; 110  : 	vertex.z = z;

  01911	f3 0f 11 43 18	 movss	 DWORD PTR [ebx+24], xmm0

; 112  : 	vertices.push_back(vertex);

  01916	e8 00 00 00 00	 call	 ?push_back@?$vector@VVertexUVRGBA@gfxu@@V?$allocator@VVertexUVRGBA@gfxu@@@std@@@std@@QAEXABVVertexUVRGBA@gfxu@@@Z ; std::vector<gfxu::VertexUVRGBA,std::allocator<gfxu::VertexUVRGBA> >::push_back

; 108  : 	vertex.x = x;

  0191b	f3 0f 10 45 c8	 movss	 xmm0, DWORD PTR tv4905[ebp]

; 156  : 	vertex.r = r;

  01920	8b 45 a8	 mov	 eax, DWORD PTR tv4892[ebp]

; 114  : 	vs++;

  01923	ff 05 00 00 00
	00		 inc	 DWORD PTR ?vs@@3HA	; vs

; 108  : 	vertex.x = x;

  01929	f3 0f 11 07	 movss	 DWORD PTR [edi], xmm0

; 109  : 	vertex.y = y;

  0192d	f3 0f 10 45 b4	 movss	 xmm0, DWORD PTR tv4906[ebp]
  01932	f3 0f 11 43 14	 movss	 DWORD PTR [ebx+20], xmm0

; 110  : 	vertex.z = z;

  01937	f3 0f 10 45 cc	 movss	 xmm0, DWORD PTR tv4907[ebp]

; 112  : 	vertices.push_back(vertex);

  0193c	57		 push	 edi
  0193d	8b ce		 mov	 ecx, esi

; 162  : 	vertex.u = u;

  0193f	c7 43 1c 00 00
	00 00		 mov	 DWORD PTR [ebx+28], 0

; 163  : 	vertex.v = v;

  01946	c7 43 20 00 00
	00 00		 mov	 DWORD PTR [ebx+32], 0

; 156  : 	vertex.r = r;

  0194d	88 43 24	 mov	 BYTE PTR [ebx+36], al

; 157  : 	vertex.g = g;

  01950	88 43 25	 mov	 BYTE PTR [ebx+37], al

; 158  : 	vertex.b = b;

  01953	88 43 26	 mov	 BYTE PTR [ebx+38], al

; 110  : 	vertex.z = z;

  01956	f3 0f 11 43 18	 movss	 DWORD PTR [ebx+24], xmm0

; 112  : 	vertices.push_back(vertex);

  0195b	e8 00 00 00 00	 call	 ?push_back@?$vector@VVertexUVRGBA@gfxu@@V?$allocator@VVertexUVRGBA@gfxu@@@std@@@std@@QAEXABVVertexUVRGBA@gfxu@@@Z ; std::vector<gfxu::VertexUVRGBA,std::allocator<gfxu::VertexUVRGBA> >::push_back

; 114  : 	vs++;

  01960	ff 05 00 00 00
	00		 inc	 DWORD PTR ?vs@@3HA	; vs
  01966	8b 5d c4	 mov	 ebx, DWORD PTR tv5127[ebp]
  01969	8b 7d c0	 mov	 edi, DWORD PTR tv5128[ebp]
$LN57@renderChun:
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp

; 40   : 			for(unsigned int k = 0; k < 16; k++)

  0196c	8b 45 e0	 mov	 eax, DWORD PTR _k$1$[ebp]
  0196f	8b 55 b8	 mov	 edx, DWORD PTR _cz$1$[ebp]
  01972	40		 inc	 eax
  01973	89 45 e0	 mov	 DWORD PTR _k$1$[ebp], eax
  01976	83 f8 10	 cmp	 eax, 16			; 00000010H
  01979	0f 82 51 e8 ff
	ff		 jb	 $LL58@renderChun

; 37   : 	{
; 38   : 		for(unsigned int j = 0; j < 16; j++)

  0197f	8b 4d dc	 mov	 ecx, DWORD PTR _j$1$[ebp]
  01982	8b 75 ac	 mov	 esi, DWORD PTR _cy$1$[ebp]
  01985	41		 inc	 ecx
  01986	89 4d dc	 mov	 DWORD PTR _j$1$[ebp], ecx
  01989	83 f9 10	 cmp	 ecx, 16			; 00000010H
  0198c	0f 82 30 e8 ff
	ff		 jb	 $LL61@renderChun

; 35   : 				
; 36   : 	for(unsigned int i = 0; i < 16; i++)

  01992	8b 45 d8	 mov	 eax, DWORD PTR _i$1$[ebp]
  01995	8b 7d a4	 mov	 edi, DWORD PTR _cx$1$[ebp]
  01998	40		 inc	 eax
  01999	89 45 d8	 mov	 DWORD PTR _i$1$[ebp], eax
  0199c	83 f8 10	 cmp	 eax, 16			; 00000010H
  0199f	0f 82 11 e8 ff
	ff		 jb	 $LL64@renderChun
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp

; 245  : 	vertices.shrink_to_fit();

  019a5	8b 75 f0	 mov	 esi, DWORD PTR $T4[ebp]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector

; 977  : 		return (this->_Myend != this->_Mylast);

  019a8	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  019ab	39 4e 0c	 cmp	 DWORD PTR [esi+12], ecx

; 978  : 		}
; 979  : 
; 980  : 	iterator begin() _NOEXCEPT
; 981  : 		{	// return iterator for beginning of mutable sequence
; 982  : 		return (iterator(this->_Myfirst, this));
; 983  : 		}
; 984  : 
; 985  : 	const_iterator begin() const _NOEXCEPT
; 986  : 		{	// return iterator for beginning of nonmutable sequence
; 987  : 		return (const_iterator(this->_Myfirst, this));
; 988  : 		}
; 989  : 
; 990  : 	iterator end() _NOEXCEPT
; 991  : 		{	// return iterator for end of mutable sequence
; 992  : 		return (iterator(this->_Mylast, this));
; 993  : 		}
; 994  : 
; 995  : 	const_iterator end() const _NOEXCEPT
; 996  : 		{	// return iterator for end of nonmutable sequence
; 997  : 		return (const_iterator(this->_Mylast, this));
; 998  : 		}
; 999  : 
; 1000 : 	iterator _Make_iter(const_iterator _Where) const
; 1001 : 		{	// make iterator from const_iterator
; 1002 : 		return (iterator(_Where._Ptr, this));
; 1003 : 		}
; 1004 : 
; 1005 : 	reverse_iterator rbegin() _NOEXCEPT
; 1006 : 		{	// return iterator for beginning of reversed mutable sequence
; 1007 : 		return (reverse_iterator(end()));
; 1008 : 		}
; 1009 : 
; 1010 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1011 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1012 : 		return (const_reverse_iterator(end()));
; 1013 : 		}
; 1014 : 
; 1015 : 	reverse_iterator rend() _NOEXCEPT
; 1016 : 		{	// return iterator for end of reversed mutable sequence
; 1017 : 		return (reverse_iterator(begin()));
; 1018 : 		}
; 1019 : 
; 1020 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1021 : 		{	// return iterator for end of reversed nonmutable sequence
; 1022 : 		return (const_reverse_iterator(begin()));
; 1023 : 		}
; 1024 : 
; 1025 :  #if _HAS_CPP0X
; 1026 : 	const_iterator cbegin() const _NOEXCEPT
; 1027 : 		{	// return iterator for beginning of nonmutable sequence
; 1028 : 		return (((const _Myt *)this)->begin());
; 1029 : 		}
; 1030 : 
; 1031 : 	const_iterator cend() const _NOEXCEPT
; 1032 : 		{	// return iterator for end of nonmutable sequence
; 1033 : 		return (((const _Myt *)this)->end());
; 1034 : 		}
; 1035 : 
; 1036 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1037 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1038 : 		return (((const _Myt *)this)->rbegin());
; 1039 : 		}
; 1040 : 
; 1041 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1042 : 		{	// return iterator for end of reversed nonmutable sequence
; 1043 : 		return (((const _Myt *)this)->rend());
; 1044 : 		}
; 1045 : 
; 1046 : 	void shrink_to_fit()
; 1047 : 		{	// reduce capacity
; 1048 : 		if (_Has_unused_capacity())

  019ae	74 47		 je	 SHORT $LN560@renderChun

; 1088 : 		}
; 1089 : 
; 1090 : 	size_type max_size() const _NOEXCEPT
; 1091 : 		{	// return maximum possible length of sequence
; 1092 : 		return (this->_Getal().max_size());
; 1093 : 		}
; 1094 : 
; 1095 : 	bool empty() const _NOEXCEPT
; 1096 : 		{	// test if sequence is empty
; 1097 : 		return (this->_Myfirst == this->_Mylast);

  019b0	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  019b3	3b c1		 cmp	 eax, ecx

; 1049 : 			{	// worth shrinking, do it
; 1050 : 			if (empty())

  019b5	75 24		 jne	 SHORT $LN561@renderChun

; 1098 : 		}
; 1099 : 
; 1100 : 	_Alloc get_allocator() const _NOEXCEPT
; 1101 : 		{	// return allocator object for values
; 1102 : 		return (this->_Getal());
; 1103 : 		}
; 1104 : 
; 1105 : 	const_reference at(size_type _Pos) const
; 1106 : 		{	// subscript nonmutable sequence with checking
; 1107 : 		if (size() <= _Pos)
; 1108 : 			_Xran();
; 1109 : 		return (*(this->_Myfirst + _Pos));
; 1110 : 		}
; 1111 : 
; 1112 : 	reference at(size_type _Pos)
; 1113 : 		{	// subscript mutable sequence with checking
; 1114 : 		if (size() <= _Pos)
; 1115 : 			_Xran();
; 1116 : 		return (*(this->_Myfirst + _Pos));
; 1117 : 		}
; 1118 : 
; 1119 : 	const_reference operator[](size_type _Pos) const
; 1120 : 		{	// subscript nonmutable sequence
; 1121 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1122 : 		if (size() <= _Pos)
; 1123 : 			{	// report error
; 1124 : 			_DEBUG_ERROR("vector subscript out of range");
; 1125 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1126 : 			}
; 1127 : 
; 1128 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1129 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1130 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1131 : 
; 1132 : 		return (*(this->_Myfirst + _Pos));
; 1133 : 		}
; 1134 : 
; 1135 : 	reference operator[](size_type _Pos)
; 1136 : 		{	// subscript mutable sequence
; 1137 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1138 : 		if (size() <= _Pos)
; 1139 : 			{	// report error
; 1140 : 			_DEBUG_ERROR("vector subscript out of range");
; 1141 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1142 : 			}
; 1143 : 
; 1144 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1145 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1146 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1147 : 
; 1148 : 		return (*(this->_Myfirst + _Pos));
; 1149 : 		}
; 1150 : 
; 1151 :  #if _HAS_CPP0X
; 1152 : 	pointer data() _NOEXCEPT
; 1153 : 		{	// return address of first element
; 1154 : 		return (this->_Myfirst);
; 1155 : 		}
; 1156 : 
; 1157 : 	const_pointer data() const _NOEXCEPT
; 1158 : 		{	// return address of first element
; 1159 : 		return (this->_Myfirst);
; 1160 : 		}
; 1161 :  #endif /* _HAS_CPP0X */
; 1162 : 
; 1163 : 	reference front()
; 1164 : 		{	// return first element of mutable sequence
; 1165 : 		return (*begin());
; 1166 : 		}
; 1167 : 
; 1168 : 	const_reference front() const
; 1169 : 		{	// return first element of nonmutable sequence
; 1170 : 		return (*begin());
; 1171 : 		}
; 1172 : 
; 1173 : 	reference back()
; 1174 : 		{	// return last element of mutable sequence
; 1175 : 		return (*(end() - 1));
; 1176 : 		}
; 1177 : 
; 1178 : 	const_reference back() const
; 1179 : 		{	// return last element of nonmutable sequence
; 1180 : 		return (*(end() - 1));
; 1181 : 		}
; 1182 : 
; 1183 : 	void push_back(const value_type& _Val)
; 1184 : 		{	// insert element at end
; 1185 : 		if (_Inside(_STD addressof(_Val)))
; 1186 : 			{	// push back an element
; 1187 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 1188 : 			if (this->_Mylast == this->_Myend)
; 1189 : 				_Reserve(1);
; 1190 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1191 : 			this->_Getal().construct(this->_Mylast,
; 1192 : 				this->_Myfirst[_Idx]);
; 1193 : 			++this->_Mylast;
; 1194 : 			}
; 1195 : 		else
; 1196 : 			{	// push back a non-element
; 1197 : 			if (this->_Mylast == this->_Myend)
; 1198 : 				_Reserve(1);
; 1199 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1200 : 			this->_Getal().construct(this->_Mylast,
; 1201 : 				_Val);
; 1202 : 			++this->_Mylast;
; 1203 : 			}
; 1204 : 		}
; 1205 : 
; 1206 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1207 : 	void pop_back()
; 1208 : 		{	// erase element at end
; 1209 : 		if (empty())
; 1210 : 			_DEBUG_ERROR("vector empty before pop");
; 1211 : 		else
; 1212 : 			{	// erase last element
; 1213 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1214 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1215 : 			--this->_Mylast;
; 1216 : 			}
; 1217 : 		}
; 1218 : 
; 1219 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1220 : 	void pop_back()
; 1221 : 		{	// erase element at end
; 1222 : 		if (!empty())
; 1223 : 			{	// erase last element
; 1224 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1225 : 			--this->_Mylast;
; 1226 : 			}
; 1227 : 		}
; 1228 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1229 : 
; 1230 : 	template<class _Iter>
; 1231 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1232 : 			void>::type
; 1233 : 		assign(_Iter _First, _Iter _Last)
; 1234 : 		{	// assign [_First, _Last), input iterators
; 1235 : 		erase(begin(), end());
; 1236 : 		insert(begin(), _First, _Last);
; 1237 : 		}
; 1238 : 
; 1239 : 	void assign(size_type _Count, const value_type& _Val)
; 1240 : 		{	// assign _Count * _Val
; 1241 : 		_Assign_n(_Count, _Val);
; 1242 : 		}
; 1243 : 
; 1244 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1245 : 		{	// insert _Val at _Where
; 1246 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1247 : 		}
; 1248 : 
; 1249 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1250 : 		const _Ty& _Val)
; 1251 : 		{	// insert _Count * _Val at _Where
; 1252 : 		return (_Insert_n(_Where, _Count, _Val));
; 1253 : 		}
; 1254 : 
; 1255 : 	template<class _Iter>
; 1256 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1257 : 			iterator>::type
; 1258 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1259 : 		{	// insert [_First, _Last) at _Where
; 1260 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1261 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1262 : 		return (begin() + _Off);
; 1263 : 		}
; 1264 : 
; 1265 : 	template<class _Iter>
; 1266 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1267 : 			input_iterator_tag)
; 1268 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1269 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1270 : 
; 1271 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1272 : 		if (size() < _Off)
; 1273 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1274 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1275 : 
; 1276 : 		if (_First != _Last)
; 1277 : 			{	// worth doing, gather at end and rotate into place
; 1278 : 			size_type _Oldsize = size();
; 1279 : 
; 1280 : 			_TRY_BEGIN
; 1281 : 			for (; _First != _Last; ++_First)
; 1282 : 				push_back(*_First);	// append
; 1283 : 
; 1284 : 			_CATCH_ALL
; 1285 : 			erase(begin() + _Oldsize, end());
; 1286 : 			_RERAISE;
; 1287 : 			_CATCH_END
; 1288 : 
; 1289 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1290 : 			}
; 1291 : 		}
; 1292 : 
; 1293 : 	template<class _Iter>
; 1294 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1295 : 			forward_iterator_tag)
; 1296 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1297 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1298 : 		if (_VICONT(_Where) != this
; 1299 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1300 : 			|| this->_Mylast < _VIPTR(_Where))
; 1301 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1302 : 		_DEBUG_RANGE(_First, _Last);
; 1303 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1304 : 
; 1305 : 		size_type _Count = 0;
; 1306 : 		_Distance(_First, _Last, _Count);
; 1307 : 
; 1308 : 		if (_Count == 0)
; 1309 : 			;
; 1310 : 		else if (_Unused_capacity() < _Count)
; 1311 : 			{	// not enough room, reallocate
; 1312 : 			if (max_size() - size() < _Count)
; 1313 : 				_Xlen();	// result too long
; 1314 : 
; 1315 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1316 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1317 : 			pointer _Ptr = _Newvec;
; 1318 : 
; 1319 : 			_TRY_BEGIN
; 1320 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1321 : 				_Newvec);	// copy prefix
; 1322 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1323 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1324 : 				_Ptr);	// copy suffix
; 1325 : 			_CATCH_ALL
; 1326 : 			_Destroy(_Newvec, _Ptr);
; 1327 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1328 : 			_RERAISE;
; 1329 : 			_CATCH_END
; 1330 : 
; 1331 : 			_Count += size();
; 1332 : 			if (this->_Myfirst != pointer())
; 1333 : 				{	// destroy and deallocate old array
; 1334 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1335 : 				this->_Getal().deallocate(this->_Myfirst,
; 1336 : 					this->_Myend - this->_Myfirst);
; 1337 : 				}
; 1338 : 
; 1339 : 			this->_Orphan_all();
; 1340 : 			this->_Myend = _Newvec + _Capacity;
; 1341 : 			this->_Mylast = _Newvec + _Count;
; 1342 : 			this->_Myfirst = _Newvec;
; 1343 : 			}
; 1344 : 		else
; 1345 : 			{	// new stuff fits, append and rotate into place
; 1346 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1347 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1348 : 				this->_Mylast + _Count);
; 1349 : 			this->_Mylast += _Count;
; 1350 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1351 : 			}
; 1352 : 		}
; 1353 : 
; 1354 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1355 : 	iterator erase(const_iterator _Where)
; 1356 : 		{	// erase element at where
; 1357 : 		if (_VICONT(_Where) != this
; 1358 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1359 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1360 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1361 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1362 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1363 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1364 : 		--this->_Mylast;
; 1365 : 		return (_Make_iter(_Where));
; 1366 : 		}
; 1367 : 
; 1368 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1369 : 	iterator erase(const_iterator _Where)
; 1370 : 		{	// erase element at where
; 1371 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1372 : 			_VIPTR(_Where));
; 1373 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1374 : 		--this->_Mylast;
; 1375 : 		return (_Make_iter(_Where));
; 1376 : 		}
; 1377 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1378 : 
; 1379 : 	iterator erase(const_iterator _First_arg,
; 1380 : 		const_iterator _Last_arg)
; 1381 : 		{	// erase [_First, _Last)
; 1382 : 		if (_First_arg == begin() && _Last_arg == end())
; 1383 : 			clear();
; 1384 : 		else if (_First_arg != _Last_arg)
; 1385 : 			{	// clear partial
; 1386 : 			iterator _First = _Make_iter(_First_arg);
; 1387 : 			iterator _Last = _Make_iter(_Last_arg);
; 1388 : 
; 1389 : 			if (_First != _Last)
; 1390 : 				{	// worth doing, copy down over hole
; 1391 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1392 : 				if (_Last < _First || _VICONT(_First) != this
; 1393 : 					|| _VIPTR(_First) < this->_Myfirst
; 1394 : 					|| this->_Mylast < _VIPTR(_Last))
; 1395 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1396 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1397 : 					_VIPTR(_First));
; 1398 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1399 : 
; 1400 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1401 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1402 : 					_VIPTR(_First));
; 1403 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1404 : 
; 1405 : 				_Destroy(_Ptr, this->_Mylast);
; 1406 : 				this->_Mylast = _Ptr;
; 1407 : 				}
; 1408 : 			}
; 1409 : 		return (_Make_iter(_First_arg));
; 1410 : 		}
; 1411 : 
; 1412 : 	void clear() _NOEXCEPT
; 1413 : 		{	// erase all
; 1414 : 		this->_Orphan_all();
; 1415 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1416 : 		this->_Mylast = this->_Myfirst;
; 1417 : 		}
; 1418 : 
; 1419 : 	void swap(_Myt& _Right)
; 1420 : 		{	// exchange contents with _Right
; 1421 : 		if (this == &_Right)
; 1422 : 			;	// same object, do nothing
; 1423 : 		else if (this->_Getal() == _Right._Getal())
; 1424 : 			{	// same allocator, swap control information
; 1425 : 			this->_Swap_all(_Right);
; 1426 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1427 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1428 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1429 : 			}
; 1430 : 
; 1431 :  #if _HAS_CPP0X
; 1432 : 		else if (_Alty::propagate_on_container_swap::value)
; 1433 : 			{	// swap allocators and control information
; 1434 : 			this->_Swap_alloc(_Right);
; 1435 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1436 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1437 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1438 : 			}
; 1439 :  #endif /* _HAS_CPP0X */
; 1440 : 
; 1441 : 		else
; 1442 : 			{	// different allocator, do multiple moves
; 1443 : 			_Myt _Ts = _Move(*this);
; 1444 : 
; 1445 : 			*this = _Move(_Right);
; 1446 : 			_Right = _Move(_Ts);
; 1447 : 			}
; 1448 : 		}
; 1449 : 
; 1450 : protected:
; 1451 : 	void _Assign_n(size_type _Count, const value_type& _Val)
; 1452 : 		{	// assign _Count * _Val
; 1453 : 		value_type _Tmp = _Val;	// in case _Val is in sequence
; 1454 : 		erase(begin(), end());
; 1455 : 		insert(begin(), _Count, _Tmp);
; 1456 : 		}
; 1457 : 
; 1458 : 	bool _Buy(size_type _Capacity)
; 1459 : 		{	// allocate array with _Capacity elements
; 1460 : 		this->_Myfirst = pointer();
; 1461 : 		this->_Mylast = pointer();
; 1462 : 		this->_Myend = pointer();
; 1463 : 
; 1464 : 		if (_Capacity == 0)
; 1465 : 			return (false);
; 1466 : 		else if (max_size() < _Capacity)
; 1467 : 			_Xlen();	// result too long
; 1468 : 		else
; 1469 : 			{	// nonempty array, allocate storage
; 1470 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1471 : 			this->_Mylast = this->_Myfirst;
; 1472 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1473 : 			}
; 1474 : 		return (true);
; 1475 : 		}
; 1476 : 
; 1477 : 	void _Destroy(pointer _First, pointer _Last)
; 1478 : 		{	// destroy [_First, _Last) using allocator
; 1479 : 		_Alty _Alval(this->_Getal());
; 1480 : 		_Destroy_range(_First, _Last, _Alval);
; 1481 : 		}
; 1482 : 
; 1483 : 	size_type _Grow_to(size_type _Count) const
; 1484 : 		{	// grow by 50% or at least to _Count
; 1485 : 		size_type _Capacity = capacity();
; 1486 : 
; 1487 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1488 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1489 : 		if (_Capacity < _Count)
; 1490 : 			_Capacity = _Count;
; 1491 : 		return (_Capacity);
; 1492 : 		}
; 1493 : 
; 1494 : 	bool _Inside(const value_type *_Ptr) const
; 1495 : 		{	// test if _Ptr points inside vector
; 1496 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);
; 1497 : 		}
; 1498 : 
; 1499 : 	void _Reallocate(size_type _Count)
; 1500 : 		{	// move to array of exactly _Count elements
; 1501 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1502 : 
; 1503 : 		_TRY_BEGIN
; 1504 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);
; 1505 : 		_CATCH_ALL
; 1506 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1507 : 		_RERAISE;
; 1508 : 		_CATCH_END
; 1509 : 
; 1510 : 		size_type _Size = size();
; 1511 : 		if (this->_Myfirst != pointer())
; 1512 : 			{	// destroy and deallocate old array
; 1513 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1514 : 			this->_Getal().deallocate(this->_Myfirst,
; 1515 : 				this->_Myend - this->_Myfirst);
; 1516 : 			}
; 1517 : 
; 1518 : 		this->_Orphan_all();
; 1519 : 		this->_Myend = _Ptr + _Count;
; 1520 : 		this->_Mylast = _Ptr + _Size;
; 1521 : 		this->_Myfirst = _Ptr;
; 1522 : 		}
; 1523 : 
; 1524 : 	void _Reserve(size_type _Count)
; 1525 : 		{	// ensure room for _Count new elements, grow exponentially
; 1526 : 		if (_Unused_capacity() < _Count)
; 1527 : 			{	// need more room, try to get it
; 1528 : 			if (max_size() - size() < _Count)
; 1529 : 				_Xlen();
; 1530 : 			_Reallocate(_Grow_to(size() + _Count));
; 1531 : 			}
; 1532 : 		}
; 1533 : 
; 1534 : 	void _Tidy()
; 1535 : 		{	// free all storage
; 1536 : 		if (this->_Myfirst != pointer())

  019b7	85 c0		 test	 eax, eax
  019b9	74 3c		 je	 SHORT $LN560@renderChun
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 586  : 		::operator delete(_Ptr);

  019bb	50		 push	 eax
  019bc	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  019c1	83 c4 04	 add	 esp, 4
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector

; 1542 : 			this->_Myfirst = pointer();

  019c4	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1543 : 			this->_Mylast = pointer();

  019cb	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0

; 1544 : 			this->_Myend = pointer();

  019d2	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0

; 1051 : 				_Tidy();
; 1052 : 			else

  019d9	eb 1c		 jmp	 SHORT $LN560@renderChun
$LN561@renderChun:

; 1054 : 			}
; 1055 : 		}
; 1056 :  #endif /* _HAS_CPP0X */
; 1057 : 
; 1058 : 	void resize(size_type _Newsize)
; 1059 : 		{	// determine new length, padding as needed
; 1060 : 		if (_Newsize < size())
; 1061 : 			erase(begin() + _Newsize, end());
; 1062 : 		else if (size() < _Newsize)
; 1063 : 			{	// pad as needed
; 1064 : 			_Alty _Alval(this->_Getal());
; 1065 : 			_Reserve(_Newsize - size());
; 1066 : 			_TRY_BEGIN
; 1067 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1068 : 				_Alval);
; 1069 : 			_CATCH_ALL
; 1070 : 			_Tidy();
; 1071 : 			_RERAISE;
; 1072 : 			_CATCH_END
; 1073 : 			this->_Mylast += _Newsize - size();
; 1074 : 			}
; 1075 : 		}
; 1076 : 
; 1077 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1078 : 		{	// determine new length, padding with _Val elements as needed
; 1079 : 		if (_Newsize < size())
; 1080 : 			erase(begin() + _Newsize, end());
; 1081 : 		else if (size() < _Newsize)
; 1082 : 			_Insert_n(end(), _Newsize - size(), _Val);
; 1083 : 		}
; 1084 : 
; 1085 : 	size_type size() const _NOEXCEPT
; 1086 : 		{	// return length of sequence
; 1087 : 		return (this->_Mylast - this->_Myfirst);

  019db	2b c8		 sub	 ecx, eax
  019dd	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  019e2	f7 e9		 imul	 ecx
  019e4	c1 fa 02	 sar	 edx, 2
  019e7	8b c2		 mov	 eax, edx
  019e9	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  019ec	03 c2		 add	 eax, edx

; 1053 : 				_Reallocate(size());

  019ee	50		 push	 eax
  019ef	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  019f2	e8 00 00 00 00	 call	 ?_Reallocate@?$vector@VVertexUVRGBA@gfxu@@V?$allocator@VVertexUVRGBA@gfxu@@@std@@@std@@IAEXI@Z ; std::vector<gfxu::VertexUVRGBA,std::allocator<gfxu::VertexUVRGBA> >::_Reallocate
$LN560@renderChun:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\mutex

; 43   : 		_Mtx_lockX(&_Mtx);

  019f7	8b 45 08	 mov	 eax, DWORD PTR _chunk$[ebp]
  019fa	83 c0 1c	 add	 eax, 28			; 0000001cH
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 68   : 	return (_Check_C_return(_Mtx_lock(_Mtx)));

  019fd	50		 push	 eax
  019fe	e8 00 00 00 00	 call	 __Mtx_lock
  01a03	83 c4 04	 add	 esp, 4

; 32   : 	if (_Res != _Thrd_success)

  01a06	85 c0		 test	 eax, eax
  01a08	74 09		 je	 SHORT $LN590@renderChun

; 33   : 		_Throw_C_error(_Res);

  01a0a	50		 push	 eax
  01a0b	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
  01a10	83 c4 04	 add	 esp, 4
$LN590@renderChun:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 487  : 		_Resetp(_Px);

  01a13	56		 push	 esi
  01a14	8d 4d a0	 lea	 ecx, DWORD PTR _vertexStream$[ebp]

; 129  : 		}
; 130  : 
; 131  : 	long _Use_count() const
; 132  : 		{	// return use count
; 133  : 		return (_Get_uses());
; 134  : 		}
; 135  : 
; 136  : 	bool _Expired() const
; 137  : 		{	// return true if _Uses == 0
; 138  : 		return (_Get_uses() == 0);
; 139  : 		}
; 140  : 
; 141  : 	virtual void *_Get_deleter(const _XSTD2 type_info&) const
; 142  : 		{	// return address of deleter object
; 143  : 		return (0);
; 144  : 		}
; 145  : 	};
; 146  : 
; 147  : 	// TEMPLATE CLASS _Ref_count
; 148  : template<class _Ty>
; 149  : 	class _Ref_count
; 150  : 	: public _Ref_count_base
; 151  : 	{	// handle reference counting for object without deleter
; 152  : public:
; 153  : 	_Ref_count(_Ty *_Px)
; 154  : 		: _Ref_count_base(), _Ptr(_Px)
; 155  : 		{	// construct
; 156  : 		}
; 157  : 
; 158  : private:
; 159  : 	virtual void _Destroy()
; 160  : 		{	// destroy managed resource
; 161  : 		delete _Ptr;
; 162  : 		}
; 163  : 
; 164  : 	virtual void _Delete_this()
; 165  : 		{	// destroy self
; 166  : 		delete this;
; 167  : 		}
; 168  : 
; 169  : 	_Ty * _Ptr;
; 170  : 	};
; 171  : 
; 172  : 	// TEMPLATE CLASS _Ref_count_del
; 173  : template<class _Ty,
; 174  : 	class _Dx>
; 175  : 	class _Ref_count_del
; 176  : 	: public _Ref_count_base
; 177  : 	{	// handle reference counting for object with deleter
; 178  : public:
; 179  : 	_Ref_count_del(_Ty *_Px, _Dx _Dt)
; 180  : 		: _Ref_count_base(), _Ptr(_Px), _Dtor(_Dt)
; 181  : 		{	// construct
; 182  : 		}
; 183  : 
; 184  : 	virtual void *_Get_deleter(const _XSTD2 type_info& _Typeid) const
; 185  : 		{	// return address of deleter object
; 186  : 		return ((void *)(_Typeid == typeid(_Dx) ? &_Dtor : 0));
; 187  : 		}
; 188  : 
; 189  : private:
; 190  : 	virtual void _Destroy()
; 191  : 		{	// destroy managed resource
; 192  : 		_Dtor(_Ptr);
; 193  : 		}
; 194  : 
; 195  : 	virtual void _Delete_this()
; 196  : 		{	// destroy self
; 197  : 		delete this;
; 198  : 		}
; 199  : 
; 200  : 	_Ty * _Ptr;
; 201  : 	_Dx _Dtor;	// the stored destructor for the controlled object
; 202  : 	};
; 203  : 
; 204  : 	// TEMPLATE CLASS _Ref_count_del_alloc
; 205  : template<class _Ty,
; 206  : 	class _Dx,
; 207  : 	class _Alloc>
; 208  : 	class _Ref_count_del_alloc
; 209  : 	: public _Ref_count_base
; 210  : 	{	// handle reference counting for object with deleter and allocator
; 211  : public:
; 212  : 	typedef _Ref_count_del_alloc<_Ty, _Dx, _Alloc> _Myty;
; 213  : 	typedef typename _Alloc::template rebind<_Myty>::other _Myalty;
; 214  : 
; 215  : 	_Ref_count_del_alloc(_Ty *_Px, _Dx _Dt, _Myalty _Al)
; 216  : 		: _Ref_count_base(), _Ptr(_Px), _Dtor(_Dt), _Myal(_Al)
; 217  : 		{	// construct
; 218  : 		}
; 219  : 
; 220  : 	virtual void *_Get_deleter(const _XSTD2 type_info& _Typeid) const
; 221  : 		{	// return address of deleter object
; 222  : 		return ((void *)(_Typeid == typeid(_Dx) ? &_Dtor : 0));
; 223  : 		}
; 224  : 
; 225  : private:
; 226  : 	virtual void _Destroy()
; 227  : 		{	// destroy managed resource
; 228  : 		_Dtor(_Ptr);
; 229  : 		}
; 230  : 
; 231  : 	virtual void _Delete_this()
; 232  : 		{	// destroy self
; 233  : 		_Myalty _Al = _Myal;
; 234  : 		_Al.destroy(this);
; 235  : 		_Al.deallocate(this, 1);
; 236  : 		}
; 237  : 
; 238  : 	_Ty * _Ptr;
; 239  : 	_Dx _Dtor;	// the stored destructor for the controlled object
; 240  : 	_Myalty _Myal;	// the stored allocator for this
; 241  : 	};
; 242  : 
; 243  : 	// DECLARATIONS
; 244  : template<class _Ty>
; 245  : 	class weak_ptr;
; 246  : template<class _Ty>
; 247  : 	class shared_ptr;
; 248  : template<class _Ty>
; 249  : 	class enable_shared_from_this;
; 250  : struct _Static_tag {};
; 251  : struct _Const_tag {};
; 252  : struct _Dynamic_tag {};
; 253  : template<class _Ty1,
; 254  : 	class _Ty2>
; 255  : 	void _Do_enable(_Ty1 *, enable_shared_from_this<_Ty2> *,
; 256  : 		_Ref_count_base *);
; 257  : 
; 258  : template<class _Ty>
; 259  : 	inline void _Enable_shared(_Ty *_Ptr, _Ref_count_base *_Refptr,
; 260  : 		typename _Ty::_EStype * = 0)
; 261  : 	{	// reset internal weak pointer
; 262  : 	if (_Ptr)
; 263  : 		_Do_enable(_Ptr,
; 264  : 			(enable_shared_from_this<typename _Ty::_EStype>*)_Ptr, _Refptr);
; 265  : 	}
; 266  : 
; 267  : inline void _Enable_shared(const volatile void *, const volatile void *)
; 268  : 	{	// not derived from enable_shared_from_this; do nothing
; 269  : 	}
; 270  : 
; 271  : 	// TEMPLATE CLASS _Ptr_base
; 272  : template<class _Ty>
; 273  : 	class _Ptr_base
; 274  : 	{	// base class for shared_ptr and weak_ptr
; 275  : public:
; 276  : 	typedef _Ptr_base<_Ty> _Myt;
; 277  : 	typedef _Ty _Elem;
; 278  : 	typedef _Elem element_type;
; 279  : 
; 280  : 	_Ptr_base()
; 281  : 		: _Ptr(0), _Rep(0)
; 282  : 		{	// construct

  01a17	c7 45 a0 00 00
	00 00		 mov	 DWORD PTR _vertexStream$[ebp], 0
  01a1e	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR _vertexStream$[ebp+4], 0

; 487  : 		_Resetp(_Px);

  01a25	e8 00 00 00 00	 call	 ??$_Resetp@VVertexStream@gfxu@@@?$shared_ptr@VVertexStream@gfxu@@@std@@AAEXPAVVertexStream@gfxu@@@Z ; std::shared_ptr<gfxu::VertexStream>::_Resetp<gfxu::VertexStream>
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp

; 435  : 	std::shared_ptr<gfxu::VertexStream> vertexStream(vStream);

  01a2a	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 407  : 		if (_Other_rep)

  01a2e	8b 75 a4	 mov	 esi, DWORD PTR _vertexStream$[ebp+4]
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp

; 436  : 	chunk->renderStream = vertexStream;

  01a31	8b 55 08	 mov	 edx, DWORD PTR _chunk$[ebp]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 407  : 		if (_Other_rep)

  01a34	85 f6		 test	 esi, esi
  01a36	74 0c		 je	 SHORT $LN620@renderChun

; 108  : 		_MT_INCR(_Ignored, _Uses);

  01a38	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  01a3b	b9 01 00 00 00	 mov	 ecx, 1
  01a40	f0 0f c1 08	 lock	  xadd	 DWORD PTR [eax], ecx
$LN620@renderChun:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility

; 48   : 	_Left = _Move(_Right);

  01a44	8b 7a 24	 mov	 edi, DWORD PTR [edx+36]

; 49   : 	_Right = _Move(_Tmp);

  01a47	8b 45 a0	 mov	 eax, DWORD PTR _vertexStream$[ebp]
  01a4a	89 72 24	 mov	 DWORD PTR [edx+36], esi
  01a4d	89 42 20	 mov	 DWORD PTR [edx+32], eax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  01a50	85 ff		 test	 edi, edi
  01a52	74 26		 je	 SHORT $LN651@renderChun

; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  01a54	83 cb ff	 or	 ebx, -1
  01a57	8d 47 04	 lea	 eax, DWORD PTR [edi+4]
  01a5a	8b cb		 mov	 ecx, ebx
  01a5c	f0 0f c1 08	 lock	  xadd	 DWORD PTR [eax], ecx
  01a60	75 18		 jne	 SHORT $LN651@renderChun

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  01a62	8b 07		 mov	 eax, DWORD PTR [edi]
  01a64	8b cf		 mov	 ecx, edi
  01a66	ff 10		 call	 DWORD PTR [eax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  01a68	8d 47 08	 lea	 eax, DWORD PTR [edi+8]
  01a6b	8b d3		 mov	 edx, ebx
  01a6d	f0 0f c1 10	 lock	  xadd	 DWORD PTR [eax], edx
  01a71	75 07		 jne	 SHORT $LN651@renderChun

; 128  : 			_Delete_this();

  01a73	8b 07		 mov	 eax, DWORD PTR [edi]
  01a75	8b cf		 mov	 ecx, edi
  01a77	ff 50 04	 call	 DWORD PTR [eax+4]
$LN651@renderChun:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\mutex

; 53   : 		_Mtx_unlockX(&_Mtx);

  01a7a	8b 45 08	 mov	 eax, DWORD PTR _chunk$[ebp]
  01a7d	83 c0 1c	 add	 eax, 28			; 0000001cH
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 83   : 	return (_Check_C_return(_Mtx_unlock(_Mtx)));

  01a80	50		 push	 eax
  01a81	e8 00 00 00 00	 call	 __Mtx_unlock
  01a86	83 c4 04	 add	 esp, 4

; 32   : 	if (_Res != _Thrd_success)

  01a89	85 c0		 test	 eax, eax
  01a8b	74 09		 je	 SHORT $LN662@renderChun

; 33   : 		_Throw_C_error(_Res);

  01a8d	50		 push	 eax
  01a8e	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
  01a93	83 c4 04	 add	 esp, 4
$LN662@renderChun:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  01a96	83 cf ff	 or	 edi, -1
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp

; 439  : 	return true;

  01a99	b3 01		 mov	 bl, 1
  01a9b	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  01a9f	85 f6		 test	 esi, esi
  01aa1	74 40		 je	 SHORT $LN673@renderChun

; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  01aa3	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  01aa6	8b cf		 mov	 ecx, edi
  01aa8	f0 0f c1 08	 lock	  xadd	 DWORD PTR [eax], ecx
  01aac	75 35		 jne	 SHORT $LN673@renderChun

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  01aae	8b 06		 mov	 eax, DWORD PTR [esi]
  01ab0	8b ce		 mov	 ecx, esi
  01ab2	ff 10		 call	 DWORD PTR [eax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  01ab4	8d 46 08	 lea	 eax, DWORD PTR [esi+8]
  01ab7	8b d7		 mov	 edx, edi
  01ab9	f0 0f c1 10	 lock	  xadd	 DWORD PTR [eax], edx
  01abd	75 24		 jne	 SHORT $LN673@renderChun

; 128  : 			_Delete_this();

  01abf	8b 06		 mov	 eax, DWORD PTR [esi]
  01ac1	8b ce		 mov	 ecx, esi
  01ac3	ff 50 04	 call	 DWORD PTR [eax+4]
  01ac6	eb 1b		 jmp	 SHORT $LN673@renderChun
$LN75@renderChun:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\mutex

; 53   : 		_Mtx_unlockX(&_Mtx);

  01ac8	8d 41 18	 lea	 eax, DWORD PTR [ecx+24]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 83   : 	return (_Check_C_return(_Mtx_unlock(_Mtx)));

  01acb	50		 push	 eax
  01acc	e8 00 00 00 00	 call	 __Mtx_unlock
  01ad1	83 c4 04	 add	 esp, 4

; 32   : 	if (_Res != _Thrd_success)

  01ad4	85 c0		 test	 eax, eax
  01ad6	74 09		 je	 SHORT $LN122@renderChun

; 33   : 		_Throw_C_error(_Res);

  01ad8	50		 push	 eax
  01ad9	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
  01ade	83 c4 04	 add	 esp, 4
$LN122@renderChun:
  01ae1	b3 01		 mov	 bl, 1
$LN673@renderChun:
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp

; 439  : 	return true;

  01ae3	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  01aea	8b 75 0c	 mov	 esi, DWORD PTR _chunk$[ebp+4]
  01aed	85 f6		 test	 esi, esi
  01aef	74 22		 je	 SHORT $LN708@renderChun

; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  01af1	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  01af4	8b cf		 mov	 ecx, edi
  01af6	f0 0f c1 08	 lock	  xadd	 DWORD PTR [eax], ecx
  01afa	75 17		 jne	 SHORT $LN708@renderChun

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  01afc	8b 06		 mov	 eax, DWORD PTR [esi]
  01afe	8b ce		 mov	 ecx, esi
  01b00	ff 10		 call	 DWORD PTR [eax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  01b02	8d 56 08	 lea	 edx, DWORD PTR [esi+8]
  01b05	f0 0f c1 3a	 lock	  xadd	 DWORD PTR [edx], edi
  01b09	4f		 dec	 edi
  01b0a	75 07		 jne	 SHORT $LN708@renderChun

; 128  : 			_Delete_this();

  01b0c	8b 16		 mov	 edx, DWORD PTR [esi]
  01b0e	8b ce		 mov	 ecx, esi
  01b10	ff 52 04	 call	 DWORD PTR [edx+4]
$LN708@renderChun:
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp

; 439  : 	return true;

  01b13	8a c3		 mov	 al, bl

; 440  : }

  01b15	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  01b18	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  01b1f	59		 pop	 ecx
  01b20	5f		 pop	 edi
  01b21	5e		 pop	 esi
  01b22	5b		 pop	 ebx
  01b23	8b e5		 mov	 esp, ebp
  01b25	5d		 pop	 ebp
  01b26	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?renderChunk@@YA_NV?$shared_ptr@VChunkBase@@@std@@@Z$0:
  00000	8d 4d 08	 lea	 ecx, DWORD PTR _chunk$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$shared_ptr@VChunkBase@@@std@@QAE@XZ ; std::shared_ptr<ChunkBase>::~shared_ptr<ChunkBase>
__unwindfunclet$?renderChunk@@YA_NV?$shared_ptr@VChunkBase@@@std@@@Z$1:
  00008	8d 4d a0	 lea	 ecx, DWORD PTR _c$2[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1?$shared_ptr@VChunkBase@@@std@@QAE@XZ ; std::shared_ptr<ChunkBase>::~shared_ptr<ChunkBase>
__unwindfunclet$?renderChunk@@YA_NV?$shared_ptr@VChunkBase@@@std@@@Z$2:
  00010	8b 45 a4	 mov	 eax, DWORD PTR $T3[ebp]
  00013	50		 push	 eax
  00014	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00019	59		 pop	 ecx
  0001a	c3		 ret	 0
__unwindfunclet$?renderChunk@@YA_NV?$shared_ptr@VChunkBase@@@std@@@Z$3:
  0001b	8d 4d a0	 lea	 ecx, DWORD PTR _vertexStream$[ebp]
  0001e	e9 00 00 00 00	 jmp	 ??1?$shared_ptr@VVertexStream@gfxu@@@std@@QAE@XZ ; std::shared_ptr<gfxu::VertexStream>::~shared_ptr<gfxu::VertexStream>
__ehhandler$?renderChunk@@YA_NV?$shared_ptr@VChunkBase@@@std@@@Z:
  00023	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00027	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0002a	8b 4a 9c	 mov	 ecx, DWORD PTR [edx-100]
  0002d	33 c8		 xor	 ecx, eax
  0002f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00034	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?renderChunk@@YA_NV?$shared_ptr@VChunkBase@@@std@@@Z
  00039	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?renderChunk@@YA_NV?$shared_ptr@VChunkBase@@@std@@@Z ENDP ; renderChunk
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\queue
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp
;	COMDAT ?renderFirstPossible@@YA_NAAV?$queue@V?$shared_ptr@VChunkBase@@@std@@V?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@2@@std@@@Z
_TEXT	SEGMENT
$T2 = -44						; size = 12
_chunk$3 = -32						; size = 8
$T4 = -24						; size = 4
_i$1$ = -20						; size = 4
$T5 = -16						; size = 4
__$EHRec$ = -12						; size = 12
?renderFirstPossible@@YA_NAAV?$queue@V?$shared_ptr@VChunkBase@@@std@@V?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@2@@std@@@Z PROC ; renderFirstPossible, COMDAT
; _q$ = ecx

; 443  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?renderFirstPossible@@YA_NAAV?$queue@V?$shared_ptr@VChunkBase@@@std@@V?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@2@@std@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 24	 sub	 esp, 36			; 00000024H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	8b f9		 mov	 edi, ecx

; 444  : 	for(unsigned int i = 0; !GlobalThread::stop && (i < q.size()); i++)

  0002a	33 c0		 xor	 eax, eax
  0002c	89 45 ec	 mov	 DWORD PTR _i$1$[ebp], eax
  0002f	38 05 00 00 00
	00		 cmp	 BYTE PTR ?stop@GlobalThread@@3_NA, al ; GlobalThread::stop
  00035	0f 85 74 01 00
	00		 jne	 $LN3@renderFirs
  0003b	eb 03 8d 49 00	 npad	 5
$LL5@renderFirs:
  00040	3b 47 10	 cmp	 eax, DWORD PTR [edi+16]
  00043	0f 83 66 01 00
	00		 jae	 $LN3@renderFirs
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 1426 : 		return (*begin());

  00049	8d 45 d4	 lea	 eax, DWORD PTR $T2[ebp]
  0004c	50		 push	 eax
  0004d	8b cf		 mov	 ecx, edi
  0004f	e8 00 00 00 00	 call	 ?begin@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@2@XZ ; std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::begin
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility

; 178  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

  00054	8b 08		 mov	 ecx, DWORD PTR [eax]
  00056	85 c9		 test	 ecx, ecx
  00058	75 04		 jne	 SHORT $LN24@renderFirs
  0005a	33 f6		 xor	 esi, esi
  0005c	eb 02		 jmp	 SHORT $LN25@renderFirs
$LN24@renderFirs:
  0005e	8b 31		 mov	 esi, DWORD PTR [ecx]
$LN25@renderFirs:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 787  : 		return ((_Off / _DEQUESIZ) & (this->_Mapsize - 1));

  00060	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00063	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00066	8b c2		 mov	 eax, edx
  00068	d1 e8		 shr	 eax, 1
  0006a	49		 dec	 ecx
  0006b	23 c8		 and	 ecx, eax

; 345  : 		return (_Mycont->_Map[_Block][_Off]);

  0006d	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00070	83 e2 01	 and	 edx, 1
  00073	8b 04 88	 mov	 eax, DWORD PTR [eax+ecx*4]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 357  : 		_Reset(_Other._Ptr, _Other._Rep);

  00076	8b 74 d0 04	 mov	 esi, DWORD PTR [eax+edx*8+4]
  0007a	8b 14 d0	 mov	 edx, DWORD PTR [eax+edx*8]
  0007d	89 55 e8	 mov	 DWORD PTR $T4[ebp], edx

; 358  : 		}
; 359  : 
; 360  : 	template<class _Ty2>
; 361  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, bool _Throw)
; 362  : 		{	// release resource and take ownership from weak_ptr _Other._Ptr
; 363  : 		_Reset(_Other._Ptr, _Other._Rep, _Throw);
; 364  : 		}
; 365  : 
; 366  : 	template<class _Ty2>
; 367  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Static_tag&)
; 368  : 		{	// release resource and take ownership of _Other._Ptr
; 369  : 		_Reset(static_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 370  : 		}
; 371  : 
; 372  : 	template<class _Ty2>
; 373  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Const_tag&)
; 374  : 		{	// release resource and take ownership of _Other._Ptr
; 375  : 		_Reset(const_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 376  : 		}
; 377  : 
; 378  : 	template<class _Ty2>
; 379  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Dynamic_tag&)
; 380  : 		{	// release resource and take ownership of _Other._Ptr
; 381  : 		_Elem *_Ptr = dynamic_cast<_Elem *>(_Other._Ptr);
; 382  : 		if (_Ptr)
; 383  : 			_Reset(_Ptr, _Other._Rep);
; 384  : 		else
; 385  : 			_Reset();
; 386  : 		}
; 387  : 
; 388  : 	template<class _Ty2>
; 389  : 		void _Reset(auto_ptr<_Ty2>&& _Other)
; 390  : 		{	// release resource and take _Other.get()
; 391  : 		_Ty2 *_Px = _Other.get();
; 392  : 		_Reset0(_Px, new _Ref_count<_Elem>(_Px));
; 393  : 		_Other.release();
; 394  : 		_Enable_shared(_Px, _Rep);
; 395  : 		}
; 396  : 
; 397  :  #if _HAS_CPP0X
; 398  : 	template<class _Ty2>
; 399  : 		void _Reset(_Ty *_Ptr, const _Ptr_base<_Ty2>& _Other)
; 400  : 		{	// release resource and alias _Ptr with _Other_rep
; 401  : 		_Reset(_Ptr, _Other._Rep);
; 402  : 		}
; 403  :  #endif /* _HAS_CPP0X */
; 404  : 
; 405  : 	void _Reset(_Ty *_Other_ptr, _Ref_count_base *_Other_rep)
; 406  : 		{	// release resource and take _Other_ptr through _Other_rep
; 407  : 		if (_Other_rep)

  00080	85 f6		 test	 esi, esi
  00082	74 0c		 je	 SHORT $LN45@renderFirs

; 108  : 		_MT_INCR(_Ignored, _Uses);

  00084	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00087	b9 01 00 00 00	 mov	 ecx, 1
  0008c	f0 0f c1 08	 lock	  xadd	 DWORD PTR [eax], ecx
$LN45@renderFirs:

; 425  : 			_Rep->_Decref();
; 426  : 		_Rep = _Other_rep;

  00090	89 75 e4	 mov	 DWORD PTR _chunk$3[ebp+4], esi

; 427  : 		_Ptr = _Other_ptr;

  00093	89 55 e0	 mov	 DWORD PTR _chunk$3[ebp], edx
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp

; 446  : 		std::shared_ptr<ChunkBase> chunk = q.front();

  00096	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 1382 : 		return (this->_Mysize == 0);

  0009d	83 7f 10 00	 cmp	 DWORD PTR [edi+16], 0

; 1427 : 		}
; 1428 : 
; 1429 : 	const_reference front() const
; 1430 : 		{	// return first element of nonmutable sequence
; 1431 : 		return (*begin());
; 1432 : 		}
; 1433 : 
; 1434 : 	reference back()
; 1435 : 		{	// return last element of mutable sequence
; 1436 : 		return (*(end() - 1));
; 1437 : 		}
; 1438 : 
; 1439 : 	const_reference back() const
; 1440 : 		{	// return last element of nonmutable sequence
; 1441 : 		return (*(end() - 1));
; 1442 : 		}
; 1443 : 
; 1444 : 	void push_front(const value_type& _Val)
; 1445 : 		{	// insert element at beginning
; 1446 : 		this->_Orphan_all();
; 1447 : 		_PUSH_FRONT_BEGIN;
; 1448 : 		this->_Getal().construct(
; 1449 : 			this->_Map[_Block] + _Newoff % _DEQUESIZ, _Val);
; 1450 : 		_PUSH_FRONT_END;
; 1451 : 		}
; 1452 : 
; 1453 : 	void pop_front()
; 1454 : 		{	// erase element at beginning
; 1455 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1456 : 		if (empty())
; 1457 : 			_DEBUG_ERROR("deque empty before pop");
; 1458 : 		else
; 1459 : 			{	// something to erase, do it
; 1460 : 			_Orphan_off(this->_Myoff);
; 1461 : 			size_type _Block = this->_Getblock(this->_Myoff);
; 1462 : 			this->_Getal().destroy(
; 1463 : 				this->_Map[_Block] + this->_Myoff % _DEQUESIZ);
; 1464 : 			if (--this->_Mysize == 0)
; 1465 : 				this->_Myoff = 0;
; 1466 : 			else
; 1467 : 				++this->_Myoff;
; 1468 : 			}
; 1469 : 
; 1470 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1471 : 		if (!empty())

  000a1	74 54		 je	 SHORT $LN50@renderFirs

; 787  : 		return ((_Off / _DEQUESIZ) & (this->_Mapsize - 1));

  000a3	8b 57 0c	 mov	 edx, DWORD PTR [edi+12]
  000a6	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  000a9	8b c2		 mov	 eax, edx
  000ab	d1 e8		 shr	 eax, 1
  000ad	49		 dec	 ecx
  000ae	23 c8		 and	 ecx, eax

; 1472 : 			{	// something to erase, do it
; 1473 : 			size_type _Block = this->_Getblock(this->_Myoff);
; 1474 : 			this->_Getal().destroy(
; 1475 : 				this->_Map[_Block] + this->_Myoff % _DEQUESIZ);

  000b0	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  000b3	83 e2 01	 and	 edx, 1
  000b6	8b 04 88	 mov	 eax, DWORD PTR [eax+ecx*4]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  000b9	8b 5c d0 04	 mov	 ebx, DWORD PTR [eax+edx*8+4]
  000bd	85 db		 test	 ebx, ebx
  000bf	74 25		 je	 SHORT $LN78@renderFirs

; 109  : 		}
; 110  : 
; 111  : 	void _Incwref()
; 112  : 		{	// increment weak reference count
; 113  : 		_MT_INCR(_Ignored, _Weaks);
; 114  : 		}
; 115  : 
; 116  : 	void _Decref()
; 117  : 		{	// decrement use count
; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  000c1	8d 43 04	 lea	 eax, DWORD PTR [ebx+4]
  000c4	83 c9 ff	 or	 ecx, -1
  000c7	f0 0f c1 08	 lock	  xadd	 DWORD PTR [eax], ecx
  000cb	75 19		 jne	 SHORT $LN78@renderFirs

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  000cd	8b 03		 mov	 eax, DWORD PTR [ebx]
  000cf	8b cb		 mov	 ecx, ebx
  000d1	ff 10		 call	 DWORD PTR [eax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  000d3	8d 43 08	 lea	 eax, DWORD PTR [ebx+8]
  000d6	83 ca ff	 or	 edx, -1
  000d9	f0 0f c1 10	 lock	  xadd	 DWORD PTR [eax], edx
  000dd	75 07		 jne	 SHORT $LN78@renderFirs

; 128  : 			_Delete_this();

  000df	8b 03		 mov	 eax, DWORD PTR [ebx]
  000e1	8b cb		 mov	 ecx, ebx
  000e3	ff 50 04	 call	 DWORD PTR [eax+4]
$LN78@renderFirs:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 1476 : 			if (--this->_Mysize == 0)

  000e6	ff 4f 10	 dec	 DWORD PTR [edi+16]
  000e9	75 09		 jne	 SHORT $LN51@renderFirs

; 1477 : 				this->_Myoff = 0;

  000eb	c7 47 0c 00 00
	00 00		 mov	 DWORD PTR [edi+12], 0

; 1478 : 			else

  000f2	eb 03		 jmp	 SHORT $LN50@renderFirs
$LN51@renderFirs:

; 1479 : 				++this->_Myoff;

  000f4	ff 47 0c	 inc	 DWORD PTR [edi+12]
$LN50@renderFirs:
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp

; 448  : 		if(renderChunk(chunk))

  000f7	83 ec 08	 sub	 esp, 8
  000fa	8b d4		 mov	 edx, esp
  000fc	89 55 f0	 mov	 DWORD PTR $T5[ebp], edx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 282  : 		{	// construct

  000ff	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0
  00105	c7 42 04 00 00
	00 00		 mov	 DWORD PTR [edx+4], 0

; 358  : 		}
; 359  : 
; 360  : 	template<class _Ty2>
; 361  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, bool _Throw)
; 362  : 		{	// release resource and take ownership from weak_ptr _Other._Ptr
; 363  : 		_Reset(_Other._Ptr, _Other._Rep, _Throw);
; 364  : 		}
; 365  : 
; 366  : 	template<class _Ty2>
; 367  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Static_tag&)
; 368  : 		{	// release resource and take ownership of _Other._Ptr
; 369  : 		_Reset(static_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 370  : 		}
; 371  : 
; 372  : 	template<class _Ty2>
; 373  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Const_tag&)
; 374  : 		{	// release resource and take ownership of _Other._Ptr
; 375  : 		_Reset(const_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 376  : 		}
; 377  : 
; 378  : 	template<class _Ty2>
; 379  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Dynamic_tag&)
; 380  : 		{	// release resource and take ownership of _Other._Ptr
; 381  : 		_Elem *_Ptr = dynamic_cast<_Elem *>(_Other._Ptr);
; 382  : 		if (_Ptr)
; 383  : 			_Reset(_Ptr, _Other._Rep);
; 384  : 		else
; 385  : 			_Reset();
; 386  : 		}
; 387  : 
; 388  : 	template<class _Ty2>
; 389  : 		void _Reset(auto_ptr<_Ty2>&& _Other)
; 390  : 		{	// release resource and take _Other.get()
; 391  : 		_Ty2 *_Px = _Other.get();
; 392  : 		_Reset0(_Px, new _Ref_count<_Elem>(_Px));
; 393  : 		_Other.release();
; 394  : 		_Enable_shared(_Px, _Rep);
; 395  : 		}
; 396  : 
; 397  :  #if _HAS_CPP0X
; 398  : 	template<class _Ty2>
; 399  : 		void _Reset(_Ty *_Ptr, const _Ptr_base<_Ty2>& _Other)
; 400  : 		{	// release resource and alias _Ptr with _Other_rep
; 401  : 		_Reset(_Ptr, _Other._Rep);
; 402  : 		}
; 403  :  #endif /* _HAS_CPP0X */
; 404  : 
; 405  : 	void _Reset(_Ty *_Other_ptr, _Ref_count_base *_Other_rep)
; 406  : 		{	// release resource and take _Other_ptr through _Other_rep
; 407  : 		if (_Other_rep)

  0010c	85 f6		 test	 esi, esi
  0010e	74 0c		 je	 SHORT $LN90@renderFirs

; 108  : 		_MT_INCR(_Ignored, _Uses);

  00110	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00113	b9 01 00 00 00	 mov	 ecx, 1
  00118	f0 0f c1 08	 lock	  xadd	 DWORD PTR [eax], ecx
$LN90@renderFirs:

; 408  : 			_Other_rep->_Incref();
; 409  : 		_Reset0(_Other_ptr, _Other_rep);
; 410  : 		}
; 411  : 
; 412  : 	void _Reset(_Ty *_Other_ptr, _Ref_count_base *_Other_rep, bool _Throw)
; 413  : 		{	// take _Other_ptr through _Other_rep from weak_ptr if not expired
; 414  : 			// otherwise, leave in default state if !_Throw,
; 415  : 			// otherwise throw exception
; 416  : 		if (_Other_rep && _Other_rep->_Incref_nz())
; 417  : 			_Reset0(_Other_ptr, _Other_rep);
; 418  : 		else if (_Throw)
; 419  : 			_THROW_NCEE(bad_weak_ptr, 0);
; 420  : 		}
; 421  : 
; 422  : 	void _Reset0(_Ty *_Other_ptr, _Ref_count_base *_Other_rep)
; 423  : 		{	// release resource and take new resource
; 424  : 		if (_Rep != 0)

  0011c	8b 5a 04	 mov	 ebx, DWORD PTR [edx+4]
  0011f	85 db		 test	 ebx, ebx
  00121	74 28		 je	 SHORT $LN98@renderFirs

; 109  : 		}
; 110  : 
; 111  : 	void _Incwref()
; 112  : 		{	// increment weak reference count
; 113  : 		_MT_INCR(_Ignored, _Weaks);
; 114  : 		}
; 115  : 
; 116  : 	void _Decref()
; 117  : 		{	// decrement use count
; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  00123	8d 43 04	 lea	 eax, DWORD PTR [ebx+4]
  00126	83 c9 ff	 or	 ecx, -1
  00129	f0 0f c1 08	 lock	  xadd	 DWORD PTR [eax], ecx
  0012d	75 1c		 jne	 SHORT $LN98@renderFirs

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  0012f	8b 03		 mov	 eax, DWORD PTR [ebx]
  00131	8b cb		 mov	 ecx, ebx
  00133	ff 10		 call	 DWORD PTR [eax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  00135	8d 43 08	 lea	 eax, DWORD PTR [ebx+8]
  00138	83 ca ff	 or	 edx, -1
  0013b	f0 0f c1 10	 lock	  xadd	 DWORD PTR [eax], edx
  0013f	75 07		 jne	 SHORT $LN129@renderFirs

; 128  : 			_Delete_this();

  00141	8b 03		 mov	 eax, DWORD PTR [ebx]
  00143	8b cb		 mov	 ecx, ebx
  00145	ff 50 04	 call	 DWORD PTR [eax+4]
$LN129@renderFirs:
  00148	8b 55 f0	 mov	 edx, DWORD PTR $T5[ebp]
$LN98@renderFirs:

; 427  : 		_Ptr = _Other_ptr;

  0014b	8b 45 e8	 mov	 eax, DWORD PTR $T4[ebp]
  0014e	89 72 04	 mov	 DWORD PTR [edx+4], esi
  00151	89 02		 mov	 DWORD PTR [edx], eax
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp

; 448  : 		if(renderChunk(chunk))

  00153	e8 00 00 00 00	 call	 ?renderChunk@@YA_NV?$shared_ptr@VChunkBase@@@std@@@Z ; renderChunk
  00158	83 c4 08	 add	 esp, 8
  0015b	84 c0		 test	 al, al
  0015d	75 64		 jne	 SHORT $LN126@renderFirs
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\queue

; 155  : 		c.push_back(_Val);

  0015f	8d 45 e0	 lea	 eax, DWORD PTR _chunk$3[ebp]
  00162	50		 push	 eax
  00163	8b cf		 mov	 ecx, edi
  00165	e8 00 00 00 00	 call	 ?push_back@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QAEXABV?$shared_ptr@VChunkBase@@@2@@Z ; std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::push_back
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp

; 456  : 	}

  0016a	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  00171	85 f6		 test	 esi, esi
  00173	74 26		 je	 SHORT $LN4@renderFirs

; 109  : 		}
; 110  : 
; 111  : 	void _Incwref()
; 112  : 		{	// increment weak reference count
; 113  : 		_MT_INCR(_Ignored, _Weaks);
; 114  : 		}
; 115  : 
; 116  : 	void _Decref()
; 117  : 		{	// decrement use count
; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  00175	83 cb ff	 or	 ebx, -1
  00178	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  0017b	8b cb		 mov	 ecx, ebx
  0017d	f0 0f c1 08	 lock	  xadd	 DWORD PTR [eax], ecx
  00181	75 18		 jne	 SHORT $LN4@renderFirs

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  00183	8b 06		 mov	 eax, DWORD PTR [esi]
  00185	8b ce		 mov	 ecx, esi
  00187	ff 10		 call	 DWORD PTR [eax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  00189	8d 46 08	 lea	 eax, DWORD PTR [esi+8]
  0018c	8b cb		 mov	 ecx, ebx
  0018e	f0 0f c1 08	 lock	  xadd	 DWORD PTR [eax], ecx
  00192	75 07		 jne	 SHORT $LN4@renderFirs

; 128  : 			_Delete_this();

  00194	8b 06		 mov	 eax, DWORD PTR [esi]
  00196	8b ce		 mov	 ecx, esi
  00198	ff 50 04	 call	 DWORD PTR [eax+4]
$LN4@renderFirs:
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp

; 444  : 	for(unsigned int i = 0; !GlobalThread::stop && (i < q.size()); i++)

  0019b	8b 45 ec	 mov	 eax, DWORD PTR _i$1$[ebp]
  0019e	40		 inc	 eax
  0019f	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR ?stop@GlobalThread@@3_NA, 0 ; GlobalThread::stop
  001a6	89 45 ec	 mov	 DWORD PTR _i$1$[ebp], eax
  001a9	0f 84 91 fe ff
	ff		 je	 $LL5@renderFirs
$LN3@renderFirs:

; 457  : 	return false;

  001af	32 c0		 xor	 al, al

; 458  : }

  001b1	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  001b4	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  001bb	59		 pop	 ecx
  001bc	5f		 pop	 edi
  001bd	5e		 pop	 esi
  001be	5b		 pop	 ebx
  001bf	8b e5		 mov	 esp, ebp
  001c1	5d		 pop	 ebp
  001c2	c3		 ret	 0
$LN126@renderFirs:

; 450  : 			return true;

  001c3	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  001ca	85 f6		 test	 esi, esi
  001cc	74 25		 je	 SHORT $LN109@renderFirs

; 109  : 		}
; 110  : 
; 111  : 	void _Incwref()
; 112  : 		{	// increment weak reference count
; 113  : 		_MT_INCR(_Ignored, _Weaks);
; 114  : 		}
; 115  : 
; 116  : 	void _Decref()
; 117  : 		{	// decrement use count
; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  001ce	83 cb ff	 or	 ebx, -1
  001d1	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  001d4	8b cb		 mov	 ecx, ebx
  001d6	f0 0f c1 08	 lock	  xadd	 DWORD PTR [eax], ecx
  001da	75 17		 jne	 SHORT $LN109@renderFirs

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  001dc	8b 06		 mov	 eax, DWORD PTR [esi]
  001de	8b ce		 mov	 ecx, esi
  001e0	ff 10		 call	 DWORD PTR [eax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  001e2	8d 46 08	 lea	 eax, DWORD PTR [esi+8]
  001e5	f0 0f c1 18	 lock	  xadd	 DWORD PTR [eax], ebx
  001e9	4b		 dec	 ebx
  001ea	75 07		 jne	 SHORT $LN109@renderFirs

; 128  : 			_Delete_this();

  001ec	8b 06		 mov	 eax, DWORD PTR [esi]
  001ee	8b ce		 mov	 ecx, esi
  001f0	ff 50 04	 call	 DWORD PTR [eax+4]
$LN109@renderFirs:
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp

; 450  : 			return true;

  001f3	b0 01		 mov	 al, 1

; 458  : }

  001f5	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  001f8	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  001ff	59		 pop	 ecx
  00200	5f		 pop	 edi
  00201	5e		 pop	 esi
  00202	5b		 pop	 ebx
  00203	8b e5		 mov	 esp, ebp
  00205	5d		 pop	 ebp
  00206	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?renderFirstPossible@@YA_NAAV?$queue@V?$shared_ptr@VChunkBase@@@std@@V?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@2@@std@@@Z$0:
  00000	8d 4d e0	 lea	 ecx, DWORD PTR _chunk$3[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$shared_ptr@VChunkBase@@@std@@QAE@XZ ; std::shared_ptr<ChunkBase>::~shared_ptr<ChunkBase>
__ehhandler$?renderFirstPossible@@YA_NAAV?$queue@V?$shared_ptr@VChunkBase@@@std@@V?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@2@@std@@@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a cc	 mov	 ecx, DWORD PTR [edx-52]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?renderFirstPossible@@YA_NAAV?$queue@V?$shared_ptr@VChunkBase@@@std@@V?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@2@@std@@@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?renderFirstPossible@@YA_NAAV?$queue@V?$shared_ptr@VChunkBase@@@std@@V?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@2@@std@@@Z ENDP ; renderFirstPossible
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\mutex
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp
;	COMDAT ?tick@ChunkDrawThread@@EAE_NXZ
_TEXT	SEGMENT
?tick@ChunkDrawThread@@EAE_NXZ PROC			; ChunkDrawThread::tick, COMDAT
; _this$ = ecx

; 461  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	57		 push	 edi
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\mutex

; 43   : 		_Mtx_lockX(&_Mtx);

  0000a	8d be 5c 04 00
	00		 lea	 edi, DWORD PTR [esi+1116]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 68   : 	return (_Check_C_return(_Mtx_lock(_Mtx)));

  00010	57		 push	 edi
  00011	e8 00 00 00 00	 call	 __Mtx_lock
  00016	83 c4 04	 add	 esp, 4

; 32   : 	if (_Res != _Thrd_success)

  00019	85 c0		 test	 eax, eax
  0001b	74 09		 je	 SHORT $LN9@tick

; 33   : 		_Throw_C_error(_Res);

  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
  00023	83 c4 04	 add	 esp, 4
$LN9@tick:
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp

; 463  : 	bool rendered = renderFirstPossible(ChunkDrawThread::drawFirstQueue) || renderFirstPossible(ChunkDrawThread::drawQueue) || renderFirstPossible(ChunkDrawThread::drawLaterQueue);

  00026	8d 8e 20 04 00
	00		 lea	 ecx, DWORD PTR [esi+1056]
  0002c	e8 00 00 00 00	 call	 ?renderFirstPossible@@YA_NAAV?$queue@V?$shared_ptr@VChunkBase@@@std@@V?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@2@@std@@@Z ; renderFirstPossible
  00031	84 c0		 test	 al, al
  00033	75 1a		 jne	 SHORT $LN3@tick
  00035	8d 8e 34 04 00
	00		 lea	 ecx, DWORD PTR [esi+1076]
  0003b	e8 00 00 00 00	 call	 ?renderFirstPossible@@YA_NAAV?$queue@V?$shared_ptr@VChunkBase@@@std@@V?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@2@@std@@@Z ; renderFirstPossible
  00040	84 c0		 test	 al, al
  00042	75 0b		 jne	 SHORT $LN3@tick
  00044	8d 8e 48 04 00
	00		 lea	 ecx, DWORD PTR [esi+1096]
  0004a	e8 00 00 00 00	 call	 ?renderFirstPossible@@YA_NAAV?$queue@V?$shared_ptr@VChunkBase@@@std@@V?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@2@@std@@@Z ; renderFirstPossible
$LN3@tick:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 83   : 	return (_Check_C_return(_Mtx_unlock(_Mtx)));

  0004f	57		 push	 edi
  00050	e8 00 00 00 00	 call	 __Mtx_unlock
  00055	83 c4 04	 add	 esp, 4

; 32   : 	if (_Res != _Thrd_success)

  00058	85 c0		 test	 eax, eax
  0005a	74 09		 je	 SHORT $LN19@tick

; 33   : 		_Throw_C_error(_Res);

  0005c	50		 push	 eax
  0005d	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
  00062	83 c4 04	 add	 esp, 4
$LN19@tick:
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp

; 467  : }

  00065	5f		 pop	 edi
  00066	b0 01		 mov	 al, 1
  00068	5e		 pop	 esi
  00069	8b e5		 mov	 esp, ebp
  0006b	5d		 pop	 ebp
  0006c	c3		 ret	 0
?tick@ChunkDrawThread@@EAE_NXZ ENDP			; ChunkDrawThread::tick
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\mutex
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\queue
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp
;	COMDAT ?requestQuickChunkDraw@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_chunk$ = 8						; size = 8
?requestQuickChunkDraw@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z PROC ; requestQuickChunkDraw, COMDAT

; 470  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?requestQuickChunkDraw@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	57		 push	 edi
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00024	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 471  : 	ChunkDrawThread* thread = &chunkDrawThreads[(drawerThread++) % DRAW_THREAD_AMOUNT];

  0002b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?drawerThread@@3HA ; drawerThread
  00030	8b f0		 mov	 esi, eax
  00032	81 e6 03 00 00
	80		 and	 esi, -2147483645	; 80000003H
  00038	79 05		 jns	 SHORT $LN32@requestQui
  0003a	4e		 dec	 esi
  0003b	83 ce fc	 or	 esi, -4			; fffffffcH
  0003e	46		 inc	 esi
$LN32@requestQui:
  0003f	69 f6 60 04 00
	00		 imul	 esi, 1120		; 00000460H
  00045	81 c6 00 00 00
	00		 add	 esi, OFFSET ?chunkDrawThreads@@3PAVChunkDrawThread@@A ; chunkDrawThreads
  0004b	40		 inc	 eax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\mutex

; 43   : 		_Mtx_lockX(&_Mtx);

  0004c	8d be 5c 04 00
	00		 lea	 edi, DWORD PTR [esi+1116]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 68   : 	return (_Check_C_return(_Mtx_lock(_Mtx)));

  00052	57		 push	 edi
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp

; 471  : 	ChunkDrawThread* thread = &chunkDrawThreads[(drawerThread++) % DRAW_THREAD_AMOUNT];

  00053	a3 00 00 00 00	 mov	 DWORD PTR ?drawerThread@@3HA, eax ; drawerThread
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 68   : 	return (_Check_C_return(_Mtx_lock(_Mtx)));

  00058	e8 00 00 00 00	 call	 __Mtx_lock
  0005d	83 c4 04	 add	 esp, 4

; 32   : 	if (_Res != _Thrd_success)

  00060	85 c0		 test	 eax, eax
  00062	74 09		 je	 SHORT $LN8@requestQui

; 33   : 		_Throw_C_error(_Res);

  00064	50		 push	 eax
  00065	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
  0006a	83 c4 04	 add	 esp, 4
$LN8@requestQui:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\queue

; 155  : 		c.push_back(_Val);

  0006d	8d 45 08	 lea	 eax, DWORD PTR _chunk$[ebp]
  00070	50		 push	 eax
  00071	8d 8e 20 04 00
	00		 lea	 ecx, DWORD PTR [esi+1056]
  00077	e8 00 00 00 00	 call	 ?push_back@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QAEXABV?$shared_ptr@VChunkBase@@@2@@Z ; std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::push_back
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 83   : 	return (_Check_C_return(_Mtx_unlock(_Mtx)));

  0007c	57		 push	 edi
  0007d	e8 00 00 00 00	 call	 __Mtx_unlock
  00082	83 c4 04	 add	 esp, 4

; 32   : 	if (_Res != _Thrd_success)

  00085	85 c0		 test	 eax, eax
  00087	74 09		 je	 SHORT $LN17@requestQui

; 33   : 		_Throw_C_error(_Res);

  00089	50		 push	 eax
  0008a	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
  0008f	83 c4 04	 add	 esp, 4
$LN17@requestQui:
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp

; 476  : }

  00092	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  00099	8b 75 0c	 mov	 esi, DWORD PTR _chunk$[ebp+4]
  0009c	85 f6		 test	 esi, esi
  0009e	74 25		 je	 SHORT $LN28@requestQui

; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  000a0	83 cf ff	 or	 edi, -1
  000a3	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  000a6	8b c7		 mov	 eax, edi
  000a8	f0 0f c1 01	 lock	  xadd	 DWORD PTR [ecx], eax
  000ac	75 17		 jne	 SHORT $LN28@requestQui

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  000ae	8b 06		 mov	 eax, DWORD PTR [esi]
  000b0	8b ce		 mov	 ecx, esi
  000b2	ff 10		 call	 DWORD PTR [eax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  000b4	8d 46 08	 lea	 eax, DWORD PTR [esi+8]
  000b7	f0 0f c1 38	 lock	  xadd	 DWORD PTR [eax], edi
  000bb	4f		 dec	 edi
  000bc	75 07		 jne	 SHORT $LN28@requestQui

; 128  : 			_Delete_this();

  000be	8b 06		 mov	 eax, DWORD PTR [esi]
  000c0	8b ce		 mov	 ecx, esi
  000c2	ff 50 04	 call	 DWORD PTR [eax+4]
$LN28@requestQui:
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp

; 476  : }

  000c5	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000c8	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000cf	59		 pop	 ecx
  000d0	5f		 pop	 edi
  000d1	5e		 pop	 esi
  000d2	8b e5		 mov	 esp, ebp
  000d4	5d		 pop	 ebp
  000d5	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?requestQuickChunkDraw@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z$0:
  00000	8d 4d 08	 lea	 ecx, DWORD PTR _chunk$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$shared_ptr@VChunkBase@@@std@@QAE@XZ ; std::shared_ptr<ChunkBase>::~shared_ptr<ChunkBase>
__ehhandler$?requestQuickChunkDraw@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?requestQuickChunkDraw@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?requestQuickChunkDraw@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z ENDP ; requestQuickChunkDraw
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\mutex
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\queue
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp
;	COMDAT ?requestChunkDraw@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_chunk$ = 8						; size = 8
?requestChunkDraw@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z PROC ; requestChunkDraw, COMDAT

; 479  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?requestChunkDraw@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	57		 push	 edi
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00024	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 480  : 	ChunkDrawThread* thread = &chunkDrawThreads[(drawerThread++) % DRAW_THREAD_AMOUNT];

  0002b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?drawerThread@@3HA ; drawerThread
  00030	8b f0		 mov	 esi, eax
  00032	81 e6 03 00 00
	80		 and	 esi, -2147483645	; 80000003H
  00038	79 05		 jns	 SHORT $LN32@requestChu
  0003a	4e		 dec	 esi
  0003b	83 ce fc	 or	 esi, -4			; fffffffcH
  0003e	46		 inc	 esi
$LN32@requestChu:
  0003f	69 f6 60 04 00
	00		 imul	 esi, 1120		; 00000460H
  00045	81 c6 00 00 00
	00		 add	 esi, OFFSET ?chunkDrawThreads@@3PAVChunkDrawThread@@A ; chunkDrawThreads
  0004b	40		 inc	 eax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\mutex

; 43   : 		_Mtx_lockX(&_Mtx);

  0004c	8d be 5c 04 00
	00		 lea	 edi, DWORD PTR [esi+1116]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 68   : 	return (_Check_C_return(_Mtx_lock(_Mtx)));

  00052	57		 push	 edi
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp

; 480  : 	ChunkDrawThread* thread = &chunkDrawThreads[(drawerThread++) % DRAW_THREAD_AMOUNT];

  00053	a3 00 00 00 00	 mov	 DWORD PTR ?drawerThread@@3HA, eax ; drawerThread
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 68   : 	return (_Check_C_return(_Mtx_lock(_Mtx)));

  00058	e8 00 00 00 00	 call	 __Mtx_lock
  0005d	83 c4 04	 add	 esp, 4

; 32   : 	if (_Res != _Thrd_success)

  00060	85 c0		 test	 eax, eax
  00062	74 09		 je	 SHORT $LN8@requestChu

; 33   : 		_Throw_C_error(_Res);

  00064	50		 push	 eax
  00065	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
  0006a	83 c4 04	 add	 esp, 4
$LN8@requestChu:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\queue

; 155  : 		c.push_back(_Val);

  0006d	8d 45 08	 lea	 eax, DWORD PTR _chunk$[ebp]
  00070	50		 push	 eax
  00071	8d 8e 34 04 00
	00		 lea	 ecx, DWORD PTR [esi+1076]
  00077	e8 00 00 00 00	 call	 ?push_back@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QAEXABV?$shared_ptr@VChunkBase@@@2@@Z ; std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::push_back
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 83   : 	return (_Check_C_return(_Mtx_unlock(_Mtx)));

  0007c	57		 push	 edi
  0007d	e8 00 00 00 00	 call	 __Mtx_unlock
  00082	83 c4 04	 add	 esp, 4

; 32   : 	if (_Res != _Thrd_success)

  00085	85 c0		 test	 eax, eax
  00087	74 09		 je	 SHORT $LN17@requestChu

; 33   : 		_Throw_C_error(_Res);

  00089	50		 push	 eax
  0008a	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
  0008f	83 c4 04	 add	 esp, 4
$LN17@requestChu:
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp

; 485  : }

  00092	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  00099	8b 75 0c	 mov	 esi, DWORD PTR _chunk$[ebp+4]
  0009c	85 f6		 test	 esi, esi
  0009e	74 25		 je	 SHORT $LN28@requestChu

; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  000a0	83 cf ff	 or	 edi, -1
  000a3	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  000a6	8b c7		 mov	 eax, edi
  000a8	f0 0f c1 01	 lock	  xadd	 DWORD PTR [ecx], eax
  000ac	75 17		 jne	 SHORT $LN28@requestChu

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  000ae	8b 06		 mov	 eax, DWORD PTR [esi]
  000b0	8b ce		 mov	 ecx, esi
  000b2	ff 10		 call	 DWORD PTR [eax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  000b4	8d 46 08	 lea	 eax, DWORD PTR [esi+8]
  000b7	f0 0f c1 38	 lock	  xadd	 DWORD PTR [eax], edi
  000bb	4f		 dec	 edi
  000bc	75 07		 jne	 SHORT $LN28@requestChu

; 128  : 			_Delete_this();

  000be	8b 06		 mov	 eax, DWORD PTR [esi]
  000c0	8b ce		 mov	 ecx, esi
  000c2	ff 50 04	 call	 DWORD PTR [eax+4]
$LN28@requestChu:
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp

; 485  : }

  000c5	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000c8	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000cf	59		 pop	 ecx
  000d0	5f		 pop	 edi
  000d1	5e		 pop	 esi
  000d2	8b e5		 mov	 esp, ebp
  000d4	5d		 pop	 ebp
  000d5	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?requestChunkDraw@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z$0:
  00000	8d 4d 08	 lea	 ecx, DWORD PTR _chunk$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$shared_ptr@VChunkBase@@@std@@QAE@XZ ; std::shared_ptr<ChunkBase>::~shared_ptr<ChunkBase>
__ehhandler$?requestChunkDraw@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?requestChunkDraw@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?requestChunkDraw@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z ENDP ; requestChunkDraw
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\mutex
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\queue
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp
;	COMDAT ?requestLateChunkDraw@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_chunk$ = 8						; size = 8
?requestLateChunkDraw@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z PROC ; requestLateChunkDraw, COMDAT

; 488  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?requestLateChunkDraw@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	57		 push	 edi
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00024	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 489  : 	ChunkDrawThread* thread = &chunkDrawThreads[(drawerThread++) % DRAW_THREAD_AMOUNT];

  0002b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?drawerThread@@3HA ; drawerThread
  00030	8b f0		 mov	 esi, eax
  00032	81 e6 03 00 00
	80		 and	 esi, -2147483645	; 80000003H
  00038	79 05		 jns	 SHORT $LN32@requestLat
  0003a	4e		 dec	 esi
  0003b	83 ce fc	 or	 esi, -4			; fffffffcH
  0003e	46		 inc	 esi
$LN32@requestLat:
  0003f	69 f6 60 04 00
	00		 imul	 esi, 1120		; 00000460H
  00045	81 c6 00 00 00
	00		 add	 esi, OFFSET ?chunkDrawThreads@@3PAVChunkDrawThread@@A ; chunkDrawThreads
  0004b	40		 inc	 eax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\mutex

; 43   : 		_Mtx_lockX(&_Mtx);

  0004c	8d be 5c 04 00
	00		 lea	 edi, DWORD PTR [esi+1116]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 68   : 	return (_Check_C_return(_Mtx_lock(_Mtx)));

  00052	57		 push	 edi
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp

; 489  : 	ChunkDrawThread* thread = &chunkDrawThreads[(drawerThread++) % DRAW_THREAD_AMOUNT];

  00053	a3 00 00 00 00	 mov	 DWORD PTR ?drawerThread@@3HA, eax ; drawerThread
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 68   : 	return (_Check_C_return(_Mtx_lock(_Mtx)));

  00058	e8 00 00 00 00	 call	 __Mtx_lock
  0005d	83 c4 04	 add	 esp, 4

; 32   : 	if (_Res != _Thrd_success)

  00060	85 c0		 test	 eax, eax
  00062	74 09		 je	 SHORT $LN8@requestLat

; 33   : 		_Throw_C_error(_Res);

  00064	50		 push	 eax
  00065	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
  0006a	83 c4 04	 add	 esp, 4
$LN8@requestLat:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\queue

; 155  : 		c.push_back(_Val);

  0006d	8d 45 08	 lea	 eax, DWORD PTR _chunk$[ebp]
  00070	50		 push	 eax
  00071	8d 8e 48 04 00
	00		 lea	 ecx, DWORD PTR [esi+1096]
  00077	e8 00 00 00 00	 call	 ?push_back@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QAEXABV?$shared_ptr@VChunkBase@@@2@@Z ; std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::push_back
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 83   : 	return (_Check_C_return(_Mtx_unlock(_Mtx)));

  0007c	57		 push	 edi
  0007d	e8 00 00 00 00	 call	 __Mtx_unlock
  00082	83 c4 04	 add	 esp, 4

; 32   : 	if (_Res != _Thrd_success)

  00085	85 c0		 test	 eax, eax
  00087	74 09		 je	 SHORT $LN17@requestLat

; 33   : 		_Throw_C_error(_Res);

  00089	50		 push	 eax
  0008a	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
  0008f	83 c4 04	 add	 esp, 4
$LN17@requestLat:
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp

; 494  : }

  00092	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  00099	8b 75 0c	 mov	 esi, DWORD PTR _chunk$[ebp+4]
  0009c	85 f6		 test	 esi, esi
  0009e	74 25		 je	 SHORT $LN28@requestLat

; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  000a0	83 cf ff	 or	 edi, -1
  000a3	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  000a6	8b c7		 mov	 eax, edi
  000a8	f0 0f c1 01	 lock	  xadd	 DWORD PTR [ecx], eax
  000ac	75 17		 jne	 SHORT $LN28@requestLat

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  000ae	8b 06		 mov	 eax, DWORD PTR [esi]
  000b0	8b ce		 mov	 ecx, esi
  000b2	ff 10		 call	 DWORD PTR [eax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  000b4	8d 46 08	 lea	 eax, DWORD PTR [esi+8]
  000b7	f0 0f c1 38	 lock	  xadd	 DWORD PTR [eax], edi
  000bb	4f		 dec	 edi
  000bc	75 07		 jne	 SHORT $LN28@requestLat

; 128  : 			_Delete_this();

  000be	8b 06		 mov	 eax, DWORD PTR [esi]
  000c0	8b ce		 mov	 ecx, esi
  000c2	ff 50 04	 call	 DWORD PTR [eax+4]
$LN28@requestLat:
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp

  000c5	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000c8	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000cf	59		 pop	 ecx
  000d0	5f		 pop	 edi
  000d1	5e		 pop	 esi
  000d2	8b e5		 mov	 esp, ebp
  000d4	5d		 pop	 ebp
  000d5	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?requestLateChunkDraw@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z$0:
  00000	8d 4d 08	 lea	 ecx, DWORD PTR _chunk$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$shared_ptr@VChunkBase@@@std@@QAE@XZ ; std::shared_ptr<ChunkBase>::~shared_ptr<ChunkBase>
__ehhandler$?requestLateChunkDraw@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?requestLateChunkDraw@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?requestLateChunkDraw@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z ENDP ; requestLateChunkDraw
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ??1?$shared_ptr@VVertexStream@gfxu@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$shared_ptr@VVertexStream@gfxu@@@std@@QAE@XZ PROC	; std::shared_ptr<gfxu::VertexStream>::~shared_ptr<gfxu::VertexStream>, COMDAT
; _this$ = ecx

; 622  : 		{	// release resource

  00000	56		 push	 esi

; 129  : 		}
; 130  : 
; 131  : 	long _Use_count() const
; 132  : 		{	// return use count
; 133  : 		return (_Get_uses());
; 134  : 		}
; 135  : 
; 136  : 	bool _Expired() const
; 137  : 		{	// return true if _Uses == 0
; 138  : 		return (_Get_uses() == 0);
; 139  : 		}
; 140  : 
; 141  : 	virtual void *_Get_deleter(const _XSTD2 type_info&) const
; 142  : 		{	// return address of deleter object
; 143  : 		return (0);
; 144  : 		}
; 145  : 	};
; 146  : 
; 147  : 	// TEMPLATE CLASS _Ref_count
; 148  : template<class _Ty>
; 149  : 	class _Ref_count
; 150  : 	: public _Ref_count_base
; 151  : 	{	// handle reference counting for object without deleter
; 152  : public:
; 153  : 	_Ref_count(_Ty *_Px)
; 154  : 		: _Ref_count_base(), _Ptr(_Px)
; 155  : 		{	// construct
; 156  : 		}
; 157  : 
; 158  : private:
; 159  : 	virtual void _Destroy()
; 160  : 		{	// destroy managed resource
; 161  : 		delete _Ptr;
; 162  : 		}
; 163  : 
; 164  : 	virtual void _Delete_this()
; 165  : 		{	// destroy self
; 166  : 		delete this;
; 167  : 		}
; 168  : 
; 169  : 	_Ty * _Ptr;
; 170  : 	};
; 171  : 
; 172  : 	// TEMPLATE CLASS _Ref_count_del
; 173  : template<class _Ty,
; 174  : 	class _Dx>
; 175  : 	class _Ref_count_del
; 176  : 	: public _Ref_count_base
; 177  : 	{	// handle reference counting for object with deleter
; 178  : public:
; 179  : 	_Ref_count_del(_Ty *_Px, _Dx _Dt)
; 180  : 		: _Ref_count_base(), _Ptr(_Px), _Dtor(_Dt)
; 181  : 		{	// construct
; 182  : 		}
; 183  : 
; 184  : 	virtual void *_Get_deleter(const _XSTD2 type_info& _Typeid) const
; 185  : 		{	// return address of deleter object
; 186  : 		return ((void *)(_Typeid == typeid(_Dx) ? &_Dtor : 0));
; 187  : 		}
; 188  : 
; 189  : private:
; 190  : 	virtual void _Destroy()
; 191  : 		{	// destroy managed resource
; 192  : 		_Dtor(_Ptr);
; 193  : 		}
; 194  : 
; 195  : 	virtual void _Delete_this()
; 196  : 		{	// destroy self
; 197  : 		delete this;
; 198  : 		}
; 199  : 
; 200  : 	_Ty * _Ptr;
; 201  : 	_Dx _Dtor;	// the stored destructor for the controlled object
; 202  : 	};
; 203  : 
; 204  : 	// TEMPLATE CLASS _Ref_count_del_alloc
; 205  : template<class _Ty,
; 206  : 	class _Dx,
; 207  : 	class _Alloc>
; 208  : 	class _Ref_count_del_alloc
; 209  : 	: public _Ref_count_base
; 210  : 	{	// handle reference counting for object with deleter and allocator
; 211  : public:
; 212  : 	typedef _Ref_count_del_alloc<_Ty, _Dx, _Alloc> _Myty;
; 213  : 	typedef typename _Alloc::template rebind<_Myty>::other _Myalty;
; 214  : 
; 215  : 	_Ref_count_del_alloc(_Ty *_Px, _Dx _Dt, _Myalty _Al)
; 216  : 		: _Ref_count_base(), _Ptr(_Px), _Dtor(_Dt), _Myal(_Al)
; 217  : 		{	// construct
; 218  : 		}
; 219  : 
; 220  : 	virtual void *_Get_deleter(const _XSTD2 type_info& _Typeid) const
; 221  : 		{	// return address of deleter object
; 222  : 		return ((void *)(_Typeid == typeid(_Dx) ? &_Dtor : 0));
; 223  : 		}
; 224  : 
; 225  : private:
; 226  : 	virtual void _Destroy()
; 227  : 		{	// destroy managed resource
; 228  : 		_Dtor(_Ptr);
; 229  : 		}
; 230  : 
; 231  : 	virtual void _Delete_this()
; 232  : 		{	// destroy self
; 233  : 		_Myalty _Al = _Myal;
; 234  : 		_Al.destroy(this);
; 235  : 		_Al.deallocate(this, 1);
; 236  : 		}
; 237  : 
; 238  : 	_Ty * _Ptr;
; 239  : 	_Dx _Dtor;	// the stored destructor for the controlled object
; 240  : 	_Myalty _Myal;	// the stored allocator for this
; 241  : 	};
; 242  : 
; 243  : 	// DECLARATIONS
; 244  : template<class _Ty>
; 245  : 	class weak_ptr;
; 246  : template<class _Ty>
; 247  : 	class shared_ptr;
; 248  : template<class _Ty>
; 249  : 	class enable_shared_from_this;
; 250  : struct _Static_tag {};
; 251  : struct _Const_tag {};
; 252  : struct _Dynamic_tag {};
; 253  : template<class _Ty1,
; 254  : 	class _Ty2>
; 255  : 	void _Do_enable(_Ty1 *, enable_shared_from_this<_Ty2> *,
; 256  : 		_Ref_count_base *);
; 257  : 
; 258  : template<class _Ty>
; 259  : 	inline void _Enable_shared(_Ty *_Ptr, _Ref_count_base *_Refptr,
; 260  : 		typename _Ty::_EStype * = 0)
; 261  : 	{	// reset internal weak pointer
; 262  : 	if (_Ptr)
; 263  : 		_Do_enable(_Ptr,
; 264  : 			(enable_shared_from_this<typename _Ty::_EStype>*)_Ptr, _Refptr);
; 265  : 	}
; 266  : 
; 267  : inline void _Enable_shared(const volatile void *, const volatile void *)
; 268  : 	{	// not derived from enable_shared_from_this; do nothing
; 269  : 	}
; 270  : 
; 271  : 	// TEMPLATE CLASS _Ptr_base
; 272  : template<class _Ty>
; 273  : 	class _Ptr_base
; 274  : 	{	// base class for shared_ptr and weak_ptr
; 275  : public:
; 276  : 	typedef _Ptr_base<_Ty> _Myt;
; 277  : 	typedef _Ty _Elem;
; 278  : 	typedef _Elem element_type;
; 279  : 
; 280  : 	_Ptr_base()
; 281  : 		: _Ptr(0), _Rep(0)
; 282  : 		{	// construct
; 283  : 		}
; 284  : 
; 285  : 	_Ptr_base(_Myt&& _Right)
; 286  : 		: _Ptr(0), _Rep(0)
; 287  : 		{	// construct _Ptr_base object that takes resource from _Right
; 288  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 289  : 		}
; 290  : 
; 291  : 	template<class _Ty2>
; 292  : 		_Ptr_base(_Ptr_base<_Ty2>&& _Right)
; 293  : 		: _Ptr(_Right._Ptr), _Rep(_Right._Rep)
; 294  : 		{	// construct _Ptr_base object that takes resource from _Right
; 295  : 		_Right._Ptr = 0;
; 296  : 		_Right._Rep = 0;
; 297  : 		}
; 298  : 
; 299  : 	_Myt& operator=(_Myt&& _Right)
; 300  : 		{	// construct _Ptr_base object that takes resource from _Right
; 301  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 302  : 		return (*this);
; 303  : 		}
; 304  : 
; 305  : 	void _Assign_rv(_Myt&& _Right)
; 306  : 		{	// assign by moving _Right
; 307  : 		if (this != &_Right)
; 308  : 			_Swap(_Right);
; 309  : 		}
; 310  : 
; 311  : 	long use_count() const _NOEXCEPT
; 312  : 		{	// return use count
; 313  : 		return (_Rep ? _Rep->_Use_count() : 0);
; 314  : 		}
; 315  : 
; 316  : 	void _Swap(_Ptr_base& _Right)
; 317  : 		{	// swap pointers
; 318  : 		_STD swap(_Rep, _Right._Rep);
; 319  : 		_STD swap(_Ptr, _Right._Ptr);
; 320  : 		}
; 321  : 
; 322  : 	template<class _Ty2>
; 323  : 		bool owner_before(const _Ptr_base<_Ty2>& _Right) const
; 324  : 		{	// compare addresses of manager objects
; 325  : 		return (_Rep < _Right._Rep);
; 326  : 		}
; 327  : 
; 328  : 	void *_Get_deleter(const _XSTD2 type_info& _Typeid) const
; 329  : 		{	// return pointer to deleter object if its type is _Typeid
; 330  : 		return (_Rep ? _Rep->_Get_deleter(_Typeid) : 0);
; 331  : 		}
; 332  : 
; 333  : 	_Ty *_Get() const
; 334  : 		{	// return pointer to resource
; 335  : 		return (_Ptr);
; 336  : 		}
; 337  : 
; 338  : 	bool _Expired() const
; 339  : 		{	// test if expired
; 340  : 		return (!_Rep || _Rep->_Expired());
; 341  : 		}
; 342  : 
; 343  : 	void _Decref()
; 344  : 		{	// decrement reference count
; 345  : 		if (_Rep != 0)

  00001	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  00004	85 f6		 test	 esi, esi
  00006	74 29		 je	 SHORT $LN9@shared_ptr
  00008	57		 push	 edi

; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  00009	83 cf ff	 or	 edi, -1
  0000c	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  0000f	8b c7		 mov	 eax, edi
  00011	f0 0f c1 01	 lock	  xadd	 DWORD PTR [ecx], eax
  00015	75 19		 jne	 SHORT $LN12@shared_ptr

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  00017	8b 06		 mov	 eax, DWORD PTR [esi]
  00019	8b ce		 mov	 ecx, esi
  0001b	ff 10		 call	 DWORD PTR [eax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  0001d	8d 46 08	 lea	 eax, DWORD PTR [esi+8]
  00020	f0 0f c1 38	 lock	  xadd	 DWORD PTR [eax], edi
  00024	4f		 dec	 edi
  00025	75 09		 jne	 SHORT $LN12@shared_ptr

; 128  : 			_Delete_this();

  00027	8b 06		 mov	 eax, DWORD PTR [esi]
  00029	5f		 pop	 edi
  0002a	8b ce		 mov	 ecx, esi
  0002c	5e		 pop	 esi
  0002d	ff 60 04	 jmp	 DWORD PTR [eax+4]
$LN12@shared_ptr:
  00030	5f		 pop	 edi
$LN9@shared_ptr:
  00031	5e		 pop	 esi

; 623  : 		this->_Decref();
; 624  : 		}

  00032	c3		 ret	 0
??1?$shared_ptr@VVertexStream@gfxu@@@std@@QAE@XZ ENDP	; std::shared_ptr<gfxu::VertexStream>::~shared_ptr<gfxu::VertexStream>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ??4?$shared_ptr@VVertexStream@gfxu@@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
$T1 = -12						; size = 8
__Right$ = 8						; size = 4
??4?$shared_ptr@VVertexStream@gfxu@@@std@@QAEAAV01@ABV01@@Z PROC ; std::shared_ptr<gfxu::VertexStream>::operator=, COMDAT
; _this$ = ecx

; 627  : 		{	// assign shared ownership of resource owned by _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 628  : 		shared_ptr(_Right).swap(*this);

  00009	ff 75 08	 push	 DWORD PTR __Right$[ebp]
  0000c	8b f1		 mov	 esi, ecx
  0000e	8d 4d f4	 lea	 ecx, DWORD PTR $T1[ebp]
  00011	e8 00 00 00 00	 call	 ??0?$shared_ptr@VVertexStream@gfxu@@@std@@QAE@ABV01@@Z ; std::shared_ptr<gfxu::VertexStream>::shared_ptr<gfxu::VertexStream>
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility

; 48   : 	_Left = _Move(_Right);

  00016	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00019	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0001c	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 49   : 	_Right = _Move(_Tmp);

  0001f	89 56 04	 mov	 DWORD PTR [esi+4], edx

; 48   : 	_Left = _Move(_Right);

  00022	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00024	8b 10		 mov	 edx, DWORD PTR [eax]
  00026	89 08		 mov	 DWORD PTR [eax], ecx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  00028	8b 7d f8	 mov	 edi, DWORD PTR $T1[ebp+4]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility

; 49   : 	_Right = _Move(_Tmp);

  0002b	89 16		 mov	 DWORD PTR [esi], edx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  0002d	85 ff		 test	 edi, edi
  0002f	74 25		 je	 SHORT $LN36@operator

; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  00031	83 cb ff	 or	 ebx, -1
  00034	8d 4f 04	 lea	 ecx, DWORD PTR [edi+4]
  00037	8b c3		 mov	 eax, ebx
  00039	f0 0f c1 01	 lock	  xadd	 DWORD PTR [ecx], eax
  0003d	75 17		 jne	 SHORT $LN36@operator

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  0003f	8b 07		 mov	 eax, DWORD PTR [edi]
  00041	8b cf		 mov	 ecx, edi
  00043	ff 10		 call	 DWORD PTR [eax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  00045	8d 47 08	 lea	 eax, DWORD PTR [edi+8]
  00048	f0 0f c1 18	 lock	  xadd	 DWORD PTR [eax], ebx
  0004c	4b		 dec	 ebx
  0004d	75 07		 jne	 SHORT $LN36@operator

; 128  : 			_Delete_this();

  0004f	8b 07		 mov	 eax, DWORD PTR [edi]
  00051	8b cf		 mov	 ecx, edi
  00053	ff 50 04	 call	 DWORD PTR [eax+4]
$LN36@operator:

; 629  : 		return (*this);
; 630  : 		}

  00056	5f		 pop	 edi
  00057	8b c6		 mov	 eax, esi
  00059	5e		 pop	 esi
  0005a	5b		 pop	 ebx
  0005b	8b e5		 mov	 esp, ebp
  0005d	5d		 pop	 ebp
  0005e	c2 04 00	 ret	 4
??4?$shared_ptr@VVertexStream@gfxu@@@std@@QAEAAV01@ABV01@@Z ENDP ; std::shared_ptr<gfxu::VertexStream>::operator=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\queue
;	COMDAT ?size@?$queue@V?$shared_ptr@VChunkBase@@@std@@V?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@2@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$queue@V?$shared_ptr@VChunkBase@@@std@@V?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@2@@std@@QBEIXZ PROC ; std::queue<std::shared_ptr<ChunkBase>,std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > > >::size, COMDAT
; _this$ = ecx

; 130  : 		return (c.size());

  00000	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]

; 131  : 		}

  00003	c3		 ret	 0
?size@?$queue@V?$shared_ptr@VChunkBase@@@std@@V?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@2@@std@@QBEIXZ ENDP ; std::queue<std::shared_ptr<ChunkBase>,std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > > >::size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\queue
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\queue
;	COMDAT ?front@?$queue@V?$shared_ptr@VChunkBase@@@std@@V?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@2@@std@@QAEAAV?$shared_ptr@VChunkBase@@@2@XZ
_TEXT	SEGMENT
$T1 = -12						; size = 12
?front@?$queue@V?$shared_ptr@VChunkBase@@@std@@V?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@2@@std@@QAEAAV?$shared_ptr@VChunkBase@@@2@XZ PROC ; std::queue<std::shared_ptr<ChunkBase>,std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > > >::front, COMDAT
; _this$ = ecx

; 134  : 		{	// return first element of mutable queue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 1426 : 		return (*begin());

  00006	8d 45 f4	 lea	 eax, DWORD PTR $T1[ebp]
  00009	56		 push	 esi
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ?begin@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@2@XZ ; std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::begin
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility

; 178  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

  00010	8b 30		 mov	 esi, DWORD PTR [eax]
  00012	85 f6		 test	 esi, esi
  00014	74 02		 je	 SHORT $LN12@front
$LN11@front:
  00016	8b 36		 mov	 esi, DWORD PTR [esi]
$LN12@front:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 787  : 		return ((_Off / _DEQUESIZ) & (this->_Mapsize - 1));

  00018	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  0001b	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0001e	48		 dec	 eax
  0001f	8b ca		 mov	 ecx, edx
  00021	d1 e9		 shr	 ecx, 1
  00023	23 c8		 and	 ecx, eax

; 345  : 		return (_Mycont->_Map[_Block][_Off]);

  00025	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00028	83 e2 01	 and	 edx, 1
  0002b	8b 04 88	 mov	 eax, DWORD PTR [eax+ecx*4]
  0002e	5e		 pop	 esi
  0002f	8d 04 d0	 lea	 eax, DWORD PTR [eax+edx*8]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\queue

; 136  : 		}

  00032	8b e5		 mov	 esp, ebp
  00034	5d		 pop	 ebp
  00035	c3		 ret	 0
?front@?$queue@V?$shared_ptr@VChunkBase@@@std@@V?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@2@@std@@QAEAAV?$shared_ptr@VChunkBase@@@2@XZ ENDP ; std::queue<std::shared_ptr<ChunkBase>,std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > > >::front
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\queue
;	COMDAT ?push@?$queue@V?$shared_ptr@VChunkBase@@@std@@V?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@2@@std@@QAEXABV?$shared_ptr@VChunkBase@@@2@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?push@?$queue@V?$shared_ptr@VChunkBase@@@std@@V?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@2@@std@@QAEXABV?$shared_ptr@VChunkBase@@@2@@Z PROC ; std::queue<std::shared_ptr<ChunkBase>,std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > > >::push, COMDAT
; _this$ = ecx

; 154  : 		{	// insert element at beginning

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 156  : 		}

  00003	5d		 pop	 ebp

; 155  : 		c.push_back(_Val);

  00004	e9 00 00 00 00	 jmp	 ?push_back@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QAEXABV?$shared_ptr@VChunkBase@@@2@@Z ; std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::push_back
?push@?$queue@V?$shared_ptr@VChunkBase@@@std@@V?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@2@@std@@QAEXABV?$shared_ptr@VChunkBase@@@2@@Z ENDP ; std::queue<std::shared_ptr<ChunkBase>,std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > > >::push
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\queue
;	COMDAT ?pop@?$queue@V?$shared_ptr@VChunkBase@@@std@@V?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@2@@std@@QAEXXZ
_TEXT	SEGMENT
?pop@?$queue@V?$shared_ptr@VChunkBase@@@std@@V?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@2@@std@@QAEXXZ PROC ; std::queue<std::shared_ptr<ChunkBase>,std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > > >::pop, COMDAT
; _this$ = ecx

; 160  : 		c.pop_front();

  00000	e9 00 00 00 00	 jmp	 ?pop_front@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QAEXXZ ; std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::pop_front
?pop@?$queue@V?$shared_ptr@VChunkBase@@@std@@V?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@2@@std@@QAEXXZ ENDP ; std::queue<std::shared_ptr<ChunkBase>,std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > > >::pop
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ??0?$shared_ptr@VChunkBase@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
$T1 = 8							; size = 4
__Other$ = 8						; size = 4
??0?$shared_ptr@VChunkBase@@@std@@QAE@ABV01@@Z PROC	; std::shared_ptr<ChunkBase>::shared_ptr<ChunkBase>, COMDAT
; _this$ = ecx

; 534  : 	shared_ptr(const _Myt& _Other) _NOEXCEPT

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 283  : 		}
; 284  : 
; 285  : 	_Ptr_base(_Myt&& _Right)
; 286  : 		: _Ptr(0), _Rep(0)
; 287  : 		{	// construct _Ptr_base object that takes resource from _Right
; 288  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 289  : 		}
; 290  : 
; 291  : 	template<class _Ty2>
; 292  : 		_Ptr_base(_Ptr_base<_Ty2>&& _Right)
; 293  : 		: _Ptr(_Right._Ptr), _Rep(_Right._Rep)
; 294  : 		{	// construct _Ptr_base object that takes resource from _Right
; 295  : 		_Right._Ptr = 0;
; 296  : 		_Right._Rep = 0;
; 297  : 		}
; 298  : 
; 299  : 	_Myt& operator=(_Myt&& _Right)
; 300  : 		{	// construct _Ptr_base object that takes resource from _Right
; 301  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 302  : 		return (*this);
; 303  : 		}
; 304  : 
; 305  : 	void _Assign_rv(_Myt&& _Right)
; 306  : 		{	// assign by moving _Right
; 307  : 		if (this != &_Right)
; 308  : 			_Swap(_Right);
; 309  : 		}
; 310  : 
; 311  : 	long use_count() const _NOEXCEPT
; 312  : 		{	// return use count
; 313  : 		return (_Rep ? _Rep->_Use_count() : 0);
; 314  : 		}
; 315  : 
; 316  : 	void _Swap(_Ptr_base& _Right)
; 317  : 		{	// swap pointers
; 318  : 		_STD swap(_Rep, _Right._Rep);
; 319  : 		_STD swap(_Ptr, _Right._Ptr);
; 320  : 		}
; 321  : 
; 322  : 	template<class _Ty2>
; 323  : 		bool owner_before(const _Ptr_base<_Ty2>& _Right) const
; 324  : 		{	// compare addresses of manager objects
; 325  : 		return (_Rep < _Right._Rep);
; 326  : 		}
; 327  : 
; 328  : 	void *_Get_deleter(const _XSTD2 type_info& _Typeid) const
; 329  : 		{	// return pointer to deleter object if its type is _Typeid
; 330  : 		return (_Rep ? _Rep->_Get_deleter(_Typeid) : 0);
; 331  : 		}
; 332  : 
; 333  : 	_Ty *_Get() const
; 334  : 		{	// return pointer to resource
; 335  : 		return (_Ptr);
; 336  : 		}
; 337  : 
; 338  : 	bool _Expired() const
; 339  : 		{	// test if expired
; 340  : 		return (!_Rep || _Rep->_Expired());
; 341  : 		}
; 342  : 
; 343  : 	void _Decref()
; 344  : 		{	// decrement reference count
; 345  : 		if (_Rep != 0)
; 346  : 			_Rep->_Decref();
; 347  : 		}
; 348  : 
; 349  : 	void _Reset()
; 350  : 		{	// release resource
; 351  : 		_Reset(0, 0);
; 352  : 		}
; 353  : 
; 354  : 	template<class _Ty2>
; 355  : 		void _Reset(const _Ptr_base<_Ty2>& _Other)
; 356  : 		{	// release resource and take ownership of _Other._Ptr
; 357  : 		_Reset(_Other._Ptr, _Other._Rep);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Other$[ebp]
  00006	53		 push	 ebx
  00007	56		 push	 esi

; 534  : 	shared_ptr(const _Myt& _Other) _NOEXCEPT

  00008	8b f1		 mov	 esi, ecx
  0000a	57		 push	 edi

; 129  : 		}
; 130  : 
; 131  : 	long _Use_count() const
; 132  : 		{	// return use count
; 133  : 		return (_Get_uses());
; 134  : 		}
; 135  : 
; 136  : 	bool _Expired() const
; 137  : 		{	// return true if _Uses == 0
; 138  : 		return (_Get_uses() == 0);
; 139  : 		}
; 140  : 
; 141  : 	virtual void *_Get_deleter(const _XSTD2 type_info&) const
; 142  : 		{	// return address of deleter object
; 143  : 		return (0);
; 144  : 		}
; 145  : 	};
; 146  : 
; 147  : 	// TEMPLATE CLASS _Ref_count
; 148  : template<class _Ty>
; 149  : 	class _Ref_count
; 150  : 	: public _Ref_count_base
; 151  : 	{	// handle reference counting for object without deleter
; 152  : public:
; 153  : 	_Ref_count(_Ty *_Px)
; 154  : 		: _Ref_count_base(), _Ptr(_Px)
; 155  : 		{	// construct
; 156  : 		}
; 157  : 
; 158  : private:
; 159  : 	virtual void _Destroy()
; 160  : 		{	// destroy managed resource
; 161  : 		delete _Ptr;
; 162  : 		}
; 163  : 
; 164  : 	virtual void _Delete_this()
; 165  : 		{	// destroy self
; 166  : 		delete this;
; 167  : 		}
; 168  : 
; 169  : 	_Ty * _Ptr;
; 170  : 	};
; 171  : 
; 172  : 	// TEMPLATE CLASS _Ref_count_del
; 173  : template<class _Ty,
; 174  : 	class _Dx>
; 175  : 	class _Ref_count_del
; 176  : 	: public _Ref_count_base
; 177  : 	{	// handle reference counting for object with deleter
; 178  : public:
; 179  : 	_Ref_count_del(_Ty *_Px, _Dx _Dt)
; 180  : 		: _Ref_count_base(), _Ptr(_Px), _Dtor(_Dt)
; 181  : 		{	// construct
; 182  : 		}
; 183  : 
; 184  : 	virtual void *_Get_deleter(const _XSTD2 type_info& _Typeid) const
; 185  : 		{	// return address of deleter object
; 186  : 		return ((void *)(_Typeid == typeid(_Dx) ? &_Dtor : 0));
; 187  : 		}
; 188  : 
; 189  : private:
; 190  : 	virtual void _Destroy()
; 191  : 		{	// destroy managed resource
; 192  : 		_Dtor(_Ptr);
; 193  : 		}
; 194  : 
; 195  : 	virtual void _Delete_this()
; 196  : 		{	// destroy self
; 197  : 		delete this;
; 198  : 		}
; 199  : 
; 200  : 	_Ty * _Ptr;
; 201  : 	_Dx _Dtor;	// the stored destructor for the controlled object
; 202  : 	};
; 203  : 
; 204  : 	// TEMPLATE CLASS _Ref_count_del_alloc
; 205  : template<class _Ty,
; 206  : 	class _Dx,
; 207  : 	class _Alloc>
; 208  : 	class _Ref_count_del_alloc
; 209  : 	: public _Ref_count_base
; 210  : 	{	// handle reference counting for object with deleter and allocator
; 211  : public:
; 212  : 	typedef _Ref_count_del_alloc<_Ty, _Dx, _Alloc> _Myty;
; 213  : 	typedef typename _Alloc::template rebind<_Myty>::other _Myalty;
; 214  : 
; 215  : 	_Ref_count_del_alloc(_Ty *_Px, _Dx _Dt, _Myalty _Al)
; 216  : 		: _Ref_count_base(), _Ptr(_Px), _Dtor(_Dt), _Myal(_Al)
; 217  : 		{	// construct
; 218  : 		}
; 219  : 
; 220  : 	virtual void *_Get_deleter(const _XSTD2 type_info& _Typeid) const
; 221  : 		{	// return address of deleter object
; 222  : 		return ((void *)(_Typeid == typeid(_Dx) ? &_Dtor : 0));
; 223  : 		}
; 224  : 
; 225  : private:
; 226  : 	virtual void _Destroy()
; 227  : 		{	// destroy managed resource
; 228  : 		_Dtor(_Ptr);
; 229  : 		}
; 230  : 
; 231  : 	virtual void _Delete_this()
; 232  : 		{	// destroy self
; 233  : 		_Myalty _Al = _Myal;
; 234  : 		_Al.destroy(this);
; 235  : 		_Al.deallocate(this, 1);
; 236  : 		}
; 237  : 
; 238  : 	_Ty * _Ptr;
; 239  : 	_Dx _Dtor;	// the stored destructor for the controlled object
; 240  : 	_Myalty _Myal;	// the stored allocator for this
; 241  : 	};
; 242  : 
; 243  : 	// DECLARATIONS
; 244  : template<class _Ty>
; 245  : 	class weak_ptr;
; 246  : template<class _Ty>
; 247  : 	class shared_ptr;
; 248  : template<class _Ty>
; 249  : 	class enable_shared_from_this;
; 250  : struct _Static_tag {};
; 251  : struct _Const_tag {};
; 252  : struct _Dynamic_tag {};
; 253  : template<class _Ty1,
; 254  : 	class _Ty2>
; 255  : 	void _Do_enable(_Ty1 *, enable_shared_from_this<_Ty2> *,
; 256  : 		_Ref_count_base *);
; 257  : 
; 258  : template<class _Ty>
; 259  : 	inline void _Enable_shared(_Ty *_Ptr, _Ref_count_base *_Refptr,
; 260  : 		typename _Ty::_EStype * = 0)
; 261  : 	{	// reset internal weak pointer
; 262  : 	if (_Ptr)
; 263  : 		_Do_enable(_Ptr,
; 264  : 			(enable_shared_from_this<typename _Ty::_EStype>*)_Ptr, _Refptr);
; 265  : 	}
; 266  : 
; 267  : inline void _Enable_shared(const volatile void *, const volatile void *)
; 268  : 	{	// not derived from enable_shared_from_this; do nothing
; 269  : 	}
; 270  : 
; 271  : 	// TEMPLATE CLASS _Ptr_base
; 272  : template<class _Ty>
; 273  : 	class _Ptr_base
; 274  : 	{	// base class for shared_ptr and weak_ptr
; 275  : public:
; 276  : 	typedef _Ptr_base<_Ty> _Myt;
; 277  : 	typedef _Ty _Elem;
; 278  : 	typedef _Elem element_type;
; 279  : 
; 280  : 	_Ptr_base()
; 281  : 		: _Ptr(0), _Rep(0)
; 282  : 		{	// construct

  0000b	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  00011	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 283  : 		}
; 284  : 
; 285  : 	_Ptr_base(_Myt&& _Right)
; 286  : 		: _Ptr(0), _Rep(0)
; 287  : 		{	// construct _Ptr_base object that takes resource from _Right
; 288  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 289  : 		}
; 290  : 
; 291  : 	template<class _Ty2>
; 292  : 		_Ptr_base(_Ptr_base<_Ty2>&& _Right)
; 293  : 		: _Ptr(_Right._Ptr), _Rep(_Right._Rep)
; 294  : 		{	// construct _Ptr_base object that takes resource from _Right
; 295  : 		_Right._Ptr = 0;
; 296  : 		_Right._Rep = 0;
; 297  : 		}
; 298  : 
; 299  : 	_Myt& operator=(_Myt&& _Right)
; 300  : 		{	// construct _Ptr_base object that takes resource from _Right
; 301  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 302  : 		return (*this);
; 303  : 		}
; 304  : 
; 305  : 	void _Assign_rv(_Myt&& _Right)
; 306  : 		{	// assign by moving _Right
; 307  : 		if (this != &_Right)
; 308  : 			_Swap(_Right);
; 309  : 		}
; 310  : 
; 311  : 	long use_count() const _NOEXCEPT
; 312  : 		{	// return use count
; 313  : 		return (_Rep ? _Rep->_Use_count() : 0);
; 314  : 		}
; 315  : 
; 316  : 	void _Swap(_Ptr_base& _Right)
; 317  : 		{	// swap pointers
; 318  : 		_STD swap(_Rep, _Right._Rep);
; 319  : 		_STD swap(_Ptr, _Right._Ptr);
; 320  : 		}
; 321  : 
; 322  : 	template<class _Ty2>
; 323  : 		bool owner_before(const _Ptr_base<_Ty2>& _Right) const
; 324  : 		{	// compare addresses of manager objects
; 325  : 		return (_Rep < _Right._Rep);
; 326  : 		}
; 327  : 
; 328  : 	void *_Get_deleter(const _XSTD2 type_info& _Typeid) const
; 329  : 		{	// return pointer to deleter object if its type is _Typeid
; 330  : 		return (_Rep ? _Rep->_Get_deleter(_Typeid) : 0);
; 331  : 		}
; 332  : 
; 333  : 	_Ty *_Get() const
; 334  : 		{	// return pointer to resource
; 335  : 		return (_Ptr);
; 336  : 		}
; 337  : 
; 338  : 	bool _Expired() const
; 339  : 		{	// test if expired
; 340  : 		return (!_Rep || _Rep->_Expired());
; 341  : 		}
; 342  : 
; 343  : 	void _Decref()
; 344  : 		{	// decrement reference count
; 345  : 		if (_Rep != 0)
; 346  : 			_Rep->_Decref();
; 347  : 		}
; 348  : 
; 349  : 	void _Reset()
; 350  : 		{	// release resource
; 351  : 		_Reset(0, 0);
; 352  : 		}
; 353  : 
; 354  : 	template<class _Ty2>
; 355  : 		void _Reset(const _Ptr_base<_Ty2>& _Other)
; 356  : 		{	// release resource and take ownership of _Other._Ptr
; 357  : 		_Reset(_Other._Ptr, _Other._Rep);

  00018	8b 58 04	 mov	 ebx, DWORD PTR [eax+4]
  0001b	8b 00		 mov	 eax, DWORD PTR [eax]
  0001d	89 45 08	 mov	 DWORD PTR $T1[ebp], eax

; 358  : 		}
; 359  : 
; 360  : 	template<class _Ty2>
; 361  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, bool _Throw)
; 362  : 		{	// release resource and take ownership from weak_ptr _Other._Ptr
; 363  : 		_Reset(_Other._Ptr, _Other._Rep, _Throw);
; 364  : 		}
; 365  : 
; 366  : 	template<class _Ty2>
; 367  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Static_tag&)
; 368  : 		{	// release resource and take ownership of _Other._Ptr
; 369  : 		_Reset(static_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 370  : 		}
; 371  : 
; 372  : 	template<class _Ty2>
; 373  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Const_tag&)
; 374  : 		{	// release resource and take ownership of _Other._Ptr
; 375  : 		_Reset(const_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 376  : 		}
; 377  : 
; 378  : 	template<class _Ty2>
; 379  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Dynamic_tag&)
; 380  : 		{	// release resource and take ownership of _Other._Ptr
; 381  : 		_Elem *_Ptr = dynamic_cast<_Elem *>(_Other._Ptr);
; 382  : 		if (_Ptr)
; 383  : 			_Reset(_Ptr, _Other._Rep);
; 384  : 		else
; 385  : 			_Reset();
; 386  : 		}
; 387  : 
; 388  : 	template<class _Ty2>
; 389  : 		void _Reset(auto_ptr<_Ty2>&& _Other)
; 390  : 		{	// release resource and take _Other.get()
; 391  : 		_Ty2 *_Px = _Other.get();
; 392  : 		_Reset0(_Px, new _Ref_count<_Elem>(_Px));
; 393  : 		_Other.release();
; 394  : 		_Enable_shared(_Px, _Rep);
; 395  : 		}
; 396  : 
; 397  :  #if _HAS_CPP0X
; 398  : 	template<class _Ty2>
; 399  : 		void _Reset(_Ty *_Ptr, const _Ptr_base<_Ty2>& _Other)
; 400  : 		{	// release resource and alias _Ptr with _Other_rep
; 401  : 		_Reset(_Ptr, _Other._Rep);
; 402  : 		}
; 403  :  #endif /* _HAS_CPP0X */
; 404  : 
; 405  : 	void _Reset(_Ty *_Other_ptr, _Ref_count_base *_Other_rep)
; 406  : 		{	// release resource and take _Other_ptr through _Other_rep
; 407  : 		if (_Other_rep)

  00020	85 db		 test	 ebx, ebx
  00022	74 0c		 je	 SHORT $LN10@shared_ptr

; 108  : 		_MT_INCR(_Ignored, _Uses);

  00024	8d 43 04	 lea	 eax, DWORD PTR [ebx+4]
  00027	b9 01 00 00 00	 mov	 ecx, 1
  0002c	f0 0f c1 08	 lock	  xadd	 DWORD PTR [eax], ecx
$LN10@shared_ptr:

; 408  : 			_Other_rep->_Incref();
; 409  : 		_Reset0(_Other_ptr, _Other_rep);
; 410  : 		}
; 411  : 
; 412  : 	void _Reset(_Ty *_Other_ptr, _Ref_count_base *_Other_rep, bool _Throw)
; 413  : 		{	// take _Other_ptr through _Other_rep from weak_ptr if not expired
; 414  : 			// otherwise, leave in default state if !_Throw,
; 415  : 			// otherwise throw exception
; 416  : 		if (_Other_rep && _Other_rep->_Incref_nz())
; 417  : 			_Reset0(_Other_ptr, _Other_rep);
; 418  : 		else if (_Throw)
; 419  : 			_THROW_NCEE(bad_weak_ptr, 0);
; 420  : 		}
; 421  : 
; 422  : 	void _Reset0(_Ty *_Other_ptr, _Ref_count_base *_Other_rep)
; 423  : 		{	// release resource and take new resource
; 424  : 		if (_Rep != 0)

  00030	8b 7e 04	 mov	 edi, DWORD PTR [esi+4]
  00033	85 ff		 test	 edi, edi
  00035	74 25		 je	 SHORT $LN18@shared_ptr

; 109  : 		}
; 110  : 
; 111  : 	void _Incwref()
; 112  : 		{	// increment weak reference count
; 113  : 		_MT_INCR(_Ignored, _Weaks);
; 114  : 		}
; 115  : 
; 116  : 	void _Decref()
; 117  : 		{	// decrement use count
; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  00037	8d 4f 04	 lea	 ecx, DWORD PTR [edi+4]
  0003a	83 c8 ff	 or	 eax, -1
  0003d	f0 0f c1 01	 lock	  xadd	 DWORD PTR [ecx], eax
  00041	75 19		 jne	 SHORT $LN18@shared_ptr

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  00043	8b 07		 mov	 eax, DWORD PTR [edi]
  00045	8b cf		 mov	 ecx, edi
  00047	ff 10		 call	 DWORD PTR [eax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  00049	8d 47 08	 lea	 eax, DWORD PTR [edi+8]
  0004c	83 c9 ff	 or	 ecx, -1
  0004f	f0 0f c1 08	 lock	  xadd	 DWORD PTR [eax], ecx
  00053	75 07		 jne	 SHORT $LN18@shared_ptr

; 128  : 			_Delete_this();

  00055	8b 07		 mov	 eax, DWORD PTR [edi]
  00057	8b cf		 mov	 ecx, edi
  00059	ff 50 04	 call	 DWORD PTR [eax+4]
$LN18@shared_ptr:

; 427  : 		_Ptr = _Other_ptr;

  0005c	8b 45 08	 mov	 eax, DWORD PTR $T1[ebp]
  0005f	89 06		 mov	 DWORD PTR [esi], eax
  00061	5f		 pop	 edi

; 425  : 			_Rep->_Decref();
; 426  : 		_Rep = _Other_rep;

  00062	89 5e 04	 mov	 DWORD PTR [esi+4], ebx

; 535  : 		{	// construct shared_ptr object that owns same resource as _Other
; 536  : 		this->_Reset(_Other);
; 537  : 		}

  00065	8b c6		 mov	 eax, esi
  00067	5e		 pop	 esi
  00068	5b		 pop	 ebx
  00069	5d		 pop	 ebp
  0006a	c2 04 00	 ret	 4
??0?$shared_ptr@VChunkBase@@@std@@QAE@ABV01@@Z ENDP	; std::shared_ptr<ChunkBase>::shared_ptr<ChunkBase>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ??1?$shared_ptr@VChunkBase@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$shared_ptr@VChunkBase@@@std@@QAE@XZ PROC		; std::shared_ptr<ChunkBase>::~shared_ptr<ChunkBase>, COMDAT
; _this$ = ecx

; 622  : 		{	// release resource

  00000	56		 push	 esi

; 129  : 		}
; 130  : 
; 131  : 	long _Use_count() const
; 132  : 		{	// return use count
; 133  : 		return (_Get_uses());
; 134  : 		}
; 135  : 
; 136  : 	bool _Expired() const
; 137  : 		{	// return true if _Uses == 0
; 138  : 		return (_Get_uses() == 0);
; 139  : 		}
; 140  : 
; 141  : 	virtual void *_Get_deleter(const _XSTD2 type_info&) const
; 142  : 		{	// return address of deleter object
; 143  : 		return (0);
; 144  : 		}
; 145  : 	};
; 146  : 
; 147  : 	// TEMPLATE CLASS _Ref_count
; 148  : template<class _Ty>
; 149  : 	class _Ref_count
; 150  : 	: public _Ref_count_base
; 151  : 	{	// handle reference counting for object without deleter
; 152  : public:
; 153  : 	_Ref_count(_Ty *_Px)
; 154  : 		: _Ref_count_base(), _Ptr(_Px)
; 155  : 		{	// construct
; 156  : 		}
; 157  : 
; 158  : private:
; 159  : 	virtual void _Destroy()
; 160  : 		{	// destroy managed resource
; 161  : 		delete _Ptr;
; 162  : 		}
; 163  : 
; 164  : 	virtual void _Delete_this()
; 165  : 		{	// destroy self
; 166  : 		delete this;
; 167  : 		}
; 168  : 
; 169  : 	_Ty * _Ptr;
; 170  : 	};
; 171  : 
; 172  : 	// TEMPLATE CLASS _Ref_count_del
; 173  : template<class _Ty,
; 174  : 	class _Dx>
; 175  : 	class _Ref_count_del
; 176  : 	: public _Ref_count_base
; 177  : 	{	// handle reference counting for object with deleter
; 178  : public:
; 179  : 	_Ref_count_del(_Ty *_Px, _Dx _Dt)
; 180  : 		: _Ref_count_base(), _Ptr(_Px), _Dtor(_Dt)
; 181  : 		{	// construct
; 182  : 		}
; 183  : 
; 184  : 	virtual void *_Get_deleter(const _XSTD2 type_info& _Typeid) const
; 185  : 		{	// return address of deleter object
; 186  : 		return ((void *)(_Typeid == typeid(_Dx) ? &_Dtor : 0));
; 187  : 		}
; 188  : 
; 189  : private:
; 190  : 	virtual void _Destroy()
; 191  : 		{	// destroy managed resource
; 192  : 		_Dtor(_Ptr);
; 193  : 		}
; 194  : 
; 195  : 	virtual void _Delete_this()
; 196  : 		{	// destroy self
; 197  : 		delete this;
; 198  : 		}
; 199  : 
; 200  : 	_Ty * _Ptr;
; 201  : 	_Dx _Dtor;	// the stored destructor for the controlled object
; 202  : 	};
; 203  : 
; 204  : 	// TEMPLATE CLASS _Ref_count_del_alloc
; 205  : template<class _Ty,
; 206  : 	class _Dx,
; 207  : 	class _Alloc>
; 208  : 	class _Ref_count_del_alloc
; 209  : 	: public _Ref_count_base
; 210  : 	{	// handle reference counting for object with deleter and allocator
; 211  : public:
; 212  : 	typedef _Ref_count_del_alloc<_Ty, _Dx, _Alloc> _Myty;
; 213  : 	typedef typename _Alloc::template rebind<_Myty>::other _Myalty;
; 214  : 
; 215  : 	_Ref_count_del_alloc(_Ty *_Px, _Dx _Dt, _Myalty _Al)
; 216  : 		: _Ref_count_base(), _Ptr(_Px), _Dtor(_Dt), _Myal(_Al)
; 217  : 		{	// construct
; 218  : 		}
; 219  : 
; 220  : 	virtual void *_Get_deleter(const _XSTD2 type_info& _Typeid) const
; 221  : 		{	// return address of deleter object
; 222  : 		return ((void *)(_Typeid == typeid(_Dx) ? &_Dtor : 0));
; 223  : 		}
; 224  : 
; 225  : private:
; 226  : 	virtual void _Destroy()
; 227  : 		{	// destroy managed resource
; 228  : 		_Dtor(_Ptr);
; 229  : 		}
; 230  : 
; 231  : 	virtual void _Delete_this()
; 232  : 		{	// destroy self
; 233  : 		_Myalty _Al = _Myal;
; 234  : 		_Al.destroy(this);
; 235  : 		_Al.deallocate(this, 1);
; 236  : 		}
; 237  : 
; 238  : 	_Ty * _Ptr;
; 239  : 	_Dx _Dtor;	// the stored destructor for the controlled object
; 240  : 	_Myalty _Myal;	// the stored allocator for this
; 241  : 	};
; 242  : 
; 243  : 	// DECLARATIONS
; 244  : template<class _Ty>
; 245  : 	class weak_ptr;
; 246  : template<class _Ty>
; 247  : 	class shared_ptr;
; 248  : template<class _Ty>
; 249  : 	class enable_shared_from_this;
; 250  : struct _Static_tag {};
; 251  : struct _Const_tag {};
; 252  : struct _Dynamic_tag {};
; 253  : template<class _Ty1,
; 254  : 	class _Ty2>
; 255  : 	void _Do_enable(_Ty1 *, enable_shared_from_this<_Ty2> *,
; 256  : 		_Ref_count_base *);
; 257  : 
; 258  : template<class _Ty>
; 259  : 	inline void _Enable_shared(_Ty *_Ptr, _Ref_count_base *_Refptr,
; 260  : 		typename _Ty::_EStype * = 0)
; 261  : 	{	// reset internal weak pointer
; 262  : 	if (_Ptr)
; 263  : 		_Do_enable(_Ptr,
; 264  : 			(enable_shared_from_this<typename _Ty::_EStype>*)_Ptr, _Refptr);
; 265  : 	}
; 266  : 
; 267  : inline void _Enable_shared(const volatile void *, const volatile void *)
; 268  : 	{	// not derived from enable_shared_from_this; do nothing
; 269  : 	}
; 270  : 
; 271  : 	// TEMPLATE CLASS _Ptr_base
; 272  : template<class _Ty>
; 273  : 	class _Ptr_base
; 274  : 	{	// base class for shared_ptr and weak_ptr
; 275  : public:
; 276  : 	typedef _Ptr_base<_Ty> _Myt;
; 277  : 	typedef _Ty _Elem;
; 278  : 	typedef _Elem element_type;
; 279  : 
; 280  : 	_Ptr_base()
; 281  : 		: _Ptr(0), _Rep(0)
; 282  : 		{	// construct
; 283  : 		}
; 284  : 
; 285  : 	_Ptr_base(_Myt&& _Right)
; 286  : 		: _Ptr(0), _Rep(0)
; 287  : 		{	// construct _Ptr_base object that takes resource from _Right
; 288  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 289  : 		}
; 290  : 
; 291  : 	template<class _Ty2>
; 292  : 		_Ptr_base(_Ptr_base<_Ty2>&& _Right)
; 293  : 		: _Ptr(_Right._Ptr), _Rep(_Right._Rep)
; 294  : 		{	// construct _Ptr_base object that takes resource from _Right
; 295  : 		_Right._Ptr = 0;
; 296  : 		_Right._Rep = 0;
; 297  : 		}
; 298  : 
; 299  : 	_Myt& operator=(_Myt&& _Right)
; 300  : 		{	// construct _Ptr_base object that takes resource from _Right
; 301  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 302  : 		return (*this);
; 303  : 		}
; 304  : 
; 305  : 	void _Assign_rv(_Myt&& _Right)
; 306  : 		{	// assign by moving _Right
; 307  : 		if (this != &_Right)
; 308  : 			_Swap(_Right);
; 309  : 		}
; 310  : 
; 311  : 	long use_count() const _NOEXCEPT
; 312  : 		{	// return use count
; 313  : 		return (_Rep ? _Rep->_Use_count() : 0);
; 314  : 		}
; 315  : 
; 316  : 	void _Swap(_Ptr_base& _Right)
; 317  : 		{	// swap pointers
; 318  : 		_STD swap(_Rep, _Right._Rep);
; 319  : 		_STD swap(_Ptr, _Right._Ptr);
; 320  : 		}
; 321  : 
; 322  : 	template<class _Ty2>
; 323  : 		bool owner_before(const _Ptr_base<_Ty2>& _Right) const
; 324  : 		{	// compare addresses of manager objects
; 325  : 		return (_Rep < _Right._Rep);
; 326  : 		}
; 327  : 
; 328  : 	void *_Get_deleter(const _XSTD2 type_info& _Typeid) const
; 329  : 		{	// return pointer to deleter object if its type is _Typeid
; 330  : 		return (_Rep ? _Rep->_Get_deleter(_Typeid) : 0);
; 331  : 		}
; 332  : 
; 333  : 	_Ty *_Get() const
; 334  : 		{	// return pointer to resource
; 335  : 		return (_Ptr);
; 336  : 		}
; 337  : 
; 338  : 	bool _Expired() const
; 339  : 		{	// test if expired
; 340  : 		return (!_Rep || _Rep->_Expired());
; 341  : 		}
; 342  : 
; 343  : 	void _Decref()
; 344  : 		{	// decrement reference count
; 345  : 		if (_Rep != 0)

  00001	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  00004	85 f6		 test	 esi, esi
  00006	74 29		 je	 SHORT $LN9@shared_ptr
  00008	57		 push	 edi

; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  00009	83 cf ff	 or	 edi, -1
  0000c	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  0000f	8b c7		 mov	 eax, edi
  00011	f0 0f c1 01	 lock	  xadd	 DWORD PTR [ecx], eax
  00015	75 19		 jne	 SHORT $LN12@shared_ptr

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  00017	8b 06		 mov	 eax, DWORD PTR [esi]
  00019	8b ce		 mov	 ecx, esi
  0001b	ff 10		 call	 DWORD PTR [eax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  0001d	8d 46 08	 lea	 eax, DWORD PTR [esi+8]
  00020	f0 0f c1 38	 lock	  xadd	 DWORD PTR [eax], edi
  00024	4f		 dec	 edi
  00025	75 09		 jne	 SHORT $LN12@shared_ptr

; 128  : 			_Delete_this();

  00027	8b 06		 mov	 eax, DWORD PTR [esi]
  00029	5f		 pop	 edi
  0002a	8b ce		 mov	 ecx, esi
  0002c	5e		 pop	 esi
  0002d	ff 60 04	 jmp	 DWORD PTR [eax+4]
$LN12@shared_ptr:
  00030	5f		 pop	 edi
$LN9@shared_ptr:
  00031	5e		 pop	 esi

; 623  : 		this->_Decref();
; 624  : 		}

  00032	c3		 ret	 0
??1?$shared_ptr@VChunkBase@@@std@@QAE@XZ ENDP		; std::shared_ptr<ChunkBase>::~shared_ptr<ChunkBase>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ??C?$shared_ptr@VChunkBase@@@std@@QBEPAVChunkBase@@XZ
_TEXT	SEGMENT
??C?$shared_ptr@VChunkBase@@@std@@QBEPAVChunkBase@@XZ PROC ; std::shared_ptr<ChunkBase>::operator->, COMDAT
; _this$ = ecx

; 691  : 		return (this->_Get());

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 692  : 		}

  00002	c3		 ret	 0
??C?$shared_ptr@VChunkBase@@@std@@QBEPAVChunkBase@@XZ ENDP ; std::shared_ptr<ChunkBase>::operator->
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ??0?$shared_ptr@VVertexStream@gfxu@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
$T1 = 8							; size = 4
__Other$ = 8						; size = 4
??0?$shared_ptr@VVertexStream@gfxu@@@std@@QAE@ABV01@@Z PROC ; std::shared_ptr<gfxu::VertexStream>::shared_ptr<gfxu::VertexStream>, COMDAT
; _this$ = ecx

; 534  : 	shared_ptr(const _Myt& _Other) _NOEXCEPT

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 283  : 		}
; 284  : 
; 285  : 	_Ptr_base(_Myt&& _Right)
; 286  : 		: _Ptr(0), _Rep(0)
; 287  : 		{	// construct _Ptr_base object that takes resource from _Right
; 288  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 289  : 		}
; 290  : 
; 291  : 	template<class _Ty2>
; 292  : 		_Ptr_base(_Ptr_base<_Ty2>&& _Right)
; 293  : 		: _Ptr(_Right._Ptr), _Rep(_Right._Rep)
; 294  : 		{	// construct _Ptr_base object that takes resource from _Right
; 295  : 		_Right._Ptr = 0;
; 296  : 		_Right._Rep = 0;
; 297  : 		}
; 298  : 
; 299  : 	_Myt& operator=(_Myt&& _Right)
; 300  : 		{	// construct _Ptr_base object that takes resource from _Right
; 301  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 302  : 		return (*this);
; 303  : 		}
; 304  : 
; 305  : 	void _Assign_rv(_Myt&& _Right)
; 306  : 		{	// assign by moving _Right
; 307  : 		if (this != &_Right)
; 308  : 			_Swap(_Right);
; 309  : 		}
; 310  : 
; 311  : 	long use_count() const _NOEXCEPT
; 312  : 		{	// return use count
; 313  : 		return (_Rep ? _Rep->_Use_count() : 0);
; 314  : 		}
; 315  : 
; 316  : 	void _Swap(_Ptr_base& _Right)
; 317  : 		{	// swap pointers
; 318  : 		_STD swap(_Rep, _Right._Rep);
; 319  : 		_STD swap(_Ptr, _Right._Ptr);
; 320  : 		}
; 321  : 
; 322  : 	template<class _Ty2>
; 323  : 		bool owner_before(const _Ptr_base<_Ty2>& _Right) const
; 324  : 		{	// compare addresses of manager objects
; 325  : 		return (_Rep < _Right._Rep);
; 326  : 		}
; 327  : 
; 328  : 	void *_Get_deleter(const _XSTD2 type_info& _Typeid) const
; 329  : 		{	// return pointer to deleter object if its type is _Typeid
; 330  : 		return (_Rep ? _Rep->_Get_deleter(_Typeid) : 0);
; 331  : 		}
; 332  : 
; 333  : 	_Ty *_Get() const
; 334  : 		{	// return pointer to resource
; 335  : 		return (_Ptr);
; 336  : 		}
; 337  : 
; 338  : 	bool _Expired() const
; 339  : 		{	// test if expired
; 340  : 		return (!_Rep || _Rep->_Expired());
; 341  : 		}
; 342  : 
; 343  : 	void _Decref()
; 344  : 		{	// decrement reference count
; 345  : 		if (_Rep != 0)
; 346  : 			_Rep->_Decref();
; 347  : 		}
; 348  : 
; 349  : 	void _Reset()
; 350  : 		{	// release resource
; 351  : 		_Reset(0, 0);
; 352  : 		}
; 353  : 
; 354  : 	template<class _Ty2>
; 355  : 		void _Reset(const _Ptr_base<_Ty2>& _Other)
; 356  : 		{	// release resource and take ownership of _Other._Ptr
; 357  : 		_Reset(_Other._Ptr, _Other._Rep);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Other$[ebp]
  00006	53		 push	 ebx
  00007	56		 push	 esi

; 534  : 	shared_ptr(const _Myt& _Other) _NOEXCEPT

  00008	8b f1		 mov	 esi, ecx
  0000a	57		 push	 edi

; 129  : 		}
; 130  : 
; 131  : 	long _Use_count() const
; 132  : 		{	// return use count
; 133  : 		return (_Get_uses());
; 134  : 		}
; 135  : 
; 136  : 	bool _Expired() const
; 137  : 		{	// return true if _Uses == 0
; 138  : 		return (_Get_uses() == 0);
; 139  : 		}
; 140  : 
; 141  : 	virtual void *_Get_deleter(const _XSTD2 type_info&) const
; 142  : 		{	// return address of deleter object
; 143  : 		return (0);
; 144  : 		}
; 145  : 	};
; 146  : 
; 147  : 	// TEMPLATE CLASS _Ref_count
; 148  : template<class _Ty>
; 149  : 	class _Ref_count
; 150  : 	: public _Ref_count_base
; 151  : 	{	// handle reference counting for object without deleter
; 152  : public:
; 153  : 	_Ref_count(_Ty *_Px)
; 154  : 		: _Ref_count_base(), _Ptr(_Px)
; 155  : 		{	// construct
; 156  : 		}
; 157  : 
; 158  : private:
; 159  : 	virtual void _Destroy()
; 160  : 		{	// destroy managed resource
; 161  : 		delete _Ptr;
; 162  : 		}
; 163  : 
; 164  : 	virtual void _Delete_this()
; 165  : 		{	// destroy self
; 166  : 		delete this;
; 167  : 		}
; 168  : 
; 169  : 	_Ty * _Ptr;
; 170  : 	};
; 171  : 
; 172  : 	// TEMPLATE CLASS _Ref_count_del
; 173  : template<class _Ty,
; 174  : 	class _Dx>
; 175  : 	class _Ref_count_del
; 176  : 	: public _Ref_count_base
; 177  : 	{	// handle reference counting for object with deleter
; 178  : public:
; 179  : 	_Ref_count_del(_Ty *_Px, _Dx _Dt)
; 180  : 		: _Ref_count_base(), _Ptr(_Px), _Dtor(_Dt)
; 181  : 		{	// construct
; 182  : 		}
; 183  : 
; 184  : 	virtual void *_Get_deleter(const _XSTD2 type_info& _Typeid) const
; 185  : 		{	// return address of deleter object
; 186  : 		return ((void *)(_Typeid == typeid(_Dx) ? &_Dtor : 0));
; 187  : 		}
; 188  : 
; 189  : private:
; 190  : 	virtual void _Destroy()
; 191  : 		{	// destroy managed resource
; 192  : 		_Dtor(_Ptr);
; 193  : 		}
; 194  : 
; 195  : 	virtual void _Delete_this()
; 196  : 		{	// destroy self
; 197  : 		delete this;
; 198  : 		}
; 199  : 
; 200  : 	_Ty * _Ptr;
; 201  : 	_Dx _Dtor;	// the stored destructor for the controlled object
; 202  : 	};
; 203  : 
; 204  : 	// TEMPLATE CLASS _Ref_count_del_alloc
; 205  : template<class _Ty,
; 206  : 	class _Dx,
; 207  : 	class _Alloc>
; 208  : 	class _Ref_count_del_alloc
; 209  : 	: public _Ref_count_base
; 210  : 	{	// handle reference counting for object with deleter and allocator
; 211  : public:
; 212  : 	typedef _Ref_count_del_alloc<_Ty, _Dx, _Alloc> _Myty;
; 213  : 	typedef typename _Alloc::template rebind<_Myty>::other _Myalty;
; 214  : 
; 215  : 	_Ref_count_del_alloc(_Ty *_Px, _Dx _Dt, _Myalty _Al)
; 216  : 		: _Ref_count_base(), _Ptr(_Px), _Dtor(_Dt), _Myal(_Al)
; 217  : 		{	// construct
; 218  : 		}
; 219  : 
; 220  : 	virtual void *_Get_deleter(const _XSTD2 type_info& _Typeid) const
; 221  : 		{	// return address of deleter object
; 222  : 		return ((void *)(_Typeid == typeid(_Dx) ? &_Dtor : 0));
; 223  : 		}
; 224  : 
; 225  : private:
; 226  : 	virtual void _Destroy()
; 227  : 		{	// destroy managed resource
; 228  : 		_Dtor(_Ptr);
; 229  : 		}
; 230  : 
; 231  : 	virtual void _Delete_this()
; 232  : 		{	// destroy self
; 233  : 		_Myalty _Al = _Myal;
; 234  : 		_Al.destroy(this);
; 235  : 		_Al.deallocate(this, 1);
; 236  : 		}
; 237  : 
; 238  : 	_Ty * _Ptr;
; 239  : 	_Dx _Dtor;	// the stored destructor for the controlled object
; 240  : 	_Myalty _Myal;	// the stored allocator for this
; 241  : 	};
; 242  : 
; 243  : 	// DECLARATIONS
; 244  : template<class _Ty>
; 245  : 	class weak_ptr;
; 246  : template<class _Ty>
; 247  : 	class shared_ptr;
; 248  : template<class _Ty>
; 249  : 	class enable_shared_from_this;
; 250  : struct _Static_tag {};
; 251  : struct _Const_tag {};
; 252  : struct _Dynamic_tag {};
; 253  : template<class _Ty1,
; 254  : 	class _Ty2>
; 255  : 	void _Do_enable(_Ty1 *, enable_shared_from_this<_Ty2> *,
; 256  : 		_Ref_count_base *);
; 257  : 
; 258  : template<class _Ty>
; 259  : 	inline void _Enable_shared(_Ty *_Ptr, _Ref_count_base *_Refptr,
; 260  : 		typename _Ty::_EStype * = 0)
; 261  : 	{	// reset internal weak pointer
; 262  : 	if (_Ptr)
; 263  : 		_Do_enable(_Ptr,
; 264  : 			(enable_shared_from_this<typename _Ty::_EStype>*)_Ptr, _Refptr);
; 265  : 	}
; 266  : 
; 267  : inline void _Enable_shared(const volatile void *, const volatile void *)
; 268  : 	{	// not derived from enable_shared_from_this; do nothing
; 269  : 	}
; 270  : 
; 271  : 	// TEMPLATE CLASS _Ptr_base
; 272  : template<class _Ty>
; 273  : 	class _Ptr_base
; 274  : 	{	// base class for shared_ptr and weak_ptr
; 275  : public:
; 276  : 	typedef _Ptr_base<_Ty> _Myt;
; 277  : 	typedef _Ty _Elem;
; 278  : 	typedef _Elem element_type;
; 279  : 
; 280  : 	_Ptr_base()
; 281  : 		: _Ptr(0), _Rep(0)
; 282  : 		{	// construct

  0000b	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  00011	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 283  : 		}
; 284  : 
; 285  : 	_Ptr_base(_Myt&& _Right)
; 286  : 		: _Ptr(0), _Rep(0)
; 287  : 		{	// construct _Ptr_base object that takes resource from _Right
; 288  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 289  : 		}
; 290  : 
; 291  : 	template<class _Ty2>
; 292  : 		_Ptr_base(_Ptr_base<_Ty2>&& _Right)
; 293  : 		: _Ptr(_Right._Ptr), _Rep(_Right._Rep)
; 294  : 		{	// construct _Ptr_base object that takes resource from _Right
; 295  : 		_Right._Ptr = 0;
; 296  : 		_Right._Rep = 0;
; 297  : 		}
; 298  : 
; 299  : 	_Myt& operator=(_Myt&& _Right)
; 300  : 		{	// construct _Ptr_base object that takes resource from _Right
; 301  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 302  : 		return (*this);
; 303  : 		}
; 304  : 
; 305  : 	void _Assign_rv(_Myt&& _Right)
; 306  : 		{	// assign by moving _Right
; 307  : 		if (this != &_Right)
; 308  : 			_Swap(_Right);
; 309  : 		}
; 310  : 
; 311  : 	long use_count() const _NOEXCEPT
; 312  : 		{	// return use count
; 313  : 		return (_Rep ? _Rep->_Use_count() : 0);
; 314  : 		}
; 315  : 
; 316  : 	void _Swap(_Ptr_base& _Right)
; 317  : 		{	// swap pointers
; 318  : 		_STD swap(_Rep, _Right._Rep);
; 319  : 		_STD swap(_Ptr, _Right._Ptr);
; 320  : 		}
; 321  : 
; 322  : 	template<class _Ty2>
; 323  : 		bool owner_before(const _Ptr_base<_Ty2>& _Right) const
; 324  : 		{	// compare addresses of manager objects
; 325  : 		return (_Rep < _Right._Rep);
; 326  : 		}
; 327  : 
; 328  : 	void *_Get_deleter(const _XSTD2 type_info& _Typeid) const
; 329  : 		{	// return pointer to deleter object if its type is _Typeid
; 330  : 		return (_Rep ? _Rep->_Get_deleter(_Typeid) : 0);
; 331  : 		}
; 332  : 
; 333  : 	_Ty *_Get() const
; 334  : 		{	// return pointer to resource
; 335  : 		return (_Ptr);
; 336  : 		}
; 337  : 
; 338  : 	bool _Expired() const
; 339  : 		{	// test if expired
; 340  : 		return (!_Rep || _Rep->_Expired());
; 341  : 		}
; 342  : 
; 343  : 	void _Decref()
; 344  : 		{	// decrement reference count
; 345  : 		if (_Rep != 0)
; 346  : 			_Rep->_Decref();
; 347  : 		}
; 348  : 
; 349  : 	void _Reset()
; 350  : 		{	// release resource
; 351  : 		_Reset(0, 0);
; 352  : 		}
; 353  : 
; 354  : 	template<class _Ty2>
; 355  : 		void _Reset(const _Ptr_base<_Ty2>& _Other)
; 356  : 		{	// release resource and take ownership of _Other._Ptr
; 357  : 		_Reset(_Other._Ptr, _Other._Rep);

  00018	8b 58 04	 mov	 ebx, DWORD PTR [eax+4]
  0001b	8b 00		 mov	 eax, DWORD PTR [eax]
  0001d	89 45 08	 mov	 DWORD PTR $T1[ebp], eax

; 358  : 		}
; 359  : 
; 360  : 	template<class _Ty2>
; 361  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, bool _Throw)
; 362  : 		{	// release resource and take ownership from weak_ptr _Other._Ptr
; 363  : 		_Reset(_Other._Ptr, _Other._Rep, _Throw);
; 364  : 		}
; 365  : 
; 366  : 	template<class _Ty2>
; 367  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Static_tag&)
; 368  : 		{	// release resource and take ownership of _Other._Ptr
; 369  : 		_Reset(static_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 370  : 		}
; 371  : 
; 372  : 	template<class _Ty2>
; 373  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Const_tag&)
; 374  : 		{	// release resource and take ownership of _Other._Ptr
; 375  : 		_Reset(const_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 376  : 		}
; 377  : 
; 378  : 	template<class _Ty2>
; 379  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Dynamic_tag&)
; 380  : 		{	// release resource and take ownership of _Other._Ptr
; 381  : 		_Elem *_Ptr = dynamic_cast<_Elem *>(_Other._Ptr);
; 382  : 		if (_Ptr)
; 383  : 			_Reset(_Ptr, _Other._Rep);
; 384  : 		else
; 385  : 			_Reset();
; 386  : 		}
; 387  : 
; 388  : 	template<class _Ty2>
; 389  : 		void _Reset(auto_ptr<_Ty2>&& _Other)
; 390  : 		{	// release resource and take _Other.get()
; 391  : 		_Ty2 *_Px = _Other.get();
; 392  : 		_Reset0(_Px, new _Ref_count<_Elem>(_Px));
; 393  : 		_Other.release();
; 394  : 		_Enable_shared(_Px, _Rep);
; 395  : 		}
; 396  : 
; 397  :  #if _HAS_CPP0X
; 398  : 	template<class _Ty2>
; 399  : 		void _Reset(_Ty *_Ptr, const _Ptr_base<_Ty2>& _Other)
; 400  : 		{	// release resource and alias _Ptr with _Other_rep
; 401  : 		_Reset(_Ptr, _Other._Rep);
; 402  : 		}
; 403  :  #endif /* _HAS_CPP0X */
; 404  : 
; 405  : 	void _Reset(_Ty *_Other_ptr, _Ref_count_base *_Other_rep)
; 406  : 		{	// release resource and take _Other_ptr through _Other_rep
; 407  : 		if (_Other_rep)

  00020	85 db		 test	 ebx, ebx
  00022	74 0c		 je	 SHORT $LN10@shared_ptr

; 108  : 		_MT_INCR(_Ignored, _Uses);

  00024	8d 43 04	 lea	 eax, DWORD PTR [ebx+4]
  00027	b9 01 00 00 00	 mov	 ecx, 1
  0002c	f0 0f c1 08	 lock	  xadd	 DWORD PTR [eax], ecx
$LN10@shared_ptr:

; 408  : 			_Other_rep->_Incref();
; 409  : 		_Reset0(_Other_ptr, _Other_rep);
; 410  : 		}
; 411  : 
; 412  : 	void _Reset(_Ty *_Other_ptr, _Ref_count_base *_Other_rep, bool _Throw)
; 413  : 		{	// take _Other_ptr through _Other_rep from weak_ptr if not expired
; 414  : 			// otherwise, leave in default state if !_Throw,
; 415  : 			// otherwise throw exception
; 416  : 		if (_Other_rep && _Other_rep->_Incref_nz())
; 417  : 			_Reset0(_Other_ptr, _Other_rep);
; 418  : 		else if (_Throw)
; 419  : 			_THROW_NCEE(bad_weak_ptr, 0);
; 420  : 		}
; 421  : 
; 422  : 	void _Reset0(_Ty *_Other_ptr, _Ref_count_base *_Other_rep)
; 423  : 		{	// release resource and take new resource
; 424  : 		if (_Rep != 0)

  00030	8b 7e 04	 mov	 edi, DWORD PTR [esi+4]
  00033	85 ff		 test	 edi, edi
  00035	74 25		 je	 SHORT $LN18@shared_ptr

; 109  : 		}
; 110  : 
; 111  : 	void _Incwref()
; 112  : 		{	// increment weak reference count
; 113  : 		_MT_INCR(_Ignored, _Weaks);
; 114  : 		}
; 115  : 
; 116  : 	void _Decref()
; 117  : 		{	// decrement use count
; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  00037	8d 4f 04	 lea	 ecx, DWORD PTR [edi+4]
  0003a	83 c8 ff	 or	 eax, -1
  0003d	f0 0f c1 01	 lock	  xadd	 DWORD PTR [ecx], eax
  00041	75 19		 jne	 SHORT $LN18@shared_ptr

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  00043	8b 07		 mov	 eax, DWORD PTR [edi]
  00045	8b cf		 mov	 ecx, edi
  00047	ff 10		 call	 DWORD PTR [eax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  00049	8d 47 08	 lea	 eax, DWORD PTR [edi+8]
  0004c	83 c9 ff	 or	 ecx, -1
  0004f	f0 0f c1 08	 lock	  xadd	 DWORD PTR [eax], ecx
  00053	75 07		 jne	 SHORT $LN18@shared_ptr

; 128  : 			_Delete_this();

  00055	8b 07		 mov	 eax, DWORD PTR [edi]
  00057	8b cf		 mov	 ecx, edi
  00059	ff 50 04	 call	 DWORD PTR [eax+4]
$LN18@shared_ptr:

; 427  : 		_Ptr = _Other_ptr;

  0005c	8b 45 08	 mov	 eax, DWORD PTR $T1[ebp]
  0005f	89 06		 mov	 DWORD PTR [esi], eax
  00061	5f		 pop	 edi

; 425  : 			_Rep->_Decref();
; 426  : 		_Rep = _Other_rep;

  00062	89 5e 04	 mov	 DWORD PTR [esi+4], ebx

; 535  : 		{	// construct shared_ptr object that owns same resource as _Other
; 536  : 		this->_Reset(_Other);
; 537  : 		}

  00065	8b c6		 mov	 eax, esi
  00067	5e		 pop	 esi
  00068	5b		 pop	 ebx
  00069	5d		 pop	 ebp
  0006a	c2 04 00	 ret	 4
??0?$shared_ptr@VVertexStream@gfxu@@@std@@QAE@ABV01@@Z ENDP ; std::shared_ptr<gfxu::VertexStream>::shared_ptr<gfxu::VertexStream>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ?swap@?$shared_ptr@VVertexStream@gfxu@@@std@@QAEXAAV12@@Z
_TEXT	SEGMENT
__Other$ = 8						; size = 4
?swap@?$shared_ptr@VVertexStream@gfxu@@@std@@QAEXAAV12@@Z PROC ; std::shared_ptr<gfxu::VertexStream>::swap, COMDAT
; _this$ = ecx

; 675  : 		{	// swap pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility

; 47   : 	_Ty _Tmp = _Move(_Left);

  00003	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00006	56		 push	 esi
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 318  : 		_STD swap(_Rep, _Right._Rep);

  00007	8b 75 08	 mov	 esi, DWORD PTR __Other$[ebp]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility

; 48   : 	_Left = _Move(_Right);

  0000a	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0000d	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 49   : 	_Right = _Move(_Tmp);

  00010	89 56 04	 mov	 DWORD PTR [esi+4], edx

; 48   : 	_Left = _Move(_Right);

  00013	8b 06		 mov	 eax, DWORD PTR [esi]
  00015	8b 11		 mov	 edx, DWORD PTR [ecx]
  00017	89 01		 mov	 DWORD PTR [ecx], eax

; 49   : 	_Right = _Move(_Tmp);

  00019	89 16		 mov	 DWORD PTR [esi], edx
  0001b	5e		 pop	 esi
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 677  : 		}

  0001c	5d		 pop	 ebp
  0001d	c2 04 00	 ret	 4
?swap@?$shared_ptr@VVertexStream@gfxu@@@std@@QAEXAAV12@@Z ENDP ; std::shared_ptr<gfxu::VertexStream>::swap
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ?_Decref@?$_Ptr_base@VVertexStream@gfxu@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Decref@?$_Ptr_base@VVertexStream@gfxu@@@std@@QAEXXZ PROC ; std::_Ptr_base<gfxu::VertexStream>::_Decref, COMDAT
; _this$ = ecx

; 344  : 		{	// decrement reference count

  00000	56		 push	 esi

; 345  : 		if (_Rep != 0)

  00001	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  00004	85 f6		 test	 esi, esi
  00006	74 29		 je	 SHORT $LN7@Decref
  00008	57		 push	 edi

; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  00009	83 cf ff	 or	 edi, -1
  0000c	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  0000f	8b c7		 mov	 eax, edi
  00011	f0 0f c1 01	 lock	  xadd	 DWORD PTR [ecx], eax
  00015	75 19		 jne	 SHORT $LN10@Decref

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  00017	8b 06		 mov	 eax, DWORD PTR [esi]
  00019	8b ce		 mov	 ecx, esi
  0001b	ff 10		 call	 DWORD PTR [eax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  0001d	8d 46 08	 lea	 eax, DWORD PTR [esi+8]
  00020	f0 0f c1 38	 lock	  xadd	 DWORD PTR [eax], edi
  00024	4f		 dec	 edi
  00025	75 09		 jne	 SHORT $LN10@Decref

; 128  : 			_Delete_this();

  00027	8b 06		 mov	 eax, DWORD PTR [esi]
  00029	5f		 pop	 edi
  0002a	8b ce		 mov	 ecx, esi
  0002c	5e		 pop	 esi
  0002d	ff 60 04	 jmp	 DWORD PTR [eax+4]
$LN10@Decref:
  00030	5f		 pop	 edi
$LN7@Decref:
  00031	5e		 pop	 esi

; 346  : 			_Rep->_Decref();
; 347  : 		}

  00032	c3		 ret	 0
?_Decref@?$_Ptr_base@VVertexStream@gfxu@@@std@@QAEXXZ ENDP ; std::_Ptr_base<gfxu::VertexStream>::_Decref
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
;	COMDAT ?size@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QBEIXZ PROC ; std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::size, COMDAT
; _this$ = ecx

; 1372 : 		return (this->_Mysize);

  00000	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]

; 1373 : 		}

  00003	c3		 ret	 0
?size@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QBEIXZ ENDP ; std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
;	COMDAT ?front@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QAEAAV?$shared_ptr@VChunkBase@@@2@XZ
_TEXT	SEGMENT
$T1 = -12						; size = 12
?front@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QAEAAV?$shared_ptr@VChunkBase@@@2@XZ PROC ; std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::front, COMDAT
; _this$ = ecx

; 1425 : 		{	// return first element of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 1426 : 		return (*begin());

  00006	8d 45 f4	 lea	 eax, DWORD PTR $T1[ebp]
  00009	56		 push	 esi
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ?begin@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@2@XZ ; std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::begin
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility

; 178  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

  00010	8b 30		 mov	 esi, DWORD PTR [eax]
  00012	85 f6		 test	 esi, esi
  00014	74 02		 je	 SHORT $LN10@front
$LN9@front:
  00016	8b 36		 mov	 esi, DWORD PTR [esi]
$LN10@front:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 787  : 		return ((_Off / _DEQUESIZ) & (this->_Mapsize - 1));

  00018	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  0001b	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0001e	48		 dec	 eax
  0001f	8b ca		 mov	 ecx, edx
  00021	d1 e9		 shr	 ecx, 1
  00023	23 c8		 and	 ecx, eax

; 345  : 		return (_Mycont->_Map[_Block][_Off]);

  00025	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00028	83 e2 01	 and	 edx, 1
  0002b	8b 04 88	 mov	 eax, DWORD PTR [eax+ecx*4]
  0002e	5e		 pop	 esi
  0002f	8d 04 d0	 lea	 eax, DWORD PTR [eax+edx*8]

; 1427 : 		}

  00032	8b e5		 mov	 esp, ebp
  00034	5d		 pop	 ebp
  00035	c3		 ret	 0
?front@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QAEAAV?$shared_ptr@VChunkBase@@@2@XZ ENDP ; std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::front
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
;	COMDAT ?pop_front@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QAEXXZ
_TEXT	SEGMENT
?pop_front@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QAEXXZ PROC ; std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::pop_front, COMDAT
; _this$ = ecx

; 1454 : 		{	// erase element at beginning

  00000	57		 push	 edi
  00001	8b f9		 mov	 edi, ecx

; 788  : 		}
; 789  : 
; 790  : 	_Mapptr _Map;		// pointer to array of pointers to blocks
; 791  : 	size_type _Mapsize;	// size of map array, zero or 2^N
; 792  : 	size_type _Myoff;	// offset of initial element
; 793  : 	size_type _Mysize;	// current length of sequence
; 794  : 	};
; 795  : 
; 796  : 		// TEMPLATE CLASS _Deque_alloc
; 797  : template<bool _Al_has_storage,
; 798  : 	class _Alloc_types>
; 799  : 	class _Deque_alloc
; 800  : 		: public _Deque_val<typename _Alloc_types::_Val_types>
; 801  : 	{	// base class for deque to hold allocator with storage
; 802  : public:
; 803  : 	typedef _Deque_alloc<_Al_has_storage, _Alloc_types> _Myt;
; 804  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 805  : 	typedef typename _Alloc_types::_Alty _Alty;
; 806  : 
; 807  : 	typedef typename _Alloc_types::_Alpty _Alpty;
; 808  : 
; 809  : 	_Deque_alloc(const _Alloc& _Al = _Alloc())
; 810  : 		: _Alval(_Al)
; 811  : 		{	// construct allocators from _Al
; 812  : 		_Alloc_proxy();
; 813  : 		}
; 814  : 
; 815  : 	~_Deque_alloc() _NOEXCEPT
; 816  : 		{	// destroy proxy
; 817  : 		_Free_proxy();
; 818  : 		}
; 819  : 
; 820  : 	void _Change_alloc(const _Alty& _Al)
; 821  : 		{	// replace old allocator
; 822  : 		_Free_proxy();
; 823  : 		_Alval = _Al;
; 824  : 		_Alloc_proxy();
; 825  : 		}
; 826  : 
; 827  : 	void _Swap_alloc(_Myt& _Right)
; 828  : 		{	// swap allocators
; 829  : 		_Swap_adl(_Alval, _Right._Alval);
; 830  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 831  : 		}
; 832  : 
; 833  : 	void _Alloc_proxy()
; 834  : 		{	// construct proxy from _Alval
; 835  : 		typename _Alty::template rebind<_Container_proxy>::other
; 836  : 			_Alproxy(_Alval);
; 837  : 		this->_Myproxy = _Alproxy.allocate(1);
; 838  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 839  : 		this->_Myproxy->_Mycont = this;
; 840  : 		}
; 841  : 
; 842  : 	void _Free_proxy()
; 843  : 		{	// destroy proxy
; 844  : 		typename _Alty::template rebind<_Container_proxy>::other
; 845  : 			_Alproxy(_Alval);
; 846  : 		this->_Orphan_all();
; 847  : 		_Alproxy.destroy(this->_Myproxy);
; 848  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 849  : 		this->_Myproxy = 0;
; 850  : 		}
; 851  : 
; 852  : 	_Alty& _Getal()
; 853  : 		{	// get reference to allocator
; 854  : 		return (_Alval);
; 855  : 		}
; 856  : 
; 857  : 	const _Alty& _Getal() const
; 858  : 		{	// get reference to allocator
; 859  : 		return (_Alval);
; 860  : 		}
; 861  : 
; 862  : 	_Alty _Alval;	// allocator object for stored elements
; 863  : 	};
; 864  : 
; 865  : template<class _Alloc_types>
; 866  : 	class _Deque_alloc<false, _Alloc_types>
; 867  : 		: public _Deque_val<typename _Alloc_types::_Val_types>
; 868  : 	{	// base class for deque to hold allocator with no storage
; 869  : public:
; 870  : 	typedef _Deque_alloc<false, _Alloc_types> _Myt;
; 871  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 872  : 
; 873  : 	typedef typename _Alloc_types::_Alty _Alty;
; 874  : 
; 875  : 	typedef typename _Alloc_types::_Alpty _Alpty;
; 876  : 
; 877  : 	_Deque_alloc(const _Alloc& = _Alloc())
; 878  : 		{	// construct allocators from _Al
; 879  : 		_Alloc_proxy();
; 880  : 		}
; 881  : 
; 882  : 	~_Deque_alloc() _NOEXCEPT
; 883  : 		{	// destroy proxy
; 884  : 		_Free_proxy();
; 885  : 		}
; 886  : 
; 887  : 	void _Change_alloc(const _Alty&)
; 888  : 		{	// replace old allocator
; 889  : 		}
; 890  : 
; 891  : 	void _Swap_alloc(_Myt& _Right)
; 892  : 		{	// swap allocators
; 893  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 894  : 		}
; 895  : 
; 896  : 	void _Alloc_proxy()
; 897  : 		{	// construct proxy from _Alval
; 898  : 		typename _Alty::template rebind<_Container_proxy>::other
; 899  : 			_Alproxy;
; 900  : 		this->_Myproxy = _Alproxy.allocate(1);
; 901  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 902  : 		this->_Myproxy->_Mycont = this;
; 903  : 		}
; 904  : 
; 905  : 	void _Free_proxy()
; 906  : 		{	// destroy proxy
; 907  : 		typename _Alty::template rebind<_Container_proxy>::other
; 908  : 			_Alproxy;
; 909  : 		this->_Orphan_all();
; 910  : 		_Alproxy.destroy(this->_Myproxy);
; 911  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 912  : 		this->_Myproxy = 0;
; 913  : 		}
; 914  : 
; 915  : 	_Alty _Getal() const
; 916  : 		{	// get reference to allocator
; 917  : 		return (_Alty());
; 918  : 		}
; 919  : 	};
; 920  : 
; 921  : 		// TEMPLATE CLASS deque
; 922  : template<class _Ty,
; 923  : 	class _Alloc = allocator<_Ty> >
; 924  : 	class deque
; 925  : 		: public _Deque_alloc<!is_empty<_Alloc>::value,
; 926  : 			_Deque_base_types<_Ty, _Alloc> >
; 927  : 	{	// circular queue of pointers to blocks
; 928  : public:
; 929  : 	typedef deque<_Ty, _Alloc> _Myt;
; 930  : 	typedef _Deque_alloc<!is_empty<_Alloc>::value,
; 931  : 		_Deque_base_types<_Ty, _Alloc> > _Mybase;
; 932  : 	typedef _Alloc allocator_type;
; 933  : 
; 934  : 	typedef typename _Mybase::_Alty _Alty;
; 935  : 	typedef typename _Mybase::_Alpty _Alpty;
; 936  : 	typedef typename _Mybase::_Mapptr _Mapptr;
; 937  : 
; 938  : 	typedef typename _Mybase::value_type value_type;
; 939  : 	typedef typename _Mybase::size_type size_type;
; 940  : 	typedef typename _Mybase::difference_type difference_type;
; 941  : 	typedef typename _Mybase::pointer pointer;
; 942  : 	typedef typename _Mybase::const_pointer const_pointer;
; 943  : 	typedef typename _Mybase::reference reference;
; 944  : 	typedef typename _Mybase::const_reference const_reference;
; 945  : 
; 946  : 	typedef typename _Mybase::iterator iterator;
; 947  : 	typedef typename _Mybase::const_iterator const_iterator;
; 948  : 
; 949  : 	typedef _STD reverse_iterator<iterator> reverse_iterator;
; 950  : 	typedef _STD reverse_iterator<const_iterator> const_reverse_iterator;
; 951  : 
; 952  : 	static const int _EEM_DS = _DEQUESIZ;
; 953  : 	enum {_EEN_DS = _DEQUESIZ};	// helper for expression evaluator
; 954  : 	deque()
; 955  : 		: _Mybase()
; 956  : 		{	// construct empty deque
; 957  : 		}
; 958  : 
; 959  : 	explicit deque(const _Alloc& _Al)
; 960  : 		: _Mybase(_Al)
; 961  : 		{	// construct empty deque with allocator
; 962  : 		}
; 963  : 
; 964  : 	explicit deque(size_type _Count)
; 965  : 		: _Mybase()
; 966  : 		{	// construct from _Count * value_type()
; 967  : 		resize(_Count);
; 968  : 		}
; 969  : 
; 970  : 	deque(size_type _Count, const value_type& _Val)
; 971  : 		: _Mybase()
; 972  : 		{	// construct from _Count * _Val
; 973  : 		_Construct_n(_Count, _Val);
; 974  : 		}
; 975  : 
; 976  : 	deque(size_type _Count, const value_type& _Val, const _Alloc& _Al)
; 977  : 		: _Mybase(_Al)
; 978  : 		{	// construct from _Count * _Val with allocator
; 979  : 		_Construct_n(_Count, _Val);
; 980  : 		}
; 981  : 
; 982  : 	deque(const _Myt& _Right)
; 983  : 
; 984  :  #if _HAS_CPP0X
; 985  : 		: _Mybase(_Right._Getal().select_on_container_copy_construction())
; 986  : 
; 987  :  #else /* _HAS_CPP0X */
; 988  : 		: _Mybase(_Right._Getal())
; 989  :  #endif /* _HAS_CPP0X */
; 990  : 
; 991  : 		{	// construct by copying _Right
; 992  : 		_TRY_BEGIN
; 993  : 		insert(begin(), _Right.begin(), _Right.end());
; 994  : 		_CATCH_ALL
; 995  : 		_Tidy();
; 996  : 		_RERAISE;
; 997  : 		_CATCH_END
; 998  : 		}
; 999  : 
; 1000 : 	deque(const _Myt& _Right, const _Alloc& _Al)
; 1001 : 		: _Mybase(_Al)
; 1002 : 		{	// construct by copying _Right
; 1003 : 		_TRY_BEGIN
; 1004 : 		insert(begin(), _Right.begin(), _Right.end());
; 1005 : 		_CATCH_ALL
; 1006 : 		_Tidy();
; 1007 : 		_RERAISE;
; 1008 : 		_CATCH_END
; 1009 : 		}
; 1010 : 
; 1011 : 	template<class _Iter>
; 1012 : 		deque(_Iter _First, _Iter _Last,
; 1013 : 			typename enable_if<_Is_iterator<_Iter>::value,
; 1014 : 				void>::type ** = 0)
; 1015 : 		: _Mybase()
; 1016 : 		{	// construct from [_First, _Last)
; 1017 : 		_Construct(_First, _Last);
; 1018 : 		}
; 1019 : 
; 1020 : 	template<class _Iter>
; 1021 : 		deque(_Iter _First, _Iter _Last, const _Alloc& _Al,
; 1022 : 			typename enable_if<_Is_iterator<_Iter>::value,
; 1023 : 				void>::type ** = 0)
; 1024 : 		: _Mybase(_Al)
; 1025 : 		{	// construct from [_First, _Last) with allocator
; 1026 : 		_Construct(_First, _Last);
; 1027 : 		}
; 1028 : 
; 1029 : 	template<class _Iter>
; 1030 : 		void _Construct(_Iter _First, _Iter _Last)
; 1031 : 		{	// initialize from [_First, _Last), input iterators
; 1032 : 		_TRY_BEGIN
; 1033 : 		insert(begin(), _First, _Last);
; 1034 : 		_CATCH_ALL
; 1035 : 		_Tidy();
; 1036 : 		_RERAISE;
; 1037 : 		_CATCH_END
; 1038 : 		}
; 1039 : 
; 1040 : 	void _Construct_n(size_type _Count, const value_type& _Val)
; 1041 : 		{	// construct from _Count * _Val
; 1042 : 		_TRY_BEGIN
; 1043 : 		_Insert_n(begin(), _Count, _Val);
; 1044 : 		_CATCH_ALL
; 1045 : 		_Tidy();
; 1046 : 		_RERAISE;
; 1047 : 		_CATCH_END
; 1048 : 		}
; 1049 : 
; 1050 : #define _PUSH_FRONT_BEGIN \
; 1051 : 	if (this->_Myoff % _DEQUESIZ == 0 \
; 1052 : 		&& this->_Mapsize <= (this->_Mysize + _DEQUESIZ) / _DEQUESIZ) \
; 1053 : 		_Growmap(1); \
; 1054 : 	this->_Myoff &= this->_Mapsize * _DEQUESIZ - 1; \
; 1055 : 	size_type _Newoff = this->_Myoff != 0 ? this->_Myoff \
; 1056 : 		: this->_Mapsize * _DEQUESIZ; \
; 1057 : 	size_type _Block = this->_Getblock(--_Newoff); \
; 1058 : 	if (this->_Map[_Block] == pointer()) \
; 1059 : 		this->_Map[_Block] = this->_Getal().allocate(_DEQUESIZ)
; 1060 : 
; 1061 : #define _PUSH_FRONT_END \
; 1062 : 	this->_Myoff = _Newoff; \
; 1063 : 	++this->_Mysize
; 1064 : 
; 1065 : #define _PUSH_BACK_BEGIN \
; 1066 : 	if ((this->_Myoff + this->_Mysize) % _DEQUESIZ == 0 \
; 1067 : 		&& this->_Mapsize <= (this->_Mysize + _DEQUESIZ) / _DEQUESIZ) \
; 1068 : 		_Growmap(1); \
; 1069 : 	this->_Myoff &= this->_Mapsize * _DEQUESIZ - 1; \
; 1070 : 	size_type _Newoff = this->_Myoff + this->_Mysize; \
; 1071 : 	size_type _Block = this->_Getblock(_Newoff); \
; 1072 : 	if (this->_Map[_Block] == pointer()) \
; 1073 : 		this->_Map[_Block] = this->_Getal().allocate(_DEQUESIZ)
; 1074 : 
; 1075 : #define _PUSH_BACK_END \
; 1076 : 	++this->_Mysize
; 1077 : 
; 1078 : 	deque(_Myt&& _Right)
; 1079 : 		: _Mybase(_Right._Getal())
; 1080 : 		{	// construct by moving _Right
; 1081 : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 1082 : 		}
; 1083 : 
; 1084 : 	deque(_Myt&& _Right, const _Alloc& _Al)
; 1085 : 		: _Mybase(_Al)
; 1086 : 		{	// construct by moving _Right
; 1087 : 		if (this->_Getal() != _Right._Getal())
; 1088 : 			assign(_STD make_move_iterator(_Right.begin()),
; 1089 : 				_STD make_move_iterator(_Right.end()));
; 1090 : 		else
; 1091 : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 1092 : 		}
; 1093 : 
; 1094 : 	_Myt& operator=(_Myt&& _Right)
; 1095 : 		{	// assign by moving _Right
; 1096 : 		if (this != &_Right)
; 1097 : 			{	// different, assign it
; 1098 : 			_Tidy();
; 1099 : 
; 1100 :  #if _HAS_CPP0X
; 1101 : 			if (this->_Getal() != _Right._Getal()
; 1102 : 				&& _Alty::propagate_on_container_move_assignment::value)
; 1103 : 				this->_Change_alloc(_Right._Getal());
; 1104 :  #endif /* _HAS_CPP0X */
; 1105 : 
; 1106 : 			if (this->_Getal() != _Right._Getal())
; 1107 : 				assign(_STD make_move_iterator(_Right.begin()),
; 1108 : 					_STD make_move_iterator(_Right.end()));
; 1109 : 			else
; 1110 : 				_Assign_rv(_STD forward<_Myt>(_Right));
; 1111 : 			}
; 1112 : 		return (*this);
; 1113 : 		}
; 1114 : 
; 1115 : 	void _Assign_rv(_Myt&& _Right)
; 1116 : 		{	// assign by moving _Right
; 1117 : 		if (this == &_Right)
; 1118 : 			;
; 1119 : 		else if (get_allocator() != _Right.get_allocator())
; 1120 : 			{	// move construct a copy
; 1121 : 			clear();
; 1122 : 			for (iterator _Next = _Right.begin(); _Next != _Right.end();
; 1123 : 				++_Next)
; 1124 : 				push_back(_STD forward<value_type>(*_Next));
; 1125 : 			}
; 1126 : 		else
; 1127 : 			{	// clear this and steal from _Right
; 1128 : 			this->_Swap_all((_Myt&)_Right);
; 1129 : 			this->_Map = _Right._Map;
; 1130 : 			this->_Mapsize = _Right._Mapsize;
; 1131 : 			this->_Myoff = _Right._Myoff;
; 1132 : 			this->_Mysize = _Right._Mysize;
; 1133 : 
; 1134 : 			_Right._Map = _Mapptr();
; 1135 : 			_Right._Mapsize = 0;
; 1136 : 			_Right._Myoff = 0;
; 1137 : 			_Right._Mysize = 0;
; 1138 : 			}
; 1139 : 		}
; 1140 : 
; 1141 : 	void push_front(value_type&& _Val)
; 1142 : 		{	// insert element at beginning
; 1143 : 		this->_Orphan_all();
; 1144 : 		_PUSH_FRONT_BEGIN;
; 1145 : 		this->_Getal().construct(
; 1146 : 			this->_Map[_Block] + _Newoff % _DEQUESIZ,
; 1147 : 			_STD forward<value_type>(_Val));
; 1148 : 		_PUSH_FRONT_END;
; 1149 : 		}
; 1150 : 
; 1151 : 	void push_back(value_type&& _Val)
; 1152 : 		{	// insert element at end
; 1153 : 		this->_Orphan_all();
; 1154 : 		_PUSH_BACK_BEGIN;
; 1155 : 		this->_Getal().construct(
; 1156 : 			this->_Map[_Block] + _Newoff % _DEQUESIZ,
; 1157 : 			_STD forward<value_type>(_Val));
; 1158 : 		_PUSH_BACK_END;
; 1159 : 		}
; 1160 : 
; 1161 : 	iterator insert(const_iterator _Where, _Ty&& _Val)
; 1162 : 		{	// insert _Val at _Where
; 1163 : 		return (emplace(_Where, _STD move(_Val)));
; 1164 : 		}
; 1165 : 
; 1166 : #define _DEQUE_EMPLACE( \
; 1167 : 	TEMPLATE_LIST, PADDING_LIST, LIST, COMMA, X1, X2, X3, X4) \
; 1168 : 	TEMPLATE_LIST(_CLASS_TYPE) \
; 1169 : 		void emplace_front(LIST(_TYPE_REFREF_ARG)) \
; 1170 : 		{	/* insert element at beginning */ \
; 1171 : 		this->_Orphan_all(); \
; 1172 : 		_PUSH_FRONT_BEGIN; \
; 1173 : 		this->_Getal().construct( \
; 1174 : 			this->_Map[_Block] + _Newoff % _DEQUESIZ \
; 1175 : 				COMMA LIST(_FORWARD_ARG)); \
; 1176 : 		_PUSH_FRONT_END; \
; 1177 : 	} \
; 1178 : 	TEMPLATE_LIST(_CLASS_TYPE) \
; 1179 : 		void emplace_back(LIST(_TYPE_REFREF_ARG)) \
; 1180 : 		{	/* insert element at end */ \
; 1181 : 		this->_Orphan_all(); \
; 1182 : 		_PUSH_BACK_BEGIN; \
; 1183 : 		this->_Getal().construct( \
; 1184 : 			this->_Map[_Block] + _Newoff % _DEQUESIZ \
; 1185 : 				COMMA LIST(_FORWARD_ARG)); \
; 1186 : 		_PUSH_BACK_END; \
; 1187 : 		} \
; 1188 : 	TEMPLATE_LIST(_CLASS_TYPE) \
; 1189 : 		iterator emplace(const_iterator _Where \
; 1190 : 			COMMA LIST(_TYPE_REFREF_ARG)) \
; 1191 : 		{	/* insert element at _Where */ \
; 1192 : 		size_type _Off = _Where - begin(); \
; 1193 : 		_DEQUE_EMPLACE_CHECK \
; 1194 : 		if (_Off <= this->_Mysize / 2) \
; 1195 : 			{	/* closer to front, push to front then rotate */ \
; 1196 : 			emplace_front(LIST(_FORWARD_ARG)); \
; 1197 : 			_STD rotate(begin(), begin() + 1, begin() + 1 + _Off); \
; 1198 : 			} \
; 1199 : 		else \
; 1200 : 			{	/* closer to back, push to back then rotate */ \
; 1201 : 			emplace_back(LIST(_FORWARD_ARG)); \
; 1202 : 			_STD rotate(begin() + _Off, end() - 1, end()); \
; 1203 : 			} \
; 1204 : 		return (begin() + _Off); \
; 1205 : 			}
; 1206 : 
; 1207 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1208 : #define _DEQUE_EMPLACE_CHECK \
; 1209 : 		if (this->_Mysize < _Off) \
; 1210 : 			_DEBUG_ERROR("deque emplace iterator outside range");
; 1211 : 
; 1212 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1213 : #define _DEQUE_EMPLACE_CHECK
; 1214 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1215 : 
; 1216 : _VARIADIC_EXPAND_0X(_DEQUE_EMPLACE, , , , )
; 1217 : #undef _DEQUE_EMPLACE_CHECK
; 1218 : #undef _DEQUE_EMPLACE
; 1219 : 
; 1220 : 	~deque() _NOEXCEPT
; 1221 : 		{	// destroy the deque
; 1222 : 		_Tidy();
; 1223 : 		}
; 1224 : 
; 1225 : 	_Myt& operator=(const _Myt& _Right)
; 1226 : 		{	// assign _Right
; 1227 : 		if (this != &_Right)
; 1228 : 			{	// different, assign it
; 1229 :  #if _HAS_CPP0X
; 1230 : 			if (this->_Getal() != _Right._Getal()
; 1231 : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 1232 : 				{	// change allocator before copying
; 1233 : 				_Tidy();
; 1234 : 				this->_Change_alloc(_Right._Getal());
; 1235 : 				}
; 1236 :  #endif /* _HAS_CPP0X */
; 1237 : 
; 1238 : 			this->_Orphan_all();
; 1239 : 
; 1240 : 			if (_Right._Mysize == 0)
; 1241 : 				clear();
; 1242 : 			else if (_Right._Mysize <= this->_Mysize)
; 1243 : 				{	// enough elements, copy new and destroy old
; 1244 : 				iterator _Mid = _STD copy(_Right.begin(), _Right.end(),
; 1245 : 					begin());
; 1246 : 				erase(_Mid, end());
; 1247 : 				}
; 1248 : 			else
; 1249 : 				{	// new sequence longer, copy and construct new
; 1250 : 				const_iterator _Mid = _Right.begin() + this->_Mysize;
; 1251 : 				_STD copy(_Right.begin(), _Mid, begin());
; 1252 : 				insert(end(), _Mid, _Right.end());
; 1253 : 				}
; 1254 : 			}
; 1255 : 		return (*this);
; 1256 : 		}
; 1257 : 
; 1258 : 	iterator begin() _NOEXCEPT
; 1259 : 		{	// return iterator for beginning of mutable sequence
; 1260 : 		return (iterator(this->_Myoff, this));
; 1261 : 		}
; 1262 : 
; 1263 : 	const_iterator begin() const _NOEXCEPT
; 1264 : 		{	// return iterator for beginning of nonmutable sequence
; 1265 : 		return (const_iterator(this->_Myoff, this));
; 1266 : 		}
; 1267 : 
; 1268 : 	iterator end() _NOEXCEPT
; 1269 : 		{	// return iterator for end of mutable sequence
; 1270 : 		return (iterator(this->_Myoff + this->_Mysize, this));
; 1271 : 		}
; 1272 : 
; 1273 : 	const_iterator end() const _NOEXCEPT
; 1274 : 		{	// return iterator for end of nonmutable sequence
; 1275 : 		return (const_iterator(this->_Myoff + this->_Mysize, this));
; 1276 : 		}
; 1277 : 
; 1278 : 	iterator _Make_iter(const_iterator _Where) const
; 1279 : 		{	// make iterator from const_iterator
; 1280 : 		return (iterator(_Where._Myoff, this));
; 1281 : 		}
; 1282 : 
; 1283 : 	reverse_iterator rbegin() _NOEXCEPT
; 1284 : 		{	// return iterator for beginning of reversed mutable sequence
; 1285 : 		return (reverse_iterator(end()));
; 1286 : 		}
; 1287 : 
; 1288 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1289 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1290 : 		return (const_reverse_iterator(end()));
; 1291 : 		}
; 1292 : 
; 1293 : 	reverse_iterator rend() _NOEXCEPT
; 1294 : 		{	// return iterator for end of reversed mutable sequence
; 1295 : 		return (reverse_iterator(begin()));
; 1296 : 		}
; 1297 : 
; 1298 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1299 : 		{	// return iterator for end of reversed nonmutable sequence
; 1300 : 		return (const_reverse_iterator(begin()));
; 1301 : 		}
; 1302 : 
; 1303 :  #if _HAS_CPP0X
; 1304 : 	const_iterator cbegin() const _NOEXCEPT
; 1305 : 		{	// return iterator for beginning of nonmutable sequence
; 1306 : 		return (((const _Myt *)this)->begin());
; 1307 : 		}
; 1308 : 
; 1309 : 	const_iterator cend() const _NOEXCEPT
; 1310 : 		{	// return iterator for end of nonmutable sequence
; 1311 : 		return (((const _Myt *)this)->end());
; 1312 : 		}
; 1313 : 
; 1314 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1315 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1316 : 		return (((const _Myt *)this)->rbegin());
; 1317 : 		}
; 1318 : 
; 1319 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1320 : 		{	// return iterator for end of reversed nonmutable sequence
; 1321 : 		return (((const _Myt *)this)->rend());
; 1322 : 		}
; 1323 : 
; 1324 : 	void shrink_to_fit()
; 1325 : 		{	// reduce capacity
; 1326 : 		size_type _Oldcapacity = _DEQUESIZ * this->_Mapsize;
; 1327 : 		size_type _Newcapacity = _Oldcapacity / 2;
; 1328 : 
; 1329 : 		if (_Newcapacity < _DEQUESIZ * _DEQUEMAPSIZ)
; 1330 : 			_Newcapacity = _DEQUESIZ * _DEQUEMAPSIZ;
; 1331 : 
; 1332 : 		if ((empty() && 0 < this->_Mapsize)
; 1333 : 			|| (!empty()
; 1334 : 				&& size() <= _Newcapacity
; 1335 : 				&& _Newcapacity < _Oldcapacity))
; 1336 : 			{	// worth shrinking, do it
; 1337 : 			_Myt _Tmp(_STD make_move_iterator(begin()),
; 1338 : 				_STD make_move_iterator(end()));
; 1339 : 			swap(_Tmp);
; 1340 : 			}
; 1341 : 		}
; 1342 :  #endif /* _HAS_CPP0X */
; 1343 : 
; 1344 : 	void resize(size_type _Newsize)
; 1345 : 		{	// determine new length, padding as needed
; 1346 : 		if (_Newsize < this->_Mysize)
; 1347 : 			erase(begin() + _Newsize, end());
; 1348 : 		else if (this->_Mysize < _Newsize)
; 1349 : 			{	// append default-constructed elements
; 1350 : 			_Alty _Alval(this->_Getal());
; 1351 : 			this->_Orphan_all();
; 1352 : 			while (this->_Mysize < _Newsize)
; 1353 : 				{	// push_back default-constructed element
; 1354 : 				_PUSH_BACK_BEGIN;
; 1355 : 				_Uninitialized_default_fill_n(
; 1356 : 					this->_Map[_Block] + _Newoff % _DEQUESIZ, 1, _Alval);
; 1357 : 				_PUSH_BACK_END;
; 1358 : 				}
; 1359 : 			}
; 1360 : 		}
; 1361 : 
; 1362 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1363 : 		{	// determine new length, padding with _Val elements as needed
; 1364 : 		if (this->_Mysize < _Newsize)
; 1365 : 			_Insert_n(end(), _Newsize - this->_Mysize, _Val);
; 1366 : 		else if (_Newsize < this->_Mysize)
; 1367 : 			erase(begin() + _Newsize, end());
; 1368 : 		}
; 1369 : 
; 1370 : 	size_type size() const _NOEXCEPT
; 1371 : 		{	// return length of sequence
; 1372 : 		return (this->_Mysize);
; 1373 : 		}
; 1374 : 
; 1375 : 	size_type max_size() const _NOEXCEPT
; 1376 : 		{	// return maximum possible length of sequence
; 1377 : 		return (this->_Getal().max_size());
; 1378 : 		}
; 1379 : 
; 1380 : 	bool empty() const _NOEXCEPT
; 1381 : 		{	// test if sequence is empty
; 1382 : 		return (this->_Mysize == 0);

  00003	83 7f 10 00	 cmp	 DWORD PTR [edi+16], 0

; 1455 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1456 : 		if (empty())
; 1457 : 			_DEBUG_ERROR("deque empty before pop");
; 1458 : 		else
; 1459 : 			{	// something to erase, do it
; 1460 : 			_Orphan_off(this->_Myoff);
; 1461 : 			size_type _Block = this->_Getblock(this->_Myoff);
; 1462 : 			this->_Getal().destroy(
; 1463 : 				this->_Map[_Block] + this->_Myoff % _DEQUESIZ);
; 1464 : 			if (--this->_Mysize == 0)
; 1465 : 				this->_Myoff = 0;
; 1466 : 			else
; 1467 : 				++this->_Myoff;
; 1468 : 			}
; 1469 : 
; 1470 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1471 : 		if (!empty())

  00007	74 58		 je	 SHORT $LN1@pop_front

; 787  : 		return ((_Off / _DEQUESIZ) & (this->_Mapsize - 1));

  00009	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  0000c	56		 push	 esi
  0000d	8b 77 0c	 mov	 esi, DWORD PTR [edi+12]
  00010	8b d6		 mov	 edx, esi
  00012	48		 dec	 eax
  00013	d1 ea		 shr	 edx, 1
  00015	23 d0		 and	 edx, eax

; 1472 : 			{	// something to erase, do it
; 1473 : 			size_type _Block = this->_Getblock(this->_Myoff);
; 1474 : 			this->_Getal().destroy(
; 1475 : 				this->_Map[_Block] + this->_Myoff % _DEQUESIZ);

  00017	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0001a	83 e6 01	 and	 esi, 1
  0001d	8b 04 90	 mov	 eax, DWORD PTR [eax+edx*4]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  00020	8b 74 f0 04	 mov	 esi, DWORD PTR [eax+esi*8+4]
  00024	85 f6		 test	 esi, esi
  00026	74 27		 je	 SHORT $LN29@pop_front
  00028	53		 push	 ebx

; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  00029	83 cb ff	 or	 ebx, -1
  0002c	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  0002f	8b c3		 mov	 eax, ebx
  00031	f0 0f c1 01	 lock	  xadd	 DWORD PTR [ecx], eax
  00035	75 17		 jne	 SHORT $LN32@pop_front

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  00037	8b 06		 mov	 eax, DWORD PTR [esi]
  00039	8b ce		 mov	 ecx, esi
  0003b	ff 10		 call	 DWORD PTR [eax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  0003d	8d 46 08	 lea	 eax, DWORD PTR [esi+8]
  00040	f0 0f c1 18	 lock	  xadd	 DWORD PTR [eax], ebx
  00044	4b		 dec	 ebx
  00045	75 07		 jne	 SHORT $LN32@pop_front

; 128  : 			_Delete_this();

  00047	8b 06		 mov	 eax, DWORD PTR [esi]
  00049	8b ce		 mov	 ecx, esi
  0004b	ff 50 04	 call	 DWORD PTR [eax+4]
$LN32@pop_front:
  0004e	5b		 pop	 ebx
$LN29@pop_front:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 1476 : 			if (--this->_Mysize == 0)

  0004f	ff 4f 10	 dec	 DWORD PTR [edi+16]
  00052	5e		 pop	 esi
  00053	75 09		 jne	 SHORT $LN2@pop_front

; 1477 : 				this->_Myoff = 0;

  00055	c7 47 0c 00 00
	00 00		 mov	 DWORD PTR [edi+12], 0
  0005c	5f		 pop	 edi

; 1480 : 			}
; 1481 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1482 : 		}

  0005d	c3		 ret	 0
$LN2@pop_front:

; 1478 : 			else
; 1479 : 				++this->_Myoff;

  0005e	ff 47 0c	 inc	 DWORD PTR [edi+12]
$LN1@pop_front:
  00061	5f		 pop	 edi

; 1480 : 			}
; 1481 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1482 : 		}

  00062	c3		 ret	 0
?pop_front@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QAEXXZ ENDP ; std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::pop_front
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
;	COMDAT ?push_back@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QAEXABV?$shared_ptr@VChunkBase@@@2@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?push_back@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QAEXABV?$shared_ptr@VChunkBase@@@2@@Z PROC ; std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::push_back, COMDAT
; _this$ = ecx

; 1485 : 		{	// insert element at end

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 1487 : 		_PUSH_BACK_BEGIN;

  00006	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  00009	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  0000c	03 c1		 add	 eax, ecx
  0000e	a8 01		 test	 al, 1
  00010	75 12		 jne	 SHORT $LN2@push_back
  00012	8d 41 02	 lea	 eax, DWORD PTR [ecx+2]
  00015	d1 e8		 shr	 eax, 1
  00017	39 46 08	 cmp	 DWORD PTR [esi+8], eax
  0001a	77 08		 ja	 SHORT $LN2@push_back
  0001c	51		 push	 ecx
  0001d	8b ce		 mov	 ecx, esi
  0001f	e8 00 00 00 00	 call	 ?_Growmap@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IAEXI@Z ; std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::_Growmap
$LN2@push_back:
  00024	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00027	53		 push	 ebx
  00028	8d 04 4d ff ff
	ff ff		 lea	 eax, DWORD PTR [ecx*2-1]
  0002f	21 46 0c	 and	 DWORD PTR [esi+12], eax
  00032	57		 push	 edi
  00033	8b 7e 10	 mov	 edi, DWORD PTR [esi+16]
  00036	03 7e 0c	 add	 edi, DWORD PTR [esi+12]

; 787  : 		return ((_Off / _DEQUESIZ) & (this->_Mapsize - 1));

  00039	49		 dec	 ecx
  0003a	8b c7		 mov	 eax, edi
  0003c	d1 e8		 shr	 eax, 1
  0003e	23 c8		 and	 ecx, eax

; 1487 : 		_PUSH_BACK_BEGIN;

  00040	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00043	8d 1c 8d 00 00
	00 00		 lea	 ebx, DWORD PTR [ecx*4]
  0004a	83 3c 03 00	 cmp	 DWORD PTR [ebx+eax], 0
  0004e	75 16		 jne	 SHORT $LN1@push_back
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  00050	6a 10		 push	 16			; 00000010H
  00052	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00057	8b c8		 mov	 ecx, eax
  00059	83 c4 04	 add	 esp, 4
  0005c	85 c9		 test	 ecx, ecx
  0005e	74 28		 je	 SHORT $LN41@push_back
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 1487 : 		_PUSH_BACK_BEGIN;

  00060	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00063	89 0c 03	 mov	 DWORD PTR [ebx+eax], ecx
$LN1@push_back:

; 1488 : 		this->_Getal().construct(
; 1489 : 			this->_Map[_Block] + _Newoff % _DEQUESIZ, _Val);

  00066	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00069	83 e7 01	 and	 edi, 1
  0006c	8b 04 18	 mov	 eax, DWORD PTR [eax+ebx]
  0006f	8d 0c f8	 lea	 ecx, DWORD PTR [eax+edi*8]
  00072	5f		 pop	 edi
  00073	5b		 pop	 ebx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 606  : 		::new ((void *)_Ptr) _Ty(_Val);

  00074	85 c9		 test	 ecx, ecx
  00076	74 08		 je	 SHORT $LN36@push_back
  00078	ff 75 08	 push	 DWORD PTR __Val$[ebp]
  0007b	e8 00 00 00 00	 call	 ??0?$shared_ptr@VChunkBase@@@std@@QAE@ABV01@@Z ; std::shared_ptr<ChunkBase>::shared_ptr<ChunkBase>
$LN36@push_back:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 1490 : 		_PUSH_BACK_END;

  00080	ff 46 10	 inc	 DWORD PTR [esi+16]
  00083	5e		 pop	 esi

; 1491 : 		}

  00084	5d		 pop	 ebp
  00085	c2 04 00	 ret	 4
$LN41@push_back:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 29   : 		_Xbad_alloc();	// report no memory

  00088	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN43@push_back:
$LN40@push_back:
  0008d	cc		 int	 3
?push_back@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QAEXABV?$shared_ptr@VChunkBase@@@2@@Z ENDP ; std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::push_back
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ??0?$_Ptr_base@VChunkBase@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Ptr_base@VChunkBase@@@std@@QAE@XZ PROC		; std::_Ptr_base<ChunkBase>::_Ptr_base<ChunkBase>, COMDAT
; _this$ = ecx

; 282  : 		{	// construct

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  00006	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 283  : 		}

  0000d	8b c1		 mov	 eax, ecx
  0000f	c3		 ret	 0
??0?$_Ptr_base@VChunkBase@@@std@@QAE@XZ ENDP		; std::_Ptr_base<ChunkBase>::_Ptr_base<ChunkBase>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ?_Get@?$_Ptr_base@VChunkBase@@@std@@QBEPAVChunkBase@@XZ
_TEXT	SEGMENT
?_Get@?$_Ptr_base@VChunkBase@@@std@@QBEPAVChunkBase@@XZ PROC ; std::_Ptr_base<ChunkBase>::_Get, COMDAT
; _this$ = ecx

; 335  : 		return (_Ptr);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 336  : 		}

  00002	c3		 ret	 0
?_Get@?$_Ptr_base@VChunkBase@@@std@@QBEPAVChunkBase@@XZ ENDP ; std::_Ptr_base<ChunkBase>::_Get
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ?_Decref@?$_Ptr_base@VChunkBase@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Decref@?$_Ptr_base@VChunkBase@@@std@@QAEXXZ PROC	; std::_Ptr_base<ChunkBase>::_Decref, COMDAT
; _this$ = ecx

; 344  : 		{	// decrement reference count

  00000	56		 push	 esi

; 345  : 		if (_Rep != 0)

  00001	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  00004	85 f6		 test	 esi, esi
  00006	74 29		 je	 SHORT $LN7@Decref
  00008	57		 push	 edi

; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  00009	83 cf ff	 or	 edi, -1
  0000c	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  0000f	8b c7		 mov	 eax, edi
  00011	f0 0f c1 01	 lock	  xadd	 DWORD PTR [ecx], eax
  00015	75 19		 jne	 SHORT $LN10@Decref

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  00017	8b 06		 mov	 eax, DWORD PTR [esi]
  00019	8b ce		 mov	 ecx, esi
  0001b	ff 10		 call	 DWORD PTR [eax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  0001d	8d 46 08	 lea	 eax, DWORD PTR [esi+8]
  00020	f0 0f c1 38	 lock	  xadd	 DWORD PTR [eax], edi
  00024	4f		 dec	 edi
  00025	75 09		 jne	 SHORT $LN10@Decref

; 128  : 			_Delete_this();

  00027	8b 06		 mov	 eax, DWORD PTR [esi]
  00029	5f		 pop	 edi
  0002a	8b ce		 mov	 ecx, esi
  0002c	5e		 pop	 esi
  0002d	ff 60 04	 jmp	 DWORD PTR [eax+4]
$LN10@Decref:
  00030	5f		 pop	 edi
$LN7@Decref:
  00031	5e		 pop	 esi

; 346  : 			_Rep->_Decref();
; 347  : 		}

  00032	c3		 ret	 0
?_Decref@?$_Ptr_base@VChunkBase@@@std@@QAEXXZ ENDP	; std::_Ptr_base<ChunkBase>::_Decref
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<std::shared_ptr<ChunkBase> > > >::~_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<std::shared_ptr<ChunkBase> > > >, COMDAT
; _this$dead$ = ecx
  00000	c3		 ret	 0
??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<std::shared_ptr<ChunkBase> > > >::~_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<std::shared_ptr<ChunkBase> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<std::shared_ptr<ChunkBase> > > >::~_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<std::shared_ptr<ChunkBase> > > >, COMDAT
; _this$dead$ = ecx
  00000	c3		 ret	 0
??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<std::shared_ptr<ChunkBase> > > >::~_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<std::shared_ptr<ChunkBase> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ??0?$_Ptr_base@VVertexStream@gfxu@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Ptr_base@VVertexStream@gfxu@@@std@@QAE@XZ PROC	; std::_Ptr_base<gfxu::VertexStream>::_Ptr_base<gfxu::VertexStream>, COMDAT
; _this$ = ecx

; 282  : 		{	// construct

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  00006	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 283  : 		}

  0000d	8b c1		 mov	 eax, ecx
  0000f	c3		 ret	 0
??0?$_Ptr_base@VVertexStream@gfxu@@@std@@QAE@XZ ENDP	; std::_Ptr_base<gfxu::VertexStream>::_Ptr_base<gfxu::VertexStream>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ?_Swap@?$_Ptr_base@VVertexStream@gfxu@@@std@@QAEXAAV12@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
?_Swap@?$_Ptr_base@VVertexStream@gfxu@@@std@@QAEXAAV12@@Z PROC ; std::_Ptr_base<gfxu::VertexStream>::_Swap, COMDAT
; _this$ = ecx

; 317  : 		{	// swap pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility

; 47   : 	_Ty _Tmp = _Move(_Left);

  00003	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00006	56		 push	 esi
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 318  : 		_STD swap(_Rep, _Right._Rep);

  00007	8b 75 08	 mov	 esi, DWORD PTR __Right$[ebp]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility

; 48   : 	_Left = _Move(_Right);

  0000a	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0000d	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 49   : 	_Right = _Move(_Tmp);

  00010	89 56 04	 mov	 DWORD PTR [esi+4], edx

; 48   : 	_Left = _Move(_Right);

  00013	8b 06		 mov	 eax, DWORD PTR [esi]
  00015	8b 11		 mov	 edx, DWORD PTR [ecx]
  00017	89 01		 mov	 DWORD PTR [ecx], eax

; 49   : 	_Right = _Move(_Tmp);

  00019	89 16		 mov	 DWORD PTR [esi], edx
  0001b	5e		 pop	 esi
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 320  : 		}

  0001c	5d		 pop	 ebp
  0001d	c2 04 00	 ret	 4
?_Swap@?$_Ptr_base@VVertexStream@gfxu@@@std@@QAEXAAV12@@Z ENDP ; std::_Ptr_base<gfxu::VertexStream>::_Swap
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
;	COMDAT ?begin@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@2@XZ PROC ; std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::begin, COMDAT
; _this$ = ecx

; 1259 : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility

; 113  : 		{	// construct orphaned iterator

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 1260 : 		return (iterator(this->_Myoff, this));

  00006	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility

; 166  : 			_Myproxy = _Parent_proxy;

  00009	8b 09		 mov	 ecx, DWORD PTR [ecx]

; 113  : 		{	// construct orphaned iterator

  0000b	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 166  : 			_Myproxy = _Parent_proxy;

  00012	89 08		 mov	 DWORD PTR [eax], ecx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 306  : 		_Myoff = _Off;

  00014	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 1261 : 		}

  00017	5d		 pop	 ebp
  00018	c2 04 00	 ret	 4
?begin@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@2@XZ ENDP ; std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::begin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
;	COMDAT ?empty@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QBE_NXZ
_TEXT	SEGMENT
?empty@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QBE_NXZ PROC ; std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::empty, COMDAT
; _this$ = ecx

; 1382 : 		return (this->_Mysize == 0);

  00000	33 c0		 xor	 eax, eax
  00002	39 41 10	 cmp	 DWORD PTR [ecx+16], eax
  00005	0f 94 c0	 sete	 al

; 1383 : 		}

  00008	c3		 ret	 0
?empty@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QBE_NXZ ENDP ; std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::empty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
;	COMDAT ?_Growmap@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IAEXI@Z
_TEXT	SEGMENT
tv523 = -16						; size = 4
__Myptr$1$ = -12					; size = 4
__Myboff$1$ = -8					; size = 4
__Ptr$1$ = -4						; size = 4
__Count$dead$ = 8					; size = 4
?_Growmap@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IAEXI@Z PROC ; std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::_Growmap, COMDAT
; _this$ = ecx

; 1802 : 		{	// grow map by at least _Count pointers, _Mapsize a power of 2

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	53		 push	 ebx
  00007	8b d9		 mov	 ebx, ecx
  00009	56		 push	 esi

; 1803 : 		static_assert(1 < _DEQUEMAPSIZ,
; 1804 : 			"The _Xlen() test should always be performed.");
; 1805 : 
; 1806 : 		typedef typename _Alpty::pointer _Blockptr;
; 1807 : 		_Alpty _Almap(this->_Getal());
; 1808 : 		size_type _Newsize = 0 < this->_Mapsize ? this->_Mapsize : 1;

  0000a	8b 53 08	 mov	 edx, DWORD PTR [ebx+8]
  0000d	be 01 00 00 00	 mov	 esi, 1
  00012	85 d2		 test	 edx, edx
  00014	0f 45 f2	 cmovne	 esi, edx
$LL7@Growmap:

; 1809 : 		while (_Newsize - this->_Mapsize < _Count || _Newsize < _DEQUEMAPSIZ)

  00017	8b c6		 mov	 eax, esi
  00019	2b c2		 sub	 eax, edx
  0001b	83 f8 01	 cmp	 eax, 1
  0001e	72 05		 jb	 SHORT $LN5@Growmap
  00020	83 fe 08	 cmp	 esi, 8
  00023	73 13		 jae	 SHORT $LN6@Growmap
$LN5@Growmap:

; 1810 : 			{	// scale _Newsize to 2^N >= _Mapsize + _Count
; 1811 : 			if (max_size() / _DEQUESIZ - _Newsize < _Newsize)

  00025	b8 ff ff ff 0f	 mov	 eax, 268435455		; 0fffffffH
  0002a	2b c6		 sub	 eax, esi
  0002c	3b c6		 cmp	 eax, esi
  0002e	0f 82 32 01 00
	00		 jb	 $LN111@Growmap

; 1812 : 				_Xlen();	// result too long
; 1813 : 			_Newsize *= 2;

  00034	03 f6		 add	 esi, esi

; 1814 : 			}

  00036	eb df		 jmp	 SHORT $LL7@Growmap
$LN6@Growmap:

; 1815 : 		_Count = _Newsize - this->_Mapsize;

  00038	2b f2		 sub	 esi, edx
  0003a	57		 push	 edi

; 1816 : 
; 1817 : 		size_type _Myboff = this->_Myoff / _DEQUESIZ;

  0003b	8b 7b 0c	 mov	 edi, DWORD PTR [ebx+12]
  0003e	d1 ef		 shr	 edi, 1

; 1818 : 		_Mapptr _Newmap = _Almap.allocate(this->_Mapsize + _Count);

  00040	8d 04 32	 lea	 eax, DWORD PTR [edx+esi]
  00043	89 7d f8	 mov	 DWORD PTR __Myboff$1$[ebp], edi
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 23   : 	void *_Ptr = 0;

  00046	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __Ptr$1$[ebp], 0

; 24   : 
; 25   : 	if (_Count == 0)

  0004d	85 c0		 test	 eax, eax
  0004f	74 22		 je	 SHORT $LN32@Growmap

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  00051	3d ff ff ff 3f	 cmp	 eax, 1073741823		; 3fffffffH
  00056	0f 87 05 01 00
	00		 ja	 $LN130@Growmap
  0005c	c1 e0 02	 shl	 eax, 2
  0005f	50		 push	 eax
  00060	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00065	83 c4 04	 add	 esp, 4
  00068	89 45 fc	 mov	 DWORD PTR __Ptr$1$[ebp], eax
  0006b	85 c0		 test	 eax, eax
  0006d	0f 84 ee 00 00
	00		 je	 $LN130@Growmap
$LN32@Growmap:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 1823 : 			_Myptr, _Almap);	// copy initial to end

  00073	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  00076	8b 43 08	 mov	 eax, DWORD PTR [ebx+8]
  00079	c1 e0 02	 shl	 eax, 2
  0007c	8d 14 b9	 lea	 edx, DWORD PTR [ecx+edi*4]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory

; 404  : 	size_t _Count = (size_t)(_Last - _First);

  0007f	2b c2		 sub	 eax, edx
  00081	03 c1		 add	 eax, ecx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 1819 : 		_Mapptr _Myptr = _Newmap + _Myboff;

  00083	8b 4d fc	 mov	 ecx, DWORD PTR __Ptr$1$[ebp]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory

; 404  : 	size_t _Count = (size_t)(_Last - _First);

  00086	c1 f8 02	 sar	 eax, 2

; 406  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

  00089	8d 3c 85 00 00
	00 00		 lea	 edi, DWORD PTR [eax*4]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 1819 : 		_Mapptr _Myptr = _Newmap + _Myboff;

  00090	8b 45 f8	 mov	 eax, DWORD PTR __Myboff$1$[ebp]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory

; 406  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

  00093	57		 push	 edi
  00094	52		 push	 edx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 1819 : 		_Mapptr _Myptr = _Newmap + _Myboff;

  00095	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory

; 406  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

  00098	50		 push	 eax
  00099	e8 00 00 00 00	 call	 _memmove
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 1824 : 		if (_Myboff <= _Count)

  0009e	8b 4d f8	 mov	 ecx, DWORD PTR __Myboff$1$[ebp]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory

; 406  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

  000a1	83 c4 0c	 add	 esp, 12			; 0000000cH
  000a4	8d 14 07	 lea	 edx, DWORD PTR [edi+eax]
  000a7	89 55 f4	 mov	 DWORD PTR __Myptr$1$[ebp], edx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 1824 : 		if (_Myboff <= _Count)

  000aa	3b ce		 cmp	 ecx, esi
  000ac	77 43		 ja	 SHORT $LN3@Growmap

; 1828 : 				_Myptr, _Almap);	// copy rest of old

  000ae	8b 53 04	 mov	 edx, DWORD PTR [ebx+4]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory

; 404  : 	size_t _Count = (size_t)(_Last - _First);

  000b1	8d 04 8d 00 00
	00 00		 lea	 eax, DWORD PTR [ecx*4]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 1830 : 				_Almap);	// clear suffix of new

  000b8	8b fe		 mov	 edi, esi
  000ba	2b f9		 sub	 edi, ecx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory

; 404  : 	size_t _Count = (size_t)(_Last - _First);

  000bc	c1 f8 02	 sar	 eax, 2
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 1830 : 				_Almap);	// clear suffix of new

  000bf	89 7d f0	 mov	 DWORD PTR tv523[ebp], edi
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory

; 406  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

  000c2	8d 3c 85 00 00
	00 00		 lea	 edi, DWORD PTR [eax*4]
  000c9	57		 push	 edi
  000ca	52		 push	 edx
  000cb	ff 75 f4	 push	 DWORD PTR __Myptr$1$[ebp]
  000ce	e8 00 00 00 00	 call	 _memmove
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility

; 2678 : 	for (; 0 < _Count; --_Count, ++_Dest)

  000d3	8b 4d f0	 mov	 ecx, DWORD PTR tv523[ebp]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory

; 406  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

  000d6	83 c4 0c	 add	 esp, 12			; 0000000cH
  000d9	03 f8		 add	 edi, eax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility

; 2678 : 	for (; 0 < _Count; --_Count, ++_Dest)

  000db	85 c9		 test	 ecx, ecx
  000dd	74 04		 je	 SHORT $LN61@Growmap
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 1828 : 				_Myptr, _Almap);	// copy rest of old

  000df	33 c0		 xor	 eax, eax
  000e1	f3 ab		 rep stosd
$LN61@Growmap:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility

; 2678 : 	for (; 0 < _Count; --_Count, ++_Dest)

  000e3	8b 45 f8	 mov	 eax, DWORD PTR __Myboff$1$[ebp]
  000e6	85 c0		 test	 eax, eax
  000e8	74 55		 je	 SHORT $LN99@Growmap
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory

; 660  : 	_Fill_n(_First, _Count, (_Valty)0);

  000ea	8b 7d fc	 mov	 edi, DWORD PTR __Ptr$1$[ebp]
  000ed	8b c8		 mov	 ecx, eax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 1834 : 		else

  000ef	eb 4a		 jmp	 SHORT $LN129@Growmap
$LN3@Growmap:

; 1838 : 				_Myptr, _Almap);	// copy more old

  000f1	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  000f4	8d 3c b5 00 00
	00 00		 lea	 edi, DWORD PTR [esi*4]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory

; 406  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

  000fb	8b c7		 mov	 eax, edi
  000fd	83 e0 fc	 and	 eax, -4			; fffffffcH
  00100	50		 push	 eax
  00101	51		 push	 ecx
  00102	52		 push	 edx
  00103	e8 00 00 00 00	 call	 _memmove
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 1841 : 				_Newmap, _Almap);	// copy rest of old

  00108	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  0010b	8d 0c 07	 lea	 ecx, DWORD PTR [edi+eax]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory

; 404  : 	size_t _Count = (size_t)(_Last - _First);

  0010e	8b 7d f8	 mov	 edi, DWORD PTR __Myboff$1$[ebp]
  00111	8d 14 bd 00 00
	00 00		 lea	 edx, DWORD PTR [edi*4]
  00118	2b d1		 sub	 edx, ecx
  0011a	03 d0		 add	 edx, eax
  0011c	c1 fa 02	 sar	 edx, 2

; 406  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

  0011f	8d 3c 95 00 00
	00 00		 lea	 edi, DWORD PTR [edx*4]
  00126	57		 push	 edi
  00127	51		 push	 ecx
  00128	ff 75 fc	 push	 DWORD PTR __Ptr$1$[ebp]
  0012b	e8 00 00 00 00	 call	 _memmove
  00130	83 c4 18	 add	 esp, 24			; 00000018H
  00133	03 f8		 add	 edi, eax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility

; 2678 : 	for (; 0 < _Count; --_Count, ++_Dest)

  00135	85 f6		 test	 esi, esi
  00137	74 06		 je	 SHORT $LN99@Growmap
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 1838 : 				_Myptr, _Almap);	// copy more old

  00139	8b ce		 mov	 ecx, esi
$LN129@Growmap:
  0013b	33 c0		 xor	 eax, eax
  0013d	f3 ab		 rep stosd
$LN99@Growmap:

; 1842 : 			_Uninitialized_default_fill_n(_Myptr, _Count,
; 1843 : 				_Almap);	// clear rest to initial block
; 1844 : 			}
; 1845 : 
; 1846 : 		_Destroy_range(this->_Map + _Myboff, this->_Map + this->_Mapsize,
; 1847 : 			_Almap);
; 1848 : 		if (this->_Map != _Mapptr())

  0013f	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  00142	5f		 pop	 edi
  00143	85 c0		 test	 eax, eax
  00145	74 09		 je	 SHORT $LN104@Growmap
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 586  : 		::operator delete(_Ptr);

  00147	50		 push	 eax
  00148	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0014d	83 c4 04	 add	 esp, 4
$LN104@Growmap:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 1853 : 		this->_Mapsize += _Count;

  00150	01 73 08	 add	 DWORD PTR [ebx+8], esi
  00153	8b 45 fc	 mov	 eax, DWORD PTR __Ptr$1$[ebp]
  00156	5e		 pop	 esi
  00157	89 43 04	 mov	 DWORD PTR [ebx+4], eax
  0015a	5b		 pop	 ebx

; 1854 : 		}

  0015b	8b e5		 mov	 esp, ebp
  0015d	5d		 pop	 ebp
  0015e	c2 04 00	 ret	 4
$LN130@Growmap:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 29   : 		_Xbad_alloc();	// report no memory

  00161	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN132@Growmap:
$LN111@Growmap:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 1793 : 		_Xlength_error("deque<T> too long");

  00166	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@KBDMBKEH@deque?$DMT?$DO?5too?5long?$AA@
  0016b	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN133@Growmap:
$LN128@Growmap:
  00170	cc		 int	 3
?_Growmap@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IAEXI@Z ENDP ; std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::_Growmap
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
;	COMDAT ?_Getal@?$_Deque_alloc@$0A@U?$_Deque_base_types@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?_Getal@?$_Deque_alloc@$0A@U?$_Deque_base_types@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@XZ PROC ; std::_Deque_alloc<0,std::_Deque_base_types<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > > >::_Getal, COMDAT
; _this$dead$ = ecx

; 916  : 		{	// get reference to allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 917  : 		return (_Alty());

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 918  : 		}

  00006	5d		 pop	 ebp
  00007	c2 04 00	 ret	 4
?_Getal@?$_Deque_alloc@$0A@U?$_Deque_base_types@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@XZ ENDP ; std::_Deque_alloc<0,std::_Deque_base_types<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QAEPAV?$shared_ptr@VChunkBase@@@2@I@Z
_TEXT	SEGMENT
__Count$dead$ = 8					; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QAEPAV?$shared_ptr@VChunkBase@@@2@I@Z PROC ; std::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> > >::allocate, COMDAT
; _this$dead$ = ecx

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  00000	6a 10		 push	 16			; 00000010H
  00002	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00007	83 c4 04	 add	 esp, 4
  0000a	85 c0		 test	 eax, eax
  0000c	74 03		 je	 SHORT $LN15@allocate

; 876  : 		return (_Mybase::allocate(_Count));
; 877  : 		}

  0000e	c2 04 00	 ret	 4
$LN15@allocate:

; 29   : 		_Xbad_alloc();	// report no memory

  00011	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN17@allocate:
$LN14@allocate:
  00016	cc		 int	 3
?allocate@?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QAEPAV?$shared_ptr@VChunkBase@@@2@I@Z ENDP ; std::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> > >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
;	COMDAT ?_Getblock@?$_Deque_val@U?$_Deque_simple_types@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QBEII@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
?_Getblock@?$_Deque_val@U?$_Deque_simple_types@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QBEII@Z PROC ; std::_Deque_val<std::_Deque_simple_types<std::shared_ptr<ChunkBase> > >::_Getblock, COMDAT
; _this$ = ecx

; 785  : 		{	// determine block from offset

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 786  : 			// NB: _Mapsize and _DEQUESIZ are guaranteed to be powers of 2
; 787  : 		return ((_Off / _DEQUESIZ) & (this->_Mapsize - 1));

  00003	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00006	8b 4d 08	 mov	 ecx, DWORD PTR __Off$[ebp]
  00009	48		 dec	 eax
  0000a	d1 e9		 shr	 ecx, 1
  0000c	23 c1		 and	 eax, ecx

; 788  : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 04 00	 ret	 4
?_Getblock@?$_Deque_val@U?$_Deque_simple_types@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QBEII@Z ENDP ; std::_Deque_val<std::_Deque_simple_types<std::shared_ptr<ChunkBase> > >::_Getblock
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
;	COMDAT ??D?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@QBEAAV?$shared_ptr@VChunkBase@@@1@XZ
_TEXT	SEGMENT
??D?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@QBEAAV?$shared_ptr@VChunkBase@@@1@XZ PROC ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<std::shared_ptr<ChunkBase> > > >::operator*, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility

; 178  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	56		 push	 esi
  00003	85 c0		 test	 eax, eax
  00005	75 04		 jne	 SHORT $LN7@operator
  00007	33 f6		 xor	 esi, esi
  00009	eb 02		 jmp	 SHORT $LN8@operator
$LN7@operator:
  0000b	8b 30		 mov	 esi, DWORD PTR [eax]
$LN8@operator:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 787  : 		return ((_Off / _DEQUESIZ) & (this->_Mapsize - 1));

  0000d	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00010	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00013	8b ca		 mov	 ecx, edx
  00015	48		 dec	 eax
  00016	d1 e9		 shr	 ecx, 1
  00018	23 c8		 and	 ecx, eax

; 345  : 		return (_Mycont->_Map[_Block][_Off]);

  0001a	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0001d	83 e2 01	 and	 edx, 1
  00020	8b 04 88	 mov	 eax, DWORD PTR [eax+ecx*4]
  00023	5e		 pop	 esi
  00024	8d 04 d0	 lea	 eax, DWORD PTR [eax+edx*8]

; 604  : 		return ((reference)**(_Mybase *)this);
; 605  : 		}

  00027	c3		 ret	 0
??D?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@QBEAAV?$shared_ptr@VChunkBase@@@1@XZ ENDP ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<std::shared_ptr<ChunkBase> > > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
;	COMDAT ?max_size@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QBEIXZ PROC ; std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::max_size, COMDAT
; _this$dead$ = ecx

; 1377 : 		return (this->_Getal().max_size());

  00000	b8 ff ff ff 1f	 mov	 eax, 536870911		; 1fffffffH

; 1378 : 		}

  00005	c3		 ret	 0
?max_size@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QBEIXZ ENDP ; std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
;	COMDAT ?_Xlen@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IBEXXZ
_TEXT	SEGMENT
?_Xlen@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IBEXXZ PROC ; std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::_Xlen, COMDAT
; _this$dead$ = ecx

; 1793 : 		_Xlength_error("deque<T> too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@KBDMBKEH@deque?$DMT?$DO?5too?5long?$AA@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN4@Xlen:
$LN3@Xlen:
  0000a	cc		 int	 3
?_Xlen@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IBEXXZ ENDP ; std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::_Xlen
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@QAEPAV?$shared_ptr@VChunkBase@@@2@I@Z
_TEXT	SEGMENT
__Count$dead$ = 8					; size = 4
?allocate@?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@QAEPAV?$shared_ptr@VChunkBase@@@2@I@Z PROC ; std::allocator<std::shared_ptr<ChunkBase> >::allocate, COMDAT
; _this$dead$ = ecx

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  00000	6a 10		 push	 16			; 00000010H
  00002	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00007	83 c4 04	 add	 esp, 4
  0000a	85 c0		 test	 eax, eax
  0000c	74 03		 je	 SHORT $LN12@allocate

; 591  : 		return (_Allocate(_Count, (pointer)0));
; 592  : 		}

  0000e	c2 04 00	 ret	 4
$LN12@allocate:

; 29   : 		_Xbad_alloc();	// report no memory

  00011	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN14@allocate:
$LN11@allocate:
  00016	cc		 int	 3
?allocate@?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@QAEPAV?$shared_ptr@VChunkBase@@@2@I@Z ENDP ; std::allocator<std::shared_ptr<ChunkBase> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> > >::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> > >, COMDAT
; _this$ = ecx

; 831  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> > >::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@PAV?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QAEPAPAV?$shared_ptr@VChunkBase@@@2@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@PAV?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QAEPAPAV?$shared_ptr@VChunkBase@@@2@I@Z PROC ; std::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> *> >::allocate, COMDAT
; _this$dead$ = ecx

; 875  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 25   : 	if (_Count == 0)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	33 c9		 xor	 ecx, ecx
  00008	85 c0		 test	 eax, eax
  0000a	74 19		 je	 SHORT $LN6@allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0000c	3d ff ff ff 3f	 cmp	 eax, 1073741823		; 3fffffffH
  00011	77 18		 ja	 SHORT $LN14@allocate
  00013	c1 e0 02	 shl	 eax, 2
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0001c	8b c8		 mov	 ecx, eax
  0001e	83 c4 04	 add	 esp, 4
  00021	85 c9		 test	 ecx, ecx
  00023	74 06		 je	 SHORT $LN14@allocate
$LN6@allocate:

; 876  : 		return (_Mybase::allocate(_Count));

  00025	8b c1		 mov	 eax, ecx

; 877  : 		}

  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
$LN14@allocate:

; 29   : 		_Xbad_alloc();	// report no memory

  0002b	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN16@allocate:
$LN13@allocate:
  00030	cc		 int	 3
?allocate@?$_Wrap_alloc@V?$allocator@PAV?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QAEPAPAV?$shared_ptr@VChunkBase@@@2@I@Z ENDP ; std::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> *> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@PAV?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QAEXPAPAV?$shared_ptr@VChunkBase@@@2@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$dead$ = 12					; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@PAV?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QAEXPAPAV?$shared_ptr@VChunkBase@@@2@I@Z PROC ; std::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> *> >::deallocate, COMDAT
; _this$dead$ = ecx

; 886  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 586  : 		::operator delete(_Ptr);

  00003	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	83 c4 04	 add	 esp, 4

; 887  : 		_Mybase::deallocate(_Ptr, _Count);
; 888  : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 08 00	 ret	 8
?deallocate@?$_Wrap_alloc@V?$allocator@PAV?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QAEXPAPAV?$shared_ptr@VChunkBase@@@2@I@Z ENDP ; std::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> *> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
;	COMDAT ??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
__Lock$1 = 12						; size = 4
__Pdeque$ = 12						; size = 4
??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z PROC ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<std::shared_ptr<ChunkBase> > > >::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<std::shared_ptr<ChunkBase> > > >, COMDAT
; _this$ = ecx

; 586  : 		{	// construct with offset _Off in *_Pdeque

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility

; 146  : 		if (_Parent == 0)

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Pdeque$[ebp]
  00006	56		 push	 esi
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 586  : 		{	// construct with offset _Off in *_Pdeque

  00007	8b f1		 mov	 esi, ecx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility

; 113  : 		{	// construct orphaned iterator

  00009	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  0000f	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 146  : 		if (_Parent == 0)

  00016	85 c0		 test	 eax, eax
  00018	75 1f		 jne	 SHORT $LN10@Deque_iter

; 147  : 			{	// no future parent, just disown current parent
; 148  : 			_Lockit _Lock(_LOCK_DEBUG);

  0001a	6a 03		 push	 3
  0001c	8d 4d 0c	 lea	 ecx, DWORD PTR __Lock$1[ebp]
  0001f	e8 00 00 00 00	 call	 ??0_Lockit@std@@QAE@H@Z	; std::_Lockit::_Lockit

; 149  : 			_Orphan_me();
; 150  : 			}

  00024	8d 4d 0c	 lea	 ecx, DWORD PTR __Lock$1[ebp]
  00027	e8 00 00 00 00	 call	 ??1_Lockit@std@@QAE@XZ	; std::_Lockit::~_Lockit
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 306  : 		_Myoff = _Off;

  0002c	8b 45 08	 mov	 eax, DWORD PTR __Off$[ebp]
  0002f	89 46 08	 mov	 DWORD PTR [esi+8], eax

; 587  : 		}

  00032	8b c6		 mov	 eax, esi
  00034	5e		 pop	 esi
  00035	5d		 pop	 ebp
  00036	c2 08 00	 ret	 8
$LN10@Deque_iter:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility

; 166  : 			_Myproxy = _Parent_proxy;

  00039	8b 00		 mov	 eax, DWORD PTR [eax]
  0003b	89 06		 mov	 DWORD PTR [esi], eax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 306  : 		_Myoff = _Off;

  0003d	8b 45 08	 mov	 eax, DWORD PTR __Off$[ebp]
  00040	89 46 08	 mov	 DWORD PTR [esi+8], eax

; 587  : 		}

  00043	8b c6		 mov	 eax, esi
  00045	5e		 pop	 esi
  00046	5d		 pop	 ebp
  00047	c2 08 00	 ret	 8
??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z ENDP ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<std::shared_ptr<ChunkBase> > > >::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<std::shared_ptr<ChunkBase> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
;	COMDAT ??D?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@QBEABV?$shared_ptr@VChunkBase@@@1@XZ
_TEXT	SEGMENT
??D?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@QBEABV?$shared_ptr@VChunkBase@@@1@XZ PROC ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<std::shared_ptr<ChunkBase> > > >::operator*, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility

; 178  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	56		 push	 esi
  00003	85 c0		 test	 eax, eax
  00005	75 04		 jne	 SHORT $LN5@operator
  00007	33 f6		 xor	 esi, esi
  00009	eb 02		 jmp	 SHORT $LN6@operator
$LN5@operator:
  0000b	8b 30		 mov	 esi, DWORD PTR [eax]
$LN6@operator:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 787  : 		return ((_Off / _DEQUESIZ) & (this->_Mapsize - 1));

  0000d	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00010	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00013	8b ca		 mov	 ecx, edx
  00015	48		 dec	 eax
  00016	d1 e9		 shr	 ecx, 1
  00018	23 c8		 and	 ecx, eax

; 324  : 		_Mydeque *_Mycont = ((_Mydeque *)this->_Getcont());
; 325  : 
; 326  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 327  : 		if (_Mycont == 0
; 328  : 			|| this->_Myoff < _Mycont->_Myoff
; 329  : 			|| _Mycont->_Myoff + _Mycont->_Mysize <= this->_Myoff)
; 330  : 		{	// report error
; 331  : 		_DEBUG_ERROR("deque iterator not dereferencable");
; 332  : 		_SCL_SECURE_OUT_OF_RANGE;
; 333  : 		}
; 334  : 
; 335  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 336  : 		_SCL_SECURE_VALIDATE(_Mycont != 0);
; 337  : 		_SCL_SECURE_VALIDATE_RANGE(_Mycont->_Myoff <= this->_Myoff
; 338  : 			&& this->_Myoff < _Mycont->_Myoff + _Mycont->_Mysize);
; 339  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 340  : 
; 341  : 		_Analysis_assume_(_Mycont != 0);
; 342  : 
; 343  : 		size_type _Block = _Mycont->_Getblock(_Myoff);
; 344  : 		size_type _Off = _Myoff % _DEQUESIZ;
; 345  : 		return (_Mycont->_Map[_Block][_Off]);

  0001a	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0001d	83 e2 01	 and	 edx, 1
  00020	8b 04 88	 mov	 eax, DWORD PTR [eax+ecx*4]
  00023	5e		 pop	 esi
  00024	8d 04 d0	 lea	 eax, DWORD PTR [eax+edx*8]

; 346  : 		}

  00027	c3		 ret	 0
??D?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@QBEABV?$shared_ptr@VChunkBase@@@1@XZ ENDP ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<std::shared_ptr<ChunkBase> > > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@QAE@XZ PROC ; std::allocator<std::shared_ptr<ChunkBase> >::allocator<std::shared_ptr<ChunkBase> >, COMDAT
; _this$ = ecx

; 566  : 		{	// construct default allocator (do nothing)
; 567  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@QAE@XZ ENDP ; std::allocator<std::shared_ptr<ChunkBase> >::allocator<std::shared_ptr<ChunkBase> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QBEIXZ PROC ; std::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> > >::max_size, COMDAT
; _this$dead$ = ecx

; 914  : 		return (_Mytraits::max_size(*this));

  00000	b8 ff ff ff 1f	 mov	 eax, 536870911		; 1fffffffH

; 915  : 		}

  00005	c3		 ret	 0
?max_size@?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QBEIXZ ENDP ; std::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@PAV?$shared_ptr@VChunkBase@@@std@@@std@@QAEXPAPAV?$shared_ptr@VChunkBase@@@2@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$dead$ = 12					; size = 4
?deallocate@?$allocator@PAV?$shared_ptr@VChunkBase@@@std@@@std@@QAEXPAPAV?$shared_ptr@VChunkBase@@@2@I@Z PROC ; std::allocator<std::shared_ptr<ChunkBase> *>::deallocate, COMDAT
; _this$dead$ = ecx

; 585  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 586  : 		::operator delete(_Ptr);

  00003	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	83 c4 04	 add	 esp, 4

; 587  : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 08 00	 ret	 8
?deallocate@?$allocator@PAV?$shared_ptr@VChunkBase@@@std@@@std@@QAEXPAPAV?$shared_ptr@VChunkBase@@@2@I@Z ENDP ; std::allocator<std::shared_ptr<ChunkBase> *>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@PAV?$shared_ptr@VChunkBase@@@std@@@std@@QAEPAPAV?$shared_ptr@VChunkBase@@@2@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@PAV?$shared_ptr@VChunkBase@@@std@@@std@@QAEPAPAV?$shared_ptr@VChunkBase@@@2@I@Z PROC ; std::allocator<std::shared_ptr<ChunkBase> *>::allocate, COMDAT
; _this$dead$ = ecx

; 590  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 25   : 	if (_Count == 0)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	33 c9		 xor	 ecx, ecx
  00008	85 c0		 test	 eax, eax
  0000a	74 19		 je	 SHORT $LN4@allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0000c	3d ff ff ff 3f	 cmp	 eax, 1073741823		; 3fffffffH
  00011	77 18		 ja	 SHORT $LN11@allocate
  00013	c1 e0 02	 shl	 eax, 2
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0001c	8b c8		 mov	 ecx, eax
  0001e	83 c4 04	 add	 esp, 4
  00021	85 c9		 test	 ecx, ecx
  00023	74 06		 je	 SHORT $LN11@allocate
$LN4@allocate:

; 591  : 		return (_Allocate(_Count, (pointer)0));

  00025	8b c1		 mov	 eax, ecx

; 592  : 		}

  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
$LN11@allocate:

; 29   : 		_Xbad_alloc();	// report no memory

  0002b	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN13@allocate:
$LN10@allocate:
  00030	cc		 int	 3
?allocate@?$allocator@PAV?$shared_ptr@VChunkBase@@@std@@@std@@QAEPAPAV?$shared_ptr@VChunkBase@@@2@I@Z ENDP ; std::allocator<std::shared_ptr<ChunkBase> *>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
;	COMDAT ??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
__Lock$1 = 12						; size = 4
__Pdeque$ = 12						; size = 4
??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z PROC ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<std::shared_ptr<ChunkBase> > > >::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<std::shared_ptr<ChunkBase> > > >, COMDAT
; _this$ = ecx

; 303  : 	_Deque_const_iterator(size_type _Off, const _Container_base12 *_Pdeque)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility

; 146  : 		if (_Parent == 0)

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Pdeque$[ebp]
  00006	56		 push	 esi
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 303  : 	_Deque_const_iterator(size_type _Off, const _Container_base12 *_Pdeque)

  00007	8b f1		 mov	 esi, ecx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility

; 113  : 		{	// construct orphaned iterator

  00009	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  0000f	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 146  : 		if (_Parent == 0)

  00016	85 c0		 test	 eax, eax
  00018	75 1f		 jne	 SHORT $LN8@Deque_cons

; 147  : 			{	// no future parent, just disown current parent
; 148  : 			_Lockit _Lock(_LOCK_DEBUG);

  0001a	6a 03		 push	 3
  0001c	8d 4d 0c	 lea	 ecx, DWORD PTR __Lock$1[ebp]
  0001f	e8 00 00 00 00	 call	 ??0_Lockit@std@@QAE@H@Z	; std::_Lockit::_Lockit

; 149  : 			_Orphan_me();
; 150  : 			}

  00024	8d 4d 0c	 lea	 ecx, DWORD PTR __Lock$1[ebp]
  00027	e8 00 00 00 00	 call	 ??1_Lockit@std@@QAE@XZ	; std::_Lockit::~_Lockit
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 306  : 		_Myoff = _Off;

  0002c	8b 45 08	 mov	 eax, DWORD PTR __Off$[ebp]
  0002f	89 46 08	 mov	 DWORD PTR [esi+8], eax

; 307  : 		}

  00032	8b c6		 mov	 eax, esi
  00034	5e		 pop	 esi
  00035	5d		 pop	 ebp
  00036	c2 08 00	 ret	 8
$LN8@Deque_cons:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility

; 166  : 			_Myproxy = _Parent_proxy;

  00039	8b 00		 mov	 eax, DWORD PTR [eax]
  0003b	89 06		 mov	 DWORD PTR [esi], eax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 306  : 		_Myoff = _Off;

  0003d	8b 45 08	 mov	 eax, DWORD PTR __Off$[ebp]
  00040	89 46 08	 mov	 DWORD PTR [esi+8], eax

; 307  : 		}

  00043	8b c6		 mov	 eax, esi
  00045	5e		 pop	 esi
  00046	5d		 pop	 ebp
  00047	c2 08 00	 ret	 8
??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z ENDP ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<std::shared_ptr<ChunkBase> > > >::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<std::shared_ptr<ChunkBase> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@SAIABV?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@Z
_TEXT	SEGMENT
?max_size@?$allocator_traits@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@SAIABV?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@Z PROC ; std::allocator_traits<std::allocator<std::shared_ptr<ChunkBase> > >::max_size, COMDAT
; __Al$dead$ = ecx

; 762  : 		return (_Al.max_size());

  00000	b8 ff ff ff 1f	 mov	 eax, 536870911		; 1fffffffH

; 763  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator_traits@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@SAIABV?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@Z ENDP ; std::allocator_traits<std::allocator<std::shared_ptr<ChunkBase> > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
;	COMDAT ?_Setcont@?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@QAEXPBV?$_Deque_val@U?$_Deque_simple_types@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@Z
_TEXT	SEGMENT
__Lock$1 = 8						; size = 4
__Pdeque$ = 8						; size = 4
?_Setcont@?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@QAEXPBV?$_Deque_val@U?$_Deque_simple_types@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@Z PROC ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<std::shared_ptr<ChunkBase> > > >::_Setcont, COMDAT
; _this$ = ecx

; 531  : 		{	// set container pointer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility

; 146  : 		if (_Parent == 0)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pdeque$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	75 16		 jne	 SHORT $LN4@Setcont

; 147  : 			{	// no future parent, just disown current parent
; 148  : 			_Lockit _Lock(_LOCK_DEBUG);

  0000a	6a 03		 push	 3
  0000c	8d 4d 08	 lea	 ecx, DWORD PTR __Lock$1[ebp]
  0000f	e8 00 00 00 00	 call	 ??0_Lockit@std@@QAE@H@Z	; std::_Lockit::_Lockit

; 149  : 			_Orphan_me();
; 150  : 			}

  00014	8d 4d 08	 lea	 ecx, DWORD PTR __Lock$1[ebp]
  00017	e8 00 00 00 00	 call	 ??1_Lockit@std@@QAE@XZ	; std::_Lockit::~_Lockit
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 533  : 		}

  0001c	5d		 pop	 ebp
  0001d	c2 04 00	 ret	 4
$LN4@Setcont:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility

; 166  : 			_Myproxy = _Parent_proxy;

  00020	8b 00		 mov	 eax, DWORD PTR [eax]
  00022	89 01		 mov	 DWORD PTR [ecx], eax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 533  : 		}

  00024	5d		 pop	 ebp
  00025	c2 04 00	 ret	 4
?_Setcont@?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@QAEXPBV?$_Deque_val@U?$_Deque_simple_types@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@Z ENDP ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<std::shared_ptr<ChunkBase> > > >::_Setcont
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@QBEIXZ PROC ; std::allocator<std::shared_ptr<ChunkBase> >::max_size, COMDAT
; _this$dead$ = ecx

; 628  : 		return ((size_t)(-1) / sizeof (_Ty));

  00000	b8 ff ff ff 1f	 mov	 eax, 536870911		; 1fffffffH

; 629  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@QBEIXZ ENDP ; std::allocator<std::shared_ptr<ChunkBase> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ??$?0VVertexStream@gfxu@@@?$shared_ptr@VVertexStream@gfxu@@@std@@QAE@PAVVertexStream@gfxu@@@Z
_TEXT	SEGMENT
__Px$ = 8						; size = 4
??$?0VVertexStream@gfxu@@@?$shared_ptr@VVertexStream@gfxu@@@std@@QAE@PAVVertexStream@gfxu@@@Z PROC ; std::shared_ptr<gfxu::VertexStream>::shared_ptr<gfxu::VertexStream><gfxu::VertexStream>, COMDAT
; _this$ = ecx

; 485  : 		explicit shared_ptr(_Ux *_Px)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 486  : 		{	// construct shared_ptr object that owns _Px
; 487  : 		_Resetp(_Px);

  00004	ff 75 08	 push	 DWORD PTR __Px$[ebp]
  00007	8b f1		 mov	 esi, ecx

; 282  : 		{	// construct

  00009	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  0000f	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 486  : 		{	// construct shared_ptr object that owns _Px
; 487  : 		_Resetp(_Px);

  00016	e8 00 00 00 00	 call	 ??$_Resetp@VVertexStream@gfxu@@@?$shared_ptr@VVertexStream@gfxu@@@std@@AAEXPAVVertexStream@gfxu@@@Z ; std::shared_ptr<gfxu::VertexStream>::_Resetp<gfxu::VertexStream>

; 488  : 		}

  0001b	8b c6		 mov	 eax, esi
  0001d	5e		 pop	 esi
  0001e	5d		 pop	 ebp
  0001f	c2 04 00	 ret	 4
??$?0VVertexStream@gfxu@@@?$shared_ptr@VVertexStream@gfxu@@@std@@QAE@PAVVertexStream@gfxu@@@Z ENDP ; std::shared_ptr<gfxu::VertexStream>::shared_ptr<gfxu::VertexStream><gfxu::VertexStream>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ??$_Reset@VChunkBase@@@?$_Ptr_base@VChunkBase@@@std@@QAEXABV01@@Z
_TEXT	SEGMENT
$T1 = 8							; size = 4
__Other$ = 8						; size = 4
??$_Reset@VChunkBase@@@?$_Ptr_base@VChunkBase@@@std@@QAEXABV01@@Z PROC ; std::_Ptr_base<ChunkBase>::_Reset<ChunkBase>, COMDAT
; _this$ = ecx

; 355  : 		void _Reset(const _Ptr_base<_Ty2>& _Other)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 356  : 		{	// release resource and take ownership of _Other._Ptr
; 357  : 		_Reset(_Other._Ptr, _Other._Rep);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Other$[ebp]
  00006	53		 push	 ebx
  00007	8b 10		 mov	 edx, DWORD PTR [eax]
  00009	56		 push	 esi
  0000a	57		 push	 edi
  0000b	8b 78 04	 mov	 edi, DWORD PTR [eax+4]
  0000e	8b f1		 mov	 esi, ecx
  00010	89 55 08	 mov	 DWORD PTR $T1[ebp], edx

; 359  : 
; 360  : 	template<class _Ty2>
; 361  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, bool _Throw)
; 362  : 		{	// release resource and take ownership from weak_ptr _Other._Ptr
; 363  : 		_Reset(_Other._Ptr, _Other._Rep, _Throw);
; 364  : 		}
; 365  : 
; 366  : 	template<class _Ty2>
; 367  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Static_tag&)
; 368  : 		{	// release resource and take ownership of _Other._Ptr
; 369  : 		_Reset(static_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 370  : 		}
; 371  : 
; 372  : 	template<class _Ty2>
; 373  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Const_tag&)
; 374  : 		{	// release resource and take ownership of _Other._Ptr
; 375  : 		_Reset(const_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 376  : 		}
; 377  : 
; 378  : 	template<class _Ty2>
; 379  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Dynamic_tag&)
; 380  : 		{	// release resource and take ownership of _Other._Ptr
; 381  : 		_Elem *_Ptr = dynamic_cast<_Elem *>(_Other._Ptr);
; 382  : 		if (_Ptr)
; 383  : 			_Reset(_Ptr, _Other._Rep);
; 384  : 		else
; 385  : 			_Reset();
; 386  : 		}
; 387  : 
; 388  : 	template<class _Ty2>
; 389  : 		void _Reset(auto_ptr<_Ty2>&& _Other)
; 390  : 		{	// release resource and take _Other.get()
; 391  : 		_Ty2 *_Px = _Other.get();
; 392  : 		_Reset0(_Px, new _Ref_count<_Elem>(_Px));
; 393  : 		_Other.release();
; 394  : 		_Enable_shared(_Px, _Rep);
; 395  : 		}
; 396  : 
; 397  :  #if _HAS_CPP0X
; 398  : 	template<class _Ty2>
; 399  : 		void _Reset(_Ty *_Ptr, const _Ptr_base<_Ty2>& _Other)
; 400  : 		{	// release resource and alias _Ptr with _Other_rep
; 401  : 		_Reset(_Ptr, _Other._Rep);
; 402  : 		}
; 403  :  #endif /* _HAS_CPP0X */
; 404  : 
; 405  : 	void _Reset(_Ty *_Other_ptr, _Ref_count_base *_Other_rep)
; 406  : 		{	// release resource and take _Other_ptr through _Other_rep
; 407  : 		if (_Other_rep)

  00013	85 ff		 test	 edi, edi
  00015	74 0f		 je	 SHORT $LN6@Reset

; 108  : 		_MT_INCR(_Ignored, _Uses);

  00017	8d 47 04	 lea	 eax, DWORD PTR [edi+4]
  0001a	ba 01 00 00 00	 mov	 edx, 1
  0001f	f0 0f c1 10	 lock	  xadd	 DWORD PTR [eax], edx
  00023	8b 55 08	 mov	 edx, DWORD PTR $T1[ebp]
$LN6@Reset:

; 408  : 			_Other_rep->_Incref();
; 409  : 		_Reset0(_Other_ptr, _Other_rep);
; 410  : 		}
; 411  : 
; 412  : 	void _Reset(_Ty *_Other_ptr, _Ref_count_base *_Other_rep, bool _Throw)
; 413  : 		{	// take _Other_ptr through _Other_rep from weak_ptr if not expired
; 414  : 			// otherwise, leave in default state if !_Throw,
; 415  : 			// otherwise throw exception
; 416  : 		if (_Other_rep && _Other_rep->_Incref_nz())
; 417  : 			_Reset0(_Other_ptr, _Other_rep);
; 418  : 		else if (_Throw)
; 419  : 			_THROW_NCEE(bad_weak_ptr, 0);
; 420  : 		}
; 421  : 
; 422  : 	void _Reset0(_Ty *_Other_ptr, _Ref_count_base *_Other_rep)
; 423  : 		{	// release resource and take new resource
; 424  : 		if (_Rep != 0)

  00026	8b 5e 04	 mov	 ebx, DWORD PTR [esi+4]
  00029	85 db		 test	 ebx, ebx
  0002b	74 34		 je	 SHORT $LN19@Reset

; 109  : 		}
; 110  : 
; 111  : 	void _Incwref()
; 112  : 		{	// increment weak reference count
; 113  : 		_MT_INCR(_Ignored, _Weaks);
; 114  : 		}
; 115  : 
; 116  : 	void _Decref()
; 117  : 		{	// decrement use count
; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  0002d	8d 4b 04	 lea	 ecx, DWORD PTR [ebx+4]
  00030	83 c8 ff	 or	 eax, -1
  00033	f0 0f c1 01	 lock	  xadd	 DWORD PTR [ecx], eax
  00037	75 28		 jne	 SHORT $LN19@Reset

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  00039	8b 03		 mov	 eax, DWORD PTR [ebx]
  0003b	8b cb		 mov	 ecx, ebx
  0003d	ff 10		 call	 DWORD PTR [eax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  0003f	8d 43 08	 lea	 eax, DWORD PTR [ebx+8]
  00042	83 c9 ff	 or	 ecx, -1
  00045	f0 0f c1 08	 lock	  xadd	 DWORD PTR [eax], ecx
  00049	75 07		 jne	 SHORT $LN17@Reset

; 128  : 			_Delete_this();

  0004b	8b 03		 mov	 eax, DWORD PTR [ebx]
  0004d	8b cb		 mov	 ecx, ebx
  0004f	ff 50 04	 call	 DWORD PTR [eax+4]
$LN17@Reset:

; 427  : 		_Ptr = _Other_ptr;

  00052	8b 45 08	 mov	 eax, DWORD PTR $T1[ebp]
  00055	89 7e 04	 mov	 DWORD PTR [esi+4], edi
  00058	5f		 pop	 edi
  00059	89 06		 mov	 DWORD PTR [esi], eax
  0005b	5e		 pop	 esi
  0005c	5b		 pop	 ebx

; 358  : 		}

  0005d	5d		 pop	 ebp
  0005e	c2 04 00	 ret	 4
$LN19@Reset:

; 425  : 			_Rep->_Decref();
; 426  : 		_Rep = _Other_rep;

  00061	89 7e 04	 mov	 DWORD PTR [esi+4], edi
  00064	5f		 pop	 edi

; 427  : 		_Ptr = _Other_ptr;

  00065	89 16		 mov	 DWORD PTR [esi], edx
  00067	5e		 pop	 esi
  00068	5b		 pop	 ebx

; 358  : 		}

  00069	5d		 pop	 ebp
  0006a	c2 04 00	 ret	 4
??$_Reset@VChunkBase@@@?$_Ptr_base@VChunkBase@@@std@@QAEXABV01@@Z ENDP ; std::_Ptr_base<ChunkBase>::_Reset<ChunkBase>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ??$_Reset@VVertexStream@gfxu@@@?$_Ptr_base@VVertexStream@gfxu@@@std@@QAEXABV01@@Z
_TEXT	SEGMENT
$T1 = 8							; size = 4
__Other$ = 8						; size = 4
??$_Reset@VVertexStream@gfxu@@@?$_Ptr_base@VVertexStream@gfxu@@@std@@QAEXABV01@@Z PROC ; std::_Ptr_base<gfxu::VertexStream>::_Reset<gfxu::VertexStream>, COMDAT
; _this$ = ecx

; 355  : 		void _Reset(const _Ptr_base<_Ty2>& _Other)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 356  : 		{	// release resource and take ownership of _Other._Ptr
; 357  : 		_Reset(_Other._Ptr, _Other._Rep);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Other$[ebp]
  00006	53		 push	 ebx
  00007	8b 10		 mov	 edx, DWORD PTR [eax]
  00009	56		 push	 esi
  0000a	57		 push	 edi
  0000b	8b 78 04	 mov	 edi, DWORD PTR [eax+4]
  0000e	8b f1		 mov	 esi, ecx
  00010	89 55 08	 mov	 DWORD PTR $T1[ebp], edx

; 359  : 
; 360  : 	template<class _Ty2>
; 361  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, bool _Throw)
; 362  : 		{	// release resource and take ownership from weak_ptr _Other._Ptr
; 363  : 		_Reset(_Other._Ptr, _Other._Rep, _Throw);
; 364  : 		}
; 365  : 
; 366  : 	template<class _Ty2>
; 367  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Static_tag&)
; 368  : 		{	// release resource and take ownership of _Other._Ptr
; 369  : 		_Reset(static_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 370  : 		}
; 371  : 
; 372  : 	template<class _Ty2>
; 373  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Const_tag&)
; 374  : 		{	// release resource and take ownership of _Other._Ptr
; 375  : 		_Reset(const_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 376  : 		}
; 377  : 
; 378  : 	template<class _Ty2>
; 379  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Dynamic_tag&)
; 380  : 		{	// release resource and take ownership of _Other._Ptr
; 381  : 		_Elem *_Ptr = dynamic_cast<_Elem *>(_Other._Ptr);
; 382  : 		if (_Ptr)
; 383  : 			_Reset(_Ptr, _Other._Rep);
; 384  : 		else
; 385  : 			_Reset();
; 386  : 		}
; 387  : 
; 388  : 	template<class _Ty2>
; 389  : 		void _Reset(auto_ptr<_Ty2>&& _Other)
; 390  : 		{	// release resource and take _Other.get()
; 391  : 		_Ty2 *_Px = _Other.get();
; 392  : 		_Reset0(_Px, new _Ref_count<_Elem>(_Px));
; 393  : 		_Other.release();
; 394  : 		_Enable_shared(_Px, _Rep);
; 395  : 		}
; 396  : 
; 397  :  #if _HAS_CPP0X
; 398  : 	template<class _Ty2>
; 399  : 		void _Reset(_Ty *_Ptr, const _Ptr_base<_Ty2>& _Other)
; 400  : 		{	// release resource and alias _Ptr with _Other_rep
; 401  : 		_Reset(_Ptr, _Other._Rep);
; 402  : 		}
; 403  :  #endif /* _HAS_CPP0X */
; 404  : 
; 405  : 	void _Reset(_Ty *_Other_ptr, _Ref_count_base *_Other_rep)
; 406  : 		{	// release resource and take _Other_ptr through _Other_rep
; 407  : 		if (_Other_rep)

  00013	85 ff		 test	 edi, edi
  00015	74 0f		 je	 SHORT $LN6@Reset

; 108  : 		_MT_INCR(_Ignored, _Uses);

  00017	8d 47 04	 lea	 eax, DWORD PTR [edi+4]
  0001a	ba 01 00 00 00	 mov	 edx, 1
  0001f	f0 0f c1 10	 lock	  xadd	 DWORD PTR [eax], edx
  00023	8b 55 08	 mov	 edx, DWORD PTR $T1[ebp]
$LN6@Reset:

; 408  : 			_Other_rep->_Incref();
; 409  : 		_Reset0(_Other_ptr, _Other_rep);
; 410  : 		}
; 411  : 
; 412  : 	void _Reset(_Ty *_Other_ptr, _Ref_count_base *_Other_rep, bool _Throw)
; 413  : 		{	// take _Other_ptr through _Other_rep from weak_ptr if not expired
; 414  : 			// otherwise, leave in default state if !_Throw,
; 415  : 			// otherwise throw exception
; 416  : 		if (_Other_rep && _Other_rep->_Incref_nz())
; 417  : 			_Reset0(_Other_ptr, _Other_rep);
; 418  : 		else if (_Throw)
; 419  : 			_THROW_NCEE(bad_weak_ptr, 0);
; 420  : 		}
; 421  : 
; 422  : 	void _Reset0(_Ty *_Other_ptr, _Ref_count_base *_Other_rep)
; 423  : 		{	// release resource and take new resource
; 424  : 		if (_Rep != 0)

  00026	8b 5e 04	 mov	 ebx, DWORD PTR [esi+4]
  00029	85 db		 test	 ebx, ebx
  0002b	74 34		 je	 SHORT $LN19@Reset

; 109  : 		}
; 110  : 
; 111  : 	void _Incwref()
; 112  : 		{	// increment weak reference count
; 113  : 		_MT_INCR(_Ignored, _Weaks);
; 114  : 		}
; 115  : 
; 116  : 	void _Decref()
; 117  : 		{	// decrement use count
; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  0002d	8d 4b 04	 lea	 ecx, DWORD PTR [ebx+4]
  00030	83 c8 ff	 or	 eax, -1
  00033	f0 0f c1 01	 lock	  xadd	 DWORD PTR [ecx], eax
  00037	75 28		 jne	 SHORT $LN19@Reset

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  00039	8b 03		 mov	 eax, DWORD PTR [ebx]
  0003b	8b cb		 mov	 ecx, ebx
  0003d	ff 10		 call	 DWORD PTR [eax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  0003f	8d 43 08	 lea	 eax, DWORD PTR [ebx+8]
  00042	83 c9 ff	 or	 ecx, -1
  00045	f0 0f c1 08	 lock	  xadd	 DWORD PTR [eax], ecx
  00049	75 07		 jne	 SHORT $LN17@Reset

; 128  : 			_Delete_this();

  0004b	8b 03		 mov	 eax, DWORD PTR [ebx]
  0004d	8b cb		 mov	 ecx, ebx
  0004f	ff 50 04	 call	 DWORD PTR [eax+4]
$LN17@Reset:

; 427  : 		_Ptr = _Other_ptr;

  00052	8b 45 08	 mov	 eax, DWORD PTR $T1[ebp]
  00055	89 7e 04	 mov	 DWORD PTR [esi+4], edi
  00058	5f		 pop	 edi
  00059	89 06		 mov	 DWORD PTR [esi], eax
  0005b	5e		 pop	 esi
  0005c	5b		 pop	 ebx

; 358  : 		}

  0005d	5d		 pop	 ebp
  0005e	c2 04 00	 ret	 4
$LN19@Reset:

; 425  : 			_Rep->_Decref();
; 426  : 		_Rep = _Other_rep;

  00061	89 7e 04	 mov	 DWORD PTR [esi+4], edi
  00064	5f		 pop	 edi

; 427  : 		_Ptr = _Other_ptr;

  00065	89 16		 mov	 DWORD PTR [esi], edx
  00067	5e		 pop	 esi
  00068	5b		 pop	 ebx

; 358  : 		}

  00069	5d		 pop	 ebp
  0006a	c2 04 00	 ret	 4
??$_Reset@VVertexStream@gfxu@@@?$_Ptr_base@VVertexStream@gfxu@@@std@@QAEXABV01@@Z ENDP ; std::_Ptr_base<gfxu::VertexStream>::_Reset<gfxu::VertexStream>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@V?$shared_ptr@VChunkBase@@@std@@@?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QAEXPAV?$shared_ptr@VChunkBase@@@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@V?$shared_ptr@VChunkBase@@@std@@@?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QAEXPAV?$shared_ptr@VChunkBase@@@1@@Z PROC ; std::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> > >::destroy<std::shared_ptr<ChunkBase> >, COMDAT
; _this$dead$ = ecx

; 907  : 		void destroy(_Ty *_Ptr)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	56		 push	 esi
  00007	8b 70 04	 mov	 esi, DWORD PTR [eax+4]
  0000a	85 f6		 test	 esi, esi
  0000c	74 27		 je	 SHORT $LN18@destroy
  0000e	57		 push	 edi

; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  0000f	83 cf ff	 or	 edi, -1
  00012	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  00015	8b c7		 mov	 eax, edi
  00017	f0 0f c1 01	 lock	  xadd	 DWORD PTR [ecx], eax
  0001b	75 17		 jne	 SHORT $LN21@destroy

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  0001d	8b 06		 mov	 eax, DWORD PTR [esi]
  0001f	8b ce		 mov	 ecx, esi
  00021	ff 10		 call	 DWORD PTR [eax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  00023	8d 46 08	 lea	 eax, DWORD PTR [esi+8]
  00026	f0 0f c1 38	 lock	  xadd	 DWORD PTR [eax], edi
  0002a	4f		 dec	 edi
  0002b	75 07		 jne	 SHORT $LN21@destroy

; 128  : 			_Delete_this();

  0002d	8b 06		 mov	 eax, DWORD PTR [esi]
  0002f	8b ce		 mov	 ecx, esi
  00031	ff 50 04	 call	 DWORD PTR [eax+4]
$LN21@destroy:
  00034	5f		 pop	 edi
$LN18@destroy:
  00035	5e		 pop	 esi
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 910  : 		}

  00036	5d		 pop	 ebp
  00037	c2 04 00	 ret	 4
??$destroy@V?$shared_ptr@VChunkBase@@@std@@@?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QAEXPAV?$shared_ptr@VChunkBase@@@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> > >::destroy<std::shared_ptr<ChunkBase> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@V?$shared_ptr@VChunkBase@@@std@@ABV12@@?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QAEXPAV?$shared_ptr@VChunkBase@@@1@ABV21@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__V0$ = 12						; size = 4
??$construct@V?$shared_ptr@VChunkBase@@@std@@ABV12@@?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QAEXPAV?$shared_ptr@VChunkBase@@@1@ABV21@@Z PROC ; std::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> > >::construct<std::shared_ptr<ChunkBase>,std::shared_ptr<ChunkBase> const &>, COMDAT
; _this$dead$ = ecx

; 903  : _VARIADIC_EXPAND_0X(_WRAP_ALLOC_CONSTRUCT, , , , )

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 606  : 		::new ((void *)_Ptr) _Ty(_Val);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 08		 je	 SHORT $LN11@construct
  0000a	ff 75 0c	 push	 DWORD PTR __V0$[ebp]
  0000d	e8 00 00 00 00	 call	 ??0?$shared_ptr@VChunkBase@@@std@@QAE@ABV01@@Z ; std::shared_ptr<ChunkBase>::shared_ptr<ChunkBase>
$LN11@construct:

; 903  : _VARIADIC_EXPAND_0X(_WRAP_ALLOC_CONSTRUCT, , , , )

  00012	5d		 pop	 ebp
  00013	c2 08 00	 ret	 8
??$construct@V?$shared_ptr@VChunkBase@@@std@@ABV12@@?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QAEXPAV?$shared_ptr@VChunkBase@@@1@ABV21@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> > >::construct<std::shared_ptr<ChunkBase>,std::shared_ptr<ChunkBase> const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
;	COMDAT ??$swap@PAV_Ref_count_base@std@@@std@@YAXAAPAV_Ref_count_base@0@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$swap@PAV_Ref_count_base@std@@@std@@YAXAAPAV_Ref_count_base@0@0@Z PROC ; std::swap<std::_Ref_count_base *>, COMDAT

; 46   : 	{	// exchange values stored at _Left and _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   : 	_Ty _Tmp = _Move(_Left);
; 48   : 	_Left = _Move(_Right);

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Right$[ebp]
  00006	8b 55 08	 mov	 edx, DWORD PTR __Left$[ebp]
  00009	8b 01		 mov	 eax, DWORD PTR [ecx]
  0000b	56		 push	 esi
  0000c	8b 32		 mov	 esi, DWORD PTR [edx]
  0000e	89 02		 mov	 DWORD PTR [edx], eax

; 49   : 	_Right = _Move(_Tmp);

  00010	89 31		 mov	 DWORD PTR [ecx], esi
  00012	5e		 pop	 esi

; 50   : 	}

  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
??$swap@PAV_Ref_count_base@std@@@std@@YAXAAPAV_Ref_count_base@0@0@Z ENDP ; std::swap<std::_Ref_count_base *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
;	COMDAT ??$swap@PAVVertexStream@gfxu@@@std@@YAXAAPAVVertexStream@gfxu@@0@Z
_TEXT	SEGMENT
??$swap@PAVVertexStream@gfxu@@@std@@YAXAAPAVVertexStream@gfxu@@0@Z PROC ; std::swap<gfxu::VertexStream *>, COMDAT
; __Left$ = ecx
; __Right$ = edx

; 47   : 	_Ty _Tmp = _Move(_Left);
; 48   : 	_Left = _Move(_Right);

  00000	8b 02		 mov	 eax, DWORD PTR [edx]
  00002	56		 push	 esi
  00003	8b 31		 mov	 esi, DWORD PTR [ecx]
  00005	89 01		 mov	 DWORD PTR [ecx], eax

; 49   : 	_Right = _Move(_Tmp);

  00007	89 32		 mov	 DWORD PTR [edx], esi
  00009	5e		 pop	 esi

; 50   : 	}

  0000a	c3		 ret	 0
??$swap@PAVVertexStream@gfxu@@@std@@YAXAAPAVVertexStream@gfxu@@0@Z ENDP ; std::swap<gfxu::VertexStream *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$?0U?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@?$_Wrap_alloc@V?$allocator@PAV?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QAE@ABU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
__Right$dead$ = 8					; size = 4
??$?0U?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@?$_Wrap_alloc@V?$allocator@PAV?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QAE@ABU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@1@@Z PROC ; std::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> *> >::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> *> ><std::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> > > >, COMDAT
; _this$ = ecx

; 847  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c2 04 00	 ret	 4
??$?0U?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@?$_Wrap_alloc@V?$allocator@PAV?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QAE@ABU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> *> >::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> *> ><std::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_copy@PAPAV?$shared_ptr@VChunkBase@@@std@@PAPAV12@U?$_Wrap_alloc@V?$allocator@PAV?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@YAPAPAV?$shared_ptr@VChunkBase@@@0@PAPAV10@00AAU?$_Wrap_alloc@V?$allocator@PAV?$shared_ptr@VChunkBase@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Al$dead$ = 12						; size = 4
??$_Uninitialized_copy@PAPAV?$shared_ptr@VChunkBase@@@std@@PAPAV12@U?$_Wrap_alloc@V?$allocator@PAV?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@YAPAPAV?$shared_ptr@VChunkBase@@@0@PAPAV10@00AAU?$_Wrap_alloc@V?$allocator@PAV?$shared_ptr@VChunkBase@@@std@@@std@@@0@@Z PROC ; std::_Uninitialized_copy<std::shared_ptr<ChunkBase> * *,std::shared_ptr<ChunkBase> * *,std::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> *> > >, COMDAT
; __First$ = ecx
; __Last$ = edx

; 414  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 404  : 	size_t _Count = (size_t)(_Last - _First);

  00003	2b d1		 sub	 edx, ecx
  00005	56		 push	 esi
  00006	c1 fa 02	 sar	 edx, 2

; 405  : 	return ((_Ty2 *)_CSTD memmove(&*_Dest, &*_First,
; 406  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

  00009	8d 34 95 00 00
	00 00		 lea	 esi, DWORD PTR [edx*4]
  00010	56		 push	 esi
  00011	51		 push	 ecx
  00012	ff 75 08	 push	 DWORD PTR __Dest$[ebp]
  00015	e8 00 00 00 00	 call	 _memmove
  0001a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0001d	03 c6		 add	 eax, esi
  0001f	5e		 pop	 esi

; 415  : 	return (_Uninit_copy(_First, _Last, _Dest, _Al,
; 416  : 		_Ptr_cat(_First, _Dest)));
; 417  : 	}

  00020	5d		 pop	 ebp
  00021	c3		 ret	 0
??$_Uninitialized_copy@PAPAV?$shared_ptr@VChunkBase@@@std@@PAPAV12@U?$_Wrap_alloc@V?$allocator@PAV?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@YAPAPAV?$shared_ptr@VChunkBase@@@0@PAPAV10@00AAU?$_Wrap_alloc@V?$allocator@PAV?$shared_ptr@VChunkBase@@@std@@@std@@@0@@Z ENDP ; std::_Uninitialized_copy<std::shared_ptr<ChunkBase> * *,std::shared_ptr<ChunkBase> * *,std::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_default_fill_n@PAPAV?$shared_ptr@VChunkBase@@@std@@IU?$_Wrap_alloc@V?$allocator@PAV?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@YAXPAPAV?$shared_ptr@VChunkBase@@@0@IAAU?$_Wrap_alloc@V?$allocator@PAV?$shared_ptr@VChunkBase@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
__Al$dead$ = 8						; size = 4
??$_Uninitialized_default_fill_n@PAPAV?$shared_ptr@VChunkBase@@@std@@IU?$_Wrap_alloc@V?$allocator@PAV?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@YAXPAPAV?$shared_ptr@VChunkBase@@@0@IAAU?$_Wrap_alloc@V?$allocator@PAV?$shared_ptr@VChunkBase@@@std@@@std@@@0@@Z PROC ; std::_Uninitialized_default_fill_n<std::shared_ptr<ChunkBase> * *,unsigned int,std::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> *> > >, COMDAT
; __First$ = ecx
; __Count$ = edx

; 668  : 	{	// copy _Count * _Val_type(_First)() to raw _First, using _Al

  00000	57		 push	 edi
  00001	8b f9		 mov	 edi, ecx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility

; 2678 : 	for (; 0 < _Count; --_Count, ++_Dest)

  00003	85 d2		 test	 edx, edx
  00005	74 06		 je	 SHORT $LN11@Uninitiali
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory

; 660  : 	_Fill_n(_First, _Count, (_Valty)0);

  00007	8b ca		 mov	 ecx, edx
  00009	33 c0		 xor	 eax, eax
  0000b	f3 ab		 rep stosd
$LN11@Uninitiali:
  0000d	5f		 pop	 edi

; 669  : 	_Uninit_def_fill_n(_First, _Count, _Al,
; 670  : 		_Val_type(_First), _Ptr_cat(_First, _First));
; 671  : 	}

  0000e	c3		 ret	 0
??$_Uninitialized_default_fill_n@PAPAV?$shared_ptr@VChunkBase@@@std@@IU?$_Wrap_alloc@V?$allocator@PAV?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@YAXPAPAV?$shared_ptr@VChunkBase@@@0@IAAU?$_Wrap_alloc@V?$allocator@PAV?$shared_ptr@VChunkBase@@@std@@@std@@@0@@Z ENDP ; std::_Uninitialized_default_fill_n<std::shared_ptr<ChunkBase> * *,unsigned int,std::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAV?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@YAXPAPAV?$shared_ptr@VChunkBase@@@0@0AAU?$_Wrap_alloc@V?$allocator@PAV?$shared_ptr@VChunkBase@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
__Al$dead$ = 8						; size = 4
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAV?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@YAXPAPAV?$shared_ptr@VChunkBase@@@0@0AAU?$_Wrap_alloc@V?$allocator@PAV?$shared_ptr@VChunkBase@@@std@@@std@@@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> *> > >, COMDAT
; __First$dead$ = ecx
; __Last$dead$ = edx

; 80   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 81   : 	}

  00000	c3		 ret	 0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAV?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@YAXPAPAV?$shared_ptr@VChunkBase@@@0@0AAU?$_Wrap_alloc@V?$allocator@PAV?$shared_ptr@VChunkBase@@@std@@@std@@@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$_Allocate@V?$shared_ptr@VChunkBase@@@std@@@std@@YAPAV?$shared_ptr@VChunkBase@@@0@IPAV10@@Z
_TEXT	SEGMENT
??$_Allocate@V?$shared_ptr@VChunkBase@@@std@@@std@@YAPAV?$shared_ptr@VChunkBase@@@0@IPAV10@@Z PROC ; std::_Allocate<std::shared_ptr<ChunkBase> >, COMDAT
; __Count$ = ecx

; 23   : 	void *_Ptr = 0;
; 24   : 
; 25   : 	if (_Count == 0)
; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  00000	81 f9 ff ff ff
	1f		 cmp	 ecx, 536870911		; 1fffffffH
  00006	77 14		 ja	 SHORT $LN1@Allocate
  00008	8d 04 cd 00 00
	00 00		 lea	 eax, DWORD PTR [ecx*8]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00015	83 c4 04	 add	 esp, 4
  00018	85 c0		 test	 eax, eax
  0001a	75 05		 jne	 SHORT $LN7@Allocate
$LN1@Allocate:

; 29   : 		_Xbad_alloc();	// report no memory

  0001c	e9 00 00 00 00	 jmp	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN7@Allocate:

; 30   : 
; 31   : 	return ((_Ty *)_Ptr);
; 32   : 	}

  00021	c3		 ret	 0
??$_Allocate@V?$shared_ptr@VChunkBase@@@std@@@std@@YAPAV?$shared_ptr@VChunkBase@@@0@IPAV10@@Z ENDP ; std::_Allocate<std::shared_ptr<ChunkBase> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$_Allocate@PAV?$shared_ptr@VChunkBase@@@std@@@std@@YAPAPAV?$shared_ptr@VChunkBase@@@0@IPAPAV10@@Z
_TEXT	SEGMENT
??$_Allocate@PAV?$shared_ptr@VChunkBase@@@std@@@std@@YAPAPAV?$shared_ptr@VChunkBase@@@0@IPAPAV10@@Z PROC ; std::_Allocate<std::shared_ptr<ChunkBase> *>, COMDAT
; __Count$ = ecx

; 23   : 	void *_Ptr = 0;
; 24   : 
; 25   : 	if (_Count == 0)
; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  00000	81 f9 ff ff ff
	3f		 cmp	 ecx, 1073741823		; 3fffffffH
  00006	77 14		 ja	 SHORT $LN1@Allocate
  00008	8d 04 8d 00 00
	00 00		 lea	 eax, DWORD PTR [ecx*4]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00015	83 c4 04	 add	 esp, 4
  00018	85 c0		 test	 eax, eax
  0001a	75 05		 jne	 SHORT $LN7@Allocate
$LN1@Allocate:

; 29   : 		_Xbad_alloc();	// report no memory

  0001c	e9 00 00 00 00	 jmp	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN7@Allocate:

; 30   : 
; 31   : 	return ((_Ty *)_Ptr);
; 32   : 	}

  00021	c3		 ret	 0
??$_Allocate@PAV?$shared_ptr@VChunkBase@@@std@@@std@@YAPAPAV?$shared_ptr@VChunkBase@@@0@IPAPAV10@@Z ENDP ; std::_Allocate<std::shared_ptr<ChunkBase> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ?_Reset@?$_Ptr_base@VVertexStream@gfxu@@@std@@QAEXPAVVertexStream@gfxu@@PAV_Ref_count_base@2@@Z
_TEXT	SEGMENT
__Other_ptr$ = 8					; size = 4
__Other_rep$ = 12					; size = 4
?_Reset@?$_Ptr_base@VVertexStream@gfxu@@@std@@QAEXPAVVertexStream@gfxu@@PAV_Ref_count_base@2@@Z PROC ; std::_Ptr_base<gfxu::VertexStream>::_Reset, COMDAT
; _this$ = ecx

; 406  : 		{	// release resource and take _Other_ptr through _Other_rep

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi
  00005	57		 push	 edi

; 407  : 		if (_Other_rep)

  00006	8b 7d 0c	 mov	 edi, DWORD PTR __Other_rep$[ebp]
  00009	8b f1		 mov	 esi, ecx
  0000b	85 ff		 test	 edi, edi
  0000d	74 0c		 je	 SHORT $LN4@Reset

; 108  : 		_MT_INCR(_Ignored, _Uses);

  0000f	8d 47 04	 lea	 eax, DWORD PTR [edi+4]
  00012	ba 01 00 00 00	 mov	 edx, 1
  00017	f0 0f c1 10	 lock	  xadd	 DWORD PTR [eax], edx
$LN4@Reset:

; 411  : 
; 412  : 	void _Reset(_Ty *_Other_ptr, _Ref_count_base *_Other_rep, bool _Throw)
; 413  : 		{	// take _Other_ptr through _Other_rep from weak_ptr if not expired
; 414  : 			// otherwise, leave in default state if !_Throw,
; 415  : 			// otherwise throw exception
; 416  : 		if (_Other_rep && _Other_rep->_Incref_nz())
; 417  : 			_Reset0(_Other_ptr, _Other_rep);
; 418  : 		else if (_Throw)
; 419  : 			_THROW_NCEE(bad_weak_ptr, 0);
; 420  : 		}
; 421  : 
; 422  : 	void _Reset0(_Ty *_Other_ptr, _Ref_count_base *_Other_rep)
; 423  : 		{	// release resource and take new resource
; 424  : 		if (_Rep != 0)

  0001b	8b 5e 04	 mov	 ebx, DWORD PTR [esi+4]
  0001e	85 db		 test	 ebx, ebx
  00020	74 25		 je	 SHORT $LN17@Reset

; 109  : 		}
; 110  : 
; 111  : 	void _Incwref()
; 112  : 		{	// increment weak reference count
; 113  : 		_MT_INCR(_Ignored, _Weaks);
; 114  : 		}
; 115  : 
; 116  : 	void _Decref()
; 117  : 		{	// decrement use count
; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  00022	8d 4b 04	 lea	 ecx, DWORD PTR [ebx+4]
  00025	83 c8 ff	 or	 eax, -1
  00028	f0 0f c1 01	 lock	  xadd	 DWORD PTR [ecx], eax
  0002c	75 19		 jne	 SHORT $LN17@Reset

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  0002e	8b 03		 mov	 eax, DWORD PTR [ebx]
  00030	8b cb		 mov	 ecx, ebx
  00032	ff 10		 call	 DWORD PTR [eax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  00034	8d 43 08	 lea	 eax, DWORD PTR [ebx+8]
  00037	83 c9 ff	 or	 ecx, -1
  0003a	f0 0f c1 08	 lock	  xadd	 DWORD PTR [eax], ecx
  0003e	75 07		 jne	 SHORT $LN17@Reset

; 128  : 			_Delete_this();

  00040	8b 03		 mov	 eax, DWORD PTR [ebx]
  00042	8b cb		 mov	 ecx, ebx
  00044	ff 50 04	 call	 DWORD PTR [eax+4]
$LN17@Reset:

; 425  : 			_Rep->_Decref();
; 426  : 		_Rep = _Other_rep;
; 427  : 		_Ptr = _Other_ptr;

  00047	8b 45 08	 mov	 eax, DWORD PTR __Other_ptr$[ebp]
  0004a	89 7e 04	 mov	 DWORD PTR [esi+4], edi
  0004d	5f		 pop	 edi
  0004e	89 06		 mov	 DWORD PTR [esi], eax
  00050	5e		 pop	 esi
  00051	5b		 pop	 ebx

; 408  : 			_Other_rep->_Incref();
; 409  : 		_Reset0(_Other_ptr, _Other_rep);
; 410  : 		}

  00052	5d		 pop	 ebp
  00053	c2 08 00	 ret	 8
?_Reset@?$_Ptr_base@VVertexStream@gfxu@@@std@@QAEXPAVVertexStream@gfxu@@PAV_Ref_count_base@2@@Z ENDP ; std::_Ptr_base<gfxu::VertexStream>::_Reset
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ?_Reset@?$_Ptr_base@VChunkBase@@@std@@QAEXPAVChunkBase@@PAV_Ref_count_base@2@@Z
_TEXT	SEGMENT
__Other_ptr$ = 8					; size = 4
__Other_rep$ = 12					; size = 4
?_Reset@?$_Ptr_base@VChunkBase@@@std@@QAEXPAVChunkBase@@PAV_Ref_count_base@2@@Z PROC ; std::_Ptr_base<ChunkBase>::_Reset, COMDAT
; _this$ = ecx

; 406  : 		{	// release resource and take _Other_ptr through _Other_rep

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi
  00005	57		 push	 edi

; 407  : 		if (_Other_rep)

  00006	8b 7d 0c	 mov	 edi, DWORD PTR __Other_rep$[ebp]
  00009	8b f1		 mov	 esi, ecx
  0000b	85 ff		 test	 edi, edi
  0000d	74 0c		 je	 SHORT $LN4@Reset

; 108  : 		_MT_INCR(_Ignored, _Uses);

  0000f	8d 47 04	 lea	 eax, DWORD PTR [edi+4]
  00012	ba 01 00 00 00	 mov	 edx, 1
  00017	f0 0f c1 10	 lock	  xadd	 DWORD PTR [eax], edx
$LN4@Reset:

; 411  : 
; 412  : 	void _Reset(_Ty *_Other_ptr, _Ref_count_base *_Other_rep, bool _Throw)
; 413  : 		{	// take _Other_ptr through _Other_rep from weak_ptr if not expired
; 414  : 			// otherwise, leave in default state if !_Throw,
; 415  : 			// otherwise throw exception
; 416  : 		if (_Other_rep && _Other_rep->_Incref_nz())
; 417  : 			_Reset0(_Other_ptr, _Other_rep);
; 418  : 		else if (_Throw)
; 419  : 			_THROW_NCEE(bad_weak_ptr, 0);
; 420  : 		}
; 421  : 
; 422  : 	void _Reset0(_Ty *_Other_ptr, _Ref_count_base *_Other_rep)
; 423  : 		{	// release resource and take new resource
; 424  : 		if (_Rep != 0)

  0001b	8b 5e 04	 mov	 ebx, DWORD PTR [esi+4]
  0001e	85 db		 test	 ebx, ebx
  00020	74 25		 je	 SHORT $LN17@Reset

; 109  : 		}
; 110  : 
; 111  : 	void _Incwref()
; 112  : 		{	// increment weak reference count
; 113  : 		_MT_INCR(_Ignored, _Weaks);
; 114  : 		}
; 115  : 
; 116  : 	void _Decref()
; 117  : 		{	// decrement use count
; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  00022	8d 4b 04	 lea	 ecx, DWORD PTR [ebx+4]
  00025	83 c8 ff	 or	 eax, -1
  00028	f0 0f c1 01	 lock	  xadd	 DWORD PTR [ecx], eax
  0002c	75 19		 jne	 SHORT $LN17@Reset

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  0002e	8b 03		 mov	 eax, DWORD PTR [ebx]
  00030	8b cb		 mov	 ecx, ebx
  00032	ff 10		 call	 DWORD PTR [eax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  00034	8d 43 08	 lea	 eax, DWORD PTR [ebx+8]
  00037	83 c9 ff	 or	 ecx, -1
  0003a	f0 0f c1 08	 lock	  xadd	 DWORD PTR [eax], ecx
  0003e	75 07		 jne	 SHORT $LN17@Reset

; 128  : 			_Delete_this();

  00040	8b 03		 mov	 eax, DWORD PTR [ebx]
  00042	8b cb		 mov	 ecx, ebx
  00044	ff 50 04	 call	 DWORD PTR [eax+4]
$LN17@Reset:

; 425  : 			_Rep->_Decref();
; 426  : 		_Rep = _Other_rep;
; 427  : 		_Ptr = _Other_ptr;

  00047	8b 45 08	 mov	 eax, DWORD PTR __Other_ptr$[ebp]
  0004a	89 7e 04	 mov	 DWORD PTR [esi+4], edi
  0004d	5f		 pop	 edi
  0004e	89 06		 mov	 DWORD PTR [esi], eax
  00050	5e		 pop	 esi
  00051	5b		 pop	 ebx

; 408  : 			_Other_rep->_Incref();
; 409  : 		_Reset0(_Other_ptr, _Other_rep);
; 410  : 		}

  00052	5d		 pop	 ebp
  00053	c2 08 00	 ret	 8
?_Reset@?$_Ptr_base@VChunkBase@@@std@@QAEXPAVChunkBase@@PAV_Ref_count_base@2@@Z ENDP ; std::_Ptr_base<ChunkBase>::_Reset
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ?_Reset0@?$_Ptr_base@VVertexStream@gfxu@@@std@@QAEXPAVVertexStream@gfxu@@PAV_Ref_count_base@2@@Z
_TEXT	SEGMENT
__Other_ptr$ = 8					; size = 4
__Other_rep$ = 12					; size = 4
?_Reset0@?$_Ptr_base@VVertexStream@gfxu@@@std@@QAEXPAVVertexStream@gfxu@@PAV_Ref_count_base@2@@Z PROC ; std::_Ptr_base<gfxu::VertexStream>::_Reset0, COMDAT
; _this$ = ecx

; 423  : 		{	// release resource and take new resource

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	57		 push	 edi

; 424  : 		if (_Rep != 0)

  00007	8b 7e 04	 mov	 edi, DWORD PTR [esi+4]
  0000a	85 ff		 test	 edi, edi
  0000c	74 38		 je	 SHORT $LN12@Reset0
  0000e	53		 push	 ebx

; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  0000f	83 cb ff	 or	 ebx, -1
  00012	8d 57 04	 lea	 edx, DWORD PTR [edi+4]
  00015	8b c3		 mov	 eax, ebx
  00017	f0 0f c1 02	 lock	  xadd	 DWORD PTR [edx], eax
  0001b	75 17		 jne	 SHORT $LN11@Reset0

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  0001d	8b 07		 mov	 eax, DWORD PTR [edi]
  0001f	8b cf		 mov	 ecx, edi
  00021	ff 10		 call	 DWORD PTR [eax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  00023	8d 47 08	 lea	 eax, DWORD PTR [edi+8]
  00026	f0 0f c1 18	 lock	  xadd	 DWORD PTR [eax], ebx
  0002a	4b		 dec	 ebx
  0002b	75 07		 jne	 SHORT $LN11@Reset0

; 128  : 			_Delete_this();

  0002d	8b 07		 mov	 eax, DWORD PTR [edi]
  0002f	8b cf		 mov	 ecx, edi
  00031	ff 50 04	 call	 DWORD PTR [eax+4]
$LN11@Reset0:

; 425  : 			_Rep->_Decref();
; 426  : 		_Rep = _Other_rep;

  00034	8b 45 0c	 mov	 eax, DWORD PTR __Other_rep$[ebp]
  00037	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 427  : 		_Ptr = _Other_ptr;

  0003a	8b 45 08	 mov	 eax, DWORD PTR __Other_ptr$[ebp]
  0003d	5b		 pop	 ebx
  0003e	5f		 pop	 edi
  0003f	89 06		 mov	 DWORD PTR [esi], eax
  00041	5e		 pop	 esi

; 428  : 		}

  00042	5d		 pop	 ebp
  00043	c2 08 00	 ret	 8
$LN12@Reset0:

; 425  : 			_Rep->_Decref();
; 426  : 		_Rep = _Other_rep;

  00046	8b 45 0c	 mov	 eax, DWORD PTR __Other_rep$[ebp]
  00049	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 427  : 		_Ptr = _Other_ptr;

  0004c	8b 45 08	 mov	 eax, DWORD PTR __Other_ptr$[ebp]
  0004f	5f		 pop	 edi
  00050	89 06		 mov	 DWORD PTR [esi], eax
  00052	5e		 pop	 esi

; 428  : 		}

  00053	5d		 pop	 ebp
  00054	c2 08 00	 ret	 8
?_Reset0@?$_Ptr_base@VVertexStream@gfxu@@@std@@QAEXPAVVertexStream@gfxu@@PAV_Ref_count_base@2@@Z ENDP ; std::_Ptr_base<gfxu::VertexStream>::_Reset0
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ?_Reset0@?$_Ptr_base@VChunkBase@@@std@@QAEXPAVChunkBase@@PAV_Ref_count_base@2@@Z
_TEXT	SEGMENT
__Other_ptr$ = 8					; size = 4
__Other_rep$ = 12					; size = 4
?_Reset0@?$_Ptr_base@VChunkBase@@@std@@QAEXPAVChunkBase@@PAV_Ref_count_base@2@@Z PROC ; std::_Ptr_base<ChunkBase>::_Reset0, COMDAT
; _this$ = ecx

; 423  : 		{	// release resource and take new resource

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	57		 push	 edi

; 424  : 		if (_Rep != 0)

  00007	8b 7e 04	 mov	 edi, DWORD PTR [esi+4]
  0000a	85 ff		 test	 edi, edi
  0000c	74 38		 je	 SHORT $LN12@Reset0
  0000e	53		 push	 ebx

; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  0000f	83 cb ff	 or	 ebx, -1
  00012	8d 57 04	 lea	 edx, DWORD PTR [edi+4]
  00015	8b c3		 mov	 eax, ebx
  00017	f0 0f c1 02	 lock	  xadd	 DWORD PTR [edx], eax
  0001b	75 17		 jne	 SHORT $LN11@Reset0

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  0001d	8b 07		 mov	 eax, DWORD PTR [edi]
  0001f	8b cf		 mov	 ecx, edi
  00021	ff 10		 call	 DWORD PTR [eax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  00023	8d 47 08	 lea	 eax, DWORD PTR [edi+8]
  00026	f0 0f c1 18	 lock	  xadd	 DWORD PTR [eax], ebx
  0002a	4b		 dec	 ebx
  0002b	75 07		 jne	 SHORT $LN11@Reset0

; 128  : 			_Delete_this();

  0002d	8b 07		 mov	 eax, DWORD PTR [edi]
  0002f	8b cf		 mov	 ecx, edi
  00031	ff 50 04	 call	 DWORD PTR [eax+4]
$LN11@Reset0:

; 425  : 			_Rep->_Decref();
; 426  : 		_Rep = _Other_rep;

  00034	8b 45 0c	 mov	 eax, DWORD PTR __Other_rep$[ebp]
  00037	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 427  : 		_Ptr = _Other_ptr;

  0003a	8b 45 08	 mov	 eax, DWORD PTR __Other_ptr$[ebp]
  0003d	5b		 pop	 ebx
  0003e	5f		 pop	 edi
  0003f	89 06		 mov	 DWORD PTR [esi], eax
  00041	5e		 pop	 esi

; 428  : 		}

  00042	5d		 pop	 ebp
  00043	c2 08 00	 ret	 8
$LN12@Reset0:

; 425  : 			_Rep->_Decref();
; 426  : 		_Rep = _Other_rep;

  00046	8b 45 0c	 mov	 eax, DWORD PTR __Other_rep$[ebp]
  00049	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 427  : 		_Ptr = _Other_ptr;

  0004c	8b 45 08	 mov	 eax, DWORD PTR __Other_ptr$[ebp]
  0004f	5f		 pop	 edi
  00050	89 06		 mov	 DWORD PTR [esi], eax
  00052	5e		 pop	 esi

; 428  : 		}

  00053	5d		 pop	 ebp
  00054	c2 08 00	 ret	 8
?_Reset0@?$_Ptr_base@VChunkBase@@@std@@QAEXPAVChunkBase@@PAV_Ref_count_base@2@@Z ENDP ; std::_Ptr_base<ChunkBase>::_Reset0
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xatomic0.h
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ??$_Resetp@VVertexStream@gfxu@@@?$shared_ptr@VVertexStream@gfxu@@@std@@AAEXPAVVertexStream@gfxu@@@Z
_TEXT	SEGMENT
_this$1$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Px$ = 8						; size = 4
??$_Resetp@VVertexStream@gfxu@@@?$shared_ptr@VVertexStream@gfxu@@@std@@AAEXPAVVertexStream@gfxu@@@Z PROC ; std::shared_ptr<gfxu::VertexStream>::_Resetp<gfxu::VertexStream>, COMDAT
; _this$ = ecx

; 708  : 		void _Resetp(_Ux *_Px)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Resetp@VVertexStream@gfxu@@@?$shared_ptr@VVertexStream@gfxu@@@std@@AAEXPAVVertexStream@gfxu@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002b	8b f9		 mov	 edi, ecx
  0002d	89 7d ec	 mov	 DWORD PTR _this$1$[ebp], edi

; 709  : 		{	// release, take ownership of _Px
; 710  : 		_TRY_BEGIN	// allocate control block and reset
; 711  : 		_Resetp0(_Px, new _Ref_count<_Ux>(_Px));

  00030	6a 10		 push	 16			; 00000010H
  00032	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  00039	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new

; 155  : 		{	// construct

  0003e	8b 5d 08	 mov	 ebx, DWORD PTR __Px$[ebp]

; 709  : 		{	// release, take ownership of _Px
; 710  : 		_TRY_BEGIN	// allocate control block and reset
; 711  : 		_Resetp0(_Px, new _Ref_count<_Ux>(_Px));

  00041	8b f0		 mov	 esi, eax
  00043	83 c4 04	 add	 esp, 4
  00046	85 f6		 test	 esi, esi
  00048	74 19		 je	 SHORT $LN4@Resetp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xatomic0.h

; 219  : 	_Counter = _Value;

  0004a	c7 46 04 01 00
	00 00		 mov	 DWORD PTR [esi+4], 1
  00051	c7 46 08 01 00
	00 00		 mov	 DWORD PTR [esi+8], 1
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 155  : 		{	// construct

  00058	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$_Ref_count@VVertexStream@gfxu@@@std@@6B@
  0005e	89 5e 0c	 mov	 DWORD PTR [esi+12], ebx

; 709  : 		{	// release, take ownership of _Px
; 710  : 		_TRY_BEGIN	// allocate control block and reset
; 711  : 		_Resetp0(_Px, new _Ref_count<_Ux>(_Px));

  00061	eb 02		 jmp	 SHORT $LN5@Resetp
$LN4@Resetp:
  00063	33 f6		 xor	 esi, esi
$LN5@Resetp:

; 156  : 		}
; 157  : 
; 158  : private:
; 159  : 	virtual void _Destroy()
; 160  : 		{	// destroy managed resource
; 161  : 		delete _Ptr;
; 162  : 		}
; 163  : 
; 164  : 	virtual void _Delete_this()
; 165  : 		{	// destroy self
; 166  : 		delete this;
; 167  : 		}
; 168  : 
; 169  : 	_Ty * _Ptr;
; 170  : 	};
; 171  : 
; 172  : 	// TEMPLATE CLASS _Ref_count_del
; 173  : template<class _Ty,
; 174  : 	class _Dx>
; 175  : 	class _Ref_count_del
; 176  : 	: public _Ref_count_base
; 177  : 	{	// handle reference counting for object with deleter
; 178  : public:
; 179  : 	_Ref_count_del(_Ty *_Px, _Dx _Dt)
; 180  : 		: _Ref_count_base(), _Ptr(_Px), _Dtor(_Dt)
; 181  : 		{	// construct
; 182  : 		}
; 183  : 
; 184  : 	virtual void *_Get_deleter(const _XSTD2 type_info& _Typeid) const
; 185  : 		{	// return address of deleter object
; 186  : 		return ((void *)(_Typeid == typeid(_Dx) ? &_Dtor : 0));
; 187  : 		}
; 188  : 
; 189  : private:
; 190  : 	virtual void _Destroy()
; 191  : 		{	// destroy managed resource
; 192  : 		_Dtor(_Ptr);
; 193  : 		}
; 194  : 
; 195  : 	virtual void _Delete_this()
; 196  : 		{	// destroy self
; 197  : 		delete this;
; 198  : 		}
; 199  : 
; 200  : 	_Ty * _Ptr;
; 201  : 	_Dx _Dtor;	// the stored destructor for the controlled object
; 202  : 	};
; 203  : 
; 204  : 	// TEMPLATE CLASS _Ref_count_del_alloc
; 205  : template<class _Ty,
; 206  : 	class _Dx,
; 207  : 	class _Alloc>
; 208  : 	class _Ref_count_del_alloc
; 209  : 	: public _Ref_count_base
; 210  : 	{	// handle reference counting for object with deleter and allocator
; 211  : public:
; 212  : 	typedef _Ref_count_del_alloc<_Ty, _Dx, _Alloc> _Myty;
; 213  : 	typedef typename _Alloc::template rebind<_Myty>::other _Myalty;
; 214  : 
; 215  : 	_Ref_count_del_alloc(_Ty *_Px, _Dx _Dt, _Myalty _Al)
; 216  : 		: _Ref_count_base(), _Ptr(_Px), _Dtor(_Dt), _Myal(_Al)
; 217  : 		{	// construct
; 218  : 		}
; 219  : 
; 220  : 	virtual void *_Get_deleter(const _XSTD2 type_info& _Typeid) const
; 221  : 		{	// return address of deleter object
; 222  : 		return ((void *)(_Typeid == typeid(_Dx) ? &_Dtor : 0));
; 223  : 		}
; 224  : 
; 225  : private:
; 226  : 	virtual void _Destroy()
; 227  : 		{	// destroy managed resource
; 228  : 		_Dtor(_Ptr);
; 229  : 		}
; 230  : 
; 231  : 	virtual void _Delete_this()
; 232  : 		{	// destroy self
; 233  : 		_Myalty _Al = _Myal;
; 234  : 		_Al.destroy(this);
; 235  : 		_Al.deallocate(this, 1);
; 236  : 		}
; 237  : 
; 238  : 	_Ty * _Ptr;
; 239  : 	_Dx _Dtor;	// the stored destructor for the controlled object
; 240  : 	_Myalty _Myal;	// the stored allocator for this
; 241  : 	};
; 242  : 
; 243  : 	// DECLARATIONS
; 244  : template<class _Ty>
; 245  : 	class weak_ptr;
; 246  : template<class _Ty>
; 247  : 	class shared_ptr;
; 248  : template<class _Ty>
; 249  : 	class enable_shared_from_this;
; 250  : struct _Static_tag {};
; 251  : struct _Const_tag {};
; 252  : struct _Dynamic_tag {};
; 253  : template<class _Ty1,
; 254  : 	class _Ty2>
; 255  : 	void _Do_enable(_Ty1 *, enable_shared_from_this<_Ty2> *,
; 256  : 		_Ref_count_base *);
; 257  : 
; 258  : template<class _Ty>
; 259  : 	inline void _Enable_shared(_Ty *_Ptr, _Ref_count_base *_Refptr,
; 260  : 		typename _Ty::_EStype * = 0)
; 261  : 	{	// reset internal weak pointer
; 262  : 	if (_Ptr)
; 263  : 		_Do_enable(_Ptr,
; 264  : 			(enable_shared_from_this<typename _Ty::_EStype>*)_Ptr, _Refptr);
; 265  : 	}
; 266  : 
; 267  : inline void _Enable_shared(const volatile void *, const volatile void *)
; 268  : 	{	// not derived from enable_shared_from_this; do nothing
; 269  : 	}
; 270  : 
; 271  : 	// TEMPLATE CLASS _Ptr_base
; 272  : template<class _Ty>
; 273  : 	class _Ptr_base
; 274  : 	{	// base class for shared_ptr and weak_ptr
; 275  : public:
; 276  : 	typedef _Ptr_base<_Ty> _Myt;
; 277  : 	typedef _Ty _Elem;
; 278  : 	typedef _Elem element_type;
; 279  : 
; 280  : 	_Ptr_base()
; 281  : 		: _Ptr(0), _Rep(0)
; 282  : 		{	// construct
; 283  : 		}
; 284  : 
; 285  : 	_Ptr_base(_Myt&& _Right)
; 286  : 		: _Ptr(0), _Rep(0)
; 287  : 		{	// construct _Ptr_base object that takes resource from _Right
; 288  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 289  : 		}
; 290  : 
; 291  : 	template<class _Ty2>
; 292  : 		_Ptr_base(_Ptr_base<_Ty2>&& _Right)
; 293  : 		: _Ptr(_Right._Ptr), _Rep(_Right._Rep)
; 294  : 		{	// construct _Ptr_base object that takes resource from _Right
; 295  : 		_Right._Ptr = 0;
; 296  : 		_Right._Rep = 0;
; 297  : 		}
; 298  : 
; 299  : 	_Myt& operator=(_Myt&& _Right)
; 300  : 		{	// construct _Ptr_base object that takes resource from _Right
; 301  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 302  : 		return (*this);
; 303  : 		}
; 304  : 
; 305  : 	void _Assign_rv(_Myt&& _Right)
; 306  : 		{	// assign by moving _Right
; 307  : 		if (this != &_Right)
; 308  : 			_Swap(_Right);
; 309  : 		}
; 310  : 
; 311  : 	long use_count() const _NOEXCEPT
; 312  : 		{	// return use count
; 313  : 		return (_Rep ? _Rep->_Use_count() : 0);
; 314  : 		}
; 315  : 
; 316  : 	void _Swap(_Ptr_base& _Right)
; 317  : 		{	// swap pointers
; 318  : 		_STD swap(_Rep, _Right._Rep);
; 319  : 		_STD swap(_Ptr, _Right._Ptr);
; 320  : 		}
; 321  : 
; 322  : 	template<class _Ty2>
; 323  : 		bool owner_before(const _Ptr_base<_Ty2>& _Right) const
; 324  : 		{	// compare addresses of manager objects
; 325  : 		return (_Rep < _Right._Rep);
; 326  : 		}
; 327  : 
; 328  : 	void *_Get_deleter(const _XSTD2 type_info& _Typeid) const
; 329  : 		{	// return pointer to deleter object if its type is _Typeid
; 330  : 		return (_Rep ? _Rep->_Get_deleter(_Typeid) : 0);
; 331  : 		}
; 332  : 
; 333  : 	_Ty *_Get() const
; 334  : 		{	// return pointer to resource
; 335  : 		return (_Ptr);
; 336  : 		}
; 337  : 
; 338  : 	bool _Expired() const
; 339  : 		{	// test if expired
; 340  : 		return (!_Rep || _Rep->_Expired());
; 341  : 		}
; 342  : 
; 343  : 	void _Decref()
; 344  : 		{	// decrement reference count
; 345  : 		if (_Rep != 0)
; 346  : 			_Rep->_Decref();
; 347  : 		}
; 348  : 
; 349  : 	void _Reset()
; 350  : 		{	// release resource
; 351  : 		_Reset(0, 0);
; 352  : 		}
; 353  : 
; 354  : 	template<class _Ty2>
; 355  : 		void _Reset(const _Ptr_base<_Ty2>& _Other)
; 356  : 		{	// release resource and take ownership of _Other._Ptr
; 357  : 		_Reset(_Other._Ptr, _Other._Rep);
; 358  : 		}
; 359  : 
; 360  : 	template<class _Ty2>
; 361  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, bool _Throw)
; 362  : 		{	// release resource and take ownership from weak_ptr _Other._Ptr
; 363  : 		_Reset(_Other._Ptr, _Other._Rep, _Throw);
; 364  : 		}
; 365  : 
; 366  : 	template<class _Ty2>
; 367  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Static_tag&)
; 368  : 		{	// release resource and take ownership of _Other._Ptr
; 369  : 		_Reset(static_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 370  : 		}
; 371  : 
; 372  : 	template<class _Ty2>
; 373  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Const_tag&)
; 374  : 		{	// release resource and take ownership of _Other._Ptr
; 375  : 		_Reset(const_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 376  : 		}
; 377  : 
; 378  : 	template<class _Ty2>
; 379  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Dynamic_tag&)
; 380  : 		{	// release resource and take ownership of _Other._Ptr
; 381  : 		_Elem *_Ptr = dynamic_cast<_Elem *>(_Other._Ptr);
; 382  : 		if (_Ptr)
; 383  : 			_Reset(_Ptr, _Other._Rep);
; 384  : 		else
; 385  : 			_Reset();
; 386  : 		}
; 387  : 
; 388  : 	template<class _Ty2>
; 389  : 		void _Reset(auto_ptr<_Ty2>&& _Other)
; 390  : 		{	// release resource and take _Other.get()
; 391  : 		_Ty2 *_Px = _Other.get();
; 392  : 		_Reset0(_Px, new _Ref_count<_Elem>(_Px));
; 393  : 		_Other.release();
; 394  : 		_Enable_shared(_Px, _Rep);
; 395  : 		}
; 396  : 
; 397  :  #if _HAS_CPP0X
; 398  : 	template<class _Ty2>
; 399  : 		void _Reset(_Ty *_Ptr, const _Ptr_base<_Ty2>& _Other)
; 400  : 		{	// release resource and alias _Ptr with _Other_rep
; 401  : 		_Reset(_Ptr, _Other._Rep);
; 402  : 		}
; 403  :  #endif /* _HAS_CPP0X */
; 404  : 
; 405  : 	void _Reset(_Ty *_Other_ptr, _Ref_count_base *_Other_rep)
; 406  : 		{	// release resource and take _Other_ptr through _Other_rep
; 407  : 		if (_Other_rep)
; 408  : 			_Other_rep->_Incref();
; 409  : 		_Reset0(_Other_ptr, _Other_rep);
; 410  : 		}
; 411  : 
; 412  : 	void _Reset(_Ty *_Other_ptr, _Ref_count_base *_Other_rep, bool _Throw)
; 413  : 		{	// take _Other_ptr through _Other_rep from weak_ptr if not expired
; 414  : 			// otherwise, leave in default state if !_Throw,
; 415  : 			// otherwise throw exception
; 416  : 		if (_Other_rep && _Other_rep->_Incref_nz())
; 417  : 			_Reset0(_Other_ptr, _Other_rep);
; 418  : 		else if (_Throw)
; 419  : 			_THROW_NCEE(bad_weak_ptr, 0);
; 420  : 		}
; 421  : 
; 422  : 	void _Reset0(_Ty *_Other_ptr, _Ref_count_base *_Other_rep)
; 423  : 		{	// release resource and take new resource
; 424  : 		if (_Rep != 0)

  00065	8b 7f 04	 mov	 edi, DWORD PTR [edi+4]
  00068	85 ff		 test	 edi, edi
  0006a	74 25		 je	 SHORT $LN29@Resetp

; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  0006c	8d 4f 04	 lea	 ecx, DWORD PTR [edi+4]
  0006f	83 c8 ff	 or	 eax, -1
  00072	f0 0f c1 01	 lock	  xadd	 DWORD PTR [ecx], eax
  00076	75 19		 jne	 SHORT $LN29@Resetp

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  00078	8b 07		 mov	 eax, DWORD PTR [edi]
  0007a	8b cf		 mov	 ecx, edi
  0007c	ff 10		 call	 DWORD PTR [eax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  0007e	8d 47 08	 lea	 eax, DWORD PTR [edi+8]
  00081	83 c9 ff	 or	 ecx, -1
  00084	f0 0f c1 08	 lock	  xadd	 DWORD PTR [eax], ecx
  00088	75 07		 jne	 SHORT $LN29@Resetp

; 128  : 			_Delete_this();

  0008a	8b 07		 mov	 eax, DWORD PTR [edi]
  0008c	8b cf		 mov	 ecx, edi
  0008e	ff 50 04	 call	 DWORD PTR [eax+4]
$LN29@Resetp:

; 425  : 			_Rep->_Decref();
; 426  : 		_Rep = _Other_rep;

  00091	8b 45 ec	 mov	 eax, DWORD PTR _this$1$[ebp]
  00094	89 70 04	 mov	 DWORD PTR [eax+4], esi

; 427  : 		_Ptr = _Other_ptr;

  00097	89 18		 mov	 DWORD PTR [eax], ebx

; 715  : 		_CATCH_END
; 716  : 		}

  00099	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  0009c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000a3	59		 pop	 ecx
  000a4	5f		 pop	 edi
  000a5	5e		 pop	 esi
  000a6	5b		 pop	 ebx
  000a7	8b e5		 mov	 esp, ebp
  000a9	5d		 pop	 ebp
  000aa	c2 04 00	 ret	 4
__catch$??$_Resetp@VVertexStream@gfxu@@@?$shared_ptr@VVertexStream@gfxu@@@std@@AAEXPAVVertexStream@gfxu@@@Z$0:

; 712  : 		_CATCH_ALL	// allocation failed, delete resource
; 713  : 		delete _Px;

  000ad	8b 4d 08	 mov	 ecx, DWORD PTR __Px$[ebp]
  000b0	85 c9		 test	 ecx, ecx
  000b2	74 06		 je	 SHORT $LN6@Resetp
  000b4	8b 01		 mov	 eax, DWORD PTR [ecx]
  000b6	6a 01		 push	 1
  000b8	ff 10		 call	 DWORD PTR [eax]
$LN6@Resetp:

; 714  : 		_RERAISE;

  000ba	6a 00		 push	 0
  000bc	6a 00		 push	 0
  000be	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN36@Resetp:
$LN35@Resetp:
  000c3	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Resetp@VVertexStream@gfxu@@@?$shared_ptr@VVertexStream@gfxu@@@std@@AAEXPAVVertexStream@gfxu@@@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Resetp@VVertexStream@gfxu@@@?$shared_ptr@VVertexStream@gfxu@@@std@@AAEXPAVVertexStream@gfxu@@@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Resetp@VVertexStream@gfxu@@@?$shared_ptr@VVertexStream@gfxu@@@std@@AAEXPAVVertexStream@gfxu@@@Z ENDP ; std::shared_ptr<gfxu::VertexStream>::_Resetp<gfxu::VertexStream>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@V?$shared_ptr@VChunkBase@@@std@@@?$allocator_traits@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@SAXAAV?$allocator@V?$shared_ptr@VChunkBase@@@std@@@1@PAV?$shared_ptr@VChunkBase@@@1@@Z
_TEXT	SEGMENT
??$destroy@V?$shared_ptr@VChunkBase@@@std@@@?$allocator_traits@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@SAXAAV?$allocator@V?$shared_ptr@VChunkBase@@@std@@@1@PAV?$shared_ptr@VChunkBase@@@1@@Z PROC ; std::allocator_traits<std::allocator<std::shared_ptr<ChunkBase> > >::destroy<std::shared_ptr<ChunkBase> >, COMDAT
; __Al$dead$ = ecx
; __Ptr$ = edx

; 755  : 		static void destroy(_Alloc& _Al, _Uty *_Ptr)

  00000	56		 push	 esi
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  00001	8b 72 04	 mov	 esi, DWORD PTR [edx+4]
  00004	85 f6		 test	 esi, esi
  00006	74 29		 je	 SHORT $LN16@destroy
  00008	57		 push	 edi

; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  00009	83 cf ff	 or	 edi, -1
  0000c	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  0000f	8b c7		 mov	 eax, edi
  00011	f0 0f c1 01	 lock	  xadd	 DWORD PTR [ecx], eax
  00015	75 19		 jne	 SHORT $LN19@destroy

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  00017	8b 06		 mov	 eax, DWORD PTR [esi]
  00019	8b ce		 mov	 ecx, esi
  0001b	ff 10		 call	 DWORD PTR [eax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  0001d	8d 46 08	 lea	 eax, DWORD PTR [esi+8]
  00020	f0 0f c1 38	 lock	  xadd	 DWORD PTR [eax], edi
  00024	4f		 dec	 edi
  00025	75 09		 jne	 SHORT $LN19@destroy

; 128  : 			_Delete_this();

  00027	8b 06		 mov	 eax, DWORD PTR [esi]
  00029	5f		 pop	 edi
  0002a	8b ce		 mov	 ecx, esi
  0002c	5e		 pop	 esi
  0002d	ff 60 04	 jmp	 DWORD PTR [eax+4]
$LN19@destroy:
  00030	5f		 pop	 edi
$LN16@destroy:
  00031	5e		 pop	 esi
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 758  : 		}

  00032	c3		 ret	 0
??$destroy@V?$shared_ptr@VChunkBase@@@std@@@?$allocator_traits@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@SAXAAV?$allocator@V?$shared_ptr@VChunkBase@@@std@@@1@PAV?$shared_ptr@VChunkBase@@@1@@Z ENDP ; std::allocator_traits<std::allocator<std::shared_ptr<ChunkBase> > >::destroy<std::shared_ptr<ChunkBase> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\type_traits
;	COMDAT ??$forward@ABV?$shared_ptr@VChunkBase@@@std@@@std@@YAABV?$shared_ptr@VChunkBase@@@0@ABV10@@Z
_TEXT	SEGMENT
??$forward@ABV?$shared_ptr@VChunkBase@@@std@@@std@@YAABV?$shared_ptr@VChunkBase@@@0@ABV10@@Z PROC ; std::forward<std::shared_ptr<ChunkBase> const &>, COMDAT
; __Arg$ = ecx

; 1776 : 	return (static_cast<_Ty&&>(_Arg));

  00000	8b c1		 mov	 eax, ecx

; 1777 : 	}

  00002	c3		 ret	 0
??$forward@ABV?$shared_ptr@VChunkBase@@@std@@@std@@YAABV?$shared_ptr@VChunkBase@@@0@ABV10@@Z ENDP ; std::forward<std::shared_ptr<ChunkBase> const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@V?$shared_ptr@VChunkBase@@@std@@ABV12@@?$allocator_traits@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@SAXAAV?$allocator@V?$shared_ptr@VChunkBase@@@std@@@1@PAV?$shared_ptr@VChunkBase@@@1@ABV31@@Z
_TEXT	SEGMENT
__V0$ = 8						; size = 4
??$construct@V?$shared_ptr@VChunkBase@@@std@@ABV12@@?$allocator_traits@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@SAXAAV?$allocator@V?$shared_ptr@VChunkBase@@@std@@@1@PAV?$shared_ptr@VChunkBase@@@1@ABV31@@Z PROC ; std::allocator_traits<std::allocator<std::shared_ptr<ChunkBase> > >::construct<std::shared_ptr<ChunkBase>,std::shared_ptr<ChunkBase> const &>, COMDAT
; __Al$dead$ = ecx
; __Ptr$ = edx

; 751  : _VARIADIC_EXPAND_0X(_ALLOC_TRAITS_SPECIAL_CONSTRUCT, , , , )

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 606  : 		::new ((void *)_Ptr) _Ty(_Val);

  00003	85 d2		 test	 edx, edx
  00005	74 0a		 je	 SHORT $LN7@construct
  00007	ff 75 08	 push	 DWORD PTR __V0$[ebp]
  0000a	8b ca		 mov	 ecx, edx
  0000c	e8 00 00 00 00	 call	 ??0?$shared_ptr@VChunkBase@@@std@@QAE@ABV01@@Z ; std::shared_ptr<ChunkBase>::shared_ptr<ChunkBase>
$LN7@construct:

; 751  : _VARIADIC_EXPAND_0X(_ALLOC_TRAITS_SPECIAL_CONSTRUCT, , , , )

  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$construct@V?$shared_ptr@VChunkBase@@@std@@ABV12@@?$allocator_traits@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@SAXAAV?$allocator@V?$shared_ptr@VChunkBase@@@std@@@1@PAV?$shared_ptr@VChunkBase@@@1@ABV31@@Z ENDP ; std::allocator_traits<std::allocator<std::shared_ptr<ChunkBase> > >::construct<std::shared_ptr<ChunkBase>,std::shared_ptr<ChunkBase> const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\type_traits
;	COMDAT ??$_Move@AAPAV_Ref_count_base@std@@@std@@YA$$QAPAV_Ref_count_base@0@AAPAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$_Move@AAPAV_Ref_count_base@std@@@std@@YA$$QAPAV_Ref_count_base@0@AAPAV10@@Z PROC ; std::_Move<std::_Ref_count_base * &>, COMDAT

; 1798 : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1799 : 	return ((typename remove_reference<_Ty>::type&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1800 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Move@AAPAV_Ref_count_base@std@@@std@@YA$$QAPAV_Ref_count_base@0@AAPAV10@@Z ENDP ; std::_Move<std::_Ref_count_base * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\type_traits
;	COMDAT ??$_Move@AAPAVVertexStream@gfxu@@@std@@YA$$QAPAVVertexStream@gfxu@@AAPAV12@@Z
_TEXT	SEGMENT
??$_Move@AAPAVVertexStream@gfxu@@@std@@YA$$QAPAVVertexStream@gfxu@@AAPAV12@@Z PROC ; std::_Move<gfxu::VertexStream * &>, COMDAT
; __Arg$ = ecx

; 1799 : 	return ((typename remove_reference<_Ty>::type&&)_Arg);

  00000	8b c1		 mov	 eax, ecx

; 1800 : 	}

  00002	c3		 ret	 0
??$_Move@AAPAVVertexStream@gfxu@@@std@@YA$$QAPAVVertexStream@gfxu@@AAPAV12@@Z ENDP ; std::_Move<gfxu::VertexStream * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$?0V?$shared_ptr@VChunkBase@@@std@@@?$allocator@PAV?$shared_ptr@VChunkBase@@@std@@@std@@QAE@ABV?$allocator@V?$shared_ptr@VChunkBase@@@std@@@1@@Z
_TEXT	SEGMENT
___formal$dead$ = 8					; size = 4
??$?0V?$shared_ptr@VChunkBase@@@std@@@?$allocator@PAV?$shared_ptr@VChunkBase@@@std@@@std@@QAE@ABV?$allocator@V?$shared_ptr@VChunkBase@@@std@@@1@@Z PROC ; std::allocator<std::shared_ptr<ChunkBase> *>::allocator<std::shared_ptr<ChunkBase> *><std::shared_ptr<ChunkBase> >, COMDAT
; _this$ = ecx

; 575  : 		{	// construct from a related allocator (do nothing)
; 576  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c2 04 00	 ret	 4
??$?0V?$shared_ptr@VChunkBase@@@std@@@?$allocator@PAV?$shared_ptr@VChunkBase@@@std@@@std@@QAE@ABV?$allocator@V?$shared_ptr@VChunkBase@@@std@@@1@@Z ENDP ; std::allocator<std::shared_ptr<ChunkBase> *>::allocator<std::shared_ptr<ChunkBase> *><std::shared_ptr<ChunkBase> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??$_Ptr_cat@PAV?$shared_ptr@VChunkBase@@@std@@PAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAV?$shared_ptr@VChunkBase@@@0@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
??$_Ptr_cat@PAV?$shared_ptr@VChunkBase@@@std@@PAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAV?$shared_ptr@VChunkBase@@@0@0@Z PROC ; std::_Ptr_cat<std::shared_ptr<ChunkBase> *,std::shared_ptr<ChunkBase> *>, COMDAT
; ___formal$dead$ = ecx
; ___formal$dead$ = edx

; 437  : 	{	// return pointer category from pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 438  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::type _Cat;
; 439  : 	return (_Cat);

  00004	8a 45 ff	 mov	 al, BYTE PTR __Cat$[ebp]

; 440  : 	}

  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
??$_Ptr_cat@PAV?$shared_ptr@VChunkBase@@@std@@PAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAV?$shared_ptr@VChunkBase@@@0@0@Z ENDP ; std::_Ptr_cat<std::shared_ptr<ChunkBase> *,std::shared_ptr<ChunkBase> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory
;	COMDAT ??$_Uninit_copy@PAV?$shared_ptr@VChunkBase@@@std@@PAV12@@std@@YAPAPAV?$shared_ptr@VChunkBase@@@0@PAPAV10@00AAU?$_Wrap_alloc@V?$allocator@PAV?$shared_ptr@VChunkBase@@@std@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
___formal$dead$ = 12					; size = 4
___formal$ = 16						; size = 1
??$_Uninit_copy@PAV?$shared_ptr@VChunkBase@@@std@@PAV12@@std@@YAPAPAV?$shared_ptr@VChunkBase@@@0@PAPAV10@00AAU?$_Wrap_alloc@V?$allocator@PAV?$shared_ptr@VChunkBase@@@std@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_copy<std::shared_ptr<ChunkBase> *,std::shared_ptr<ChunkBase> *>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 401  : 	{	// copy [_First, _Last) to raw _Dest, scalar type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 402  : 	_DEBUG_RANGE(_First, _Last);
; 403  : 	_DEBUG_POINTER(_Dest);
; 404  : 	size_t _Count = (size_t)(_Last - _First);

  00003	2b d1		 sub	 edx, ecx
  00005	56		 push	 esi
  00006	c1 fa 02	 sar	 edx, 2

; 405  : 	return ((_Ty2 *)_CSTD memmove(&*_Dest, &*_First,
; 406  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

  00009	8d 34 95 00 00
	00 00		 lea	 esi, DWORD PTR [edx*4]
  00010	56		 push	 esi
  00011	51		 push	 ecx
  00012	ff 75 08	 push	 DWORD PTR __Dest$[ebp]
  00015	e8 00 00 00 00	 call	 _memmove
  0001a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0001d	03 c6		 add	 eax, esi
  0001f	5e		 pop	 esi

; 407  : 	}

  00020	5d		 pop	 ebp
  00021	c3		 ret	 0
??$_Uninit_copy@PAV?$shared_ptr@VChunkBase@@@std@@PAV12@@std@@YAPAPAV?$shared_ptr@VChunkBase@@@0@PAPAV10@00AAU?$_Wrap_alloc@V?$allocator@PAV?$shared_ptr@VChunkBase@@@std@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<std::shared_ptr<ChunkBase> *,std::shared_ptr<ChunkBase> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??$_Val_type@PAPAV?$shared_ptr@VChunkBase@@@std@@@std@@YAPAPAV?$shared_ptr@VChunkBase@@@0@PAPAV10@@Z
_TEXT	SEGMENT
??$_Val_type@PAPAV?$shared_ptr@VChunkBase@@@std@@@std@@YAPAPAV?$shared_ptr@VChunkBase@@@0@PAPAV10@@Z PROC ; std::_Val_type<std::shared_ptr<ChunkBase> * *>, COMDAT
; ___formal$dead$ = ecx

; 711  : 	return (0);

  00000	33 c0		 xor	 eax, eax

; 712  : 	}

  00002	c3		 ret	 0
??$_Val_type@PAPAV?$shared_ptr@VChunkBase@@@std@@@std@@YAPAPAV?$shared_ptr@VChunkBase@@@0@PAPAV10@@Z ENDP ; std::_Val_type<std::shared_ptr<ChunkBase> * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory
;	COMDAT ??$_Uninit_def_fill_n@PAV?$shared_ptr@VChunkBase@@@std@@IPAV12@@std@@YAXPAPAV?$shared_ptr@VChunkBase@@@0@IAAU?$_Wrap_alloc@V?$allocator@PAV?$shared_ptr@VChunkBase@@@std@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
___formal$dead$ = 8					; size = 4
___formal$dead$ = 12					; size = 4
___formal$ = 16						; size = 1
??$_Uninit_def_fill_n@PAV?$shared_ptr@VChunkBase@@@std@@IPAV12@@std@@YAXPAPAV?$shared_ptr@VChunkBase@@@0@IAAU?$_Wrap_alloc@V?$allocator@PAV?$shared_ptr@VChunkBase@@@std@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_def_fill_n<std::shared_ptr<ChunkBase> *,unsigned int,std::shared_ptr<ChunkBase> *>, COMDAT
; __First$ = ecx
; __Count$ = edx

; 659  : 	{	// copy _Count * _Valty() to raw _First, using _Al, scalar type

  00000	57		 push	 edi
  00001	8b f9		 mov	 edi, ecx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility

; 2678 : 	for (; 0 < _Count; --_Count, ++_Dest)

  00003	85 d2		 test	 edx, edx
  00005	74 06		 je	 SHORT $LN5@Uninit_def
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory

; 660  : 	_Fill_n(_First, _Count, (_Valty)0);

  00007	8b ca		 mov	 ecx, edx
  00009	33 c0		 xor	 eax, eax
  0000b	f3 ab		 rep stosd
$LN5@Uninit_def:
  0000d	5f		 pop	 edi

; 661  : 	}

  0000e	c3		 ret	 0
??$_Uninit_def_fill_n@PAV?$shared_ptr@VChunkBase@@@std@@IPAV12@@std@@YAXPAPAV?$shared_ptr@VChunkBase@@@0@IAAU?$_Wrap_alloc@V?$allocator@PAV?$shared_ptr@VChunkBase@@@std@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_def_fill_n<std::shared_ptr<ChunkBase> *,unsigned int,std::shared_ptr<ChunkBase> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAV?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@YAXPAPAV?$shared_ptr@VChunkBase@@@0@0AAU?$_Wrap_alloc@V?$allocator@PAV?$shared_ptr@VChunkBase@@@std@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__Al$dead$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAV?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@YAXPAPAV?$shared_ptr@VChunkBase@@@0@0AAU?$_Wrap_alloc@V?$allocator@PAV?$shared_ptr@VChunkBase@@@std@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> *> > >, COMDAT
; __First$dead$ = ecx
; __Last$dead$ = edx

; 97   : 	}

  00000	c3		 ret	 0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAV?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@YAXPAPAV?$shared_ptr@VChunkBase@@@0@0AAU?$_Wrap_alloc@V?$allocator@PAV?$shared_ptr@VChunkBase@@@std@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?construct@?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@QAEXPAV?$shared_ptr@VChunkBase@@@2@ABV32@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@QAEXPAV?$shared_ptr@VChunkBase@@@2@ABV32@@Z PROC ; std::allocator<std::shared_ptr<ChunkBase> >::construct, COMDAT
; _this$dead$ = ecx

; 605  : 		{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 606  : 		::new ((void *)_Ptr) _Ty(_Val);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 08		 je	 SHORT $LN3@construct
  0000a	ff 75 0c	 push	 DWORD PTR __Val$[ebp]
  0000d	e8 00 00 00 00	 call	 ??0?$shared_ptr@VChunkBase@@@std@@QAE@ABV01@@Z ; std::shared_ptr<ChunkBase>::shared_ptr<ChunkBase>
$LN3@construct:

; 607  : 		}

  00012	5d		 pop	 ebp
  00013	c2 08 00	 ret	 8
?construct@?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@QAEXPAV?$shared_ptr@VChunkBase@@@2@ABV32@@Z ENDP ; std::allocator<std::shared_ptr<ChunkBase> >::construct
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xatomic0.h
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ??0?$_Ref_count@VVertexStream@gfxu@@@std@@QAE@PAVVertexStream@gfxu@@@Z
_TEXT	SEGMENT
__Px$ = 8						; size = 4
??0?$_Ref_count@VVertexStream@gfxu@@@std@@QAE@PAVVertexStream@gfxu@@@Z PROC ; std::_Ref_count<gfxu::VertexStream>::_Ref_count<gfxu::VertexStream>, COMDAT
; _this$ = ecx

; 155  : 		{	// construct

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Px$[ebp]
  00006	89 41 0c	 mov	 DWORD PTR [ecx+12], eax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xatomic0.h

; 219  : 	_Counter = _Value;

  00009	c7 41 04 01 00
	00 00		 mov	 DWORD PTR [ecx+4], 1
  00010	c7 41 08 01 00
	00 00		 mov	 DWORD PTR [ecx+8], 1
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 155  : 		{	// construct

  00017	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7?$_Ref_count@VVertexStream@gfxu@@@std@@6B@

; 156  : 		}

  0001d	8b c1		 mov	 eax, ecx
  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
??0?$_Ref_count@VVertexStream@gfxu@@@std@@QAE@PAVVertexStream@gfxu@@@Z ENDP ; std::_Ref_count<gfxu::VertexStream>::_Ref_count<gfxu::VertexStream>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ?_Destroy@?$_Ref_count@VVertexStream@gfxu@@@std@@EAEXXZ
_TEXT	SEGMENT
?_Destroy@?$_Ref_count@VVertexStream@gfxu@@@std@@EAEXXZ PROC ; std::_Ref_count<gfxu::VertexStream>::_Destroy, COMDAT
; _this$ = ecx

; 161  : 		delete _Ptr;

  00000	8b 49 0c	 mov	 ecx, DWORD PTR [ecx+12]
  00003	85 c9		 test	 ecx, ecx
  00005	74 06		 je	 SHORT $LN3@Destroy
  00007	8b 01		 mov	 eax, DWORD PTR [ecx]
  00009	6a 01		 push	 1
  0000b	ff 10		 call	 DWORD PTR [eax]
$LN3@Destroy:

; 162  : 		}

  0000d	c3		 ret	 0
?_Destroy@?$_Ref_count@VVertexStream@gfxu@@@std@@EAEXXZ ENDP ; std::_Ref_count<gfxu::VertexStream>::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ?_Delete_this@?$_Ref_count@VVertexStream@gfxu@@@std@@EAEXXZ
_TEXT	SEGMENT
?_Delete_this@?$_Ref_count@VVertexStream@gfxu@@@std@@EAEXXZ PROC ; std::_Ref_count<gfxu::VertexStream>::_Delete_this, COMDAT
; _this$ = ecx

; 166  : 		delete this;

  00000	85 c9		 test	 ecx, ecx
  00002	74 07		 je	 SHORT $LN3@Delete_thi
  00004	8b 01		 mov	 eax, DWORD PTR [ecx]
  00006	6a 01		 push	 1
  00008	ff 50 08	 call	 DWORD PTR [eax+8]
$LN3@Delete_thi:

; 167  : 		}

  0000b	c3		 ret	 0
?_Delete_this@?$_Ref_count@VVertexStream@gfxu@@@std@@EAEXXZ ENDP ; std::_Ref_count<gfxu::VertexStream>::_Delete_this
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ??_G?$_Ref_count@VVertexStream@gfxu@@@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$_Ref_count@VVertexStream@gfxu@@@std@@UAEPAXI@Z PROC ; std::_Ref_count<gfxu::VertexStream>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx

; 69   : 		{	// ensure that derived classes can be destroyed properly

  0000a	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7_Ref_count_base@std@@6B@
  00010	74 09		 je	 SHORT $LN8@scalar
  00012	56		 push	 esi
  00013	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00018	83 c4 04	 add	 esp, 4
$LN8@scalar:
  0001b	8b c6		 mov	 eax, esi
  0001d	5e		 pop	 esi
  0001e	5d		 pop	 ebp
  0001f	c2 04 00	 ret	 4
??_G?$_Ref_count@VVertexStream@gfxu@@@std@@UAEPAXI@Z ENDP ; std::_Ref_count<gfxu::VertexStream>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ??1?$_Ref_count@VVertexStream@gfxu@@@std@@UAE@XZ
_TEXT	SEGMENT
??1?$_Ref_count@VVertexStream@gfxu@@@std@@UAE@XZ PROC	; std::_Ref_count<gfxu::VertexStream>::~_Ref_count<gfxu::VertexStream>, COMDAT
; _this$ = ecx

; 69   : 		{	// ensure that derived classes can be destroyed properly

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7_Ref_count_base@std@@6B@
  00006	c3		 ret	 0
??1?$_Ref_count@VVertexStream@gfxu@@@std@@UAE@XZ ENDP	; std::_Ref_count<gfxu::VertexStream>::~_Ref_count<gfxu::VertexStream>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ??$_Resetp0@VVertexStream@gfxu@@@?$shared_ptr@VVertexStream@gfxu@@@std@@QAEXPAVVertexStream@gfxu@@PAV_Ref_count_base@1@@Z
_TEXT	SEGMENT
__Px$ = 8						; size = 4
__Rx$ = 12						; size = 4
??$_Resetp0@VVertexStream@gfxu@@@?$shared_ptr@VVertexStream@gfxu@@@std@@QAEXPAVVertexStream@gfxu@@PAV_Ref_count_base@1@@Z PROC ; std::shared_ptr<gfxu::VertexStream>::_Resetp0<gfxu::VertexStream>, COMDAT
; _this$ = ecx

; 752  : 		void _Resetp0(_Ux *_Px, _Ref_count_base *_Rx)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	57		 push	 edi

; 129  : 		}
; 130  : 
; 131  : 	long _Use_count() const
; 132  : 		{	// return use count
; 133  : 		return (_Get_uses());
; 134  : 		}
; 135  : 
; 136  : 	bool _Expired() const
; 137  : 		{	// return true if _Uses == 0
; 138  : 		return (_Get_uses() == 0);
; 139  : 		}
; 140  : 
; 141  : 	virtual void *_Get_deleter(const _XSTD2 type_info&) const
; 142  : 		{	// return address of deleter object
; 143  : 		return (0);
; 144  : 		}
; 145  : 	};
; 146  : 
; 147  : 	// TEMPLATE CLASS _Ref_count
; 148  : template<class _Ty>
; 149  : 	class _Ref_count
; 150  : 	: public _Ref_count_base
; 151  : 	{	// handle reference counting for object without deleter
; 152  : public:
; 153  : 	_Ref_count(_Ty *_Px)
; 154  : 		: _Ref_count_base(), _Ptr(_Px)
; 155  : 		{	// construct
; 156  : 		}
; 157  : 
; 158  : private:
; 159  : 	virtual void _Destroy()
; 160  : 		{	// destroy managed resource
; 161  : 		delete _Ptr;
; 162  : 		}
; 163  : 
; 164  : 	virtual void _Delete_this()
; 165  : 		{	// destroy self
; 166  : 		delete this;
; 167  : 		}
; 168  : 
; 169  : 	_Ty * _Ptr;
; 170  : 	};
; 171  : 
; 172  : 	// TEMPLATE CLASS _Ref_count_del
; 173  : template<class _Ty,
; 174  : 	class _Dx>
; 175  : 	class _Ref_count_del
; 176  : 	: public _Ref_count_base
; 177  : 	{	// handle reference counting for object with deleter
; 178  : public:
; 179  : 	_Ref_count_del(_Ty *_Px, _Dx _Dt)
; 180  : 		: _Ref_count_base(), _Ptr(_Px), _Dtor(_Dt)
; 181  : 		{	// construct
; 182  : 		}
; 183  : 
; 184  : 	virtual void *_Get_deleter(const _XSTD2 type_info& _Typeid) const
; 185  : 		{	// return address of deleter object
; 186  : 		return ((void *)(_Typeid == typeid(_Dx) ? &_Dtor : 0));
; 187  : 		}
; 188  : 
; 189  : private:
; 190  : 	virtual void _Destroy()
; 191  : 		{	// destroy managed resource
; 192  : 		_Dtor(_Ptr);
; 193  : 		}
; 194  : 
; 195  : 	virtual void _Delete_this()
; 196  : 		{	// destroy self
; 197  : 		delete this;
; 198  : 		}
; 199  : 
; 200  : 	_Ty * _Ptr;
; 201  : 	_Dx _Dtor;	// the stored destructor for the controlled object
; 202  : 	};
; 203  : 
; 204  : 	// TEMPLATE CLASS _Ref_count_del_alloc
; 205  : template<class _Ty,
; 206  : 	class _Dx,
; 207  : 	class _Alloc>
; 208  : 	class _Ref_count_del_alloc
; 209  : 	: public _Ref_count_base
; 210  : 	{	// handle reference counting for object with deleter and allocator
; 211  : public:
; 212  : 	typedef _Ref_count_del_alloc<_Ty, _Dx, _Alloc> _Myty;
; 213  : 	typedef typename _Alloc::template rebind<_Myty>::other _Myalty;
; 214  : 
; 215  : 	_Ref_count_del_alloc(_Ty *_Px, _Dx _Dt, _Myalty _Al)
; 216  : 		: _Ref_count_base(), _Ptr(_Px), _Dtor(_Dt), _Myal(_Al)
; 217  : 		{	// construct
; 218  : 		}
; 219  : 
; 220  : 	virtual void *_Get_deleter(const _XSTD2 type_info& _Typeid) const
; 221  : 		{	// return address of deleter object
; 222  : 		return ((void *)(_Typeid == typeid(_Dx) ? &_Dtor : 0));
; 223  : 		}
; 224  : 
; 225  : private:
; 226  : 	virtual void _Destroy()
; 227  : 		{	// destroy managed resource
; 228  : 		_Dtor(_Ptr);
; 229  : 		}
; 230  : 
; 231  : 	virtual void _Delete_this()
; 232  : 		{	// destroy self
; 233  : 		_Myalty _Al = _Myal;
; 234  : 		_Al.destroy(this);
; 235  : 		_Al.deallocate(this, 1);
; 236  : 		}
; 237  : 
; 238  : 	_Ty * _Ptr;
; 239  : 	_Dx _Dtor;	// the stored destructor for the controlled object
; 240  : 	_Myalty _Myal;	// the stored allocator for this
; 241  : 	};
; 242  : 
; 243  : 	// DECLARATIONS
; 244  : template<class _Ty>
; 245  : 	class weak_ptr;
; 246  : template<class _Ty>
; 247  : 	class shared_ptr;
; 248  : template<class _Ty>
; 249  : 	class enable_shared_from_this;
; 250  : struct _Static_tag {};
; 251  : struct _Const_tag {};
; 252  : struct _Dynamic_tag {};
; 253  : template<class _Ty1,
; 254  : 	class _Ty2>
; 255  : 	void _Do_enable(_Ty1 *, enable_shared_from_this<_Ty2> *,
; 256  : 		_Ref_count_base *);
; 257  : 
; 258  : template<class _Ty>
; 259  : 	inline void _Enable_shared(_Ty *_Ptr, _Ref_count_base *_Refptr,
; 260  : 		typename _Ty::_EStype * = 0)
; 261  : 	{	// reset internal weak pointer
; 262  : 	if (_Ptr)
; 263  : 		_Do_enable(_Ptr,
; 264  : 			(enable_shared_from_this<typename _Ty::_EStype>*)_Ptr, _Refptr);
; 265  : 	}
; 266  : 
; 267  : inline void _Enable_shared(const volatile void *, const volatile void *)
; 268  : 	{	// not derived from enable_shared_from_this; do nothing
; 269  : 	}
; 270  : 
; 271  : 	// TEMPLATE CLASS _Ptr_base
; 272  : template<class _Ty>
; 273  : 	class _Ptr_base
; 274  : 	{	// base class for shared_ptr and weak_ptr
; 275  : public:
; 276  : 	typedef _Ptr_base<_Ty> _Myt;
; 277  : 	typedef _Ty _Elem;
; 278  : 	typedef _Elem element_type;
; 279  : 
; 280  : 	_Ptr_base()
; 281  : 		: _Ptr(0), _Rep(0)
; 282  : 		{	// construct
; 283  : 		}
; 284  : 
; 285  : 	_Ptr_base(_Myt&& _Right)
; 286  : 		: _Ptr(0), _Rep(0)
; 287  : 		{	// construct _Ptr_base object that takes resource from _Right
; 288  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 289  : 		}
; 290  : 
; 291  : 	template<class _Ty2>
; 292  : 		_Ptr_base(_Ptr_base<_Ty2>&& _Right)
; 293  : 		: _Ptr(_Right._Ptr), _Rep(_Right._Rep)
; 294  : 		{	// construct _Ptr_base object that takes resource from _Right
; 295  : 		_Right._Ptr = 0;
; 296  : 		_Right._Rep = 0;
; 297  : 		}
; 298  : 
; 299  : 	_Myt& operator=(_Myt&& _Right)
; 300  : 		{	// construct _Ptr_base object that takes resource from _Right
; 301  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 302  : 		return (*this);
; 303  : 		}
; 304  : 
; 305  : 	void _Assign_rv(_Myt&& _Right)
; 306  : 		{	// assign by moving _Right
; 307  : 		if (this != &_Right)
; 308  : 			_Swap(_Right);
; 309  : 		}
; 310  : 
; 311  : 	long use_count() const _NOEXCEPT
; 312  : 		{	// return use count
; 313  : 		return (_Rep ? _Rep->_Use_count() : 0);
; 314  : 		}
; 315  : 
; 316  : 	void _Swap(_Ptr_base& _Right)
; 317  : 		{	// swap pointers
; 318  : 		_STD swap(_Rep, _Right._Rep);
; 319  : 		_STD swap(_Ptr, _Right._Ptr);
; 320  : 		}
; 321  : 
; 322  : 	template<class _Ty2>
; 323  : 		bool owner_before(const _Ptr_base<_Ty2>& _Right) const
; 324  : 		{	// compare addresses of manager objects
; 325  : 		return (_Rep < _Right._Rep);
; 326  : 		}
; 327  : 
; 328  : 	void *_Get_deleter(const _XSTD2 type_info& _Typeid) const
; 329  : 		{	// return pointer to deleter object if its type is _Typeid
; 330  : 		return (_Rep ? _Rep->_Get_deleter(_Typeid) : 0);
; 331  : 		}
; 332  : 
; 333  : 	_Ty *_Get() const
; 334  : 		{	// return pointer to resource
; 335  : 		return (_Ptr);
; 336  : 		}
; 337  : 
; 338  : 	bool _Expired() const
; 339  : 		{	// test if expired
; 340  : 		return (!_Rep || _Rep->_Expired());
; 341  : 		}
; 342  : 
; 343  : 	void _Decref()
; 344  : 		{	// decrement reference count
; 345  : 		if (_Rep != 0)
; 346  : 			_Rep->_Decref();
; 347  : 		}
; 348  : 
; 349  : 	void _Reset()
; 350  : 		{	// release resource
; 351  : 		_Reset(0, 0);
; 352  : 		}
; 353  : 
; 354  : 	template<class _Ty2>
; 355  : 		void _Reset(const _Ptr_base<_Ty2>& _Other)
; 356  : 		{	// release resource and take ownership of _Other._Ptr
; 357  : 		_Reset(_Other._Ptr, _Other._Rep);
; 358  : 		}
; 359  : 
; 360  : 	template<class _Ty2>
; 361  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, bool _Throw)
; 362  : 		{	// release resource and take ownership from weak_ptr _Other._Ptr
; 363  : 		_Reset(_Other._Ptr, _Other._Rep, _Throw);
; 364  : 		}
; 365  : 
; 366  : 	template<class _Ty2>
; 367  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Static_tag&)
; 368  : 		{	// release resource and take ownership of _Other._Ptr
; 369  : 		_Reset(static_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 370  : 		}
; 371  : 
; 372  : 	template<class _Ty2>
; 373  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Const_tag&)
; 374  : 		{	// release resource and take ownership of _Other._Ptr
; 375  : 		_Reset(const_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 376  : 		}
; 377  : 
; 378  : 	template<class _Ty2>
; 379  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Dynamic_tag&)
; 380  : 		{	// release resource and take ownership of _Other._Ptr
; 381  : 		_Elem *_Ptr = dynamic_cast<_Elem *>(_Other._Ptr);
; 382  : 		if (_Ptr)
; 383  : 			_Reset(_Ptr, _Other._Rep);
; 384  : 		else
; 385  : 			_Reset();
; 386  : 		}
; 387  : 
; 388  : 	template<class _Ty2>
; 389  : 		void _Reset(auto_ptr<_Ty2>&& _Other)
; 390  : 		{	// release resource and take _Other.get()
; 391  : 		_Ty2 *_Px = _Other.get();
; 392  : 		_Reset0(_Px, new _Ref_count<_Elem>(_Px));
; 393  : 		_Other.release();
; 394  : 		_Enable_shared(_Px, _Rep);
; 395  : 		}
; 396  : 
; 397  :  #if _HAS_CPP0X
; 398  : 	template<class _Ty2>
; 399  : 		void _Reset(_Ty *_Ptr, const _Ptr_base<_Ty2>& _Other)
; 400  : 		{	// release resource and alias _Ptr with _Other_rep
; 401  : 		_Reset(_Ptr, _Other._Rep);
; 402  : 		}
; 403  :  #endif /* _HAS_CPP0X */
; 404  : 
; 405  : 	void _Reset(_Ty *_Other_ptr, _Ref_count_base *_Other_rep)
; 406  : 		{	// release resource and take _Other_ptr through _Other_rep
; 407  : 		if (_Other_rep)
; 408  : 			_Other_rep->_Incref();
; 409  : 		_Reset0(_Other_ptr, _Other_rep);
; 410  : 		}
; 411  : 
; 412  : 	void _Reset(_Ty *_Other_ptr, _Ref_count_base *_Other_rep, bool _Throw)
; 413  : 		{	// take _Other_ptr through _Other_rep from weak_ptr if not expired
; 414  : 			// otherwise, leave in default state if !_Throw,
; 415  : 			// otherwise throw exception
; 416  : 		if (_Other_rep && _Other_rep->_Incref_nz())
; 417  : 			_Reset0(_Other_ptr, _Other_rep);
; 418  : 		else if (_Throw)
; 419  : 			_THROW_NCEE(bad_weak_ptr, 0);
; 420  : 		}
; 421  : 
; 422  : 	void _Reset0(_Ty *_Other_ptr, _Ref_count_base *_Other_rep)
; 423  : 		{	// release resource and take new resource
; 424  : 		if (_Rep != 0)

  00007	8b 7e 04	 mov	 edi, DWORD PTR [esi+4]
  0000a	85 ff		 test	 edi, edi
  0000c	74 38		 je	 SHORT $LN16@Resetp0
  0000e	53		 push	 ebx

; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  0000f	83 cb ff	 or	 ebx, -1
  00012	8d 57 04	 lea	 edx, DWORD PTR [edi+4]
  00015	8b c3		 mov	 eax, ebx
  00017	f0 0f c1 02	 lock	  xadd	 DWORD PTR [edx], eax
  0001b	75 17		 jne	 SHORT $LN15@Resetp0

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  0001d	8b 07		 mov	 eax, DWORD PTR [edi]
  0001f	8b cf		 mov	 ecx, edi
  00021	ff 10		 call	 DWORD PTR [eax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  00023	8d 47 08	 lea	 eax, DWORD PTR [edi+8]
  00026	f0 0f c1 18	 lock	  xadd	 DWORD PTR [eax], ebx
  0002a	4b		 dec	 ebx
  0002b	75 07		 jne	 SHORT $LN15@Resetp0

; 128  : 			_Delete_this();

  0002d	8b 07		 mov	 eax, DWORD PTR [edi]
  0002f	8b cf		 mov	 ecx, edi
  00031	ff 50 04	 call	 DWORD PTR [eax+4]
$LN15@Resetp0:

; 425  : 			_Rep->_Decref();
; 426  : 		_Rep = _Other_rep;

  00034	8b 45 0c	 mov	 eax, DWORD PTR __Rx$[ebp]
  00037	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 427  : 		_Ptr = _Other_ptr;

  0003a	8b 45 08	 mov	 eax, DWORD PTR __Px$[ebp]
  0003d	5b		 pop	 ebx
  0003e	5f		 pop	 edi
  0003f	89 06		 mov	 DWORD PTR [esi], eax
  00041	5e		 pop	 esi

; 753  : 		{	// release resource and take ownership of _Px
; 754  : 		this->_Reset0(_Px, _Rx);
; 755  : 		_Enable_shared(_Px, _Rx);
; 756  : 		}

  00042	5d		 pop	 ebp
  00043	c2 08 00	 ret	 8
$LN16@Resetp0:

; 425  : 			_Rep->_Decref();
; 426  : 		_Rep = _Other_rep;

  00046	8b 45 0c	 mov	 eax, DWORD PTR __Rx$[ebp]
  00049	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 427  : 		_Ptr = _Other_ptr;

  0004c	8b 45 08	 mov	 eax, DWORD PTR __Px$[ebp]
  0004f	5f		 pop	 edi
  00050	89 06		 mov	 DWORD PTR [esi], eax
  00052	5e		 pop	 esi

; 753  : 		{	// release resource and take ownership of _Px
; 754  : 		this->_Reset0(_Px, _Rx);
; 755  : 		_Enable_shared(_Px, _Rx);
; 756  : 		}

  00053	5d		 pop	 ebp
  00054	c2 08 00	 ret	 8
??$_Resetp0@VVertexStream@gfxu@@@?$shared_ptr@VVertexStream@gfxu@@@std@@QAEXPAVVertexStream@gfxu@@PAV_Ref_count_base@1@@Z ENDP ; std::shared_ptr<gfxu::VertexStream>::_Resetp0<gfxu::VertexStream>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@V?$shared_ptr@VChunkBase@@@std@@@?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@QAEXPAV?$shared_ptr@VChunkBase@@@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@V?$shared_ptr@VChunkBase@@@std@@@?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@QAEXPAV?$shared_ptr@VChunkBase@@@1@@Z PROC ; std::allocator<std::shared_ptr<ChunkBase> >::destroy<std::shared_ptr<ChunkBase> >, COMDAT
; _this$dead$ = ecx

; 621  : 		void destroy(_Uty *_Ptr)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	56		 push	 esi
  00007	8b 70 04	 mov	 esi, DWORD PTR [eax+4]
  0000a	85 f6		 test	 esi, esi
  0000c	74 27		 je	 SHORT $LN14@destroy
  0000e	57		 push	 edi

; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  0000f	83 cf ff	 or	 edi, -1
  00012	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  00015	8b c7		 mov	 eax, edi
  00017	f0 0f c1 01	 lock	  xadd	 DWORD PTR [ecx], eax
  0001b	75 17		 jne	 SHORT $LN17@destroy

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  0001d	8b 06		 mov	 eax, DWORD PTR [esi]
  0001f	8b ce		 mov	 ecx, esi
  00021	ff 10		 call	 DWORD PTR [eax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  00023	8d 46 08	 lea	 eax, DWORD PTR [esi+8]
  00026	f0 0f c1 38	 lock	  xadd	 DWORD PTR [eax], edi
  0002a	4f		 dec	 edi
  0002b	75 07		 jne	 SHORT $LN17@destroy

; 128  : 			_Delete_this();

  0002d	8b 06		 mov	 eax, DWORD PTR [esi]
  0002f	8b ce		 mov	 ecx, esi
  00031	ff 50 04	 call	 DWORD PTR [eax+4]
$LN17@destroy:
  00034	5f		 pop	 edi
$LN14@destroy:
  00035	5e		 pop	 esi
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 624  : 		}

  00036	5d		 pop	 ebp
  00037	c2 04 00	 ret	 4
??$destroy@V?$shared_ptr@VChunkBase@@@std@@@?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@QAEXPAV?$shared_ptr@VChunkBase@@@1@@Z ENDP ; std::allocator<std::shared_ptr<ChunkBase> >::destroy<std::shared_ptr<ChunkBase> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??$_Fill_n@PAPAV?$shared_ptr@VChunkBase@@@std@@IPAV12@@std@@YAPAPAV?$shared_ptr@VChunkBase@@@0@PAPAV10@IABQAV10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$_Fill_n@PAPAV?$shared_ptr@VChunkBase@@@std@@IPAV12@@std@@YAPAPAV?$shared_ptr@VChunkBase@@@0@PAPAV10@IABQAV10@@Z PROC ; std::_Fill_n<std::shared_ptr<ChunkBase> * *,unsigned int,std::shared_ptr<ChunkBase> *>, COMDAT
; __Dest$ = ecx
; __Count$ = edx

; 2677 : 	{	// copy _Val _Count times through [_Dest, ...)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2678 : 	for (; 0 < _Count; --_Count, ++_Dest)

  00003	85 d2		 test	 edx, edx
  00005	74 14		 je	 SHORT $LN9@Fill_n
  00007	56		 push	 esi
  00008	8b 75 08	 mov	 esi, DWORD PTR __Val$[ebp]
  0000b	eb 03 8d 49 00	 npad	 5
$LL3@Fill_n:

; 2679 : 		*_Dest = _Val;

  00010	8b 06		 mov	 eax, DWORD PTR [esi]
  00012	89 01		 mov	 DWORD PTR [ecx], eax
  00014	83 c1 04	 add	 ecx, 4
  00017	4a		 dec	 edx
  00018	75 f6		 jne	 SHORT $LL3@Fill_n
  0001a	5e		 pop	 esi
$LN9@Fill_n:

; 2680 : 	return (_Dest);

  0001b	8b c1		 mov	 eax, ecx

; 2681 : 	}

  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
??$_Fill_n@PAPAV?$shared_ptr@VChunkBase@@@std@@IPAV12@@std@@YAPAPAV?$shared_ptr@VChunkBase@@@0@PAPAV10@IABQAV10@@Z ENDP ; std::_Fill_n<std::shared_ptr<ChunkBase> * *,unsigned int,std::shared_ptr<ChunkBase> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ??_G?$shared_ptr@VChunkBase@@@std@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$dead$ = 8					; size = 4
??_G?$shared_ptr@VChunkBase@@@std@@QAEPAXI@Z PROC	; std::shared_ptr<ChunkBase>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	57		 push	 edi

; 345  : 		if (_Rep != 0)

  00004	8b 7e 04	 mov	 edi, DWORD PTR [esi+4]
  00007	85 ff		 test	 edi, edi
  00009	74 2e		 je	 SHORT $LN17@scalar
  0000b	53		 push	 ebx

; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  0000c	83 cb ff	 or	 ebx, -1
  0000f	8d 57 04	 lea	 edx, DWORD PTR [edi+4]
  00012	8b c3		 mov	 eax, ebx
  00014	f0 0f c1 02	 lock	  xadd	 DWORD PTR [edx], eax
  00018	75 17		 jne	 SHORT $LN16@scalar

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  0001a	8b 07		 mov	 eax, DWORD PTR [edi]
  0001c	8b cf		 mov	 ecx, edi
  0001e	ff 10		 call	 DWORD PTR [eax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  00020	8d 47 08	 lea	 eax, DWORD PTR [edi+8]
  00023	f0 0f c1 18	 lock	  xadd	 DWORD PTR [eax], ebx
  00027	4b		 dec	 ebx
  00028	75 07		 jne	 SHORT $LN16@scalar

; 128  : 			_Delete_this();

  0002a	8b 07		 mov	 eax, DWORD PTR [edi]
  0002c	8b cf		 mov	 ecx, edi
  0002e	ff 50 04	 call	 DWORD PTR [eax+4]
$LN16@scalar:
  00031	5b		 pop	 ebx
  00032	5f		 pop	 edi
  00033	8b c6		 mov	 eax, esi
  00035	5e		 pop	 esi
  00036	c2 04 00	 ret	 4
$LN17@scalar:
  00039	5f		 pop	 edi
  0003a	8b c6		 mov	 eax, esi
  0003c	5e		 pop	 esi
  0003d	c2 04 00	 ret	 4
??_G?$shared_ptr@VChunkBase@@@std@@QAEPAXI@Z ENDP	; std::shared_ptr<ChunkBase>::`scalar deleting destructor'
_TEXT	ENDS
END
