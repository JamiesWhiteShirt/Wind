; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.50727.1 

	TITLE	C:\Users\Glenn\Documents\GitHub\Wind\Project\Wind\Wind\main.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	?camX@@3HA					; camX
PUBLIC	?camY@@3HA					; camY
PUBLIC	??_7?$_Ref_count@VChunk@@@std@@6B@		; std::_Ref_count<Chunk>::`vftable'
PUBLIC	??_R3?$_Ref_count@VChunk@@@std@@8		; std::_Ref_count<Chunk>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$_Ref_count@VChunk@@@std@@8		; std::_Ref_count<Chunk>::`RTTI Base Class Array'
PUBLIC	?prevCamX@@3HA					; prevCamX
PUBLIC	??_R0?AV?$_Ref_count@VChunk@@@std@@@8		; std::_Ref_count<Chunk> `RTTI Type Descriptor'
PUBLIC	?prevCamZ@@3HA					; prevCamZ
PUBLIC	?ticks@@3HA					; ticks
PUBLIC	??_R4?$_Ref_count@VChunk@@@std@@6B@		; std::_Ref_count<Chunk>::`RTTI Complete Object Locator'
PUBLIC	?camZ@@3HA					; camZ
PUBLIC	?prevCamY@@3HA					; prevCamY
PUBLIC	??_R1A@?0A@EA@?$_Ref_count@VChunk@@@std@@8	; std::_Ref_count<Chunk>::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	__imp__TranslateMessage@4:PROC
EXTRN	__imp__PeekMessageW@20:PROC
EXTRN	__imp__DispatchMessageW@4:PROC
?camX@@3HA DD	01H DUP (?)				; camX
?camY@@3HA DD	01H DUP (?)				; camY
?prevCamX@@3HA DD 01H DUP (?)				; prevCamX
?prevCamZ@@3HA DD 01H DUP (?)				; prevCamZ
?ticks@@3HA DD	01H DUP (?)				; ticks
?camZ@@3HA DD	01H DUP (?)				; camZ
?prevCamY@@3HA DD 01H DUP (?)				; prevCamY
_BSS	ENDS
;	COMDAT ??_R1A@?0A@EA@?$_Ref_count@VChunk@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$_Ref_count@VChunk@@@std@@8 DD FLAT:??_R0?AV?$_Ref_count@VChunk@@@std@@@8 ; std::_Ref_count<Chunk>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$_Ref_count@VChunk@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R4?$_Ref_count@VChunk@@@std@@6B@
rdata$r	SEGMENT
??_R4?$_Ref_count@VChunk@@@std@@6B@ DD 00H		; std::_Ref_count<Chunk>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$_Ref_count@VChunk@@@std@@@8
	DD	FLAT:??_R3?$_Ref_count@VChunk@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$_Ref_count@VChunk@@@std@@@8
_DATA	SEGMENT
??_R0?AV?$_Ref_count@VChunk@@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_Ref_count<Chunk> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$_Ref_count@VChunk@@@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R2?$_Ref_count@VChunk@@@std@@8
rdata$r	SEGMENT
??_R2?$_Ref_count@VChunk@@@std@@8 DD FLAT:??_R1A@?0A@EA@?$_Ref_count@VChunk@@@std@@8 ; std::_Ref_count<Chunk>::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@_Ref_count_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$_Ref_count@VChunk@@@std@@8
rdata$r	SEGMENT
??_R3?$_Ref_count@VChunk@@@std@@8 DD 00H		; std::_Ref_count<Chunk>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2?$_Ref_count@VChunk@@@std@@8
rdata$r	ENDS
;	COMDAT ??_7?$_Ref_count@VChunk@@@std@@6B@
CONST	SEGMENT
??_7?$_Ref_count@VChunk@@@std@@6B@ DD FLAT:??_R4?$_Ref_count@VChunk@@@std@@6B@ ; std::_Ref_count<Chunk>::`vftable'
	DD	FLAT:?_Destroy@?$_Ref_count@VChunk@@@std@@EAEXXZ
	DD	FLAT:?_Delete_this@?$_Ref_count@VChunk@@@std@@EAEXXZ
	DD	FLAT:??_E?$_Ref_count@VChunk@@@std@@UAEPAXI@Z
	DD	FLAT:?_Get_deleter@_Ref_count_base@std@@UBEPAXABVtype_info@@@Z
$SG4294941285 DB 'W', 00H, 'i', 00H, 'n', 00H, 'd', 00H, 00H, 00H
PUBLIC	??$_Resetp0@VChunk@@@?$shared_ptr@VChunkBase@@@std@@QAEXPAVChunk@@PAV_Ref_count_base@1@@Z ; std::shared_ptr<ChunkBase>::_Resetp0<Chunk>
PUBLIC	??1?$_Ref_count@VChunk@@@std@@UAE@XZ		; std::_Ref_count<Chunk>::~_Ref_count<Chunk>
PUBLIC	??_G?$_Ref_count@VChunk@@@std@@UAEPAXI@Z	; std::_Ref_count<Chunk>::`scalar deleting destructor'
PUBLIC	?_Delete_this@?$_Ref_count@VChunk@@@std@@EAEXXZ	; std::_Ref_count<Chunk>::_Delete_this
PUBLIC	?_Destroy@?$_Ref_count@VChunk@@@std@@EAEXXZ	; std::_Ref_count<Chunk>::_Destroy
PUBLIC	??0?$_Ref_count@VChunk@@@std@@QAE@PAVChunk@@@Z	; std::_Ref_count<Chunk>::_Ref_count<Chunk>
PUBLIC	??_GChunk@@QAEPAXI@Z				; Chunk::`scalar deleting destructor'
PUBLIC	??$_Resetp@VChunk@@@?$shared_ptr@VChunkBase@@@std@@AAEXPAVChunk@@@Z ; std::shared_ptr<ChunkBase>::_Resetp<Chunk>
PUBLIC	??$move@AAV?$shared_ptr@VChunkBase@@@std@@@std@@YA$$QAV?$shared_ptr@VChunkBase@@@0@AAV10@@Z ; std::move<std::shared_ptr<ChunkBase> &>
PUBLIC	??$?0VChunk@@@?$shared_ptr@VChunkBase@@@std@@QAE@PAVChunk@@@Z ; std::shared_ptr<ChunkBase>::shared_ptr<ChunkBase><Chunk>
PUBLIC	??4?$shared_ptr@VChunkBase@@@std@@QAEAAV01@$$QAV01@@Z ; std::shared_ptr<ChunkBase>::operator=
PUBLIC	?clear@?$List@VMouseAction@@$0BA@@@QAEXXZ	; List<MouseAction,16>::clear
PUBLIC	?getSize@?$List@VMouseAction@@$0BA@@@QAEHXZ	; List<MouseAction,16>::getSize
PUBLIC	??A?$List@VMouseAction@@$0BA@@@QAEAAVMouseAction@@H@Z ; List<MouseAction,16>::operator[]
PUBLIC	?clear@?$List@VKeyboardAction@@$0BA@@@QAEXXZ	; List<KeyboardAction,16>::clear
PUBLIC	??_GGLWindow@@QAEPAXI@Z				; GLWindow::`scalar deleting destructor'
PUBLIC	_WinMain@16
PUBLIC	?mainLoop@@YA_NXZ				; mainLoop
EXTRN	??_E?$_Ref_count@VChunk@@@std@@UAEPAXI@Z:PROC	; std::_Ref_count<Chunk>::`vector deleting destructor'
	ALIGN	4

__Tuple_alloc DB 01H DUP (?)
	ALIGN	4

_ignore	DB	01H DUP (?)
	ALIGN	4

_allocator_arg DB 01H DUP (?)
	ALIGN	4

_piecewise_construct DB 01H DUP (?)
_BSS	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?mainLoop@@YA_NXZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?mainLoop@@YA_NXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?mainLoop@@YA_NXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?mainLoop@@YA_NXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?mainLoop@@YA_NXZ$1
	DD	00H
	DD	FLAT:__unwindfunclet$?mainLoop@@YA_NXZ$5
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Resetp@VChunk@@@?$shared_ptr@VChunkBase@@@std@@AAEXPAVChunk@@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Resetp@VChunk@@@?$shared_ptr@VChunkBase@@@std@@AAEXPAVChunk@@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Resetp@VChunk@@@?$shared_ptr@VChunkBase@@@std@@AAEXPAVChunk@@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$_Resetp@VChunk@@@?$shared_ptr@VChunkBase@@@std@@AAEXPAVChunk@@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Resetp@VChunk@@@?$shared_ptr@VChunkBase@@@std@@AAEXPAVChunk@@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Resetp@VChunk@@@?$shared_ptr@VChunkBase@@@std@@AAEXPAVChunk@@@Z$3
__catchsym$??$_Resetp@VChunk@@@?$shared_ptr@VChunkBase@@@std@@AAEXPAVChunk@@@Z$3 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Resetp@VChunk@@@?$shared_ptr@VChunkBase@@@std@@AAEXPAVChunk@@@Z$0
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\main.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\users\glenn\documents\github\wind\project\wind\wind\main.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\users\glenn\documents\github\wind\project\wind\wind\input.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\users\glenn\documents\github\wind\project\wind\wind\input.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\users\glenn\documents\github\wind\project\wind\wind\main.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\users\glenn\documents\github\wind\project\wind\wind\input.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\users\glenn\documents\github\wind\project\wind\wind\main.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\users\glenn\documents\github\wind\project\wind\wind\main.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\users\glenn\documents\github\wind\project\wind\wind\input.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\users\glenn\documents\github\wind\project\wind\wind\main.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\users\glenn\documents\github\wind\project\wind\wind\input.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\users\glenn\documents\github\wind\project\wind\wind\main.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\users\glenn\documents\github\wind\project\wind\wind\input.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\users\glenn\documents\github\wind\project\wind\wind\main.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\users\glenn\documents\github\wind\project\wind\wind\input.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\users\glenn\documents\github\wind\project\wind\wind\main.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\users\glenn\documents\github\wind\project\wind\wind\input.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\users\glenn\documents\github\wind\project\wind\wind\main.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
; File c:\users\glenn\documents\github\wind\project\wind\wind\main.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
; File c:\users\glenn\documents\github\wind\project\wind\wind\main.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
; File c:\users\glenn\documents\github\wind\project\wind\wind\main.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
; File c:\users\glenn\documents\github\wind\project\wind\wind\main.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
; File c:\users\glenn\documents\github\wind\project\wind\wind\main.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\users\glenn\documents\github\wind\project\wind\wind\input.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\users\glenn\documents\github\wind\project\wind\wind\main.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
; File c:\users\glenn\documents\github\wind\project\wind\wind\main.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
; File c:\users\glenn\documents\github\wind\project\wind\wind\main.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
; File c:\users\glenn\documents\github\wind\project\wind\wind\main.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
; File c:\users\glenn\documents\github\wind\project\wind\wind\main.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
; File c:\users\glenn\documents\github\wind\project\wind\wind\main.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\list.h
; File c:\users\glenn\documents\github\wind\project\wind\wind\main.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\users\glenn\documents\github\wind\project\wind\wind\main.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\users\glenn\documents\github\wind\project\wind\wind\main.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\main.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkloadthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkloadthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\users\glenn\documents\github\wind\project\wind\wind\main.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\users\glenn\documents\github\wind\project\wind\wind\main.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\users\glenn\documents\github\wind\project\wind\wind\main.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\users\glenn\documents\github\wind\project\wind\wind\main.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\users\glenn\documents\github\wind\project\wind\wind\main.cpp
;	COMDAT ?mainLoop@@YA_NXZ
_TEXT	SEGMENT
_ma$2 = -116						; size = 20
$T3 = -96						; size = 8
__real@400921fb54442d18$1$ = -88			; size = 8
tv2540 = -88						; size = 8
tv2528 = -88						; size = 8
tv2522 = -88						; size = 8
tv2516 = -88						; size = 8
tv2510 = -88						; size = 8
tv2504 = -88						; size = 8
tv2492 = -88						; size = 8
tv2486 = -88						; size = 8
tv2480 = -88						; size = 8
tv2474 = -88						; size = 8
tv2335 = -88						; size = 8
$T4 = -88						; size = 8
__real@4066800000000000$1$ = -80			; size = 8
tv2534 = -80						; size = 8
tv2498 = -80						; size = 8
_c$5 = -80						; size = 8
tv2336 = -72						; size = 8
tv2334 = -72						; size = 8
tv2333 = -72						; size = 8
_xLimit$1$ = -68					; size = 4
tv2332 = -64						; size = 8
tv2331 = -64						; size = 8
tv2352 = -60						; size = 4
tv2338 = -56						; size = 8
tv2337 = -56						; size = 8
tv2353 = -52						; size = 4
_xPrevDist$1$ = -48					; size = 4
_xDist$1$ = -44						; size = 4
_yLimit$1$ = -40					; size = 4
_zLimit$1$ = -36					; size = 4
$T6 = -32						; size = 4
$T7 = -32						; size = 4
_j$1$ = -28						; size = 4
_i$1$ = -24						; size = 4
_b$1$ = -20						; size = 4
_k$1$ = -20						; size = 4
_value$1$ = -13						; size = 1
__$EHRec$ = -12						; size = 12
?mainLoop@@YA_NXZ PROC					; mainLoop, COMDAT

; 21   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?mainLoop@@YA_NXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 6c	 sub	 esp, 108		; 0000006cH
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 22   : 	Camera* cam = &GameStates::processedState->cam;

  00028	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?processedState@GameStates@@3PAVGameState@1@A ; GameStates::processedState

; 23   : 
; 24   : 	for(int i = 0; i < Mouse::actions.getSize(); i++)

  0002e	33 db		 xor	 ebx, ebx
  00030	8b f2		 mov	 esi, edx
  00032	39 1d 40 01 00
	00		 cmp	 DWORD PTR ?actions@Mouse@@2V?$List@VMouseAction@@$0BA@@@A+320, ebx
  00038	0f 8e c0 00 00
	00		 jle	 $LN28@mainLoop

; 22   : 	Camera* cam = &GameStates::processedState->cam;

  0003e	bf 00 00 00 00	 mov	 edi, OFFSET ?actions@Mouse@@2V?$List@VMouseAction@@$0BA@@@A ; Mouse::actions
$LL30@mainLoop:

; 25   : 	{
; 26   : 		MouseAction ma = Mouse::actions[i];

  00043	f3 0f 7e 07	 movq	 xmm0, QWORD PTR [edi]
  00047	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  0004a	66 0f d6 45 8c	 movq	 QWORD PTR _ma$2[ebp], xmm0
  0004f	f3 0f 7e 47 08	 movq	 xmm0, QWORD PTR [edi+8]
  00054	66 0f d6 45 94	 movq	 QWORD PTR _ma$2[ebp+8], xmm0

; 27   : 		GameStates::processedState->FOV -= ma.sc * 5;

  00059	8b 4d 94	 mov	 ecx, DWORD PTR _ma$2[ebp+8]
  0005c	f7 d9		 neg	 ecx
  0005e	c1 e1 02	 shl	 ecx, 2
  00061	2b 4d 94	 sub	 ecx, DWORD PTR _ma$2[ebp+8]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 68   : 	return (_Check_C_return(_Mtx_lock(_Mtx)));

  00064	68 00 00 00 00	 push	 OFFSET ?mut@Mouse@@2Vmutex@std@@A ; Mouse::mut
; File c:\users\glenn\documents\github\wind\project\wind\wind\main.cpp

; 27   : 		GameStates::processedState->FOV -= ma.sc * 5;

  00069	01 4a 20	 add	 DWORD PTR [edx+32], ecx
  0006c	89 45 9c	 mov	 DWORD PTR _ma$2[ebp+16], eax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 68   : 	return (_Check_C_return(_Mtx_lock(_Mtx)));

  0006f	e8 00 00 00 00	 call	 __Mtx_lock
  00074	83 c4 04	 add	 esp, 4

; 32   : 	if (_Res != _Thrd_success)

  00077	85 c0		 test	 eax, eax
  00079	74 09		 je	 SHORT $LN51@mainLoop

; 33   : 		_Throw_C_error(_Res);

  0007b	50		 push	 eax
  0007c	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
  00081	83 c4 04	 add	 esp, 4
$LN51@mainLoop:
; File c:\users\glenn\documents\github\wind\project\wind\wind\input.cpp

; 48   : 	bool value = mbs[index];

  00084	a0 00 00 00 00	 mov	 al, BYTE PTR ?mbs@Mouse@@0PA_NA
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 83   : 	return (_Check_C_return(_Mtx_unlock(_Mtx)));

  00089	68 00 00 00 00	 push	 OFFSET ?mut@Mouse@@2Vmutex@std@@A ; Mouse::mut
; File c:\users\glenn\documents\github\wind\project\wind\wind\input.cpp

; 48   : 	bool value = mbs[index];

  0008e	88 45 f3	 mov	 BYTE PTR _value$1$[ebp], al
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 83   : 	return (_Check_C_return(_Mtx_unlock(_Mtx)));

  00091	e8 00 00 00 00	 call	 __Mtx_unlock
  00096	83 c4 04	 add	 esp, 4

; 32   : 	if (_Res != _Thrd_success)

  00099	85 c0		 test	 eax, eax
  0009b	74 09		 je	 SHORT $LN58@mainLoop

; 33   : 		_Throw_C_error(_Res);

  0009d	50		 push	 eax
  0009e	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
  000a3	83 c4 04	 add	 esp, 4
$LN58@mainLoop:
; File c:\users\glenn\documents\github\wind\project\wind\wind\main.cpp

; 28   : 		if(Mouse::getMB(0))

  000a6	80 7d f3 00	 cmp	 BYTE PTR _value$1$[ebp], 0
  000aa	74 3c		 je	 SHORT $LN29@mainLoop

; 29   : 		{
; 30   : 			cam->rot.x -= ma.ry * 0.5f;

  000ac	66 0f 6e 4d 90	 movd	 xmm1, DWORD PTR _ma$2[ebp+4]
  000b1	f3 0f 10 46 10	 movss	 xmm0, DWORD PTR [esi+16]
  000b6	0f 5b c9	 cvtdq2ps xmm1, xmm1
  000b9	f3 0f 59 0d 00
	00 00 00	 mulss	 xmm1, DWORD PTR __real@3f000000
  000c1	f3 0f 5c c1	 subss	 xmm0, xmm1
  000c5	66 0f 6e 4d 8c	 movd	 xmm1, DWORD PTR _ma$2[ebp]

; 31   : 			cam->rot.y -= ma.rx * 0.5f;

  000ca	0f 5b c9	 cvtdq2ps xmm1, xmm1
  000cd	f3 0f 11 46 10	 movss	 DWORD PTR [esi+16], xmm0
  000d2	f3 0f 59 0d 00
	00 00 00	 mulss	 xmm1, DWORD PTR __real@3f000000
  000da	f3 0f 10 46 14	 movss	 xmm0, DWORD PTR [esi+20]
  000df	f3 0f 5c c1	 subss	 xmm0, xmm1
  000e3	f3 0f 11 46 14	 movss	 DWORD PTR [esi+20], xmm0
$LN29@mainLoop:

; 23   : 
; 24   : 	for(int i = 0; i < Mouse::actions.getSize(); i++)

  000e8	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?processedState@GameStates@@3PAVGameState@1@A ; GameStates::processedState
  000ee	43		 inc	 ebx
  000ef	83 c7 14	 add	 edi, 20			; 00000014H
  000f2	3b 1d 40 01 00
	00		 cmp	 ebx, DWORD PTR ?actions@Mouse@@2V?$List@VMouseAction@@$0BA@@@A+320
  000f8	0f 8c 45 ff ff
	ff		 jl	 $LL30@mainLoop
$LN28@mainLoop:

; 32   : 		}
; 33   : 	}
; 34   : 	if(GameStates::processedState->FOV < 5)

  000fe	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  00101	83 f8 05	 cmp	 eax, 5
  00104	7d 09		 jge	 SHORT $LN26@mainLoop

; 35   : 	{
; 36   : 		GameStates::processedState->FOV = 5;

  00106	c7 42 20 05 00
	00 00		 mov	 DWORD PTR [edx+32], 5
  0010d	eb 0e		 jmp	 SHORT $LN24@mainLoop
$LN26@mainLoop:

; 37   : 	}
; 38   : 	else if(GameStates::processedState->FOV > 175)

  0010f	3d af 00 00 00	 cmp	 eax, 175		; 000000afH
  00114	7e 07		 jle	 SHORT $LN24@mainLoop

; 39   : 	{
; 40   : 		GameStates::processedState->FOV = 175;

  00116	c7 42 20 af 00
	00 00		 mov	 DWORD PTR [edx+32], 175	; 000000afH
$LN24@mainLoop:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 68   : 	return (_Check_C_return(_Mtx_lock(_Mtx)));

  0011d	68 00 00 00 00	 push	 OFFSET ?mut@Keyboard@@2Vmutex@std@@A ; Keyboard::mut
  00122	e8 00 00 00 00	 call	 __Mtx_lock
  00127	83 c4 04	 add	 esp, 4

; 32   : 	if (_Res != _Thrd_success)

  0012a	85 c0		 test	 eax, eax
  0012c	74 09		 je	 SHORT $LN67@mainLoop

; 33   : 		_Throw_C_error(_Res);

  0012e	50		 push	 eax
  0012f	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
  00134	83 c4 04	 add	 esp, 4
$LN67@mainLoop:
; File c:\users\glenn\documents\github\wind\project\wind\wind\input.cpp

; 23   : 	bool value = keys[index];

  00137	8a 1d 10 00 00
	00		 mov	 bl, BYTE PTR ?keys@Keyboard@@0PA_NA+16
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 83   : 	return (_Check_C_return(_Mtx_unlock(_Mtx)));

  0013d	68 00 00 00 00	 push	 OFFSET ?mut@Keyboard@@2Vmutex@std@@A ; Keyboard::mut
  00142	e8 00 00 00 00	 call	 __Mtx_unlock
  00147	83 c4 04	 add	 esp, 4

; 32   : 	if (_Res != _Thrd_success)

  0014a	85 c0		 test	 eax, eax
  0014c	74 09		 je	 SHORT $LN74@mainLoop

; 33   : 		_Throw_C_error(_Res);

  0014e	50		 push	 eax
  0014f	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
  00154	83 c4 04	 add	 esp, 4
$LN74@mainLoop:
; File c:\users\glenn\documents\github\wind\project\wind\wind\main.cpp

; 43   : 	float b = Keyboard::getKey(16) ? 0.4f : 0.1f;

  00157	84 db		 test	 bl, bl
  00159	74 0a		 je	 SHORT $LN33@mainLoop
  0015b	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3ecccccd
  00163	eb 08		 jmp	 SHORT $LN592@mainLoop
$LN33@mainLoop:
  00165	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3dcccccd
$LN592@mainLoop:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 68   : 	return (_Check_C_return(_Mtx_lock(_Mtx)));

  0016d	68 00 00 00 00	 push	 OFFSET ?mut@Keyboard@@2Vmutex@std@@A ; Keyboard::mut
; File c:\users\glenn\documents\github\wind\project\wind\wind\main.cpp

; 43   : 	float b = Keyboard::getKey(16) ? 0.4f : 0.1f;

  00172	f3 0f 11 45 ec	 movss	 DWORD PTR _b$1$[ebp], xmm0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 68   : 	return (_Check_C_return(_Mtx_lock(_Mtx)));

  00177	e8 00 00 00 00	 call	 __Mtx_lock
  0017c	83 c4 04	 add	 esp, 4

; 32   : 	if (_Res != _Thrd_success)

  0017f	85 c0		 test	 eax, eax
  00181	74 09		 je	 SHORT $LN83@mainLoop

; 33   : 		_Throw_C_error(_Res);

  00183	50		 push	 eax
  00184	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
  00189	83 c4 04	 add	 esp, 4
$LN83@mainLoop:
; File c:\users\glenn\documents\github\wind\project\wind\wind\input.cpp

; 23   : 	bool value = keys[index];

  0018c	8a 1d 57 00 00
	00		 mov	 bl, BYTE PTR ?keys@Keyboard@@0PA_NA+87
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 83   : 	return (_Check_C_return(_Mtx_unlock(_Mtx)));

  00192	68 00 00 00 00	 push	 OFFSET ?mut@Keyboard@@2Vmutex@std@@A ; Keyboard::mut
  00197	e8 00 00 00 00	 call	 __Mtx_unlock
  0019c	83 c4 04	 add	 esp, 4

; 32   : 	if (_Res != _Thrd_success)

  0019f	85 c0		 test	 eax, eax
  001a1	74 09		 je	 SHORT $LN90@mainLoop

; 33   : 		_Throw_C_error(_Res);

  001a3	50		 push	 eax
  001a4	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
  001a9	83 c4 04	 add	 esp, 4
$LN90@mainLoop:
; File c:\users\glenn\documents\github\wind\project\wind\wind\main.cpp

; 45   : 	if(Keyboard::getKey(87)) //W

  001ac	f2 0f 10 0d 00
	00 00 00	 movsd	 xmm1, QWORD PTR __real@400921fb54442d18
  001b4	f2 0f 10 15 00
	00 00 00	 movsd	 xmm2, QWORD PTR __real@4066800000000000
  001bc	f2 0f 11 4d a8	 movsd	 QWORD PTR __real@400921fb54442d18$1$[ebp], xmm1
  001c1	f2 0f 11 55 b0	 movsd	 QWORD PTR __real@4066800000000000$1$[ebp], xmm2
  001c6	84 db		 test	 bl, bl
  001c8	0f 84 b5 00 00
	00		 je	 $LN23@mainLoop

; 46   : 	{
; 47   : 		cam->pos.x -= b * cos(cam->rot.x * M_PI / 180.0f) * sin(cam->rot.y * M_PI / 180.0f);

  001ce	f3 0f 10 46 10	 movss	 xmm0, DWORD PTR [esi+16]
  001d3	0f 5a c0	 cvtps2pd xmm0, xmm0
  001d6	f2 0f 59 c1	 mulsd	 xmm0, xmm1
  001da	f2 0f 5e c2	 divsd	 xmm0, xmm2
  001de	f2 0f 11 45 c0	 movsd	 QWORD PTR tv2332[ebp], xmm0
  001e3	e8 00 00 00 00	 call	 __libm_sse2_cos_precise
  001e8	66 0f 28 c8	 movapd	 xmm1, xmm0
  001ec	f3 0f 10 45 ec	 movss	 xmm0, DWORD PTR _b$1$[ebp]
  001f1	0f 5a c0	 cvtps2pd xmm0, xmm0
  001f4	f2 0f 59 c8	 mulsd	 xmm1, xmm0
  001f8	f3 0f 10 46 14	 movss	 xmm0, DWORD PTR [esi+20]
  001fd	0f 5a c0	 cvtps2pd xmm0, xmm0
  00200	f2 0f 11 4d b8	 movsd	 QWORD PTR tv2334[ebp], xmm1
  00205	f2 0f 59 45 a8	 mulsd	 xmm0, QWORD PTR __real@400921fb54442d18$1$[ebp]
  0020a	f2 0f 5e 45 b0	 divsd	 xmm0, QWORD PTR __real@4066800000000000$1$[ebp]
  0020f	f2 0f 11 45 c8	 movsd	 QWORD PTR tv2338[ebp], xmm0
  00214	e8 00 00 00 00	 call	 __libm_sse2_sin_precise
  00219	f3 0f 10 0e	 movss	 xmm1, DWORD PTR [esi]
  0021d	f2 0f 59 45 b8	 mulsd	 xmm0, QWORD PTR tv2334[ebp]
  00222	0f 5a c9	 cvtps2pd xmm1, xmm1
  00225	f2 0f 5c c8	 subsd	 xmm1, xmm0

; 48   : 		cam->pos.y += b * sin(cam->rot.x * M_PI / 180.0f);

  00229	f2 0f 10 45 c0	 movsd	 xmm0, QWORD PTR tv2332[ebp]
  0022e	66 0f 5a c9	 cvtpd2ps xmm1, xmm1
  00232	f3 0f 11 0e	 movss	 DWORD PTR [esi], xmm1
  00236	e8 00 00 00 00	 call	 __libm_sse2_sin_precise
  0023b	f3 0f 10 4d ec	 movss	 xmm1, DWORD PTR _b$1$[ebp]
  00240	0f 5a c9	 cvtps2pd xmm1, xmm1
  00243	f2 0f 59 c1	 mulsd	 xmm0, xmm1
  00247	f3 0f 10 4e 04	 movss	 xmm1, DWORD PTR [esi+4]
  0024c	0f 5a c9	 cvtps2pd xmm1, xmm1
  0024f	f2 0f 58 c1	 addsd	 xmm0, xmm1
  00253	0f 57 c9	 xorps	 xmm1, xmm1
  00256	f2 0f 5a c8	 cvtsd2ss xmm1, xmm0

; 49   : 		cam->pos.z += b * cos(cam->rot.x * M_PI / 180.0f) * cos(cam->rot.y * M_PI / 180.0f);

  0025a	f2 0f 10 45 c8	 movsd	 xmm0, QWORD PTR tv2338[ebp]
  0025f	f3 0f 11 4e 04	 movss	 DWORD PTR [esi+4], xmm1
  00264	e8 00 00 00 00	 call	 __libm_sse2_cos_precise
  00269	f3 0f 10 4e 08	 movss	 xmm1, DWORD PTR [esi+8]
  0026e	f2 0f 59 45 b8	 mulsd	 xmm0, QWORD PTR tv2334[ebp]
  00273	0f 5a c9	 cvtps2pd xmm1, xmm1
  00276	f2 0f 58 c1	 addsd	 xmm0, xmm1
  0027a	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  0027e	f3 0f 11 46 08	 movss	 DWORD PTR [esi+8], xmm0
$LN23@mainLoop:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 68   : 	return (_Check_C_return(_Mtx_lock(_Mtx)));

  00283	68 00 00 00 00	 push	 OFFSET ?mut@Keyboard@@2Vmutex@std@@A ; Keyboard::mut
  00288	e8 00 00 00 00	 call	 __Mtx_lock
  0028d	83 c4 04	 add	 esp, 4

; 32   : 	if (_Res != _Thrd_success)

  00290	85 c0		 test	 eax, eax
  00292	74 09		 je	 SHORT $LN99@mainLoop

; 33   : 		_Throw_C_error(_Res);

  00294	50		 push	 eax
  00295	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
  0029a	83 c4 04	 add	 esp, 4
$LN99@mainLoop:
; File c:\users\glenn\documents\github\wind\project\wind\wind\input.cpp

; 23   : 	bool value = keys[index];

  0029d	8a 1d 53 00 00
	00		 mov	 bl, BYTE PTR ?keys@Keyboard@@0PA_NA+83
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 83   : 	return (_Check_C_return(_Mtx_unlock(_Mtx)));

  002a3	68 00 00 00 00	 push	 OFFSET ?mut@Keyboard@@2Vmutex@std@@A ; Keyboard::mut
  002a8	e8 00 00 00 00	 call	 __Mtx_unlock
  002ad	83 c4 04	 add	 esp, 4

; 32   : 	if (_Res != _Thrd_success)

  002b0	85 c0		 test	 eax, eax
  002b2	74 09		 je	 SHORT $LN106@mainLoop

; 33   : 		_Throw_C_error(_Res);

  002b4	50		 push	 eax
  002b5	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
  002ba	83 c4 04	 add	 esp, 4
$LN106@mainLoop:
; File c:\users\glenn\documents\github\wind\project\wind\wind\main.cpp

; 52   : 	if(Keyboard::getKey(83)) //S

  002bd	84 db		 test	 bl, bl
  002bf	0f 84 b3 00 00
	00		 je	 $LN22@mainLoop

; 53   : 	{
; 54   : 		cam->pos.x += b * cos(cam->rot.x * M_PI / 180.0f) * sin(cam->rot.y * M_PI / 180.0f);

  002c5	f3 0f 10 46 10	 movss	 xmm0, DWORD PTR [esi+16]
  002ca	0f 5a c0	 cvtps2pd xmm0, xmm0
  002cd	f2 0f 59 45 a8	 mulsd	 xmm0, QWORD PTR __real@400921fb54442d18$1$[ebp]
  002d2	f2 0f 5e 45 b0	 divsd	 xmm0, QWORD PTR __real@4066800000000000$1$[ebp]
  002d7	f2 0f 11 45 c0	 movsd	 QWORD PTR tv2331[ebp], xmm0
  002dc	e8 00 00 00 00	 call	 __libm_sse2_cos_precise
  002e1	f3 0f 10 4d ec	 movss	 xmm1, DWORD PTR _b$1$[ebp]
  002e6	0f 5a c9	 cvtps2pd xmm1, xmm1
  002e9	f2 0f 59 c1	 mulsd	 xmm0, xmm1
  002ed	f2 0f 11 45 b8	 movsd	 QWORD PTR tv2333[ebp], xmm0
  002f2	f3 0f 10 46 14	 movss	 xmm0, DWORD PTR [esi+20]
  002f7	0f 5a c0	 cvtps2pd xmm0, xmm0
  002fa	f2 0f 59 45 a8	 mulsd	 xmm0, QWORD PTR __real@400921fb54442d18$1$[ebp]
  002ff	f2 0f 5e 45 b0	 divsd	 xmm0, QWORD PTR __real@4066800000000000$1$[ebp]
  00304	f2 0f 11 45 c8	 movsd	 QWORD PTR tv2337[ebp], xmm0
  00309	e8 00 00 00 00	 call	 __libm_sse2_sin_precise
  0030e	f3 0f 10 0e	 movss	 xmm1, DWORD PTR [esi]
  00312	f2 0f 59 45 b8	 mulsd	 xmm0, QWORD PTR tv2333[ebp]
  00317	0f 5a c9	 cvtps2pd xmm1, xmm1
  0031a	f2 0f 58 c1	 addsd	 xmm0, xmm1
  0031e	0f 57 c9	 xorps	 xmm1, xmm1
  00321	f2 0f 5a c8	 cvtsd2ss xmm1, xmm0

; 55   : 		cam->pos.y -= b * sin(cam->rot.x * M_PI / 180.0f);

  00325	f2 0f 10 45 c0	 movsd	 xmm0, QWORD PTR tv2331[ebp]
  0032a	f3 0f 11 0e	 movss	 DWORD PTR [esi], xmm1
  0032e	e8 00 00 00 00	 call	 __libm_sse2_sin_precise
  00333	f3 0f 10 4d ec	 movss	 xmm1, DWORD PTR _b$1$[ebp]
  00338	0f 5a c9	 cvtps2pd xmm1, xmm1
  0033b	f2 0f 59 c1	 mulsd	 xmm0, xmm1
  0033f	f3 0f 10 4e 04	 movss	 xmm1, DWORD PTR [esi+4]
  00344	0f 5a c9	 cvtps2pd xmm1, xmm1
  00347	f2 0f 5c c8	 subsd	 xmm1, xmm0

; 56   : 		cam->pos.z -= b * cos(cam->rot.x * M_PI / 180.0f) * cos(cam->rot.y * M_PI / 180.0f);

  0034b	f2 0f 10 45 c8	 movsd	 xmm0, QWORD PTR tv2337[ebp]
  00350	66 0f 5a c9	 cvtpd2ps xmm1, xmm1
  00354	f3 0f 11 4e 04	 movss	 DWORD PTR [esi+4], xmm1
  00359	e8 00 00 00 00	 call	 __libm_sse2_cos_precise
  0035e	f3 0f 10 4e 08	 movss	 xmm1, DWORD PTR [esi+8]
  00363	f2 0f 59 45 b8	 mulsd	 xmm0, QWORD PTR tv2333[ebp]
  00368	0f 5a c9	 cvtps2pd xmm1, xmm1
  0036b	f2 0f 5c c8	 subsd	 xmm1, xmm0
  0036f	66 0f 5a c1	 cvtpd2ps xmm0, xmm1
  00373	f3 0f 11 46 08	 movss	 DWORD PTR [esi+8], xmm0
$LN22@mainLoop:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 68   : 	return (_Check_C_return(_Mtx_lock(_Mtx)));

  00378	68 00 00 00 00	 push	 OFFSET ?mut@Keyboard@@2Vmutex@std@@A ; Keyboard::mut
  0037d	e8 00 00 00 00	 call	 __Mtx_lock
  00382	83 c4 04	 add	 esp, 4

; 32   : 	if (_Res != _Thrd_success)

  00385	85 c0		 test	 eax, eax
  00387	74 09		 je	 SHORT $LN115@mainLoop

; 33   : 		_Throw_C_error(_Res);

  00389	50		 push	 eax
  0038a	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
  0038f	83 c4 04	 add	 esp, 4
$LN115@mainLoop:
; File c:\users\glenn\documents\github\wind\project\wind\wind\input.cpp

; 23   : 	bool value = keys[index];

  00392	8a 1d 41 00 00
	00		 mov	 bl, BYTE PTR ?keys@Keyboard@@0PA_NA+65
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 83   : 	return (_Check_C_return(_Mtx_unlock(_Mtx)));

  00398	68 00 00 00 00	 push	 OFFSET ?mut@Keyboard@@2Vmutex@std@@A ; Keyboard::mut
  0039d	e8 00 00 00 00	 call	 __Mtx_unlock
  003a2	83 c4 04	 add	 esp, 4

; 32   : 	if (_Res != _Thrd_success)

  003a5	85 c0		 test	 eax, eax
  003a7	74 09		 je	 SHORT $LN122@mainLoop

; 33   : 		_Throw_C_error(_Res);

  003a9	50		 push	 eax
  003aa	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
  003af	83 c4 04	 add	 esp, 4
$LN122@mainLoop:
; File c:\users\glenn\documents\github\wind\project\wind\wind\main.cpp

; 59   : 	if(Keyboard::getKey(65)) //A

  003b2	84 db		 test	 bl, bl
  003b4	74 6a		 je	 SHORT $LN21@mainLoop

; 60   : 	{
; 61   : 		cam->pos.x -= b * cos(cam->rot.y * M_PI / 180.0f);

  003b6	f3 0f 10 4e 14	 movss	 xmm1, DWORD PTR [esi+20]
  003bb	0f 5a c9	 cvtps2pd xmm1, xmm1
  003be	f2 0f 59 4d a8	 mulsd	 xmm1, QWORD PTR __real@400921fb54442d18$1$[ebp]
  003c3	f2 0f 5e 4d b0	 divsd	 xmm1, QWORD PTR __real@4066800000000000$1$[ebp]
  003c8	66 0f 28 c1	 movapd	 xmm0, xmm1
  003cc	f2 0f 11 4d b8	 movsd	 QWORD PTR tv2336[ebp], xmm1
  003d1	e8 00 00 00 00	 call	 __libm_sse2_cos_precise
  003d6	f3 0f 10 4d ec	 movss	 xmm1, DWORD PTR _b$1$[ebp]
  003db	0f 5a c9	 cvtps2pd xmm1, xmm1
  003de	f2 0f 59 c1	 mulsd	 xmm0, xmm1
  003e2	f3 0f 10 0e	 movss	 xmm1, DWORD PTR [esi]
  003e6	0f 5a c9	 cvtps2pd xmm1, xmm1
  003e9	f2 0f 5c c8	 subsd	 xmm1, xmm0

; 62   : 		cam->pos.z -= b * sin(cam->rot.y * M_PI / 180.0f);

  003ed	f2 0f 10 45 b8	 movsd	 xmm0, QWORD PTR tv2336[ebp]
  003f2	66 0f 5a c9	 cvtpd2ps xmm1, xmm1
  003f6	f3 0f 11 0e	 movss	 DWORD PTR [esi], xmm1
  003fa	e8 00 00 00 00	 call	 __libm_sse2_sin_precise
  003ff	f3 0f 10 4d ec	 movss	 xmm1, DWORD PTR _b$1$[ebp]
  00404	0f 5a c9	 cvtps2pd xmm1, xmm1
  00407	f2 0f 59 c1	 mulsd	 xmm0, xmm1
  0040b	f3 0f 10 4e 08	 movss	 xmm1, DWORD PTR [esi+8]
  00410	0f 5a c9	 cvtps2pd xmm1, xmm1
  00413	f2 0f 5c c8	 subsd	 xmm1, xmm0
  00417	66 0f 5a c1	 cvtpd2ps xmm0, xmm1
  0041b	f3 0f 11 46 08	 movss	 DWORD PTR [esi+8], xmm0
$LN21@mainLoop:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 68   : 	return (_Check_C_return(_Mtx_lock(_Mtx)));

  00420	68 00 00 00 00	 push	 OFFSET ?mut@Keyboard@@2Vmutex@std@@A ; Keyboard::mut
  00425	e8 00 00 00 00	 call	 __Mtx_lock
  0042a	83 c4 04	 add	 esp, 4

; 32   : 	if (_Res != _Thrd_success)

  0042d	85 c0		 test	 eax, eax
  0042f	74 09		 je	 SHORT $LN131@mainLoop

; 33   : 		_Throw_C_error(_Res);

  00431	50		 push	 eax
  00432	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
  00437	83 c4 04	 add	 esp, 4
$LN131@mainLoop:
; File c:\users\glenn\documents\github\wind\project\wind\wind\input.cpp

; 23   : 	bool value = keys[index];

  0043a	8a 1d 44 00 00
	00		 mov	 bl, BYTE PTR ?keys@Keyboard@@0PA_NA+68
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 83   : 	return (_Check_C_return(_Mtx_unlock(_Mtx)));

  00440	68 00 00 00 00	 push	 OFFSET ?mut@Keyboard@@2Vmutex@std@@A ; Keyboard::mut
  00445	e8 00 00 00 00	 call	 __Mtx_unlock
  0044a	83 c4 04	 add	 esp, 4

; 32   : 	if (_Res != _Thrd_success)

  0044d	85 c0		 test	 eax, eax
  0044f	74 09		 je	 SHORT $LN138@mainLoop

; 33   : 		_Throw_C_error(_Res);

  00451	50		 push	 eax
  00452	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
  00457	83 c4 04	 add	 esp, 4
$LN138@mainLoop:
; File c:\users\glenn\documents\github\wind\project\wind\wind\main.cpp

; 65   : 	if(Keyboard::getKey(68)) //D

  0045a	84 db		 test	 bl, bl
  0045c	74 69		 je	 SHORT $LN20@mainLoop

; 66   : 	{
; 67   : 		cam->pos.x += b * cos(cam->rot.y * M_PI / 180.0f);

  0045e	f3 0f 10 46 14	 movss	 xmm0, DWORD PTR [esi+20]
  00463	0f 5a c0	 cvtps2pd xmm0, xmm0
  00466	f2 0f 59 45 a8	 mulsd	 xmm0, QWORD PTR __real@400921fb54442d18$1$[ebp]
  0046b	f2 0f 5e 45 b0	 divsd	 xmm0, QWORD PTR __real@4066800000000000$1$[ebp]
  00470	f2 0f 11 45 a8	 movsd	 QWORD PTR tv2335[ebp], xmm0
  00475	e8 00 00 00 00	 call	 __libm_sse2_cos_precise
  0047a	f3 0f 10 4d ec	 movss	 xmm1, DWORD PTR _b$1$[ebp]
  0047f	0f 5a c9	 cvtps2pd xmm1, xmm1
  00482	f2 0f 59 c1	 mulsd	 xmm0, xmm1
  00486	f3 0f 10 0e	 movss	 xmm1, DWORD PTR [esi]
  0048a	0f 5a c9	 cvtps2pd xmm1, xmm1
  0048d	f2 0f 58 c1	 addsd	 xmm0, xmm1
  00491	0f 57 c9	 xorps	 xmm1, xmm1
  00494	f2 0f 5a c8	 cvtsd2ss xmm1, xmm0

; 68   : 		cam->pos.z += b * sin(cam->rot.y * M_PI / 180.0f);

  00498	f2 0f 10 45 a8	 movsd	 xmm0, QWORD PTR tv2335[ebp]
  0049d	f3 0f 11 0e	 movss	 DWORD PTR [esi], xmm1
  004a1	e8 00 00 00 00	 call	 __libm_sse2_sin_precise
  004a6	f3 0f 10 4d ec	 movss	 xmm1, DWORD PTR _b$1$[ebp]
  004ab	0f 5a c9	 cvtps2pd xmm1, xmm1
  004ae	f2 0f 59 c1	 mulsd	 xmm0, xmm1
  004b2	f3 0f 10 4e 08	 movss	 xmm1, DWORD PTR [esi+8]
  004b7	0f 5a c9	 cvtps2pd xmm1, xmm1
  004ba	f2 0f 58 c1	 addsd	 xmm0, xmm1
  004be	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  004c2	f3 0f 11 46 08	 movss	 DWORD PTR [esi+8], xmm0
$LN20@mainLoop:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 68   : 	return (_Check_C_return(_Mtx_lock(_Mtx)));

  004c7	68 00 00 00 00	 push	 OFFSET ?mut@Keyboard@@2Vmutex@std@@A ; Keyboard::mut
  004cc	e8 00 00 00 00	 call	 __Mtx_lock
  004d1	83 c4 04	 add	 esp, 4

; 32   : 	if (_Res != _Thrd_success)

  004d4	85 c0		 test	 eax, eax
  004d6	74 09		 je	 SHORT $LN147@mainLoop

; 33   : 		_Throw_C_error(_Res);

  004d8	50		 push	 eax
  004d9	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
  004de	83 c4 04	 add	 esp, 4
$LN147@mainLoop:
; File c:\users\glenn\documents\github\wind\project\wind\wind\input.cpp

; 23   : 	bool value = keys[index];

  004e1	8a 1d 20 00 00
	00		 mov	 bl, BYTE PTR ?keys@Keyboard@@0PA_NA+32
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 83   : 	return (_Check_C_return(_Mtx_unlock(_Mtx)));

  004e7	68 00 00 00 00	 push	 OFFSET ?mut@Keyboard@@2Vmutex@std@@A ; Keyboard::mut
  004ec	e8 00 00 00 00	 call	 __Mtx_unlock
  004f1	83 c4 04	 add	 esp, 4

; 32   : 	if (_Res != _Thrd_success)

  004f4	85 c0		 test	 eax, eax
  004f6	74 09		 je	 SHORT $LN154@mainLoop

; 33   : 		_Throw_C_error(_Res);

  004f8	50		 push	 eax
  004f9	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
  004fe	83 c4 04	 add	 esp, 4
$LN154@mainLoop:
; File c:\users\glenn\documents\github\wind\project\wind\wind\main.cpp

; 71   : 	if(Keyboard::getKey(32)) //SPACE

  00501	84 db		 test	 bl, bl
  00503	0f 84 92 00 00
	00		 je	 $LN19@mainLoop
  00509	f3 0f 10 46 08	 movss	 xmm0, DWORD PTR [esi+8]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h

; 416  :         {return ((float)floor((double)_X)); }

  0050e	0f 5a c0	 cvtps2pd xmm0, xmm0
  00511	83 ec 08	 sub	 esp, 8
  00514	f2 0f 11 45 a8	 movsd	 QWORD PTR tv2540[ebp], xmm0
  00519	dd 45 a8	 fld	 QWORD PTR tv2540[ebp]
  0051c	dd 1c 24	 fstp	 QWORD PTR [esp]
  0051f	e8 00 00 00 00	 call	 _floor
  00524	f3 0f 10 46 04	 movss	 xmm0, DWORD PTR [esi+4]
  00529	dd 5d b0	 fstp	 QWORD PTR tv2534[ebp]
  0052c	0f 5a c0	 cvtps2pd xmm0, xmm0
  0052f	f2 0f 11 45 a8	 movsd	 QWORD PTR tv2528[ebp], xmm0
  00534	dd 45 a8	 fld	 QWORD PTR tv2528[ebp]
  00537	dd 1c 24	 fstp	 QWORD PTR [esp]
  0053a	e8 00 00 00 00	 call	 _floor
  0053f	f2 0f 10 4d b0	 movsd	 xmm1, QWORD PTR tv2534[ebp]
  00544	dd 5d a8	 fstp	 QWORD PTR tv2522[ebp]
  00547	f2 0f 10 45 a8	 movsd	 xmm0, QWORD PTR tv2522[ebp]
; File c:\users\glenn\documents\github\wind\project\wind\wind\main.cpp

; 73   : 		GlobalThread::world.setBlock(floorf(cam->pos.x), floorf(cam->pos.y), floorf(cam->pos.z), 1); //SPAAAAAAAAAAAAAACE!

  0054c	66 0f 5a c9	 cvtpd2ps xmm1, xmm1
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h

; 416  :         {return ((float)floor((double)_X)); }

  00550	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
; File c:\users\glenn\documents\github\wind\project\wind\wind\main.cpp

; 73   : 		GlobalThread::world.setBlock(floorf(cam->pos.x), floorf(cam->pos.y), floorf(cam->pos.z), 1); //SPAAAAAAAAAAAAAACE!

  00554	f3 0f 2c c1	 cvttss2si eax, xmm1
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h

; 416  :         {return ((float)floor((double)_X)); }

  00558	83 c4 08	 add	 esp, 8
; File c:\users\glenn\documents\github\wind\project\wind\wind\main.cpp

; 73   : 		GlobalThread::world.setBlock(floorf(cam->pos.x), floorf(cam->pos.y), floorf(cam->pos.z), 1); //SPAAAAAAAAAAAAAACE!

  0055b	6a 01		 push	 1
  0055d	50		 push	 eax
  0055e	f3 0f 2c c0	 cvttss2si eax, xmm0
  00562	f3 0f 10 06	 movss	 xmm0, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h

; 416  :         {return ((float)floor((double)_X)); }

  00566	0f 5a c0	 cvtps2pd xmm0, xmm0
; File c:\users\glenn\documents\github\wind\project\wind\wind\main.cpp

; 73   : 		GlobalThread::world.setBlock(floorf(cam->pos.x), floorf(cam->pos.y), floorf(cam->pos.z), 1); //SPAAAAAAAAAAAAAACE!

  00569	50		 push	 eax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h

; 416  :         {return ((float)floor((double)_X)); }

  0056a	f2 0f 11 45 a8	 movsd	 QWORD PTR tv2516[ebp], xmm0
  0056f	83 ec 08	 sub	 esp, 8
  00572	dd 45 a8	 fld	 QWORD PTR tv2516[ebp]
  00575	dd 1c 24	 fstp	 QWORD PTR [esp]
  00578	e8 00 00 00 00	 call	 _floor
  0057d	dd 5d a8	 fstp	 QWORD PTR tv2510[ebp]
  00580	f2 0f 10 45 a8	 movsd	 xmm0, QWORD PTR tv2510[ebp]
  00585	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  00589	83 c4 08	 add	 esp, 8
; File c:\users\glenn\documents\github\wind\project\wind\wind\main.cpp

; 73   : 		GlobalThread::world.setBlock(floorf(cam->pos.x), floorf(cam->pos.y), floorf(cam->pos.z), 1); //SPAAAAAAAAAAAAAACE!

  0058c	f3 0f 2c c0	 cvttss2si eax, xmm0
  00590	b9 00 00 00 00	 mov	 ecx, OFFSET ?world@GlobalThread@@3VWorld@@A ; GlobalThread::world
  00595	50		 push	 eax
  00596	e8 00 00 00 00	 call	 ?setBlock@World@@QAEXHHHG@Z ; World::setBlock
$LN19@mainLoop:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 68   : 	return (_Check_C_return(_Mtx_lock(_Mtx)));

  0059b	68 00 00 00 00	 push	 OFFSET ?mut@Keyboard@@2Vmutex@std@@A ; Keyboard::mut
  005a0	e8 00 00 00 00	 call	 __Mtx_lock
  005a5	83 c4 04	 add	 esp, 4

; 32   : 	if (_Res != _Thrd_success)

  005a8	85 c0		 test	 eax, eax
  005aa	74 09		 je	 SHORT $LN169@mainLoop

; 33   : 		_Throw_C_error(_Res);

  005ac	50		 push	 eax
  005ad	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
  005b2	83 c4 04	 add	 esp, 4
$LN169@mainLoop:
; File c:\users\glenn\documents\github\wind\project\wind\wind\input.cpp

; 23   : 	bool value = keys[index];

  005b5	8a 1d 11 00 00
	00		 mov	 bl, BYTE PTR ?keys@Keyboard@@0PA_NA+17
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 83   : 	return (_Check_C_return(_Mtx_unlock(_Mtx)));

  005bb	68 00 00 00 00	 push	 OFFSET ?mut@Keyboard@@2Vmutex@std@@A ; Keyboard::mut
  005c0	e8 00 00 00 00	 call	 __Mtx_unlock
  005c5	83 c4 04	 add	 esp, 4

; 32   : 	if (_Res != _Thrd_success)

  005c8	85 c0		 test	 eax, eax
  005ca	74 09		 je	 SHORT $LN176@mainLoop

; 33   : 		_Throw_C_error(_Res);

  005cc	50		 push	 eax
  005cd	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
  005d2	83 c4 04	 add	 esp, 4
$LN176@mainLoop:
; File c:\users\glenn\documents\github\wind\project\wind\wind\main.cpp

; 76   : 	if(Keyboard::getKey(17)) //CTRL

  005d5	84 db		 test	 bl, bl
  005d7	0f 84 92 00 00
	00		 je	 $LN18@mainLoop
  005dd	f3 0f 10 46 08	 movss	 xmm0, DWORD PTR [esi+8]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h

; 416  :         {return ((float)floor((double)_X)); }

  005e2	0f 5a c0	 cvtps2pd xmm0, xmm0
  005e5	83 ec 08	 sub	 esp, 8
  005e8	f2 0f 11 45 a8	 movsd	 QWORD PTR tv2504[ebp], xmm0
  005ed	dd 45 a8	 fld	 QWORD PTR tv2504[ebp]
  005f0	dd 1c 24	 fstp	 QWORD PTR [esp]
  005f3	e8 00 00 00 00	 call	 _floor
  005f8	f3 0f 10 46 04	 movss	 xmm0, DWORD PTR [esi+4]
  005fd	dd 5d b0	 fstp	 QWORD PTR tv2498[ebp]
  00600	0f 5a c0	 cvtps2pd xmm0, xmm0
  00603	f2 0f 11 45 a8	 movsd	 QWORD PTR tv2492[ebp], xmm0
  00608	dd 45 a8	 fld	 QWORD PTR tv2492[ebp]
  0060b	dd 1c 24	 fstp	 QWORD PTR [esp]
  0060e	e8 00 00 00 00	 call	 _floor
  00613	f2 0f 10 4d b0	 movsd	 xmm1, QWORD PTR tv2498[ebp]
  00618	dd 5d a8	 fstp	 QWORD PTR tv2486[ebp]
  0061b	f2 0f 10 45 a8	 movsd	 xmm0, QWORD PTR tv2486[ebp]
; File c:\users\glenn\documents\github\wind\project\wind\wind\main.cpp

; 78   : 		GlobalThread::world.setBlock(floorf(cam->pos.x), floorf(cam->pos.y), floorf(cam->pos.z), 0);

  00620	66 0f 5a c9	 cvtpd2ps xmm1, xmm1
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h

; 416  :         {return ((float)floor((double)_X)); }

  00624	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
; File c:\users\glenn\documents\github\wind\project\wind\wind\main.cpp

; 78   : 		GlobalThread::world.setBlock(floorf(cam->pos.x), floorf(cam->pos.y), floorf(cam->pos.z), 0);

  00628	f3 0f 2c c1	 cvttss2si eax, xmm1
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h

; 416  :         {return ((float)floor((double)_X)); }

  0062c	83 c4 08	 add	 esp, 8
; File c:\users\glenn\documents\github\wind\project\wind\wind\main.cpp

; 78   : 		GlobalThread::world.setBlock(floorf(cam->pos.x), floorf(cam->pos.y), floorf(cam->pos.z), 0);

  0062f	6a 00		 push	 0
  00631	50		 push	 eax
  00632	f3 0f 2c c0	 cvttss2si eax, xmm0
  00636	f3 0f 10 06	 movss	 xmm0, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h

; 416  :         {return ((float)floor((double)_X)); }

  0063a	0f 5a c0	 cvtps2pd xmm0, xmm0
; File c:\users\glenn\documents\github\wind\project\wind\wind\main.cpp

; 78   : 		GlobalThread::world.setBlock(floorf(cam->pos.x), floorf(cam->pos.y), floorf(cam->pos.z), 0);

  0063d	50		 push	 eax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h

; 416  :         {return ((float)floor((double)_X)); }

  0063e	f2 0f 11 45 a8	 movsd	 QWORD PTR tv2480[ebp], xmm0
  00643	83 ec 08	 sub	 esp, 8
  00646	dd 45 a8	 fld	 QWORD PTR tv2480[ebp]
  00649	dd 1c 24	 fstp	 QWORD PTR [esp]
  0064c	e8 00 00 00 00	 call	 _floor
  00651	dd 5d a8	 fstp	 QWORD PTR tv2474[ebp]
  00654	f2 0f 10 45 a8	 movsd	 xmm0, QWORD PTR tv2474[ebp]
  00659	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  0065d	83 c4 08	 add	 esp, 8
; File c:\users\glenn\documents\github\wind\project\wind\wind\main.cpp

; 78   : 		GlobalThread::world.setBlock(floorf(cam->pos.x), floorf(cam->pos.y), floorf(cam->pos.z), 0);

  00660	f3 0f 2c c0	 cvttss2si eax, xmm0
  00664	b9 00 00 00 00	 mov	 ecx, OFFSET ?world@GlobalThread@@3VWorld@@A ; GlobalThread::world
  00669	50		 push	 eax
  0066a	e8 00 00 00 00	 call	 ?setBlock@World@@QAEXHHHG@Z ; World::setBlock
$LN18@mainLoop:

; 84   : 	camX = cam->pos.x / 16.0f;

  0066f	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@3d800000
; File c:\users\glenn\documents\github\wind\project\wind\wind\list.h

; 37   : 		count = 0;

  00677	c7 05 40 01 00
	00 00 00 00 00	 mov	 DWORD PTR ?actions@Mouse@@2V?$List@VMouseAction@@$0BA@@@A+320, 0
  00681	c7 05 80 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?actions@Keyboard@@2V?$List@VKeyboardAction@@$0BA@@@A+128, 0
; File c:\users\glenn\documents\github\wind\project\wind\wind\main.cpp

; 84   : 	camX = cam->pos.x / 16.0f;

  0068b	f3 0f 10 06	 movss	 xmm0, DWORD PTR [esi]
  0068f	f3 0f 59 c1	 mulss	 xmm0, xmm1

; 85   : 	camY = cam->pos.y / 16.0f;
; 86   : 	camZ = cam->pos.z / 16.0f;
; 87   : 	
; 88   : 	if(camX != prevCamX || camY != prevCamY || camZ != prevCamZ)

  00693	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?prevCamX@@3HA ; prevCamX
  00699	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR ?prevCamZ@@3HA ; prevCamZ
  0069f	f3 0f 2c d0	 cvttss2si edx, xmm0
  006a3	f3 0f 10 46 04	 movss	 xmm0, DWORD PTR [esi+4]
  006a8	f3 0f 59 c1	 mulss	 xmm0, xmm1
  006ac	89 15 00 00 00
	00		 mov	 DWORD PTR ?camX@@3HA, edx ; camX
  006b2	f3 0f 2c c0	 cvttss2si eax, xmm0
  006b6	f3 0f 10 46 08	 movss	 xmm0, DWORD PTR [esi+8]
  006bb	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?prevCamY@@3HA ; prevCamY
  006c1	f3 0f 59 c1	 mulss	 xmm0, xmm1
  006c5	a3 00 00 00 00	 mov	 DWORD PTR ?camY@@3HA, eax ; camY
  006ca	f3 0f 2c c8	 cvttss2si ecx, xmm0
  006ce	89 0d 00 00 00
	00		 mov	 DWORD PTR ?camZ@@3HA, ecx ; camZ
  006d4	3b d7		 cmp	 edx, edi
  006d6	75 0e		 jne	 SHORT $LN593@mainLoop
  006d8	3b c6		 cmp	 eax, esi
  006da	75 08		 jne	 SHORT $LN16@mainLoop
  006dc	3b cb		 cmp	 ecx, ebx
  006de	0f 84 71 06 00
	00		 je	 $LN551@mainLoop
$LN16@mainLoop:

; 90   : 		int xLimit = (camX > prevCamX ? camX : prevCamX) + renderDistance;

  006e4	3b d7		 cmp	 edx, edi
$LN593@mainLoop:
  006e6	0f 4f fa	 cmovg	 edi, edx
  006e9	83 c7 0a	 add	 edi, 10			; 0000000aH

; 91   : 		int yLimit = (camY > prevCamY ? camY : prevCamY) + renderDistance;

  006ec	3b c6		 cmp	 eax, esi
  006ee	0f 4f f0	 cmovg	 esi, eax
  006f1	83 c6 0a	 add	 esi, 10			; 0000000aH

; 92   : 		int zLimit = (camZ > prevCamZ ? camZ : prevCamZ) + renderDistance;

  006f4	3b cb		 cmp	 ecx, ebx
  006f6	0f 4f d9	 cmovg	 ebx, ecx
  006f9	83 c3 0a	 add	 ebx, 10			; 0000000aH
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 68   : 	return (_Check_C_return(_Mtx_lock(_Mtx)));

  006fc	68 0c 00 00 00	 push	 OFFSET ?world@GlobalThread@@3VWorld@@A+12
; File c:\users\glenn\documents\github\wind\project\wind\wind\main.cpp

; 90   : 		int xLimit = (camX > prevCamX ? camX : prevCamX) + renderDistance;

  00701	89 7d bc	 mov	 DWORD PTR _xLimit$1$[ebp], edi

; 91   : 		int yLimit = (camY > prevCamY ? camY : prevCamY) + renderDistance;

  00704	89 75 d8	 mov	 DWORD PTR _yLimit$1$[ebp], esi

; 92   : 		int zLimit = (camZ > prevCamZ ? camZ : prevCamZ) + renderDistance;

  00707	89 5d dc	 mov	 DWORD PTR _zLimit$1$[ebp], ebx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 68   : 	return (_Check_C_return(_Mtx_lock(_Mtx)));

  0070a	e8 00 00 00 00	 call	 __Mtx_lock
  0070f	83 c4 04	 add	 esp, 4

; 32   : 	if (_Res != _Thrd_success)

  00712	85 c0		 test	 eax, eax
  00714	74 09		 je	 SHORT $LN193@mainLoop

; 33   : 		_Throw_C_error(_Res);

  00716	50		 push	 eax
  00717	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
  0071c	83 c4 04	 add	 esp, 4
$LN193@mainLoop:

; 68   : 	return (_Check_C_return(_Mtx_lock(_Mtx)));

  0071f	68 24 00 00 00	 push	 OFFSET ?world@GlobalThread@@3VWorld@@A+36
  00724	e8 00 00 00 00	 call	 __Mtx_lock
  00729	83 c4 04	 add	 esp, 4

; 32   : 	if (_Res != _Thrd_success)

  0072c	85 c0		 test	 eax, eax
  0072e	74 09		 je	 SHORT $LN200@mainLoop

; 33   : 		_Throw_C_error(_Res);

  00730	50		 push	 eax
  00731	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
  00736	83 c4 04	 add	 esp, 4
$LN200@mainLoop:
; File c:\users\glenn\documents\github\wind\project\wind\wind\main.cpp

; 95   : 		for(int i = (camX < prevCamX ? camX : prevCamX) - renderDistance; i <= xLimit; i++)

  00739	a1 00 00 00 00	 mov	 eax, DWORD PTR ?prevCamX@@3HA ; prevCamX
  0073e	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?camX@@3HA ; camX
  00744	3b f0		 cmp	 esi, eax
  00746	8b c8		 mov	 ecx, eax
  00748	0f 4c ce	 cmovl	 ecx, esi
  0074b	83 e9 0a	 sub	 ecx, 10			; 0000000aH
  0074e	89 4d e8	 mov	 DWORD PTR _i$1$[ebp], ecx
  00751	3b cf		 cmp	 ecx, edi
  00753	0f 8f b7 05 00
	00		 jg	 $LN585@mainLoop
  00759	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?camY@@3HA ; camY
  0075f	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR ?prevCamY@@3HA ; prevCamY
$LL15@mainLoop:

; 96   : 		{
; 97   : 			int xDist = (i - camX) * (i - camX);

  00765	8b 4d e8	 mov	 ecx, DWORD PTR _i$1$[ebp]
  00768	8b d1		 mov	 edx, ecx

; 98   : 			int xPrevDist = (i - prevCamX) * (i - prevCamX);

  0076a	2b c8		 sub	 ecx, eax
  0076c	0f af c9	 imul	 ecx, ecx
  0076f	2b d6		 sub	 edx, esi
  00771	0f af d2	 imul	 edx, edx
  00774	89 4d d0	 mov	 DWORD PTR _xPrevDist$1$[ebp], ecx

; 99   : 			for(int j = (camY < prevCamY ? camY : prevCamY) - renderDistance; j <= yLimit; j++)

  00777	3b fb		 cmp	 edi, ebx
  00779	8b cb		 mov	 ecx, ebx
  0077b	0f 4c cf	 cmovl	 ecx, edi
  0077e	83 e9 0a	 sub	 ecx, 10			; 0000000aH
  00781	3b 4d d8	 cmp	 ecx, DWORD PTR _yLimit$1$[ebp]
  00784	89 55 d4	 mov	 DWORD PTR _xDist$1$[ebp], edx
  00787	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?prevCamZ@@3HA ; prevCamZ
  0078d	89 4d e4	 mov	 DWORD PTR _j$1$[ebp], ecx
  00790	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?camZ@@3HA ; camZ
  00796	0f 8f 5f 05 00
	00		 jg	 $LN14@mainLoop
  0079c	8b 75 e4	 mov	 esi, DWORD PTR _j$1$[ebp]
  0079f	90		 npad	 1
$LL12@mainLoop:

; 100  : 			{
; 101  : 				int yDist = (j - camY) * (j - camY);

  007a0	8b c6		 mov	 eax, esi
  007a2	2b c7		 sub	 eax, edi

; 102  : 				int yPrevDist = (j - prevCamY) * (j - prevCamY);

  007a4	2b f3		 sub	 esi, ebx
  007a6	0f af c0	 imul	 eax, eax
  007a9	0f af f6	 imul	 esi, esi

; 103  : 				for(int k = (camZ < prevCamZ ? camZ : prevCamZ) - renderDistance; k <= zLimit; k++)

  007ac	3b ca		 cmp	 ecx, edx
  007ae	8b fa		 mov	 edi, edx
  007b0	0f 4c f9	 cmovl	 edi, ecx
  007b3	83 ef 0a	 sub	 edi, 10			; 0000000aH
  007b6	3b 7d dc	 cmp	 edi, DWORD PTR _zLimit$1$[ebp]
  007b9	89 7d ec	 mov	 DWORD PTR _k$1$[ebp], edi
  007bc	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?camY@@3HA ; camY
  007c2	0f 8f 18 05 00
	00		 jg	 $LN11@mainLoop
  007c8	8b 5d d4	 mov	 ebx, DWORD PTR _xDist$1$[ebp]
  007cb	8b 7d ec	 mov	 edi, DWORD PTR _k$1$[ebp]
  007ce	03 d8		 add	 ebx, eax
  007d0	03 75 d0	 add	 esi, DWORD PTR _xPrevDist$1$[ebp]
  007d3	89 5d cc	 mov	 DWORD PTR tv2353[ebp], ebx
  007d6	89 75 c4	 mov	 DWORD PTR tv2352[ebp], esi
  007d9	8d a4 24 00 00
	00 00		 npad	 7
$LL9@mainLoop:

; 104  : 				{
; 105  : 					int zDist = (k - camZ) * (k - camZ);

  007e0	8b c7		 mov	 eax, edi
  007e2	2b c1		 sub	 eax, ecx
  007e4	0f af c0	 imul	 eax, eax

; 106  : 					int zPrevDist = (k - prevCamZ) * (k - prevCamZ);

  007e7	8b cf		 mov	 ecx, edi
  007e9	2b ca		 sub	 ecx, edx
  007eb	0f af c9	 imul	 ecx, ecx

; 107  : 
; 108  : 					bool in1 = xDist + yDist + zDist <= renderDistance * renderDistance;

  007ee	03 c3		 add	 eax, ebx

; 109  : 					bool in2 = xPrevDist + yPrevDist + zPrevDist <= renderDistance * renderDistance;
; 110  : 
; 111  : 					std::shared_ptr<ChunkBase> c = GlobalThread::world.getChunk(i, j, k);

  007f0	57		 push	 edi
  007f1	ff 75 e4	 push	 DWORD PTR _j$1$[ebp]
  007f4	83 f8 64	 cmp	 eax, 100		; 00000064H
  007f7	ff 75 e8	 push	 DWORD PTR _i$1$[ebp]
  007fa	8d 04 0e	 lea	 eax, DWORD PTR [esi+ecx]
  007fd	0f 9e c3	 setle	 bl
  00800	83 f8 64	 cmp	 eax, 100		; 00000064H
  00803	8d 45 b0	 lea	 eax, DWORD PTR _c$5[ebp]
  00806	50		 push	 eax
  00807	b9 00 00 00 00	 mov	 ecx, OFFSET ?world@GlobalThread@@3VWorld@@A ; GlobalThread::world
  0080c	0f 9e c7	 setle	 bh
  0080f	e8 00 00 00 00	 call	 ?getChunk@World@@QAE?AV?$shared_ptr@VChunkBase@@@std@@HHH@Z ; World::getChunk

; 112  : 
; 113  : 					if(in1 & !in2)

  00814	33 c0		 xor	 eax, eax
  00816	84 ff		 test	 bh, bh
  00818	0f 94 c0	 sete	 al
  0081b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00822	84 c3		 test	 al, bl
  00824	0f 84 83 03 00
	00		 je	 $LN6@mainLoop

; 114  : 					{
; 115  : 						if(c->isEmpty())

  0082a	8b 4d b0	 mov	 ecx, DWORD PTR _c$5[ebp]
  0082d	8b 01		 mov	 eax, DWORD PTR [ecx]
  0082f	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00832	ff d0		 call	 eax
  00834	84 c0		 test	 al, al
  00836	0f 84 90 04 00
	00		 je	 $LN574@mainLoop

; 117  : 							c = std::shared_ptr<ChunkBase>(new Chunk(GlobalThread::world, i, j, k));

  0083c	68 84 20 00 00	 push	 8324			; 00002084H
  00841	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00846	8b f0		 mov	 esi, eax
  00848	83 c4 04	 add	 esp, 4
  0084b	89 75 e0	 mov	 DWORD PTR $T7[ebp], esi
  0084e	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  00852	85 f6		 test	 esi, esi
  00854	74 2c		 je	 SHORT $LN35@mainLoop
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp

; 135  : {

  00856	57		 push	 edi
  00857	ff 75 e4	 push	 DWORD PTR _j$1$[ebp]
  0085a	8b ce		 mov	 ecx, esi
  0085c	ff 75 e8	 push	 DWORD PTR _i$1$[ebp]
  0085f	68 00 00 00 00	 push	 OFFSET ?world@GlobalThread@@3VWorld@@A ; GlobalThread::world
  00864	e8 00 00 00 00	 call	 ??0ChunkBase@@QAE@AAVWorld@@HHH@Z ; ChunkBase::ChunkBase
  00869	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7Chunk@@6B@
  0086f	c7 46 7c 00 00
	00 00		 mov	 DWORD PTR [esi+124], 0
  00876	c7 86 80 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+128], 0
; File c:\users\glenn\documents\github\wind\project\wind\wind\main.cpp

; 117  : 							c = std::shared_ptr<ChunkBase>(new Chunk(GlobalThread::world, i, j, k));

  00880	eb 02		 jmp	 SHORT $LN36@mainLoop
$LN35@mainLoop:
  00882	33 f6		 xor	 esi, esi
$LN36@mainLoop:
  00884	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 487  : 		_Resetp(_Px);

  00888	56		 push	 esi
  00889	8d 4d a8	 lea	 ecx, DWORD PTR $T4[ebp]

; 282  : 		{	// construct

  0088c	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR $T4[ebp], 0
  00893	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR $T4[ebp+4], 0

; 487  : 		_Resetp(_Px);

  0089a	e8 00 00 00 00	 call	 ??$_Resetp@VChunk@@@?$shared_ptr@VChunkBase@@@std@@AAEXPAVChunk@@@Z ; std::shared_ptr<ChunkBase>::_Resetp<Chunk>
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility

; 48   : 	_Left = _Move(_Right);

  0089f	8b 45 a8	 mov	 eax, DWORD PTR $T4[ebp]
  008a2	8b 7d b4	 mov	 edi, DWORD PTR _c$5[ebp+4]
  008a5	8b 75 ac	 mov	 esi, DWORD PTR $T4[ebp+4]

; 49   : 	_Right = _Move(_Tmp);

  008a8	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR $T4[ebp+4], 0

; 48   : 	_Left = _Move(_Right);

  008af	89 45 e0	 mov	 DWORD PTR $T6[ebp], eax

; 49   : 	_Right = _Move(_Tmp);

  008b2	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR $T4[ebp], 0
  008b9	89 75 b4	 mov	 DWORD PTR _c$5[ebp+4], esi
  008bc	89 45 b0	 mov	 DWORD PTR _c$5[ebp], eax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  008bf	85 ff		 test	 edi, edi
  008c1	74 25		 je	 SHORT $LN286@mainLoop

; 109  : 		}
; 110  : 
; 111  : 	void _Incwref()
; 112  : 		{	// increment weak reference count
; 113  : 		_MT_INCR(_Ignored, _Weaks);
; 114  : 		}
; 115  : 
; 116  : 	void _Decref()
; 117  : 		{	// decrement use count
; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  008c3	8d 47 04	 lea	 eax, DWORD PTR [edi+4]
  008c6	83 c9 ff	 or	 ecx, -1
  008c9	f0 0f c1 08	 lock	  xadd	 DWORD PTR [eax], ecx
  008cd	75 19		 jne	 SHORT $LN286@mainLoop

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  008cf	8b 07		 mov	 eax, DWORD PTR [edi]
  008d1	8b cf		 mov	 ecx, edi
  008d3	ff 10		 call	 DWORD PTR [eax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  008d5	8d 47 08	 lea	 eax, DWORD PTR [edi+8]
  008d8	83 ca ff	 or	 edx, -1
  008db	f0 0f c1 10	 lock	  xadd	 DWORD PTR [eax], edx
  008df	75 07		 jne	 SHORT $LN286@mainLoop

; 128  : 			_Delete_this();

  008e1	8b 07		 mov	 eax, DWORD PTR [edi]
  008e3	8b cf		 mov	 ecx, edi
  008e5	ff 50 04	 call	 DWORD PTR [eax+4]
$LN286@mainLoop:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 1487 : 		_PUSH_BACK_BEGIN;

  008e8	8b 15 1c 00 00
	00		 mov	 edx, DWORD PTR ?world@GlobalThread@@3VWorld@@A+28
  008ee	8b 0d 20 00 00
	00		 mov	 ecx, DWORD PTR ?world@GlobalThread@@3VWorld@@A+32
  008f4	8b 3d 18 00 00
	00		 mov	 edi, DWORD PTR ?world@GlobalThread@@3VWorld@@A+24
  008fa	8d 04 0a	 lea	 eax, DWORD PTR [edx+ecx]
  008fd	a8 01		 test	 al, 1
  008ff	75 26		 jne	 SHORT $LN292@mainLoop
  00901	8d 41 02	 lea	 eax, DWORD PTR [ecx+2]
  00904	d1 e8		 shr	 eax, 1
  00906	3b f8		 cmp	 edi, eax
  00908	77 1d		 ja	 SHORT $LN292@mainLoop
  0090a	51		 push	 ecx
  0090b	b9 10 00 00 00	 mov	 ecx, OFFSET ?world@GlobalThread@@3VWorld@@A+16
  00910	e8 00 00 00 00	 call	 ?_Growmap@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IAEXI@Z ; std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::_Growmap
  00915	8b 0d 20 00 00
	00		 mov	 ecx, DWORD PTR ?world@GlobalThread@@3VWorld@@A+32
  0091b	8b 15 1c 00 00
	00		 mov	 edx, DWORD PTR ?world@GlobalThread@@3VWorld@@A+28
  00921	8b 3d 18 00 00
	00		 mov	 edi, DWORD PTR ?world@GlobalThread@@3VWorld@@A+24
$LN292@mainLoop:
  00927	8d 04 7d ff ff
	ff ff		 lea	 eax, DWORD PTR [edi*2-1]
  0092e	23 d0		 and	 edx, eax

; 787  : 		return ((_Off / _DEQUESIZ) & (this->_Mapsize - 1));

  00930	4f		 dec	 edi

; 1487 : 		_PUSH_BACK_BEGIN;

  00931	8d 1c 0a	 lea	 ebx, DWORD PTR [edx+ecx]

; 787  : 		return ((_Off / _DEQUESIZ) & (this->_Mapsize - 1));

  00934	8b c3		 mov	 eax, ebx
  00936	d1 e8		 shr	 eax, 1
  00938	23 f8		 and	 edi, eax

; 1487 : 		_PUSH_BACK_BEGIN;

  0093a	a1 14 00 00 00	 mov	 eax, DWORD PTR ?world@GlobalThread@@3VWorld@@A+20
  0093f	89 15 1c 00 00
	00		 mov	 DWORD PTR ?world@GlobalThread@@3VWorld@@A+28, edx
  00945	83 3c b8 00	 cmp	 DWORD PTR [eax+edi*4], 0
  00949	75 26		 jne	 SHORT $LN291@mainLoop
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0094b	6a 10		 push	 16			; 00000010H
  0094d	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00952	83 c4 04	 add	 esp, 4
  00955	85 c0		 test	 eax, eax
  00957	0f 84 69 04 00
	00		 je	 $LN558@mainLoop
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 1487 : 		_PUSH_BACK_BEGIN;

  0095d	8b 0d 14 00 00
	00		 mov	 ecx, DWORD PTR ?world@GlobalThread@@3VWorld@@A+20
  00963	89 04 b9	 mov	 DWORD PTR [ecx+edi*4], eax
  00966	8b 0d 20 00 00
	00		 mov	 ecx, DWORD PTR ?world@GlobalThread@@3VWorld@@A+32
  0096c	a1 14 00 00 00	 mov	 eax, DWORD PTR ?world@GlobalThread@@3VWorld@@A+20
$LN291@mainLoop:

; 1489 : 			this->_Map[_Block] + _Newoff % _DEQUESIZ, _Val);

  00971	8b 04 b8	 mov	 eax, DWORD PTR [eax+edi*4]
  00974	83 e3 01	 and	 ebx, 1
  00977	8d 1c d8	 lea	 ebx, DWORD PTR [eax+ebx*8]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 606  : 		::new ((void *)_Ptr) _Ty(_Val);

  0097a	85 db		 test	 ebx, ebx
  0097c	74 59		 je	 SHORT $LN586@mainLoop
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 282  : 		{	// construct

  0097e	c7 03 00 00 00
	00		 mov	 DWORD PTR [ebx], 0
  00984	c7 43 04 00 00
	00 00		 mov	 DWORD PTR [ebx+4], 0

; 407  : 		if (_Other_rep)

  0098b	85 f6		 test	 esi, esi
  0098d	74 0c		 je	 SHORT $LN339@mainLoop

; 108  : 		_MT_INCR(_Ignored, _Uses);

  0098f	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00992	b9 01 00 00 00	 mov	 ecx, 1
  00997	f0 0f c1 08	 lock	  xadd	 DWORD PTR [eax], ecx
$LN339@mainLoop:

; 408  : 			_Other_rep->_Incref();
; 409  : 		_Reset0(_Other_ptr, _Other_rep);
; 410  : 		}
; 411  : 
; 412  : 	void _Reset(_Ty *_Other_ptr, _Ref_count_base *_Other_rep, bool _Throw)
; 413  : 		{	// take _Other_ptr through _Other_rep from weak_ptr if not expired
; 414  : 			// otherwise, leave in default state if !_Throw,
; 415  : 			// otherwise throw exception
; 416  : 		if (_Other_rep && _Other_rep->_Incref_nz())
; 417  : 			_Reset0(_Other_ptr, _Other_rep);
; 418  : 		else if (_Throw)
; 419  : 			_THROW_NCEE(bad_weak_ptr, 0);
; 420  : 		}
; 421  : 
; 422  : 	void _Reset0(_Ty *_Other_ptr, _Ref_count_base *_Other_rep)
; 423  : 		{	// release resource and take new resource
; 424  : 		if (_Rep != 0)

  0099b	8b 7b 04	 mov	 edi, DWORD PTR [ebx+4]
  0099e	85 ff		 test	 edi, edi
  009a0	74 25		 je	 SHORT $LN347@mainLoop

; 109  : 		}
; 110  : 
; 111  : 	void _Incwref()
; 112  : 		{	// increment weak reference count
; 113  : 		_MT_INCR(_Ignored, _Weaks);
; 114  : 		}
; 115  : 
; 116  : 	void _Decref()
; 117  : 		{	// decrement use count
; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  009a2	8d 47 04	 lea	 eax, DWORD PTR [edi+4]
  009a5	83 c9 ff	 or	 ecx, -1
  009a8	f0 0f c1 08	 lock	  xadd	 DWORD PTR [eax], ecx
  009ac	75 19		 jne	 SHORT $LN347@mainLoop

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  009ae	8b 07		 mov	 eax, DWORD PTR [edi]
  009b0	8b cf		 mov	 ecx, edi
  009b2	ff 10		 call	 DWORD PTR [eax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  009b4	8d 47 08	 lea	 eax, DWORD PTR [edi+8]
  009b7	83 ca ff	 or	 edx, -1
  009ba	f0 0f c1 10	 lock	  xadd	 DWORD PTR [eax], edx
  009be	75 07		 jne	 SHORT $LN347@mainLoop

; 128  : 			_Delete_this();

  009c0	8b 07		 mov	 eax, DWORD PTR [edi]
  009c2	8b cf		 mov	 ecx, edi
  009c4	ff 50 04	 call	 DWORD PTR [eax+4]
$LN347@mainLoop:

; 427  : 		_Ptr = _Other_ptr;

  009c7	8b 55 e0	 mov	 edx, DWORD PTR $T6[ebp]
  009ca	89 73 04	 mov	 DWORD PTR [ebx+4], esi
  009cd	89 13		 mov	 DWORD PTR [ebx], edx
  009cf	8b 0d 20 00 00
	00		 mov	 ecx, DWORD PTR ?world@GlobalThread@@3VWorld@@A+32
  009d5	eb 03		 jmp	 SHORT $LN326@mainLoop
$LN586@mainLoop:
  009d7	8b 55 e0	 mov	 edx, DWORD PTR $T6[ebp]
$LN326@mainLoop:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 1490 : 		_PUSH_BACK_END;

  009da	41		 inc	 ecx
  009db	89 0d 20 00 00
	00		 mov	 DWORD PTR ?world@GlobalThread@@3VWorld@@A+32, ecx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 407  : 		if (_Other_rep)

  009e1	85 f6		 test	 esi, esi
  009e3	74 0c		 je	 SHORT $LN361@mainLoop

; 108  : 		_MT_INCR(_Ignored, _Uses);

  009e5	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  009e8	b9 01 00 00 00	 mov	 ecx, 1
  009ed	f0 0f c1 08	 lock	  xadd	 DWORD PTR [eax], ecx
$LN361@mainLoop:

; 425  : 			_Rep->_Decref();
; 426  : 		_Rep = _Other_rep;

  009f1	89 75 a4	 mov	 DWORD PTR $T3[ebp+4], esi

; 427  : 		_Ptr = _Other_ptr;

  009f4	89 55 a0	 mov	 DWORD PTR $T3[ebp], edx
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkloadthread.cpp

; 88   : {

  009f7	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2

; 89   : 	ChunkLoadThread* thread = &chunkLoadThreads[(loaderThread++) % LOAD_THREAD_AMOUNT];

  009fb	ff 05 00 00 00
	00		 inc	 DWORD PTR ?loaderThread@@3HA ; loaderThread
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 68   : 	return (_Check_C_return(_Mtx_lock(_Mtx)));

  00a01	68 34 04 00 00	 push	 OFFSET ?chunkLoadThreads@@3PAVChunkLoadThread@@A+1076
  00a06	e8 00 00 00 00	 call	 __Mtx_lock
  00a0b	83 c4 04	 add	 esp, 4

; 32   : 	if (_Res != _Thrd_success)

  00a0e	85 c0		 test	 eax, eax
  00a10	74 09		 je	 SHORT $LN379@mainLoop

; 33   : 		_Throw_C_error(_Res);

  00a12	50		 push	 eax
  00a13	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
  00a18	83 c4 04	 add	 esp, 4
$LN379@mainLoop:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 1487 : 		_PUSH_BACK_BEGIN;

  00a1b	8b 15 2c 04 00
	00		 mov	 edx, DWORD PTR ?chunkLoadThreads@@3PAVChunkLoadThread@@A+1068
  00a21	8b 0d 30 04 00
	00		 mov	 ecx, DWORD PTR ?chunkLoadThreads@@3PAVChunkLoadThread@@A+1072
  00a27	8b 3d 28 04 00
	00		 mov	 edi, DWORD PTR ?chunkLoadThreads@@3PAVChunkLoadThread@@A+1064
  00a2d	8d 04 0a	 lea	 eax, DWORD PTR [edx+ecx]
  00a30	a8 01		 test	 al, 1
  00a32	75 26		 jne	 SHORT $LN385@mainLoop
  00a34	8d 41 02	 lea	 eax, DWORD PTR [ecx+2]
  00a37	d1 e8		 shr	 eax, 1
  00a39	3b f8		 cmp	 edi, eax
  00a3b	77 1d		 ja	 SHORT $LN385@mainLoop
  00a3d	51		 push	 ecx
  00a3e	b9 20 04 00 00	 mov	 ecx, OFFSET ?chunkLoadThreads@@3PAVChunkLoadThread@@A+1056
  00a43	e8 00 00 00 00	 call	 ?_Growmap@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IAEXI@Z ; std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::_Growmap
  00a48	8b 0d 30 04 00
	00		 mov	 ecx, DWORD PTR ?chunkLoadThreads@@3PAVChunkLoadThread@@A+1072
  00a4e	8b 15 2c 04 00
	00		 mov	 edx, DWORD PTR ?chunkLoadThreads@@3PAVChunkLoadThread@@A+1068
  00a54	8b 3d 28 04 00
	00		 mov	 edi, DWORD PTR ?chunkLoadThreads@@3PAVChunkLoadThread@@A+1064
$LN385@mainLoop:
  00a5a	8d 04 7d ff ff
	ff ff		 lea	 eax, DWORD PTR [edi*2-1]
  00a61	23 d0		 and	 edx, eax

; 787  : 		return ((_Off / _DEQUESIZ) & (this->_Mapsize - 1));

  00a63	4f		 dec	 edi

; 1487 : 		_PUSH_BACK_BEGIN;

  00a64	8d 1c 0a	 lea	 ebx, DWORD PTR [edx+ecx]

; 787  : 		return ((_Off / _DEQUESIZ) & (this->_Mapsize - 1));

  00a67	8b c3		 mov	 eax, ebx
  00a69	d1 e8		 shr	 eax, 1
  00a6b	23 f8		 and	 edi, eax

; 1487 : 		_PUSH_BACK_BEGIN;

  00a6d	a1 24 04 00 00	 mov	 eax, DWORD PTR ?chunkLoadThreads@@3PAVChunkLoadThread@@A+1060
  00a72	89 15 2c 04 00
	00		 mov	 DWORD PTR ?chunkLoadThreads@@3PAVChunkLoadThread@@A+1068, edx
  00a78	83 3c b8 00	 cmp	 DWORD PTR [eax+edi*4], 0
  00a7c	75 26		 jne	 SHORT $LN384@mainLoop
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  00a7e	6a 10		 push	 16			; 00000010H
  00a80	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00a85	83 c4 04	 add	 esp, 4
  00a88	85 c0		 test	 eax, eax
  00a8a	0f 84 36 03 00
	00		 je	 $LN558@mainLoop
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 1487 : 		_PUSH_BACK_BEGIN;

  00a90	8b 0d 24 04 00
	00		 mov	 ecx, DWORD PTR ?chunkLoadThreads@@3PAVChunkLoadThread@@A+1060
  00a96	89 04 b9	 mov	 DWORD PTR [ecx+edi*4], eax
  00a99	8b 0d 30 04 00
	00		 mov	 ecx, DWORD PTR ?chunkLoadThreads@@3PAVChunkLoadThread@@A+1072
  00a9f	a1 24 04 00 00	 mov	 eax, DWORD PTR ?chunkLoadThreads@@3PAVChunkLoadThread@@A+1060
$LN384@mainLoop:

; 1489 : 			this->_Map[_Block] + _Newoff % _DEQUESIZ, _Val);

  00aa4	8b 04 b8	 mov	 eax, DWORD PTR [eax+edi*4]
  00aa7	83 e3 01	 and	 ebx, 1
  00aaa	8d 1c d8	 lea	 ebx, DWORD PTR [eax+ebx*8]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 606  : 		::new ((void *)_Ptr) _Ty(_Val);

  00aad	85 db		 test	 ebx, ebx
  00aaf	74 57		 je	 SHORT $LN419@mainLoop
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 282  : 		{	// construct

  00ab1	c7 03 00 00 00
	00		 mov	 DWORD PTR [ebx], 0
  00ab7	c7 43 04 00 00
	00 00		 mov	 DWORD PTR [ebx+4], 0

; 407  : 		if (_Other_rep)

  00abe	85 f6		 test	 esi, esi
  00ac0	74 0c		 je	 SHORT $LN432@mainLoop

; 108  : 		_MT_INCR(_Ignored, _Uses);

  00ac2	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00ac5	b9 01 00 00 00	 mov	 ecx, 1
  00aca	f0 0f c1 08	 lock	  xadd	 DWORD PTR [eax], ecx
$LN432@mainLoop:

; 408  : 			_Other_rep->_Incref();
; 409  : 		_Reset0(_Other_ptr, _Other_rep);
; 410  : 		}
; 411  : 
; 412  : 	void _Reset(_Ty *_Other_ptr, _Ref_count_base *_Other_rep, bool _Throw)
; 413  : 		{	// take _Other_ptr through _Other_rep from weak_ptr if not expired
; 414  : 			// otherwise, leave in default state if !_Throw,
; 415  : 			// otherwise throw exception
; 416  : 		if (_Other_rep && _Other_rep->_Incref_nz())
; 417  : 			_Reset0(_Other_ptr, _Other_rep);
; 418  : 		else if (_Throw)
; 419  : 			_THROW_NCEE(bad_weak_ptr, 0);
; 420  : 		}
; 421  : 
; 422  : 	void _Reset0(_Ty *_Other_ptr, _Ref_count_base *_Other_rep)
; 423  : 		{	// release resource and take new resource
; 424  : 		if (_Rep != 0)

  00ace	8b 7b 04	 mov	 edi, DWORD PTR [ebx+4]
  00ad1	85 ff		 test	 edi, edi
  00ad3	74 25		 je	 SHORT $LN440@mainLoop

; 109  : 		}
; 110  : 
; 111  : 	void _Incwref()
; 112  : 		{	// increment weak reference count
; 113  : 		_MT_INCR(_Ignored, _Weaks);
; 114  : 		}
; 115  : 
; 116  : 	void _Decref()
; 117  : 		{	// decrement use count
; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  00ad5	8d 47 04	 lea	 eax, DWORD PTR [edi+4]
  00ad8	83 c9 ff	 or	 ecx, -1
  00adb	f0 0f c1 08	 lock	  xadd	 DWORD PTR [eax], ecx
  00adf	75 19		 jne	 SHORT $LN440@mainLoop

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  00ae1	8b 07		 mov	 eax, DWORD PTR [edi]
  00ae3	8b cf		 mov	 ecx, edi
  00ae5	ff 10		 call	 DWORD PTR [eax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  00ae7	8d 47 08	 lea	 eax, DWORD PTR [edi+8]
  00aea	83 ca ff	 or	 edx, -1
  00aed	f0 0f c1 10	 lock	  xadd	 DWORD PTR [eax], edx
  00af1	75 07		 jne	 SHORT $LN440@mainLoop

; 128  : 			_Delete_this();

  00af3	8b 07		 mov	 eax, DWORD PTR [edi]
  00af5	8b cf		 mov	 ecx, edi
  00af7	ff 50 04	 call	 DWORD PTR [eax+4]
$LN440@mainLoop:

; 427  : 		_Ptr = _Other_ptr;

  00afa	8b 45 e0	 mov	 eax, DWORD PTR $T6[ebp]
  00afd	89 73 04	 mov	 DWORD PTR [ebx+4], esi
  00b00	89 03		 mov	 DWORD PTR [ebx], eax
  00b02	8b 0d 30 04 00
	00		 mov	 ecx, DWORD PTR ?chunkLoadThreads@@3PAVChunkLoadThread@@A+1072
$LN419@mainLoop:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 1490 : 		_PUSH_BACK_END;

  00b08	41		 inc	 ecx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 83   : 	return (_Check_C_return(_Mtx_unlock(_Mtx)));

  00b09	68 34 04 00 00	 push	 OFFSET ?chunkLoadThreads@@3PAVChunkLoadThread@@A+1076
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 1490 : 		_PUSH_BACK_END;

  00b0e	89 0d 30 04 00
	00		 mov	 DWORD PTR ?chunkLoadThreads@@3PAVChunkLoadThread@@A+1072, ecx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 83   : 	return (_Check_C_return(_Mtx_unlock(_Mtx)));

  00b14	e8 00 00 00 00	 call	 __Mtx_unlock
  00b19	83 c4 04	 add	 esp, 4

; 32   : 	if (_Res != _Thrd_success)

  00b1c	85 c0		 test	 eax, eax
  00b1e	74 09		 je	 SHORT $LN449@mainLoop

; 33   : 		_Throw_C_error(_Res);

  00b20	50		 push	 eax
  00b21	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
  00b26	83 c4 04	 add	 esp, 4
$LN449@mainLoop:
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkloadthread.cpp

; 94   : }

  00b29	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  00b2d	85 f6		 test	 esi, esi
  00b2f	74 25		 je	 SHORT $LN589@mainLoop

; 109  : 		}
; 110  : 
; 111  : 	void _Incwref()
; 112  : 		{	// increment weak reference count
; 113  : 		_MT_INCR(_Ignored, _Weaks);
; 114  : 		}
; 115  : 
; 116  : 	void _Decref()
; 117  : 		{	// decrement use count
; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  00b31	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00b34	83 c9 ff	 or	 ecx, -1
  00b37	f0 0f c1 08	 lock	  xadd	 DWORD PTR [eax], ecx
  00b3b	75 19		 jne	 SHORT $LN589@mainLoop

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  00b3d	8b 06		 mov	 eax, DWORD PTR [esi]
  00b3f	8b ce		 mov	 ecx, esi
  00b41	ff 10		 call	 DWORD PTR [eax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  00b43	8d 46 08	 lea	 eax, DWORD PTR [esi+8]
  00b46	83 c9 ff	 or	 ecx, -1
  00b49	f0 0f c1 08	 lock	  xadd	 DWORD PTR [eax], ecx
  00b4d	75 07		 jne	 SHORT $LN589@mainLoop

; 128  : 			_Delete_this();

  00b4f	8b 06		 mov	 eax, DWORD PTR [esi]
  00b51	8b ce		 mov	 ecx, esi
  00b53	ff 50 04	 call	 DWORD PTR [eax+4]
$LN589@mainLoop:
  00b56	8b 7d ec	 mov	 edi, DWORD PTR _k$1$[ebp]
$LN471@mainLoop:
; File c:\users\glenn\documents\github\wind\project\wind\wind\main.cpp

; 133  : 				}

  00b59	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  00b60	85 f6		 test	 esi, esi
  00b62	74 25		 je	 SHORT $LN8@mainLoop

; 109  : 		}
; 110  : 
; 111  : 	void _Incwref()
; 112  : 		{	// increment weak reference count
; 113  : 		_MT_INCR(_Ignored, _Weaks);
; 114  : 		}
; 115  : 
; 116  : 	void _Decref()
; 117  : 		{	// decrement use count
; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  00b64	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00b67	83 c9 ff	 or	 ecx, -1
  00b6a	f0 0f c1 08	 lock	  xadd	 DWORD PTR [eax], ecx
  00b6e	75 19		 jne	 SHORT $LN8@mainLoop

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  00b70	8b 06		 mov	 eax, DWORD PTR [esi]
  00b72	8b ce		 mov	 ecx, esi
  00b74	ff 10		 call	 DWORD PTR [eax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  00b76	8d 46 08	 lea	 eax, DWORD PTR [esi+8]
  00b79	83 ca ff	 or	 edx, -1
  00b7c	f0 0f c1 10	 lock	  xadd	 DWORD PTR [eax], edx
  00b80	75 07		 jne	 SHORT $LN8@mainLoop

; 128  : 			_Delete_this();

  00b82	8b 06		 mov	 eax, DWORD PTR [esi]
  00b84	8b ce		 mov	 ecx, esi
  00b86	ff 50 04	 call	 DWORD PTR [eax+4]
$LN8@mainLoop:
; File c:\users\glenn\documents\github\wind\project\wind\wind\main.cpp

; 103  : 				for(int k = (camZ < prevCamZ ? camZ : prevCamZ) - renderDistance; k <= zLimit; k++)

  00b89	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?camZ@@3HA ; camZ
  00b8f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?prevCamZ@@3HA ; prevCamZ
  00b95	47		 inc	 edi
  00b96	89 7d ec	 mov	 DWORD PTR _k$1$[ebp], edi
  00b99	3b 7d dc	 cmp	 edi, DWORD PTR _zLimit$1$[ebp]
  00b9c	0f 8f 32 01 00
	00		 jg	 $LN583@mainLoop
  00ba2	8b 5d cc	 mov	 ebx, DWORD PTR tv2353[ebp]
  00ba5	8b 75 c4	 mov	 esi, DWORD PTR tv2352[ebp]
  00ba8	e9 33 fc ff ff	 jmp	 $LL9@mainLoop
$LN6@mainLoop:

; 118  : 							GlobalThread::world.additionQueue.push(c);
; 119  : 							requestChunkLoad(c);
; 120  : 						}
; 121  : 					}
; 122  : 					else if(!in1 & in2)

  00bad	33 c0		 xor	 eax, eax
  00baf	84 db		 test	 bl, bl
  00bb1	0f 94 c0	 sete	 al
  00bb4	84 c7		 test	 al, bh
  00bb6	0f 84 10 01 00
	00		 je	 $LN574@mainLoop

; 123  : 					{
; 124  : 						if(!c->isEmpty())

  00bbc	8b 4d b0	 mov	 ecx, DWORD PTR _c$5[ebp]
  00bbf	8b 01		 mov	 eax, DWORD PTR [ecx]
  00bc1	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00bc4	ff d0		 call	 eax
  00bc6	84 c0		 test	 al, al
  00bc8	0f 85 fe 00 00
	00		 jne	 $LN574@mainLoop
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 1487 : 		_PUSH_BACK_BEGIN;

  00bce	8b 15 34 00 00
	00		 mov	 edx, DWORD PTR ?world@GlobalThread@@3VWorld@@A+52
  00bd4	8b 0d 38 00 00
	00		 mov	 ecx, DWORD PTR ?world@GlobalThread@@3VWorld@@A+56
  00bda	8b 3d 30 00 00
	00		 mov	 edi, DWORD PTR ?world@GlobalThread@@3VWorld@@A+48
  00be0	8d 04 0a	 lea	 eax, DWORD PTR [edx+ecx]
  00be3	a8 01		 test	 al, 1
  00be5	75 26		 jne	 SHORT $LN470@mainLoop
  00be7	8d 41 02	 lea	 eax, DWORD PTR [ecx+2]
  00bea	d1 e8		 shr	 eax, 1
  00bec	3b f8		 cmp	 edi, eax
  00bee	77 1d		 ja	 SHORT $LN470@mainLoop
  00bf0	51		 push	 ecx
  00bf1	b9 28 00 00 00	 mov	 ecx, OFFSET ?world@GlobalThread@@3VWorld@@A+40
  00bf6	e8 00 00 00 00	 call	 ?_Growmap@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IAEXI@Z ; std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::_Growmap
  00bfb	8b 0d 38 00 00
	00		 mov	 ecx, DWORD PTR ?world@GlobalThread@@3VWorld@@A+56
  00c01	8b 15 34 00 00
	00		 mov	 edx, DWORD PTR ?world@GlobalThread@@3VWorld@@A+52
  00c07	8b 3d 30 00 00
	00		 mov	 edi, DWORD PTR ?world@GlobalThread@@3VWorld@@A+48
$LN470@mainLoop:
  00c0d	8d 04 7d ff ff
	ff ff		 lea	 eax, DWORD PTR [edi*2-1]
  00c14	23 d0		 and	 edx, eax

; 787  : 		return ((_Off / _DEQUESIZ) & (this->_Mapsize - 1));

  00c16	8d 47 ff	 lea	 eax, DWORD PTR [edi-1]

; 1487 : 		_PUSH_BACK_BEGIN;

  00c19	8d 1c 0a	 lea	 ebx, DWORD PTR [edx+ecx]

; 787  : 		return ((_Off / _DEQUESIZ) & (this->_Mapsize - 1));

  00c1c	8b f3		 mov	 esi, ebx
  00c1e	d1 ee		 shr	 esi, 1
  00c20	23 f0		 and	 esi, eax

; 1487 : 		_PUSH_BACK_BEGIN;

  00c22	a1 2c 00 00 00	 mov	 eax, DWORD PTR ?world@GlobalThread@@3VWorld@@A+44
  00c27	89 15 34 00 00
	00		 mov	 DWORD PTR ?world@GlobalThread@@3VWorld@@A+52, edx
  00c2d	83 3c b0 00	 cmp	 DWORD PTR [eax+esi*4], 0
  00c31	75 26		 jne	 SHORT $LN469@mainLoop
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  00c33	6a 10		 push	 16			; 00000010H
  00c35	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00c3a	83 c4 04	 add	 esp, 4
  00c3d	85 c0		 test	 eax, eax
  00c3f	0f 84 81 01 00
	00		 je	 $LN558@mainLoop
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 1487 : 		_PUSH_BACK_BEGIN;

  00c45	8b 0d 2c 00 00
	00		 mov	 ecx, DWORD PTR ?world@GlobalThread@@3VWorld@@A+44
  00c4b	89 04 b1	 mov	 DWORD PTR [ecx+esi*4], eax
  00c4e	8b 0d 38 00 00
	00		 mov	 ecx, DWORD PTR ?world@GlobalThread@@3VWorld@@A+56
  00c54	a1 2c 00 00 00	 mov	 eax, DWORD PTR ?world@GlobalThread@@3VWorld@@A+44
$LN469@mainLoop:

; 1489 : 			this->_Map[_Block] + _Newoff % _DEQUESIZ, _Val);

  00c59	8b 04 b0	 mov	 eax, DWORD PTR [eax+esi*4]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 606  : 		::new ((void *)_Ptr) _Ty(_Val);

  00c5c	8b 75 b4	 mov	 esi, DWORD PTR _c$5[ebp+4]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 1489 : 			this->_Map[_Block] + _Newoff % _DEQUESIZ, _Val);

  00c5f	83 e3 01	 and	 ebx, 1
  00c62	8d 1c d8	 lea	 ebx, DWORD PTR [eax+ebx*8]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 606  : 		::new ((void *)_Ptr) _Ty(_Val);

  00c65	85 db		 test	 ebx, ebx
  00c67	74 57		 je	 SHORT $LN504@mainLoop
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 282  : 		{	// construct

  00c69	c7 03 00 00 00
	00		 mov	 DWORD PTR [ebx], 0
  00c6f	c7 43 04 00 00
	00 00		 mov	 DWORD PTR [ebx+4], 0

; 407  : 		if (_Other_rep)

  00c76	85 f6		 test	 esi, esi
  00c78	74 0c		 je	 SHORT $LN517@mainLoop

; 108  : 		_MT_INCR(_Ignored, _Uses);

  00c7a	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00c7d	b9 01 00 00 00	 mov	 ecx, 1
  00c82	f0 0f c1 08	 lock	  xadd	 DWORD PTR [eax], ecx
$LN517@mainLoop:

; 408  : 			_Other_rep->_Incref();
; 409  : 		_Reset0(_Other_ptr, _Other_rep);
; 410  : 		}
; 411  : 
; 412  : 	void _Reset(_Ty *_Other_ptr, _Ref_count_base *_Other_rep, bool _Throw)
; 413  : 		{	// take _Other_ptr through _Other_rep from weak_ptr if not expired
; 414  : 			// otherwise, leave in default state if !_Throw,
; 415  : 			// otherwise throw exception
; 416  : 		if (_Other_rep && _Other_rep->_Incref_nz())
; 417  : 			_Reset0(_Other_ptr, _Other_rep);
; 418  : 		else if (_Throw)
; 419  : 			_THROW_NCEE(bad_weak_ptr, 0);
; 420  : 		}
; 421  : 
; 422  : 	void _Reset0(_Ty *_Other_ptr, _Ref_count_base *_Other_rep)
; 423  : 		{	// release resource and take new resource
; 424  : 		if (_Rep != 0)

  00c86	8b 7b 04	 mov	 edi, DWORD PTR [ebx+4]
  00c89	85 ff		 test	 edi, edi
  00c8b	74 25		 je	 SHORT $LN525@mainLoop

; 109  : 		}
; 110  : 
; 111  : 	void _Incwref()
; 112  : 		{	// increment weak reference count
; 113  : 		_MT_INCR(_Ignored, _Weaks);
; 114  : 		}
; 115  : 
; 116  : 	void _Decref()
; 117  : 		{	// decrement use count
; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  00c8d	8d 47 04	 lea	 eax, DWORD PTR [edi+4]
  00c90	83 c9 ff	 or	 ecx, -1
  00c93	f0 0f c1 08	 lock	  xadd	 DWORD PTR [eax], ecx
  00c97	75 19		 jne	 SHORT $LN525@mainLoop

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  00c99	8b 07		 mov	 eax, DWORD PTR [edi]
  00c9b	8b cf		 mov	 ecx, edi
  00c9d	ff 10		 call	 DWORD PTR [eax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  00c9f	8d 47 08	 lea	 eax, DWORD PTR [edi+8]
  00ca2	83 ca ff	 or	 edx, -1
  00ca5	f0 0f c1 10	 lock	  xadd	 DWORD PTR [eax], edx
  00ca9	75 07		 jne	 SHORT $LN525@mainLoop

; 128  : 			_Delete_this();

  00cab	8b 07		 mov	 eax, DWORD PTR [edi]
  00cad	8b cf		 mov	 ecx, edi
  00caf	ff 50 04	 call	 DWORD PTR [eax+4]
$LN525@mainLoop:

; 427  : 		_Ptr = _Other_ptr;

  00cb2	8b 45 b0	 mov	 eax, DWORD PTR _c$5[ebp]
  00cb5	89 73 04	 mov	 DWORD PTR [ebx+4], esi
  00cb8	89 03		 mov	 DWORD PTR [ebx], eax
  00cba	8b 0d 38 00 00
	00		 mov	 ecx, DWORD PTR ?world@GlobalThread@@3VWorld@@A+56
$LN504@mainLoop:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 1490 : 		_PUSH_BACK_END;

  00cc0	41		 inc	 ecx
  00cc1	89 0d 38 00 00
	00		 mov	 DWORD PTR ?world@GlobalThread@@3VWorld@@A+56, ecx
  00cc7	e9 8a fe ff ff	 jmp	 $LN589@mainLoop
$LN574@mainLoop:
  00ccc	8b 75 b4	 mov	 esi, DWORD PTR _c$5[ebp+4]
  00ccf	e9 85 fe ff ff	 jmp	 $LN471@mainLoop
$LN583@mainLoop:
; File c:\users\glenn\documents\github\wind\project\wind\wind\main.cpp

; 103  : 				for(int k = (camZ < prevCamZ ? camZ : prevCamZ) - renderDistance; k <= zLimit; k++)

  00cd4	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?camY@@3HA ; camY
  00cda	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR ?prevCamY@@3HA ; prevCamY
$LN11@mainLoop:

; 99   : 			for(int j = (camY < prevCamY ? camY : prevCamY) - renderDistance; j <= yLimit; j++)

  00ce0	8b 75 e4	 mov	 esi, DWORD PTR _j$1$[ebp]
  00ce3	46		 inc	 esi
  00ce4	89 75 e4	 mov	 DWORD PTR _j$1$[ebp], esi
  00ce7	3b 75 d8	 cmp	 esi, DWORD PTR _yLimit$1$[ebp]
  00cea	0f 8e b0 fa ff
	ff		 jle	 $LL12@mainLoop
  00cf0	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?camX@@3HA ; camX
  00cf6	a1 00 00 00 00	 mov	 eax, DWORD PTR ?prevCamX@@3HA ; prevCamX
$LN14@mainLoop:

; 95   : 		for(int i = (camX < prevCamX ? camX : prevCamX) - renderDistance; i <= xLimit; i++)

  00cfb	8b 7d bc	 mov	 edi, DWORD PTR _xLimit$1$[ebp]
  00cfe	ff 45 e8	 inc	 DWORD PTR _i$1$[ebp]
  00d01	39 7d e8	 cmp	 DWORD PTR _i$1$[ebp], edi
  00d04	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?camY@@3HA ; camY
  00d0a	0f 8e 55 fa ff
	ff		 jle	 $LL15@mainLoop
$LN585@mainLoop:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 83   : 	return (_Check_C_return(_Mtx_unlock(_Mtx)));

  00d10	68 0c 00 00 00	 push	 OFFSET ?world@GlobalThread@@3VWorld@@A+12
  00d15	e8 00 00 00 00	 call	 __Mtx_unlock
  00d1a	83 c4 04	 add	 esp, 4

; 32   : 	if (_Res != _Thrd_success)

  00d1d	85 c0		 test	 eax, eax
  00d1f	74 09		 je	 SHORT $LN544@mainLoop

; 33   : 		_Throw_C_error(_Res);

  00d21	50		 push	 eax
  00d22	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
  00d27	83 c4 04	 add	 esp, 4
$LN544@mainLoop:

; 83   : 	return (_Check_C_return(_Mtx_unlock(_Mtx)));

  00d2a	68 24 00 00 00	 push	 OFFSET ?world@GlobalThread@@3VWorld@@A+36
  00d2f	e8 00 00 00 00	 call	 __Mtx_unlock
  00d34	83 c4 04	 add	 esp, 4

; 32   : 	if (_Res != _Thrd_success)

  00d37	85 c0		 test	 eax, eax
  00d39	74 09		 je	 SHORT $LN575@mainLoop

; 33   : 		_Throw_C_error(_Res);

  00d3b	50		 push	 eax
  00d3c	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
  00d41	83 c4 04	 add	 esp, 4
$LN575@mainLoop:
  00d44	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?camZ@@3HA ; camZ
  00d4a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?camY@@3HA ; camY
  00d4f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?camX@@3HA ; camX
$LN551@mainLoop:
; File c:\users\glenn\documents\github\wind\project\wind\wind\main.cpp

; 140  : 	prevCamX = camX;

  00d55	89 15 00 00 00
	00		 mov	 DWORD PTR ?prevCamX@@3HA, edx ; prevCamX

; 141  : 	prevCamY = camY;

  00d5b	a3 00 00 00 00	 mov	 DWORD PTR ?prevCamY@@3HA, eax ; prevCamY

; 142  : 	prevCamZ = camZ;

  00d60	89 0d 00 00 00
	00		 mov	 DWORD PTR ?prevCamZ@@3HA, ecx ; prevCamZ

; 143  : 
; 144  : 	GameStates::swapProcessedPending();

  00d66	e8 00 00 00 00	 call	 ?swapProcessedPending@GameStates@@YAXXZ ; GameStates::swapProcessedPending

; 145  : 
; 146  : 	if((GameStates::processedState == GameStates::pendingState) | (GameStates::pendingState == GameStates::renderingState) | (GameStates::processedState == GameStates::renderingState))

  00d6b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?renderingState@GameStates@@3PAVGameState@1@A ; GameStates::renderingState
  00d71	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?pendingState@GameStates@@3PAVGameState@1@A ; GameStates::pendingState
  00d77	33 db		 xor	 ebx, ebx
  00d79	3b f1		 cmp	 esi, ecx
  00d7b	0f 94 c3	 sete	 bl
  00d7e	33 c0		 xor	 eax, eax
  00d80	39 0d 00 00 00
	00		 cmp	 DWORD PTR ?processedState@GameStates@@3PAVGameState@1@A, ecx ; GameStates::processedState
  00d86	b9 01 00 00 00	 mov	 ecx, 1
  00d8b	0f 94 c0	 sete	 al
  00d8e	0b d8		 or	 ebx, eax
  00d90	33 c0		 xor	 eax, eax
  00d92	39 35 00 00 00
	00		 cmp	 DWORD PTR ?processedState@GameStates@@3PAVGameState@1@A, esi ; GameStates::processedState
  00d98	0f 94 c0	 sete	 al
  00d9b	0b d8		 or	 ebx, eax
  00d9d	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR ?stop@GlobalThread@@3_NA ; GlobalThread::stop
  00da4	0f 45 c1	 cmovne	 eax, ecx

; 147  : 	{
; 148  : 		GlobalThread::stop = true;
; 149  : 	}
; 150  : 
; 151  : 	ticks++;

  00da7	ff 05 00 00 00
	00		 inc	 DWORD PTR ?ticks@@3HA	; ticks
  00dad	a2 00 00 00 00	 mov	 BYTE PTR ?stop@GlobalThread@@3_NA, al ; GlobalThread::stop

; 152  : 	return true;

  00db2	8a c1		 mov	 al, cl

; 153  : }

  00db4	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00db7	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00dbe	59		 pop	 ecx
  00dbf	5f		 pop	 edi
  00dc0	5e		 pop	 esi
  00dc1	5b		 pop	 ebx
  00dc2	8b e5		 mov	 esp, ebp
  00dc4	5d		 pop	 ebp
  00dc5	c3		 ret	 0
$LN558@mainLoop:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 29   : 		_Xbad_alloc();	// report no memory

  00dc6	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN595@mainLoop:
$LN591@mainLoop:
  00dcb	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?mainLoop@@YA_NXZ$0:
  00000	8d 4d b0	 lea	 ecx, DWORD PTR _c$5[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$shared_ptr@VChunkBase@@@std@@QAE@XZ ; std::shared_ptr<ChunkBase>::~shared_ptr<ChunkBase>
__unwindfunclet$?mainLoop@@YA_NXZ$1:
  00008	8b 45 e0	 mov	 eax, DWORD PTR $T7[ebp]
  0000b	50		 push	 eax
  0000c	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00011	59		 pop	 ecx
  00012	c3		 ret	 0
__unwindfunclet$?mainLoop@@YA_NXZ$5:
  00013	8d 4d a0	 lea	 ecx, DWORD PTR $T3[ebp]
  00016	e9 00 00 00 00	 jmp	 ??1?$shared_ptr@VChunkBase@@@std@@QAE@XZ ; std::shared_ptr<ChunkBase>::~shared_ptr<ChunkBase>
__ehhandler$?mainLoop@@YA_NXZ:
  0001b	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001f	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00022	8b 4a 84	 mov	 ecx, DWORD PTR [edx-124]
  00025	33 c8		 xor	 ecx, eax
  00027	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002c	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?mainLoop@@YA_NXZ
  00031	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?mainLoop@@YA_NXZ ENDP					; mainLoop
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\main.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\users\glenn\documents\github\wind\project\wind\wind\main.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\users\glenn\documents\github\wind\project\wind\wind\main.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\main.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\users\glenn\documents\github\wind\project\wind\wind\main.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkloadthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\users\glenn\documents\github\wind\project\wind\wind\main.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\users\glenn\documents\github\wind\project\wind\wind\window.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\users\glenn\documents\github\wind\project\wind\wind\window.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\users\glenn\documents\github\wind\project\wind\wind\main.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\threads.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\users\glenn\documents\github\wind\project\wind\wind\threads.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xrefwrap
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\functional
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thread
; File c:\users\glenn\documents\github\wind\project\wind\wind\main.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thread
; File c:\users\glenn\documents\github\wind\project\wind\wind\main.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\chrono
; File c:\users\glenn\documents\github\wind\project\wind\wind\main.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\chrono
; File c:\users\glenn\documents\github\wind\project\wind\wind\main.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\chrono
; File c:\users\glenn\documents\github\wind\project\wind\wind\main.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\threads.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thread
; File c:\users\glenn\documents\github\wind\project\wind\wind\threads.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thread
; File c:\users\glenn\documents\github\wind\project\wind\wind\main.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\threads.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thread
; File c:\users\glenn\documents\github\wind\project\wind\wind\main.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\window.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
; File c:\users\glenn\documents\github\wind\project\wind\wind\gamestates.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\main.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thread
; File c:\users\glenn\documents\github\wind\project\wind\wind\main.cpp
;	COMDAT _WinMain@16
_TEXT	SEGMENT
_j$1$ = -116						; size = 4
_k$1$ = -112						; size = 4
_i$1$ = -108						; size = 4
_r2$1$ = -104						; size = 4
_r$1$ = -100						; size = 4
_r1$1$ = -96						; size = 4
_yDist$1$ = -92						; size = 4
_startTime$2$ = -88					; size = 4
tv2727 = -88						; size = 4
_startTime$1$ = -84					; size = 4
_xDist$1$ = -84						; size = 4
_theThread$1 = -84					; size = 4
$T2 = -80						; size = 8
_c$3 = -80						; size = 8
_lastTick$ = -72					; size = 8
tv2831 = -64						; size = 8
$T4 = -64						; size = 8
__Launcher$5 = -56					; size = 24
$T6 = -56						; size = 24
_msg$ = -28						; size = 28
__hInstance$ = 8					; size = 4
_hPrevInstance$ = 12					; size = 4
_lpCmdLine$ = 16					; size = 4
__nCmdShow$ = 20					; size = 4
_WinMain@16 PROC					; COMDAT

; 156  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	83 ec 74	 sub	 esp, 116		; 00000074H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	0f 57 c0	 xorps	 xmm0, xmm0

; 157  : 	long long tickTime = 20000000;
; 158  : 	long long lastTick = 0;
; 159  : 
; 160  : 	/*for(int i = 0; i < 4; i++)
; 161  : 	{
; 162  : 		for(int j = -2; j < 2; j++)
; 163  : 		{
; 164  : 			for(int k = 0; k < 4; k++)
; 165  : 			{
; 166  : 				std::shared_ptr<ChunkBase> c(new Chunk(GlobalThread::world, i, j, k));
; 167  : 				GlobalThread::world.chunkMap[c->pos] = c;
; 168  : 				ChunkLoadThread::loadQueue.push(c);
; 169  : 			}
; 170  : 		}
; 171  : 	}*/
; 172  : 
; 173  : 	for(int r = 0; r <= renderDistance; r++)

  0000e	33 c9		 xor	 ecx, ecx
  00010	57		 push	 edi
  00011	66 0f 13 44 24
	38		 movlpd	 QWORD PTR _lastTick$[esp+128], xmm0
  00017	89 4c 24 1c	 mov	 DWORD PTR _r$1$[esp+128], ecx
  0001b	eb 03 8d 49 00	 npad	 5
$LL37@WinMain:

; 174  : 	//int r = 8;
; 175  : 	{
; 176  : 		int r1 = r * r;

  00020	8b c1		 mov	 eax, ecx
  00022	0f af c1	 imul	 eax, ecx
  00025	89 44 24 20	 mov	 DWORD PTR _r1$1$[esp+128], eax

; 177  : 		int r2 = r == 0 ? -1 : (r - 1) * (r - 1);

  00029	85 c9		 test	 ecx, ecx
  0002b	75 0a		 jne	 SHORT $LN40@WinMain
  0002d	c7 44 24 18 ff
	ff ff ff	 mov	 DWORD PTR _r2$1$[esp+128], -1
  00035	eb 0a		 jmp	 SHORT $LN41@WinMain
$LN40@WinMain:
  00037	8d 41 ff	 lea	 eax, DWORD PTR [ecx-1]
  0003a	0f af c0	 imul	 eax, eax
  0003d	89 44 24 18	 mov	 DWORD PTR _r2$1$[esp+128], eax
$LN41@WinMain:

; 178  : 		for(int i = -r; i <= r; i++)

  00041	8b f9		 mov	 edi, ecx
  00043	f7 df		 neg	 edi
  00045	8b d7		 mov	 edx, edi
  00047	89 7c 24 28	 mov	 DWORD PTR tv2727[esp+128], edi
  0004b	89 7c 24 14	 mov	 DWORD PTR _i$1$[esp+128], edi
  0004f	3b d1		 cmp	 edx, ecx
  00051	0f 8f 24 03 00
	00		 jg	 $LN36@WinMain
$LL34@WinMain:

; 179  : 		{
; 180  : 			int xDist = i * i;

  00057	8b c2		 mov	 eax, edx
  00059	0f af c2	 imul	 eax, edx

; 181  : 			for(int j = -r; j <= r; j++)

  0005c	8b df		 mov	 ebx, edi
  0005e	89 44 24 2c	 mov	 DWORD PTR _xDist$1$[esp+128], eax
  00062	89 7c 24 0c	 mov	 DWORD PTR _j$1$[esp+128], edi
  00066	3b d9		 cmp	 ebx, ecx
  00068	0f 8f 00 03 00
	00		 jg	 $LN33@WinMain
  0006e	8b ff		 npad	 2
$LL31@WinMain:

; 182  : 			{
; 183  : 				int yDist = xDist + j * j;

  00070	8b f3		 mov	 esi, ebx
  00072	0f af f3	 imul	 esi, ebx
  00075	03 f0		 add	 esi, eax

; 184  : 				for(int k = -r; k <= r; k++)

  00077	8b c7		 mov	 eax, edi
  00079	89 74 24 24	 mov	 DWORD PTR _yDist$1$[esp+128], esi
  0007d	89 44 24 10	 mov	 DWORD PTR _k$1$[esp+128], eax
  00081	3b c1		 cmp	 eax, ecx
  00083	0f 8f d4 02 00
	00		 jg	 $LN30@WinMain
  00089	8d a4 24 00 00
	00 00		 npad	 7
$LL28@WinMain:

; 185  : 				{
; 186  : 					int zDist = yDist + k * k;

  00090	8b f8		 mov	 edi, eax
  00092	0f af f8	 imul	 edi, eax

; 187  : 					bool b = GlobalThread::world.getChunk(i, j, k)->isEmpty();

  00095	50		 push	 eax
  00096	53		 push	 ebx
  00097	52		 push	 edx
  00098	8d 44 24 4c	 lea	 eax, DWORD PTR $T4[esp+140]
  0009c	50		 push	 eax
  0009d	b9 00 00 00 00	 mov	 ecx, OFFSET ?world@GlobalThread@@3VWorld@@A ; GlobalThread::world
  000a2	03 fe		 add	 edi, esi
  000a4	e8 00 00 00 00	 call	 ?getChunk@World@@QAE?AV?$shared_ptr@VChunkBase@@@std@@HHH@Z ; World::getChunk
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 335  : 		return (_Ptr);

  000a9	8b 08		 mov	 ecx, DWORD PTR [eax]
; File c:\users\glenn\documents\github\wind\project\wind\wind\main.cpp

; 187  : 					bool b = GlobalThread::world.getChunk(i, j, k)->isEmpty();

  000ab	8b 01		 mov	 eax, DWORD PTR [ecx]
  000ad	ff 50 0c	 call	 DWORD PTR [eax+12]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  000b0	8b 74 24 44	 mov	 esi, DWORD PTR $T4[esp+132]
  000b4	85 f6		 test	 esi, esi
  000b6	74 25		 je	 SHORT $LN60@WinMain

; 109  : 		}
; 110  : 
; 111  : 	void _Incwref()
; 112  : 		{	// increment weak reference count
; 113  : 		_MT_INCR(_Ignored, _Weaks);
; 114  : 		}
; 115  : 
; 116  : 	void _Decref()
; 117  : 		{	// decrement use count
; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  000b8	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  000bb	83 c9 ff	 or	 ecx, -1
  000be	f0 0f c1 08	 lock	  xadd	 DWORD PTR [eax], ecx
  000c2	75 19		 jne	 SHORT $LN60@WinMain

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  000c4	8b 06		 mov	 eax, DWORD PTR [esi]
  000c6	8b ce		 mov	 ecx, esi
  000c8	ff 10		 call	 DWORD PTR [eax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  000ca	8d 46 08	 lea	 eax, DWORD PTR [esi+8]
  000cd	83 ca ff	 or	 edx, -1
  000d0	f0 0f c1 10	 lock	  xadd	 DWORD PTR [eax], edx
  000d4	75 07		 jne	 SHORT $LN60@WinMain

; 128  : 			_Delete_this();

  000d6	8b 06		 mov	 eax, DWORD PTR [esi]
  000d8	8b ce		 mov	 ecx, esi
  000da	ff 50 04	 call	 DWORD PTR [eax+4]
$LN60@WinMain:
; File c:\users\glenn\documents\github\wind\project\wind\wind\main.cpp

; 194  : 					if((zDist <= r1) && (zDist > r2))

  000dd	3b 7c 24 20	 cmp	 edi, DWORD PTR _r1$1$[esp+128]
  000e1	0f 8f 55 02 00
	00		 jg	 $LN27@WinMain
  000e7	3b 7c 24 18	 cmp	 edi, DWORD PTR _r2$1$[esp+128]
  000eb	0f 8e 4b 02 00
	00		 jle	 $LN27@WinMain

; 197  : 						std::shared_ptr<ChunkBase> c(new Chunk(GlobalThread::world, i, j, k));

  000f1	68 84 20 00 00	 push	 8324			; 00002084H
  000f6	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  000fb	8b f0		 mov	 esi, eax
  000fd	83 c4 04	 add	 esp, 4
  00100	85 f6		 test	 esi, esi
  00102	74 2e		 je	 SHORT $LN42@WinMain
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp

; 135  : {

  00104	ff 74 24 10	 push	 DWORD PTR _k$1$[esp+128]
  00108	8b ce		 mov	 ecx, esi
  0010a	53		 push	 ebx
  0010b	ff 74 24 1c	 push	 DWORD PTR _i$1$[esp+136]
  0010f	68 00 00 00 00	 push	 OFFSET ?world@GlobalThread@@3VWorld@@A ; GlobalThread::world
  00114	e8 00 00 00 00	 call	 ??0ChunkBase@@QAE@AAVWorld@@HHH@Z ; ChunkBase::ChunkBase
  00119	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7Chunk@@6B@
  0011f	c7 46 7c 00 00
	00 00		 mov	 DWORD PTR [esi+124], 0
  00126	c7 86 80 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+128], 0
; File c:\users\glenn\documents\github\wind\project\wind\wind\main.cpp

; 197  : 						std::shared_ptr<ChunkBase> c(new Chunk(GlobalThread::world, i, j, k));

  00130	eb 02		 jmp	 SHORT $LN43@WinMain
$LN42@WinMain:
  00132	33 f6		 xor	 esi, esi
$LN43@WinMain:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 487  : 		_Resetp(_Px);

  00134	56		 push	 esi
  00135	8d 4c 24 34	 lea	 ecx, DWORD PTR _c$3[esp+132]

; 282  : 		{	// construct

  00139	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR _c$3[esp+132], 0
  00141	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR _c$3[esp+136], 0

; 487  : 		_Resetp(_Px);

  00149	e8 00 00 00 00	 call	 ??$_Resetp@VChunk@@@?$shared_ptr@VChunkBase@@@std@@AAEXPAVChunk@@@Z ; std::shared_ptr<ChunkBase>::_Resetp<Chunk>
; File c:\users\glenn\documents\github\wind\project\wind\wind\main.cpp

; 198  : 						GlobalThread::world.chunkMap[c->pos] = c;

  0014e	8b 5c 24 30	 mov	 ebx, DWORD PTR _c$3[esp+128]
  00152	b9 04 00 00 00	 mov	 ecx, OFFSET ?world@GlobalThread@@3VWorld@@A+4
  00157	8d 43 0c	 lea	 eax, DWORD PTR [ebx+12]
  0015a	50		 push	 eax
  0015b	e8 00 00 00 00	 call	 ??A?$map@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@@std@@QAEAAV?$shared_ptr@VChunkBase@@@1@ABVChunkPosition@@@Z ; std::map<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::operator[]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 407  : 		if (_Other_rep)

  00160	8b 74 24 34	 mov	 esi, DWORD PTR _c$3[esp+132]
  00164	85 f6		 test	 esi, esi
  00166	74 0c		 je	 SHORT $LN92@WinMain

; 108  : 		_MT_INCR(_Ignored, _Uses);

  00168	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  0016b	ba 01 00 00 00	 mov	 edx, 1
  00170	f0 0f c1 11	 lock	  xadd	 DWORD PTR [ecx], edx
$LN92@WinMain:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility

; 48   : 	_Left = _Move(_Right);

  00174	8b 78 04	 mov	 edi, DWORD PTR [eax+4]

; 49   : 	_Right = _Move(_Tmp);

  00177	89 70 04	 mov	 DWORD PTR [eax+4], esi
  0017a	89 18		 mov	 DWORD PTR [eax], ebx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  0017c	85 ff		 test	 edi, edi
  0017e	74 25		 je	 SHORT $LN123@WinMain

; 109  : 		}
; 110  : 
; 111  : 	void _Incwref()
; 112  : 		{	// increment weak reference count
; 113  : 		_MT_INCR(_Ignored, _Weaks);
; 114  : 		}
; 115  : 
; 116  : 	void _Decref()
; 117  : 		{	// decrement use count
; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  00180	8d 47 04	 lea	 eax, DWORD PTR [edi+4]
  00183	83 c9 ff	 or	 ecx, -1
  00186	f0 0f c1 08	 lock	  xadd	 DWORD PTR [eax], ecx
  0018a	75 19		 jne	 SHORT $LN123@WinMain

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  0018c	8b 07		 mov	 eax, DWORD PTR [edi]
  0018e	8b cf		 mov	 ecx, edi
  00190	ff 10		 call	 DWORD PTR [eax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  00192	8d 47 08	 lea	 eax, DWORD PTR [edi+8]
  00195	83 ca ff	 or	 edx, -1
  00198	f0 0f c1 10	 lock	  xadd	 DWORD PTR [eax], edx
  0019c	75 07		 jne	 SHORT $LN123@WinMain

; 128  : 			_Delete_this();

  0019e	8b 07		 mov	 eax, DWORD PTR [edi]
  001a0	8b cf		 mov	 ecx, edi
  001a2	ff 50 04	 call	 DWORD PTR [eax+4]
$LN123@WinMain:

; 407  : 		if (_Other_rep)

  001a5	85 f6		 test	 esi, esi
  001a7	74 0c		 je	 SHORT $LN135@WinMain

; 108  : 		_MT_INCR(_Ignored, _Uses);

  001a9	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  001ac	b9 01 00 00 00	 mov	 ecx, 1
  001b1	f0 0f c1 08	 lock	  xadd	 DWORD PTR [eax], ecx
$LN135@WinMain:
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkloadthread.cpp

; 89   : 	ChunkLoadThread* thread = &chunkLoadThreads[(loaderThread++) % LOAD_THREAD_AMOUNT];

  001b5	ff 05 00 00 00
	00		 inc	 DWORD PTR ?loaderThread@@3HA ; loaderThread
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 68   : 	return (_Check_C_return(_Mtx_lock(_Mtx)));

  001bb	68 34 04 00 00	 push	 OFFSET ?chunkLoadThreads@@3PAVChunkLoadThread@@A+1076
  001c0	e8 00 00 00 00	 call	 __Mtx_lock
  001c5	83 c4 04	 add	 esp, 4

; 32   : 	if (_Res != _Thrd_success)

  001c8	85 c0		 test	 eax, eax
  001ca	74 09		 je	 SHORT $LN152@WinMain

; 33   : 		_Throw_C_error(_Res);

  001cc	50		 push	 eax
  001cd	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
  001d2	83 c4 04	 add	 esp, 4
$LN152@WinMain:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 1487 : 		_PUSH_BACK_BEGIN;

  001d5	8b 0d 2c 04 00
	00		 mov	 ecx, DWORD PTR ?chunkLoadThreads@@3PAVChunkLoadThread@@A+1068
  001db	8b 15 30 04 00
	00		 mov	 edx, DWORD PTR ?chunkLoadThreads@@3PAVChunkLoadThread@@A+1072
  001e1	8b 3d 28 04 00
	00		 mov	 edi, DWORD PTR ?chunkLoadThreads@@3PAVChunkLoadThread@@A+1064
  001e7	8d 04 11	 lea	 eax, DWORD PTR [ecx+edx]
  001ea	a8 01		 test	 al, 1
  001ec	75 26		 jne	 SHORT $LN158@WinMain
  001ee	8d 42 02	 lea	 eax, DWORD PTR [edx+2]
  001f1	d1 e8		 shr	 eax, 1
  001f3	3b f8		 cmp	 edi, eax
  001f5	77 1d		 ja	 SHORT $LN158@WinMain
  001f7	51		 push	 ecx
  001f8	b9 20 04 00 00	 mov	 ecx, OFFSET ?chunkLoadThreads@@3PAVChunkLoadThread@@A+1056
  001fd	e8 00 00 00 00	 call	 ?_Growmap@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IAEXI@Z ; std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::_Growmap
  00202	8b 15 30 04 00
	00		 mov	 edx, DWORD PTR ?chunkLoadThreads@@3PAVChunkLoadThread@@A+1072
  00208	8b 0d 2c 04 00
	00		 mov	 ecx, DWORD PTR ?chunkLoadThreads@@3PAVChunkLoadThread@@A+1068
  0020e	8b 3d 28 04 00
	00		 mov	 edi, DWORD PTR ?chunkLoadThreads@@3PAVChunkLoadThread@@A+1064
$LN158@WinMain:
  00214	8d 04 7d ff ff
	ff ff		 lea	 eax, DWORD PTR [edi*2-1]
  0021b	23 c8		 and	 ecx, eax
  0021d	89 0d 2c 04 00
	00		 mov	 DWORD PTR ?chunkLoadThreads@@3PAVChunkLoadThread@@A+1068, ecx
  00223	8d 1c 11	 lea	 ebx, DWORD PTR [ecx+edx]

; 787  : 		return ((_Off / _DEQUESIZ) & (this->_Mapsize - 1));

  00226	8b cb		 mov	 ecx, ebx
  00228	8d 47 ff	 lea	 eax, DWORD PTR [edi-1]
  0022b	d1 e9		 shr	 ecx, 1
  0022d	23 c8		 and	 ecx, eax

; 1487 : 		_PUSH_BACK_BEGIN;

  0022f	a1 24 04 00 00	 mov	 eax, DWORD PTR ?chunkLoadThreads@@3PAVChunkLoadThread@@A+1060
  00234	8d 3c 8d 00 00
	00 00		 lea	 edi, DWORD PTR [ecx*4]
  0023b	83 3c 07 00	 cmp	 DWORD PTR [edi+eax], 0
  0023f	75 26		 jne	 SHORT $LN157@WinMain
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  00241	6a 10		 push	 16			; 00000010H
  00243	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00248	83 c4 04	 add	 esp, 4
  0024b	85 c0		 test	 eax, eax
  0024d	0f 84 cf 05 00
	00		 je	 $LN760@WinMain
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 1487 : 		_PUSH_BACK_BEGIN;

  00253	8b 0d 24 04 00
	00		 mov	 ecx, DWORD PTR ?chunkLoadThreads@@3PAVChunkLoadThread@@A+1060
  00259	89 04 0f	 mov	 DWORD PTR [edi+ecx], eax
  0025c	8b 15 30 04 00
	00		 mov	 edx, DWORD PTR ?chunkLoadThreads@@3PAVChunkLoadThread@@A+1072
  00262	a1 24 04 00 00	 mov	 eax, DWORD PTR ?chunkLoadThreads@@3PAVChunkLoadThread@@A+1060
$LN157@WinMain:

; 1488 : 		this->_Getal().construct(
; 1489 : 			this->_Map[_Block] + _Newoff % _DEQUESIZ, _Val);

  00267	8b 04 07	 mov	 eax, DWORD PTR [edi+eax]
  0026a	83 e3 01	 and	 ebx, 1
  0026d	8d 1c d8	 lea	 ebx, DWORD PTR [eax+ebx*8]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 606  : 		::new ((void *)_Ptr) _Ty(_Val);

  00270	85 db		 test	 ebx, ebx
  00272	74 58		 je	 SHORT $LN192@WinMain
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 282  : 		{	// construct

  00274	c7 03 00 00 00
	00		 mov	 DWORD PTR [ebx], 0
  0027a	c7 43 04 00 00
	00 00		 mov	 DWORD PTR [ebx+4], 0

; 407  : 		if (_Other_rep)

  00281	85 f6		 test	 esi, esi
  00283	74 0c		 je	 SHORT $LN205@WinMain

; 108  : 		_MT_INCR(_Ignored, _Uses);

  00285	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00288	b9 01 00 00 00	 mov	 ecx, 1
  0028d	f0 0f c1 08	 lock	  xadd	 DWORD PTR [eax], ecx
$LN205@WinMain:

; 408  : 			_Other_rep->_Incref();
; 409  : 		_Reset0(_Other_ptr, _Other_rep);
; 410  : 		}
; 411  : 
; 412  : 	void _Reset(_Ty *_Other_ptr, _Ref_count_base *_Other_rep, bool _Throw)
; 413  : 		{	// take _Other_ptr through _Other_rep from weak_ptr if not expired
; 414  : 			// otherwise, leave in default state if !_Throw,
; 415  : 			// otherwise throw exception
; 416  : 		if (_Other_rep && _Other_rep->_Incref_nz())
; 417  : 			_Reset0(_Other_ptr, _Other_rep);
; 418  : 		else if (_Throw)
; 419  : 			_THROW_NCEE(bad_weak_ptr, 0);
; 420  : 		}
; 421  : 
; 422  : 	void _Reset0(_Ty *_Other_ptr, _Ref_count_base *_Other_rep)
; 423  : 		{	// release resource and take new resource
; 424  : 		if (_Rep != 0)

  00291	8b 7b 04	 mov	 edi, DWORD PTR [ebx+4]
  00294	85 ff		 test	 edi, edi
  00296	74 25		 je	 SHORT $LN213@WinMain

; 109  : 		}
; 110  : 
; 111  : 	void _Incwref()
; 112  : 		{	// increment weak reference count
; 113  : 		_MT_INCR(_Ignored, _Weaks);
; 114  : 		}
; 115  : 
; 116  : 	void _Decref()
; 117  : 		{	// decrement use count
; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  00298	8d 47 04	 lea	 eax, DWORD PTR [edi+4]
  0029b	83 c9 ff	 or	 ecx, -1
  0029e	f0 0f c1 08	 lock	  xadd	 DWORD PTR [eax], ecx
  002a2	75 19		 jne	 SHORT $LN213@WinMain

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  002a4	8b 07		 mov	 eax, DWORD PTR [edi]
  002a6	8b cf		 mov	 ecx, edi
  002a8	ff 10		 call	 DWORD PTR [eax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  002aa	8d 47 08	 lea	 eax, DWORD PTR [edi+8]
  002ad	83 ca ff	 or	 edx, -1
  002b0	f0 0f c1 10	 lock	  xadd	 DWORD PTR [eax], edx
  002b4	75 07		 jne	 SHORT $LN213@WinMain

; 128  : 			_Delete_this();

  002b6	8b 07		 mov	 eax, DWORD PTR [edi]
  002b8	8b cf		 mov	 ecx, edi
  002ba	ff 50 04	 call	 DWORD PTR [eax+4]
$LN213@WinMain:

; 425  : 			_Rep->_Decref();
; 426  : 		_Rep = _Other_rep;
; 427  : 		_Ptr = _Other_ptr;

  002bd	8b 44 24 30	 mov	 eax, DWORD PTR _c$3[esp+128]
  002c1	89 73 04	 mov	 DWORD PTR [ebx+4], esi
  002c4	89 03		 mov	 DWORD PTR [ebx], eax
  002c6	8b 15 30 04 00
	00		 mov	 edx, DWORD PTR ?chunkLoadThreads@@3PAVChunkLoadThread@@A+1072
$LN192@WinMain:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 1490 : 		_PUSH_BACK_END;

  002cc	42		 inc	 edx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 83   : 	return (_Check_C_return(_Mtx_unlock(_Mtx)));

  002cd	68 34 04 00 00	 push	 OFFSET ?chunkLoadThreads@@3PAVChunkLoadThread@@A+1076
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 1490 : 		_PUSH_BACK_END;

  002d2	89 15 30 04 00
	00		 mov	 DWORD PTR ?chunkLoadThreads@@3PAVChunkLoadThread@@A+1072, edx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 83   : 	return (_Check_C_return(_Mtx_unlock(_Mtx)));

  002d8	e8 00 00 00 00	 call	 __Mtx_unlock
  002dd	83 c4 04	 add	 esp, 4

; 32   : 	if (_Res != _Thrd_success)

  002e0	85 c0		 test	 eax, eax
  002e2	74 09		 je	 SHORT $LN222@WinMain

; 33   : 		_Throw_C_error(_Res);

  002e4	50		 push	 eax
  002e5	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
  002ea	83 c4 04	 add	 esp, 4
$LN222@WinMain:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  002ed	85 f6		 test	 esi, esi
  002ef	74 47		 je	 SHORT $LN758@WinMain

; 109  : 		}
; 110  : 
; 111  : 	void _Incwref()
; 112  : 		{	// increment weak reference count
; 113  : 		_MT_INCR(_Ignored, _Weaks);
; 114  : 		}
; 115  : 
; 116  : 	void _Decref()
; 117  : 		{	// decrement use count
; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  002f1	8d 7e 04	 lea	 edi, DWORD PTR [esi+4]
  002f4	83 c8 ff	 or	 eax, -1
  002f7	f0 0f c1 07	 lock	  xadd	 DWORD PTR [edi], eax
  002fb	75 19		 jne	 SHORT $LN233@WinMain

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  002fd	8b 06		 mov	 eax, DWORD PTR [esi]
  002ff	8b ce		 mov	 ecx, esi
  00301	ff 10		 call	 DWORD PTR [eax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  00303	8d 46 08	 lea	 eax, DWORD PTR [esi+8]
  00306	83 c9 ff	 or	 ecx, -1
  00309	f0 0f c1 08	 lock	  xadd	 DWORD PTR [eax], ecx
  0030d	75 07		 jne	 SHORT $LN233@WinMain

; 128  : 			_Delete_this();

  0030f	8b 06		 mov	 eax, DWORD PTR [esi]
  00311	8b ce		 mov	 ecx, esi
  00313	ff 50 04	 call	 DWORD PTR [eax+4]
$LN233@WinMain:

; 109  : 		}
; 110  : 
; 111  : 	void _Incwref()
; 112  : 		{	// increment weak reference count
; 113  : 		_MT_INCR(_Ignored, _Weaks);
; 114  : 		}
; 115  : 
; 116  : 	void _Decref()
; 117  : 		{	// decrement use count
; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  00316	83 c8 ff	 or	 eax, -1
  00319	f0 0f c1 07	 lock	  xadd	 DWORD PTR [edi], eax
  0031d	75 19		 jne	 SHORT $LN758@WinMain

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  0031f	8b 06		 mov	 eax, DWORD PTR [esi]
  00321	8b ce		 mov	 ecx, esi
  00323	ff 10		 call	 DWORD PTR [eax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  00325	8d 46 08	 lea	 eax, DWORD PTR [esi+8]
  00328	83 ca ff	 or	 edx, -1
  0032b	f0 0f c1 10	 lock	  xadd	 DWORD PTR [eax], edx
  0032f	75 07		 jne	 SHORT $LN758@WinMain

; 128  : 			_Delete_this();

  00331	8b 06		 mov	 eax, DWORD PTR [esi]
  00333	8b ce		 mov	 ecx, esi
  00335	ff 50 04	 call	 DWORD PTR [eax+4]
$LN758@WinMain:
  00338	8b 5c 24 0c	 mov	 ebx, DWORD PTR _j$1$[esp+128]
$LN27@WinMain:
; File c:\users\glenn\documents\github\wind\project\wind\wind\main.cpp

; 184  : 				for(int k = -r; k <= r; k++)

  0033c	8b 44 24 10	 mov	 eax, DWORD PTR _k$1$[esp+128]
  00340	8b 4c 24 1c	 mov	 ecx, DWORD PTR _r$1$[esp+128]
  00344	8b 54 24 14	 mov	 edx, DWORD PTR _i$1$[esp+128]
  00348	8b 74 24 24	 mov	 esi, DWORD PTR _yDist$1$[esp+128]
  0034c	40		 inc	 eax
  0034d	89 44 24 10	 mov	 DWORD PTR _k$1$[esp+128], eax
  00351	3b c1		 cmp	 eax, ecx
  00353	0f 8e 37 fd ff
	ff		 jle	 $LL28@WinMain
  00359	8b 7c 24 28	 mov	 edi, DWORD PTR tv2727[esp+128]
$LN30@WinMain:

; 181  : 			for(int j = -r; j <= r; j++)

  0035d	8b 44 24 2c	 mov	 eax, DWORD PTR _xDist$1$[esp+128]
  00361	43		 inc	 ebx
  00362	89 5c 24 0c	 mov	 DWORD PTR _j$1$[esp+128], ebx
  00366	3b d9		 cmp	 ebx, ecx
  00368	0f 8e 02 fd ff
	ff		 jle	 $LL31@WinMain
$LN33@WinMain:

; 178  : 		for(int i = -r; i <= r; i++)

  0036e	42		 inc	 edx
  0036f	89 54 24 14	 mov	 DWORD PTR _i$1$[esp+128], edx
  00373	3b d1		 cmp	 edx, ecx
  00375	0f 8e dc fc ff
	ff		 jle	 $LL34@WinMain
$LN36@WinMain:

; 157  : 	long long tickTime = 20000000;
; 158  : 	long long lastTick = 0;
; 159  : 
; 160  : 	/*for(int i = 0; i < 4; i++)
; 161  : 	{
; 162  : 		for(int j = -2; j < 2; j++)
; 163  : 		{
; 164  : 			for(int k = 0; k < 4; k++)
; 165  : 			{
; 166  : 				std::shared_ptr<ChunkBase> c(new Chunk(GlobalThread::world, i, j, k));
; 167  : 				GlobalThread::world.chunkMap[c->pos] = c;
; 168  : 				ChunkLoadThread::loadQueue.push(c);
; 169  : 			}
; 170  : 		}
; 171  : 	}*/
; 172  : 
; 173  : 	for(int r = 0; r <= renderDistance; r++)

  0037b	41		 inc	 ecx
  0037c	89 4c 24 1c	 mov	 DWORD PTR _r$1$[esp+128], ecx
  00380	83 f9 0a	 cmp	 ecx, 10			; 0000000aH
  00383	0f 8e 97 fc ff
	ff		 jle	 $LL37@WinMain

; 199  : 						requestChunkLoad(c);
; 200  : 					}
; 201  : 				}
; 202  : 			}
; 203  : 		}
; 204  : 	}
; 205  : 
; 206  : 	IOUtil::init();

  00389	e8 00 00 00 00	 call	 ?init@IOUtil@@YAXXZ	; IOUtil::init

; 208  : 	GLWindow::instance = new GLWindow(L"Wind", 600, 600, _hInstance, 3, 4);

  0038e	6a 48		 push	 72			; 00000048H
  00390	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00395	8b f0		 mov	 esi, eax
  00397	83 c4 04	 add	 esp, 4
  0039a	85 f6		 test	 esi, esi
  0039c	0f 84 85 00 00
	00		 je	 $LN44@WinMain
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 1144 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

  003a2	6a 04		 push	 4
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd

; 347  : 		_Left = _Right;

  003a4	33 c0		 xor	 eax, eax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 1144 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

  003a6	68 00 00 00 00	 push	 OFFSET $SG4294941285
  003ab	8d 4c 24 50	 lea	 ecx, DWORD PTR $T6[esp+136]

; 2265 : 		this->_Myres = this->_BUF_SIZE - 1;

  003af	c7 44 24 64 07
	00 00 00	 mov	 DWORD PTR $T6[esp+156], 7

; 1145 : 		}
; 1146 : 
; 1147 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1148 : 		{	// assign _Count * _Ch
; 1149 : 		if (_Count == npos)
; 1150 : 			_Xlen();	// result too long
; 1151 : 
; 1152 : 		if (_Grow(_Count))
; 1153 : 			{	// make room and assign new stuff
; 1154 : 			_Chassign(0, _Count, _Ch);
; 1155 : 			_Eos(_Count);
; 1156 : 			}
; 1157 : 		return (*this);
; 1158 : 		}
; 1159 : 
; 1160 : 	template<class _Iter>
; 1161 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1162 : 			_Myt&>::type
; 1163 : 		assign(_Iter _First, _Iter _Last)
; 1164 : 		{	// assign [First, _Last), input iterators
; 1165 : 		return (replace(begin(), end(), _First, _Last));
; 1166 : 		}
; 1167 : 
; 1168 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1169 : 		{	// assign [First, _Last), const pointers
; 1170 : 		return (replace(begin(), end(), _First, _Last));
; 1171 : 		}
; 1172 : 
; 1173 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1174 : 		{	// assign [First, _Last), const_iterators
; 1175 : 		return (replace(begin(), end(), _First, _Last));
; 1176 : 		}
; 1177 : 
; 1178 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1179 : 		{	// insert _Right at _Off
; 1180 : 		return (insert(_Off, _Right, 0, npos));
; 1181 : 		}
; 1182 : 
; 1183 : 	_Myt& insert(size_type _Off,
; 1184 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1185 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1186 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1187 : 			_Xran();	// _Off or _Roff off end
; 1188 : 		size_type _Num = _Right.size() - _Roff;
; 1189 : 		if (_Num < _Count)
; 1190 : 			_Count = _Num;	// trim _Count to size
; 1191 : 		if (npos - this->_Mysize <= _Count)
; 1192 : 			_Xlen();	// result too long
; 1193 : 
; 1194 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1195 : 			{	// make room and insert new stuff
; 1196 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1197 : 				this->_Myptr() + _Off,
; 1198 : 				this->_Mysize - _Off);	// empty out hole
; 1199 : 			if (this == &_Right)
; 1200 : 				_Traits::move(this->_Myptr() + _Off,
; 1201 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1202 : 						_Count);	// substring
; 1203 : 			else
; 1204 : 				_Traits::copy(this->_Myptr() + _Off,
; 1205 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1206 : 			_Eos(_Num);
; 1207 : 			}
; 1208 : 		return (*this);
; 1209 : 		}
; 1210 : 
; 1211 : 	_Myt& insert(size_type _Off,
; 1212 : 		const _Elem *_Ptr, size_type _Count)
; 1213 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1214 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1215 : 		if (_Count != 0)
; 1216 : 			_DEBUG_POINTER(_Ptr);
; 1217 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1218 : 
; 1219 : 		if (_Inside(_Ptr))
; 1220 : 			return (insert(_Off, *this,
; 1221 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1222 : 		if (this->_Mysize < _Off)
; 1223 : 			_Xran();	// _Off off end
; 1224 : 		if (npos - this->_Mysize <= _Count)
; 1225 : 			_Xlen();	// result too long
; 1226 : 		size_type _Num;
; 1227 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1228 : 			{	// make room and insert new stuff
; 1229 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1230 : 				this->_Myptr() + _Off,
; 1231 : 				this->_Mysize - _Off);	// empty out hole
; 1232 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1233 : 			_Eos(_Num);
; 1234 : 			}
; 1235 : 		return (*this);
; 1236 : 		}
; 1237 : 
; 1238 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1239 : 		{	// insert [_Ptr, <null>) at _Off
; 1240 : 		_DEBUG_POINTER(_Ptr);
; 1241 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1242 : 		}
; 1243 : 
; 1244 : 	_Myt& insert(size_type _Off,
; 1245 : 		size_type _Count, _Elem _Ch)
; 1246 : 		{	// insert _Count * _Ch at _Off
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	iterator insert(const_iterator _Where)
; 1264 : 		{	// insert <null> at _Where
; 1265 : 		return (insert(_Where, _Elem()));
; 1266 : 		}
; 1267 : 
; 1268 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1269 : 		{	// insert _Ch at _Where
; 1270 : 		size_type _Off = _Pdif(_Where, begin());
; 1271 : 		insert(_Off, 1, _Ch);
; 1272 : 		return (begin() + _Off);
; 1273 : 		}
; 1274 : 
; 1275 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1276 : 		{	// insert _Count * _Elem at _Where
; 1277 : 		size_type _Off = _Pdif(_Where, begin());
; 1278 : 		insert(_Off, _Count, _Ch);
; 1279 : 		return (begin() + _Off);
; 1280 : 		}
; 1281 : 
; 1282 : 	template<class _Iter>
; 1283 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1284 : 			iterator>::type
; 1285 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1286 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1287 : 		size_type _Off = _Pdif(_Where, begin());
; 1288 : 		replace(_Where, _Where, _First, _Last);
; 1289 : 		return (begin() + _Off);
; 1290 : 		}
; 1291 : 
; 1292 : 	iterator insert(const_iterator _Where,
; 1293 : 		const_pointer _First, const_pointer _Last)
; 1294 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		replace(_Where, _Where, _First, _Last);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where,
; 1301 : 		const_iterator _First, const_iterator _Last)
; 1302 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1303 : 		size_type _Off = _Pdif(_Where, begin());
; 1304 : 		replace(_Where, _Where, _First, _Last);
; 1305 : 		return (begin() + _Off);
; 1306 : 		}
; 1307 : 
; 1308 : 	_Myt& erase(size_type _Off = 0)
; 1309 : 		{	// erase elements [_Off, ...)
; 1310 : 		if (this->_Mysize < _Off)
; 1311 : 			_Xran();	// _Off off end
; 1312 : 		_Eos(_Off);
; 1313 : 		return (*this);
; 1314 : 		}
; 1315 : 
; 1316 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1317 : 		{	// erase elements [_Off, _Off + _Count)
; 1318 : 		if (this->_Mysize < _Off)
; 1319 : 			_Xran();	// _Off off end
; 1320 : 		if (this->_Mysize - _Off <= _Count)
; 1321 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1322 : 		else if (0 < _Count)
; 1323 : 			{	// move elements down
; 1324 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1325 : 			size_type _Newsize = this->_Mysize - _Count;
; 1326 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1327 : 			_Eos(_Newsize);
; 1328 : 			}
; 1329 : 		return (*this);
; 1330 : 		}
; 1331 : 
; 1332 : 	iterator erase(const_iterator _Where)
; 1333 : 		{	// erase element at _Where
; 1334 : 		size_type _Count = _Pdif(_Where, begin());
; 1335 : 		erase(_Count, 1);
; 1336 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1337 : 		}
; 1338 : 
; 1339 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1340 : 		{	// erase substring [_First, _Last)
; 1341 : 		_DEBUG_RANGE(_First, _Last);
; 1342 : 		size_type _Count = _Pdif(_First, begin());
; 1343 : 		erase(_Count, _Pdif(_Last, _First));
; 1344 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1345 : 		}
; 1346 : 
; 1347 : 	void clear() _NOEXCEPT
; 1348 : 		{	// erase all
; 1349 : 		_Eos(0);
; 1350 : 		}
; 1351 : 
; 1352 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1353 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1354 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1355 : 		}
; 1356 : 
; 1357 : 	_Myt& replace(size_type _Off,
; 1358 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1359 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1360 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1361 : 			_Xran();	// _Off or _Roff off end
; 1362 : 		if (this->_Mysize - _Off < _N0)
; 1363 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1364 : 		size_type _Num = _Right.size() - _Roff;
; 1365 : 		if (_Num < _Count)
; 1366 : 			_Count = _Num;	// trim _Count to size
; 1367 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1368 : 			_Xlen();	// result too long
; 1369 : 
; 1370 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1371 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1372 : 		if (this->_Mysize < _Newsize)
; 1373 : 			_Grow(_Newsize);
; 1374 : 
; 1375 : 		if (this != &_Right)
; 1376 : 			{	// no overlap, just move down and copy in new stuff
; 1377 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1378 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1379 : 			_Traits::copy(this->_Myptr() + _Off,
; 1380 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1381 : 			}
; 1382 : 		else if (_Count <= _N0)
; 1383 : 			{	// hole doesn't get larger, just copy in substring
; 1384 : 			_Traits::move(this->_Myptr() + _Off,
; 1385 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1386 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1387 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1388 : 			}
; 1389 : 		else if (_Roff <= _Off)
; 1390 : 			{	// hole gets larger, substring begins before hole
; 1391 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1392 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1393 : 			_Traits::move(this->_Myptr() + _Off,
; 1394 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1395 : 			}
; 1396 : 		else if (_Off + _N0 <= _Roff)
; 1397 : 			{	// hole gets larger, substring begins after hole
; 1398 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1399 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1400 : 			_Traits::move(this->_Myptr() + _Off,
; 1401 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1402 : 				_Count);	// fill hole
; 1403 : 			}
; 1404 : 		else
; 1405 : 			{	// hole gets larger, substring begins in hole
; 1406 : 			_Traits::move(this->_Myptr() + _Off,
; 1407 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1408 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1409 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1410 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1411 : 				this->_Myptr() + _Roff + _Count,
; 1412 : 				_Count - _N0);	// fill rest of new hole
; 1413 : 			}
; 1414 : 
; 1415 : 		_Eos(_Newsize);
; 1416 : 		return (*this);
; 1417 : 		}
; 1418 : 
; 1419 : 	_Myt& replace(size_type _Off,
; 1420 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1421 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1422 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1423 : 		if (_Count != 0)
; 1424 : 			_DEBUG_POINTER(_Ptr);
; 1425 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1426 : 
; 1427 : 		if (_Inside(_Ptr))
; 1428 : 			return (replace(_Off, _N0, *this,
; 1429 : 				_Ptr - this->_Myptr(),
; 1430 : 				_Count));	// substring, replace carefully
; 1431 : 		if (this->_Mysize < _Off)
; 1432 : 			_Xran();	// _Off off end
; 1433 : 		if (this->_Mysize - _Off < _N0)
; 1434 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1435 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1436 : 			_Xlen();	// result too long
; 1437 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1438 : 
; 1439 : 		if (_Count < _N0)
; 1440 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1441 : 				this->_Myptr() + _Off + _N0,
; 1442 : 				_Nm);	// smaller hole, move tail up
; 1443 : 		size_type _Num;
; 1444 : 		if ((0 < _Count || 0 < _N0)
; 1445 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1446 : 			{	// make room and rearrange
; 1447 : 			if (_N0 < _Count)
; 1448 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1449 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1450 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1451 : 			_Eos(_Num);
; 1452 : 			}
; 1453 : 		return (*this);
; 1454 : 		}
; 1455 : 
; 1456 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1457 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1458 : 		_DEBUG_POINTER(_Ptr);
; 1459 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1460 : 		}
; 1461 : 
; 1462 : 	_Myt& replace(size_type _Off,
; 1463 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1464 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1465 : 		if (this->_Mysize < _Off)
; 1466 : 			_Xran();	// _Off off end
; 1467 : 		if (this->_Mysize - _Off < _N0)
; 1468 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1469 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1470 : 			_Xlen();	// result too long
; 1471 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1472 : 
; 1473 : 		if (_Count < _N0)
; 1474 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1475 : 				this->_Myptr() + _Off + _N0,
; 1476 : 				_Nm);	// smaller hole, move tail up
; 1477 : 		size_type _Num;
; 1478 : 		if ((0 < _Count || 0 < _N0)
; 1479 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1480 : 			{	// make room and rearrange
; 1481 : 			if (_N0 < _Count)
; 1482 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1483 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1484 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1485 : 			_Eos(_Num);
; 1486 : 			}
; 1487 : 		return (*this);
; 1488 : 		}
; 1489 : 
; 1490 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1491 : 		const _Myt& _Right)
; 1492 : 		{	// replace [_First, _Last) with _Right
; 1493 : 		return (replace(
; 1494 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1495 : 		}
; 1496 : 
; 1497 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1498 : 		const _Elem *_Ptr, size_type _Count)
; 1499 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1500 : 		return (replace(
; 1501 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1502 : 		}
; 1503 : 
; 1504 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1505 : 		const _Elem *_Ptr)
; 1506 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1507 : 		return (replace(
; 1508 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1509 : 		}
; 1510 : 
; 1511 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1512 : 		size_type _Count, _Elem _Ch)
; 1513 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1514 : 		return (replace(
; 1515 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1516 : 		}
; 1517 : 
; 1518 : 	template<class _Iter>
; 1519 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1520 : 			_Myt&>::type
; 1521 : 		replace(const_iterator _First, const_iterator _Last,
; 1522 : 			_Iter _First2, _Iter _Last2)
; 1523 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1524 : 		_Myt _Right(_First2, _Last2);
; 1525 : 		replace(_First, _Last, _Right);
; 1526 : 		return (*this);
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const_pointer _First2, const_pointer _Last2)
; 1531 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1532 : 		if (_First2 == _Last2)
; 1533 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1534 : 		else
; 1535 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1536 : 				&*_First2, _Last2 - _First2);
; 1537 : 		return (*this);
; 1538 : 		}
; 1539 : 
; 1540 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1541 : 		pointer _First2, pointer _Last2)
; 1542 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1543 : 		if (_First2 == _Last2)
; 1544 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1545 : 		else
; 1546 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1547 : 				&*_First2, _Last2 - _First2);
; 1548 : 		return (*this);
; 1549 : 		}
; 1550 : 
; 1551 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1552 : 		const_iterator _First2, const_iterator _Last2)
; 1553 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1554 : 		if (_First2 == _Last2)
; 1555 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1556 : 		else
; 1557 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1558 : 				&*_First2, _Last2 - _First2);
; 1559 : 		return (*this);
; 1560 : 		}
; 1561 : 
; 1562 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1563 : 		iterator _First2, iterator _Last2)
; 1564 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1565 : 		if (_First2 == _Last2)
; 1566 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1567 : 		else
; 1568 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1569 : 				&*_First2, _Last2 - _First2);
; 1570 : 		return (*this);
; 1571 : 		}
; 1572 : 
; 1573 : 	iterator begin() _NOEXCEPT
; 1574 : 		{	// return iterator for beginning of mutable sequence
; 1575 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1576 : 		}
; 1577 : 
; 1578 : 	const_iterator begin() const _NOEXCEPT
; 1579 : 		{	// return iterator for beginning of nonmutable sequence
; 1580 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1581 : 		}
; 1582 : 
; 1583 : 	iterator end() _NOEXCEPT
; 1584 : 		{	// return iterator for end of mutable sequence
; 1585 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1586 : 		}
; 1587 : 
; 1588 : 	const_iterator end() const _NOEXCEPT
; 1589 : 		{	// return iterator for end of nonmutable sequence
; 1590 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1591 : 		}
; 1592 : 
; 1593 : 	reverse_iterator rbegin() _NOEXCEPT
; 1594 : 		{	// return iterator for beginning of reversed mutable sequence
; 1595 : 		return (reverse_iterator(end()));
; 1596 : 		}
; 1597 : 
; 1598 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1600 : 		return (const_reverse_iterator(end()));
; 1601 : 		}
; 1602 : 
; 1603 : 	reverse_iterator rend() _NOEXCEPT
; 1604 : 		{	// return iterator for end of reversed mutable sequence
; 1605 : 		return (reverse_iterator(begin()));
; 1606 : 		}
; 1607 : 
; 1608 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1609 : 		{	// return iterator for end of reversed nonmutable sequence
; 1610 : 		return (const_reverse_iterator(begin()));
; 1611 : 		}
; 1612 : 
; 1613 :  #if _HAS_CPP0X
; 1614 : 	const_iterator cbegin() const _NOEXCEPT
; 1615 : 		{	// return iterator for beginning of nonmutable sequence
; 1616 : 		return (((const _Myt *)this)->begin());
; 1617 : 		}
; 1618 : 
; 1619 : 	const_iterator cend() const _NOEXCEPT
; 1620 : 		{	// return iterator for end of nonmutable sequence
; 1621 : 		return (((const _Myt *)this)->end());
; 1622 : 		}
; 1623 : 
; 1624 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1625 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1626 : 		return (((const _Myt *)this)->rbegin());
; 1627 : 		}
; 1628 : 
; 1629 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1630 : 		{	// return iterator for end of reversed nonmutable sequence
; 1631 : 		return (((const _Myt *)this)->rend());
; 1632 : 		}
; 1633 : 
; 1634 : 	void shrink_to_fit()
; 1635 : 		{	// reduce capacity
; 1636 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1637 : 			{	// worth shrinking, do it
; 1638 : 			_Myt _Tmp(*this);
; 1639 : 			swap(_Tmp);
; 1640 : 			}
; 1641 : 		}
; 1642 :  #endif /* _HAS_CPP0X */
; 1643 : 
; 1644 : 	reference at(size_type _Off)
; 1645 : 		{	// subscript mutable sequence with checking
; 1646 : 		if (this->_Mysize <= _Off)
; 1647 : 			_Xran();	// _Off off end
; 1648 : 		return (this->_Myptr()[_Off]);
; 1649 : 		}
; 1650 : 
; 1651 : 	const_reference at(size_type _Off) const
; 1652 : 		{	// subscript nonmutable sequence with checking
; 1653 : 		if (this->_Mysize <= _Off)
; 1654 : 			_Xran();	// _Off off end
; 1655 : 		return (this->_Myptr()[_Off]);
; 1656 : 		}
; 1657 : 
; 1658 : 	reference operator[](size_type _Off)
; 1659 : 		{	// subscript mutable sequence
; 1660 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1661 : 		if (this->_Mysize < _Off)	// sic
; 1662 : 			_DEBUG_ERROR("string subscript out of range");
; 1663 : 
; 1664 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1665 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1666 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1667 : 
; 1668 : 		return (this->_Myptr()[_Off]);
; 1669 : 		}
; 1670 : 
; 1671 : 	const_reference operator[](size_type _Off) const
; 1672 : 		{	// subscript nonmutable sequence
; 1673 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1674 : 		if (this->_Mysize < _Off)	// sic
; 1675 : 			_DEBUG_ERROR("string subscript out of range");
; 1676 : 
; 1677 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1678 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1679 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1680 : 
; 1681 : 		return (this->_Myptr()[_Off]);
; 1682 : 		}
; 1683 : 
; 1684 : 	void push_back(_Elem _Ch)
; 1685 : 		{	// insert element at end
; 1686 : 		insert(end(), _Ch);
; 1687 : 		}
; 1688 : 
; 1689 :  #if _HAS_CPP0X
; 1690 : 	void pop_back()
; 1691 : 		{	// erase element at end
; 1692 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1693 : 		}
; 1694 : 
; 1695 : 	reference front()
; 1696 : 		{	// return first element of mutable sequence
; 1697 : 		return (*begin());
; 1698 : 		}
; 1699 : 
; 1700 : 	const_reference front() const
; 1701 : 		{	// return first element of nonmutable sequence
; 1702 : 		return (*begin());
; 1703 : 		}
; 1704 : 
; 1705 : 	reference back()
; 1706 : 		{	// return last element of mutable sequence
; 1707 : 		return (*(end() - 1));
; 1708 : 		}
; 1709 : 
; 1710 : 	const_reference back() const
; 1711 : 		{	// return last element of nonmutable sequence
; 1712 : 		return (*(end() - 1));
; 1713 : 		}
; 1714 :  #endif /* _HAS_CPP0X */
; 1715 : 
; 1716 : 	const _Elem *c_str() const _NOEXCEPT
; 1717 : 		{	// return pointer to null-terminated nonmutable array
; 1718 : 		return (this->_Myptr());
; 1719 : 		}
; 1720 : 
; 1721 : 	const _Elem *data() const _NOEXCEPT
; 1722 : 		{	// return pointer to nonmutable array
; 1723 : 		return (c_str());
; 1724 : 		}
; 1725 : 
; 1726 : 	size_type length() const _NOEXCEPT
; 1727 : 		{	// return length of sequence
; 1728 : 		return (this->_Mysize);
; 1729 : 		}
; 1730 : 
; 1731 : 	size_type size() const _NOEXCEPT
; 1732 : 		{	// return length of sequence
; 1733 : 		return (this->_Mysize);
; 1734 : 		}
; 1735 : 
; 1736 : 	size_type max_size() const _NOEXCEPT
; 1737 : 		{	// return maximum possible length of sequence
; 1738 : 		size_type _Num = this->_Getal().max_size();
; 1739 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1740 : 		}
; 1741 : 
; 1742 : 	void resize(size_type _Newsize)
; 1743 : 		{	// determine new length, padding with null elements as needed
; 1744 : 		resize(_Newsize, _Elem());
; 1745 : 		}
; 1746 : 
; 1747 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1748 : 		{	// determine new length, padding with _Ch elements as needed
; 1749 : 		if (_Newsize <= this->_Mysize)
; 1750 : 			_Eos(_Newsize);
; 1751 : 		else
; 1752 : 			append(_Newsize - this->_Mysize, _Ch);
; 1753 : 		}
; 1754 : 
; 1755 : 	size_type capacity() const _NOEXCEPT
; 1756 : 		{	// return current length of allocated storage
; 1757 : 		return (this->_Myres);
; 1758 : 		}
; 1759 : 
; 1760 : 	void reserve(size_type _Newcap = 0)
; 1761 : 		{	// determine new minimum length of allocated storage
; 1762 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1763 : 			{	// change reservation
; 1764 : 			size_type _Size = this->_Mysize;
; 1765 : 			if (_Grow(_Newcap, true))
; 1766 : 				_Eos(_Size);
; 1767 : 			}
; 1768 : 		}
; 1769 : 
; 1770 : 	bool empty() const _NOEXCEPT
; 1771 : 		{	// test if sequence is empty
; 1772 : 		return (this->_Mysize == 0);
; 1773 : 		}
; 1774 : 
; 1775 : 	_SCL_INSECURE_DEPRECATE
; 1776 : 
; 1777 : 	size_type copy(_Elem *_Ptr,
; 1778 : 		size_type _Count, size_type _Off = 0) const
; 1779 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1780 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1781 : 		if (_Count != 0)
; 1782 : 			_DEBUG_POINTER(_Ptr);
; 1783 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1784 : 
; 1785 : 		if (this->_Mysize < _Off)
; 1786 : 			_Xran();	// _Off off end
; 1787 : 		if (this->_Mysize - _Off < _Count)
; 1788 : 			_Count = this->_Mysize - _Off;
; 1789 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1790 : 		return (_Count);
; 1791 : 		}
; 1792 : 
; 1793 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1794 : 		size_type _Count, size_type _Off = 0) const
; 1795 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1796 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1797 : 		if (_Count != 0)
; 1798 : 			_DEBUG_POINTER(_Dest);
; 1799 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1800 : 
; 1801 : 		if (this->_Mysize < _Off)
; 1802 : 			_Xran();	// _Off off end
; 1803 : 		if (this->_Mysize - _Off < _Count)
; 1804 : 			_Count = this->_Mysize - _Off;
; 1805 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1806 : 		return (_Count);
; 1807 : 		}
; 1808 : 
; 1809 : 	void _Swap_bx(_Myt& _Right)
; 1810 : 		{	// exchange _Bx with _Right._Bx
; 1811 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1812 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1813 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1814 : 			else
; 1815 : 				{	// swap large with small
; 1816 : 				pointer _Ptr = this->_Bx._Ptr;
; 1817 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1818 : 				_Traits::copy(this->_Bx._Buf,
; 1819 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1820 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1821 : 				}
; 1822 : 		else
; 1823 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1824 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1825 : 			else
; 1826 : 				{	// swap small with large
; 1827 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1828 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1829 : 				_Traits::copy(_Right._Bx._Buf,
; 1830 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1831 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1832 : 				}
; 1833 : 		}
; 1834 : 
; 1835 : 	void swap(_Myt& _Right)
; 1836 : 		{	// exchange contents with _Right
; 1837 : 		if (this == &_Right)
; 1838 : 			;	// same object, do nothing
; 1839 : 		else if (this->_Getal() == _Right._Getal())
; 1840 : 			{	// same allocator, swap control information
; 1841 : 			this->_Swap_all(_Right);
; 1842 : 			_Swap_bx(_Right);
; 1843 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1844 : 			_STD swap(this->_Myres, _Right._Myres);
; 1845 : 			}
; 1846 : 
; 1847 :  #if _HAS_CPP0X
; 1848 : 		else if (_Alty::propagate_on_container_swap::value)
; 1849 : 			{	// swap allocators and control information
; 1850 : 			this->_Swap_alloc(_Right);
; 1851 : 			_Swap_bx(_Right);
; 1852 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1853 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1854 : 			_STD swap(this->_Myres, _Right._Myres);
; 1855 : 			}
; 1856 :  #endif /* _HAS_CPP0X */
; 1857 : 
; 1858 : 		else
; 1859 : 			{	// different allocator, do multiple assigns
; 1860 : 			_Myt _Tmp = *this;
; 1861 : 
; 1862 : 			*this = _Right;
; 1863 : 			_Right = _Tmp;
; 1864 : 			}
; 1865 : 		}
; 1866 : 
; 1867 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1868 : 		{	// look for _Right beginning at or after _Off
; 1869 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1870 : 		}
; 1871 : 
; 1872 : 	size_type find(const _Elem *_Ptr,
; 1873 : 		size_type _Off, size_type _Count) const
; 1874 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1875 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1876 : 		if (_Count != 0)
; 1877 : 			_DEBUG_POINTER(_Ptr);
; 1878 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1879 : 
; 1880 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1881 : 			return (_Off);	// null string always matches (if inside string)
; 1882 : 
; 1883 : 		size_type _Nm;
; 1884 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1885 : 			{	// room for match, look for it
; 1886 : 			const _Elem *_Uptr, *_Vptr;
; 1887 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1888 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1889 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1890 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1891 : 					return (_Uptr - this->_Myptr());	// found a match
; 1892 : 			}
; 1893 : 
; 1894 : 		return (npos);	// no match
; 1895 : 		}
; 1896 : 
; 1897 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1898 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1899 : 		_DEBUG_POINTER(_Ptr);
; 1900 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1901 : 		}
; 1902 : 
; 1903 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1904 : 		{	// look for _Ch at or after _Off
; 1905 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1906 : 		}
; 1907 : 
; 1908 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1909 : 		{	// look for _Right beginning before _Off
; 1910 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1911 : 		}
; 1912 : 
; 1913 : 	size_type rfind(const _Elem *_Ptr,
; 1914 : 		size_type _Off, size_type _Count) const
; 1915 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1916 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1917 : 		if (_Count != 0)
; 1918 : 			_DEBUG_POINTER(_Ptr);
; 1919 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1920 : 
; 1921 : 		if (_Count == 0)
; 1922 : 			return (_Off < this->_Mysize ? _Off
; 1923 : 				: this->_Mysize);	// null always matches
; 1924 : 		if (_Count <= this->_Mysize)
; 1925 : 			{	// room for match, look for it
; 1926 : 			const _Elem *_Uptr = this->_Myptr() +
; 1927 : 				(_Off < this->_Mysize - _Count ? _Off
; 1928 : 					: this->_Mysize - _Count);
; 1929 : 			for (; ; --_Uptr)
; 1930 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1931 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1932 : 					return (_Uptr - this->_Myptr());	// found a match
; 1933 : 				else if (_Uptr == this->_Myptr())
; 1934 : 					break;	// at beginning, no more chance for match
; 1935 : 			}
; 1936 : 
; 1937 : 		return (npos);	// no match
; 1938 : 		}
; 1939 : 
; 1940 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1941 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1942 : 		_DEBUG_POINTER(_Ptr);
; 1943 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1944 : 		}
; 1945 : 
; 1946 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1947 : 		{	// look for _Ch before _Off
; 1948 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1949 : 		}
; 1950 : 
; 1951 : 	size_type find_first_of(const _Myt& _Right,
; 1952 : 		size_type _Off = 0) const _NOEXCEPT
; 1953 : 		{	// look for one of _Right at or after _Off
; 1954 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1955 : 		}
; 1956 : 
; 1957 : 	size_type find_first_of(const _Elem *_Ptr,
; 1958 : 		size_type _Off, size_type _Count) const
; 1959 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1960 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1961 : 		if (_Count != 0)
; 1962 : 			_DEBUG_POINTER(_Ptr);
; 1963 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1964 : 
; 1965 : 		if (0 < _Count && _Off < this->_Mysize)
; 1966 : 			{	// room for match, look for it
; 1967 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1968 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1969 : 				_Uptr < _Vptr; ++_Uptr)
; 1970 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1971 : 					return (_Uptr - this->_Myptr());	// found a match
; 1972 : 			}
; 1973 : 
; 1974 : 		return (npos);	// no match
; 1975 : 		}
; 1976 : 
; 1977 : 	size_type find_first_of(const _Elem *_Ptr,
; 1978 : 		size_type _Off = 0) const
; 1979 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1980 : 		_DEBUG_POINTER(_Ptr);
; 1981 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 1982 : 		}
; 1983 : 
; 1984 : 	size_type find_first_of(_Elem _Ch,
; 1985 : 		size_type _Off = 0) const
; 1986 : 		{	// look for _Ch at or after _Off
; 1987 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1988 : 		}
; 1989 : 
; 1990 : 	size_type find_last_of(const _Myt& _Right,
; 1991 : 		size_type _Off = npos) const _NOEXCEPT
; 1992 : 		{	// look for one of _Right before _Off
; 1993 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_last_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off, size_type _Count) const
; 1998 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 1999 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2000 : 		if (_Count != 0)
; 2001 : 			_DEBUG_POINTER(_Ptr);
; 2002 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2003 : 
; 2004 : 		if (0 < _Count && 0 < this->_Mysize)
; 2005 : 			{	// worth searching, do it
; 2006 : 			const _Elem *_Uptr = this->_Myptr()
; 2007 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2008 : 			for (; ; --_Uptr)
; 2009 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2010 : 					return (_Uptr - this->_Myptr());	// found a match
; 2011 : 				else if (_Uptr == this->_Myptr())
; 2012 : 					break;	// at beginning, no more chance for match
; 2013 : 			}
; 2014 : 
; 2015 : 		return (npos);	// no match
; 2016 : 		}
; 2017 : 
; 2018 : 	size_type find_last_of(const _Elem *_Ptr,
; 2019 : 		size_type _Off = npos) const
; 2020 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2021 : 		_DEBUG_POINTER(_Ptr);
; 2022 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2023 : 		}
; 2024 : 
; 2025 : 	size_type find_last_of(_Elem _Ch,
; 2026 : 		size_type _Off = npos) const
; 2027 : 		{	// look for _Ch before _Off
; 2028 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2029 : 		}
; 2030 : 
; 2031 : 	size_type find_first_not_of(const _Myt& _Right,
; 2032 : 		size_type _Off = 0) const _NOEXCEPT
; 2033 : 		{	// look for none of _Right at or after _Off
; 2034 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2035 : 			_Right.size()));
; 2036 : 		}
; 2037 : 
; 2038 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2039 : 		size_type _Off, size_type _Count) const
; 2040 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2041 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2042 : 		if (_Count != 0)
; 2043 : 			_DEBUG_POINTER(_Ptr);
; 2044 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2045 : 
; 2046 : 		if (_Off < this->_Mysize)
; 2047 : 			{	// room for match, look for it
; 2048 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2049 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2050 : 				_Uptr < _Vptr; ++_Uptr)
; 2051 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2052 : 					return (_Uptr - this->_Myptr());
; 2053 : 			}
; 2054 : 		return (npos);
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off = 0) const
; 2059 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2060 : 		_DEBUG_POINTER(_Ptr);
; 2061 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2062 : 		}
; 2063 : 
; 2064 : 	size_type find_first_not_of(_Elem _Ch,
; 2065 : 		size_type _Off = 0) const
; 2066 : 		{	// look for non _Ch at or after _Off
; 2067 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2068 : 		}
; 2069 : 
; 2070 : 	size_type find_last_not_of(const _Myt& _Right,
; 2071 : 		size_type _Off = npos) const _NOEXCEPT
; 2072 : 		{	// look for none of _Right before _Off
; 2073 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off, size_type _Count) const
; 2078 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2079 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2080 : 		if (_Count != 0)
; 2081 : 			_DEBUG_POINTER(_Ptr);
; 2082 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2083 : 
; 2084 : 		if (0 < this->_Mysize)
; 2085 : 			{	// worth searching, do it
; 2086 : 			const _Elem *_Uptr = this->_Myptr()
; 2087 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2088 : 			for (; ; --_Uptr)
; 2089 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2090 : 					return (_Uptr - this->_Myptr());
; 2091 : 				else if (_Uptr == this->_Myptr())
; 2092 : 					break;
; 2093 : 			}
; 2094 : 		return (npos);
; 2095 : 		}
; 2096 : 
; 2097 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2098 : 		size_type _Off = npos) const
; 2099 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2100 : 		_DEBUG_POINTER(_Ptr);
; 2101 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2102 : 		}
; 2103 : 
; 2104 : 	size_type find_last_not_of(_Elem _Ch,
; 2105 : 		size_type _Off = npos) const
; 2106 : 		{	// look for non _Ch before _Off
; 2107 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2108 : 		}
; 2109 : 
; 2110 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2111 : 		{	// return [_Off, _Off + _Count) as new string
; 2112 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2113 : 		}
; 2114 : 
; 2115 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2116 : 		{	// compare [0, _Mysize) with _Right
; 2117 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2118 : 		}
; 2119 : 
; 2120 : 	int compare(size_type _Off, size_type _N0,
; 2121 : 		const _Myt& _Right) const
; 2122 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2123 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2124 : 		}
; 2125 : 
; 2126 : 	int compare(size_type _Off,
; 2127 : 		size_type _N0, const _Myt& _Right,
; 2128 : 		size_type _Roff, size_type _Count) const
; 2129 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2130 : 		if (_Right.size() < _Roff)
; 2131 : 			_Xran();	// _Off off end
; 2132 : 		if (_Right._Mysize - _Roff < _Count)
; 2133 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2134 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2135 : 		}
; 2136 : 
; 2137 : 	int compare(const _Elem *_Ptr) const
; 2138 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2139 : 		_DEBUG_POINTER(_Ptr);
; 2140 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2141 : 		}
; 2142 : 
; 2143 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2144 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2145 : 		_DEBUG_POINTER(_Ptr);
; 2146 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2147 : 		}
; 2148 : 
; 2149 : 	int compare(size_type _Off,
; 2150 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2151 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2152 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2153 : 		if (_Count != 0)
; 2154 : 			_DEBUG_POINTER(_Ptr);
; 2155 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2156 : 
; 2157 : 		if (this->_Mysize < _Off)
; 2158 : 			_Xran();	// _Off off end
; 2159 : 		if (this->_Mysize - _Off < _N0)
; 2160 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2161 : 
; 2162 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2163 : 			_N0 < _Count ? _N0 : _Count);
; 2164 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2165 : 			: _N0 == _Count ? 0 : +1);
; 2166 : 		}
; 2167 : 
; 2168 : 	allocator_type get_allocator() const _NOEXCEPT
; 2169 : 		{	// return allocator object for values
; 2170 : 		return (this->_Getal());
; 2171 : 		}
; 2172 : 
; 2173 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2174 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2175 : 		if (_Count == 1)
; 2176 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2177 : 		else
; 2178 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2179 : 		}
; 2180 : 
; 2181 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2182 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2183 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2184 : 		if (max_size() < _Newres)
; 2185 : 			_Newres = _Newsize;	// undo roundup if too big
; 2186 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2187 : 			;
; 2188 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2189 : 			_Newres = this->_Myres
; 2190 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2191 : 		else
; 2192 : 			_Newres = max_size();	// settle for max_size()
; 2193 : 
; 2194 : 		_Elem *_Ptr;
; 2195 : 		_TRY_BEGIN
; 2196 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2197 : 		_CATCH_ALL
; 2198 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2199 : 			_TRY_BEGIN
; 2200 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2201 : 			_CATCH_ALL
; 2202 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2203 : 			_RERAISE;
; 2204 : 			_CATCH_END
; 2205 : 		_CATCH_END
; 2206 : 
; 2207 : 		if (0 < _Oldlen)
; 2208 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2209 : 				_Oldlen);	// copy existing elements
; 2210 : 		_Tidy(true);
; 2211 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2212 : 		this->_Myres = _Newres;
; 2213 : 		_Eos(_Oldlen);
; 2214 : 		}
; 2215 : 
; 2216 : 	void _Eos(size_type _Newsize)
; 2217 : 		{	// set new length and null terminator
; 2218 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  003b7	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR $T6[esp+152], 0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd

; 347  : 		_Left = _Right;

  003bf	66 89 44 24 50	 mov	 WORD PTR $T6[esp+136], ax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 1144 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

  003c4	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
; File c:\users\glenn\documents\github\wind\project\wind\wind\window.cpp

; 21   : {

  003c9	8b 45 08	 mov	 eax, DWORD PTR __hInstance$[ebp]
  003cc	89 46 04	 mov	 DWORD PTR [esi+4], eax
  003cf	8d 4e 18	 lea	 ecx, DWORD PTR [esi+24]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd

; 347  : 		_Left = _Right;

  003d2	33 c0		 xor	 eax, eax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 735  : 		assign(_Right, 0, npos);

  003d4	6a ff		 push	 -1

; 2265 : 		this->_Myres = this->_BUF_SIZE - 1;

  003d6	c7 41 14 07 00
	00 00		 mov	 DWORD PTR [ecx+20], 7

; 1145 : 		}
; 1146 : 
; 1147 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1148 : 		{	// assign _Count * _Ch
; 1149 : 		if (_Count == npos)
; 1150 : 			_Xlen();	// result too long
; 1151 : 
; 1152 : 		if (_Grow(_Count))
; 1153 : 			{	// make room and assign new stuff
; 1154 : 			_Chassign(0, _Count, _Ch);
; 1155 : 			_Eos(_Count);
; 1156 : 			}
; 1157 : 		return (*this);
; 1158 : 		}
; 1159 : 
; 1160 : 	template<class _Iter>
; 1161 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1162 : 			_Myt&>::type
; 1163 : 		assign(_Iter _First, _Iter _Last)
; 1164 : 		{	// assign [First, _Last), input iterators
; 1165 : 		return (replace(begin(), end(), _First, _Last));
; 1166 : 		}
; 1167 : 
; 1168 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1169 : 		{	// assign [First, _Last), const pointers
; 1170 : 		return (replace(begin(), end(), _First, _Last));
; 1171 : 		}
; 1172 : 
; 1173 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1174 : 		{	// assign [First, _Last), const_iterators
; 1175 : 		return (replace(begin(), end(), _First, _Last));
; 1176 : 		}
; 1177 : 
; 1178 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1179 : 		{	// insert _Right at _Off
; 1180 : 		return (insert(_Off, _Right, 0, npos));
; 1181 : 		}
; 1182 : 
; 1183 : 	_Myt& insert(size_type _Off,
; 1184 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1185 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1186 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1187 : 			_Xran();	// _Off or _Roff off end
; 1188 : 		size_type _Num = _Right.size() - _Roff;
; 1189 : 		if (_Num < _Count)
; 1190 : 			_Count = _Num;	// trim _Count to size
; 1191 : 		if (npos - this->_Mysize <= _Count)
; 1192 : 			_Xlen();	// result too long
; 1193 : 
; 1194 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1195 : 			{	// make room and insert new stuff
; 1196 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1197 : 				this->_Myptr() + _Off,
; 1198 : 				this->_Mysize - _Off);	// empty out hole
; 1199 : 			if (this == &_Right)
; 1200 : 				_Traits::move(this->_Myptr() + _Off,
; 1201 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1202 : 						_Count);	// substring
; 1203 : 			else
; 1204 : 				_Traits::copy(this->_Myptr() + _Off,
; 1205 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1206 : 			_Eos(_Num);
; 1207 : 			}
; 1208 : 		return (*this);
; 1209 : 		}
; 1210 : 
; 1211 : 	_Myt& insert(size_type _Off,
; 1212 : 		const _Elem *_Ptr, size_type _Count)
; 1213 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1214 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1215 : 		if (_Count != 0)
; 1216 : 			_DEBUG_POINTER(_Ptr);
; 1217 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1218 : 
; 1219 : 		if (_Inside(_Ptr))
; 1220 : 			return (insert(_Off, *this,
; 1221 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1222 : 		if (this->_Mysize < _Off)
; 1223 : 			_Xran();	// _Off off end
; 1224 : 		if (npos - this->_Mysize <= _Count)
; 1225 : 			_Xlen();	// result too long
; 1226 : 		size_type _Num;
; 1227 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1228 : 			{	// make room and insert new stuff
; 1229 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1230 : 				this->_Myptr() + _Off,
; 1231 : 				this->_Mysize - _Off);	// empty out hole
; 1232 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1233 : 			_Eos(_Num);
; 1234 : 			}
; 1235 : 		return (*this);
; 1236 : 		}
; 1237 : 
; 1238 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1239 : 		{	// insert [_Ptr, <null>) at _Off
; 1240 : 		_DEBUG_POINTER(_Ptr);
; 1241 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1242 : 		}
; 1243 : 
; 1244 : 	_Myt& insert(size_type _Off,
; 1245 : 		size_type _Count, _Elem _Ch)
; 1246 : 		{	// insert _Count * _Ch at _Off
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	iterator insert(const_iterator _Where)
; 1264 : 		{	// insert <null> at _Where
; 1265 : 		return (insert(_Where, _Elem()));
; 1266 : 		}
; 1267 : 
; 1268 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1269 : 		{	// insert _Ch at _Where
; 1270 : 		size_type _Off = _Pdif(_Where, begin());
; 1271 : 		insert(_Off, 1, _Ch);
; 1272 : 		return (begin() + _Off);
; 1273 : 		}
; 1274 : 
; 1275 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1276 : 		{	// insert _Count * _Elem at _Where
; 1277 : 		size_type _Off = _Pdif(_Where, begin());
; 1278 : 		insert(_Off, _Count, _Ch);
; 1279 : 		return (begin() + _Off);
; 1280 : 		}
; 1281 : 
; 1282 : 	template<class _Iter>
; 1283 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1284 : 			iterator>::type
; 1285 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1286 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1287 : 		size_type _Off = _Pdif(_Where, begin());
; 1288 : 		replace(_Where, _Where, _First, _Last);
; 1289 : 		return (begin() + _Off);
; 1290 : 		}
; 1291 : 
; 1292 : 	iterator insert(const_iterator _Where,
; 1293 : 		const_pointer _First, const_pointer _Last)
; 1294 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		replace(_Where, _Where, _First, _Last);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where,
; 1301 : 		const_iterator _First, const_iterator _Last)
; 1302 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1303 : 		size_type _Off = _Pdif(_Where, begin());
; 1304 : 		replace(_Where, _Where, _First, _Last);
; 1305 : 		return (begin() + _Off);
; 1306 : 		}
; 1307 : 
; 1308 : 	_Myt& erase(size_type _Off = 0)
; 1309 : 		{	// erase elements [_Off, ...)
; 1310 : 		if (this->_Mysize < _Off)
; 1311 : 			_Xran();	// _Off off end
; 1312 : 		_Eos(_Off);
; 1313 : 		return (*this);
; 1314 : 		}
; 1315 : 
; 1316 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1317 : 		{	// erase elements [_Off, _Off + _Count)
; 1318 : 		if (this->_Mysize < _Off)
; 1319 : 			_Xran();	// _Off off end
; 1320 : 		if (this->_Mysize - _Off <= _Count)
; 1321 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1322 : 		else if (0 < _Count)
; 1323 : 			{	// move elements down
; 1324 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1325 : 			size_type _Newsize = this->_Mysize - _Count;
; 1326 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1327 : 			_Eos(_Newsize);
; 1328 : 			}
; 1329 : 		return (*this);
; 1330 : 		}
; 1331 : 
; 1332 : 	iterator erase(const_iterator _Where)
; 1333 : 		{	// erase element at _Where
; 1334 : 		size_type _Count = _Pdif(_Where, begin());
; 1335 : 		erase(_Count, 1);
; 1336 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1337 : 		}
; 1338 : 
; 1339 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1340 : 		{	// erase substring [_First, _Last)
; 1341 : 		_DEBUG_RANGE(_First, _Last);
; 1342 : 		size_type _Count = _Pdif(_First, begin());
; 1343 : 		erase(_Count, _Pdif(_Last, _First));
; 1344 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1345 : 		}
; 1346 : 
; 1347 : 	void clear() _NOEXCEPT
; 1348 : 		{	// erase all
; 1349 : 		_Eos(0);
; 1350 : 		}
; 1351 : 
; 1352 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1353 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1354 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1355 : 		}
; 1356 : 
; 1357 : 	_Myt& replace(size_type _Off,
; 1358 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1359 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1360 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1361 : 			_Xran();	// _Off or _Roff off end
; 1362 : 		if (this->_Mysize - _Off < _N0)
; 1363 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1364 : 		size_type _Num = _Right.size() - _Roff;
; 1365 : 		if (_Num < _Count)
; 1366 : 			_Count = _Num;	// trim _Count to size
; 1367 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1368 : 			_Xlen();	// result too long
; 1369 : 
; 1370 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1371 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1372 : 		if (this->_Mysize < _Newsize)
; 1373 : 			_Grow(_Newsize);
; 1374 : 
; 1375 : 		if (this != &_Right)
; 1376 : 			{	// no overlap, just move down and copy in new stuff
; 1377 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1378 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1379 : 			_Traits::copy(this->_Myptr() + _Off,
; 1380 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1381 : 			}
; 1382 : 		else if (_Count <= _N0)
; 1383 : 			{	// hole doesn't get larger, just copy in substring
; 1384 : 			_Traits::move(this->_Myptr() + _Off,
; 1385 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1386 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1387 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1388 : 			}
; 1389 : 		else if (_Roff <= _Off)
; 1390 : 			{	// hole gets larger, substring begins before hole
; 1391 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1392 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1393 : 			_Traits::move(this->_Myptr() + _Off,
; 1394 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1395 : 			}
; 1396 : 		else if (_Off + _N0 <= _Roff)
; 1397 : 			{	// hole gets larger, substring begins after hole
; 1398 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1399 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1400 : 			_Traits::move(this->_Myptr() + _Off,
; 1401 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1402 : 				_Count);	// fill hole
; 1403 : 			}
; 1404 : 		else
; 1405 : 			{	// hole gets larger, substring begins in hole
; 1406 : 			_Traits::move(this->_Myptr() + _Off,
; 1407 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1408 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1409 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1410 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1411 : 				this->_Myptr() + _Roff + _Count,
; 1412 : 				_Count - _N0);	// fill rest of new hole
; 1413 : 			}
; 1414 : 
; 1415 : 		_Eos(_Newsize);
; 1416 : 		return (*this);
; 1417 : 		}
; 1418 : 
; 1419 : 	_Myt& replace(size_type _Off,
; 1420 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1421 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1422 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1423 : 		if (_Count != 0)
; 1424 : 			_DEBUG_POINTER(_Ptr);
; 1425 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1426 : 
; 1427 : 		if (_Inside(_Ptr))
; 1428 : 			return (replace(_Off, _N0, *this,
; 1429 : 				_Ptr - this->_Myptr(),
; 1430 : 				_Count));	// substring, replace carefully
; 1431 : 		if (this->_Mysize < _Off)
; 1432 : 			_Xran();	// _Off off end
; 1433 : 		if (this->_Mysize - _Off < _N0)
; 1434 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1435 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1436 : 			_Xlen();	// result too long
; 1437 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1438 : 
; 1439 : 		if (_Count < _N0)
; 1440 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1441 : 				this->_Myptr() + _Off + _N0,
; 1442 : 				_Nm);	// smaller hole, move tail up
; 1443 : 		size_type _Num;
; 1444 : 		if ((0 < _Count || 0 < _N0)
; 1445 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1446 : 			{	// make room and rearrange
; 1447 : 			if (_N0 < _Count)
; 1448 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1449 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1450 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1451 : 			_Eos(_Num);
; 1452 : 			}
; 1453 : 		return (*this);
; 1454 : 		}
; 1455 : 
; 1456 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1457 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1458 : 		_DEBUG_POINTER(_Ptr);
; 1459 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1460 : 		}
; 1461 : 
; 1462 : 	_Myt& replace(size_type _Off,
; 1463 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1464 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1465 : 		if (this->_Mysize < _Off)
; 1466 : 			_Xran();	// _Off off end
; 1467 : 		if (this->_Mysize - _Off < _N0)
; 1468 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1469 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1470 : 			_Xlen();	// result too long
; 1471 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1472 : 
; 1473 : 		if (_Count < _N0)
; 1474 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1475 : 				this->_Myptr() + _Off + _N0,
; 1476 : 				_Nm);	// smaller hole, move tail up
; 1477 : 		size_type _Num;
; 1478 : 		if ((0 < _Count || 0 < _N0)
; 1479 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1480 : 			{	// make room and rearrange
; 1481 : 			if (_N0 < _Count)
; 1482 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1483 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1484 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1485 : 			_Eos(_Num);
; 1486 : 			}
; 1487 : 		return (*this);
; 1488 : 		}
; 1489 : 
; 1490 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1491 : 		const _Myt& _Right)
; 1492 : 		{	// replace [_First, _Last) with _Right
; 1493 : 		return (replace(
; 1494 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1495 : 		}
; 1496 : 
; 1497 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1498 : 		const _Elem *_Ptr, size_type _Count)
; 1499 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1500 : 		return (replace(
; 1501 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1502 : 		}
; 1503 : 
; 1504 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1505 : 		const _Elem *_Ptr)
; 1506 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1507 : 		return (replace(
; 1508 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1509 : 		}
; 1510 : 
; 1511 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1512 : 		size_type _Count, _Elem _Ch)
; 1513 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1514 : 		return (replace(
; 1515 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1516 : 		}
; 1517 : 
; 1518 : 	template<class _Iter>
; 1519 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1520 : 			_Myt&>::type
; 1521 : 		replace(const_iterator _First, const_iterator _Last,
; 1522 : 			_Iter _First2, _Iter _Last2)
; 1523 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1524 : 		_Myt _Right(_First2, _Last2);
; 1525 : 		replace(_First, _Last, _Right);
; 1526 : 		return (*this);
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const_pointer _First2, const_pointer _Last2)
; 1531 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1532 : 		if (_First2 == _Last2)
; 1533 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1534 : 		else
; 1535 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1536 : 				&*_First2, _Last2 - _First2);
; 1537 : 		return (*this);
; 1538 : 		}
; 1539 : 
; 1540 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1541 : 		pointer _First2, pointer _Last2)
; 1542 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1543 : 		if (_First2 == _Last2)
; 1544 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1545 : 		else
; 1546 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1547 : 				&*_First2, _Last2 - _First2);
; 1548 : 		return (*this);
; 1549 : 		}
; 1550 : 
; 1551 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1552 : 		const_iterator _First2, const_iterator _Last2)
; 1553 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1554 : 		if (_First2 == _Last2)
; 1555 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1556 : 		else
; 1557 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1558 : 				&*_First2, _Last2 - _First2);
; 1559 : 		return (*this);
; 1560 : 		}
; 1561 : 
; 1562 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1563 : 		iterator _First2, iterator _Last2)
; 1564 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1565 : 		if (_First2 == _Last2)
; 1566 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1567 : 		else
; 1568 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1569 : 				&*_First2, _Last2 - _First2);
; 1570 : 		return (*this);
; 1571 : 		}
; 1572 : 
; 1573 : 	iterator begin() _NOEXCEPT
; 1574 : 		{	// return iterator for beginning of mutable sequence
; 1575 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1576 : 		}
; 1577 : 
; 1578 : 	const_iterator begin() const _NOEXCEPT
; 1579 : 		{	// return iterator for beginning of nonmutable sequence
; 1580 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1581 : 		}
; 1582 : 
; 1583 : 	iterator end() _NOEXCEPT
; 1584 : 		{	// return iterator for end of mutable sequence
; 1585 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1586 : 		}
; 1587 : 
; 1588 : 	const_iterator end() const _NOEXCEPT
; 1589 : 		{	// return iterator for end of nonmutable sequence
; 1590 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1591 : 		}
; 1592 : 
; 1593 : 	reverse_iterator rbegin() _NOEXCEPT
; 1594 : 		{	// return iterator for beginning of reversed mutable sequence
; 1595 : 		return (reverse_iterator(end()));
; 1596 : 		}
; 1597 : 
; 1598 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1600 : 		return (const_reverse_iterator(end()));
; 1601 : 		}
; 1602 : 
; 1603 : 	reverse_iterator rend() _NOEXCEPT
; 1604 : 		{	// return iterator for end of reversed mutable sequence
; 1605 : 		return (reverse_iterator(begin()));
; 1606 : 		}
; 1607 : 
; 1608 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1609 : 		{	// return iterator for end of reversed nonmutable sequence
; 1610 : 		return (const_reverse_iterator(begin()));
; 1611 : 		}
; 1612 : 
; 1613 :  #if _HAS_CPP0X
; 1614 : 	const_iterator cbegin() const _NOEXCEPT
; 1615 : 		{	// return iterator for beginning of nonmutable sequence
; 1616 : 		return (((const _Myt *)this)->begin());
; 1617 : 		}
; 1618 : 
; 1619 : 	const_iterator cend() const _NOEXCEPT
; 1620 : 		{	// return iterator for end of nonmutable sequence
; 1621 : 		return (((const _Myt *)this)->end());
; 1622 : 		}
; 1623 : 
; 1624 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1625 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1626 : 		return (((const _Myt *)this)->rbegin());
; 1627 : 		}
; 1628 : 
; 1629 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1630 : 		{	// return iterator for end of reversed nonmutable sequence
; 1631 : 		return (((const _Myt *)this)->rend());
; 1632 : 		}
; 1633 : 
; 1634 : 	void shrink_to_fit()
; 1635 : 		{	// reduce capacity
; 1636 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1637 : 			{	// worth shrinking, do it
; 1638 : 			_Myt _Tmp(*this);
; 1639 : 			swap(_Tmp);
; 1640 : 			}
; 1641 : 		}
; 1642 :  #endif /* _HAS_CPP0X */
; 1643 : 
; 1644 : 	reference at(size_type _Off)
; 1645 : 		{	// subscript mutable sequence with checking
; 1646 : 		if (this->_Mysize <= _Off)
; 1647 : 			_Xran();	// _Off off end
; 1648 : 		return (this->_Myptr()[_Off]);
; 1649 : 		}
; 1650 : 
; 1651 : 	const_reference at(size_type _Off) const
; 1652 : 		{	// subscript nonmutable sequence with checking
; 1653 : 		if (this->_Mysize <= _Off)
; 1654 : 			_Xran();	// _Off off end
; 1655 : 		return (this->_Myptr()[_Off]);
; 1656 : 		}
; 1657 : 
; 1658 : 	reference operator[](size_type _Off)
; 1659 : 		{	// subscript mutable sequence
; 1660 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1661 : 		if (this->_Mysize < _Off)	// sic
; 1662 : 			_DEBUG_ERROR("string subscript out of range");
; 1663 : 
; 1664 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1665 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1666 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1667 : 
; 1668 : 		return (this->_Myptr()[_Off]);
; 1669 : 		}
; 1670 : 
; 1671 : 	const_reference operator[](size_type _Off) const
; 1672 : 		{	// subscript nonmutable sequence
; 1673 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1674 : 		if (this->_Mysize < _Off)	// sic
; 1675 : 			_DEBUG_ERROR("string subscript out of range");
; 1676 : 
; 1677 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1678 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1679 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1680 : 
; 1681 : 		return (this->_Myptr()[_Off]);
; 1682 : 		}
; 1683 : 
; 1684 : 	void push_back(_Elem _Ch)
; 1685 : 		{	// insert element at end
; 1686 : 		insert(end(), _Ch);
; 1687 : 		}
; 1688 : 
; 1689 :  #if _HAS_CPP0X
; 1690 : 	void pop_back()
; 1691 : 		{	// erase element at end
; 1692 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1693 : 		}
; 1694 : 
; 1695 : 	reference front()
; 1696 : 		{	// return first element of mutable sequence
; 1697 : 		return (*begin());
; 1698 : 		}
; 1699 : 
; 1700 : 	const_reference front() const
; 1701 : 		{	// return first element of nonmutable sequence
; 1702 : 		return (*begin());
; 1703 : 		}
; 1704 : 
; 1705 : 	reference back()
; 1706 : 		{	// return last element of mutable sequence
; 1707 : 		return (*(end() - 1));
; 1708 : 		}
; 1709 : 
; 1710 : 	const_reference back() const
; 1711 : 		{	// return last element of nonmutable sequence
; 1712 : 		return (*(end() - 1));
; 1713 : 		}
; 1714 :  #endif /* _HAS_CPP0X */
; 1715 : 
; 1716 : 	const _Elem *c_str() const _NOEXCEPT
; 1717 : 		{	// return pointer to null-terminated nonmutable array
; 1718 : 		return (this->_Myptr());
; 1719 : 		}
; 1720 : 
; 1721 : 	const _Elem *data() const _NOEXCEPT
; 1722 : 		{	// return pointer to nonmutable array
; 1723 : 		return (c_str());
; 1724 : 		}
; 1725 : 
; 1726 : 	size_type length() const _NOEXCEPT
; 1727 : 		{	// return length of sequence
; 1728 : 		return (this->_Mysize);
; 1729 : 		}
; 1730 : 
; 1731 : 	size_type size() const _NOEXCEPT
; 1732 : 		{	// return length of sequence
; 1733 : 		return (this->_Mysize);
; 1734 : 		}
; 1735 : 
; 1736 : 	size_type max_size() const _NOEXCEPT
; 1737 : 		{	// return maximum possible length of sequence
; 1738 : 		size_type _Num = this->_Getal().max_size();
; 1739 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1740 : 		}
; 1741 : 
; 1742 : 	void resize(size_type _Newsize)
; 1743 : 		{	// determine new length, padding with null elements as needed
; 1744 : 		resize(_Newsize, _Elem());
; 1745 : 		}
; 1746 : 
; 1747 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1748 : 		{	// determine new length, padding with _Ch elements as needed
; 1749 : 		if (_Newsize <= this->_Mysize)
; 1750 : 			_Eos(_Newsize);
; 1751 : 		else
; 1752 : 			append(_Newsize - this->_Mysize, _Ch);
; 1753 : 		}
; 1754 : 
; 1755 : 	size_type capacity() const _NOEXCEPT
; 1756 : 		{	// return current length of allocated storage
; 1757 : 		return (this->_Myres);
; 1758 : 		}
; 1759 : 
; 1760 : 	void reserve(size_type _Newcap = 0)
; 1761 : 		{	// determine new minimum length of allocated storage
; 1762 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1763 : 			{	// change reservation
; 1764 : 			size_type _Size = this->_Mysize;
; 1765 : 			if (_Grow(_Newcap, true))
; 1766 : 				_Eos(_Size);
; 1767 : 			}
; 1768 : 		}
; 1769 : 
; 1770 : 	bool empty() const _NOEXCEPT
; 1771 : 		{	// test if sequence is empty
; 1772 : 		return (this->_Mysize == 0);
; 1773 : 		}
; 1774 : 
; 1775 : 	_SCL_INSECURE_DEPRECATE
; 1776 : 
; 1777 : 	size_type copy(_Elem *_Ptr,
; 1778 : 		size_type _Count, size_type _Off = 0) const
; 1779 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1780 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1781 : 		if (_Count != 0)
; 1782 : 			_DEBUG_POINTER(_Ptr);
; 1783 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1784 : 
; 1785 : 		if (this->_Mysize < _Off)
; 1786 : 			_Xran();	// _Off off end
; 1787 : 		if (this->_Mysize - _Off < _Count)
; 1788 : 			_Count = this->_Mysize - _Off;
; 1789 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1790 : 		return (_Count);
; 1791 : 		}
; 1792 : 
; 1793 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1794 : 		size_type _Count, size_type _Off = 0) const
; 1795 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1796 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1797 : 		if (_Count != 0)
; 1798 : 			_DEBUG_POINTER(_Dest);
; 1799 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1800 : 
; 1801 : 		if (this->_Mysize < _Off)
; 1802 : 			_Xran();	// _Off off end
; 1803 : 		if (this->_Mysize - _Off < _Count)
; 1804 : 			_Count = this->_Mysize - _Off;
; 1805 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1806 : 		return (_Count);
; 1807 : 		}
; 1808 : 
; 1809 : 	void _Swap_bx(_Myt& _Right)
; 1810 : 		{	// exchange _Bx with _Right._Bx
; 1811 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1812 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1813 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1814 : 			else
; 1815 : 				{	// swap large with small
; 1816 : 				pointer _Ptr = this->_Bx._Ptr;
; 1817 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1818 : 				_Traits::copy(this->_Bx._Buf,
; 1819 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1820 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1821 : 				}
; 1822 : 		else
; 1823 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1824 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1825 : 			else
; 1826 : 				{	// swap small with large
; 1827 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1828 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1829 : 				_Traits::copy(_Right._Bx._Buf,
; 1830 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1831 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1832 : 				}
; 1833 : 		}
; 1834 : 
; 1835 : 	void swap(_Myt& _Right)
; 1836 : 		{	// exchange contents with _Right
; 1837 : 		if (this == &_Right)
; 1838 : 			;	// same object, do nothing
; 1839 : 		else if (this->_Getal() == _Right._Getal())
; 1840 : 			{	// same allocator, swap control information
; 1841 : 			this->_Swap_all(_Right);
; 1842 : 			_Swap_bx(_Right);
; 1843 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1844 : 			_STD swap(this->_Myres, _Right._Myres);
; 1845 : 			}
; 1846 : 
; 1847 :  #if _HAS_CPP0X
; 1848 : 		else if (_Alty::propagate_on_container_swap::value)
; 1849 : 			{	// swap allocators and control information
; 1850 : 			this->_Swap_alloc(_Right);
; 1851 : 			_Swap_bx(_Right);
; 1852 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1853 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1854 : 			_STD swap(this->_Myres, _Right._Myres);
; 1855 : 			}
; 1856 :  #endif /* _HAS_CPP0X */
; 1857 : 
; 1858 : 		else
; 1859 : 			{	// different allocator, do multiple assigns
; 1860 : 			_Myt _Tmp = *this;
; 1861 : 
; 1862 : 			*this = _Right;
; 1863 : 			_Right = _Tmp;
; 1864 : 			}
; 1865 : 		}
; 1866 : 
; 1867 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1868 : 		{	// look for _Right beginning at or after _Off
; 1869 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1870 : 		}
; 1871 : 
; 1872 : 	size_type find(const _Elem *_Ptr,
; 1873 : 		size_type _Off, size_type _Count) const
; 1874 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1875 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1876 : 		if (_Count != 0)
; 1877 : 			_DEBUG_POINTER(_Ptr);
; 1878 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1879 : 
; 1880 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1881 : 			return (_Off);	// null string always matches (if inside string)
; 1882 : 
; 1883 : 		size_type _Nm;
; 1884 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1885 : 			{	// room for match, look for it
; 1886 : 			const _Elem *_Uptr, *_Vptr;
; 1887 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1888 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1889 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1890 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1891 : 					return (_Uptr - this->_Myptr());	// found a match
; 1892 : 			}
; 1893 : 
; 1894 : 		return (npos);	// no match
; 1895 : 		}
; 1896 : 
; 1897 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1898 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1899 : 		_DEBUG_POINTER(_Ptr);
; 1900 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1901 : 		}
; 1902 : 
; 1903 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1904 : 		{	// look for _Ch at or after _Off
; 1905 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1906 : 		}
; 1907 : 
; 1908 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1909 : 		{	// look for _Right beginning before _Off
; 1910 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1911 : 		}
; 1912 : 
; 1913 : 	size_type rfind(const _Elem *_Ptr,
; 1914 : 		size_type _Off, size_type _Count) const
; 1915 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1916 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1917 : 		if (_Count != 0)
; 1918 : 			_DEBUG_POINTER(_Ptr);
; 1919 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1920 : 
; 1921 : 		if (_Count == 0)
; 1922 : 			return (_Off < this->_Mysize ? _Off
; 1923 : 				: this->_Mysize);	// null always matches
; 1924 : 		if (_Count <= this->_Mysize)
; 1925 : 			{	// room for match, look for it
; 1926 : 			const _Elem *_Uptr = this->_Myptr() +
; 1927 : 				(_Off < this->_Mysize - _Count ? _Off
; 1928 : 					: this->_Mysize - _Count);
; 1929 : 			for (; ; --_Uptr)
; 1930 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1931 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1932 : 					return (_Uptr - this->_Myptr());	// found a match
; 1933 : 				else if (_Uptr == this->_Myptr())
; 1934 : 					break;	// at beginning, no more chance for match
; 1935 : 			}
; 1936 : 
; 1937 : 		return (npos);	// no match
; 1938 : 		}
; 1939 : 
; 1940 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1941 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1942 : 		_DEBUG_POINTER(_Ptr);
; 1943 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1944 : 		}
; 1945 : 
; 1946 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1947 : 		{	// look for _Ch before _Off
; 1948 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1949 : 		}
; 1950 : 
; 1951 : 	size_type find_first_of(const _Myt& _Right,
; 1952 : 		size_type _Off = 0) const _NOEXCEPT
; 1953 : 		{	// look for one of _Right at or after _Off
; 1954 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1955 : 		}
; 1956 : 
; 1957 : 	size_type find_first_of(const _Elem *_Ptr,
; 1958 : 		size_type _Off, size_type _Count) const
; 1959 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1960 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1961 : 		if (_Count != 0)
; 1962 : 			_DEBUG_POINTER(_Ptr);
; 1963 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1964 : 
; 1965 : 		if (0 < _Count && _Off < this->_Mysize)
; 1966 : 			{	// room for match, look for it
; 1967 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1968 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1969 : 				_Uptr < _Vptr; ++_Uptr)
; 1970 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1971 : 					return (_Uptr - this->_Myptr());	// found a match
; 1972 : 			}
; 1973 : 
; 1974 : 		return (npos);	// no match
; 1975 : 		}
; 1976 : 
; 1977 : 	size_type find_first_of(const _Elem *_Ptr,
; 1978 : 		size_type _Off = 0) const
; 1979 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1980 : 		_DEBUG_POINTER(_Ptr);
; 1981 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 1982 : 		}
; 1983 : 
; 1984 : 	size_type find_first_of(_Elem _Ch,
; 1985 : 		size_type _Off = 0) const
; 1986 : 		{	// look for _Ch at or after _Off
; 1987 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1988 : 		}
; 1989 : 
; 1990 : 	size_type find_last_of(const _Myt& _Right,
; 1991 : 		size_type _Off = npos) const _NOEXCEPT
; 1992 : 		{	// look for one of _Right before _Off
; 1993 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_last_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off, size_type _Count) const
; 1998 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 1999 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2000 : 		if (_Count != 0)
; 2001 : 			_DEBUG_POINTER(_Ptr);
; 2002 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2003 : 
; 2004 : 		if (0 < _Count && 0 < this->_Mysize)
; 2005 : 			{	// worth searching, do it
; 2006 : 			const _Elem *_Uptr = this->_Myptr()
; 2007 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2008 : 			for (; ; --_Uptr)
; 2009 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2010 : 					return (_Uptr - this->_Myptr());	// found a match
; 2011 : 				else if (_Uptr == this->_Myptr())
; 2012 : 					break;	// at beginning, no more chance for match
; 2013 : 			}
; 2014 : 
; 2015 : 		return (npos);	// no match
; 2016 : 		}
; 2017 : 
; 2018 : 	size_type find_last_of(const _Elem *_Ptr,
; 2019 : 		size_type _Off = npos) const
; 2020 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2021 : 		_DEBUG_POINTER(_Ptr);
; 2022 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2023 : 		}
; 2024 : 
; 2025 : 	size_type find_last_of(_Elem _Ch,
; 2026 : 		size_type _Off = npos) const
; 2027 : 		{	// look for _Ch before _Off
; 2028 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2029 : 		}
; 2030 : 
; 2031 : 	size_type find_first_not_of(const _Myt& _Right,
; 2032 : 		size_type _Off = 0) const _NOEXCEPT
; 2033 : 		{	// look for none of _Right at or after _Off
; 2034 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2035 : 			_Right.size()));
; 2036 : 		}
; 2037 : 
; 2038 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2039 : 		size_type _Off, size_type _Count) const
; 2040 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2041 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2042 : 		if (_Count != 0)
; 2043 : 			_DEBUG_POINTER(_Ptr);
; 2044 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2045 : 
; 2046 : 		if (_Off < this->_Mysize)
; 2047 : 			{	// room for match, look for it
; 2048 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2049 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2050 : 				_Uptr < _Vptr; ++_Uptr)
; 2051 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2052 : 					return (_Uptr - this->_Myptr());
; 2053 : 			}
; 2054 : 		return (npos);
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off = 0) const
; 2059 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2060 : 		_DEBUG_POINTER(_Ptr);
; 2061 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2062 : 		}
; 2063 : 
; 2064 : 	size_type find_first_not_of(_Elem _Ch,
; 2065 : 		size_type _Off = 0) const
; 2066 : 		{	// look for non _Ch at or after _Off
; 2067 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2068 : 		}
; 2069 : 
; 2070 : 	size_type find_last_not_of(const _Myt& _Right,
; 2071 : 		size_type _Off = npos) const _NOEXCEPT
; 2072 : 		{	// look for none of _Right before _Off
; 2073 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off, size_type _Count) const
; 2078 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2079 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2080 : 		if (_Count != 0)
; 2081 : 			_DEBUG_POINTER(_Ptr);
; 2082 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2083 : 
; 2084 : 		if (0 < this->_Mysize)
; 2085 : 			{	// worth searching, do it
; 2086 : 			const _Elem *_Uptr = this->_Myptr()
; 2087 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2088 : 			for (; ; --_Uptr)
; 2089 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2090 : 					return (_Uptr - this->_Myptr());
; 2091 : 				else if (_Uptr == this->_Myptr())
; 2092 : 					break;
; 2093 : 			}
; 2094 : 		return (npos);
; 2095 : 		}
; 2096 : 
; 2097 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2098 : 		size_type _Off = npos) const
; 2099 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2100 : 		_DEBUG_POINTER(_Ptr);
; 2101 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2102 : 		}
; 2103 : 
; 2104 : 	size_type find_last_not_of(_Elem _Ch,
; 2105 : 		size_type _Off = npos) const
; 2106 : 		{	// look for non _Ch before _Off
; 2107 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2108 : 		}
; 2109 : 
; 2110 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2111 : 		{	// return [_Off, _Off + _Count) as new string
; 2112 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2113 : 		}
; 2114 : 
; 2115 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2116 : 		{	// compare [0, _Mysize) with _Right
; 2117 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2118 : 		}
; 2119 : 
; 2120 : 	int compare(size_type _Off, size_type _N0,
; 2121 : 		const _Myt& _Right) const
; 2122 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2123 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2124 : 		}
; 2125 : 
; 2126 : 	int compare(size_type _Off,
; 2127 : 		size_type _N0, const _Myt& _Right,
; 2128 : 		size_type _Roff, size_type _Count) const
; 2129 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2130 : 		if (_Right.size() < _Roff)
; 2131 : 			_Xran();	// _Off off end
; 2132 : 		if (_Right._Mysize - _Roff < _Count)
; 2133 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2134 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2135 : 		}
; 2136 : 
; 2137 : 	int compare(const _Elem *_Ptr) const
; 2138 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2139 : 		_DEBUG_POINTER(_Ptr);
; 2140 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2141 : 		}
; 2142 : 
; 2143 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2144 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2145 : 		_DEBUG_POINTER(_Ptr);
; 2146 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2147 : 		}
; 2148 : 
; 2149 : 	int compare(size_type _Off,
; 2150 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2151 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2152 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2153 : 		if (_Count != 0)
; 2154 : 			_DEBUG_POINTER(_Ptr);
; 2155 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2156 : 
; 2157 : 		if (this->_Mysize < _Off)
; 2158 : 			_Xran();	// _Off off end
; 2159 : 		if (this->_Mysize - _Off < _N0)
; 2160 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2161 : 
; 2162 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2163 : 			_N0 < _Count ? _N0 : _Count);
; 2164 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2165 : 			: _N0 == _Count ? 0 : +1);
; 2166 : 		}
; 2167 : 
; 2168 : 	allocator_type get_allocator() const _NOEXCEPT
; 2169 : 		{	// return allocator object for values
; 2170 : 		return (this->_Getal());
; 2171 : 		}
; 2172 : 
; 2173 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2174 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2175 : 		if (_Count == 1)
; 2176 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2177 : 		else
; 2178 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2179 : 		}
; 2180 : 
; 2181 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2182 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2183 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2184 : 		if (max_size() < _Newres)
; 2185 : 			_Newres = _Newsize;	// undo roundup if too big
; 2186 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2187 : 			;
; 2188 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2189 : 			_Newres = this->_Myres
; 2190 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2191 : 		else
; 2192 : 			_Newres = max_size();	// settle for max_size()
; 2193 : 
; 2194 : 		_Elem *_Ptr;
; 2195 : 		_TRY_BEGIN
; 2196 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2197 : 		_CATCH_ALL
; 2198 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2199 : 			_TRY_BEGIN
; 2200 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2201 : 			_CATCH_ALL
; 2202 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2203 : 			_RERAISE;
; 2204 : 			_CATCH_END
; 2205 : 		_CATCH_END
; 2206 : 
; 2207 : 		if (0 < _Oldlen)
; 2208 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2209 : 				_Oldlen);	// copy existing elements
; 2210 : 		_Tidy(true);
; 2211 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2212 : 		this->_Myres = _Newres;
; 2213 : 		_Eos(_Oldlen);
; 2214 : 		}
; 2215 : 
; 2216 : 	void _Eos(size_type _Newsize)
; 2217 : 		{	// set new length and null terminator
; 2218 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  003dd	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 735  : 		assign(_Right, 0, npos);

  003e4	50		 push	 eax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd

; 347  : 		_Left = _Right;

  003e5	66 89 01	 mov	 WORD PTR [ecx], ax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 735  : 		assign(_Right, 0, npos);

  003e8	8d 44 24 50	 lea	 eax, DWORD PTR $T6[esp+136]
  003ec	50		 push	 eax
  003ed	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign

; 2256 : 		else if (this->_BUF_SIZE <= this->_Myres)

  003f2	83 7c 24 5c 08	 cmp	 DWORD PTR $T6[esp+148], 8
; File c:\users\glenn\documents\github\wind\project\wind\wind\window.cpp

; 21   : {

  003f7	c6 46 30 01	 mov	 BYTE PTR [esi+48], 1
  003fb	c7 46 34 58 02
	00 00		 mov	 DWORD PTR [esi+52], 600	; 00000258H
  00402	c7 46 38 58 02
	00 00		 mov	 DWORD PTR [esi+56], 600	; 00000258H
  00409	c7 46 3c 03 00
	00 00		 mov	 DWORD PTR [esi+60], 3
  00410	c7 46 40 04 00
	00 00		 mov	 DWORD PTR [esi+64], 4
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 2256 : 		else if (this->_BUF_SIZE <= this->_Myres)

  00417	72 10		 jb	 SHORT $LN45@WinMain
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 586  : 		::operator delete(_Ptr);

  00419	ff 74 24 48	 push	 DWORD PTR $T6[esp+128]
  0041d	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00422	83 c4 04	 add	 esp, 4
; File c:\users\glenn\documents\github\wind\project\wind\wind\main.cpp

; 208  : 	GLWindow::instance = new GLWindow(L"Wind", 600, 600, _hInstance, 3, 4);

  00425	eb 02		 jmp	 SHORT $LN45@WinMain
$LN44@WinMain:
  00427	33 f6		 xor	 esi, esi
$LN45@WinMain:
  00429	89 35 00 00 00
	00		 mov	 DWORD PTR ?instance@GLWindow@@2PAV1@A, esi ; GLWindow::instance

; 209  : 	GLWindow::instance->initWindow();

  0042f	e8 00 00 00 00	 call	 ?initWindow@GLWindow@@QAEXXZ ; GLWindow::initWindow

; 210  : 
; 211  : 	renderThread.start();

  00434	b9 00 00 00 00	 mov	 ecx, OFFSET ?renderThread@@3VRenderThread@@A ; renderThread
  00439	e8 00 00 00 00	 call	 ?start@Thread@@UAE_NXZ	; Thread::start
  0043e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?instance@GLWindow@@2PAV1@A ; GLWindow::instance
$LL23@WinMain:

; 212  : 	while(GLWindow::instance == nullptr || !GLWindow::instance->isOK())

  00443	85 c0		 test	 eax, eax
  00445	74 fc		 je	 SHORT $LL23@WinMain
  00447	80 38 00	 cmp	 BYTE PTR [eax], 0
  0044a	74 f7		 je	 SHORT $LL23@WinMain

; 213  : 	{
; 214  : 
; 215  : 	}
; 216  : 
; 217  : 	for(int i = 0; i < LOAD_THREAD_AMOUNT; i++)
; 218  : 	{
; 219  : 		chunkLoadThreads[i].start();

  0044c	b9 00 00 00 00	 mov	 ecx, OFFSET ?chunkLoadThreads@@3PAVChunkLoadThread@@A ; chunkLoadThreads
  00451	e8 00 00 00 00	 call	 ?start@Thread@@UAE_NXZ	; Thread::start

; 222  : 	for(int i = 0; i < DRAW_THREAD_AMOUNT; i++)

  00456	be 0c 00 00 00	 mov	 esi, OFFSET ?chunkDrawThreads@@3PAVChunkDrawThread@@A+12
  0045b	eb 03 8d 49 00	 npad	 5
$LL17@WinMain:
; File c:\users\glenn\documents\github\wind\project\wind\wind\threads.cpp

; 37   : 	Thread* theThread = this;

  00460	8d 46 f4	 lea	 eax, DWORD PTR [esi-12]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 182  : 		{	// construct from target

  00463	8d 4c 24 48	 lea	 ecx, DWORD PTR __Launcher$5[esp+128]
; File c:\users\glenn\documents\github\wind\project\wind\wind\threads.cpp

; 35   : 	started = true;

  00467	66 c7 06 01 00	 mov	 WORD PTR [esi], 1

; 37   : 	Thread* theThread = this;

  0046c	89 44 24 2c	 mov	 DWORD PTR _theThread$1[esp+128], eax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 182  : 		{	// construct from target

  00470	e8 00 00 00 00	 call	 ??0_Pad@std@@QAE@XZ	; std::_Pad::_Pad
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xrefwrap

; 346  : 		{	// construct

  00475	8d 44 24 2c	 lea	 eax, DWORD PTR _theThread$1[esp+128]
  00479	89 44 24 5c	 mov	 DWORD PTR __Launcher$5[esp+148], eax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 206  : 	_Launcher._Launch(_Thr);

  0047d	8d 44 24 30	 lea	 eax, DWORD PTR $T2[esp+128]
  00481	50		 push	 eax
  00482	8d 4c 24 4c	 lea	 ecx, DWORD PTR __Launcher$5[esp+132]

; 182  : 		{	// construct from target

  00486	c7 44 24 4c 00
	00 00 00	 mov	 DWORD PTR __Launcher$5[esp+132], OFFSET ??_7?$_LaunchPad@V?$_Bind@$00XQ6AXPAVThread@@@ZV?$reference_wrapper@PAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@std@@@std@@6B@
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\functional

; 1152 : _VARIADIC_EXPAND_0X(_CLASS_BIND, , , , )

  0048e	c7 44 24 5c 00
	00 00 00	 mov	 DWORD PTR __Launcher$5[esp+148], OFFSET ?loop@Thread@@KAXPAV1@@Z ; Thread::loop
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 206  : 	_Launcher._Launch(_Thr);

  00496	e8 00 00 00 00	 call	 ?_Launch@_Pad@std@@QAEXPAU_Thrd_imp_t@@@Z ; std::_Pad::_Launch
  0049b	8d 4c 24 48	 lea	 ecx, DWORD PTR __Launcher$5[esp+128]
  0049f	e8 00 00 00 00	 call	 ??1_Pad@std@@QAE@XZ	; std::_Pad::~_Pad
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thread

; 83   : 		return (!_Thr_is_null(_Thr));

  004a4	83 7e fc 00	 cmp	 DWORD PTR [esi-4], 0

; 84   : 		}
; 85   : 
; 86   : 	void join();
; 87   : 
; 88   : 	void detach()
; 89   : 		{	// detach thread
; 90   : 		if (!joinable())
; 91   : 			_Throw_Cpp_error(_INVALID_ARGUMENT);
; 92   : 		_Thrd_detachX(_Thr);
; 93   : 		_Thr_set_null(_Thr);
; 94   : 		}
; 95   : 
; 96   : 	id get_id() const _NOEXCEPT;
; 97   : 
; 98   : 	static unsigned int hardware_concurrency() _NOEXCEPT
; 99   : 		{	// return number of hardware thread contexts
; 100  : 		return (::Concurrency::details::_GetConcurrency());
; 101  : 		}
; 102  : 
; 103  : 	native_handle_type native_handle()
; 104  : 		{	// return Win32 HANDLE as void *
; 105  : 		return (_Thr._Hnd);
; 106  : 		}
; 107  : 
; 108  : private:
; 109  : 	thread& _Move_thread(thread& _Other)
; 110  : 		{	// move from _Other
; 111  : 		if (joinable())

  004a8	0f 85 79 03 00
	00		 jne	 $LN729@WinMain

; 113  : 		_Thr = _Other._Thr;

  004ae	8b 44 24 30	 mov	 eax, DWORD PTR $T2[esp+128]
  004b2	89 46 f8	 mov	 DWORD PTR [esi-8], eax
  004b5	8b 44 24 34	 mov	 eax, DWORD PTR $T2[esp+132]
  004b9	89 46 fc	 mov	 DWORD PTR [esi-4], eax
; File c:\users\glenn\documents\github\wind\project\wind\wind\main.cpp

; 222  : 	for(int i = 0; i < DRAW_THREAD_AMOUNT; i++)

  004bc	81 c6 60 04 00
	00		 add	 esi, 1120		; 00000460H
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thread

; 114  : 		_Thr_set_null(_Other._Thr);

  004c2	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR $T2[esp+132], 0
; File c:\users\glenn\documents\github\wind\project\wind\wind\main.cpp

; 222  : 	for(int i = 0; i < DRAW_THREAD_AMOUNT; i++)

  004ca	81 fe 8c 11 00
	00		 cmp	 esi, OFFSET ?chunkDrawThreads@@3PAVChunkDrawThread@@A+4492
  004d0	7c 8e		 jl	 SHORT $LL17@WinMain

; 223  : 	{
; 224  : 		chunkDrawThreads[i].start();
; 225  : 	}
; 226  : 
; 227  : 	GameStates::init();

  004d2	e8 00 00 00 00	 call	 ?init@GameStates@@YAXXZ	; GameStates::init
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\chrono

; 706  : 		return (time_point(duration(_Xtime_get_ticks())));

  004d7	e8 00 00 00 00	 call	 __Xtime_get_ticks
; File c:\users\glenn\documents\github\wind\project\wind\wind\main.cpp

; 233  : 	while(!GlobalThread::stop)

  004dc	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR ?stop@GlobalThread@@3_NA, 0 ; GlobalThread::stop
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\chrono

; 259  : 		{	// construct from a duration

  004e3	89 44 24 2c	 mov	 DWORD PTR _startTime$1$[esp+128], eax
  004e7	89 54 24 28	 mov	 DWORD PTR _startTime$2$[esp+128], edx
; File c:\users\glenn\documents\github\wind\project\wind\wind\main.cpp

; 233  : 	while(!GlobalThread::stop)

  004eb	0f 85 ae 00 00
	00		 jne	 $LN749@WinMain
  004f1	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__PeekMessageW@20
  004f7	8b 74 24 3c	 mov	 esi, DWORD PTR _lastTick$[esp+132]
  004fb	8b 7c 24 38	 mov	 edi, DWORD PTR _lastTick$[esp+128]
  004ff	90		 npad	 1
$LL14@WinMain:

; 234  : 	{
; 235  : 		if(PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))

  00500	6a 01		 push	 1
  00502	6a 00		 push	 0
  00504	6a 00		 push	 0
  00506	6a 00		 push	 0
  00508	8d 44 24 74	 lea	 eax, DWORD PTR _msg$[esp+144]
  0050c	50		 push	 eax
  0050d	ff d3		 call	 ebx
  0050f	85 c0		 test	 eax, eax
  00511	74 1f		 je	 SHORT $LN12@WinMain

; 236  : 		{
; 237  : 			if(msg.message == WM_QUIT)

  00513	83 7c 24 68 12	 cmp	 DWORD PTR _msg$[esp+132], 18 ; 00000012H
  00518	74 7e		 je	 SHORT $LN752@WinMain

; 238  : 			{
; 239  : 				GlobalThread::stop = true;
; 240  : 			} else
; 241  : 			{
; 242  : 				TranslateMessage(&msg);

  0051a	8d 44 24 64	 lea	 eax, DWORD PTR _msg$[esp+128]
  0051e	50		 push	 eax
  0051f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__TranslateMessage@4

; 243  : 				DispatchMessage(&msg);

  00525	8d 44 24 64	 lea	 eax, DWORD PTR _msg$[esp+128]
  00529	50		 push	 eax
  0052a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DispatchMessageW@4

; 244  : 			}
; 245  : 		} else

  00530	eb 57		 jmp	 SHORT $LN7@WinMain
$LN12@WinMain:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\chrono

; 706  : 		return (time_point(duration(_Xtime_get_ticks())));

  00532	e8 00 00 00 00	 call	 __Xtime_get_ticks

; 105  : 		{	// construct from representation

  00537	2b 44 24 2c	 sub	 eax, DWORD PTR _startTime$1$[esp+128]

; 260  : 		}
; 261  : 
; 262  : 	template<class _Duration2>
; 263  : 		time_point(const time_point<_Clock, _Duration2>& _Tp,
; 264  : 			typename enable_if<is_convertible<_Duration2, _Duration>::value,
; 265  : 			void>::type ** = 0)
; 266  : 		: _MyDur(_Tp.time_since_epoch())
; 267  : 		{	// construct from another duration
; 268  : 		}
; 269  : 
; 270  : 	_Duration time_since_epoch() const
; 271  : 		{	// get duration from epoch
; 272  : 		return (_MyDur);
; 273  : 		}
; 274  : 
; 275  : 	time_point& operator+=(const _Duration& _Dur)
; 276  : 		{	// increment by duration
; 277  : 		_MyDur += _Dur;
; 278  : 		return (*this);
; 279  : 		}
; 280  : 
; 281  : 	time_point& operator-=(const _Duration& _Dur)
; 282  : 		{	// decrement by duration
; 283  : 		_MyDur -= _Dur;
; 284  : 		return (*this);
; 285  : 		}
; 286  : 
; 287  : 	static time_point (min)()
; 288  : 		{	// get minimum time point
; 289  : 		return (time_point((_Duration::min)()));
; 290  : 		}
; 291  : 	static time_point (max)()
; 292  : 		{	// get maximum time point
; 293  : 		return (time_point((_Duration::max)()));
; 294  : 		}
; 295  : 
; 296  : private:
; 297  : 	_Duration _MyDur;	// duration since the epoch
; 298  : 	};
; 299  : }	// namespace chrono
; 300  : 
; 301  : 	// CLASS TEMPLATE _Lcm (LEAST COMMON MULTIPLE)
; 302  : template<intmax_t _Ax,
; 303  : 	intmax_t _Bx>
; 304  : 	struct _Lcm
; 305  : 	{   /* compute least common multiple of _Ax and _Bx */
; 306  : 	static const intmax_t _Gx = _Gcd<_Ax, _Bx>::value;
; 307  : 	static const intmax_t value = (_Ax / _Gx) * _Bx;
; 308  : 	};
; 309  : 
; 310  : 	// CLASS TEMPLATE common_type SPECIALIZATIONS
; 311  : template<class _Rep1,
; 312  : 	class _Period1,
; 313  : 	class _Rep2,
; 314  : 	class _Period2>
; 315  : 	struct common_type<
; 316  : 		chrono::duration<_Rep1, _Period1>,
; 317  : 		chrono::duration<_Rep2, _Period2> >
; 318  : 	{	// common type of two durations
; 319  : 	typedef chrono::duration<typename common_type<_Rep1, _Rep2>::type,
; 320  : 		ratio<_Gcd<_Period1::num, _Period2::num>::value,
; 321  : 			_Lcm<_Period1::den, _Period2::den>::value> > type;
; 322  : 	};
; 323  : 
; 324  : template<class _Clock,
; 325  : 	class _Duration1,
; 326  : 	class _Duration2>
; 327  : 	struct common_type<
; 328  : 		chrono::time_point<_Clock, _Duration1>,
; 329  : 		chrono::time_point<_Clock, _Duration2> >
; 330  : 	{	// common type of two time points
; 331  : 	typedef chrono::time_point<
; 332  : 		_Clock, typename common_type<_Duration1, _Duration2>::type> type;
; 333  : 	};
; 334  : 
; 335  : namespace chrono {
; 336  : 	// duration ARITHMETIC
; 337  : template<class _Rep1,
; 338  : 	class _Period1,
; 339  : 	class _Rep2,
; 340  : 	class _Period2> inline
; 341  : 	typename common_type<
; 342  : 		duration<_Rep1, _Period1>,
; 343  : 		duration<_Rep2, _Period2> >::type
; 344  : 		operator+(
; 345  : 			const duration<_Rep1, _Period1>& _Left,
; 346  : 			const duration<_Rep2, _Period2>& _Right)
; 347  : 	{	// add two durations
; 348  : 	typedef typename common_type<
; 349  : 		duration<_Rep1, _Period1>,
; 350  : 		duration<_Rep2, _Period2> >::type _CD;
; 351  : 		return (_CD(_Left) += _Right);
; 352  : 		}
; 353  : 
; 354  : template<class _Rep1,
; 355  : 	class _Period1,
; 356  : 	class _Rep2,
; 357  : 	class _Period2> inline
; 358  : 	typename common_type<
; 359  : 		duration<_Rep1, _Period1>,
; 360  : 		duration<_Rep2, _Period2> >::type
; 361  : 		operator-(
; 362  : 			const duration<_Rep1, _Period1>& _Left,
; 363  : 			const duration<_Rep2, _Period2>& _Right)
; 364  : 	{	// subtract two durations
; 365  : 	typedef typename common_type<
; 366  : 		duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _CD;
; 367  : 	return (_CD(_Left) -= _Right);
; 368  : 	}
; 369  : 
; 370  : template<class _Rep1,
; 371  : 	class _Period1,
; 372  : 	class _Rep2> inline
; 373  : 	typename enable_if<is_convertible<_Rep2,
; 374  : 		typename common_type<_Rep1, _Rep2>::type>::value,
; 375  : 		duration<typename common_type<_Rep1, _Rep2>::type, _Period1> >::type
; 376  : 		operator*(
; 377  : 			const duration<_Rep1, _Period1>& _Left,
; 378  : 			const _Rep2& _Right)
; 379  : 	{	// multiply duration by rep
; 380  : 	typedef typename common_type<_Rep1, _Rep2>::type _CR;
; 381  : 	return (duration<_CR, _Period1>(_Left) *= _Right);
; 382  : 	}
; 383  : 
; 384  : template<class _Rep1,
; 385  : 	class _Rep2,
; 386  : 	class _Period2> inline
; 387  : 	typename enable_if<is_convertible<_Rep1,
; 388  : 		typename common_type<_Rep1, _Rep2>::type>::value,
; 389  : 		duration<typename common_type<_Rep1, _Rep2>::type, _Period2> >::type
; 390  : 		operator*(
; 391  : 			const _Rep1& _Left,
; 392  : 			const duration<_Rep2, _Period2>& _Right)
; 393  : 	{	// multiply rep by duration
; 394  : 	return (_Right * _Left);
; 395  : 	}
; 396  : 
; 397  : template<class _Rep1,
; 398  : 	class _Period1,
; 399  : 	class _Rep2> inline
; 400  : 	typename enable_if<is_convertible<_Rep2,
; 401  : 		typename common_type<_Rep1, _Rep2>::type>::value
; 402  : 		&& !_Is_duration<_Rep2>::value,
; 403  : 		duration<typename common_type<_Rep1, _Rep2>::type, _Period1> >::type
; 404  : 		operator/(
; 405  : 			const duration<_Rep1, _Period1>& _Left,
; 406  : 			const _Rep2& _Right)
; 407  : 	{	// divide duration by rep
; 408  : 	typedef typename common_type<_Rep1, _Rep2>::type _CR;
; 409  : 	return (duration<_CR, _Period1>(_Left) /= _Right);
; 410  : 	}
; 411  : 
; 412  : template<class _Rep1,
; 413  : 	class _Period1,
; 414  : 	class _Rep2,
; 415  : 	class _Period2> inline
; 416  : 	typename common_type<_Rep1, _Rep2>::type
; 417  : 		operator/(
; 418  : 			const duration<_Rep1, _Period1>& _Left,
; 419  : 			const duration<_Rep2, _Period2>& _Right)
; 420  : 	{	// divide duration by duration
; 421  : 	typedef typename common_type<
; 422  : 		duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _CD;
; 423  : 	return (_CD(_Left).count() / _CD(_Right).count());
; 424  : 	}
; 425  : 
; 426  : template<class _Rep1,
; 427  : 	class _Period1,
; 428  : 	class _Rep2> inline
; 429  : 	typename enable_if<is_convertible<_Rep2,
; 430  : 		typename common_type<_Rep1, _Rep2>::type>::value
; 431  : 		&& !_Is_duration<_Rep2>::value,
; 432  : 		duration<typename common_type<_Rep1, _Rep2>::type, _Period1> >::type
; 433  : 		operator%(
; 434  : 			const duration<_Rep1, _Period1>& _Left,
; 435  : 			const _Rep2& _Right)
; 436  : 	{	// divide duration by rep
; 437  : 	typedef typename common_type<_Rep1, _Rep2>::type _CR;
; 438  : 	return (duration<_CR, _Period1>(_Left) %= _Right);
; 439  : 	}
; 440  : 
; 441  : template<class _Rep1,
; 442  : 	class _Period1,
; 443  : 	class _Rep2,
; 444  : 	class _Period2> inline
; 445  : 	typename common_type<_Rep1, _Rep2>::type
; 446  : 		operator%(
; 447  : 			const duration<_Rep1, _Period1>& _Left,
; 448  : 			const duration<_Rep2, _Period2>& _Right)
; 449  : 	{	// divide duration by duration
; 450  : 	typedef typename common_type<
; 451  : 		duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _CD;
; 452  : 	return (_CD(_Left).count() % _CD(_Right).count());
; 453  : 	}
; 454  : 
; 455  : 	// duration COMPARISONS
; 456  : template<class _Rep1,
; 457  : 	class _Period1,
; 458  : 	class _Rep2,
; 459  : 	class _Period2> inline
; 460  : 	bool operator==(
; 461  : 		const duration<_Rep1, _Period1>& _Left,
; 462  : 		const duration<_Rep2, _Period2>& _Right)
; 463  : 	{	// test if duration == duration
; 464  : 	typedef typename common_type<
; 465  : 		duration<_Rep1, _Period1>,
; 466  : 		duration<_Rep2, _Period2> >::type _CT;
; 467  : 	return (_CT(_Left).count() == _CT(_Right).count());
; 468  : 	}
; 469  : 
; 470  : template<class _Rep1,
; 471  : 	class _Period1,
; 472  : 	class _Rep2,
; 473  : 	class _Period2> inline
; 474  : 	bool operator!=(
; 475  : 		const duration<_Rep1, _Period1>& _Left,
; 476  : 		const duration<_Rep2, _Period2>& _Right)
; 477  : 	{	// test if duration != duration
; 478  : 	return (!(_Left == _Right));
; 479  : 	}
; 480  : 
; 481  : template<class _Rep1,
; 482  : 	class _Period1,
; 483  : 	class _Rep2,
; 484  : 	class _Period2> inline
; 485  : 	bool operator<(
; 486  : 		const duration<_Rep1, _Period1>& _Left,
; 487  : 		const duration<_Rep2, _Period2>& _Right)
; 488  : 	{	// test if duration < duration
; 489  : 	typedef typename common_type<
; 490  : 		duration<_Rep1, _Period1>,
; 491  : 		duration<_Rep2, _Period2> >::type _CT;
; 492  : 	return (_CT(_Left).count() < _CT(_Right).count());
; 493  : 	}
; 494  : 
; 495  : template<class _Rep1,
; 496  : 	class _Period1,
; 497  : 	class _Rep2,
; 498  : 	class _Period2> inline
; 499  : 	bool operator<=(
; 500  : 		const duration<_Rep1, _Period1>& _Left,
; 501  : 		const duration<_Rep2, _Period2>& _Right)
; 502  : 	{	// test if duration <= duration
; 503  : 	return (!(_Right < _Left));
; 504  : 	}
; 505  : 
; 506  : template<class _Rep1,
; 507  : 	class _Period1,
; 508  : 	class _Rep2,
; 509  : 	class _Period2> inline
; 510  : 	bool operator>(
; 511  : 		const duration<_Rep1, _Period1>& _Left,
; 512  : 		const duration<_Rep2, _Period2>& _Right)
; 513  : 	{	// test if duration > duration
; 514  : 	return (_Right < _Left);
; 515  : 	}
; 516  : 
; 517  : template<class _Rep1,
; 518  : 	class _Period1,
; 519  : 	class _Rep2,
; 520  : 	class _Period2> inline
; 521  : 	bool operator>=(
; 522  : 		const duration<_Rep1, _Period1>& _Left,
; 523  : 		const duration<_Rep2, _Period2>& _Right)
; 524  : 	{	// test if duration >= duration
; 525  : 	return (!(_Left < _Right));
; 526  : 	}
; 527  : 
; 528  : 	// duration_cast
; 529  : template<class _To,
; 530  : 	class _Rep,
; 531  : 	class _Period> inline
; 532  : 	typename enable_if<_Is_duration<_To>::value,
; 533  : 		_To>::type
; 534  : 		duration_cast(const duration<_Rep, _Period>& _Dur)
; 535  : 	{	// convert duration to another duration
; 536  : 	typedef typename ratio_divide<_Period, typename _To::period>::type _CF;
; 537  : 	typedef typename common_type<
; 538  : 		typename common_type<typename _To::rep, _Rep>::type,
; 539  : 			intmax_t>::type _CR;
; 540  : 	if (_CF::num == 1 && _CF::den == 1)
; 541  : 		return (_To(static_cast<typename _To::rep>(_Dur.count())));
; 542  : 	else if (_CF::num != 1 && _CF::den == 1)
; 543  : 		return (_To(static_cast<typename _To::rep>(

  0053b	6a 00		 push	 0

; 105  : 		{	// construct from representation

  0053d	1b 54 24 2c	 sbb	 edx, DWORD PTR _startTime$2$[esp+132]

; 260  : 		}
; 261  : 
; 262  : 	template<class _Duration2>
; 263  : 		time_point(const time_point<_Clock, _Duration2>& _Tp,
; 264  : 			typename enable_if<is_convertible<_Duration2, _Duration>::value,
; 265  : 			void>::type ** = 0)
; 266  : 		: _MyDur(_Tp.time_since_epoch())
; 267  : 		{	// construct from another duration
; 268  : 		}
; 269  : 
; 270  : 	_Duration time_since_epoch() const
; 271  : 		{	// get duration from epoch
; 272  : 		return (_MyDur);
; 273  : 		}
; 274  : 
; 275  : 	time_point& operator+=(const _Duration& _Dur)
; 276  : 		{	// increment by duration
; 277  : 		_MyDur += _Dur;
; 278  : 		return (*this);
; 279  : 		}
; 280  : 
; 281  : 	time_point& operator-=(const _Duration& _Dur)
; 282  : 		{	// decrement by duration
; 283  : 		_MyDur -= _Dur;
; 284  : 		return (*this);
; 285  : 		}
; 286  : 
; 287  : 	static time_point (min)()
; 288  : 		{	// get minimum time point
; 289  : 		return (time_point((_Duration::min)()));
; 290  : 		}
; 291  : 	static time_point (max)()
; 292  : 		{	// get maximum time point
; 293  : 		return (time_point((_Duration::max)()));
; 294  : 		}
; 295  : 
; 296  : private:
; 297  : 	_Duration _MyDur;	// duration since the epoch
; 298  : 	};
; 299  : }	// namespace chrono
; 300  : 
; 301  : 	// CLASS TEMPLATE _Lcm (LEAST COMMON MULTIPLE)
; 302  : template<intmax_t _Ax,
; 303  : 	intmax_t _Bx>
; 304  : 	struct _Lcm
; 305  : 	{   /* compute least common multiple of _Ax and _Bx */
; 306  : 	static const intmax_t _Gx = _Gcd<_Ax, _Bx>::value;
; 307  : 	static const intmax_t value = (_Ax / _Gx) * _Bx;
; 308  : 	};
; 309  : 
; 310  : 	// CLASS TEMPLATE common_type SPECIALIZATIONS
; 311  : template<class _Rep1,
; 312  : 	class _Period1,
; 313  : 	class _Rep2,
; 314  : 	class _Period2>
; 315  : 	struct common_type<
; 316  : 		chrono::duration<_Rep1, _Period1>,
; 317  : 		chrono::duration<_Rep2, _Period2> >
; 318  : 	{	// common type of two durations
; 319  : 	typedef chrono::duration<typename common_type<_Rep1, _Rep2>::type,
; 320  : 		ratio<_Gcd<_Period1::num, _Period2::num>::value,
; 321  : 			_Lcm<_Period1::den, _Period2::den>::value> > type;
; 322  : 	};
; 323  : 
; 324  : template<class _Clock,
; 325  : 	class _Duration1,
; 326  : 	class _Duration2>
; 327  : 	struct common_type<
; 328  : 		chrono::time_point<_Clock, _Duration1>,
; 329  : 		chrono::time_point<_Clock, _Duration2> >
; 330  : 	{	// common type of two time points
; 331  : 	typedef chrono::time_point<
; 332  : 		_Clock, typename common_type<_Duration1, _Duration2>::type> type;
; 333  : 	};
; 334  : 
; 335  : namespace chrono {
; 336  : 	// duration ARITHMETIC
; 337  : template<class _Rep1,
; 338  : 	class _Period1,
; 339  : 	class _Rep2,
; 340  : 	class _Period2> inline
; 341  : 	typename common_type<
; 342  : 		duration<_Rep1, _Period1>,
; 343  : 		duration<_Rep2, _Period2> >::type
; 344  : 		operator+(
; 345  : 			const duration<_Rep1, _Period1>& _Left,
; 346  : 			const duration<_Rep2, _Period2>& _Right)
; 347  : 	{	// add two durations
; 348  : 	typedef typename common_type<
; 349  : 		duration<_Rep1, _Period1>,
; 350  : 		duration<_Rep2, _Period2> >::type _CD;
; 351  : 		return (_CD(_Left) += _Right);
; 352  : 		}
; 353  : 
; 354  : template<class _Rep1,
; 355  : 	class _Period1,
; 356  : 	class _Rep2,
; 357  : 	class _Period2> inline
; 358  : 	typename common_type<
; 359  : 		duration<_Rep1, _Period1>,
; 360  : 		duration<_Rep2, _Period2> >::type
; 361  : 		operator-(
; 362  : 			const duration<_Rep1, _Period1>& _Left,
; 363  : 			const duration<_Rep2, _Period2>& _Right)
; 364  : 	{	// subtract two durations
; 365  : 	typedef typename common_type<
; 366  : 		duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _CD;
; 367  : 	return (_CD(_Left) -= _Right);
; 368  : 	}
; 369  : 
; 370  : template<class _Rep1,
; 371  : 	class _Period1,
; 372  : 	class _Rep2> inline
; 373  : 	typename enable_if<is_convertible<_Rep2,
; 374  : 		typename common_type<_Rep1, _Rep2>::type>::value,
; 375  : 		duration<typename common_type<_Rep1, _Rep2>::type, _Period1> >::type
; 376  : 		operator*(
; 377  : 			const duration<_Rep1, _Period1>& _Left,
; 378  : 			const _Rep2& _Right)
; 379  : 	{	// multiply duration by rep
; 380  : 	typedef typename common_type<_Rep1, _Rep2>::type _CR;
; 381  : 	return (duration<_CR, _Period1>(_Left) *= _Right);
; 382  : 	}
; 383  : 
; 384  : template<class _Rep1,
; 385  : 	class _Rep2,
; 386  : 	class _Period2> inline
; 387  : 	typename enable_if<is_convertible<_Rep1,
; 388  : 		typename common_type<_Rep1, _Rep2>::type>::value,
; 389  : 		duration<typename common_type<_Rep1, _Rep2>::type, _Period2> >::type
; 390  : 		operator*(
; 391  : 			const _Rep1& _Left,
; 392  : 			const duration<_Rep2, _Period2>& _Right)
; 393  : 	{	// multiply rep by duration
; 394  : 	return (_Right * _Left);
; 395  : 	}
; 396  : 
; 397  : template<class _Rep1,
; 398  : 	class _Period1,
; 399  : 	class _Rep2> inline
; 400  : 	typename enable_if<is_convertible<_Rep2,
; 401  : 		typename common_type<_Rep1, _Rep2>::type>::value
; 402  : 		&& !_Is_duration<_Rep2>::value,
; 403  : 		duration<typename common_type<_Rep1, _Rep2>::type, _Period1> >::type
; 404  : 		operator/(
; 405  : 			const duration<_Rep1, _Period1>& _Left,
; 406  : 			const _Rep2& _Right)
; 407  : 	{	// divide duration by rep
; 408  : 	typedef typename common_type<_Rep1, _Rep2>::type _CR;
; 409  : 	return (duration<_CR, _Period1>(_Left) /= _Right);
; 410  : 	}
; 411  : 
; 412  : template<class _Rep1,
; 413  : 	class _Period1,
; 414  : 	class _Rep2,
; 415  : 	class _Period2> inline
; 416  : 	typename common_type<_Rep1, _Rep2>::type
; 417  : 		operator/(
; 418  : 			const duration<_Rep1, _Period1>& _Left,
; 419  : 			const duration<_Rep2, _Period2>& _Right)
; 420  : 	{	// divide duration by duration
; 421  : 	typedef typename common_type<
; 422  : 		duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _CD;
; 423  : 	return (_CD(_Left).count() / _CD(_Right).count());
; 424  : 	}
; 425  : 
; 426  : template<class _Rep1,
; 427  : 	class _Period1,
; 428  : 	class _Rep2> inline
; 429  : 	typename enable_if<is_convertible<_Rep2,
; 430  : 		typename common_type<_Rep1, _Rep2>::type>::value
; 431  : 		&& !_Is_duration<_Rep2>::value,
; 432  : 		duration<typename common_type<_Rep1, _Rep2>::type, _Period1> >::type
; 433  : 		operator%(
; 434  : 			const duration<_Rep1, _Period1>& _Left,
; 435  : 			const _Rep2& _Right)
; 436  : 	{	// divide duration by rep
; 437  : 	typedef typename common_type<_Rep1, _Rep2>::type _CR;
; 438  : 	return (duration<_CR, _Period1>(_Left) %= _Right);
; 439  : 	}
; 440  : 
; 441  : template<class _Rep1,
; 442  : 	class _Period1,
; 443  : 	class _Rep2,
; 444  : 	class _Period2> inline
; 445  : 	typename common_type<_Rep1, _Rep2>::type
; 446  : 		operator%(
; 447  : 			const duration<_Rep1, _Period1>& _Left,
; 448  : 			const duration<_Rep2, _Period2>& _Right)
; 449  : 	{	// divide duration by duration
; 450  : 	typedef typename common_type<
; 451  : 		duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _CD;
; 452  : 	return (_CD(_Left).count() % _CD(_Right).count());
; 453  : 	}
; 454  : 
; 455  : 	// duration COMPARISONS
; 456  : template<class _Rep1,
; 457  : 	class _Period1,
; 458  : 	class _Rep2,
; 459  : 	class _Period2> inline
; 460  : 	bool operator==(
; 461  : 		const duration<_Rep1, _Period1>& _Left,
; 462  : 		const duration<_Rep2, _Period2>& _Right)
; 463  : 	{	// test if duration == duration
; 464  : 	typedef typename common_type<
; 465  : 		duration<_Rep1, _Period1>,
; 466  : 		duration<_Rep2, _Period2> >::type _CT;
; 467  : 	return (_CT(_Left).count() == _CT(_Right).count());
; 468  : 	}
; 469  : 
; 470  : template<class _Rep1,
; 471  : 	class _Period1,
; 472  : 	class _Rep2,
; 473  : 	class _Period2> inline
; 474  : 	bool operator!=(
; 475  : 		const duration<_Rep1, _Period1>& _Left,
; 476  : 		const duration<_Rep2, _Period2>& _Right)
; 477  : 	{	// test if duration != duration
; 478  : 	return (!(_Left == _Right));
; 479  : 	}
; 480  : 
; 481  : template<class _Rep1,
; 482  : 	class _Period1,
; 483  : 	class _Rep2,
; 484  : 	class _Period2> inline
; 485  : 	bool operator<(
; 486  : 		const duration<_Rep1, _Period1>& _Left,
; 487  : 		const duration<_Rep2, _Period2>& _Right)
; 488  : 	{	// test if duration < duration
; 489  : 	typedef typename common_type<
; 490  : 		duration<_Rep1, _Period1>,
; 491  : 		duration<_Rep2, _Period2> >::type _CT;
; 492  : 	return (_CT(_Left).count() < _CT(_Right).count());
; 493  : 	}
; 494  : 
; 495  : template<class _Rep1,
; 496  : 	class _Period1,
; 497  : 	class _Rep2,
; 498  : 	class _Period2> inline
; 499  : 	bool operator<=(
; 500  : 		const duration<_Rep1, _Period1>& _Left,
; 501  : 		const duration<_Rep2, _Period2>& _Right)
; 502  : 	{	// test if duration <= duration
; 503  : 	return (!(_Right < _Left));
; 504  : 	}
; 505  : 
; 506  : template<class _Rep1,
; 507  : 	class _Period1,
; 508  : 	class _Rep2,
; 509  : 	class _Period2> inline
; 510  : 	bool operator>(
; 511  : 		const duration<_Rep1, _Period1>& _Left,
; 512  : 		const duration<_Rep2, _Period2>& _Right)
; 513  : 	{	// test if duration > duration
; 514  : 	return (_Right < _Left);
; 515  : 	}
; 516  : 
; 517  : template<class _Rep1,
; 518  : 	class _Period1,
; 519  : 	class _Rep2,
; 520  : 	class _Period2> inline
; 521  : 	bool operator>=(
; 522  : 		const duration<_Rep1, _Period1>& _Left,
; 523  : 		const duration<_Rep2, _Period2>& _Right)
; 524  : 	{	// test if duration >= duration
; 525  : 	return (!(_Left < _Right));
; 526  : 	}
; 527  : 
; 528  : 	// duration_cast
; 529  : template<class _To,
; 530  : 	class _Rep,
; 531  : 	class _Period> inline
; 532  : 	typename enable_if<_Is_duration<_To>::value,
; 533  : 		_To>::type
; 534  : 		duration_cast(const duration<_Rep, _Period>& _Dur)
; 535  : 	{	// convert duration to another duration
; 536  : 	typedef typename ratio_divide<_Period, typename _To::period>::type _CF;
; 537  : 	typedef typename common_type<
; 538  : 		typename common_type<typename _To::rep, _Rep>::type,
; 539  : 			intmax_t>::type _CR;
; 540  : 	if (_CF::num == 1 && _CF::den == 1)
; 541  : 		return (_To(static_cast<typename _To::rep>(_Dur.count())));
; 542  : 	else if (_CF::num != 1 && _CF::den == 1)
; 543  : 		return (_To(static_cast<typename _To::rep>(

  00541	6a 64		 push	 100			; 00000064H
  00543	52		 push	 edx
  00544	50		 push	 eax
  00545	e8 00 00 00 00	 call	 __allmul
; File c:\users\glenn\documents\github\wind\project\wind\wind\main.cpp

; 250  : 			long long tick = difference / tickTime;

  0054a	6a 00		 push	 0
  0054c	68 00 2d 31 01	 push	 20000000		; 01312d00H
  00551	52		 push	 edx
  00552	50		 push	 eax
  00553	e8 00 00 00 00	 call	 __alldiv

; 251  : 			long long ticksToProcess = tick - lastTick;

  00558	2b c7		 sub	 eax, edi
  0055a	1b d6		 sbb	 edx, esi

; 252  : 
; 253  : 			if(ticksToProcess > 0)

  0055c	89 54 24 44	 mov	 DWORD PTR tv2831[esp+132], edx
  00560	78 27		 js	 SHORT $LN7@WinMain
  00562	7f 04		 jg	 SHORT $LN753@WinMain
  00564	85 c0		 test	 eax, eax
  00566	74 21		 je	 SHORT $LN7@WinMain
$LN753@WinMain:

; 254  : 			{
; 255  : 				lastTick++;
; 256  : 				RenderThread::skipRender = false;
; 257  : 				if(GLWindow::instance->active && !mainLoop())

  00568	a1 00 00 00 00	 mov	 eax, DWORD PTR ?instance@GLWindow@@2PAV1@A ; GLWindow::instance
  0056d	83 c7 01	 add	 edi, 1
  00570	83 d6 00	 adc	 esi, 0
  00573	80 78 44 00	 cmp	 BYTE PTR [eax+68], 0
  00577	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?skipRender@RenderThread@@2_NA, 0 ; RenderThread::skipRender
  0057e	74 09		 je	 SHORT $LN7@WinMain
  00580	e8 00 00 00 00	 call	 ?mainLoop@@YA_NXZ	; mainLoop
  00585	84 c0		 test	 al, al
  00587	74 0f		 je	 SHORT $LN752@WinMain
$LN7@WinMain:

; 233  : 	while(!GlobalThread::stop)

  00589	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR ?stop@GlobalThread@@3_NA, 0 ; GlobalThread::stop
  00590	0f 84 6a ff ff
	ff		 je	 $LL14@WinMain
  00596	eb 07		 jmp	 SHORT $LN749@WinMain
$LN752@WinMain:

; 258  : 				{
; 259  : 					GlobalThread::stop = true;

  00598	c6 05 00 00 00
	00 01		 mov	 BYTE PTR ?stop@GlobalThread@@3_NA, 1 ; GlobalThread::stop
$LN749@WinMain:
; File c:\users\glenn\documents\github\wind\project\wind\wind\threads.cpp

; 45   : 	if(started) thread.join();

  0059f	80 3d 0c 00 00
	00 00		 cmp	 BYTE PTR ?renderThread@@3VRenderThread@@A+12, 0
  005a6	c6 05 0d 00 00
	00 01		 mov	 BYTE PTR ?renderThread@@3VRenderThread@@A+13, 1
  005ad	0f 84 7d 00 00
	00		 je	 $LL593@WinMain
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thread

; 83   : 		return (!_Thr_is_null(_Thr));

  005b3	83 3d 08 00 00
	00 00		 cmp	 DWORD PTR ?renderThread@@3VRenderThread@@A+8, 0

; 115  : 		return (*this);
; 116  : 		}
; 117  : 
; 118  : 	_Thrd_t _Thr;
; 119  : 	};
; 120  : 
; 121  : 	namespace this_thread {
; 122  : thread::id get_id() _NOEXCEPT;
; 123  : 
; 124  : inline void yield() _NOEXCEPT
; 125  : 	{	// give up balance of time slice
; 126  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)
; 127  : 		{	// yield, then quit
; 128  : 		::Concurrency::details::_Context::_Yield();
; 129  : 		return;
; 130  : 		}
; 131  : 	_Thrd_yield();
; 132  : 	}
; 133  : 
; 134  : inline void sleep_until(const stdext::threads::xtime *_Abs_time)
; 135  : 	{	// sleep until _Abs_time
; 136  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)
; 137  : 		{
; 138  : 		stdext::threads::xtime _Now;
; 139  : 		stdext::threads::xtime_get(&_Now, stdext::threads::TIME_UTC);
; 140  : 		::Concurrency::wait(_Xtime_diff_to_millis2(_Abs_time, &_Now));
; 141  : 		return;
; 142  : 		}
; 143  : 
; 144  : 	_Thrd_sleep(_Abs_time);
; 145  : 	}
; 146  : 
; 147  : template<class _Clock,
; 148  : 	class _Duration> inline
; 149  : 	void sleep_until(
; 150  : 		const chrono::time_point<_Clock, _Duration>& _Abs_time)
; 151  : 	{	// sleep until time point
; 152  : 	stdext::threads::xtime _Tgt;
; 153  : 	_Tgt.sec = chrono::duration_cast<chrono::seconds>(
; 154  : 		_Abs_time.time_since_epoch()).count();
; 155  : 	_Tgt.nsec = (long)chrono::duration_cast<chrono::nanoseconds>(
; 156  : 		_Abs_time.time_since_epoch() - chrono::seconds(_Tgt.sec)).count();
; 157  : 	sleep_until(&_Tgt);
; 158  : 	}
; 159  : 
; 160  : template<class _Rep,
; 161  : 	class _Period> inline
; 162  : 	void sleep_for(const chrono::duration<_Rep, _Period>& _Rel_time)
; 163  : 	{	// sleep for duration
; 164  : 	stdext::threads::xtime _Tgt = _To_xtime(_Rel_time);
; 165  : 	sleep_until(&_Tgt);
; 166  : 	}
; 167  : 	}	// namespace this_thread
; 168  : 
; 169  : class thread::id
; 170  : 	{	// thread id
; 171  : public:
; 172  : 	id() _NOEXCEPT
; 173  : 		{	// id for no thread
; 174  : 		_Thr_set_null(_Thr);
; 175  : 		}
; 176  : 
; 177  : 	template<class _Ch,
; 178  : 		class _Tr>
; 179  : 		basic_ostream<_Ch, _Tr>& _To_text(
; 180  : 			basic_ostream<_Ch, _Tr>& _Str)
; 181  : 		{	// insert representation into stream
; 182  : 		return (_Str << _Thr_val(_Thr));
; 183  : 		}
; 184  : 
; 185  : 	size_t hash() const
; 186  : 		{	// hash bits to size_t value by pseudorandomizing transform
; 187  : 		return (_STD hash<size_t>()((size_t)_Thr_val(_Thr)));
; 188  : 		}
; 189  : 
; 190  : private:
; 191  : 	id(const thread& _Thrd)
; 192  : 		: _Thr(_Thrd._Thr)
; 193  : 		{	// construct from thread object
; 194  : 		}
; 195  : 
; 196  : 	id(_Thrd_t _Thrd)
; 197  : 		: _Thr(_Thrd)
; 198  : 		{	// construct from thread identifier
; 199  : 		}
; 200  : 
; 201  : 	_Thrd_t _Thr;
; 202  : 
; 203  : 	friend thread::id thread::get_id() const _NOEXCEPT;
; 204  : 	friend thread::id this_thread::get_id() _NOEXCEPT;
; 205  : 	friend bool operator==(thread::id _Left, thread::id _Right) _NOEXCEPT;
; 206  : 	friend bool operator<(thread::id _Left, thread::id _Right) _NOEXCEPT;
; 207  : 	};
; 208  : 
; 209  : inline void thread::join()
; 210  : 	{	// join thread
; 211  : 	if (!joinable())

  005ba	75 1d		 jne	 SHORT $LN591@WinMain

; 212  : 		_Throw_Cpp_error(_INVALID_ARGUMENT);

  005bc	6a 01		 push	 1
  005be	e8 00 00 00 00	 call	 ?_Throw_Cpp_error@std@@YAXH@Z ; std::_Throw_Cpp_error
  005c3	83 c4 04	 add	 esp, 4

; 213  : 	if (_Thr_is_null(_Thr))

  005c6	83 3d 08 00 00
	00 00		 cmp	 DWORD PTR ?renderThread@@3VRenderThread@@A+8, 0
  005cd	75 0a		 jne	 SHORT $LN591@WinMain

; 214  : 		_Throw_Cpp_error(_INVALID_ARGUMENT);

  005cf	6a 01		 push	 1
  005d1	e8 00 00 00 00	 call	 ?_Throw_Cpp_error@std@@YAXH@Z ; std::_Throw_Cpp_error
  005d6	83 c4 04	 add	 esp, 4
$LN591@WinMain:

; 220  : 	}
; 221  : 
; 222  : inline thread::id thread::get_id() const _NOEXCEPT
; 223  : 	{	// return id for this thread
; 224  : 	return (id(*this));
; 225  : 	}
; 226  : 
; 227  : inline thread::id this_thread::get_id() _NOEXCEPT
; 228  : 	{	// return id for current thread
; 229  : 	return (_Thrd_current());

  005d9	e8 00 00 00 00	 call	 __Thrd_current

; 230  : 	}
; 231  : 
; 232  : inline void swap(thread& _Left, thread& _Right) _NOEXCEPT
; 233  : 	{	// swap _Left with _Right
; 234  : 	_Left.swap(_Right);
; 235  : 	}
; 236  : 
; 237  : inline bool operator==(thread::id _Left, thread::id _Right) _NOEXCEPT
; 238  : 	{	// return true if _Left and _Right identify the same thread
; 239  : 	return (_Thrd_equal(_Left._Thr, _Right._Thr));

  005de	52		 push	 edx
  005df	50		 push	 eax
  005e0	ff 35 08 00 00
	00		 push	 DWORD PTR ?renderThread@@3VRenderThread@@A+8
  005e6	ff 35 04 00 00
	00		 push	 DWORD PTR ?renderThread@@3VRenderThread@@A+4
  005ec	e8 00 00 00 00	 call	 __Thrd_equal
  005f1	83 c4 10	 add	 esp, 16			; 00000010H
  005f4	85 c0		 test	 eax, eax

; 215  : 	if (get_id() == _STD this_thread::get_id())

  005f6	74 0a		 je	 SHORT $LN590@WinMain

; 216  : 		_Throw_Cpp_error(_RESOURCE_DEADLOCK_WOULD_OCCUR);

  005f8	6a 05		 push	 5
  005fa	e8 00 00 00 00	 call	 ?_Throw_Cpp_error@std@@YAXH@Z ; std::_Throw_Cpp_error
  005ff	83 c4 04	 add	 esp, 4
$LN590@WinMain:

; 217  : 	if (_Thrd_join(_Thr, 0) != _Thrd_success)

  00602	6a 00		 push	 0
  00604	ff 35 08 00 00
	00		 push	 DWORD PTR ?renderThread@@3VRenderThread@@A+8
  0060a	ff 35 04 00 00
	00		 push	 DWORD PTR ?renderThread@@3VRenderThread@@A+4
  00610	e8 00 00 00 00	 call	 __Thrd_join
  00615	83 c4 0c	 add	 esp, 12			; 0000000cH
  00618	85 c0		 test	 eax, eax
  0061a	74 0a		 je	 SHORT $LN589@WinMain

; 218  : 		_Throw_Cpp_error(_NO_SUCH_PROCESS);

  0061c	6a 02		 push	 2
  0061e	e8 00 00 00 00	 call	 ?_Throw_Cpp_error@std@@YAXH@Z ; std::_Throw_Cpp_error
  00623	83 c4 04	 add	 esp, 4
$LN589@WinMain:

; 219  : 	_Thr_set_null(_Thr);

  00626	c7 05 08 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?renderThread@@3VRenderThread@@A+8, 0
$LL593@WinMain:
; File c:\users\glenn\documents\github\wind\project\wind\wind\threads.cpp

; 45   : 	if(started) thread.join();

  00630	80 3d 0c 00 00
	00 00		 cmp	 BYTE PTR ?chunkLoadThreads@@3PAVChunkLoadThread@@A+12, 0
  00637	c6 05 0d 00 00
	00 01		 mov	 BYTE PTR ?chunkLoadThreads@@3PAVChunkLoadThread@@A+13, 1
  0063e	0f 84 7d 00 00
	00		 je	 $LN5@WinMain
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thread

; 83   : 		return (!_Thr_is_null(_Thr));

  00644	83 3d 08 00 00
	00 00		 cmp	 DWORD PTR ?chunkLoadThreads@@3PAVChunkLoadThread@@A+8, 0

; 115  : 		return (*this);
; 116  : 		}
; 117  : 
; 118  : 	_Thrd_t _Thr;
; 119  : 	};
; 120  : 
; 121  : 	namespace this_thread {
; 122  : thread::id get_id() _NOEXCEPT;
; 123  : 
; 124  : inline void yield() _NOEXCEPT
; 125  : 	{	// give up balance of time slice
; 126  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)
; 127  : 		{	// yield, then quit
; 128  : 		::Concurrency::details::_Context::_Yield();
; 129  : 		return;
; 130  : 		}
; 131  : 	_Thrd_yield();
; 132  : 	}
; 133  : 
; 134  : inline void sleep_until(const stdext::threads::xtime *_Abs_time)
; 135  : 	{	// sleep until _Abs_time
; 136  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)
; 137  : 		{
; 138  : 		stdext::threads::xtime _Now;
; 139  : 		stdext::threads::xtime_get(&_Now, stdext::threads::TIME_UTC);
; 140  : 		::Concurrency::wait(_Xtime_diff_to_millis2(_Abs_time, &_Now));
; 141  : 		return;
; 142  : 		}
; 143  : 
; 144  : 	_Thrd_sleep(_Abs_time);
; 145  : 	}
; 146  : 
; 147  : template<class _Clock,
; 148  : 	class _Duration> inline
; 149  : 	void sleep_until(
; 150  : 		const chrono::time_point<_Clock, _Duration>& _Abs_time)
; 151  : 	{	// sleep until time point
; 152  : 	stdext::threads::xtime _Tgt;
; 153  : 	_Tgt.sec = chrono::duration_cast<chrono::seconds>(
; 154  : 		_Abs_time.time_since_epoch()).count();
; 155  : 	_Tgt.nsec = (long)chrono::duration_cast<chrono::nanoseconds>(
; 156  : 		_Abs_time.time_since_epoch() - chrono::seconds(_Tgt.sec)).count();
; 157  : 	sleep_until(&_Tgt);
; 158  : 	}
; 159  : 
; 160  : template<class _Rep,
; 161  : 	class _Period> inline
; 162  : 	void sleep_for(const chrono::duration<_Rep, _Period>& _Rel_time)
; 163  : 	{	// sleep for duration
; 164  : 	stdext::threads::xtime _Tgt = _To_xtime(_Rel_time);
; 165  : 	sleep_until(&_Tgt);
; 166  : 	}
; 167  : 	}	// namespace this_thread
; 168  : 
; 169  : class thread::id
; 170  : 	{	// thread id
; 171  : public:
; 172  : 	id() _NOEXCEPT
; 173  : 		{	// id for no thread
; 174  : 		_Thr_set_null(_Thr);
; 175  : 		}
; 176  : 
; 177  : 	template<class _Ch,
; 178  : 		class _Tr>
; 179  : 		basic_ostream<_Ch, _Tr>& _To_text(
; 180  : 			basic_ostream<_Ch, _Tr>& _Str)
; 181  : 		{	// insert representation into stream
; 182  : 		return (_Str << _Thr_val(_Thr));
; 183  : 		}
; 184  : 
; 185  : 	size_t hash() const
; 186  : 		{	// hash bits to size_t value by pseudorandomizing transform
; 187  : 		return (_STD hash<size_t>()((size_t)_Thr_val(_Thr)));
; 188  : 		}
; 189  : 
; 190  : private:
; 191  : 	id(const thread& _Thrd)
; 192  : 		: _Thr(_Thrd._Thr)
; 193  : 		{	// construct from thread object
; 194  : 		}
; 195  : 
; 196  : 	id(_Thrd_t _Thrd)
; 197  : 		: _Thr(_Thrd)
; 198  : 		{	// construct from thread identifier
; 199  : 		}
; 200  : 
; 201  : 	_Thrd_t _Thr;
; 202  : 
; 203  : 	friend thread::id thread::get_id() const _NOEXCEPT;
; 204  : 	friend thread::id this_thread::get_id() _NOEXCEPT;
; 205  : 	friend bool operator==(thread::id _Left, thread::id _Right) _NOEXCEPT;
; 206  : 	friend bool operator<(thread::id _Left, thread::id _Right) _NOEXCEPT;
; 207  : 	};
; 208  : 
; 209  : inline void thread::join()
; 210  : 	{	// join thread
; 211  : 	if (!joinable())

  0064b	75 1d		 jne	 SHORT $LN612@WinMain

; 212  : 		_Throw_Cpp_error(_INVALID_ARGUMENT);

  0064d	6a 01		 push	 1
  0064f	e8 00 00 00 00	 call	 ?_Throw_Cpp_error@std@@YAXH@Z ; std::_Throw_Cpp_error
  00654	83 c4 04	 add	 esp, 4

; 213  : 	if (_Thr_is_null(_Thr))

  00657	83 3d 08 00 00
	00 00		 cmp	 DWORD PTR ?chunkLoadThreads@@3PAVChunkLoadThread@@A+8, 0
  0065e	75 0a		 jne	 SHORT $LN612@WinMain

; 214  : 		_Throw_Cpp_error(_INVALID_ARGUMENT);

  00660	6a 01		 push	 1
  00662	e8 00 00 00 00	 call	 ?_Throw_Cpp_error@std@@YAXH@Z ; std::_Throw_Cpp_error
  00667	83 c4 04	 add	 esp, 4
$LN612@WinMain:

; 220  : 	}
; 221  : 
; 222  : inline thread::id thread::get_id() const _NOEXCEPT
; 223  : 	{	// return id for this thread
; 224  : 	return (id(*this));
; 225  : 	}
; 226  : 
; 227  : inline thread::id this_thread::get_id() _NOEXCEPT
; 228  : 	{	// return id for current thread
; 229  : 	return (_Thrd_current());

  0066a	e8 00 00 00 00	 call	 __Thrd_current

; 230  : 	}
; 231  : 
; 232  : inline void swap(thread& _Left, thread& _Right) _NOEXCEPT
; 233  : 	{	// swap _Left with _Right
; 234  : 	_Left.swap(_Right);
; 235  : 	}
; 236  : 
; 237  : inline bool operator==(thread::id _Left, thread::id _Right) _NOEXCEPT
; 238  : 	{	// return true if _Left and _Right identify the same thread
; 239  : 	return (_Thrd_equal(_Left._Thr, _Right._Thr));

  0066f	52		 push	 edx
  00670	50		 push	 eax
  00671	ff 35 08 00 00
	00		 push	 DWORD PTR ?chunkLoadThreads@@3PAVChunkLoadThread@@A+8
  00677	ff 35 04 00 00
	00		 push	 DWORD PTR ?chunkLoadThreads@@3PAVChunkLoadThread@@A+4
  0067d	e8 00 00 00 00	 call	 __Thrd_equal
  00682	83 c4 10	 add	 esp, 16			; 00000010H
  00685	85 c0		 test	 eax, eax

; 215  : 	if (get_id() == _STD this_thread::get_id())

  00687	74 0a		 je	 SHORT $LN611@WinMain

; 216  : 		_Throw_Cpp_error(_RESOURCE_DEADLOCK_WOULD_OCCUR);

  00689	6a 05		 push	 5
  0068b	e8 00 00 00 00	 call	 ?_Throw_Cpp_error@std@@YAXH@Z ; std::_Throw_Cpp_error
  00690	83 c4 04	 add	 esp, 4
$LN611@WinMain:

; 217  : 	if (_Thrd_join(_Thr, 0) != _Thrd_success)

  00693	6a 00		 push	 0
  00695	ff 35 08 00 00
	00		 push	 DWORD PTR ?chunkLoadThreads@@3PAVChunkLoadThread@@A+8
  0069b	ff 35 04 00 00
	00		 push	 DWORD PTR ?chunkLoadThreads@@3PAVChunkLoadThread@@A+4
  006a1	e8 00 00 00 00	 call	 __Thrd_join
  006a6	83 c4 0c	 add	 esp, 12			; 0000000cH
  006a9	85 c0		 test	 eax, eax
  006ab	74 0a		 je	 SHORT $LN610@WinMain

; 218  : 		_Throw_Cpp_error(_NO_SUCH_PROCESS);

  006ad	6a 02		 push	 2
  006af	e8 00 00 00 00	 call	 ?_Throw_Cpp_error@std@@YAXH@Z ; std::_Throw_Cpp_error
  006b4	83 c4 04	 add	 esp, 4
$LN610@WinMain:

; 219  : 	_Thr_set_null(_Thr);

  006b7	c7 05 08 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?chunkLoadThreads@@3PAVChunkLoadThread@@A+8, 0
$LN5@WinMain:
; File c:\users\glenn\documents\github\wind\project\wind\wind\main.cpp

; 270  : 	for(int i = 0; i < DRAW_THREAD_AMOUNT; i++)

  006c1	be 08 00 00 00	 mov	 esi, OFFSET ?chunkDrawThreads@@3PAVChunkDrawThread@@A+8
$LL3@WinMain:
; File c:\users\glenn\documents\github\wind\project\wind\wind\threads.cpp

; 45   : 	if(started) thread.join();

  006c6	80 7e 04 00	 cmp	 BYTE PTR [esi+4], 0
  006ca	c6 46 05 01	 mov	 BYTE PTR [esi+5], 1
  006ce	74 63		 je	 SHORT $LN2@WinMain
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thread

; 83   : 		return (!_Thr_is_null(_Thr));

  006d0	83 3e 00	 cmp	 DWORD PTR [esi], 0

; 115  : 		return (*this);
; 116  : 		}
; 117  : 
; 118  : 	_Thrd_t _Thr;
; 119  : 	};
; 120  : 
; 121  : 	namespace this_thread {
; 122  : thread::id get_id() _NOEXCEPT;
; 123  : 
; 124  : inline void yield() _NOEXCEPT
; 125  : 	{	// give up balance of time slice
; 126  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)
; 127  : 		{	// yield, then quit
; 128  : 		::Concurrency::details::_Context::_Yield();
; 129  : 		return;
; 130  : 		}
; 131  : 	_Thrd_yield();
; 132  : 	}
; 133  : 
; 134  : inline void sleep_until(const stdext::threads::xtime *_Abs_time)
; 135  : 	{	// sleep until _Abs_time
; 136  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)
; 137  : 		{
; 138  : 		stdext::threads::xtime _Now;
; 139  : 		stdext::threads::xtime_get(&_Now, stdext::threads::TIME_UTC);
; 140  : 		::Concurrency::wait(_Xtime_diff_to_millis2(_Abs_time, &_Now));
; 141  : 		return;
; 142  : 		}
; 143  : 
; 144  : 	_Thrd_sleep(_Abs_time);
; 145  : 	}
; 146  : 
; 147  : template<class _Clock,
; 148  : 	class _Duration> inline
; 149  : 	void sleep_until(
; 150  : 		const chrono::time_point<_Clock, _Duration>& _Abs_time)
; 151  : 	{	// sleep until time point
; 152  : 	stdext::threads::xtime _Tgt;
; 153  : 	_Tgt.sec = chrono::duration_cast<chrono::seconds>(
; 154  : 		_Abs_time.time_since_epoch()).count();
; 155  : 	_Tgt.nsec = (long)chrono::duration_cast<chrono::nanoseconds>(
; 156  : 		_Abs_time.time_since_epoch() - chrono::seconds(_Tgt.sec)).count();
; 157  : 	sleep_until(&_Tgt);
; 158  : 	}
; 159  : 
; 160  : template<class _Rep,
; 161  : 	class _Period> inline
; 162  : 	void sleep_for(const chrono::duration<_Rep, _Period>& _Rel_time)
; 163  : 	{	// sleep for duration
; 164  : 	stdext::threads::xtime _Tgt = _To_xtime(_Rel_time);
; 165  : 	sleep_until(&_Tgt);
; 166  : 	}
; 167  : 	}	// namespace this_thread
; 168  : 
; 169  : class thread::id
; 170  : 	{	// thread id
; 171  : public:
; 172  : 	id() _NOEXCEPT
; 173  : 		{	// id for no thread
; 174  : 		_Thr_set_null(_Thr);
; 175  : 		}
; 176  : 
; 177  : 	template<class _Ch,
; 178  : 		class _Tr>
; 179  : 		basic_ostream<_Ch, _Tr>& _To_text(
; 180  : 			basic_ostream<_Ch, _Tr>& _Str)
; 181  : 		{	// insert representation into stream
; 182  : 		return (_Str << _Thr_val(_Thr));
; 183  : 		}
; 184  : 
; 185  : 	size_t hash() const
; 186  : 		{	// hash bits to size_t value by pseudorandomizing transform
; 187  : 		return (_STD hash<size_t>()((size_t)_Thr_val(_Thr)));
; 188  : 		}
; 189  : 
; 190  : private:
; 191  : 	id(const thread& _Thrd)
; 192  : 		: _Thr(_Thrd._Thr)
; 193  : 		{	// construct from thread object
; 194  : 		}
; 195  : 
; 196  : 	id(_Thrd_t _Thrd)
; 197  : 		: _Thr(_Thrd)
; 198  : 		{	// construct from thread identifier
; 199  : 		}
; 200  : 
; 201  : 	_Thrd_t _Thr;
; 202  : 
; 203  : 	friend thread::id thread::get_id() const _NOEXCEPT;
; 204  : 	friend thread::id this_thread::get_id() _NOEXCEPT;
; 205  : 	friend bool operator==(thread::id _Left, thread::id _Right) _NOEXCEPT;
; 206  : 	friend bool operator<(thread::id _Left, thread::id _Right) _NOEXCEPT;
; 207  : 	};
; 208  : 
; 209  : inline void thread::join()
; 210  : 	{	// join thread
; 211  : 	if (!joinable())

  006d3	75 19		 jne	 SHORT $LN633@WinMain

; 212  : 		_Throw_Cpp_error(_INVALID_ARGUMENT);

  006d5	6a 01		 push	 1
  006d7	e8 00 00 00 00	 call	 ?_Throw_Cpp_error@std@@YAXH@Z ; std::_Throw_Cpp_error
  006dc	83 c4 04	 add	 esp, 4

; 213  : 	if (_Thr_is_null(_Thr))

  006df	83 3e 00	 cmp	 DWORD PTR [esi], 0
  006e2	75 0a		 jne	 SHORT $LN633@WinMain

; 214  : 		_Throw_Cpp_error(_INVALID_ARGUMENT);

  006e4	6a 01		 push	 1
  006e6	e8 00 00 00 00	 call	 ?_Throw_Cpp_error@std@@YAXH@Z ; std::_Throw_Cpp_error
  006eb	83 c4 04	 add	 esp, 4
$LN633@WinMain:

; 220  : 	}
; 221  : 
; 222  : inline thread::id thread::get_id() const _NOEXCEPT
; 223  : 	{	// return id for this thread
; 224  : 	return (id(*this));
; 225  : 	}
; 226  : 
; 227  : inline thread::id this_thread::get_id() _NOEXCEPT
; 228  : 	{	// return id for current thread
; 229  : 	return (_Thrd_current());

  006ee	e8 00 00 00 00	 call	 __Thrd_current

; 230  : 	}
; 231  : 
; 232  : inline void swap(thread& _Left, thread& _Right) _NOEXCEPT
; 233  : 	{	// swap _Left with _Right
; 234  : 	_Left.swap(_Right);
; 235  : 	}
; 236  : 
; 237  : inline bool operator==(thread::id _Left, thread::id _Right) _NOEXCEPT
; 238  : 	{	// return true if _Left and _Right identify the same thread
; 239  : 	return (_Thrd_equal(_Left._Thr, _Right._Thr));

  006f3	52		 push	 edx
  006f4	50		 push	 eax
  006f5	ff 36		 push	 DWORD PTR [esi]
  006f7	ff 76 fc	 push	 DWORD PTR [esi-4]
  006fa	e8 00 00 00 00	 call	 __Thrd_equal
  006ff	83 c4 10	 add	 esp, 16			; 00000010H
  00702	85 c0		 test	 eax, eax

; 215  : 	if (get_id() == _STD this_thread::get_id())

  00704	74 0a		 je	 SHORT $LN632@WinMain

; 216  : 		_Throw_Cpp_error(_RESOURCE_DEADLOCK_WOULD_OCCUR);

  00706	6a 05		 push	 5
  00708	e8 00 00 00 00	 call	 ?_Throw_Cpp_error@std@@YAXH@Z ; std::_Throw_Cpp_error
  0070d	83 c4 04	 add	 esp, 4
$LN632@WinMain:

; 217  : 	if (_Thrd_join(_Thr, 0) != _Thrd_success)

  00710	6a 00		 push	 0
  00712	ff 36		 push	 DWORD PTR [esi]
  00714	ff 76 fc	 push	 DWORD PTR [esi-4]
  00717	e8 00 00 00 00	 call	 __Thrd_join
  0071c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0071f	85 c0		 test	 eax, eax
  00721	74 0a		 je	 SHORT $LN631@WinMain

; 218  : 		_Throw_Cpp_error(_NO_SUCH_PROCESS);

  00723	6a 02		 push	 2
  00725	e8 00 00 00 00	 call	 ?_Throw_Cpp_error@std@@YAXH@Z ; std::_Throw_Cpp_error
  0072a	83 c4 04	 add	 esp, 4
$LN631@WinMain:

; 219  : 	_Thr_set_null(_Thr);

  0072d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
$LN2@WinMain:
; File c:\users\glenn\documents\github\wind\project\wind\wind\main.cpp

; 270  : 	for(int i = 0; i < DRAW_THREAD_AMOUNT; i++)

  00733	81 c6 60 04 00
	00		 add	 esi, 1120		; 00000460H
  00739	81 fe 88 11 00
	00		 cmp	 esi, OFFSET ?chunkDrawThreads@@3PAVChunkDrawThread@@A+4488
  0073f	7c 85		 jl	 SHORT $LL3@WinMain

; 271  : 	{
; 272  : 		chunkDrawThreads[i].stop();
; 273  : 	}
; 274  : 
; 275  : 	delete GLWindow::instance;

  00741	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?instance@GLWindow@@2PAV1@A ; GLWindow::instance
  00747	85 f6		 test	 esi, esi
  00749	0f 84 90 00 00
	00		 je	 $LN649@WinMain
; File c:\users\glenn\documents\github\wind\project\wind\wind\window.cpp

; 238  : 	if(hDC && !ReleaseDC(hWnd, hDC))

  0074f	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  00752	32 db		 xor	 bl, bl
  00754	85 c0		 test	 eax, eax
  00756	74 13		 je	 SHORT $LN657@WinMain
  00758	50		 push	 eax
  00759	ff 76 08	 push	 DWORD PTR [esi+8]
  0075c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ReleaseDC@8
  00762	85 c0		 test	 eax, eax
  00764	75 05		 jne	 SHORT $LN657@WinMain

; 239  : 	{
; 240  : 		hDC = NULL;

  00766	89 46 0c	 mov	 DWORD PTR [esi+12], eax

; 241  : 		error = true;

  00769	b3 01		 mov	 bl, 1
$LN657@WinMain:

; 242  : 	}
; 243  : 	if(hWnd && !DestroyWindow(hWnd))

  0076b	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0076e	85 c0		 test	 eax, eax
  00770	74 10		 je	 SHORT $LN656@WinMain
  00772	50		 push	 eax
  00773	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DestroyWindow@4
  00779	85 c0		 test	 eax, eax
  0077b	75 05		 jne	 SHORT $LN656@WinMain

; 244  : 	{
; 245  : 		hWnd = NULL;

  0077d	89 46 08	 mov	 DWORD PTR [esi+8], eax

; 246  : 		error = true;

  00780	b3 01		 mov	 bl, 1
$LN656@WinMain:

; 247  : 	}
; 248  : 	if(!UnregisterClass(L"GLWindow", hInstance))

  00782	ff 76 04	 push	 DWORD PTR [esi+4]
  00785	68 00 00 00 00	 push	 OFFSET $SG4294937611
  0078a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__UnregisterClassW@8
  00790	85 c0		 test	 eax, eax
  00792	75 05		 jne	 SHORT $LN655@WinMain

; 249  : 	{
; 250  : 		hInstance = NULL;

  00794	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 251  : 		error = true;
; 252  : 	}
; 253  : 	if(error)

  00797	eb 04		 jmp	 SHORT $LN750@WinMain
$LN655@WinMain:
  00799	84 db		 test	 bl, bl
  0079b	74 14		 je	 SHORT $LN654@WinMain
$LN750@WinMain:

; 254  : 	{
; 255  : 		MessageBox(NULL, L"There was an error while destroying the window", L"ERROR", MB_OK | MB_ICONINFORMATION);

  0079d	6a 40		 push	 64			; 00000040H
  0079f	68 00 00 00 00	 push	 OFFSET $SG4294937610
  007a4	68 00 00 00 00	 push	 OFFSET $SG4294937609
  007a9	6a 00		 push	 0
  007ab	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxW@16
$LN654@WinMain:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 2256 : 		else if (this->_BUF_SIZE <= this->_Myres)

  007b1	83 7e 2c 08	 cmp	 DWORD PTR [esi+44], 8
  007b5	72 0b		 jb	 SHORT $LN682@WinMain
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 586  : 		::operator delete(_Ptr);

  007b7	ff 76 18	 push	 DWORD PTR [esi+24]
  007ba	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  007bf	83 c4 04	 add	 esp, 4
$LN682@WinMain:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd

; 347  : 		_Left = _Right;

  007c2	33 c0		 xor	 eax, eax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 2265 : 		this->_Myres = this->_BUF_SIZE - 1;

  007c4	c7 46 2c 07 00
	00 00		 mov	 DWORD PTR [esi+44], 7

; 1145 : 		}
; 1146 : 
; 1147 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1148 : 		{	// assign _Count * _Ch
; 1149 : 		if (_Count == npos)
; 1150 : 			_Xlen();	// result too long
; 1151 : 
; 1152 : 		if (_Grow(_Count))
; 1153 : 			{	// make room and assign new stuff
; 1154 : 			_Chassign(0, _Count, _Ch);
; 1155 : 			_Eos(_Count);
; 1156 : 			}
; 1157 : 		return (*this);
; 1158 : 		}
; 1159 : 
; 1160 : 	template<class _Iter>
; 1161 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1162 : 			_Myt&>::type
; 1163 : 		assign(_Iter _First, _Iter _Last)
; 1164 : 		{	// assign [First, _Last), input iterators
; 1165 : 		return (replace(begin(), end(), _First, _Last));
; 1166 : 		}
; 1167 : 
; 1168 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1169 : 		{	// assign [First, _Last), const pointers
; 1170 : 		return (replace(begin(), end(), _First, _Last));
; 1171 : 		}
; 1172 : 
; 1173 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1174 : 		{	// assign [First, _Last), const_iterators
; 1175 : 		return (replace(begin(), end(), _First, _Last));
; 1176 : 		}
; 1177 : 
; 1178 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1179 : 		{	// insert _Right at _Off
; 1180 : 		return (insert(_Off, _Right, 0, npos));
; 1181 : 		}
; 1182 : 
; 1183 : 	_Myt& insert(size_type _Off,
; 1184 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1185 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1186 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1187 : 			_Xran();	// _Off or _Roff off end
; 1188 : 		size_type _Num = _Right.size() - _Roff;
; 1189 : 		if (_Num < _Count)
; 1190 : 			_Count = _Num;	// trim _Count to size
; 1191 : 		if (npos - this->_Mysize <= _Count)
; 1192 : 			_Xlen();	// result too long
; 1193 : 
; 1194 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1195 : 			{	// make room and insert new stuff
; 1196 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1197 : 				this->_Myptr() + _Off,
; 1198 : 				this->_Mysize - _Off);	// empty out hole
; 1199 : 			if (this == &_Right)
; 1200 : 				_Traits::move(this->_Myptr() + _Off,
; 1201 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1202 : 						_Count);	// substring
; 1203 : 			else
; 1204 : 				_Traits::copy(this->_Myptr() + _Off,
; 1205 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1206 : 			_Eos(_Num);
; 1207 : 			}
; 1208 : 		return (*this);
; 1209 : 		}
; 1210 : 
; 1211 : 	_Myt& insert(size_type _Off,
; 1212 : 		const _Elem *_Ptr, size_type _Count)
; 1213 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1214 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1215 : 		if (_Count != 0)
; 1216 : 			_DEBUG_POINTER(_Ptr);
; 1217 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1218 : 
; 1219 : 		if (_Inside(_Ptr))
; 1220 : 			return (insert(_Off, *this,
; 1221 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1222 : 		if (this->_Mysize < _Off)
; 1223 : 			_Xran();	// _Off off end
; 1224 : 		if (npos - this->_Mysize <= _Count)
; 1225 : 			_Xlen();	// result too long
; 1226 : 		size_type _Num;
; 1227 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1228 : 			{	// make room and insert new stuff
; 1229 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1230 : 				this->_Myptr() + _Off,
; 1231 : 				this->_Mysize - _Off);	// empty out hole
; 1232 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1233 : 			_Eos(_Num);
; 1234 : 			}
; 1235 : 		return (*this);
; 1236 : 		}
; 1237 : 
; 1238 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1239 : 		{	// insert [_Ptr, <null>) at _Off
; 1240 : 		_DEBUG_POINTER(_Ptr);
; 1241 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1242 : 		}
; 1243 : 
; 1244 : 	_Myt& insert(size_type _Off,
; 1245 : 		size_type _Count, _Elem _Ch)
; 1246 : 		{	// insert _Count * _Ch at _Off
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	iterator insert(const_iterator _Where)
; 1264 : 		{	// insert <null> at _Where
; 1265 : 		return (insert(_Where, _Elem()));
; 1266 : 		}
; 1267 : 
; 1268 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1269 : 		{	// insert _Ch at _Where
; 1270 : 		size_type _Off = _Pdif(_Where, begin());
; 1271 : 		insert(_Off, 1, _Ch);
; 1272 : 		return (begin() + _Off);
; 1273 : 		}
; 1274 : 
; 1275 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1276 : 		{	// insert _Count * _Elem at _Where
; 1277 : 		size_type _Off = _Pdif(_Where, begin());
; 1278 : 		insert(_Off, _Count, _Ch);
; 1279 : 		return (begin() + _Off);
; 1280 : 		}
; 1281 : 
; 1282 : 	template<class _Iter>
; 1283 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1284 : 			iterator>::type
; 1285 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1286 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1287 : 		size_type _Off = _Pdif(_Where, begin());
; 1288 : 		replace(_Where, _Where, _First, _Last);
; 1289 : 		return (begin() + _Off);
; 1290 : 		}
; 1291 : 
; 1292 : 	iterator insert(const_iterator _Where,
; 1293 : 		const_pointer _First, const_pointer _Last)
; 1294 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		replace(_Where, _Where, _First, _Last);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where,
; 1301 : 		const_iterator _First, const_iterator _Last)
; 1302 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1303 : 		size_type _Off = _Pdif(_Where, begin());
; 1304 : 		replace(_Where, _Where, _First, _Last);
; 1305 : 		return (begin() + _Off);
; 1306 : 		}
; 1307 : 
; 1308 : 	_Myt& erase(size_type _Off = 0)
; 1309 : 		{	// erase elements [_Off, ...)
; 1310 : 		if (this->_Mysize < _Off)
; 1311 : 			_Xran();	// _Off off end
; 1312 : 		_Eos(_Off);
; 1313 : 		return (*this);
; 1314 : 		}
; 1315 : 
; 1316 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1317 : 		{	// erase elements [_Off, _Off + _Count)
; 1318 : 		if (this->_Mysize < _Off)
; 1319 : 			_Xran();	// _Off off end
; 1320 : 		if (this->_Mysize - _Off <= _Count)
; 1321 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1322 : 		else if (0 < _Count)
; 1323 : 			{	// move elements down
; 1324 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1325 : 			size_type _Newsize = this->_Mysize - _Count;
; 1326 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1327 : 			_Eos(_Newsize);
; 1328 : 			}
; 1329 : 		return (*this);
; 1330 : 		}
; 1331 : 
; 1332 : 	iterator erase(const_iterator _Where)
; 1333 : 		{	// erase element at _Where
; 1334 : 		size_type _Count = _Pdif(_Where, begin());
; 1335 : 		erase(_Count, 1);
; 1336 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1337 : 		}
; 1338 : 
; 1339 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1340 : 		{	// erase substring [_First, _Last)
; 1341 : 		_DEBUG_RANGE(_First, _Last);
; 1342 : 		size_type _Count = _Pdif(_First, begin());
; 1343 : 		erase(_Count, _Pdif(_Last, _First));
; 1344 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1345 : 		}
; 1346 : 
; 1347 : 	void clear() _NOEXCEPT
; 1348 : 		{	// erase all
; 1349 : 		_Eos(0);
; 1350 : 		}
; 1351 : 
; 1352 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1353 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1354 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1355 : 		}
; 1356 : 
; 1357 : 	_Myt& replace(size_type _Off,
; 1358 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1359 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1360 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1361 : 			_Xran();	// _Off or _Roff off end
; 1362 : 		if (this->_Mysize - _Off < _N0)
; 1363 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1364 : 		size_type _Num = _Right.size() - _Roff;
; 1365 : 		if (_Num < _Count)
; 1366 : 			_Count = _Num;	// trim _Count to size
; 1367 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1368 : 			_Xlen();	// result too long
; 1369 : 
; 1370 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1371 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1372 : 		if (this->_Mysize < _Newsize)
; 1373 : 			_Grow(_Newsize);
; 1374 : 
; 1375 : 		if (this != &_Right)
; 1376 : 			{	// no overlap, just move down and copy in new stuff
; 1377 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1378 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1379 : 			_Traits::copy(this->_Myptr() + _Off,
; 1380 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1381 : 			}
; 1382 : 		else if (_Count <= _N0)
; 1383 : 			{	// hole doesn't get larger, just copy in substring
; 1384 : 			_Traits::move(this->_Myptr() + _Off,
; 1385 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1386 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1387 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1388 : 			}
; 1389 : 		else if (_Roff <= _Off)
; 1390 : 			{	// hole gets larger, substring begins before hole
; 1391 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1392 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1393 : 			_Traits::move(this->_Myptr() + _Off,
; 1394 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1395 : 			}
; 1396 : 		else if (_Off + _N0 <= _Roff)
; 1397 : 			{	// hole gets larger, substring begins after hole
; 1398 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1399 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1400 : 			_Traits::move(this->_Myptr() + _Off,
; 1401 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1402 : 				_Count);	// fill hole
; 1403 : 			}
; 1404 : 		else
; 1405 : 			{	// hole gets larger, substring begins in hole
; 1406 : 			_Traits::move(this->_Myptr() + _Off,
; 1407 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1408 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1409 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1410 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1411 : 				this->_Myptr() + _Roff + _Count,
; 1412 : 				_Count - _N0);	// fill rest of new hole
; 1413 : 			}
; 1414 : 
; 1415 : 		_Eos(_Newsize);
; 1416 : 		return (*this);
; 1417 : 		}
; 1418 : 
; 1419 : 	_Myt& replace(size_type _Off,
; 1420 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1421 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1422 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1423 : 		if (_Count != 0)
; 1424 : 			_DEBUG_POINTER(_Ptr);
; 1425 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1426 : 
; 1427 : 		if (_Inside(_Ptr))
; 1428 : 			return (replace(_Off, _N0, *this,
; 1429 : 				_Ptr - this->_Myptr(),
; 1430 : 				_Count));	// substring, replace carefully
; 1431 : 		if (this->_Mysize < _Off)
; 1432 : 			_Xran();	// _Off off end
; 1433 : 		if (this->_Mysize - _Off < _N0)
; 1434 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1435 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1436 : 			_Xlen();	// result too long
; 1437 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1438 : 
; 1439 : 		if (_Count < _N0)
; 1440 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1441 : 				this->_Myptr() + _Off + _N0,
; 1442 : 				_Nm);	// smaller hole, move tail up
; 1443 : 		size_type _Num;
; 1444 : 		if ((0 < _Count || 0 < _N0)
; 1445 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1446 : 			{	// make room and rearrange
; 1447 : 			if (_N0 < _Count)
; 1448 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1449 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1450 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1451 : 			_Eos(_Num);
; 1452 : 			}
; 1453 : 		return (*this);
; 1454 : 		}
; 1455 : 
; 1456 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1457 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1458 : 		_DEBUG_POINTER(_Ptr);
; 1459 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1460 : 		}
; 1461 : 
; 1462 : 	_Myt& replace(size_type _Off,
; 1463 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1464 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1465 : 		if (this->_Mysize < _Off)
; 1466 : 			_Xran();	// _Off off end
; 1467 : 		if (this->_Mysize - _Off < _N0)
; 1468 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1469 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1470 : 			_Xlen();	// result too long
; 1471 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1472 : 
; 1473 : 		if (_Count < _N0)
; 1474 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1475 : 				this->_Myptr() + _Off + _N0,
; 1476 : 				_Nm);	// smaller hole, move tail up
; 1477 : 		size_type _Num;
; 1478 : 		if ((0 < _Count || 0 < _N0)
; 1479 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1480 : 			{	// make room and rearrange
; 1481 : 			if (_N0 < _Count)
; 1482 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1483 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1484 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1485 : 			_Eos(_Num);
; 1486 : 			}
; 1487 : 		return (*this);
; 1488 : 		}
; 1489 : 
; 1490 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1491 : 		const _Myt& _Right)
; 1492 : 		{	// replace [_First, _Last) with _Right
; 1493 : 		return (replace(
; 1494 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1495 : 		}
; 1496 : 
; 1497 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1498 : 		const _Elem *_Ptr, size_type _Count)
; 1499 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1500 : 		return (replace(
; 1501 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1502 : 		}
; 1503 : 
; 1504 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1505 : 		const _Elem *_Ptr)
; 1506 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1507 : 		return (replace(
; 1508 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1509 : 		}
; 1510 : 
; 1511 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1512 : 		size_type _Count, _Elem _Ch)
; 1513 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1514 : 		return (replace(
; 1515 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1516 : 		}
; 1517 : 
; 1518 : 	template<class _Iter>
; 1519 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1520 : 			_Myt&>::type
; 1521 : 		replace(const_iterator _First, const_iterator _Last,
; 1522 : 			_Iter _First2, _Iter _Last2)
; 1523 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1524 : 		_Myt _Right(_First2, _Last2);
; 1525 : 		replace(_First, _Last, _Right);
; 1526 : 		return (*this);
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const_pointer _First2, const_pointer _Last2)
; 1531 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1532 : 		if (_First2 == _Last2)
; 1533 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1534 : 		else
; 1535 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1536 : 				&*_First2, _Last2 - _First2);
; 1537 : 		return (*this);
; 1538 : 		}
; 1539 : 
; 1540 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1541 : 		pointer _First2, pointer _Last2)
; 1542 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1543 : 		if (_First2 == _Last2)
; 1544 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1545 : 		else
; 1546 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1547 : 				&*_First2, _Last2 - _First2);
; 1548 : 		return (*this);
; 1549 : 		}
; 1550 : 
; 1551 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1552 : 		const_iterator _First2, const_iterator _Last2)
; 1553 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1554 : 		if (_First2 == _Last2)
; 1555 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1556 : 		else
; 1557 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1558 : 				&*_First2, _Last2 - _First2);
; 1559 : 		return (*this);
; 1560 : 		}
; 1561 : 
; 1562 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1563 : 		iterator _First2, iterator _Last2)
; 1564 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1565 : 		if (_First2 == _Last2)
; 1566 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1567 : 		else
; 1568 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1569 : 				&*_First2, _Last2 - _First2);
; 1570 : 		return (*this);
; 1571 : 		}
; 1572 : 
; 1573 : 	iterator begin() _NOEXCEPT
; 1574 : 		{	// return iterator for beginning of mutable sequence
; 1575 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1576 : 		}
; 1577 : 
; 1578 : 	const_iterator begin() const _NOEXCEPT
; 1579 : 		{	// return iterator for beginning of nonmutable sequence
; 1580 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1581 : 		}
; 1582 : 
; 1583 : 	iterator end() _NOEXCEPT
; 1584 : 		{	// return iterator for end of mutable sequence
; 1585 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1586 : 		}
; 1587 : 
; 1588 : 	const_iterator end() const _NOEXCEPT
; 1589 : 		{	// return iterator for end of nonmutable sequence
; 1590 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1591 : 		}
; 1592 : 
; 1593 : 	reverse_iterator rbegin() _NOEXCEPT
; 1594 : 		{	// return iterator for beginning of reversed mutable sequence
; 1595 : 		return (reverse_iterator(end()));
; 1596 : 		}
; 1597 : 
; 1598 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1600 : 		return (const_reverse_iterator(end()));
; 1601 : 		}
; 1602 : 
; 1603 : 	reverse_iterator rend() _NOEXCEPT
; 1604 : 		{	// return iterator for end of reversed mutable sequence
; 1605 : 		return (reverse_iterator(begin()));
; 1606 : 		}
; 1607 : 
; 1608 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1609 : 		{	// return iterator for end of reversed nonmutable sequence
; 1610 : 		return (const_reverse_iterator(begin()));
; 1611 : 		}
; 1612 : 
; 1613 :  #if _HAS_CPP0X
; 1614 : 	const_iterator cbegin() const _NOEXCEPT
; 1615 : 		{	// return iterator for beginning of nonmutable sequence
; 1616 : 		return (((const _Myt *)this)->begin());
; 1617 : 		}
; 1618 : 
; 1619 : 	const_iterator cend() const _NOEXCEPT
; 1620 : 		{	// return iterator for end of nonmutable sequence
; 1621 : 		return (((const _Myt *)this)->end());
; 1622 : 		}
; 1623 : 
; 1624 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1625 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1626 : 		return (((const _Myt *)this)->rbegin());
; 1627 : 		}
; 1628 : 
; 1629 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1630 : 		{	// return iterator for end of reversed nonmutable sequence
; 1631 : 		return (((const _Myt *)this)->rend());
; 1632 : 		}
; 1633 : 
; 1634 : 	void shrink_to_fit()
; 1635 : 		{	// reduce capacity
; 1636 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1637 : 			{	// worth shrinking, do it
; 1638 : 			_Myt _Tmp(*this);
; 1639 : 			swap(_Tmp);
; 1640 : 			}
; 1641 : 		}
; 1642 :  #endif /* _HAS_CPP0X */
; 1643 : 
; 1644 : 	reference at(size_type _Off)
; 1645 : 		{	// subscript mutable sequence with checking
; 1646 : 		if (this->_Mysize <= _Off)
; 1647 : 			_Xran();	// _Off off end
; 1648 : 		return (this->_Myptr()[_Off]);
; 1649 : 		}
; 1650 : 
; 1651 : 	const_reference at(size_type _Off) const
; 1652 : 		{	// subscript nonmutable sequence with checking
; 1653 : 		if (this->_Mysize <= _Off)
; 1654 : 			_Xran();	// _Off off end
; 1655 : 		return (this->_Myptr()[_Off]);
; 1656 : 		}
; 1657 : 
; 1658 : 	reference operator[](size_type _Off)
; 1659 : 		{	// subscript mutable sequence
; 1660 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1661 : 		if (this->_Mysize < _Off)	// sic
; 1662 : 			_DEBUG_ERROR("string subscript out of range");
; 1663 : 
; 1664 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1665 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1666 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1667 : 
; 1668 : 		return (this->_Myptr()[_Off]);
; 1669 : 		}
; 1670 : 
; 1671 : 	const_reference operator[](size_type _Off) const
; 1672 : 		{	// subscript nonmutable sequence
; 1673 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1674 : 		if (this->_Mysize < _Off)	// sic
; 1675 : 			_DEBUG_ERROR("string subscript out of range");
; 1676 : 
; 1677 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1678 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1679 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1680 : 
; 1681 : 		return (this->_Myptr()[_Off]);
; 1682 : 		}
; 1683 : 
; 1684 : 	void push_back(_Elem _Ch)
; 1685 : 		{	// insert element at end
; 1686 : 		insert(end(), _Ch);
; 1687 : 		}
; 1688 : 
; 1689 :  #if _HAS_CPP0X
; 1690 : 	void pop_back()
; 1691 : 		{	// erase element at end
; 1692 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1693 : 		}
; 1694 : 
; 1695 : 	reference front()
; 1696 : 		{	// return first element of mutable sequence
; 1697 : 		return (*begin());
; 1698 : 		}
; 1699 : 
; 1700 : 	const_reference front() const
; 1701 : 		{	// return first element of nonmutable sequence
; 1702 : 		return (*begin());
; 1703 : 		}
; 1704 : 
; 1705 : 	reference back()
; 1706 : 		{	// return last element of mutable sequence
; 1707 : 		return (*(end() - 1));
; 1708 : 		}
; 1709 : 
; 1710 : 	const_reference back() const
; 1711 : 		{	// return last element of nonmutable sequence
; 1712 : 		return (*(end() - 1));
; 1713 : 		}
; 1714 :  #endif /* _HAS_CPP0X */
; 1715 : 
; 1716 : 	const _Elem *c_str() const _NOEXCEPT
; 1717 : 		{	// return pointer to null-terminated nonmutable array
; 1718 : 		return (this->_Myptr());
; 1719 : 		}
; 1720 : 
; 1721 : 	const _Elem *data() const _NOEXCEPT
; 1722 : 		{	// return pointer to nonmutable array
; 1723 : 		return (c_str());
; 1724 : 		}
; 1725 : 
; 1726 : 	size_type length() const _NOEXCEPT
; 1727 : 		{	// return length of sequence
; 1728 : 		return (this->_Mysize);
; 1729 : 		}
; 1730 : 
; 1731 : 	size_type size() const _NOEXCEPT
; 1732 : 		{	// return length of sequence
; 1733 : 		return (this->_Mysize);
; 1734 : 		}
; 1735 : 
; 1736 : 	size_type max_size() const _NOEXCEPT
; 1737 : 		{	// return maximum possible length of sequence
; 1738 : 		size_type _Num = this->_Getal().max_size();
; 1739 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1740 : 		}
; 1741 : 
; 1742 : 	void resize(size_type _Newsize)
; 1743 : 		{	// determine new length, padding with null elements as needed
; 1744 : 		resize(_Newsize, _Elem());
; 1745 : 		}
; 1746 : 
; 1747 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1748 : 		{	// determine new length, padding with _Ch elements as needed
; 1749 : 		if (_Newsize <= this->_Mysize)
; 1750 : 			_Eos(_Newsize);
; 1751 : 		else
; 1752 : 			append(_Newsize - this->_Mysize, _Ch);
; 1753 : 		}
; 1754 : 
; 1755 : 	size_type capacity() const _NOEXCEPT
; 1756 : 		{	// return current length of allocated storage
; 1757 : 		return (this->_Myres);
; 1758 : 		}
; 1759 : 
; 1760 : 	void reserve(size_type _Newcap = 0)
; 1761 : 		{	// determine new minimum length of allocated storage
; 1762 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1763 : 			{	// change reservation
; 1764 : 			size_type _Size = this->_Mysize;
; 1765 : 			if (_Grow(_Newcap, true))
; 1766 : 				_Eos(_Size);
; 1767 : 			}
; 1768 : 		}
; 1769 : 
; 1770 : 	bool empty() const _NOEXCEPT
; 1771 : 		{	// test if sequence is empty
; 1772 : 		return (this->_Mysize == 0);
; 1773 : 		}
; 1774 : 
; 1775 : 	_SCL_INSECURE_DEPRECATE
; 1776 : 
; 1777 : 	size_type copy(_Elem *_Ptr,
; 1778 : 		size_type _Count, size_type _Off = 0) const
; 1779 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1780 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1781 : 		if (_Count != 0)
; 1782 : 			_DEBUG_POINTER(_Ptr);
; 1783 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1784 : 
; 1785 : 		if (this->_Mysize < _Off)
; 1786 : 			_Xran();	// _Off off end
; 1787 : 		if (this->_Mysize - _Off < _Count)
; 1788 : 			_Count = this->_Mysize - _Off;
; 1789 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1790 : 		return (_Count);
; 1791 : 		}
; 1792 : 
; 1793 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1794 : 		size_type _Count, size_type _Off = 0) const
; 1795 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1796 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1797 : 		if (_Count != 0)
; 1798 : 			_DEBUG_POINTER(_Dest);
; 1799 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1800 : 
; 1801 : 		if (this->_Mysize < _Off)
; 1802 : 			_Xran();	// _Off off end
; 1803 : 		if (this->_Mysize - _Off < _Count)
; 1804 : 			_Count = this->_Mysize - _Off;
; 1805 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1806 : 		return (_Count);
; 1807 : 		}
; 1808 : 
; 1809 : 	void _Swap_bx(_Myt& _Right)
; 1810 : 		{	// exchange _Bx with _Right._Bx
; 1811 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1812 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1813 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1814 : 			else
; 1815 : 				{	// swap large with small
; 1816 : 				pointer _Ptr = this->_Bx._Ptr;
; 1817 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1818 : 				_Traits::copy(this->_Bx._Buf,
; 1819 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1820 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1821 : 				}
; 1822 : 		else
; 1823 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1824 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1825 : 			else
; 1826 : 				{	// swap small with large
; 1827 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1828 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1829 : 				_Traits::copy(_Right._Bx._Buf,
; 1830 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1831 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1832 : 				}
; 1833 : 		}
; 1834 : 
; 1835 : 	void swap(_Myt& _Right)
; 1836 : 		{	// exchange contents with _Right
; 1837 : 		if (this == &_Right)
; 1838 : 			;	// same object, do nothing
; 1839 : 		else if (this->_Getal() == _Right._Getal())
; 1840 : 			{	// same allocator, swap control information
; 1841 : 			this->_Swap_all(_Right);
; 1842 : 			_Swap_bx(_Right);
; 1843 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1844 : 			_STD swap(this->_Myres, _Right._Myres);
; 1845 : 			}
; 1846 : 
; 1847 :  #if _HAS_CPP0X
; 1848 : 		else if (_Alty::propagate_on_container_swap::value)
; 1849 : 			{	// swap allocators and control information
; 1850 : 			this->_Swap_alloc(_Right);
; 1851 : 			_Swap_bx(_Right);
; 1852 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1853 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1854 : 			_STD swap(this->_Myres, _Right._Myres);
; 1855 : 			}
; 1856 :  #endif /* _HAS_CPP0X */
; 1857 : 
; 1858 : 		else
; 1859 : 			{	// different allocator, do multiple assigns
; 1860 : 			_Myt _Tmp = *this;
; 1861 : 
; 1862 : 			*this = _Right;
; 1863 : 			_Right = _Tmp;
; 1864 : 			}
; 1865 : 		}
; 1866 : 
; 1867 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1868 : 		{	// look for _Right beginning at or after _Off
; 1869 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1870 : 		}
; 1871 : 
; 1872 : 	size_type find(const _Elem *_Ptr,
; 1873 : 		size_type _Off, size_type _Count) const
; 1874 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1875 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1876 : 		if (_Count != 0)
; 1877 : 			_DEBUG_POINTER(_Ptr);
; 1878 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1879 : 
; 1880 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1881 : 			return (_Off);	// null string always matches (if inside string)
; 1882 : 
; 1883 : 		size_type _Nm;
; 1884 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1885 : 			{	// room for match, look for it
; 1886 : 			const _Elem *_Uptr, *_Vptr;
; 1887 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1888 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1889 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1890 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1891 : 					return (_Uptr - this->_Myptr());	// found a match
; 1892 : 			}
; 1893 : 
; 1894 : 		return (npos);	// no match
; 1895 : 		}
; 1896 : 
; 1897 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1898 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1899 : 		_DEBUG_POINTER(_Ptr);
; 1900 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1901 : 		}
; 1902 : 
; 1903 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1904 : 		{	// look for _Ch at or after _Off
; 1905 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1906 : 		}
; 1907 : 
; 1908 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1909 : 		{	// look for _Right beginning before _Off
; 1910 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1911 : 		}
; 1912 : 
; 1913 : 	size_type rfind(const _Elem *_Ptr,
; 1914 : 		size_type _Off, size_type _Count) const
; 1915 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1916 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1917 : 		if (_Count != 0)
; 1918 : 			_DEBUG_POINTER(_Ptr);
; 1919 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1920 : 
; 1921 : 		if (_Count == 0)
; 1922 : 			return (_Off < this->_Mysize ? _Off
; 1923 : 				: this->_Mysize);	// null always matches
; 1924 : 		if (_Count <= this->_Mysize)
; 1925 : 			{	// room for match, look for it
; 1926 : 			const _Elem *_Uptr = this->_Myptr() +
; 1927 : 				(_Off < this->_Mysize - _Count ? _Off
; 1928 : 					: this->_Mysize - _Count);
; 1929 : 			for (; ; --_Uptr)
; 1930 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1931 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1932 : 					return (_Uptr - this->_Myptr());	// found a match
; 1933 : 				else if (_Uptr == this->_Myptr())
; 1934 : 					break;	// at beginning, no more chance for match
; 1935 : 			}
; 1936 : 
; 1937 : 		return (npos);	// no match
; 1938 : 		}
; 1939 : 
; 1940 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1941 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1942 : 		_DEBUG_POINTER(_Ptr);
; 1943 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1944 : 		}
; 1945 : 
; 1946 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1947 : 		{	// look for _Ch before _Off
; 1948 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1949 : 		}
; 1950 : 
; 1951 : 	size_type find_first_of(const _Myt& _Right,
; 1952 : 		size_type _Off = 0) const _NOEXCEPT
; 1953 : 		{	// look for one of _Right at or after _Off
; 1954 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1955 : 		}
; 1956 : 
; 1957 : 	size_type find_first_of(const _Elem *_Ptr,
; 1958 : 		size_type _Off, size_type _Count) const
; 1959 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1960 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1961 : 		if (_Count != 0)
; 1962 : 			_DEBUG_POINTER(_Ptr);
; 1963 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1964 : 
; 1965 : 		if (0 < _Count && _Off < this->_Mysize)
; 1966 : 			{	// room for match, look for it
; 1967 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1968 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1969 : 				_Uptr < _Vptr; ++_Uptr)
; 1970 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1971 : 					return (_Uptr - this->_Myptr());	// found a match
; 1972 : 			}
; 1973 : 
; 1974 : 		return (npos);	// no match
; 1975 : 		}
; 1976 : 
; 1977 : 	size_type find_first_of(const _Elem *_Ptr,
; 1978 : 		size_type _Off = 0) const
; 1979 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1980 : 		_DEBUG_POINTER(_Ptr);
; 1981 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 1982 : 		}
; 1983 : 
; 1984 : 	size_type find_first_of(_Elem _Ch,
; 1985 : 		size_type _Off = 0) const
; 1986 : 		{	// look for _Ch at or after _Off
; 1987 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1988 : 		}
; 1989 : 
; 1990 : 	size_type find_last_of(const _Myt& _Right,
; 1991 : 		size_type _Off = npos) const _NOEXCEPT
; 1992 : 		{	// look for one of _Right before _Off
; 1993 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_last_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off, size_type _Count) const
; 1998 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 1999 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2000 : 		if (_Count != 0)
; 2001 : 			_DEBUG_POINTER(_Ptr);
; 2002 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2003 : 
; 2004 : 		if (0 < _Count && 0 < this->_Mysize)
; 2005 : 			{	// worth searching, do it
; 2006 : 			const _Elem *_Uptr = this->_Myptr()
; 2007 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2008 : 			for (; ; --_Uptr)
; 2009 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2010 : 					return (_Uptr - this->_Myptr());	// found a match
; 2011 : 				else if (_Uptr == this->_Myptr())
; 2012 : 					break;	// at beginning, no more chance for match
; 2013 : 			}
; 2014 : 
; 2015 : 		return (npos);	// no match
; 2016 : 		}
; 2017 : 
; 2018 : 	size_type find_last_of(const _Elem *_Ptr,
; 2019 : 		size_type _Off = npos) const
; 2020 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2021 : 		_DEBUG_POINTER(_Ptr);
; 2022 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2023 : 		}
; 2024 : 
; 2025 : 	size_type find_last_of(_Elem _Ch,
; 2026 : 		size_type _Off = npos) const
; 2027 : 		{	// look for _Ch before _Off
; 2028 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2029 : 		}
; 2030 : 
; 2031 : 	size_type find_first_not_of(const _Myt& _Right,
; 2032 : 		size_type _Off = 0) const _NOEXCEPT
; 2033 : 		{	// look for none of _Right at or after _Off
; 2034 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2035 : 			_Right.size()));
; 2036 : 		}
; 2037 : 
; 2038 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2039 : 		size_type _Off, size_type _Count) const
; 2040 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2041 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2042 : 		if (_Count != 0)
; 2043 : 			_DEBUG_POINTER(_Ptr);
; 2044 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2045 : 
; 2046 : 		if (_Off < this->_Mysize)
; 2047 : 			{	// room for match, look for it
; 2048 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2049 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2050 : 				_Uptr < _Vptr; ++_Uptr)
; 2051 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2052 : 					return (_Uptr - this->_Myptr());
; 2053 : 			}
; 2054 : 		return (npos);
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off = 0) const
; 2059 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2060 : 		_DEBUG_POINTER(_Ptr);
; 2061 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2062 : 		}
; 2063 : 
; 2064 : 	size_type find_first_not_of(_Elem _Ch,
; 2065 : 		size_type _Off = 0) const
; 2066 : 		{	// look for non _Ch at or after _Off
; 2067 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2068 : 		}
; 2069 : 
; 2070 : 	size_type find_last_not_of(const _Myt& _Right,
; 2071 : 		size_type _Off = npos) const _NOEXCEPT
; 2072 : 		{	// look for none of _Right before _Off
; 2073 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off, size_type _Count) const
; 2078 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2079 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2080 : 		if (_Count != 0)
; 2081 : 			_DEBUG_POINTER(_Ptr);
; 2082 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2083 : 
; 2084 : 		if (0 < this->_Mysize)
; 2085 : 			{	// worth searching, do it
; 2086 : 			const _Elem *_Uptr = this->_Myptr()
; 2087 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2088 : 			for (; ; --_Uptr)
; 2089 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2090 : 					return (_Uptr - this->_Myptr());
; 2091 : 				else if (_Uptr == this->_Myptr())
; 2092 : 					break;
; 2093 : 			}
; 2094 : 		return (npos);
; 2095 : 		}
; 2096 : 
; 2097 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2098 : 		size_type _Off = npos) const
; 2099 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2100 : 		_DEBUG_POINTER(_Ptr);
; 2101 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2102 : 		}
; 2103 : 
; 2104 : 	size_type find_last_not_of(_Elem _Ch,
; 2105 : 		size_type _Off = npos) const
; 2106 : 		{	// look for non _Ch before _Off
; 2107 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2108 : 		}
; 2109 : 
; 2110 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2111 : 		{	// return [_Off, _Off + _Count) as new string
; 2112 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2113 : 		}
; 2114 : 
; 2115 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2116 : 		{	// compare [0, _Mysize) with _Right
; 2117 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2118 : 		}
; 2119 : 
; 2120 : 	int compare(size_type _Off, size_type _N0,
; 2121 : 		const _Myt& _Right) const
; 2122 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2123 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2124 : 		}
; 2125 : 
; 2126 : 	int compare(size_type _Off,
; 2127 : 		size_type _N0, const _Myt& _Right,
; 2128 : 		size_type _Roff, size_type _Count) const
; 2129 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2130 : 		if (_Right.size() < _Roff)
; 2131 : 			_Xran();	// _Off off end
; 2132 : 		if (_Right._Mysize - _Roff < _Count)
; 2133 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2134 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2135 : 		}
; 2136 : 
; 2137 : 	int compare(const _Elem *_Ptr) const
; 2138 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2139 : 		_DEBUG_POINTER(_Ptr);
; 2140 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2141 : 		}
; 2142 : 
; 2143 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2144 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2145 : 		_DEBUG_POINTER(_Ptr);
; 2146 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2147 : 		}
; 2148 : 
; 2149 : 	int compare(size_type _Off,
; 2150 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2151 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2152 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2153 : 		if (_Count != 0)
; 2154 : 			_DEBUG_POINTER(_Ptr);
; 2155 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2156 : 
; 2157 : 		if (this->_Mysize < _Off)
; 2158 : 			_Xran();	// _Off off end
; 2159 : 		if (this->_Mysize - _Off < _N0)
; 2160 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2161 : 
; 2162 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2163 : 			_N0 < _Count ? _N0 : _Count);
; 2164 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2165 : 			: _N0 == _Count ? 0 : +1);
; 2166 : 		}
; 2167 : 
; 2168 : 	allocator_type get_allocator() const _NOEXCEPT
; 2169 : 		{	// return allocator object for values
; 2170 : 		return (this->_Getal());
; 2171 : 		}
; 2172 : 
; 2173 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2174 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2175 : 		if (_Count == 1)
; 2176 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2177 : 		else
; 2178 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2179 : 		}
; 2180 : 
; 2181 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2182 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2183 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2184 : 		if (max_size() < _Newres)
; 2185 : 			_Newres = _Newsize;	// undo roundup if too big
; 2186 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2187 : 			;
; 2188 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2189 : 			_Newres = this->_Myres
; 2190 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2191 : 		else
; 2192 : 			_Newres = max_size();	// settle for max_size()
; 2193 : 
; 2194 : 		_Elem *_Ptr;
; 2195 : 		_TRY_BEGIN
; 2196 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2197 : 		_CATCH_ALL
; 2198 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2199 : 			_TRY_BEGIN
; 2200 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2201 : 			_CATCH_ALL
; 2202 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2203 : 			_RERAISE;
; 2204 : 			_CATCH_END
; 2205 : 		_CATCH_END
; 2206 : 
; 2207 : 		if (0 < _Oldlen)
; 2208 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2209 : 				_Oldlen);	// copy existing elements
; 2210 : 		_Tidy(true);
; 2211 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2212 : 		this->_Myres = _Newres;
; 2213 : 		_Eos(_Oldlen);
; 2214 : 		}
; 2215 : 
; 2216 : 	void _Eos(size_type _Newsize)
; 2217 : 		{	// set new length and null terminator
; 2218 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  007cb	c7 46 28 00 00
	00 00		 mov	 DWORD PTR [esi+40], 0
  007d2	56		 push	 esi
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd

; 347  : 		_Left = _Right;

  007d3	66 89 46 18	 mov	 WORD PTR [esi+24], ax
  007d7	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  007dc	83 c4 04	 add	 esp, 4
$LN649@WinMain:
; File c:\users\glenn\documents\github\wind\project\wind\wind\gamestates.cpp

; 42   : 	delete GameStates::renderingState;

  007df	a1 00 00 00 00	 mov	 eax, DWORD PTR ?renderingState@GameStates@@3PAVGameState@1@A ; GameStates::renderingState
  007e4	85 c0		 test	 eax, eax
  007e6	74 09		 je	 SHORT $LN702@WinMain
  007e8	50		 push	 eax
  007e9	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  007ee	83 c4 04	 add	 esp, 4
$LN702@WinMain:

; 43   : 	delete GameStates::processedState;

  007f1	a1 00 00 00 00	 mov	 eax, DWORD PTR ?processedState@GameStates@@3PAVGameState@1@A ; GameStates::processedState
  007f6	85 c0		 test	 eax, eax
  007f8	74 09		 je	 SHORT $LN707@WinMain
  007fa	50		 push	 eax
  007fb	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00800	83 c4 04	 add	 esp, 4
$LN707@WinMain:

; 44   : 	delete GameStates::pendingState;

  00803	a1 00 00 00 00	 mov	 eax, DWORD PTR ?pendingState@GameStates@@3PAVGameState@1@A ; GameStates::pendingState
  00808	85 c0		 test	 eax, eax
  0080a	74 09		 je	 SHORT $LN712@WinMain
  0080c	50		 push	 eax
  0080d	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00812	83 c4 04	 add	 esp, 4
$LN712@WinMain:
; File c:\users\glenn\documents\github\wind\project\wind\wind\main.cpp

; 277  : 	return msg.wParam;

  00815	8b 44 24 6c	 mov	 eax, DWORD PTR _msg$[esp+136]

; 278  : }

  00819	5f		 pop	 edi
  0081a	5e		 pop	 esi
  0081b	5b		 pop	 ebx
  0081c	8b e5		 mov	 esp, ebp
  0081e	5d		 pop	 ebp
  0081f	c2 10 00	 ret	 16			; 00000010H
$LN760@WinMain:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 29   : 		_Xbad_alloc();	// report no memory

  00822	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN761@WinMain:
$LN729@WinMain:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thread

; 112  : 			_XSTD terminate();

  00827	e8 00 00 00 00	 call	 ?terminate@@YAXXZ	; terminate
$LN762@WinMain:
$LN759@WinMain:
  0082c	cc		 int	 3
_WinMain@16 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\window.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
;	COMDAT ??_GGLWindow@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$dead$ = 8					; size = 4
??_GGLWindow@@QAEPAXI@Z PROC				; GLWindow::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
; File c:\users\glenn\documents\github\wind\project\wind\wind\window.cpp

; 27   : 	destroyWindow();

  00003	e8 00 00 00 00	 call	 ?destroyWindow@GLWindow@@QAEXXZ ; GLWindow::destroyWindow
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 2256 : 		else if (this->_BUF_SIZE <= this->_Myres)

  00008	83 7e 2c 08	 cmp	 DWORD PTR [esi+44], 8
  0000c	72 0b		 jb	 SHORT $LN28@scalar
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 586  : 		::operator delete(_Ptr);

  0000e	ff 76 18	 push	 DWORD PTR [esi+24]
  00011	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00016	83 c4 04	 add	 esp, 4
$LN28@scalar:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd

; 347  : 		_Left = _Right;

  00019	33 c0		 xor	 eax, eax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 2265 : 		this->_Myres = this->_BUF_SIZE - 1;

  0001b	c7 46 2c 07 00
	00 00		 mov	 DWORD PTR [esi+44], 7

; 2218 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  00022	c7 46 28 00 00
	00 00		 mov	 DWORD PTR [esi+40], 0
  00029	56		 push	 esi
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd

; 347  : 		_Left = _Right;

  0002a	66 89 46 18	 mov	 WORD PTR [esi+24], ax
  0002e	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00033	83 c4 04	 add	 esp, 4
  00036	8b c6		 mov	 eax, esi
  00038	5e		 pop	 esi
  00039	c2 04 00	 ret	 4
??_GGLWindow@@QAEPAXI@Z ENDP				; GLWindow::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\list.h
;	COMDAT ?clear@?$List@VKeyboardAction@@$0BA@@@QAEXXZ
_TEXT	SEGMENT
?clear@?$List@VKeyboardAction@@$0BA@@@QAEXXZ PROC	; List<KeyboardAction,16>::clear, COMDAT
; _this$dead$ = ecx

; 37   : 		count = 0;

  00000	c7 05 80 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?actions@Keyboard@@2V?$List@VKeyboardAction@@$0BA@@@A+128, 0

; 38   : 	}

  0000a	c3		 ret	 0
?clear@?$List@VKeyboardAction@@$0BA@@@QAEXXZ ENDP	; List<KeyboardAction,16>::clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\list.h
;	COMDAT ??A?$List@VMouseAction@@$0BA@@@QAEAAVMouseAction@@H@Z
_TEXT	SEGMENT
_index$ = 8						; size = 4
??A?$List@VMouseAction@@$0BA@@@QAEAAVMouseAction@@H@Z PROC ; List<MouseAction,16>::operator[], COMDAT
; _this$dead$ = ecx

; 18   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 19   : 		return content[index];

  00003	8b 45 08	 mov	 eax, DWORD PTR _index$[ebp]
  00006	8d 04 80	 lea	 eax, DWORD PTR [eax+eax*4]
  00009	8d 04 85 00 00
	00 00		 lea	 eax, DWORD PTR ?actions@Mouse@@2V?$List@VMouseAction@@$0BA@@@A[eax*4]

; 20   : 	}

  00010	5d		 pop	 ebp
  00011	c2 04 00	 ret	 4
??A?$List@VMouseAction@@$0BA@@@QAEAAVMouseAction@@H@Z ENDP ; List<MouseAction,16>::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\list.h
;	COMDAT ?getSize@?$List@VMouseAction@@$0BA@@@QAEHXZ
_TEXT	SEGMENT
?getSize@?$List@VMouseAction@@$0BA@@@QAEHXZ PROC	; List<MouseAction,16>::getSize, COMDAT
; _this$dead$ = ecx

; 32   : 		return count;

  00000	a1 40 01 00 00	 mov	 eax, DWORD PTR ?actions@Mouse@@2V?$List@VMouseAction@@$0BA@@@A+320

; 33   : 	}

  00005	c3		 ret	 0
?getSize@?$List@VMouseAction@@$0BA@@@QAEHXZ ENDP	; List<MouseAction,16>::getSize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\list.h
;	COMDAT ?clear@?$List@VMouseAction@@$0BA@@@QAEXXZ
_TEXT	SEGMENT
?clear@?$List@VMouseAction@@$0BA@@@QAEXXZ PROC		; List<MouseAction,16>::clear, COMDAT
; _this$dead$ = ecx

; 37   : 		count = 0;

  00000	c7 05 40 01 00
	00 00 00 00 00	 mov	 DWORD PTR ?actions@Mouse@@2V?$List@VMouseAction@@$0BA@@@A+320, 0

; 38   : 	}

  0000a	c3		 ret	 0
?clear@?$List@VMouseAction@@$0BA@@@QAEXXZ ENDP		; List<MouseAction,16>::clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ??4?$shared_ptr@VChunkBase@@@std@@QAEAAV01@$$QAV01@@Z
_TEXT	SEGMENT
$T1 = -12						; size = 8
__Right$ = 8						; size = 4
??4?$shared_ptr@VChunkBase@@@std@@QAEAAV01@$$QAV01@@Z PROC ; std::shared_ptr<ChunkBase>::operator=, COMDAT
; _this$ = ecx

; 609  : 		{	// construct shared_ptr object that takes resource from _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 288  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 289  : 		}
; 290  : 
; 291  : 	template<class _Ty2>
; 292  : 		_Ptr_base(_Ptr_base<_Ty2>&& _Right)
; 293  : 		: _Ptr(_Right._Ptr), _Rep(_Right._Rep)
; 294  : 		{	// construct _Ptr_base object that takes resource from _Right
; 295  : 		_Right._Ptr = 0;
; 296  : 		_Right._Rep = 0;
; 297  : 		}
; 298  : 
; 299  : 	_Myt& operator=(_Myt&& _Right)
; 300  : 		{	// construct _Ptr_base object that takes resource from _Right
; 301  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 302  : 		return (*this);
; 303  : 		}
; 304  : 
; 305  : 	void _Assign_rv(_Myt&& _Right)
; 306  : 		{	// assign by moving _Right
; 307  : 		if (this != &_Right)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]

; 609  : 		{	// construct shared_ptr object that takes resource from _Right

  00006	83 ec 10	 sub	 esp, 16			; 00000010H

; 129  : 		}
; 130  : 
; 131  : 	long _Use_count() const
; 132  : 		{	// return use count
; 133  : 		return (_Get_uses());
; 134  : 		}
; 135  : 
; 136  : 	bool _Expired() const
; 137  : 		{	// return true if _Uses == 0
; 138  : 		return (_Get_uses() == 0);
; 139  : 		}
; 140  : 
; 141  : 	virtual void *_Get_deleter(const _XSTD2 type_info&) const
; 142  : 		{	// return address of deleter object
; 143  : 		return (0);
; 144  : 		}
; 145  : 	};
; 146  : 
; 147  : 	// TEMPLATE CLASS _Ref_count
; 148  : template<class _Ty>
; 149  : 	class _Ref_count
; 150  : 	: public _Ref_count_base
; 151  : 	{	// handle reference counting for object without deleter
; 152  : public:
; 153  : 	_Ref_count(_Ty *_Px)
; 154  : 		: _Ref_count_base(), _Ptr(_Px)
; 155  : 		{	// construct
; 156  : 		}
; 157  : 
; 158  : private:
; 159  : 	virtual void _Destroy()
; 160  : 		{	// destroy managed resource
; 161  : 		delete _Ptr;
; 162  : 		}
; 163  : 
; 164  : 	virtual void _Delete_this()
; 165  : 		{	// destroy self
; 166  : 		delete this;
; 167  : 		}
; 168  : 
; 169  : 	_Ty * _Ptr;
; 170  : 	};
; 171  : 
; 172  : 	// TEMPLATE CLASS _Ref_count_del
; 173  : template<class _Ty,
; 174  : 	class _Dx>
; 175  : 	class _Ref_count_del
; 176  : 	: public _Ref_count_base
; 177  : 	{	// handle reference counting for object with deleter
; 178  : public:
; 179  : 	_Ref_count_del(_Ty *_Px, _Dx _Dt)
; 180  : 		: _Ref_count_base(), _Ptr(_Px), _Dtor(_Dt)
; 181  : 		{	// construct
; 182  : 		}
; 183  : 
; 184  : 	virtual void *_Get_deleter(const _XSTD2 type_info& _Typeid) const
; 185  : 		{	// return address of deleter object
; 186  : 		return ((void *)(_Typeid == typeid(_Dx) ? &_Dtor : 0));
; 187  : 		}
; 188  : 
; 189  : private:
; 190  : 	virtual void _Destroy()
; 191  : 		{	// destroy managed resource
; 192  : 		_Dtor(_Ptr);
; 193  : 		}
; 194  : 
; 195  : 	virtual void _Delete_this()
; 196  : 		{	// destroy self
; 197  : 		delete this;
; 198  : 		}
; 199  : 
; 200  : 	_Ty * _Ptr;
; 201  : 	_Dx _Dtor;	// the stored destructor for the controlled object
; 202  : 	};
; 203  : 
; 204  : 	// TEMPLATE CLASS _Ref_count_del_alloc
; 205  : template<class _Ty,
; 206  : 	class _Dx,
; 207  : 	class _Alloc>
; 208  : 	class _Ref_count_del_alloc
; 209  : 	: public _Ref_count_base
; 210  : 	{	// handle reference counting for object with deleter and allocator
; 211  : public:
; 212  : 	typedef _Ref_count_del_alloc<_Ty, _Dx, _Alloc> _Myty;
; 213  : 	typedef typename _Alloc::template rebind<_Myty>::other _Myalty;
; 214  : 
; 215  : 	_Ref_count_del_alloc(_Ty *_Px, _Dx _Dt, _Myalty _Al)
; 216  : 		: _Ref_count_base(), _Ptr(_Px), _Dtor(_Dt), _Myal(_Al)
; 217  : 		{	// construct
; 218  : 		}
; 219  : 
; 220  : 	virtual void *_Get_deleter(const _XSTD2 type_info& _Typeid) const
; 221  : 		{	// return address of deleter object
; 222  : 		return ((void *)(_Typeid == typeid(_Dx) ? &_Dtor : 0));
; 223  : 		}
; 224  : 
; 225  : private:
; 226  : 	virtual void _Destroy()
; 227  : 		{	// destroy managed resource
; 228  : 		_Dtor(_Ptr);
; 229  : 		}
; 230  : 
; 231  : 	virtual void _Delete_this()
; 232  : 		{	// destroy self
; 233  : 		_Myalty _Al = _Myal;
; 234  : 		_Al.destroy(this);
; 235  : 		_Al.deallocate(this, 1);
; 236  : 		}
; 237  : 
; 238  : 	_Ty * _Ptr;
; 239  : 	_Dx _Dtor;	// the stored destructor for the controlled object
; 240  : 	_Myalty _Myal;	// the stored allocator for this
; 241  : 	};
; 242  : 
; 243  : 	// DECLARATIONS
; 244  : template<class _Ty>
; 245  : 	class weak_ptr;
; 246  : template<class _Ty>
; 247  : 	class shared_ptr;
; 248  : template<class _Ty>
; 249  : 	class enable_shared_from_this;
; 250  : struct _Static_tag {};
; 251  : struct _Const_tag {};
; 252  : struct _Dynamic_tag {};
; 253  : template<class _Ty1,
; 254  : 	class _Ty2>
; 255  : 	void _Do_enable(_Ty1 *, enable_shared_from_this<_Ty2> *,
; 256  : 		_Ref_count_base *);
; 257  : 
; 258  : template<class _Ty>
; 259  : 	inline void _Enable_shared(_Ty *_Ptr, _Ref_count_base *_Refptr,
; 260  : 		typename _Ty::_EStype * = 0)
; 261  : 	{	// reset internal weak pointer
; 262  : 	if (_Ptr)
; 263  : 		_Do_enable(_Ptr,
; 264  : 			(enable_shared_from_this<typename _Ty::_EStype>*)_Ptr, _Refptr);
; 265  : 	}
; 266  : 
; 267  : inline void _Enable_shared(const volatile void *, const volatile void *)
; 268  : 	{	// not derived from enable_shared_from_this; do nothing
; 269  : 	}
; 270  : 
; 271  : 	// TEMPLATE CLASS _Ptr_base
; 272  : template<class _Ty>
; 273  : 	class _Ptr_base
; 274  : 	{	// base class for shared_ptr and weak_ptr
; 275  : public:
; 276  : 	typedef _Ptr_base<_Ty> _Myt;
; 277  : 	typedef _Ty _Elem;
; 278  : 	typedef _Elem element_type;
; 279  : 
; 280  : 	_Ptr_base()
; 281  : 		: _Ptr(0), _Rep(0)
; 282  : 		{	// construct
; 283  : 		}
; 284  : 
; 285  : 	_Ptr_base(_Myt&& _Right)
; 286  : 		: _Ptr(0), _Rep(0)
; 287  : 		{	// construct _Ptr_base object that takes resource from _Right

  00009	33 d2		 xor	 edx, edx

; 609  : 		{	// construct shared_ptr object that takes resource from _Right

  0000b	53		 push	 ebx
  0000c	56		 push	 esi
  0000d	57		 push	 edi
  0000e	8b f1		 mov	 esi, ecx

; 288  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 289  : 		}
; 290  : 
; 291  : 	template<class _Ty2>
; 292  : 		_Ptr_base(_Ptr_base<_Ty2>&& _Right)
; 293  : 		: _Ptr(_Right._Ptr), _Rep(_Right._Rep)
; 294  : 		{	// construct _Ptr_base object that takes resource from _Right
; 295  : 		_Right._Ptr = 0;
; 296  : 		_Right._Rep = 0;
; 297  : 		}
; 298  : 
; 299  : 	_Myt& operator=(_Myt&& _Right)
; 300  : 		{	// construct _Ptr_base object that takes resource from _Right
; 301  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 302  : 		return (*this);
; 303  : 		}
; 304  : 
; 305  : 	void _Assign_rv(_Myt&& _Right)
; 306  : 		{	// assign by moving _Right
; 307  : 		if (this != &_Right)

  00010	8d 7d f4	 lea	 edi, DWORD PTR $T1[ebp]

; 129  : 		}
; 130  : 
; 131  : 	long _Use_count() const
; 132  : 		{	// return use count
; 133  : 		return (_Get_uses());
; 134  : 		}
; 135  : 
; 136  : 	bool _Expired() const
; 137  : 		{	// return true if _Uses == 0
; 138  : 		return (_Get_uses() == 0);
; 139  : 		}
; 140  : 
; 141  : 	virtual void *_Get_deleter(const _XSTD2 type_info&) const
; 142  : 		{	// return address of deleter object
; 143  : 		return (0);
; 144  : 		}
; 145  : 	};
; 146  : 
; 147  : 	// TEMPLATE CLASS _Ref_count
; 148  : template<class _Ty>
; 149  : 	class _Ref_count
; 150  : 	: public _Ref_count_base
; 151  : 	{	// handle reference counting for object without deleter
; 152  : public:
; 153  : 	_Ref_count(_Ty *_Px)
; 154  : 		: _Ref_count_base(), _Ptr(_Px)
; 155  : 		{	// construct
; 156  : 		}
; 157  : 
; 158  : private:
; 159  : 	virtual void _Destroy()
; 160  : 		{	// destroy managed resource
; 161  : 		delete _Ptr;
; 162  : 		}
; 163  : 
; 164  : 	virtual void _Delete_this()
; 165  : 		{	// destroy self
; 166  : 		delete this;
; 167  : 		}
; 168  : 
; 169  : 	_Ty * _Ptr;
; 170  : 	};
; 171  : 
; 172  : 	// TEMPLATE CLASS _Ref_count_del
; 173  : template<class _Ty,
; 174  : 	class _Dx>
; 175  : 	class _Ref_count_del
; 176  : 	: public _Ref_count_base
; 177  : 	{	// handle reference counting for object with deleter
; 178  : public:
; 179  : 	_Ref_count_del(_Ty *_Px, _Dx _Dt)
; 180  : 		: _Ref_count_base(), _Ptr(_Px), _Dtor(_Dt)
; 181  : 		{	// construct
; 182  : 		}
; 183  : 
; 184  : 	virtual void *_Get_deleter(const _XSTD2 type_info& _Typeid) const
; 185  : 		{	// return address of deleter object
; 186  : 		return ((void *)(_Typeid == typeid(_Dx) ? &_Dtor : 0));
; 187  : 		}
; 188  : 
; 189  : private:
; 190  : 	virtual void _Destroy()
; 191  : 		{	// destroy managed resource
; 192  : 		_Dtor(_Ptr);
; 193  : 		}
; 194  : 
; 195  : 	virtual void _Delete_this()
; 196  : 		{	// destroy self
; 197  : 		delete this;
; 198  : 		}
; 199  : 
; 200  : 	_Ty * _Ptr;
; 201  : 	_Dx _Dtor;	// the stored destructor for the controlled object
; 202  : 	};
; 203  : 
; 204  : 	// TEMPLATE CLASS _Ref_count_del_alloc
; 205  : template<class _Ty,
; 206  : 	class _Dx,
; 207  : 	class _Alloc>
; 208  : 	class _Ref_count_del_alloc
; 209  : 	: public _Ref_count_base
; 210  : 	{	// handle reference counting for object with deleter and allocator
; 211  : public:
; 212  : 	typedef _Ref_count_del_alloc<_Ty, _Dx, _Alloc> _Myty;
; 213  : 	typedef typename _Alloc::template rebind<_Myty>::other _Myalty;
; 214  : 
; 215  : 	_Ref_count_del_alloc(_Ty *_Px, _Dx _Dt, _Myalty _Al)
; 216  : 		: _Ref_count_base(), _Ptr(_Px), _Dtor(_Dt), _Myal(_Al)
; 217  : 		{	// construct
; 218  : 		}
; 219  : 
; 220  : 	virtual void *_Get_deleter(const _XSTD2 type_info& _Typeid) const
; 221  : 		{	// return address of deleter object
; 222  : 		return ((void *)(_Typeid == typeid(_Dx) ? &_Dtor : 0));
; 223  : 		}
; 224  : 
; 225  : private:
; 226  : 	virtual void _Destroy()
; 227  : 		{	// destroy managed resource
; 228  : 		_Dtor(_Ptr);
; 229  : 		}
; 230  : 
; 231  : 	virtual void _Delete_this()
; 232  : 		{	// destroy self
; 233  : 		_Myalty _Al = _Myal;
; 234  : 		_Al.destroy(this);
; 235  : 		_Al.deallocate(this, 1);
; 236  : 		}
; 237  : 
; 238  : 	_Ty * _Ptr;
; 239  : 	_Dx _Dtor;	// the stored destructor for the controlled object
; 240  : 	_Myalty _Myal;	// the stored allocator for this
; 241  : 	};
; 242  : 
; 243  : 	// DECLARATIONS
; 244  : template<class _Ty>
; 245  : 	class weak_ptr;
; 246  : template<class _Ty>
; 247  : 	class shared_ptr;
; 248  : template<class _Ty>
; 249  : 	class enable_shared_from_this;
; 250  : struct _Static_tag {};
; 251  : struct _Const_tag {};
; 252  : struct _Dynamic_tag {};
; 253  : template<class _Ty1,
; 254  : 	class _Ty2>
; 255  : 	void _Do_enable(_Ty1 *, enable_shared_from_this<_Ty2> *,
; 256  : 		_Ref_count_base *);
; 257  : 
; 258  : template<class _Ty>
; 259  : 	inline void _Enable_shared(_Ty *_Ptr, _Ref_count_base *_Refptr,
; 260  : 		typename _Ty::_EStype * = 0)
; 261  : 	{	// reset internal weak pointer
; 262  : 	if (_Ptr)
; 263  : 		_Do_enable(_Ptr,
; 264  : 			(enable_shared_from_this<typename _Ty::_EStype>*)_Ptr, _Refptr);
; 265  : 	}
; 266  : 
; 267  : inline void _Enable_shared(const volatile void *, const volatile void *)
; 268  : 	{	// not derived from enable_shared_from_this; do nothing
; 269  : 	}
; 270  : 
; 271  : 	// TEMPLATE CLASS _Ptr_base
; 272  : template<class _Ty>
; 273  : 	class _Ptr_base
; 274  : 	{	// base class for shared_ptr and weak_ptr
; 275  : public:
; 276  : 	typedef _Ptr_base<_Ty> _Myt;
; 277  : 	typedef _Ty _Elem;
; 278  : 	typedef _Elem element_type;
; 279  : 
; 280  : 	_Ptr_base()
; 281  : 		: _Ptr(0), _Rep(0)
; 282  : 		{	// construct
; 283  : 		}
; 284  : 
; 285  : 	_Ptr_base(_Myt&& _Right)
; 286  : 		: _Ptr(0), _Rep(0)
; 287  : 		{	// construct _Ptr_base object that takes resource from _Right

  00013	33 c9		 xor	 ecx, ecx

; 288  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 289  : 		}
; 290  : 
; 291  : 	template<class _Ty2>
; 292  : 		_Ptr_base(_Ptr_base<_Ty2>&& _Right)
; 293  : 		: _Ptr(_Right._Ptr), _Rep(_Right._Rep)
; 294  : 		{	// construct _Ptr_base object that takes resource from _Right
; 295  : 		_Right._Ptr = 0;
; 296  : 		_Right._Rep = 0;
; 297  : 		}
; 298  : 
; 299  : 	_Myt& operator=(_Myt&& _Right)
; 300  : 		{	// construct _Ptr_base object that takes resource from _Right
; 301  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 302  : 		return (*this);
; 303  : 		}
; 304  : 
; 305  : 	void _Assign_rv(_Myt&& _Right)
; 306  : 		{	// assign by moving _Right
; 307  : 		if (this != &_Right)

  00015	3b f8		 cmp	 edi, eax
  00017	74 0e		 je	 SHORT $LN26@operator
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility

; 48   : 	_Left = _Move(_Right);

  00019	8b 50 04	 mov	 edx, DWORD PTR [eax+4]

; 49   : 	_Right = _Move(_Tmp);

  0001c	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 48   : 	_Left = _Move(_Right);

  0001f	8b 08		 mov	 ecx, DWORD PTR [eax]

; 49   : 	_Right = _Move(_Tmp);

  00021	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
$LN26@operator:

; 48   : 	_Left = _Move(_Right);

  00027	8b 7e 04	 mov	 edi, DWORD PTR [esi+4]

; 49   : 	_Right = _Move(_Tmp);

  0002a	89 56 04	 mov	 DWORD PTR [esi+4], edx
  0002d	89 0e		 mov	 DWORD PTR [esi], ecx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  0002f	85 ff		 test	 edi, edi
  00031	74 25		 je	 SHORT $LN67@operator

; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  00033	83 cb ff	 or	 ebx, -1
  00036	8d 4f 04	 lea	 ecx, DWORD PTR [edi+4]
  00039	8b c3		 mov	 eax, ebx
  0003b	f0 0f c1 01	 lock	  xadd	 DWORD PTR [ecx], eax
  0003f	75 17		 jne	 SHORT $LN67@operator

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  00041	8b 07		 mov	 eax, DWORD PTR [edi]
  00043	8b cf		 mov	 ecx, edi
  00045	ff 10		 call	 DWORD PTR [eax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  00047	8d 47 08	 lea	 eax, DWORD PTR [edi+8]
  0004a	f0 0f c1 18	 lock	  xadd	 DWORD PTR [eax], ebx
  0004e	4b		 dec	 ebx
  0004f	75 07		 jne	 SHORT $LN67@operator

; 128  : 			_Delete_this();

  00051	8b 07		 mov	 eax, DWORD PTR [edi]
  00053	8b cf		 mov	 ecx, edi
  00055	ff 50 04	 call	 DWORD PTR [eax+4]
$LN67@operator:

; 610  : 		shared_ptr(_STD move(_Right)).swap(*this);
; 611  : 		return (*this);
; 612  : 		}

  00058	5f		 pop	 edi
  00059	8b c6		 mov	 eax, esi
  0005b	5e		 pop	 esi
  0005c	5b		 pop	 ebx
  0005d	8b e5		 mov	 esp, ebp
  0005f	5d		 pop	 ebp
  00060	c2 04 00	 ret	 4
??4?$shared_ptr@VChunkBase@@@std@@QAEAAV01@$$QAV01@@Z ENDP ; std::shared_ptr<ChunkBase>::operator=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ??$?0VChunk@@@?$shared_ptr@VChunkBase@@@std@@QAE@PAVChunk@@@Z
_TEXT	SEGMENT
__Px$ = 8						; size = 4
??$?0VChunk@@@?$shared_ptr@VChunkBase@@@std@@QAE@PAVChunk@@@Z PROC ; std::shared_ptr<ChunkBase>::shared_ptr<ChunkBase><Chunk>, COMDAT
; _this$ = ecx

; 485  : 		explicit shared_ptr(_Ux *_Px)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 486  : 		{	// construct shared_ptr object that owns _Px
; 487  : 		_Resetp(_Px);

  00004	ff 75 08	 push	 DWORD PTR __Px$[ebp]
  00007	8b f1		 mov	 esi, ecx

; 282  : 		{	// construct

  00009	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  0000f	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 486  : 		{	// construct shared_ptr object that owns _Px
; 487  : 		_Resetp(_Px);

  00016	e8 00 00 00 00	 call	 ??$_Resetp@VChunk@@@?$shared_ptr@VChunkBase@@@std@@AAEXPAVChunk@@@Z ; std::shared_ptr<ChunkBase>::_Resetp<Chunk>

; 488  : 		}

  0001b	8b c6		 mov	 eax, esi
  0001d	5e		 pop	 esi
  0001e	5d		 pop	 ebp
  0001f	c2 04 00	 ret	 4
??$?0VChunk@@@?$shared_ptr@VChunkBase@@@std@@QAE@PAVChunk@@@Z ENDP ; std::shared_ptr<ChunkBase>::shared_ptr<ChunkBase><Chunk>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\type_traits
;	COMDAT ??$move@AAV?$shared_ptr@VChunkBase@@@std@@@std@@YA$$QAV?$shared_ptr@VChunkBase@@@0@AAV10@@Z
_TEXT	SEGMENT
??$move@AAV?$shared_ptr@VChunkBase@@@std@@@std@@YA$$QAV?$shared_ptr@VChunkBase@@@0@AAV10@@Z PROC ; std::move<std::shared_ptr<ChunkBase> &>, COMDAT
; __Arg$ = ecx

; 1791 : 	return ((typename remove_reference<_Ty>::type&&)_Arg);

  00000	8b c1		 mov	 eax, ecx

; 1792 : 	}

  00002	c3		 ret	 0
??$move@AAV?$shared_ptr@VChunkBase@@@std@@@std@@YA$$QAV?$shared_ptr@VChunkBase@@@0@AAV10@@Z ENDP ; std::move<std::shared_ptr<ChunkBase> &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xatomic0.h
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ??$_Resetp@VChunk@@@?$shared_ptr@VChunkBase@@@std@@AAEXPAVChunk@@@Z
_TEXT	SEGMENT
_this$1$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Px$ = 8						; size = 4
??$_Resetp@VChunk@@@?$shared_ptr@VChunkBase@@@std@@AAEXPAVChunk@@@Z PROC ; std::shared_ptr<ChunkBase>::_Resetp<Chunk>, COMDAT
; _this$ = ecx

; 708  : 		void _Resetp(_Ux *_Px)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Resetp@VChunk@@@?$shared_ptr@VChunkBase@@@std@@AAEXPAVChunk@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002b	8b f9		 mov	 edi, ecx
  0002d	89 7d ec	 mov	 DWORD PTR _this$1$[ebp], edi

; 709  : 		{	// release, take ownership of _Px
; 710  : 		_TRY_BEGIN	// allocate control block and reset
; 711  : 		_Resetp0(_Px, new _Ref_count<_Ux>(_Px));

  00030	6a 10		 push	 16			; 00000010H
  00032	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  00039	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new

; 155  : 		{	// construct

  0003e	8b 5d 08	 mov	 ebx, DWORD PTR __Px$[ebp]

; 709  : 		{	// release, take ownership of _Px
; 710  : 		_TRY_BEGIN	// allocate control block and reset
; 711  : 		_Resetp0(_Px, new _Ref_count<_Ux>(_Px));

  00041	8b f0		 mov	 esi, eax
  00043	83 c4 04	 add	 esp, 4
  00046	85 f6		 test	 esi, esi
  00048	74 19		 je	 SHORT $LN4@Resetp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xatomic0.h

; 219  : 	_Counter = _Value;

  0004a	c7 46 04 01 00
	00 00		 mov	 DWORD PTR [esi+4], 1
  00051	c7 46 08 01 00
	00 00		 mov	 DWORD PTR [esi+8], 1
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 155  : 		{	// construct

  00058	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$_Ref_count@VChunk@@@std@@6B@
  0005e	89 5e 0c	 mov	 DWORD PTR [esi+12], ebx

; 709  : 		{	// release, take ownership of _Px
; 710  : 		_TRY_BEGIN	// allocate control block and reset
; 711  : 		_Resetp0(_Px, new _Ref_count<_Ux>(_Px));

  00061	eb 02		 jmp	 SHORT $LN5@Resetp
$LN4@Resetp:
  00063	33 f6		 xor	 esi, esi
$LN5@Resetp:

; 156  : 		}
; 157  : 
; 158  : private:
; 159  : 	virtual void _Destroy()
; 160  : 		{	// destroy managed resource
; 161  : 		delete _Ptr;
; 162  : 		}
; 163  : 
; 164  : 	virtual void _Delete_this()
; 165  : 		{	// destroy self
; 166  : 		delete this;
; 167  : 		}
; 168  : 
; 169  : 	_Ty * _Ptr;
; 170  : 	};
; 171  : 
; 172  : 	// TEMPLATE CLASS _Ref_count_del
; 173  : template<class _Ty,
; 174  : 	class _Dx>
; 175  : 	class _Ref_count_del
; 176  : 	: public _Ref_count_base
; 177  : 	{	// handle reference counting for object with deleter
; 178  : public:
; 179  : 	_Ref_count_del(_Ty *_Px, _Dx _Dt)
; 180  : 		: _Ref_count_base(), _Ptr(_Px), _Dtor(_Dt)
; 181  : 		{	// construct
; 182  : 		}
; 183  : 
; 184  : 	virtual void *_Get_deleter(const _XSTD2 type_info& _Typeid) const
; 185  : 		{	// return address of deleter object
; 186  : 		return ((void *)(_Typeid == typeid(_Dx) ? &_Dtor : 0));
; 187  : 		}
; 188  : 
; 189  : private:
; 190  : 	virtual void _Destroy()
; 191  : 		{	// destroy managed resource
; 192  : 		_Dtor(_Ptr);
; 193  : 		}
; 194  : 
; 195  : 	virtual void _Delete_this()
; 196  : 		{	// destroy self
; 197  : 		delete this;
; 198  : 		}
; 199  : 
; 200  : 	_Ty * _Ptr;
; 201  : 	_Dx _Dtor;	// the stored destructor for the controlled object
; 202  : 	};
; 203  : 
; 204  : 	// TEMPLATE CLASS _Ref_count_del_alloc
; 205  : template<class _Ty,
; 206  : 	class _Dx,
; 207  : 	class _Alloc>
; 208  : 	class _Ref_count_del_alloc
; 209  : 	: public _Ref_count_base
; 210  : 	{	// handle reference counting for object with deleter and allocator
; 211  : public:
; 212  : 	typedef _Ref_count_del_alloc<_Ty, _Dx, _Alloc> _Myty;
; 213  : 	typedef typename _Alloc::template rebind<_Myty>::other _Myalty;
; 214  : 
; 215  : 	_Ref_count_del_alloc(_Ty *_Px, _Dx _Dt, _Myalty _Al)
; 216  : 		: _Ref_count_base(), _Ptr(_Px), _Dtor(_Dt), _Myal(_Al)
; 217  : 		{	// construct
; 218  : 		}
; 219  : 
; 220  : 	virtual void *_Get_deleter(const _XSTD2 type_info& _Typeid) const
; 221  : 		{	// return address of deleter object
; 222  : 		return ((void *)(_Typeid == typeid(_Dx) ? &_Dtor : 0));
; 223  : 		}
; 224  : 
; 225  : private:
; 226  : 	virtual void _Destroy()
; 227  : 		{	// destroy managed resource
; 228  : 		_Dtor(_Ptr);
; 229  : 		}
; 230  : 
; 231  : 	virtual void _Delete_this()
; 232  : 		{	// destroy self
; 233  : 		_Myalty _Al = _Myal;
; 234  : 		_Al.destroy(this);
; 235  : 		_Al.deallocate(this, 1);
; 236  : 		}
; 237  : 
; 238  : 	_Ty * _Ptr;
; 239  : 	_Dx _Dtor;	// the stored destructor for the controlled object
; 240  : 	_Myalty _Myal;	// the stored allocator for this
; 241  : 	};
; 242  : 
; 243  : 	// DECLARATIONS
; 244  : template<class _Ty>
; 245  : 	class weak_ptr;
; 246  : template<class _Ty>
; 247  : 	class shared_ptr;
; 248  : template<class _Ty>
; 249  : 	class enable_shared_from_this;
; 250  : struct _Static_tag {};
; 251  : struct _Const_tag {};
; 252  : struct _Dynamic_tag {};
; 253  : template<class _Ty1,
; 254  : 	class _Ty2>
; 255  : 	void _Do_enable(_Ty1 *, enable_shared_from_this<_Ty2> *,
; 256  : 		_Ref_count_base *);
; 257  : 
; 258  : template<class _Ty>
; 259  : 	inline void _Enable_shared(_Ty *_Ptr, _Ref_count_base *_Refptr,
; 260  : 		typename _Ty::_EStype * = 0)
; 261  : 	{	// reset internal weak pointer
; 262  : 	if (_Ptr)
; 263  : 		_Do_enable(_Ptr,
; 264  : 			(enable_shared_from_this<typename _Ty::_EStype>*)_Ptr, _Refptr);
; 265  : 	}
; 266  : 
; 267  : inline void _Enable_shared(const volatile void *, const volatile void *)
; 268  : 	{	// not derived from enable_shared_from_this; do nothing
; 269  : 	}
; 270  : 
; 271  : 	// TEMPLATE CLASS _Ptr_base
; 272  : template<class _Ty>
; 273  : 	class _Ptr_base
; 274  : 	{	// base class for shared_ptr and weak_ptr
; 275  : public:
; 276  : 	typedef _Ptr_base<_Ty> _Myt;
; 277  : 	typedef _Ty _Elem;
; 278  : 	typedef _Elem element_type;
; 279  : 
; 280  : 	_Ptr_base()
; 281  : 		: _Ptr(0), _Rep(0)
; 282  : 		{	// construct
; 283  : 		}
; 284  : 
; 285  : 	_Ptr_base(_Myt&& _Right)
; 286  : 		: _Ptr(0), _Rep(0)
; 287  : 		{	// construct _Ptr_base object that takes resource from _Right
; 288  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 289  : 		}
; 290  : 
; 291  : 	template<class _Ty2>
; 292  : 		_Ptr_base(_Ptr_base<_Ty2>&& _Right)
; 293  : 		: _Ptr(_Right._Ptr), _Rep(_Right._Rep)
; 294  : 		{	// construct _Ptr_base object that takes resource from _Right
; 295  : 		_Right._Ptr = 0;
; 296  : 		_Right._Rep = 0;
; 297  : 		}
; 298  : 
; 299  : 	_Myt& operator=(_Myt&& _Right)
; 300  : 		{	// construct _Ptr_base object that takes resource from _Right
; 301  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 302  : 		return (*this);
; 303  : 		}
; 304  : 
; 305  : 	void _Assign_rv(_Myt&& _Right)
; 306  : 		{	// assign by moving _Right
; 307  : 		if (this != &_Right)
; 308  : 			_Swap(_Right);
; 309  : 		}
; 310  : 
; 311  : 	long use_count() const _NOEXCEPT
; 312  : 		{	// return use count
; 313  : 		return (_Rep ? _Rep->_Use_count() : 0);
; 314  : 		}
; 315  : 
; 316  : 	void _Swap(_Ptr_base& _Right)
; 317  : 		{	// swap pointers
; 318  : 		_STD swap(_Rep, _Right._Rep);
; 319  : 		_STD swap(_Ptr, _Right._Ptr);
; 320  : 		}
; 321  : 
; 322  : 	template<class _Ty2>
; 323  : 		bool owner_before(const _Ptr_base<_Ty2>& _Right) const
; 324  : 		{	// compare addresses of manager objects
; 325  : 		return (_Rep < _Right._Rep);
; 326  : 		}
; 327  : 
; 328  : 	void *_Get_deleter(const _XSTD2 type_info& _Typeid) const
; 329  : 		{	// return pointer to deleter object if its type is _Typeid
; 330  : 		return (_Rep ? _Rep->_Get_deleter(_Typeid) : 0);
; 331  : 		}
; 332  : 
; 333  : 	_Ty *_Get() const
; 334  : 		{	// return pointer to resource
; 335  : 		return (_Ptr);
; 336  : 		}
; 337  : 
; 338  : 	bool _Expired() const
; 339  : 		{	// test if expired
; 340  : 		return (!_Rep || _Rep->_Expired());
; 341  : 		}
; 342  : 
; 343  : 	void _Decref()
; 344  : 		{	// decrement reference count
; 345  : 		if (_Rep != 0)
; 346  : 			_Rep->_Decref();
; 347  : 		}
; 348  : 
; 349  : 	void _Reset()
; 350  : 		{	// release resource
; 351  : 		_Reset(0, 0);
; 352  : 		}
; 353  : 
; 354  : 	template<class _Ty2>
; 355  : 		void _Reset(const _Ptr_base<_Ty2>& _Other)
; 356  : 		{	// release resource and take ownership of _Other._Ptr
; 357  : 		_Reset(_Other._Ptr, _Other._Rep);
; 358  : 		}
; 359  : 
; 360  : 	template<class _Ty2>
; 361  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, bool _Throw)
; 362  : 		{	// release resource and take ownership from weak_ptr _Other._Ptr
; 363  : 		_Reset(_Other._Ptr, _Other._Rep, _Throw);
; 364  : 		}
; 365  : 
; 366  : 	template<class _Ty2>
; 367  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Static_tag&)
; 368  : 		{	// release resource and take ownership of _Other._Ptr
; 369  : 		_Reset(static_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 370  : 		}
; 371  : 
; 372  : 	template<class _Ty2>
; 373  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Const_tag&)
; 374  : 		{	// release resource and take ownership of _Other._Ptr
; 375  : 		_Reset(const_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 376  : 		}
; 377  : 
; 378  : 	template<class _Ty2>
; 379  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Dynamic_tag&)
; 380  : 		{	// release resource and take ownership of _Other._Ptr
; 381  : 		_Elem *_Ptr = dynamic_cast<_Elem *>(_Other._Ptr);
; 382  : 		if (_Ptr)
; 383  : 			_Reset(_Ptr, _Other._Rep);
; 384  : 		else
; 385  : 			_Reset();
; 386  : 		}
; 387  : 
; 388  : 	template<class _Ty2>
; 389  : 		void _Reset(auto_ptr<_Ty2>&& _Other)
; 390  : 		{	// release resource and take _Other.get()
; 391  : 		_Ty2 *_Px = _Other.get();
; 392  : 		_Reset0(_Px, new _Ref_count<_Elem>(_Px));
; 393  : 		_Other.release();
; 394  : 		_Enable_shared(_Px, _Rep);
; 395  : 		}
; 396  : 
; 397  :  #if _HAS_CPP0X
; 398  : 	template<class _Ty2>
; 399  : 		void _Reset(_Ty *_Ptr, const _Ptr_base<_Ty2>& _Other)
; 400  : 		{	// release resource and alias _Ptr with _Other_rep
; 401  : 		_Reset(_Ptr, _Other._Rep);
; 402  : 		}
; 403  :  #endif /* _HAS_CPP0X */
; 404  : 
; 405  : 	void _Reset(_Ty *_Other_ptr, _Ref_count_base *_Other_rep)
; 406  : 		{	// release resource and take _Other_ptr through _Other_rep
; 407  : 		if (_Other_rep)
; 408  : 			_Other_rep->_Incref();
; 409  : 		_Reset0(_Other_ptr, _Other_rep);
; 410  : 		}
; 411  : 
; 412  : 	void _Reset(_Ty *_Other_ptr, _Ref_count_base *_Other_rep, bool _Throw)
; 413  : 		{	// take _Other_ptr through _Other_rep from weak_ptr if not expired
; 414  : 			// otherwise, leave in default state if !_Throw,
; 415  : 			// otherwise throw exception
; 416  : 		if (_Other_rep && _Other_rep->_Incref_nz())
; 417  : 			_Reset0(_Other_ptr, _Other_rep);
; 418  : 		else if (_Throw)
; 419  : 			_THROW_NCEE(bad_weak_ptr, 0);
; 420  : 		}
; 421  : 
; 422  : 	void _Reset0(_Ty *_Other_ptr, _Ref_count_base *_Other_rep)
; 423  : 		{	// release resource and take new resource
; 424  : 		if (_Rep != 0)

  00065	8b 7f 04	 mov	 edi, DWORD PTR [edi+4]
  00068	85 ff		 test	 edi, edi
  0006a	74 25		 je	 SHORT $LN29@Resetp

; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  0006c	8d 4f 04	 lea	 ecx, DWORD PTR [edi+4]
  0006f	83 c8 ff	 or	 eax, -1
  00072	f0 0f c1 01	 lock	  xadd	 DWORD PTR [ecx], eax
  00076	75 19		 jne	 SHORT $LN29@Resetp

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  00078	8b 07		 mov	 eax, DWORD PTR [edi]
  0007a	8b cf		 mov	 ecx, edi
  0007c	ff 10		 call	 DWORD PTR [eax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  0007e	8d 47 08	 lea	 eax, DWORD PTR [edi+8]
  00081	83 c9 ff	 or	 ecx, -1
  00084	f0 0f c1 08	 lock	  xadd	 DWORD PTR [eax], ecx
  00088	75 07		 jne	 SHORT $LN29@Resetp

; 128  : 			_Delete_this();

  0008a	8b 07		 mov	 eax, DWORD PTR [edi]
  0008c	8b cf		 mov	 ecx, edi
  0008e	ff 50 04	 call	 DWORD PTR [eax+4]
$LN29@Resetp:

; 425  : 			_Rep->_Decref();
; 426  : 		_Rep = _Other_rep;

  00091	8b 45 ec	 mov	 eax, DWORD PTR _this$1$[ebp]
  00094	89 70 04	 mov	 DWORD PTR [eax+4], esi

; 427  : 		_Ptr = _Other_ptr;

  00097	89 18		 mov	 DWORD PTR [eax], ebx

; 715  : 		_CATCH_END
; 716  : 		}

  00099	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  0009c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000a3	59		 pop	 ecx
  000a4	5f		 pop	 edi
  000a5	5e		 pop	 esi
  000a6	5b		 pop	 ebx
  000a7	8b e5		 mov	 esp, ebp
  000a9	5d		 pop	 ebp
  000aa	c2 04 00	 ret	 4
__catch$??$_Resetp@VChunk@@@?$shared_ptr@VChunkBase@@@std@@AAEXPAVChunk@@@Z$0:

; 712  : 		_CATCH_ALL	// allocation failed, delete resource
; 713  : 		delete _Px;

  000ad	8b 4d 08	 mov	 ecx, DWORD PTR __Px$[ebp]
  000b0	85 c9		 test	 ecx, ecx
  000b2	74 06		 je	 SHORT $LN6@Resetp
  000b4	51		 push	 ecx
  000b5	e8 00 00 00 00	 call	 ??_GChunk@@QAEPAXI@Z
$LN6@Resetp:

; 714  : 		_RERAISE;

  000ba	6a 00		 push	 0
  000bc	6a 00		 push	 0
  000be	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN36@Resetp:
$LN35@Resetp:
  000c3	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Resetp@VChunk@@@?$shared_ptr@VChunkBase@@@std@@AAEXPAVChunk@@@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Resetp@VChunk@@@?$shared_ptr@VChunkBase@@@std@@AAEXPAVChunk@@@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Resetp@VChunk@@@?$shared_ptr@VChunkBase@@@std@@AAEXPAVChunk@@@Z ENDP ; std::shared_ptr<ChunkBase>::_Resetp<Chunk>
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\mutex
;	COMDAT ??_GChunk@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$dead$ = 8					; size = 4
??_GChunk@@QAEPAXI@Z PROC				; Chunk::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	57		 push	 edi
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp

; 54   : {

  00004	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7ChunkBase@@6B@
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  0000a	8b 7e 24	 mov	 edi, DWORD PTR [esi+36]
  0000d	85 ff		 test	 edi, edi
  0000f	74 27		 je	 SHORT $LN16@scalar
  00011	53		 push	 ebx

; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  00012	83 cb ff	 or	 ebx, -1
  00015	8d 57 04	 lea	 edx, DWORD PTR [edi+4]
  00018	8b c3		 mov	 eax, ebx
  0001a	f0 0f c1 02	 lock	  xadd	 DWORD PTR [edx], eax
  0001e	75 17		 jne	 SHORT $LN27@scalar

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  00020	8b 07		 mov	 eax, DWORD PTR [edi]
  00022	8b cf		 mov	 ecx, edi
  00024	ff 10		 call	 DWORD PTR [eax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  00026	8d 47 08	 lea	 eax, DWORD PTR [edi+8]
  00029	f0 0f c1 18	 lock	  xadd	 DWORD PTR [eax], ebx
  0002d	4b		 dec	 ebx
  0002e	75 07		 jne	 SHORT $LN27@scalar

; 128  : 			_Delete_this();

  00030	8b 07		 mov	 eax, DWORD PTR [edi]
  00032	8b cf		 mov	 ecx, edi
  00034	ff 50 04	 call	 DWORD PTR [eax+4]
$LN27@scalar:
  00037	5b		 pop	 ebx
$LN16@scalar:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\mutex

; 33   : 		_Mtx_destroy(&_Mtx);

  00038	8d 46 1c	 lea	 eax, DWORD PTR [esi+28]
  0003b	50		 push	 eax
  0003c	e8 00 00 00 00	 call	 __Mtx_destroy
  00041	8d 46 18	 lea	 eax, DWORD PTR [esi+24]
  00044	50		 push	 eax
  00045	e8 00 00 00 00	 call	 __Mtx_destroy
  0004a	56		 push	 esi
  0004b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00050	83 c4 0c	 add	 esp, 12			; 0000000cH
  00053	8b c6		 mov	 eax, esi
  00055	5f		 pop	 edi
  00056	5e		 pop	 esi
  00057	c2 04 00	 ret	 4
??_GChunk@@QAEPAXI@Z ENDP				; Chunk::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xatomic0.h
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ??0?$_Ref_count@VChunk@@@std@@QAE@PAVChunk@@@Z
_TEXT	SEGMENT
__Px$ = 8						; size = 4
??0?$_Ref_count@VChunk@@@std@@QAE@PAVChunk@@@Z PROC	; std::_Ref_count<Chunk>::_Ref_count<Chunk>, COMDAT
; _this$ = ecx

; 155  : 		{	// construct

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Px$[ebp]
  00006	89 41 0c	 mov	 DWORD PTR [ecx+12], eax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xatomic0.h

; 219  : 	_Counter = _Value;

  00009	c7 41 04 01 00
	00 00		 mov	 DWORD PTR [ecx+4], 1
  00010	c7 41 08 01 00
	00 00		 mov	 DWORD PTR [ecx+8], 1
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 155  : 		{	// construct

  00017	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7?$_Ref_count@VChunk@@@std@@6B@

; 156  : 		}

  0001d	8b c1		 mov	 eax, ecx
  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
??0?$_Ref_count@VChunk@@@std@@QAE@PAVChunk@@@Z ENDP	; std::_Ref_count<Chunk>::_Ref_count<Chunk>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ?_Destroy@?$_Ref_count@VChunk@@@std@@EAEXXZ
_TEXT	SEGMENT
?_Destroy@?$_Ref_count@VChunk@@@std@@EAEXXZ PROC	; std::_Ref_count<Chunk>::_Destroy, COMDAT
; _this$ = ecx

; 161  : 		delete _Ptr;

  00000	8b 49 0c	 mov	 ecx, DWORD PTR [ecx+12]
  00003	85 c9		 test	 ecx, ecx
  00005	74 06		 je	 SHORT $LN3@Destroy
  00007	51		 push	 ecx
  00008	e8 00 00 00 00	 call	 ??_GChunk@@QAEPAXI@Z
$LN3@Destroy:

; 162  : 		}

  0000d	c3		 ret	 0
?_Destroy@?$_Ref_count@VChunk@@@std@@EAEXXZ ENDP	; std::_Ref_count<Chunk>::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ?_Delete_this@?$_Ref_count@VChunk@@@std@@EAEXXZ
_TEXT	SEGMENT
?_Delete_this@?$_Ref_count@VChunk@@@std@@EAEXXZ PROC	; std::_Ref_count<Chunk>::_Delete_this, COMDAT
; _this$ = ecx

; 166  : 		delete this;

  00000	85 c9		 test	 ecx, ecx
  00002	74 07		 je	 SHORT $LN3@Delete_thi
  00004	8b 01		 mov	 eax, DWORD PTR [ecx]
  00006	6a 01		 push	 1
  00008	ff 50 08	 call	 DWORD PTR [eax+8]
$LN3@Delete_thi:

; 167  : 		}

  0000b	c3		 ret	 0
?_Delete_this@?$_Ref_count@VChunk@@@std@@EAEXXZ ENDP	; std::_Ref_count<Chunk>::_Delete_this
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ??_G?$_Ref_count@VChunk@@@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$_Ref_count@VChunk@@@std@@UAEPAXI@Z PROC		; std::_Ref_count<Chunk>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx

; 69   : 		{	// ensure that derived classes can be destroyed properly

  0000a	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7_Ref_count_base@std@@6B@
  00010	74 09		 je	 SHORT $LN8@scalar
  00012	56		 push	 esi
  00013	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00018	83 c4 04	 add	 esp, 4
$LN8@scalar:
  0001b	8b c6		 mov	 eax, esi
  0001d	5e		 pop	 esi
  0001e	5d		 pop	 ebp
  0001f	c2 04 00	 ret	 4
??_G?$_Ref_count@VChunk@@@std@@UAEPAXI@Z ENDP		; std::_Ref_count<Chunk>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ??1?$_Ref_count@VChunk@@@std@@UAE@XZ
_TEXT	SEGMENT
??1?$_Ref_count@VChunk@@@std@@UAE@XZ PROC		; std::_Ref_count<Chunk>::~_Ref_count<Chunk>, COMDAT
; _this$ = ecx

; 69   : 		{	// ensure that derived classes can be destroyed properly

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7_Ref_count_base@std@@6B@
  00006	c3		 ret	 0
??1?$_Ref_count@VChunk@@@std@@UAE@XZ ENDP		; std::_Ref_count<Chunk>::~_Ref_count<Chunk>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ??$_Resetp0@VChunk@@@?$shared_ptr@VChunkBase@@@std@@QAEXPAVChunk@@PAV_Ref_count_base@1@@Z
_TEXT	SEGMENT
__Px$ = 8						; size = 4
__Rx$ = 12						; size = 4
??$_Resetp0@VChunk@@@?$shared_ptr@VChunkBase@@@std@@QAEXPAVChunk@@PAV_Ref_count_base@1@@Z PROC ; std::shared_ptr<ChunkBase>::_Resetp0<Chunk>, COMDAT
; _this$ = ecx

; 752  : 		void _Resetp0(_Ux *_Px, _Ref_count_base *_Rx)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	57		 push	 edi

; 129  : 		}
; 130  : 
; 131  : 	long _Use_count() const
; 132  : 		{	// return use count
; 133  : 		return (_Get_uses());
; 134  : 		}
; 135  : 
; 136  : 	bool _Expired() const
; 137  : 		{	// return true if _Uses == 0
; 138  : 		return (_Get_uses() == 0);
; 139  : 		}
; 140  : 
; 141  : 	virtual void *_Get_deleter(const _XSTD2 type_info&) const
; 142  : 		{	// return address of deleter object
; 143  : 		return (0);
; 144  : 		}
; 145  : 	};
; 146  : 
; 147  : 	// TEMPLATE CLASS _Ref_count
; 148  : template<class _Ty>
; 149  : 	class _Ref_count
; 150  : 	: public _Ref_count_base
; 151  : 	{	// handle reference counting for object without deleter
; 152  : public:
; 153  : 	_Ref_count(_Ty *_Px)
; 154  : 		: _Ref_count_base(), _Ptr(_Px)
; 155  : 		{	// construct
; 156  : 		}
; 157  : 
; 158  : private:
; 159  : 	virtual void _Destroy()
; 160  : 		{	// destroy managed resource
; 161  : 		delete _Ptr;
; 162  : 		}
; 163  : 
; 164  : 	virtual void _Delete_this()
; 165  : 		{	// destroy self
; 166  : 		delete this;
; 167  : 		}
; 168  : 
; 169  : 	_Ty * _Ptr;
; 170  : 	};
; 171  : 
; 172  : 	// TEMPLATE CLASS _Ref_count_del
; 173  : template<class _Ty,
; 174  : 	class _Dx>
; 175  : 	class _Ref_count_del
; 176  : 	: public _Ref_count_base
; 177  : 	{	// handle reference counting for object with deleter
; 178  : public:
; 179  : 	_Ref_count_del(_Ty *_Px, _Dx _Dt)
; 180  : 		: _Ref_count_base(), _Ptr(_Px), _Dtor(_Dt)
; 181  : 		{	// construct
; 182  : 		}
; 183  : 
; 184  : 	virtual void *_Get_deleter(const _XSTD2 type_info& _Typeid) const
; 185  : 		{	// return address of deleter object
; 186  : 		return ((void *)(_Typeid == typeid(_Dx) ? &_Dtor : 0));
; 187  : 		}
; 188  : 
; 189  : private:
; 190  : 	virtual void _Destroy()
; 191  : 		{	// destroy managed resource
; 192  : 		_Dtor(_Ptr);
; 193  : 		}
; 194  : 
; 195  : 	virtual void _Delete_this()
; 196  : 		{	// destroy self
; 197  : 		delete this;
; 198  : 		}
; 199  : 
; 200  : 	_Ty * _Ptr;
; 201  : 	_Dx _Dtor;	// the stored destructor for the controlled object
; 202  : 	};
; 203  : 
; 204  : 	// TEMPLATE CLASS _Ref_count_del_alloc
; 205  : template<class _Ty,
; 206  : 	class _Dx,
; 207  : 	class _Alloc>
; 208  : 	class _Ref_count_del_alloc
; 209  : 	: public _Ref_count_base
; 210  : 	{	// handle reference counting for object with deleter and allocator
; 211  : public:
; 212  : 	typedef _Ref_count_del_alloc<_Ty, _Dx, _Alloc> _Myty;
; 213  : 	typedef typename _Alloc::template rebind<_Myty>::other _Myalty;
; 214  : 
; 215  : 	_Ref_count_del_alloc(_Ty *_Px, _Dx _Dt, _Myalty _Al)
; 216  : 		: _Ref_count_base(), _Ptr(_Px), _Dtor(_Dt), _Myal(_Al)
; 217  : 		{	// construct
; 218  : 		}
; 219  : 
; 220  : 	virtual void *_Get_deleter(const _XSTD2 type_info& _Typeid) const
; 221  : 		{	// return address of deleter object
; 222  : 		return ((void *)(_Typeid == typeid(_Dx) ? &_Dtor : 0));
; 223  : 		}
; 224  : 
; 225  : private:
; 226  : 	virtual void _Destroy()
; 227  : 		{	// destroy managed resource
; 228  : 		_Dtor(_Ptr);
; 229  : 		}
; 230  : 
; 231  : 	virtual void _Delete_this()
; 232  : 		{	// destroy self
; 233  : 		_Myalty _Al = _Myal;
; 234  : 		_Al.destroy(this);
; 235  : 		_Al.deallocate(this, 1);
; 236  : 		}
; 237  : 
; 238  : 	_Ty * _Ptr;
; 239  : 	_Dx _Dtor;	// the stored destructor for the controlled object
; 240  : 	_Myalty _Myal;	// the stored allocator for this
; 241  : 	};
; 242  : 
; 243  : 	// DECLARATIONS
; 244  : template<class _Ty>
; 245  : 	class weak_ptr;
; 246  : template<class _Ty>
; 247  : 	class shared_ptr;
; 248  : template<class _Ty>
; 249  : 	class enable_shared_from_this;
; 250  : struct _Static_tag {};
; 251  : struct _Const_tag {};
; 252  : struct _Dynamic_tag {};
; 253  : template<class _Ty1,
; 254  : 	class _Ty2>
; 255  : 	void _Do_enable(_Ty1 *, enable_shared_from_this<_Ty2> *,
; 256  : 		_Ref_count_base *);
; 257  : 
; 258  : template<class _Ty>
; 259  : 	inline void _Enable_shared(_Ty *_Ptr, _Ref_count_base *_Refptr,
; 260  : 		typename _Ty::_EStype * = 0)
; 261  : 	{	// reset internal weak pointer
; 262  : 	if (_Ptr)
; 263  : 		_Do_enable(_Ptr,
; 264  : 			(enable_shared_from_this<typename _Ty::_EStype>*)_Ptr, _Refptr);
; 265  : 	}
; 266  : 
; 267  : inline void _Enable_shared(const volatile void *, const volatile void *)
; 268  : 	{	// not derived from enable_shared_from_this; do nothing
; 269  : 	}
; 270  : 
; 271  : 	// TEMPLATE CLASS _Ptr_base
; 272  : template<class _Ty>
; 273  : 	class _Ptr_base
; 274  : 	{	// base class for shared_ptr and weak_ptr
; 275  : public:
; 276  : 	typedef _Ptr_base<_Ty> _Myt;
; 277  : 	typedef _Ty _Elem;
; 278  : 	typedef _Elem element_type;
; 279  : 
; 280  : 	_Ptr_base()
; 281  : 		: _Ptr(0), _Rep(0)
; 282  : 		{	// construct
; 283  : 		}
; 284  : 
; 285  : 	_Ptr_base(_Myt&& _Right)
; 286  : 		: _Ptr(0), _Rep(0)
; 287  : 		{	// construct _Ptr_base object that takes resource from _Right
; 288  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 289  : 		}
; 290  : 
; 291  : 	template<class _Ty2>
; 292  : 		_Ptr_base(_Ptr_base<_Ty2>&& _Right)
; 293  : 		: _Ptr(_Right._Ptr), _Rep(_Right._Rep)
; 294  : 		{	// construct _Ptr_base object that takes resource from _Right
; 295  : 		_Right._Ptr = 0;
; 296  : 		_Right._Rep = 0;
; 297  : 		}
; 298  : 
; 299  : 	_Myt& operator=(_Myt&& _Right)
; 300  : 		{	// construct _Ptr_base object that takes resource from _Right
; 301  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 302  : 		return (*this);
; 303  : 		}
; 304  : 
; 305  : 	void _Assign_rv(_Myt&& _Right)
; 306  : 		{	// assign by moving _Right
; 307  : 		if (this != &_Right)
; 308  : 			_Swap(_Right);
; 309  : 		}
; 310  : 
; 311  : 	long use_count() const _NOEXCEPT
; 312  : 		{	// return use count
; 313  : 		return (_Rep ? _Rep->_Use_count() : 0);
; 314  : 		}
; 315  : 
; 316  : 	void _Swap(_Ptr_base& _Right)
; 317  : 		{	// swap pointers
; 318  : 		_STD swap(_Rep, _Right._Rep);
; 319  : 		_STD swap(_Ptr, _Right._Ptr);
; 320  : 		}
; 321  : 
; 322  : 	template<class _Ty2>
; 323  : 		bool owner_before(const _Ptr_base<_Ty2>& _Right) const
; 324  : 		{	// compare addresses of manager objects
; 325  : 		return (_Rep < _Right._Rep);
; 326  : 		}
; 327  : 
; 328  : 	void *_Get_deleter(const _XSTD2 type_info& _Typeid) const
; 329  : 		{	// return pointer to deleter object if its type is _Typeid
; 330  : 		return (_Rep ? _Rep->_Get_deleter(_Typeid) : 0);
; 331  : 		}
; 332  : 
; 333  : 	_Ty *_Get() const
; 334  : 		{	// return pointer to resource
; 335  : 		return (_Ptr);
; 336  : 		}
; 337  : 
; 338  : 	bool _Expired() const
; 339  : 		{	// test if expired
; 340  : 		return (!_Rep || _Rep->_Expired());
; 341  : 		}
; 342  : 
; 343  : 	void _Decref()
; 344  : 		{	// decrement reference count
; 345  : 		if (_Rep != 0)
; 346  : 			_Rep->_Decref();
; 347  : 		}
; 348  : 
; 349  : 	void _Reset()
; 350  : 		{	// release resource
; 351  : 		_Reset(0, 0);
; 352  : 		}
; 353  : 
; 354  : 	template<class _Ty2>
; 355  : 		void _Reset(const _Ptr_base<_Ty2>& _Other)
; 356  : 		{	// release resource and take ownership of _Other._Ptr
; 357  : 		_Reset(_Other._Ptr, _Other._Rep);
; 358  : 		}
; 359  : 
; 360  : 	template<class _Ty2>
; 361  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, bool _Throw)
; 362  : 		{	// release resource and take ownership from weak_ptr _Other._Ptr
; 363  : 		_Reset(_Other._Ptr, _Other._Rep, _Throw);
; 364  : 		}
; 365  : 
; 366  : 	template<class _Ty2>
; 367  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Static_tag&)
; 368  : 		{	// release resource and take ownership of _Other._Ptr
; 369  : 		_Reset(static_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 370  : 		}
; 371  : 
; 372  : 	template<class _Ty2>
; 373  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Const_tag&)
; 374  : 		{	// release resource and take ownership of _Other._Ptr
; 375  : 		_Reset(const_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 376  : 		}
; 377  : 
; 378  : 	template<class _Ty2>
; 379  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Dynamic_tag&)
; 380  : 		{	// release resource and take ownership of _Other._Ptr
; 381  : 		_Elem *_Ptr = dynamic_cast<_Elem *>(_Other._Ptr);
; 382  : 		if (_Ptr)
; 383  : 			_Reset(_Ptr, _Other._Rep);
; 384  : 		else
; 385  : 			_Reset();
; 386  : 		}
; 387  : 
; 388  : 	template<class _Ty2>
; 389  : 		void _Reset(auto_ptr<_Ty2>&& _Other)
; 390  : 		{	// release resource and take _Other.get()
; 391  : 		_Ty2 *_Px = _Other.get();
; 392  : 		_Reset0(_Px, new _Ref_count<_Elem>(_Px));
; 393  : 		_Other.release();
; 394  : 		_Enable_shared(_Px, _Rep);
; 395  : 		}
; 396  : 
; 397  :  #if _HAS_CPP0X
; 398  : 	template<class _Ty2>
; 399  : 		void _Reset(_Ty *_Ptr, const _Ptr_base<_Ty2>& _Other)
; 400  : 		{	// release resource and alias _Ptr with _Other_rep
; 401  : 		_Reset(_Ptr, _Other._Rep);
; 402  : 		}
; 403  :  #endif /* _HAS_CPP0X */
; 404  : 
; 405  : 	void _Reset(_Ty *_Other_ptr, _Ref_count_base *_Other_rep)
; 406  : 		{	// release resource and take _Other_ptr through _Other_rep
; 407  : 		if (_Other_rep)
; 408  : 			_Other_rep->_Incref();
; 409  : 		_Reset0(_Other_ptr, _Other_rep);
; 410  : 		}
; 411  : 
; 412  : 	void _Reset(_Ty *_Other_ptr, _Ref_count_base *_Other_rep, bool _Throw)
; 413  : 		{	// take _Other_ptr through _Other_rep from weak_ptr if not expired
; 414  : 			// otherwise, leave in default state if !_Throw,
; 415  : 			// otherwise throw exception
; 416  : 		if (_Other_rep && _Other_rep->_Incref_nz())
; 417  : 			_Reset0(_Other_ptr, _Other_rep);
; 418  : 		else if (_Throw)
; 419  : 			_THROW_NCEE(bad_weak_ptr, 0);
; 420  : 		}
; 421  : 
; 422  : 	void _Reset0(_Ty *_Other_ptr, _Ref_count_base *_Other_rep)
; 423  : 		{	// release resource and take new resource
; 424  : 		if (_Rep != 0)

  00007	8b 7e 04	 mov	 edi, DWORD PTR [esi+4]
  0000a	85 ff		 test	 edi, edi
  0000c	74 38		 je	 SHORT $LN16@Resetp0
  0000e	53		 push	 ebx

; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  0000f	83 cb ff	 or	 ebx, -1
  00012	8d 57 04	 lea	 edx, DWORD PTR [edi+4]
  00015	8b c3		 mov	 eax, ebx
  00017	f0 0f c1 02	 lock	  xadd	 DWORD PTR [edx], eax
  0001b	75 17		 jne	 SHORT $LN15@Resetp0

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  0001d	8b 07		 mov	 eax, DWORD PTR [edi]
  0001f	8b cf		 mov	 ecx, edi
  00021	ff 10		 call	 DWORD PTR [eax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  00023	8d 47 08	 lea	 eax, DWORD PTR [edi+8]
  00026	f0 0f c1 18	 lock	  xadd	 DWORD PTR [eax], ebx
  0002a	4b		 dec	 ebx
  0002b	75 07		 jne	 SHORT $LN15@Resetp0

; 128  : 			_Delete_this();

  0002d	8b 07		 mov	 eax, DWORD PTR [edi]
  0002f	8b cf		 mov	 ecx, edi
  00031	ff 50 04	 call	 DWORD PTR [eax+4]
$LN15@Resetp0:

; 425  : 			_Rep->_Decref();
; 426  : 		_Rep = _Other_rep;

  00034	8b 45 0c	 mov	 eax, DWORD PTR __Rx$[ebp]
  00037	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 427  : 		_Ptr = _Other_ptr;

  0003a	8b 45 08	 mov	 eax, DWORD PTR __Px$[ebp]
  0003d	5b		 pop	 ebx
  0003e	5f		 pop	 edi
  0003f	89 06		 mov	 DWORD PTR [esi], eax
  00041	5e		 pop	 esi

; 753  : 		{	// release resource and take ownership of _Px
; 754  : 		this->_Reset0(_Px, _Rx);
; 755  : 		_Enable_shared(_Px, _Rx);
; 756  : 		}

  00042	5d		 pop	 ebp
  00043	c2 08 00	 ret	 8
$LN16@Resetp0:

; 425  : 			_Rep->_Decref();
; 426  : 		_Rep = _Other_rep;

  00046	8b 45 0c	 mov	 eax, DWORD PTR __Rx$[ebp]
  00049	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 427  : 		_Ptr = _Other_ptr;

  0004c	8b 45 08	 mov	 eax, DWORD PTR __Px$[ebp]
  0004f	5f		 pop	 edi
  00050	89 06		 mov	 DWORD PTR [esi], eax
  00052	5e		 pop	 esi

; 753  : 		{	// release resource and take ownership of _Px
; 754  : 		this->_Reset0(_Px, _Rx);
; 755  : 		_Enable_shared(_Px, _Rx);
; 756  : 		}

  00053	5d		 pop	 ebp
  00054	c2 08 00	 ret	 8
??$_Resetp0@VChunk@@@?$shared_ptr@VChunkBase@@@std@@QAEXPAVChunk@@PAV_Ref_count_base@1@@Z ENDP ; std::shared_ptr<ChunkBase>::_Resetp0<Chunk>
_TEXT	ENDS
END
